[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define it register int\n#define ct const int\n#define il inline\nusing namespace std;\ntypedef long long ll;\n#define rll register ll\n#define cll const ll\n#define P 998244353\nconst int N=1005;\nint a[N],pl[N],pr[N],K,n,mx,m,mk,p[N];\nbool tag[N];\nint main(){ \n\tscanf(\"%d\",&K);it i,j;\n\tfor(i=1;i<=K;++i) scanf(\"%d\",&a[i]),n+=a[i],mx=(a[i]>mx?a[i]:mx),pl[i]=K,pr[i]=i;\n\tfor(i=1;i<=K;++i) if((a[i]<<1)<mx) return puts(\"-1\"),0;\n\tfor(i=1;i<=n;++i){\n\t\tfor(j=1;j<=K;++j)\n\t\t\tif(!tag[j]){\n\t\t\t\tmx=0;it flag=1;\n\t\t\t\tfor(it k=1;k<=K;++k) mx=(a[k]>mx?a[k]:mx);\n\t\t\t\tfor(it k=1;k<=pl[j];++k) a[pr[k]]-=(!tag[pr[k]]);\n\t\t\t\tfor(it k=1;k<=K;++k) if((a[k]<<1)+2<mx){flag=0;break;}\n\t\t\t\tif((a[j]<<1|1)<mx) flag=0;\n\t\t\t\tfor(it k=1;k<=pl[j];++k) a[pr[k]]+=(!tag[pr[k]]);\n\t\t\t\tif(flag) break;\n\t\t\t}\n\t\ttag[j]=1,p[i]=j,--a[j],++m,mk=(mk>pl[j]?mk:pl[j]);\n\t\tif(i>=K&&(i==K||m==mk)){for(j=1;j<=K;++j) tag[j]=0,pl[p[i+j-K]]=j,pr[j]=p[i+j-K];m=mk=0;}\n\t} \n\tfor(i=1;i<=n;++i) printf(\"%d \",p[i]);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[233];\nvector<int> ans,tx,ty;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(1)\n\t{\n\t\tint minn=114514,maxx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tminn=min(minn,a[i]);\n\t\t\tmaxx=max(maxx,a[i]);\n\t\t}\n\t\tif(maxx==0)break;\n\t\telse if(minn==0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttx.clear();ty.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]!=minn)tx.push_back(i),a[i]-=2;\n\t\t\telse ty.push_back(i),a[i]--;\n\t\t}\n\t\tfor(auto x:tx)ans.push_back(x);\n\t\tfor(auto x:ty)ans.push_back(x);\n\t\tfor(auto x:tx)ans.push_back(x);\n\t}\n\tfor(auto x:ans)cout<<x<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nbool validarray(vector<int>& a) {\n\tint mi = mod, ma = 0;\n\trep(i, a.size()) {\n\t\tif (a[i] < 0)return false;\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\treturn ma <= mi * 2;\n}\n\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\tif (!validarray(a)) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tint sum = 0;\n\trep(i, k)sum += a[i];\n\n\tint las = 0;\n\tvector<int> ans;\n\trep(i, sum) {\n\t\tvector<bool> b(k);\n\t\tfor (int j = las; j < ans.size(); j++) {\n\t\t\tb[ans[j]] = true;\n\t\t}\n\t\tint chk = -1;\n\t\tvector<bool> b2(k);\n\t\trep(j, k) {\n\t\t\tbool valid = false;\n\t\t\tif (b[j])continue;\n\t\t\tb2 = b;\n\t\t\tb2[j] = true;\n\t\t\tfor (int ex = 0; ex <= k; ex++) {\n\t\t\t\tif (las - ex < 0)break;\n\t\t\t\tif (ex > 0) {\n\t\t\t\t\tif (b2[ans[las - ex]])break;\n\t\t\t\t\tb2[ans[las - ex]] = true;\n\t\t\t\t}\n\n\n\t\t\t\t//cout << \"?! \" << i << \" \" << j <<\" \"<<ex<< \"\\n\";\n\t\t\t\tvector<int> cop = a;\n\n\t\t\t\tcop[j]--;\n\t\t\t\trep(x, k) {\n\t\t\t\t\tif (!b2[x])\n\t\t\t\t\tcop[x]--;\n\t\t\t\t}\n\n\n\t\t\t\tint mi = mod;\n\t\t\t\trep(x, k)mi = min(mi, cop[x]);\n\t\t\t\tif (mi < 0)continue;\n\n\t\t\t\tint len = ans.size() - (las - ex);\n\t\t\t\tint fl = 0;\n\t\t\t\tbool e = false;\n\t\t\t\trep(x, k)if (!b2[x]) {\n\t\t\t\t\tif (cop[x] > 2 * mi) {\n\t\t\t\t\t\tfl = len;\n\t\t\t\t\t\tcop[x]--;\n\t\t\t\t\t\te = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e)cop[j]--;\n\t\t\t\telse {\n\t\t\t\t\tif (cop[j] > 2 * mi) {\n\t\t\t\t\t\tfl = len;\n\t\t\t\t\t\tcop[j]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//cout << \"hello\\n\";\n\t\t\t\t\t\trep1(t, len) {\n\t\t\t\t\t\t\tif (cop[ans[ans.size() - t]] > 2 * mi) {\n\t\t\t\t\t\t\t\tfl = len+1 - t; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(t, fl)cop[ans[las - ex + t]]--;\n\t\t\t\t//cout << i << \" \" << j << \" \" << ex << \" \" << fl << \"\\n\";\n\t\t\t\tif (validarray(cop)) {\n\t\t\t\t\tvalid = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tchk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << chk+1 << \" \"<<las<<\"\\n\";\n\t\tassert(chk >= 0);\n\t\tans.push_back(chk);\n\t\ta[chk]--;\n\t\tif (ans.size() >= k) {\n\t\t\tvector<int> cnt(k, 0);\n\t\t\trep(j, k) {\n\t\t\t\tcnt[ans[ans.size() - 1 - j]]++;\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tif (valid) {\n\t\t\t\tlas = ans.size();\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint main(){\n  cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\nint last[101];\nstring R;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tif(*max_element(A,A+K)>*min_element(A,A+K)*2) return _P(\"-1\\n\");\n\tMINUS(last);\n\twhile(R.size()<N) {\n\t\t/*\n\t\tcout<<\"!\"<<R.size()<<\" \";\n\t\tFOR(i,4) cout<<A[i]<<\" \";\n\t\tcout<<endl;\n\t\t*/\n\t\tstring tar;\n\t\ttar.push_back(120);\n\t\tfor(int len=1;len<=K;len++) {\n\t\t\tif(R.size()+len<K) continue;\n\t\t\tif(R.size()+len>N) continue;\n\t\t\t\n\t\t\tint B[101];\n\t\t\tint did[101]={};\n\t\t\tFOR(i,K) B[i]=A[i];\n\t\t\tFOR(i,K-len) did[R[R.size()-1-i]]=1;\n\t\t\tstring cand;\n\t\t\tFOR(i,K) if(did[i]==0) cand.push_back(i),B[i]--;\n\t\t\tx=*max_element(B,B+K);\n\t\t\ty=*min_element(B,B+K);\n\t\t\tif(y<0 || x>2*y+1) continue;\n\t\t\t\n\t\t\tif(x==2*y+1) {\n\t\t\t\tstring AA,BB,CC;\n\t\t\t\tFOR(i,K) if(did[i]==0) {\n\t\t\t\t\tif(B[i]==x) AA.push_back(i);\n\t\t\t\t\telse if(B[i]==y) BB.push_back(i);\n\t\t\t\t\telse CC.push_back(i);\n\t\t\t\t}\n\t\t\t\tint ok=1;\n\t\t\t\tFOR(i,K) if(did[i]==0 && B[i]==x) {\n\t\t\t\t\tFOR(j,K) if(did[i]&&B[j]==y) ok=0;\n\t\t\t\t}\n\t\t\t\tif(ok==0) continue;\n\t\t\t\tcand.clear();\n\t\t\t\twhile(AA.size()+BB.size()+CC.size()) {\n\t\t\t\t\tif(AA.size()) {\n\t\t\t\t\t\tif(CC.size()&&CC[0]<AA[0]) {\n\t\t\t\t\t\t\tcand+=CC[0];\n\t\t\t\t\t\t\tCC.erase(CC.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcand+=AA[0];\n\t\t\t\t\t\t\tAA.erase(AA.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(BB.size()) {\n\t\t\t\t\t\tif(CC.size()&&CC[0]<BB[0]) {\n\t\t\t\t\t\t\tcand+=CC[0];\n\t\t\t\t\t\t\tCC.erase(CC.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcand+=BB[0];\n\t\t\t\t\t\t\tBB.erase(BB.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcand+=CC[0];\n\t\t\t\t\t\tCC.erase(CC.begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\ttar=min(tar,cand);\n\t\t}\n\t\t\n\t\t//cout<<\"#\"<<tar.size()<<endl;\n\t\tR+=tar;\n\t\tFORR(a,tar) A[a]--;\n\t}\n\t\n\tFORR(c,R) cout<<((int)c+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint K;\nint A[111];\n\nbool valid() {\n    int ma = *max_element(A, A+K);\n    if (ma == 0) return true;\n    int mi = *min_element(A, A+K);\n    return mi * 2 >= ma;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &K);\n    REP (i, K) {\n\tint a;\n\tscanf(\"%d\", &a);\n\tA[i] = a;\n    }\n\n    if (!valid()) {\n\tputs(\"-1\");\n\treturn;\n    }\n\n    VI ans;\n    while (1) {\n\t// rprintf(\"%d\", A, A+K);\n\tif (*max_element(A, A+K) == 0) break;\n\n\tif (A[0] >= 2) {\n\t    REP (i, K) A[i]--;\n\t    A[0]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tans.push_back(0);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t\tA[0]++;\n\t    }\n\t}\n\n\t{\n\t    REP (i, K) A[i]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t    }\n\t}\n\t\t\n\tint ma = *max_element(A, A+K);\n\tVI once, twice;\n\tREP (i, K) {\n\t    if (A[i] == ma) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    }\n\t}\n\n\tassert(valid());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n\tans.insert(ans.end(), once.begin(), once.end());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n    }\n\n    EACH (e, ans) (*e)++;\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\tj=-1;\n\t\tFOR(i,K) if(A[i]==2*y) j=i;\n\t\tif(j==-1 && A[0]>y && (A[0]-2)*2>=y-1) j=0;\n\t\tvector<int> X,Y;\n\t\tFOR(i,K) {\n\t\t\tif(i<=j && A[i]>=2 && (A[i]-2)*2>=y-1) X.push_back(i),A[i]-=2;\n\t\t\telse Y.push_back(i),A[i]--;\n\t\t}\n\t\tFORR(c,X) V.push_back(c);\n\t\tFORR(c,Y) V.push_back(c);\n\t\tFORR(c,X) V.push_back(c);\n\t}\n\t\n\tFOR(i,N) cout<<V[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvector<int> ori;\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)ori.push_back(i);\n\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint num = 10000;\n\trep(i, n)num = min(num, a[i]);\n\trep(i, n)if (a[i] > 2 * num) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tassert(false);\n\tvector<vector<int>> ads(num);\n\trep(i, n) {\n\t\tint ad = a[i] - num;\n\t\trep(j, ad) {\n\t\t\tads[num - 1 - j].push_back(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(i, num) {\n\t\tint memo = ans.size();\n\t\tfor (int ad : ads[i]) {\n\t\t\tans.push_back(ad);\n\t\t}\n\t\tint las = 0;\n\t\trep(j, ads[i].size()) {\n\t\t\tvector<int> v;\n\t\t\tint g = memo + j;\n\t\t\tbool valid = false;\n\t\t\tif (g >= n - 1) {\n\t\t\t\trep(t, n) {\n\t\t\t\t\tv.push_back(ans[g - t]);\n\t\t\t\t}\n\t\t\t\tsort(all(v));\n\t\t\t\tif (v == ori)valid = true;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tlas++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvector<bool> skip(n,false);\n\t\trep(j, ads[i].size()) {\n\t\t\tif (j >= las)skip[ads[i][j]] = true;\n\t\t}\n\t\trep(i, n)if (!skip[i])ans.push_back(i);\n\t\trep(i, n)if (skip[i])ans.push_back(i);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\tvector<int> tet;\n\n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ttet.push_back(i+1);\n\t\t\tarr[i].first--;\n\t\t}\n\t}\n\n\tvector<vector<int> > blocks;\n\n\tint u = 0;\n\n\twhile (true) {\n\n\t\tauto kek = arr;\n\t\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\t\tkek[i].first--;\n\t\t}\n\n\t\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\t\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\t\tif (2*minimum.first < maximum.first) break;\n\t\ttet.push_back(u+1);\n\t\tu = (u+1)%n;\n\n\t\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\t\tarr = kek; \n\n\t}\n\n\tblocks.push_back(tet);\n\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\ttet.clear();\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tsort(all(big));\n\t\tsort(all(small));\n\n\t\tfor (int e = 0; e < big.size(); ++e) tet.push_back(big[e]+1);\n\t\tfor (int e = 0; e < small.size(); ++e) tet.push_back(small[e]+1);\n\t\tfor (int e = 0; e < big.size(); ++e) tet.push_back(big[e]+1);\n\n\t\tblocks.push_back(tet);\n\n\t}\n\n\tsort(all(blocks));\n\n\tfor (int i = 0; i < blocks.size(); ++i) for (int j = 0; j < blocks[i].size(); ++j) {\n\t\tcout << blocks[i][j] << \" \";\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    vector<int> two, one;\n    int min = A[0].first;\n    for (int i = 0; i < K; ++i) {\n      if (min * 2 == A[i].first) {\n        two.push_back(A[i].second);\n      }\n    }\n\n    sort(two.begin(), two.end());\n    if (two.size()) {\n      int max_two = two.back();\n      for (int i = 0; i < K; ++i) {\n        if (min < A[i].first && A[i].first < min * 2 && A[i].second < max_two) {\n          two.push_back(A[i].second);\n        }\n      }\n    }\n\n    sort(two.begin(), two.end());\n    set<int> S(two.begin(), two.end());\n    for (int i = 0; i < K; ++i) {\n      if (!S.count(A[i].second)) {\n        one.push_back(A[i].second);\n        A[i].first--;\n      } else {\n        A[i].first -= 2;\n      }\n    }\n\n    sort(one.begin(), one.end());\n    for (int x : two) cout << x + 1 << ' ';\n    for (int x : one) cout << x + 1 << ' ';\n    for (int x : two) cout << x + 1 << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\tint nxt = min(mh(), j==k-1? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tif (!p1valid(tst)) ++a[v], tst.pop_back();\n\t\t\t\t\telse {\n\t\t\t\t\t\t++a[v], nh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 111;\n\nint a[maxn], p[1111], n, k, tot, mn, mx;\n\nbool have[maxn];\nstd::vector<int> try_extend(std::vector<int> pre)\n{\n\tstatic int b[maxn], have[maxn];\n\t\n\tstd::vector<int> ret;\n\tfor(int i=1; i<=k; i++)\n\t{\n\t\tb[i] = a[i];\n\t\thave[i] = 0;\n\t}\n\tfor(auto v : pre) have[v] = 1;\n\tfor(int i=1; i<=k; i++) if(!have[i]) ret.pb(i);\n\t// printf(\"try size= %d mx= %d mn= %d\\n\", ret.size(), mx, mn);\n\t// for(int i=1; i<=k; i++) printf(\"i= %d c= %d\\n\", i, a[i]);\n\tfor(auto v : ret)\n\t{\n\t\tb[v]--;\n\t\tif(b[v] < 0) return std::vector<int>();\n\t}\n\tmx = *std::max_element(b+1, b+k+1);\n\tmn = *std::min_element(b+1, b+k+1);\n\tif(mx > mn * 2 + 1) return std::vector<int>();\n\t\n\tif(mx <= mn * 2) std::sort(ret.begin(), ret.end());\n\telse\n\t{\n\t\tstd::vector<int> good, other;\n\t\tfor(auto v : ret) if(b[v] != mx && b[v] != mn) good.pb(v); else if(b[v] == mx) other.pb(v);\n\t\tfor(auto v : ret) if(b[v] == mn) other.pb(v);\n\t\tint it1 = 0, it2 = 0;\n\t\t\n\t\tret.clear();\n\t\twhile(it1 < good.size() && it2 < other.size())\n\t\t{\n\t\t\tif(good[it1] < other[it2]) ret.pb(good[it1++]);\n\t\t\telse ret.pb(other[it2++]);\n\t\t}\n\t\twhile(it1 < good.size()) ret.pb(good[it1++]);\n\t\twhile(it2 < other.size()) ret.pb(other[it2++]);\n\t}\n\t\n\tif(mx == mn * 2 + 1)\n\t{\n\t\tbool haveMN = 0;\n\t\tfor(auto v : pre)\n\t\t{\n\t\t\tif(b[v] == mn) haveMN = 1;\n\t\t\telse if(b[v] == mx && haveMN) return std::vector<int>();\n\t\t}\n\t\tfor(auto v : ret)\n\t\t{\n\t\t\tif(b[v] == mn) haveMN = 1;\n\t\t\telse if(b[v] == mx && haveMN) return std::vector<int>();\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nvoid extend()\n{\n\tstd::vector<int> ext, tmp;\n\tif(tot == 0) ext = try_extend(std::vector<int>());\n\telse\n\t{\n\t\tfor(int i=std::max(0, tot + k - n); i < k; i++)\n\t\t{\n\t\t\ttmp.clear();\n\t\t\tfor(int j=tot-i+1; j<=tot; j++) tmp.pb(p[j]);\n\t\t\ttmp = try_extend(tmp);\n\t\t\tif(tmp.size() && (ext.size() == 0 || tmp < ext)) ext = tmp;\n\t\t}\n\t}\n\tassert(ext.size());\n\tfor(auto v : ext)\n\t{\n\t\tp[++tot] = v;\n\t\ta[v]--;\n\t}\n}\n\nint main()\n{\n\tget1(k);\n\tfor(int i=1; i<=k; i++)\n\t{\n\t\tget1(a[i]);\n\t\tn += a[i];\n\t}\n\t\n\tint mx = *std::max_element(a+1, a+k+1), mn = *std::min_element(a+1, a+k+1);\n\tif(mx > mn * 2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(tot < n) extend();\n\tfor(int i=1; i<=n; i++) printf(\"%d \", p[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\nbool seen[MAXVALS];\n\nvoid makeperm(vector<int>& perm,const vector<int> &suff) {\n\tperm = suff;\n\tREP(j, nvals) seen[j] = false;\n\tREPSZ(j, perm) seen[perm[j]] = true;\n\tREP(j, nvals) if (!seen[j]) perm.PB(j);\n}\n\nvector<int> calc(int nblock) {\n\tREP(i, nvals) rem[i] = cnt[i] - nblock;\n\tREP(i, nvals) if (rem[i] > nblock) return vector<int>();\n\n\tvector<vector<int>> suff(nblock);\n\tREP(i, rem[0]) suff[i].PB(0);\n\trem[0] = 0;\n\tvector<vector<int>> perm(nblock);\n\twhile (true) {\n\t\tint mxidx = -1;\n\t\tREP(i, nvals) if (rem[i] > 0 && (mxidx == -1 || rem[i] > rem[mxidx])) mxidx = i;\n\t\tif (mxidx == -1) break;\n\t\tint start = nblock - rem[mxidx];\n\t\tREP(i,start) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\n\t\tif (start - 1 >= 0) {\n\t\t\twhile (SZ(suff[start - 1]) < SZ(perm[start - 1])) {\n\t\t\t\tint x = perm[start - 1][SZ(suff[start - 1])];\n\t\t\t\tif (rem[x] == 0 || x > mxidx) break;\n\t\t\t\tsuff[start - 1].PB(x);\n\t\t\t\t--rem[x];\n\t\t\t}\n\t\t}\n\t\tREP(i, nvals) if (i <= mxidx) {\n\t\t\tREP(j, rem[i]) suff[start + j].PB(i);\n\t\t\trem[i] = 0;\n\t\t}\n\t}\n\tREP(i, nblock) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\tvector<int> ret;\n\tREP(i, nblock) {\n\t\tREPSZ(j, perm[i]) ret.PB(perm[i][j]);\n\t\tREPSZ(j, suff[i]) ret.PB(suff[i][j]);\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tbool ret = false;\n\tint mxblock = cnt[0]; FOR(i, 1, nvals) mxblock = min(mxblock, cnt[i]);\n\tFORE(i, 1, mxblock) {\n\t\tvector<int> cur = calc(i);\n\t\tif (SZ(cur) == 0) continue;\n\t\tif (ret == false || cur < ans) ret = true, ans = cur;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\tvi prev(k, -1);\n\n\trep(i,0,len){\n\t\tmx = 0, mn = 1000;\n\t\ttrav(x, a) mx = max(mx, x);\n\t\ttrav(x, a) mn = min(mn, x);\n\t\tint imx = 1000;\n\t\trep(d,0,k) if(a[d] == mn) imx = min(imx, prev[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx && !(mx=2*mn+1 && a[d] < mx && prev[d] > imx)){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans[i] < 0){\n\t\t\trep(j,0,i) cout << 1+ans[j] << \" \";\n\t\t\tcout << endl;\n\t\t\ttrav(x, a) cout << x << \" \";\n\t\t\tcout << endl;\n\n\t\t\tcout << mx << \" \" << mn << endl;\n\t\t\tcout << a[ans[i]] << endl;\n\t\t\tcout << imx << \" \" << prev[ans[i]] << endl;\n\t\t\tassert(false);\n\t\t}\n\t\tprev[ans[i]] = i;\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt) {\n\t\t\t\t\t++a[v];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,m,cnt,a[1111],k[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  while (cnt>0) {\n    m=0;\n    //printf(\"cnt=%d: \",cnt);\n    //for (i=1; i<=n; i++) printf(\"%d,\",a[i]);\n    for (i=1; a[i]>0; i++);\n    m=i-1;\n    for (; i<=n; i++) if (a[i]==cnt) m=i;\n    //printf(\"m=%d\\n\",m);\n    for (i=1; i<=m; i++) if (a[i]>0) printf(\"%d \",i);\n    for (i=1; i<=m; i++) if (a[i]==0) printf(\"%d \",i);\n    for (; i<=n; i++) printf(\"%d \",i);\n    for (i=1; i<=m; i++) if (a[i]>0) {\n      --a[i];\n      printf(\"%d \",i);\n    }\n    cnt--;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint N;\n\nvoid generate(vector<int> &src, vector<int> &dest) {\n\tvector<bool> flag(N, true);\n\tsort(src.begin(), src.end());\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t\tflag[src[i]] = false;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (flag[i] == true) {\n\t\t\tdest.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint K; cin >> K;\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tN = a.size();\n\tint M = 100000;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tchmin(M, a[i]);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i] > M * 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\tset<int> st;\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<int> sizes(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsizes[j] = a[j];\n\t\t}\n\t\tsort(sizes.begin(), sizes.end());\n\n\t\tvector<int> v;\n\t\tfor (auto itr = st.begin(); itr != st.end(); itr++) {\n\t\t\tv.push_back(*itr);\n\t\t}\n\t\tint m = N;\n\t\tif (v.size() > 0) {\n\t\t\tm = v[v.size() - 1];\n\t\t}\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tif (st.find(c) != st.end()) { continue; }\n\t\t\tbool f = true;\n\n\t\t\tint _m = sizes[0];\n\t\t\tchmin(_m, a[c] - 1);\n\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (a[k] > 2 * _m) { f = false; }\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tv.push_back(c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\ta[v[j]]--;\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j]--;\n\t\t}\n\n\t\tm = 100000;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tchmin(m, a[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (a[j] == m * 2) {\n\t\t\t\tst.insert(j);\n\t\t\t}\n\t\t}\n\n\t\tgenerate(v, ans);\n\t}\n\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1005;\nvector<int> inf;\nint n,k,a[N],b[N],ans[N],vis[N],now;\nbool check(){\n\tint x=*max_element(a+1,a+k+1);\n\tint y=*min_element(a+1,a+k+1);\n\treturn x<=2*y;\n}\nvoid merge(vector<int> &a,vector<int> &b,vector<int> &c){\n\tint posa=0,posb=0;\n\twhile(posa<a.size() && posb<b.size()){\n\t\tif(a[posa]<b[posb]) c.push_back(a[posa++]);\n\t\telse c.push_back(b[posb++]);\n\t}\n\twhile(posa<a.size()) c.push_back(a[posa++]);\n\twhile(posb<b.size()) c.push_back(b[posb++]);\n}\nvector<int> calc(int len){\n\t//cout<<len<<endl;\n\tfor(int i=1;i<=k;++i)\n\t\tb[i]=a[i],vis[i]=0;\n\tfor(int i=now+len-k+1;i<=now;++i)\n\t\tvis[ans[i]]=1;\n\tfor(int i=1;i<=k;++i)\n\t\tif(vis[i]==0){\n\t\t\t--b[i];\n\t\t\tif(b[i]<0) return inf;\n\t\t}\n\tint x=*max_element(b+1,b+k+1),\n\t\ty=*min_element(b+1,b+k+1);\n\t//cout<<x<<\" \"<<y<<endl;\n\tvector<int> res;\n\tif(x>2*y+1) return inf;\n\tif(x<=2*y){\n\t\tfor(int i=1;i<=k;++i)\n\t\t\tif(!vis[i]) res.push_back(i);\n\t\treturn res;\n\t}\n\tvector<int> A,B,all;\n\tfor(int i=1;i<=k;++i)\n\t\tif(!vis[i] && b[i]==x) A.push_back(i);\n\tfor(int i=1;i<=k;++i)\n\t\tif(!vis[i] && b[i]==y) A.push_back(i);\n\tfor(int i=1;i<=k;++i)\n\t\tif(!vis[i] && b[i]!=x && b[i]!=y) B.push_back(i);\n\tmerge(A,B,res);\n\tfor(int i=now+len-k+1;i<=now;++i)\n\t\tall.push_back(ans[i]);\n\tall.insert(all.end(),res.begin(),res.end());\n\tint pos_mx=-1,pos_mn=n+1;\n\tfor(int i=0;i<all.size();++i)\n\t\tif(b[all[i]]==x) pos_mx=max(pos_mx,i);\n\t\telse if(b[all[i]]==y) pos_mn=min(pos_mn,i);\n//\tfor(int i=0;i<all.size();++i)\n//\t\tcout<<all[i]<<\" \";cout<<endl;\n\tif(pos_mx>pos_mn) return inf;\n\telse return res;\n}\nint main(){\n\tcin>>k;\n\tfor(int i=1;i<=k;++i)\n\t\tcin>>a[i],n+=a[i];\n\tif(!check()) return puts(\"-1\"),0;\n\tinf.push_back(23333);\n\twhile(now<n){\n\t\tvector<int> S=inf;\n\t\tfor(int len=1;now+len<=n && len<=k;++len)\n\t\t\tif(now+len>=k) S=min(S,calc(len));\n\t\t//cout<<S.size()<<endl;\n\t\tfor(int i=0;i<S.size();++i)\n\t\t\tans[++now]=S[i],--a[S[i]];\n\t}\n\tfor(int i=1;i<=now;++i)cout<<ans[i]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"[DEBUG] \");W(__VA_ARGS__);}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1<<10;\nint a[101],n,K,now[101];\nint an[SIZE];\nint u[SIZE],tt;\nint u2[SIZE],tt2;\nbool good[SIZE];\nbool valid(int sep_pos){\n    tt++;\n    int ll=sep_pos;\n    for(int i=0;i<=sep_pos&&i<K;i++){\n        if(u[an[sep_pos-i]]==tt) break;\n        u[an[sep_pos-i]]=tt;\n        ll=sep_pos-i;\n    }\n    if(ll){\n        if(!good[ll-1])return 0;\n    }\n    memcpy(now,a,sizeof(int)*(K+1));\n    int mi=1001,ma=-1;\n    int ma_cnt=0;\n    FOR(i,1,K){\n        if(u[i]!=tt){\n            if(!now[i])return 0;\n            now[i]--;\n        }\n        mi=min(mi,now[i]);\n        if(ma<now[i]){\n            ma=now[i];\n            ma_cnt=1;\n        }\n        else if(ma==now[i]){\n            ma_cnt++;\n        }\n    }\n    if(mi*2>=ma)return 1;\n    FOR(i,ll,sep_pos){\n        if(!good[i]){\n            ll=i;\n            break;\n        }\n        int x=an[i];\n        if(!now[x])return 0;\n        if(now[x]==ma){\n            ma_cnt--;\n        }\n        u[x]=0;\n        now[x]--;\n        mi=min(mi,now[x]);\n        if(mi*2>=ma-(ma_cnt==0))return 1;\n    }\n    FOR(i,ll,sep_pos){\n        int x=an[i];\n        if(!now[x])return 0;\n        if(now[x]==ma){\n            ma_cnt--;\n        }\n        now[x]--;\n        mi=min(mi,now[x]);\n        if(mi*2>=ma-(ma_cnt==0))return 1;\n    }\n\n    \n    mi=1001,ma=-1;\n    ma_cnt=0;\n    FOR(i,1,K){\n        mi=min(mi,now[i]);\n        if(ma<now[i]){\n            ma=now[i];\n            ma_cnt=1;\n        }\n        else if(ma==now[i]){\n            ma_cnt++;\n        }\n    }\n\n    FOR(i,1,K){\n        if(u[i]!=tt&&now[i]==ma){\n            ma_cnt--;\n            if(mi*2>=ma-(ma_cnt==0))return 1;\n        }\n    }\n    return 0;\n}\nvoid solve() {\n    R(K);\n    FOR(i,1,K){\n        R(a[i]);\n        n+=a[i];\n    }\n    if(*max_element(a+1,a+1+K)>2*(*min_element(a+1,a+1+K))){\n        W(-1);\n        return;\n    }\n    REP(i,n){\n        FOR(j,1,K){\n            if(a[j]){\n                a[j]--;\n                an[i]=j;\n                if(valid(i))break;\n                a[j]++;\n            }\n        }\n        if(i>=K-1){\n            vector<int>ker(K+1);\n            REP(j,K){\n                ker[an[i-j]]=1;\n            }\n            if(count(ALL(ker),1)==K){\n                REP(j,K)good[i-j]=1;\n            }\n        }\n    }\n    W(VI(an,an+n));\n}\nint main(){\n#define MULTITEST 0\n#if MULTITEST    \n    CASET{\n        solve();\n    }\n#else\n    solve();\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[233];\nvector<int> ans,tx,ty;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(1)\n\t{\n\t\tint minn=114514,maxx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tminn=min(minn,a[i]);\n\t\t\tmaxx=max(maxx,a[i]);\n\t\t}\n\t\tif(maxx==0)break;\n\t\telse if(maxx>2*minn)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttx.clear();ty.clear();\n\t\tint zz=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]>2*minn-1)tx.push_back(i),a[i]-=2,zz=1;\n\t\t\telse if(a[i]>minn&&!zz)tx.push_back(i),a[i]-=2,zz=1;\n\t\t\telse ty.push_back(i),a[i]--;\n\t\t}\n\t\tfor(auto x:tx)ans.push_back(x);\n\t\tfor(auto x:ty)ans.push_back(x);\n\t\tfor(auto x:tx)ans.push_back(x);\n\t}\n\tfor(auto x:ans)cout<<x<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    for (int i = 0; i < K; ++i) cout << A[i].second + 1 << ' ';\n    for (int i = 1; i < K; ++i) {\n      if (A[0].first * 2 == A[i].first) {\n        cout << A[i].second + 1 << ' ';\n        --A[i].first;\n      }\n    }\n    for (int i = 0; i < K; ++i) --A[i].first;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint a[105], type[105];\nint main() {\n\tint k, m=0, max=0;\n\tscanf(\"%d\", &k);\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(m==0 || a[i]<a[m]) m=i;\n\t\tif(a[i]>max) max=a[i];\n\t}\n\tif(max>2*a[m]) return 0;\n\twhile(a[m]) {\n\t\tint max2=0;\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(a[i]==2*a[m]) {\n\t\t\t\ttype[i]=2;\n\t\t\t\tmax2=i;\n\t\t\t} else if(a[i]==a[m]) {\n\t\t\t\ttype[i]=1;\n\t\t\t} else {\n\t\t\t\ttype[i]=0;\n\t\t\t}\n\t\t}\n\t\tif(max2==0 && type[1]==0) {\n\t\t\tmax2=1;\n\t\t\ttype[1]=2;\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==0)\n\t\t\t\ttype[i] = i<max2?2:1;\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==2)\n\t\t\t\tprintf(\"%d \", i);\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==1)\n\t\t\t\tprintf(\"%d \", i);\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==2)\n\t\t\t\tprintf(\"%d \", i);\n\t\t}\n\t\tfor(int i=1; i<=k; ++i)\n\t\t\ta[i]-=type[i];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nbool ok(vector<int> a){\n\twhile(1){\n\t\tconst int mn=*min_element(all(a));\n\t\tif(mn<0) return false;\n\t\tif(mn==*max_element(all(a))) return true;\n\t\tif(mn==0) return false;\n\t\tfor(auto &x:a){\n\t\t\tif(x==mn) --x;\n\t\t\telse x-=2;\n\t\t}\n\t}\n}\n\nvector<int> solve(vector<int> a){\n\tconst int n=a.size();\n\tif(!ok(a)){\n\t\treturn {};\n\t}\n\tvv<int> ls;\n\twhile(*min_element(all(a))<*max_element(all(a))){\n\t\tvector<int> large;\n\t\tint mn=*min_element(all(a));\n\t\tbool yametai=0;\n\t\trep(i,n){\n\t\t\tif(a[i]!=mn){\n\t\t\t\tlarge.pb(i);\n\t\t\t}else{\n\t\t\t\tyametai=1;\n\t\t\t}\n\t\t\tif(yametai){\n\t\t\t\tif(large.empty()) continue;\n\t\t\t\tauto b=a;\n\t\t\t\tfor(auto &x:b) --x;\n\t\t\t\tfor(auto i:large) b[i]--;\n\t\t\t\tif(ok(b)){\n\t\t\t\t\ta=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// out(large,1);\n\t\tls.eb(large);\n\t}\n\tconst int m=ls.size();\n\tvector<int> re;\n\trep(_,a[0])rep(i,n) re.pb(i);\n\trep(i,m){\n\t\tconst auto &large=ls[i];\n\t\tvector<int> small;\n\t\t{\n\t\t\tvector<int> usd(n);\n\t\t\tfor(int i:large) usd[i]=1;\n\t\t\trep(i,n)if(!usd[i]) small.pb(i);\n\t\t}\n\t\t// if(t && (i+1==m || small[0]<ls[i+1][0])){\n\t\t// \trep(_,t){\n\t\t// \t\tfor(auto i:large) re.pb(i);\n\t\t// \t\tfor(auto i:small) re.pb(i);\n\t\t// \t}\n\t\t// \tt=0;\n\t\t// }\n\t\tfor(auto i:large) re.pb(i);\n\t\tfor(auto i:small) re.pb(i);\n\t\tfor(auto i:large) re.pb(i);\n\t\t// out(i,re,1);\n\t}\n\treturn re;\n}\n\nint main(){\n\tif(0){\n\t\trep(_,1000){\n\t\tconst int n=rand()%6+1;\n\t\tconst int t=rand()%10+1;\n\t\tvector<int> ans;\n\t\trep(_,t){\n\t\t\tvector<int> p(n); iota(all(p),0); random_shuffle(all(p));\n\t\t\tint r=rand()%n;\n\t\t\tint t=rand()%2+1;\n\t\t\trep(_,t)for(int x:p) ans.pb(x);\n\t\t\trep(i,r) ans.pb(p[i]);\n\t\t}\n\t\tvector<int> a(n);\n\t\tfor(int x:ans) ++a[x];\n\t\tauto act=solve(a);\n\t\tif(act.empty()){\n\t\t\tout(ans,a,1);\n\t\t\treturn 0;\n\t\t}\n\t\t}\n\t\tout(\"done\",1);\n\t\treturn 0;\n\t}\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(auto &x:a) cin>>x;\n\tauto re=solve(a);\n\tif(re.empty()){\n\t\tcout<<-1 NL;\n\t}else{\n\t\trep(i,re.size()) cout<<re[i]+1<<\" \\n\"[i+1==re.size()];\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint N;\n\nvoid generate(vector<int> &src, vector<int> &dest) {\n\tvector<bool> flag(N, true);\n\tsort(src.begin(), src.end());\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t\tflag[src[i]] = false;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (flag[i] == true) {\n\t\t\tdest.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint K; cin >> K;\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tN = a.size();\n\tint M = 100000;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tchmin(M, a[i]);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i] > M * 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\tset<int> st;\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<int> sizes(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsizes[j] = a[j];\n\t\t}\n\t\tsort(sizes.begin(), sizes.end());\n\n\t\tvector<int> v;\n\t\tfor (auto itr = st.begin(); itr != st.end(); itr++) {\n\t\t\tv.push_back(*itr);\n\t\t}\n\t\tint m = N;\n\t\tif (v.size() > 0) {\n\t\t\tm = v[v.size() - 1];\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\ta[v[j]]--;\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tif (st.find(c) != st.end()) { continue; }\n\t\t\tbool f = true;\n\n\t\t\tint _m = sizes[0];\n\t\t\tchmin(_m, a[c] - 1);\n\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (a[k] > 2 * _m) { f = false; }\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tv.push_back(c);\n\t\t\t\ta[c]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j]--;\n\t\t}\n\n\t\tm = 100000;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tchmin(m, a[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (a[j] == m * 2) {\n\t\t\t\tst.insert(j);\n\t\t\t}\n\t\t}\n\n\t\tgenerate(v, ans);\n\t}\n\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[la] < sb[lb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[res[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= sum; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  while(1){\n    debug(t,res);\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    if(ma == 0)break;\n    int il = 0;\n    if(mi * 2 == ma){\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] != ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n          il++;\n          t[i]-=2;\n        }else{\n          t[i]--;\n        }\n      }\n    }else{\n      R(i,n){\n        res.PB(i);\n        t[i]--;\n      }\n    }\n//     int xx = n - il;\n//     int naj = 0;\n//     R(i,xx){\n//       \n//     }\n    while(il < n){\n      int pom = dajmi();\n      t[res[SZ(res) - n]]--;\n      int pom2 = dajmi();\n      debug(il,pom,pom2,res[SZ(res) - n]);\n      if(pom2 != MAX && res[SZ(res) - n] <= pom){\n        res.PB(res[SZ(res) - n]);\n        il++;\n      }else{\n        t[res[SZ(res) - n]]++;\n        break;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            //ここの優先順位の付け方が甘い\n\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,j,cnt,lst,a[1111],k[1111],st[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  lst=cnt;\n  for (i=n; i>0; i--) if (a[i]>0) {\n    st[i]=min(lst,cnt-a[i]+1);\n    lst=min(lst,st[i]);\n  }\n  if (st[1]!=0) st[1]=1;\n  for (j=1; j<=cnt; j++) {\n    for (i=1; i<=n; i++) if (st[i]!=0 && j>=st[i] && j<st[i]+a[i]) printf(\"%d \",i);\n    for (i=1; i<=n; i++) if (!(st[i]!=0 && j>=st[i] && j<st[i]+a[i])) printf(\"%d \",i);\n    for (i=1; i<=n; i++) if (st[i]!=0 && j>=st[i] && j<st[i]+a[i]) printf(\"%d \",i);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[la] < sb[lb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[sa[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= sum; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\tj=-1;\n\t\tFOR(i,K) if(A[i]==2*y) j=i;\n\t\tif(j==-1 && A[0]>y && (A[0]-2)*2<=y-1) j=0;\n\t\tvector<int> X,Y;\n\t\tFOR(i,K) {\n\t\t\tif(i<=j && A[i]>y) X.push_back(i),A[i]-=2;\n\t\t\telse Y.push_back(i),A[i]--;\n\t\t}\n\t\tFORR(c,X) V.push_back(c);\n\t\tFORR(c,Y) V.push_back(c);\n\t\tFORR(c,X) V.push_back(c);\n\t}\n\t\n\tFOR(i,N) cout<<V[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e3+10;\nint n,cnt[N],s,m,ans[N];\n\nint b[N];\npoly res;\nbool vis[N];\ninline bool check(int len){\n\tint las=n-len;\n\tif (m-las+1<=0||m+len>s) return 0;\n\tFor(i,1,n) vis[i]=0;\n\tFor(i,m-las+1,m) vis[ans[i]]=1;\n\tint mn=1e9,mx=0;\n\tFor(i,1,n) b[i]=cnt[i]-(vis[i]^1),mn=min(mn,b[i]),mx=max(mx,b[i]);\n\tif (mn<0) return 0;\n\tres={};\n\tif (mn*2>=mx){\n\t\tFor(i,1,n) if (!vis[i]) res.pb(i);\n\t\treturn 1;\n\t} else if (mn*2+1==mx){\n\t\tpoly A,B;\n\t\tFor(i,1,n) if (!vis[i]&&b[i]==mx) A.pb(i);\n\t\tFor(i,1,n) if (!vis[i]&&b[i]==mn) A.pb(i);\n\t\tFor(i,1,n) if (!vis[i]&&b[i]!=mx&&b[i]!=mn) B.pb(i);\n\t\tint l1=0,l2=0;\n\t\twhile (l1<siz(A)||l2<siz(B)){\n\t\t\tif (l2==siz(B)) res.pb(A[l1++]);\n\t\t\telse if (l1==siz(A)) res.pb(B[l2++]);\n\t\t\telse if (A[l1]<B[l2]) res.pb(A[l1++]);\n\t\t\telse res.pb(B[l2++]);\n\t\t}\n\t\tint r=0,l=0;\n\t\tFor(i,1,las){\n\t\t\tif (b[ans[m-i+1]]==mx) r=i;\n\t\t\tif (b[ans[m-i+1]]==mn&&!l) l=i;\n\t\t}\n\t\tFOR(i,0,siz(res)){\n\t\t\tif (b[res[i]]==mx) r=las+i+1;\n\t\t\tif (b[res[i]]==mn&&!l) l=las+i+1; \n\t\t}\n\t\tif (r<l) return 1;\n\t\t\telse return 0;\n\t} else return 0;\n}\ninline bool check(poly a,poly b){\n\tint n=max(siz(a),siz(b));\n\ta.resize(n),b.resize(n);\n\tFOR(i,0,n) if (a[i]!=b[i]) return a[i]<b[i];\n\treturn 0;\n}\ninline void insert(){\n\tpoly ret;\n\tFor(i,1,n)\n\t\tif (check(i))\n\t\t\tif (ret.empty()||check(res,ret)) ret=res;\n\tfor (auto i:ret) ans[++m]=i,cnt[i]--;\n}\n\nint main(){\n\tn=read();\n\tint mx=0,mn=1e9;\n\tFor(i,1,n){\n\t\tcnt[i]=read(),s+=cnt[i];\n\t\tmx=max(mx,cnt[i]),mn=min(mn,cnt[i]);\n\t}\n\tif (mn*2<mx) return puts(\"-1\"),0;\n\twhile (m<s) insert();\n\tFor(i,1,m) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,j,cnt,lst,nxt,fi,a[1111],k[1111],st[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  for (j=cnt; j>=1; j--) {\n    lst=0;\n    for (i=1; i<=n; i++) if (a[i]==j) lst=i;\n    if (lst==0) {\n      if (j==1) {\n        for (i=1; i<=n; i++) printf(\"%d \",i);\n      } else {\n        nxt=0;\n        for (i=1; i<=n; i++) if (a[i]==j-1) nxt=i;\n        if (nxt) {\n          for (i=1; i<=nxt; i++) if (a[i]>1) { fi=i; break; }\n\t\t  if (fi==0 && a[1]>0) fi=1;\n        } else fi=1;\n        for (i=1; i<=fi; i++) if (a[i]>0) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]<=0) printf(\"%d \",i);\n        for (; i<=n; i++) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n      }\n    } else {\n      for (i=1; i<=lst; i++) if (a[i]>0) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]<=0) printf(\"%d \",i);\n      for (; i<=n; i++) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint k, a[105], p[1005], last[105], l=1;\nbool chk(int x, int y) {\n\tif(last[x]<l) {\n\t\tif(last[y]<l) {\n\t\t\treturn 2*a[x]>=a[y];\n\t\t} else {\n\t\t\treturn 2*a[x]>=a[y]+1;\n\t\t}\n\t} else {\n\t\tif(last[y]<l) {\n\t\t\treturn 2*a[x]+1>=a[y];\n\t\t} else {\n\t\t\tif(last[x]<last[y])\n\t\t\t\treturn 2*a[x]>=a[y];\n\t\t\telse\n\t\t\t\treturn 2*a[x]+1>=a[y];\n\t\t}\n\t}\n}\nbool check() {\n\tfor(int x=1; x<=k; ++x) {\n\t\tfor(int y=1; y<=k; ++y) {\n\t\t\tif(x==y) continue;\n\t\t\tif(!chk(x, y)) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint n=0;\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tn+=a[i];\n\t}\n\tif(!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint sat=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tint &P=p[i], lsave=l;\n\t\tif(i-l==k) {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=last[P]+1;\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t\tif(i-l+1==k) sat=i;\n\t\t} else {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0 || last[P]>sat) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=std::max(l, last[P]+1);\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) printf(\"%d \", p[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\n\nusing namespace std;\ntemplate<typename T1, typename T2> inline void chkmin(T1 &a, T2 b) {if (a > b) a = b;}\ntemplate<typename T1, typename T2> inline void chkmax(T1 &a, T2 b) {if (a < b) a = b;}\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define left left228\n#define right right228\n#define y1 y1228\n#define mp make_pair\n#define pb push_back\n#define y2 y2228\n#define rank rank228\nusing ll = long long;\nusing ld = long double; \nconst string FILENAME = \"input\";\nconst int MAXN = 1028;\n\n\n\nint n, k;\nint a[MAXN];\nint pl[MAXN], pr[MAXN], p[MAXN];\nbool bl[MAXN];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n \t//read(FILENAME);\n \tcin >> k;\n \tint mx = 0;\n \tfor (int i = 1; i <= k; i++) {\n \t\tcin >> a[i];\n \t\tn += a[i];\n \t\tpl[i] = k, pr[i] = i;\n \t\tchkmax(mx, a[i]);\n \t}\n \tfor (int i = 1; i <= k; i++) {\n \t\tif (a[i] * 2 < mx) {\n \t\t\tcout << -1 << endl;\n \t\t\treturn 0;\n \t\t}\n \t}\n \tint mm = 0, mk = 0;\n \tfor (int i = 1; i <= n; i++) {\n \t\tint j = 1;\n \t\tfor (; j <= k; j++) {\n \t\t\tif (bl[j]) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbool bb = 1;\n \t\t\tmx = 0;\n \t\t\tfor (int is = 1; is <= k; is++) {\n \t\t\t\tchkmax(mx, a[is]);\n \t\t\t}\n \t\t\tfor (int is = 1; is <= pl[j]; is++) {\n \t\t\t\tif (!bl[pr[is]]) {\n \t\t\t\t\ta[pr[is]]--;\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (int is = 1; is <= k; is++) {\n \t\t\t\tif (a[is] * 2 + 2 < mx) {\n \t\t\t\t\tbb = 0;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (a[j] * 2 + 1 < mx) {\n \t\t\t\tbb = 0;\n \t\t\t}\n \t\t\tfor (int is = 1; is <= pl[j]; is++) {\n \t\t\t\tif (!bl[pr[is]]) {\n \t\t\t\t\ta[pr[is]]++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (bb) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tbl[j] = 1;\n \t\tp[i] = j;\n \t\ta[j]--;\n \t\tmm++;\n \t\tchkmax(mk, pl[j]);\n \t\tif (i >= k && (i == k || mm == mk)) {\n \t\t\tfor (int j = 1; j <= k; j++) {\n \t\t\t\tbl[j] = 0;\n \t\t\t\tpl[p[i - k + j]] = j;\n \t\t\t\tpr[j] = p[i - k + j];\n \t\t\t}\n \t\t\tmm = 0;\n \t\t\tmk = 0;\n \t\t}\n \t}\n \tfor (int i = 1; i <= n; i++) {\n \t\tcout << p[i] << ' ';\n \t}\n \tcout << '\\n';\n\treturn 0;\t \t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\n\trep(i,0,len){\n\t\tmx = 0;\n\t\trep(d,0,k) mx = max(mx, a[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tassert(ans[i] >= 0);\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 1e3 + 50;\ncs int INF = 1e9 + 7;\nvoid ckmn(int &a, int b){ if(a > b) a = b; }\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\nint n, a[N], m, ans[N];\nint now[N], nxt[N], my;\nbool cmp(cs int &i, cs int &j){\n\tint x=a[i]==my,y=a[j]==my;\n\tif(x!=y)return x<y; return i<j;\n}\nbool work(int len){\n\tfor(int i=1;i<=len;i++)--a[now[i]];\n\tint mn=INF,mx=0;\n\tfor(int i=1; i<=n; i++)\n\tmn=min(mn,a[i]),mx=max(mx,a[i]);\n\t\n\tif(mn*2>=mx){\n\t\tfor(int i=1; i<=len; i++)\n\t\t++a[nxt[i]=now[i]];\n\t\tsort(nxt+1,nxt+len+1);\n\t\treturn true;\n\t}\n\t\n\tif(mn*2+1<mx){\n\t\tfor(int i=1; i<=len; i++) ++a[now[i]];\n\t\treturn false;\n\t}\n\t\n\tstatic int t1[N], t2[N]; int z1=0, z2=0;\n\tfor(int i=1; i<=len; i++)\n\tif(a[now[i]]==mn||a[now[i]]==mx)\n\tt1[++z1]=now[i]; else t2[++z2]=now[i]; \n\t\n\tmy=mn;\n\tsort(t1+1,t1+z1+1,cmp);\n\tsort(t2+1,t2+z2+1);\n\t\n\tfor(int i=1,p=1,q=1; i<=len; i++)\n\tif((p<=z1 && t1[p]<t2[q])||q>z2) nxt[i]=t1[p++];\n\telse nxt[i]=t2[q++];\n\t\n\tbool ok=true;\n\tfor(int i=len+1;i<=n;i++)ok&=(a[now[i]]!=mn);\n\tok|=(z1==0)|(a[t1[1]]==mn);\n\t\n\tfor(int i=1; i<=len; i++)++a[now[i]];\n\treturn ok;\n}\nbool cmp(int *a, int *b){ \n\tint i=1;for(;a[i]==b[i];i++);\n\treturn a[i]<b[i];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tint mn=INF,mx=0,sm=0;\n\tfor(int i=1; i<=n; i++)\n\tscanf(\"%d\",&a[i]),sm+=a[i],\n\tckmn(mn,a[i]),ckmx(mx,a[i]);\n\tfor(int i=1; i<=n; i++)\t\n\tnow[i]=i; if(!work(n))return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\n\tnow[i]=ans[++m]=nxt[i],--a[now[i]];\n\twhile(m<sm){\n\t\tstatic int trs[N];\n\t\tint len=0;trs[1]=n+1;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(work(i)&&cmp(nxt,trs))\n\t\t\tlen=i,memcpy(trs,nxt,sizeof(int)*(len+1));\n\t\t}\n\t\tfor(int i=1; i+len<=n; i++)\n\t\tnow[i]=now[i+len];\n\t\tfor(int i=1; i<=len; i++)\n\t\tnow[i+n-len]=ans[++m]=trs[i],--a[trs[i]];\n\t} for(int i=1; i<=m; i++)cout<<ans[i]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid swap(int *a, int *b)\n{\n\tint temp=*a;\n\t*a=*b;\n\t*b=temp;\n}\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint arr[n];\n\tfor(int i=0;i<n;i++)\n\t\tcin>>arr[i];\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(i%2==0 && arr[i] > arr[i+1])\n\t\t\tswap(arr[i],arr[i+1]);\n\t\tif(i%2!=0 && arr[i] < arr[i+1])\n\t\t\tswap(arr[i],arr[i+1]);\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcout<<arr[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\nbool seen[MAXVALS];\n\nvoid makeperm(vector<int>& perm,const vector<int> &suff) {\n\tperm = suff;\n\tREP(j, nvals) seen[j] = false;\n\tREPSZ(j, perm) seen[perm[j]] = true;\n\tREP(j, nvals) if (!seen[j]) perm.PB(j);\n}\n\nvector<int> calc(int nblock) {\n\tREP(i, nvals) rem[i] = cnt[i] - nblock;\n\tREP(i, nvals) if (rem[i] > nblock) return vector<int>();\n\n\tvector<vector<int>> suff(nblock);\n\tREP(i, rem[0]) suff[i].PB(0);\n\trem[0] = 0;\n\tvector<vector<int>> perm(nblock);\n\twhile (true) {\n\t\tint mxidx = -1;\n\t\tREP(i, nvals) if (rem[i] > 0 && (mxidx == -1 || rem[i] > rem[mxidx])) mxidx = i;\n\t\tif (mxidx == -1) break;\n\t\tint start = nblock - rem[mxidx];\n\t\tREP(i,start) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\n\t\tif (start - 1 >= 0) {\n\t\t\twhile (SZ(suff[start - 1]) < SZ(perm[start - 1])) {\n\t\t\t\tint x = perm[start - 1][SZ(suff[start - 1])];\n\t\t\t\tif (rem[x] == 0) break;\n\t\t\t\tsuff[start - 1].PB(x);\n\t\t\t\t--rem[x];\n\t\t\t}\n\t\t}\n\t\tREP(i, nvals) if (i <= mxidx) {\n\t\t\tREP(j, rem[i]) suff[start + j].PB(i);\n\t\t\trem[i] = 0;\n\t\t}\n\t}\n\tREP(i, nblock) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\tvector<int> ret;\n\tREP(i, nblock) {\n\t\tREPSZ(j, perm[i]) ret.PB(perm[i][j]);\n\t\tREPSZ(j, suff[i]) ret.PB(suff[i][j]);\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tbool ret = false;\n\tint mxblock = cnt[0]; FOR(i, 1, nvals) mxblock = min(mxblock, cnt[i]);\n\tFORE(i, 1, mxblock) {\n\t\tvector<int> cur = calc(i);\n\t\tif (SZ(cur) == 0) continue;\n\t\tif (ret == false || cur < ans) ret = true, ans = cur;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    while(a[1] > 0) {\n        --a[1];\n        vs[a[1]].insert(1);\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; a[i] > 0; ++ind) {\n                    --a[i];\n                    vs[ind].insert(i);\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tarr[i].first--;\n\t\t}\n\t}\n\n\tint u = 0;\n\twhile (true) {\n\n\t\tauto kek = arr;\n\t\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\t\tkek[i].first--;\n\t\t}\n\n\t\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\t\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\t\tif (2*minimum.first < maximum.first) break;\n\t\tcout << u+1 << \" \";\n\t\tu = (u+1)%n;\n\n\t\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\t\tarr = kek; \n\n\t}\n\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, deque<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\n\n\n\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  li n; cin>>n;\n  vi A(n); for(li i = 0; i < (li)(n); ++i) cin>>A[i];\n\n  vi I(n); iota(begin(I), end(I), 0);\n  sort(begin(I), end(I), [&](int i, int j) { return A[i] < A[j]; });\n\n  if(A[I[0]] > 2*A[I[n-1]]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int m = A[I[0]];\n  vector<vi> V(2*m);\n  for(li i = 0; i < (li)(n); ++i) {\n    if(i < I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*j+1].push_back(i);\n    } else if(i > I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j+1].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*m - 2*j - 2].push_back(i);\n    }\n  }\n\n  for(li i = 0; i < (li)(m); ++i) {\n    vector<int> seen1(n);\n    for(int a : V[2*i+1]) seen1[a] = 1;\n    vector<int> seen2(n);\n    for(int a : V[2*i]) seen2[a] = 1;\n    vi v2, w2, v1, w1;\n    for(int a : V[2*i]) if(seen[a]) v1.push_back(a); else w1.push_back(a);\n    for(int a : V[2*i+1]) if(seen[a]) v2.push_back(a); else w2.push_back(a);\n\n    sort(begin(v1), end(v1));\n    sort(begin(w1), end(w1));\n    sort(begin(v2), end(v2));\n    sort(begin(w2), end(w2));\n\n    for(int x : v1) cout << x+1 << ' ';\n    for(int x : w1) cout << x+1 << ' ';\n    cout << I[0]+1 << ' ';\n    for(int x : w2) cout << x+1 << ' ';\n    for(int x : v2) cout << x+1 << ' ';\n  }\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] != *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\twhile (sz < sum){\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tvector<int> A;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.push_back(q[j]);\n\t\t\t}\n\t\t\tsort(A.begin(), A.end());\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tvector<int> me;\n\t\t\tif (2*mnm+1 == mxm){\n\t\t\t\tint idx = -1;\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (a[A[j]] == mxm)\n\t\t\t\t\t\tidx = j;\n\t\t\t\tfor (int j = 0; j <= idx; j++){\n\t\t\t\t\tif (a[A[j]] == mnm)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp[++now] = A[j];\n\t\t\t\t\tme.push_back(A[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (j > idx or a[A[j]] == mnm)\n\t\t\t\t\t\tp[++now] = A[j], me.push_back(A[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tme = A;\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map> \n#define fr first\n#include<algorithm>\n#include<vector>\n#define sc second\nusing namespace std;\nconst int N=1100,inf=1e9;\nint n,k,a[N],ans[N],curlen;\ntypedef vector<int> vi;\nvoid merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1,l=0;\n\twhile(i<=len1&&j<=len2){if(x[i]<y[j])z[++l]=x[i++];else z[++l]=y[j++];}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[N], x[N], y[N], z[N], l1, l2, l3;bool vis[N];\nvi solve_ext(int exlen){l1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-exlen;i++){\n\t\t//if(vis[ans[curlen-i]])return vi(1,k+1);\n\t\tvis[ans[curlen-i]]=1;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vi(1,k+1);}\n\tint mn=inf,mx=0;\n\tfor(int i=1;i<=k;i++)mn=min(mn,b[i]),mx=max(mx,b[i]);\n\tif(mn*2>=mx){\n\t\tvi ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\n\t}else if(mn*2+1==mx){\n\t\tvi res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i]&&b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i]&&b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i]&&b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-exlen-1);i<=curlen;i++){\n\t\t\tif(b[ans[i]]==mx)p1=i;\n\t\t\tif(b[ans[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\t\t\t\n}\nbool bigger(vi a,vi b){\n\tfor(int i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;if(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\nvoid extend(){vi ext(1,k+1);\n\tfor(int exlen=1;exlen<=k&&exlen+curlen<=n;exlen++){\n\t\tint need=k-exlen;\n\t\tif(curlen-need+1>0){\n\t\t\tvi nw=solve_ext(exlen);\n\t\t\tif(bigger(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(int i=0;i<ext.size();i++)\n\t\tprintf(\"%d \",ext[i]),ans[++curlen]=ext[i],a[ext[i]]--;\n}\nbool check(){\n\tint mn=inf,mx=0;\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]),mn=min(mn,a[i]);\n\treturn mn*2>=mx;\t\n}\nint main(){//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){puts(\"-1\");return 0;}\n\twhile(curlen<n)extend();\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    if (a[1] > 0) {\n        for (int i = 1; i <= k; ++i) {\n            vs[i].insert(1);\n        }\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 10005, K = 10005;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) {\n\t\t\tlen = pre - i;\n\t\t\tbreak;\n\t\t}\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\t// if (pre == 6) debug(len);\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// for (int i = 1; i <= n; i++) debug(i), debug(b[i]);\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nll tail(vll &a, ll mx){\n\tdep(i, sz(a)-1, 0){\n\t\tif (a[i]==mx) return i;\n\t}\n\treturn -1;\n}\n\nvoid dump(vll &ans, vll &a, ll mn, ll mx){\n\tcoutv(a);\n\tcout << mn << \" \"<<mx<<'\\n';\n\tvll an=ans;\n\teach(e, an)e++;\n\tcoutv(an);\n}\n\n\nvoid solve()\n{\n\tll k;  cin >> k;\n\tvector<ll> a = cinv<ll>(k);\n\n\tll mn=MinE(a);\n\tll mx=MaxE(a);\n\tif (mx>mn*2){\n\t\tcout << -1 << '\\n'; return;\n\t}\n\n\tvll ans;\n\t//phase1\n\twhile (mx<mn*2){\n\t\trep(i, 0, k-1) ans.push_back(i);\n\t\teach(e, a) e--;\n\t\tmn--; mx--;\n\t\t//dump(ans, a, mn, mx);\n\t\tif (mx==mn*2 and a[0]==mn)break;\n\n\n\t\tans.push_back(0);\n\t\ta[0]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\t\t//dump(ans, a, mn, mx);\n\n\t\tif (mx==mn*2)break;\n\t\tif (mx>mn*2){\n\t\t\tll t=tail(a, mx);\n\t\t\trep(i, 1, t){\n\t\t\t\ta[i]--;\n\t\t\t\tans.push_back(i);\n\t\t\t}\n\t\t\tmx--;\n\t\t\t//dump(ans, a, mn, mx);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//phase2\n\twhile (a[0]>0){\n\t\tll t=tail(a, mx);\n\t\tvll fro, mid;\n\t\trep(i, 0, t){\n\t\t\tif (a[i]==mn){\n\t\t\t\tmid.push_back(i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfro.push_back(i);\n\t\t\t}\n\t\t}\n\t\trep(i, t+1, k-1){\n\t\t\tmid.push_back(i);\n\t\t}\n\t\teach(e, fro)ans.push_back(e);\n\t\teach(e, mid)ans.push_back(e);\n\t\teach(e, fro)ans.push_back(e);\n\t\t//カウントダウン\n\t\teach(e, fro)a[e]-=2;\n\t\teach(e, mid)a[e]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\t\t//dump(ans, a, mn, mx);\n\t}\n\n\teach(e, ans)e++;\n\tcoutv(ans);\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\n\tif(mn*2+1==mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tret=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n//\t\tfor(int i=1;i<=l3;i++){\n//\t\t\tcerr << z[i] << \" \";\n//\t\t}\n//\t\tputs(\"\");\n\t\tif(p1<p2)return ret;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tcerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";puts(\"\");\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n//\t\tcout << ext[i] << \" \";\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n//\tputs(\"\");\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nvoid ok()\n{\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng()\n{\n    cout << -1 << endl;\n    exit(0);\n}\n\nInt n;\nvector<Int> a(n + 1, INF);\nInt extra[110];\n\nint min_initial()\n{\n    Int mn = *min_element(a.begin(), a.end());\n    Int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        extra[i] = a[i] - mn;\n        if (extra[i] > mn)\n            return INF;\n        mx = max(mx, extra[i]);\n    }\n    if (mx <= mn)\n        return 1;\n    for (int i = 1; i <= n; i++)\n        if (extra[i] > 0)\n            return i;\n    exit(1);\n}\n\nvector<Int> ans;\nInt aa[110];\nInt cnt[1100];\nInt use[110];\n\nvoid push_min_permutation()\n{\n    Int mn = *min_element(a.begin(), a.end());\n    Int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        extra[i] = a[i] - mn;\n        if (extra[i] > mn)\n            return;\n        mx = max(mx, extra[i]);\n        use[i] = false;\n    }\n    if (mx < mn) {\n        for (int i = 1; i <= n; i++) {\n            a[i]--;\n            ans.push_back(i);\n        }\n        return;\n    }\n    int mxmx = n;\n    while (extra[mxmx] != mx)\n        mxmx--;\n    for (int i = 1; i <= mxmx; i++) {\n        if (extra[i] > 0)\n            use[i] = true;\n    }\n    for (int i = 1; i <= n; i++) {\n        a[i]--;\n        if (use[i])\n            ans.push_back(i);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!use[i])\n            ans.push_back(i);\n    }\n    return;\n}\n\nint min_initial2()\n{\n    if (ans.size() < n)\n        return INF;\n    Int mx = 0, mn = INF;\n    fill(cnt, cnt + 1001, 0);\n    for (int i = 1; i <= n; i++) {\n        aa[i] = a[i];\n        cnt[a[i]]++;\n        mx = max(mx, a[i]);\n        mn = min(mn, a[i]);\n    }\n    Int from = ans.size() - n;\n    for (int i = from; i < ans.size(); i++) {\n        cnt[aa[ans[i]]]--;\n        cnt[--aa[ans[i]]]++;\n        mn = min(mn, aa[ans[i]]);\n        if (cnt[mx] == 0)\n            mx--;\n        if (mn * 2 >= mx)\n            return ans[from];\n    }\n    return INF;\n}\n\nint main()\n{\n\n    cin >> n;\n    a.resize(n + 1, INF);\n    int as = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        as += a[i];\n    }\n\n    Int mn = *min_element(a.begin(), a.end());\n    vector<vector<Int>> block(mn);\n    for (int i = 1; i <= n; i++) {\n        extra[i] = a[i] - mn;\n        if (extra[i] > mn)\n            ng();\n    }\n    while (ans.size() < as) {\n        int initial1 = min_initial();\n        int initial2 = min_initial2();\n\n        if (initial1 < initial2) {\n            push_min_permutation();\n        }\n        else {\n            ans.push_back(initial2);\n            a[initial2]--;\n        }\n    }\n\n    for (auto elem : ans)\n        cout << elem << \" \";\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass EPermutationCover {\npublic:\n    vi solve(int k, arri a) {\n        vi p;\n        int lastPerm = 0;\n        arri last(k, -k);\n        while (true) {\n            int mx = *max_element(all(a));\n            if (mx == 0) {\n                break;\n            }\n            int minLast = p.size();\n            for (int i : range(k)) {\n                for (int j : range(k)) {\n                    if (a[i] > 2 * a[j]) {\n                        minim(minLast, last[j]);\n                    }\n                }\n            }\n            bool found = false;\n            for (int i : range(k)) {\n                if (a[i] == 0 || mx >= 2 * a[i] || last[i] > minLast) {\n                    continue;\n                }\n                bool bad = false;\n                for (int j : range(lastPerm, p.size())) {\n                    if (p[j] == i + 1) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    continue;\n                }\n                found = true;\n                last[i] = p.size();\n                a[i]--;\n                p.push_back(i + 1);\n                break;\n            }\n            if (!found) {\n                throw \"Jopa\";\n            }\n            if (*min_element(all(last)) >= p.size() - k) {\n                lastPerm = p.size();\n            }\n        }\n        return p;\n    }\n\n    void solve() {\n        int k = in.readInt();\n        auto a = in.readIntArray(k);\n\n        if (*min_element(all(a)) * 2 < *max_element(all(a))) {\n            out.printLine(-1);\n            return;\n        }\n        out.printLine(solve(k, a));\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    EPermutationCover solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n      assert(false);\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[i] <= num && num <= (a[i] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) len = pre - i;\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 1;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  while(1){\n    debug(t,res);\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    if(ma == 0)break;\n    int il = 0;\n    if(mi * 2 == ma){\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] != ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n          il++;\n          t[i]-=2;\n        }else{\n          t[i]--;\n        }\n      }\n    }else{\n      R(i,n){\n        res.PB(i);\n        t[i]--;\n      }\n    }\n    while(il < n){\n      int pom = dajmi();\n      t[res[SZ(res) - n]]--;\n      int pom2 = dajmi();\n      if(pom2 != MAX && res[SZ(res) - n] <= pom){\n        res.PB(res[SZ(res) - n]);\n        il++;\n      }else{\n        t[res[SZ(res) - n]]++;\n        break;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint k, a[105], p[1005], last[105], l=1, sat;\nbool chk(int x, int y) {\n\tif(last[x]<l) {\n\t\tif(last[y]<=sat) {\n\t\t\treturn 2*a[x]>=a[y];\n\t\t} else {\n\t\t\treturn 2*a[x]>=a[y]+1;\n\t\t}\n\t} else {\n\t\tif(last[x]<last[y])\n\t\t\treturn 2*a[x]>=a[y];\n\t\telse\n\t\t\treturn 2*a[x]+1>=a[y];\n\t}\n}\nbool check() {\n\tfor(int x=1; x<=k; ++x) {\n\t\tfor(int y=1; y<=k; ++y) {\n\t\t\tif(x==y) continue;\n\t\t\tif(!chk(x, y)) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint n=0;\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tn+=a[i];\n\t}\n\tif(!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tint &P=p[i], lsave=l;\n\t\tif(i-l==k) {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=last[P]+1;\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t\tif(i-l+1==k) sat=i;\n\t\t} else {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0 || last[P]>sat) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=std::max(l, last[P]+1);\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) printf(\"%d \", p[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 1111;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N], b[N];\nvector<int> s[N];\nbool f[N], pre[N];\nint main() {\n\tint k;\n\tscanf(\"%d\", &k);\n\tint x = 0;\n\tfor(int i = 1; i <= k; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx = max(x, a[i]);\n\t}\n\tmemcpy(b, a, sizeof(b));\n\tvector<int> aa;\n\tfor(;; x++) {\n\t\tbool flag = true;\n\t\tmemcpy(a, b, sizeof(a));\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tif(x - a[i] <= (x / 2)) {\n\n\t\t\t}else flag = false;\n\t\t}\n\t//\tcout << x << ' ' << flag << endl;\n\t\tif(!flag) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tfor(int i = 1; i < x; i++) s[i].clear();\n\t\tfor(int i = 1; i < x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(a[j] + (x - i) / 2 < x) {\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ta[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = k; j >= 1; j--) {\n\t\t\t\tif(a[j] < x && pre[j] == 0 && f[j] == 0 && !(s[i].size() == k - 1 && j == 1)) {\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\ta[j]++;\n\t\t\t\t}else if(f[j]) {\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tmemcpy(pre, f, sizeof(pre));\n\t\t}\n\t\tvector<int> ans;\n\t\tfor(int i = 1; i <= x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int k : s[i - 1]) f[k] = 1;\n\t\t\tfor(int k : s[i]) f[k] = 1;\n\t\t\tfor(int j = 1; j <= k; j++) if(!f[j]) ans.pb(j);\n\t\t\tif(i < x) {\n\t\t\t\tsort(s[i].begin(), s[i].end());\n\t\t\t\tfor(int j : s[i]) ans.pb(j);\n\t\t\t}\n\t\t}\n\t\tif(aa.empty() || ans < aa) aa = ans;\n\t}\n\tvector<int> ans;\n\tif(aa.empty()) {\n\n\t\tprintf(\"%d\\n\", -1);\n\t\treturn 0;\n\t}else ans = aa;\n\tfor(int i = 0; i < (int)ans.size(); i++) {\n\t\tprintf(\"%d%c\", ans[i], i == (int)ans.size() - 1 ? '\\n' : ' ');\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define ll long long\n\nconst int N = 303;\nconst int Q = N * 2;\nconst int mod = 998244353;\n\nusing namespace std;\n\nint n;\nint a[N];\nint b[N];\n\nbool good()\n{\n        int mn = a[1], mx = a[1];\n        for(int i = 2; i <= n; i++){\n                mn = min(mn, a[i]);\n                mx = max(mx, a[i]);\n        }\n        return mn * 2 >= mx;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        if(!good()){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n\n        while(a[1] > 0){\n                int mn = a[1], mx = a[1];\n                for(int i = 2; i <= n; i++){\n                        mn = min(mn, a[i]);\n                        mx = max(mx, a[i]);\n                }\n                vector < int > S1, S2;\n                for(int i = 1; i <= n; i++){\n                        if(a[i] == mn * 2){\n                                S1.push_back(i);\n                                b[i] = 2;\n                        } else{\n                                b[i] = 1;\n                        }\n                }\n                for(int i = 1; i <= n; i++){\n                        if(b[i] == 2){\n                                continue;\n                        }\n                        if((a[i] - 2) * 2 < mx - 1){\n                                break;\n                        }\n                        b[i] = 2;\n                        S1.push_back(i);\n                }\n                for(int i = 1; i <= n; i++) if(b[i] == 1) S2.push_back(i);\n                sort(S1.begin(), S1.end());\n                for(int x: S1) cout << x << \" \";\n                for(int x: S2) cout << x << \" \";\n                for(int x: S1) cout << x << \" \";\n                for(int i = 1; i <= n; i++) a[i] -= b[i];\n\n                assert(good());\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else if (!flag1) {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n            else {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tvi Ans;\n\t\tset<pii> S;\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=1;i<=k;i++) S.insert({H[i]-diff,-i});\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tset<pii> NS;\n\t\t\tint mn = (*S.begin()).first;\n\t\t\tif(mn==0) break;\n\t\t\tfor(auto p:S)\n\t\t\t{\n\t\t\t\tif(p.first==mn)\n\t\t\t\t{\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-1,p.second});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tD.push_back(-p.second);\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-2,p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Ans.size()==0)\n\t\t\t{\n\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t}\n\n\t\t\tS=NS;\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 2111;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N], b[N];\nvector<int> s[N];\nint k, L;\nint ans[N];\nint mm = 0;\nint f[105], cc[105], cnt[105], rmn[N], pos[N];\nbool check(int ed) {\n\tfor(int i = 1; i <= k; i++) {\n\t\trmn[i] = a[i] - cc[i] - (ans[ed] == i);\n\t\tif(rmn < 0) return false;\n\t}\n\tmemset(f, 0, sizeof(f));\n\tmemset(cnt, 0, sizeof(cnt));\n\tcnt[0] = k;\n\tif(ed - mm > k) return false;\n\tint mx = 0;\n\tmemset(f, 0, sizeof(f));\n\tfor(int i = ed; i >= 1; i--) {\n\t\tf[ans[i]]++;\n\t\tif(f[ans[i]] == 2) {mx = i; break; }\n\t}\n\tif(mx > mm) return false;\n\tmemset(f, 0, sizeof(f));\n\tfor(int i = mx + 1; i <= ed; i++) {\n\t\tf[ans[i]]++;\n\t\tpos[ans[i]] = i;\n\t\trmn[ans[i]]++;\n\t}\n//\tprintf(\"try a[%d] = %d\\n\", ed, ans[ed]);\n//\tcout << ed << ' ' << mx << ' ' << mm << endl;\n\tint x = 0;\n\tfor(int i = 1; i <= k; i++) x = max(x, rmn[i]);\n\tfor(int i = 1; i <= k; i++) {\n\t\tif(x - rmn[i] > x / 2) return false;\n\t}\n\t//cout << '?' << endl;\n\tfor(int j = mx + 2; j <= ed + 1; j++) {\n\t\tbool flag = true;\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tif((f[i] && pos[i] >= j || !f[i] && j != ed + 1) && x == rmn[i]) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tif(f[i] && pos[i] < j && x % 2 == 0 && x - rmn[i] == x / 2) flag = false;\n\t\t}\n\t\tif(flag) return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint x = 0;\n\tL = 0;\n\tfor(int i = 1; i <= k; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx = max(x, a[i]);\n\t\tL += a[i];\n\t}\n\tmemcpy(b, a, sizeof(b));\n\tvector<int> aa;\n\tfor(int i = 1; i <= L; i++) {\n\t\tbool flag = false;\n\t\tfor(int j = 1; j <= k; j++) {\n\t\t\tans[i] = j;\n\t\t\tif(check(i)) {\n\t\t\t//\tprintf(\"%d!%d\\n\", i, ans[i]);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcc[ans[i]]++;\n\t\tif(i >= k) {\n\t\t\tmemset(cnt, 0, sizeof(cnt));\n\t\t\tfor(int j = 1; j <= k; j++) cnt[ans[i - j + 1]]++;\n\t\t\tbool flag = true;\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(cnt[j] == 0) flag = false;\n\t\t\t}\n\t\t\tif(flag == true) mm = i;\n\t\t}\n\t\tif(!flag) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i <= L; i++) {\n\t\tprintf(\"%d%c\", ans[i], i == L ? '\\n' : ' ');\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010;\nint n, a[maxn], id[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0;i < n;++i)\n\t\tcin >> a[i];\n\tiota(id, id+n, 0);\n\tsort(id, id+n, [&](int x, int y) {\n\t\treturn a[x] > a[y];\n\t});\n\tif (a[id[n-1]] * 2 < a[id[0]])\n\t\treturn puts(\"-1\"), 0;\n\tvector<int> res;\n\tfor (int l = 1, r = a[id[0]];l <= a[id[n-1]];++l) {\n\t\tfor (int i = 0;i < n;++i)\n\t\t\tres.pb(id[i]);\n\t\tif (r > l) {\n\t\t\tfor (int i = 0;i < n;++i)\n\t\t\t\tif (a[id[i]] >= r)\n\t\t\t\t\tres.pb(id[i]);\n\t\t\t--r;\n\t\t}\n\t}\n\tfor (int i = 0;i < res.size();++i)\n\t\tcout << res[i] +1 << \" \\n\"[i+1==res.size()];\n\t\t\t\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 < *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n\n    unsigned long N{accumulate(begin(a), end(a), 0UL)};\n    unsigned long upb{N / (K + 1)}, lwb{(N + 2 * K - 2) / (2 * K - 1)};\n\n    vector<unsigned long> ans(N, K + 1);\n    for(unsigned long i{lwb}; i <= upb; ++i)[&]{\n        vector<unsigned long> yobun(K);\n        for(unsigned long j{0}; j < K; ++j){\n            if(a[j] < i)return;\n            if(a[j] > 2 * i)return;\n            yobun[j] = a[j] - i;\n        }\n        vector<unsigned long> tmp(N);\n        unsigned long now{0};\n        for(unsigned long j{0}; j < i; ++j){\n            vector<unsigned long> mae, naka;\n            for(unsigned long k{0}; k < K; ++k){\n                if(yobun[k] == 0)naka.push_back(k);\n                else if(yobun[k] == (i - j)){\n                    mae.push_back(k);\n                    --yobun[k];\n                }\n                else if(naka.empty()){\n                    mae.push_back(k);\n                    --yobun[k];\n                }\n                else naka.push_back(k);\n            }\n            copy(begin(mae), end(mae), begin(tmp) + now);\n            now += mae.size();\n            copy(begin(naka), end(naka), begin(tmp) + now);\n            now += naka.size();\n            copy(begin(mae), end(mae), begin(tmp) + now);\n            now += mae.size();\n        }\n        if(ans > tmp){\n            copy(begin(tmp), end(tmp), begin(ans));\n        }\n    }();\n\n    for(const auto& i : ans)cout << i + 1 << \" \";\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // 特殊形(単調増加)\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  vector<int> nie(n);\n  int ilnie = 0;\n  while(1){\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    debug(ilnie);\n    \n    vector<int> zle(n);\n    R(i,n){\n      if(t[i] * 2 < ma){\n        zle[i] = 1;\n      }\n    }\n    int naj = 0;\n    R(i,min(SZ(res),n)){\n      if(zle[res[SZ(res) - i - 1]]){\n        naj = i;\n      }\n    }\n    R(i,naj){\n      zle[res[SZ(res) - i - 1]] = 1;\n    }\n    \n    \n    if(ma == 0)break;\n    R(i,n)if(!nie[i] && t[i] * 2 > ma && t[i] && !zle[i]){\n      debug(ma,t[i],i);\n      res.PB(i);\n      t[i]--;\n      nie[i] = 1;\n      ilnie++;\n      goto ok;\n    }\n    debug(res);\n    assert(0);\n    ok:;\n    if(SZ(res) >= n){\n      vector<int> cz(n);\n      bool nope = 0;\n      R(i,n){\n        if(cz[res[SZ(res) - i - 1]]){\n          nope = 1;\n          break;\n        }\n        cz[res[SZ(res) - i - 1]] = 1;\n      }\n      if(!nope){\n        ilnie = 0;\n        R(i,n)nie[i] = 0;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"[DEBUG] \");W(__VA_ARGS__);}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1<<10;\nint a[101],n,K,now[101];\nint an[SIZE];\nint u[SIZE],tt;\nint u2[SIZE],tt2;\nbool invalid(int id,int rr){\n    tt2++;\n    int v=0;\n    int it;\n    for(it=id;it<=rr;it++){\n        if(u2[an[it]]==tt2)break;\n        u2[an[it]]=tt2;\n        v++;\n    }\n    if(v==K)return 0;\n    for(int i=id-1;i>=0;i--){\n        if(u2[an[i]]==tt2){\n            bool suc=0;\n            while(it>id+1){\n                it--;\n                u2[an[it]]=0;\n                v--;\n                if(an[it]==an[i]){\n                    suc=1;\n                    break;\n                }\n            }\n            if(!suc)return 1;\n        }\n        v++;\n        u2[an[i]]=tt2;\n        if(v==K)return 0;\n    }\n    return 1;\n}\nbool valid(int sep_pos){\n    tt++;\n    int ll=sep_pos;\n    for(int i=0;i<=sep_pos&&i<K;i++){\n        if(u[an[sep_pos-i]]==tt) break;\n        u[an[sep_pos-i]]=tt;\n        ll=sep_pos-i;\n    }\n    if(ll){\n        if(invalid(ll-1,sep_pos))return 0;\n    }\n    memcpy(now,a,sizeof(int)*(K+1));\n    int mi=1001,ma=-1;\n    int ma_cnt=0;\n    FOR(i,1,K){\n        if(u[i]!=tt){\n            if(!now[i])return 0;\n            now[i]--;\n        }\n        mi=min(mi,now[i]);\n        if(ma<now[i]){\n            ma=now[i];\n            ma_cnt=1;\n        }\n        else if(ma==now[i]){\n            ma_cnt++;\n        }\n    }\n    if(mi*2>=ma)return 1;\n    FOR(i,ll,sep_pos){\n        int x=an[i];\n        if(!now[x])return 0;\n        if(now[x]==ma){\n            ma_cnt--;\n        }\n        now[x]--;\n        mi=min(mi,now[x]);\n        if(mi*2>=ma-(ma_cnt==0))return 1;\n    }\n    FOR(i,1,K){\n        if(u[i]!=tt&&now[i]==ma){\n            ma_cnt--;\n            if(mi*2>=ma-(ma_cnt==0))return 1;\n        }\n    }\n    return 0;\n}\nvoid solve() {\n    R(K);\n    FOR(i,1,K){\n        R(a[i]);\n        n+=a[i];\n    }\n    if(*max_element(a+1,a+1+K)>2*(*min_element(a+1,a+1+K))){\n        W(-1);\n        return;\n    }\n    REP(i,n){\n        FOR(j,1,K){\n            if(a[j]){\n                a[j]--;\n                an[i]=j;\n                if(valid(i))break;\n                a[j]++;\n            }\n        }\n    }\n    W(VI(an,an+n));\n}\nint main(){\n#define MULTITEST 0\n#if MULTITEST    \n    CASET{\n        solve();\n    }\n#else\n    solve();\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>0){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvector<int> ori;\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)ori.push_back(i);\n\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint num = 10000;\n\trep(i, n)num = min(num, a[i]);\n\trep(i, n)if (a[i] > 2 * num) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tvector<vector<int>> ads(num);\n\trep(i, n) {\n\t\tint ad = a[i] - num;\n\t\trep(j, ad) {\n\t\t\tads[num - 1 - j].push_back(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(i, num) {\n\t\tint memo = ans.size();\n\t\tfor (int ad : ads[i]) {\n\t\t\tans.push_back(ad);\n\t\t}\n\t\tint las = 0;\n\t\trep(j, ads[i].size()) {\n\t\t\tvector<int> v;\n\t\t\tint g = memo + j;\n\t\t\tbool valid = false;\n\t\t\tif (g >= n - 1) {\n\t\t\t\trep(t, n) {\n\t\t\t\t\tv.push_back(ans[g - t]);\n\t\t\t\t}\n\t\t\t\tsort(all(v));\n\t\t\t\tif (v == ori)valid = true;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tlas++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvector<bool> skip(n,false);\n\t\trep(j, ads[i].size()) {\n\t\t\tif (j >= las)skip[ads[i][j]] = true;\n\t\t}\n\t\trep(i, n)if (!skip[i])ans.push_back(i);\n\t\trep(i, n)if (skip[i])ans.push_back(i);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:45:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  {\n    int mn = *min_element(a.begin(), a.end());\n    int mx = *max_element(a.begin(), a.end());\n    if (2 * mn < mx) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  vector<int> b(n);\n  auto Can = [&]() {\n//    debug(a, b);\n    vector<int> c(n);\n    int mn = 787788;\n    int mx = -787788;\n    for (int i = 0; i < n; i++) {\n      if (b[i] == 0) {\n        c[i] = -1;\n        mn = min(mn, a[i] - 1);\n        mx = max(mx, a[i] - 2);\n      } else {\n        c[i] = a[i] - b[i];\n        mn = min(mn, c[i]);\n        mx = max(mx, c[i]);\n      }\n    }\n    if (mn < 0 || mx < 0 || 2 * mn < mx) {\n      return false;\n    }\n    return true;\n  };\n  auto One = [&]() {\n    if (*max_element(a.begin(), a.end()) == 0) {\n      return vector<int>();\n    }\n    int pos = 0;\n    while (true) {\n      for (int i = pos; i < n; i++) {\n        b[i] = 1;\n      }\n      if (Can()) {\n        break;\n      }\n      for (int i = pos; i < n; i++) {\n        b[i] = 0;\n      }\n      bool found = false;\n      for (int i = pos; i < n; i++) {\n        b[i] = 2;\n        if (Can()) {\n          pos = i + 1;\n          found = true;\n          break;\n        }\n        b[i] = 1;\n      }\n      assert(found);\n    }\n    vector<int> ter;\n    for (int x : {2, 1, 2}) {\n      for (int i = 0; i < n; i++) {\n        if (b[i] == x) {\n          ter.push_back(i);\n        }\n      }\n    }\n    return ter;\n  };\n  vector<int> ret;\n  while (*max_element(a.begin(), a.end()) > 0) {\n    bool done = false;\n    vector<int> best;\n    int bcut = -1;\n    for (int cut = 1; cut < n; cut++) {\n      for (int i = 0; i < cut; i++) {\n        b[i] = 2;\n      }\n      for (int i = cut; i < n; i++) {\n        b[i] = 1;\n      }\n      if (Can()) {\n        auto bb = b;\n        for (int i = 0; i < n; i++) {\n          a[i] -= bb[i];\n        }\n        auto help = One();\n        for (int i = 0; i < n; i++) {\n          a[i] += bb[i];\n        }\n        vector<int> cur;\n        for (int i = 0; i < n; i++) {\n          cur.push_back(i);\n        }\n        for (int i = 0; i < cut; i++) {\n          cur.push_back(i);\n        }\n        for (int x : help) {\n          cur.push_back(x);\n        }\n        debug(cut, cur);\n        if (best.empty() || cur < best) {\n          best = cur;\n          bcut = cut;\n        }\n      }\n    }\n    if (bcut != -1) {\n      for (int i = 0; i < bcut; i++) {\n        b[i] = 2;\n      }\n      for (int i = bcut; i < n; i++) {\n        b[i] = 1;\n      }\n      done = true;\n    }\n    if (!done) {\n      fill(b.begin(), b.end(), 0);\n      int pos = 0;\n      while (true) {\n        for (int i = pos; i < n; i++) {\n          b[i] = 1;\n        }\n        if (Can()) {\n          break;\n        }\n        for (int i = pos; i < n; i++) {\n          b[i] = 0;\n        }\n        bool found = false;\n        for (int i = pos; i < n; i++) {\n          b[i] = 2;\n          if (Can()) {\n            pos = i + 1;\n            found = true;\n            break;\n          }\n          b[i] = 1;\n        }\n        assert(found);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      a[i] -= b[i];\n    }\n    for (int x : {2, 1, 2}) {\n      for (int i = 0; i < n; i++) {\n        if (b[i] == x) {\n          ret.push_back(i);\n        }\n      }\n    }\n  }\n  int sz = (int) ret.size();\n  vector<int> was(n, 0);\n  bool changed = true;\n  while (changed) {\n    changed = false;\n    for (int i = 0; i < sz - 1; i++) {\n      if (ret[i] > ret[i + 1]) {\n        swap(ret[i], ret[i + 1]);\n        for (int j = 0; j < n; j++) {\n          was[j] = 0;\n        }\n        bool ok = true;\n        int R = -1;\n        for (int j = 0; j < n; j++) {\n          if (was[ret[j]] == 1) {\n            ok = false;\n            break;\n          }\n          was[ret[j]] = 1;\n        }\n        int zeros = 0;\n        if (ok) {\n          R = n - 1;\n          for (int j = n; j < sz; j++) {\n            --was[ret[j - n]];\n            if (was[ret[j - n]] == 0) {\n              ++zeros;\n            }\n            if (was[ret[j]] == 0) {\n              --zeros;\n            }\n            ++was[ret[j]];\n            if (zeros == 0) {\n              int nL = j - n + 1;\n              int nR = j;\n              if (nL > R + 1) {\n                ok = false;\n                break;\n              }\n              R = nR;\n            }\n          }\n          if (R < sz - 1) {\n            ok = false;\n          }\n        }\n        if (ok) {\n          changed = true;\n        } else {\n          swap(ret[i], ret[i + 1]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < (int) ret.size(); i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << ret[i] + 1;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\nint pst=0;\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>pst){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tpst=curlen;\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nvoid ok()\n{\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng()\n{\n    cout << -1 << endl;\n    exit(0);\n}\n\nstruct Trie {\n    map<Int, Trie *> edge;\n    bool exist = false;\n};\n\nbool used[110];\n\nInt n;\nvector<Int> ans;\n\nint main()\n{\n\n    cin >> n;\n    vector<Int> a(n + 1, INF);\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n\n    Int mn = *min_element(a.begin(), a.end());\n    vector<vector<Int>> block(mn);\n    for (int i = 1; i <= n; i++) {\n        if (a[i] - mn > mn)\n            ng();\n        for (int j = 0; j < a[i] - mn; j++) {\n            block[j].push_back(i);\n        }\n    }\n\n    sort(block.begin(), block.end());\n\n    for (auto b : block) {\n        for (auto elem : b) {\n            used[elem] = true;\n            ans.push_back(elem);\n        }\n        for (int i = 1; i <= n; i++) {\n            if (!used[i])\n                ans.push_back(i);\n        }\n        for (auto elem : b) {\n            used[elem] = false;\n            ans.push_back(elem);\n        }\n    }\n    for (auto elem : ans)\n        cout << elem << \" \";\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>  \n#include <complex>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 998244353;\ndouble eps = 1e-12;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e18\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n \nll mpow(ll a, ll b){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2);\n\tt1 *= t1;\n\tt1 %= MOD;\n\tif(b%2) t1 *= a;\n\tt1 %= MOD;\n\treturn t1;\n}\n \nll mpow(ll a, ll b, ll p){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2,p);\n\tt1 *= t1;\n\tt1 %= p;\n\tif(b%2) t1 *= a;\n\tt1 %= p;\n\treturn t1;\n}\n \nll modinverse(ll a, ll m){\n\tll m0 = m; \n    ll y = 0, x = 1; \n    if (m == 1) return 0; \n    while (a > 1){\n        ll q = a / m; \n        ll t = m; \n        m = a % m, a = t; \n        t = y; \n        y = x - q * y; \n        x = t; \n    }\n    if (x < 0) x += m0; \n    return x; \n}\n\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n \nll range(ll l, ll r){\n\treturn l + mt()%(r-l+1);\n}\n \nll rev(ll v){\n\treturn mpow(v,MOD-2);\n}\n\nvoid solve(){\n\tll n;\n\tcin >> n;\n\tll a[n];\n\tll mn = 1000;\n\tforn(i,n){\n\t\tcin >> a[i];\n\t\tmn = min(mn,a[i]);\n\t}\n\tv64 arr[mn];\n\tll st = mn;\n\trforn(i,n-1){\n\t\tif(a[i]>2*mn){\n\t\t\tcout << -1 << ln;\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tst = min(st,2*mn-a[i]);\n\t\t\tif(i==0) st=0;\n\t\t\tforsn(j,st,st+a[i]-mn) arr[j].pb(i);\n\t\t}\n\t}\n\tforn(i,mn){\n\t\tv64 pr(n,0);\n\t\trforn(j,sz(arr[i])-1){\n\t\t\tcout << arr[i][j]+1 << \" \";\n\t\t\tpr[arr[i][j]]=1;\n\t\t}\n\t\tforn(j,n) if(!pr[j]) cout << j+1 << \" \";\n\t\trforn(j,sz(arr[i])-1){\n\t\t\tcout << arr[i][j]+1 << \" \";\n\t\t}\n\t}\n\tcout << ln;\n}\n \nint main()\n{\n\tfast_cin();\n    ll t=1;\n    // cin >> t;\n    forn(i,t) {\n    \t// cout << \"Case #\" << i+1 << \": \";\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,cnt,a[1111],k[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  while (cnt--) {\n    for (i=0; i<n; i++) printf(\"%d \",k[i]);\n    for (i=0; i<n; i++) if (a[k[i]]>0) {\n      --a[k[i]];\n      printf(\"%d \",k[i]);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, deque<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\n\n\n\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  li n; cin>>n;\n  vi A(n); for(li i = 0; i < (li)(n); ++i) cin>>A[i];\n\n  vi I(n); iota(begin(I), end(I), 0);\n  sort(begin(I), end(I), [&](int i, int j) { return A[i] < A[j]; });\n\n  if(A[I[0]] > 2*A[I[n-1]]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int m = A[I[0]];\n  vector<vi> V(2*m);\n  for(li i = 0; i < (li)(n); ++i) {\n    if(i < I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*j+1].push_back(i);\n    } else if(i > I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j+1].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*m - 2*j - 2].push_back(i);\n    }\n  }\n\n  for(li i = 0; i < (li)(m); ++i) {\n    vector<int> seen1(n);\n    for(int a : V[2*i+1]) seen1[a] = 1;\n    vector<int> seen2(n);\n    for(int a : V[2*i]) seen2[a] = 1;\n    vi v2, w2, v1, w1;\n    for(int a : V[2*i]) if(seen1[a]) v1.push_back(a); else w1.push_back(a);\n    for(int a : V[2*i+1]) if(seen2[a]) v2.push_back(a); else w2.push_back(a);\n\n    sort(begin(v1), end(v1));\n    sort(begin(w1), end(w1));\n    sort(begin(v2), end(v2));\n    sort(begin(w2), end(w2));\n\n    for(int x : v1) cout << x+1 << ' ';\n    for(int x : w1) cout << x+1 << ' ';\n    cout << I[0]+1 << ' ';\n    for(int x : w2) cout << x+1 << ' ';\n    for(int x : v2) cout << x+1 << ' ';\n  }\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repn(i, n) for(int i=1;i<=n;i++)\n\nint n, k, a[105], b[105], ans[1005], mn=100000, mx=-100000;\nint main(){\n\tcin >> k;\n\trepn(i, k){\n\t\tcin >> a[i];\n\t\tn += a[i];\n\t\tmn = min(mn, a[i]);\n\t\tmx = max(mx, a[i]);\n\t}\n\tif(2*mn < mx){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tint las = 0;\n\trepn(id, n){\n\t\trepn(i, k){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tbool OK = 0;\n\t\t\tfor(int add=0;;add++){\n\t\t\t\tif(n-id < add || add+id-las > k) break;\n\t\t\t\tmemcpy(b, a, sizeof(a));\n\t\t\t\tb[i]--;\n\t\t\t\tbool ex[105] = {};\n\t\t\t\tfor(int x=id+add-k+1;x<id;x++) ex[ans[x]] = 1;\n\t\t\t\tex[i] = 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\trepn(x, k){\n\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\tcnt++; if(a[x] == 0) cnt++; b[x]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt != add) continue;\n\t\t\t\tif(n-id-add <= k){\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] > 1) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\t\tif(b[x] == 0) b[x]++;\n\t\t\t\t\t\t\t\telse bad = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(b[v] >= 1) break;\n\t\t\t\t\t\t\telse b[v]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k) if(b[x] != 1) bad = 1;\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmn = 100000, mx = -100000;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tmn = min(mn, b[x]);\n\t\t\t\t\t\tmx = max(mx, b[x]);\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn >= mx){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn+1 < mx){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbool need[105] = {};\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] == mx) need[x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\tif(need[x] == 1) bad = 1;\n\t\t\t\t\t\t\tneed[x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(need[v]) break;\n\t\t\t\t\t\t\tneed[v] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!need[x] && mn == b[x]) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t\t\tans[id] = i;\n\t\t\t\tif(id >= k){\n\t\t\t\t\tunordered_set<int>S;\n\t\t\t\t\tfor(int i=id-k+1;i<=id;i++) S.insert(ans[i]);\n\t\t\t\t\tif(S.size() == k) las = id;\n\t\t\t\t}\n\t\t\t\ta[i]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans[id] << ' ';\n\t}\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    if (a[1] > 0) {\n        for (int i = 1; i <= k; ++i) {\n            for (int j = cr; j >= cl; --j) {\n                if (a[i] == 0) {\n                    cl = j + 1;\n                    break;\n                }\n                --a[i];\n                vs[j].insert(i);\n            }\n        }\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    vector<int> two, one;\n    int min = A[0].first;\n    for (int i = 0; i < K; ++i) {\n      if (min * 2 == A[i].first) {\n        two.push_back(A[i].second);\n        A[i].first -= 2;\n      } else {\n        A[i].first -= 1;\n        one.push_back(A[i].second);\n      }\n    }\n    sort(two.begin(), two.end());\n    sort(one.begin(), one.end());\n    for (int x : two) cout << x + 1 << ' ';\n    for (int x : one) cout << x + 1 << ' ';\n    for (int x : two) cout << x + 1 << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nbool validarray(vector<int>& a) {\n\tint mi = mod, ma = 0;\n\trep(i, a.size()) {\n\t\tif (a[i] < 0)return false;\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\treturn ma <= mi * 2;\n}\n\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\tif (!validarray(a)) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tint sum = 0;\n\trep(i, k)sum += a[i];\n\n\tint las = 0;\n\tvector<int> ans;\n\trep(i, sum) {\n\t\tvector<bool> b(k);\n\t\tfor (int j = las; j < ans.size(); j++) {\n\t\t\tb[ans[j]] = true;\n\t\t}\n\t\tint chk = -1;\n\t\tvector<bool> b2(k);\n\t\trep(j, k) {\n\t\t\tbool valid = false;\n\t\t\tif (b[j])continue;\n\t\t\tb2 = b;\n\t\t\tb2[j] = true;\n\t\t\tfor (int ex = 0; ex <= k; ex++) {\n\t\t\t\tif (las - ex < 0)break;\n\t\t\t\tif (ex > 0) {\n\t\t\t\t\tif (b2[ans[las - ex]])break;\n\t\t\t\t\tb2[ans[las - ex]] = true;\n\t\t\t\t}\n\n\n\t\t\t\t//cout << \"?! \" << i << \" \" << j <<\" \"<<ex<< \"\\n\";\n\t\t\t\tvector<int> cop = a;\n\n\t\t\t\tvector<int> cs;\n\t\t\t\tfor (int loc = las - ex; loc < ans.size();loc++)cs.push_back(ans[loc]);\n\t\t\t\tcs.push_back(j); cop[j]--;\n\n\t\t\t\tvector<P> v;\n\t\t\t\trep(x, k)if (!b2[x]) {\n\t\t\t\t\tv.push_back({ a[x],x });\n\t\t\t\t}\n\t\t\t\tsort(all(v), greater<P>());\n\t\t\t\tfor (P p : v) {\n\t\t\t\t\tcs.push_back(p.second);\n\t\t\t\t\tcop[p.second]--;\n\t\t\t\t}\n\t\t\t\tint mi = mod;\n\t\t\t\trep(x, k)mi = min(mi, cop[x]);\n\t\t\t\tif (mi < 0)continue;\n\n\t\t\t\tint pre = 0;\n\t\t\t\trep(x, k) {\n\t\t\t\t\tif (cop[cs[x]] > 2 * mi) {\n\t\t\t\t\t\tfor (int y = pre; y <= x; y++) {\n\t\t\t\t\t\t\tcop[cs[y]]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpre = x + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (validarray(cop)) {\n\t\t\t\t\tvalid = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tchk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << chk+1 << \" \"<<las<<\"\\n\";\n\t\tassert(chk >= 0);\n\t\tans.push_back(chk);\n\t\ta[chk]--;\n\t\tif (ans.size() >= k) {\n\t\t\tvector<int> cnt(k, 0);\n\t\t\trep(j, k) {\n\t\t\t\tcnt[ans[ans.size() - 1 - j]]++;\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tif (valid) {\n\t\t\t\tlas = ans.size();\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint k;\n\tcin >> k;\n\tvector<int> freq(k);\n\tfor(int& x : freq) cin >> x;\n\tint minv = 1000000, maxv = -1;\n\tfor(int x : freq){\n\t\tminv = min(minv, x); maxv = max(maxv, x);\n\t}\n\tint sum = 0;\n\tfor(int x : freq) sum += x;\n\tif(minv * 2 < maxv){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> ans;\n\tint maxworks = 0;\n\twhile((int)ans.size() < sum){\n\t\tbool found = false;\n\t\tfor(int nxt = 0; nxt < k; nxt++){\n\t\t\tvector<int> cans = ans;\n\t\t\tcans.push_back(nxt);\n\t\t\tint cmaxworks = maxworks;\n\t\t\t{\n\t\t\t\tif((int)cans.size() >= k){\n\t\t\t\t\tvector<int> d(k, 0);\n\t\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\t\td[cans[(int)cans.size() - 1 - i]]++;\n\t\t\t\t\t}\n\t\t\t\t\tbool works = true;\n\t\t\t\t\tfor(int i = 0; i < k; i++) if(!d[i]) works = false;\n\t\t\t\t\tif(works) cmaxworks = (int)cans.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cfreq = freq;\n\t\t\tcfreq[nxt]--;\n\t\t\tif(cfreq[nxt] < 0) continue;\n\t\t\tvector<int> known;\n\t\t\tfor(int f = cmaxworks; f < (int)cans.size(); f++) known.push_back(cans[f]);\n\t\t\tvector<int> zk = known;\n\t\t\tsort(zk.begin(), zk.end());\n\t\t\tif(unique(zk.begin(), zk.end()) != zk.end()) continue;\n\t\t\tbool ok = false;\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\treverse(known.begin(), known.end());\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t\treverse(known.begin(), known.end());\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t}\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tfor(int b = cmaxworks - 1; b >= 0; b--){\n\t\t\t\t\tif(cur[cans[b]]) break;\n\t\t\t\t\tcur[cans[b]] = 1;\n\t\t\t\t\tint a = cans[b];\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tint minval = 1000000;\n\t\t\t\tfor(int b : dfreq) minval = min(minval, b);\n\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\tif(cur[i]) continue;\n\t\t\t\t\tif(dfreq[i] > 2 * minval){\n\t\t\t\t\t\tdfreq[i]--;\n\t\t\t\t\t\tcur[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ming = 100000, maxg = 0;\n\t\t\t\tfor(int b : dfreq) ming = min(ming, b);\n\t\t\t\tfor(int b : dfreq) maxg = max(maxg, b);\n\t\t\t\tif(ming * 2 >= maxg){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(nxt);\n\t\t\t\tmaxworks = cmaxworks;\n\t\t\t\tfound = true;\n\t\t\t\tfreq[nxt]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for(int b : ans) cerr << b << ' ';\n\t\t// cerr << '\\n';\n\t\tassert(found);\n\t}\n\tfor(int b : ans) cout << b+1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint K,sum;\nvi _A,sol;\n\nint getSum(vi v) {\n\tint res = 0; trav(t,v) res += t;\n\treturn res;\n}\n\nbool initial(vi v) {\n\tvi A = _A; vector<bool> con(K);\n\t//dbg(\"OOPS\",sz(A),K);\n\ttrav(t,v) A[t] ++, con[t] = 1;\n\tint lef = getSum(A); assert(lef >= K);\n\tint l = MOD, r = -MOD;\n\ttrav(t,A) ckmin(l,t), ckmax(r,t);\n\tint lo = cdiv(lef,K), hi = lef/K*2;\n\tdbg(\"UHOH\",lef,v);\n\tFOR(num,lo,hi+1) {\n\t\tint LO = (num+1)/2, HI = num;\n\t\tif (LO <= l && r <= HI) {\n\t\t\tif (num == 1 || LO < l || r < HI) return 1;\n\t\t\tbool bad = 0, flag = 0;\n\t\t\ttrav(t,v) {\n\t\t\t\tflag |= A[t] == LO;\n\t\t\t\tif (A[t] == HI && flag) {\n\t\t\t\t\tbad = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tF0R(i,K) if (!con[i] && A[i] == HI) {\n\t\t\t\t\tbad = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bad) {\n\t\t\t\tdbg(\"OK\",num,LO,HI);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\t/*vi con(K);\n\ttrav(t,v) {\n\t\tassert(!con[t]);\n\t\tcon[t] = 1;\n\t}\n\tF0R(i,K) if (!con[i]) {\n\t\tif (!A[i]) return 0;\n\t\tv.pb(i); A[i] --;\n\t}\n\tFOR(nex,1,K+1) {\n\n\t}\n\tdbg(\"AH\",v,A); exit(0);*/\n}\n\nbool ok() {\n\tvi cnt(K); int ok = 0;\n\tvi cool(sz(sol)+1);\n\tauto ad = [&](int r, int inc) {\n\t\tr = sol[r];\n\t\tok -= cnt[r] == 1;\n\t\tcnt[r] += inc;\n\t\tok += cnt[r] == 1;\n\t};\n\tint r = -1;\n\tF0R(l,sz(sol)-K+1) {\n\t\twhile (r < l+K-1) ad(++r,1);\n\t\tif (ok == K) cool[l] ++, cool[r+1] --;\n\t\tad(l,-1);\n\t}\n\tFOR(i,1,sz(sol)+1) cool[i] += cool[i-1];\n\tint fst = 0; while (cool[fst]) fst ++;\n\tif (sz(sol) == sum)  return fst == sum;\n\tcnt = vi(K);\n\tFOR(i,fst,sz(sol)) if (cnt[sol[i]]++) return 0;\n\tdbg(\"HA\",fst,sol);\n\t// fst to sz(sol)-1\n\tfor (int i = fst; i+K >= sz(sol); --i) {\n\t\t//dbg(\"TRYING\",i);\n\t\tif (i+K <= sum && initial(vi(begin(sol)+i,end(sol)))) return 1;\n\t\tif (i == 0) break;\n\t\tif (cnt[sol[i-1]]++) break;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tsetIO(); re(K); _A.rsz(K); re(_A);\n\ttrav(t,_A) sum += t;\n\tif (!ok()) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\twhile (sz(sol) < sum) {\n\t\tdbg(\"SOL\",sol);\n\t\tbool done = 0;\n\t\tF0R(i,K) if (_A[i]) { // K*sum\n\t\t\t_A[i] --; sol.pb(i);\n\t\t\tif (ok()) { done = 1; break; }\n\t\t\t_A[i] ++; sol.pop_back();\n\t\t}\n\t\tassert(done);\n\t}\n\ttrav(t,sol) pr(t+1,' ');\n\tps();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n        }\n        if (flag[i] && flag[j]) {\n            //if (j < K-1) {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            //}\n            //else {\n                //if (li < lj) flag[i] = false;\n                //else flag[j] = false;\n            //}\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    for (int i = 0; i < a[1]; ++i) {\n        vs[i].insert(1);\n    }\n    if (a[1] > 0) {\n        for (int i = 2; i <= k; ++i) {\n            if (a[i] > 0) {\n                --a[i];\n                vs[a[1] - 1].insert(i);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; a[i] > 0; ++ind) {\n                    --a[i];\n                    vs[ind].insert(i);\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tvi Ans;\n\t\tset<pii> S;\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=1;i<=k;i++) S.insert({H[i]-diff,-i});\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tset<pii> NS;\n\t\t\tint min = (*S.begin()).first;\n\t\t\tif(min==0) break;\n\t\t\tfor(auto p:S)\n\t\t\t{\n\t\t\t\tif(p.first==min)\n\t\t\t\t{\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-1,p.second});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tD.push_back(-p.second);\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-2,p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tS=NS;\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\nconst int N = 1e3 + 5;\nint _w;\n\nint dat[N] , n , m , _mx , _mn , ans[N] , cur , vis[N] , vis_t;\nVI inf;\n\nVI solve( int len ) {\n  static int dat[N];\n  if( cur + len - n < 0 ) return inf;\n  if( cur + len > m ) return inf;\n  _mx = 0 , _mn = 0x3f3f3f3f , ++vis_t;\n  memcpy( dat + 1 , ::dat + 1 , sizeof( int ) * n );\n  for( int i = cur + len - n + 1 ; i <= cur ; ++i ) vis[ans[i]] = vis_t;\n  for( int i = 1 ; i <= n ; ++i ) {\n    if( vis[i] ^ vis_t ) {\n      if( dat[i] == 0 ) return inf;\n      --dat[i];\n    }\n    _mx = max( _mx , dat[i] );\n    _mn = min( _mn , dat[i] );\n  }\n  if( _mn * 2 + 1 < _mx ) return inf;\n  if( _mn * 2 >= _mx ) {\n    VI res;\n    for( int i = 1 ; i <= n ; ++i ) if( vis[i] ^ vis_t ) res.push_back( i );\n    return res;\n  }\n  VI a , b , c;\n  for( int i = 1 ; i <= n ; ++i ) if( (vis[i]^vis_t) && dat[i] == _mx ) a.push_back( i );\n  for( int i = 1 ; i <= n ; ++i ) if( (vis[i]^vis_t) && dat[i] == _mn ) a.push_back( i );\n  for( int i = 1 ; i <= n ; ++i ) if( (vis[i]^vis_t) && (dat[i]^_mn) && (dat[i]^_mx) ) b.push_back( i );\n  int p = 0 , q = 0;\n  while( p < a.size() && q < b.size() ) \n    if( a[p] < b[q] ) c.push_back( a[p++] );\n    else c.push_back( b[q++] );\n  while( p < a.size() ) c.push_back( a[p++] );\n  while( q < b.size() ) c.push_back( b[q++] );\n  int fi = 0 , se = 0;\n  for( int i = cur + len - n + 1 ; i <= cur ; ++i ) {\n    if( dat[ans[i]] == _mn && !se ) se = i;\n    if( dat[ans[i]] == _mx ) fi = i;\n  }\n  for( int i = 0 ; i < c.size() ; ++i ) {\n    if( dat[c[i]] == _mn && !se ) se = i + cur + 1;\n    if( dat[c[i]] == _mx ) fi = i + cur + 1;\n  }\n  if( fi > se ) return inf;\n  return c;\n}\n\nint main( void ) {\n  _w = scanf(\"%d\",&n); _mx = 0 , _mn = 0x3f3f3f3f;\n  inf = VI( n , n );\n  for( int i = 1 ; i <= n ; ++i ) _w = scanf(\"%d\",dat+i) , m += dat[i] , _mx = max( _mx , dat[i] ) , _mn = min( _mn , dat[i] );\n  if( _mn * 2  < _mx ) {\n    puts(\"-1\");\n    return 0;\n  }\n  int l;\n  VI res;\n  while( cur < m ) {\n    res = inf;\n    for( l = n ; l ; --l ) {\n      VI tmp = solve( l );\n      if( res > tmp ) res = tmp;\n    }\n    for( const int & v : res )\n      ans[++cur] = v , --dat[v];\n  }\n  for( int i = 1 ; i <= m ; ++i )\n    printf(\"%d \",ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\tint ok=0;\n\trep(_,len){\n\t\tdmp2(ans,cur,ok);\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tvi tmp;\n\t\t\tint waf;\n\t\t\tif(p==si(cur)){\n\t\t\t\ttmp=cur;\n\t\t\t\twaf=ok;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ok<=p)continue;\n\t\t\t\ttmp=vi(cur.bg+p+1,cur.ed);\n\t\t\t\twaf=ok-(p+1);\n\t\t\t}\n\t\t\ttmp.pb(nx);\n\t\t\tif(si(tmp)==k)waf=k;\n\t\t\ta[nx]--;\n\t\t\tbool relka=false;\n\t\t\trep(j,waf+1){\n\t\t\t\tif(inc(1,j,waf-1))continue;\n\t\t\t\tif(can(k,a,vi(tmp.bg+j,tmp.ed))){\n\t\t\t\t\tans.pb(nx);\n\t\t\t\t\tcur=tmp;\n\t\t\t\t\tok=waf;\n\t\t\t\t\tfound=true;\n\t\t\t\t\trelka=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(relka)break;\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\nconst int N = 105; \n\nint n, a[N], s, mx_a, v[N];\nint main(int argc,char *argv[]){\n\tfreopen(\"d.in\", \"r\", stdin); \n\tcin >> n;\n\tvector<int> ans, cur_left(n); \n\tlop(i, 0, n) {\n\t\tcin >> cur_left[i]; \n\t\ts += cur_left[i]; \n\t\tcmax(mx_a, cur_left[i]); \n\t}\n\tlop(i, 0, n) if (mx_a > cur_left[i]*2) {\n\t\tcout << -1 << endl;\n\t\treturn 0; \n\t}\n\twhile (ans.size() < s) {\n\t\tint m = ans.size();\n\t\tvector<int> best_left, best_add;\n\t\trep(len, 1, n) {\n\t\t\tif (m+len < n || m+len > s) continue;\n\t\t\tauto left = cur_left; \n\t\t\tlop(i, 0, n) v[i] = 1;\n\t\t\tlop(i, m-(n-len), m) \n\t\t\t\tv[ans[i]] = 0;\t\n\t\t\tlop(i, 0, n) if (v[i]) --left[i]; \n\t\t\tint mn = left[0], mx = left[0];\n\t\t\tlop(i, 1, n) {\n\t\t\t\tcmin(mn, left[i]); \n\t\t\t\tcmax(mx, left[i]); \n\t\t\t}\n\t\t\tint mn_idx = n, mx_idx = -1, fail = 0, mx_r;\n\t\t\tlop(i, m-(n-len), m) {\n\t\t\t\tif (left[ans[i]] == mn) cmin(mn_idx, i-(m-(n-len))); \n\t\t\t\tif (left[ans[i]] == mx) cmax(mx_idx, i-(m-(n-len))); \n\t\t\t}\n\t\t\tif (mx <= mn*2) ;\n\t\t\telse if (mx == mn*2+1) {\n\t\t\t\tfail |= mn_idx < mx_idx; \n\t\t\t} else fail = 1;\n\t\t\tif (fail) continue;\n\t\t\tvector<int> add;\n\t\t\tif (mx == mn*2+1){\n\t\t\t\tlop(i, 0, n) if (v[i] && left[i] == mx) mx_r = i;\n\t\t\t\tvector<int> z;\n\t\t\t\tlop(i, 0, n) if (v[i]) {\n\t\t\t\t\tif ((i > mx_r) || (left[i] > mn)) add.pb(i); \n\t\t\t\t\telse z.pb(i); \n\t\t\t\t\tif (i == mx_r) {\n\t\t\t\t\t\tadd.insert(add.end(), z.begin(), z.end()); \n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t} else {\n\t\t\t\tlop(i, 0, n) if (v[i]) add.pb(i); \n\t\t\t}\n\t\t\tif (best_add.empty() || add < best_add) best_add = add, best_left = left;\n\t\t}\n\t\tcur_left = best_left; \n\t\tans.insert(ans.end(), best_add.begin(), best_add.end()); \n\t}\n\tfor (int x : ans) cout << x+1 << \" \"; \n\tcout << endl;\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int K = 101;\nconst int N = 1010;\nint k;\nint a[K];\nint aa[K];\nint b[N];\nint id[K];\nint lastP = 0;\n\n/*\n\n\t\tvector<pii> c;\n\t\tif (n == 0) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tc.push_back(mp(a[i], i));\n\t\t} else {\n\t\t\tfor (int i = 0; ; i++) {\n\t\t\t\tint v = b[n - k + i];\n\t\t\t\tc.push_back(mp(a[v], v));\n\t\t\t\tif (a[v] == mx) break;\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\treverse(all(c));\n\t\tfor (auto t : c) {\n\t\t\tint v = t.second;\n\t\t\tif (a[v] == 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[v]--;\n\t\t\tb[n++] = v;\n\t\t}\n*/\n\nbool canCont(int n) {\n\tint oldn = n;\n\tfor (int i = 0; i < k; i++)\n\t\ta[i] = aa[i];\n\tfor (int i = lastP; i < oldn; i++)\n\t\ta[b[i]]++;\n\tint z = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tid[i] = 0;\n\t}\n\tfor (int i = lastP; i < n; i++) {\n\t\tif (id[b[i]]) return false;\n\t\tid[b[i]] = 1;\n\t}\n\tif (lastP == 0) {\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tid[i] = i;\n\t\t}\n\t\tz = k;\n\t} else {\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tid[b[lastP - k + i]] = i;\n\t\tfor (int i = lastP; i < n; i++)\n\t\t\tz = max(z, id[b[i]] + 1);\n\t}\n\tint mx = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (a[i] < 0) return false;\n\t\tmx = max(mx, a[i]);\n\t}\n\tif (mx == 0) return true;\n\tfor (int i = 0; i < k; i++)\n\t\tif (a[i] == mx)\n\t\t\tz = max(z, id[i] + 1);\n\tfor (int i = lastP; i < n; i++)\n\t\tid[b[i]] = k + 1;\n\tvector<pii> c;\n\tfor (int i = 0; i < k; i++)\n\t\tif (id[i] < z)\n\t\t\tc.push_back(mp(a[i], i));\n\tsort(all(c));\n\treverse(all(c));\n\tfor (auto t : c) {\n\t\tint v = t.second;\n\t\tif (a[v] == 0) {\n\t\t\treturn false;\n\t\t}\n\t\ta[v]--;\n\t\tb[n++] = v;\n\t}\n\tfor (int i = lastP; i < oldn; i++)\n\t\ta[b[i]]--;\n\twhile(true) {\n\t\tc.clear();\n\t\tint cntMax = 0;\n\t\tint mx = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (a[i] > mx) {\n\t\t\t\tmx = a[i];\n\t\t\t\tcntMax = 0;\n\t\t\t}\n\t\t\tif (a[i] == mx) cntMax++;\n\t\t}\n\t\tif (mx == 0) return true;\n\t\tfor (int i = 0; ; i++) {\n\t\t\tint v = b[n - k + i];\n\t\t\tc.push_back(mp(a[v], v));\n\t\t\tif (a[v] == mx) cntMax--;\n\t\t\tif (cntMax == 0) break;\n\t\t}\n\t\tsort(all(c));\n\t\treverse(all(c));\n\t\tfor (auto t : c) {\n\t\t\tint v = t.second;\n\t\t\tif (a[v] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ta[v]--;\n\t\t\tb[n++] = v;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(\"%d\", &aa[i]);\n\tint n = 0;\n\tif (!canCont(n)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\twhile(true) {\n\t\t/*\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d \", b[i]);\n\t\tprintf(\"\\n\");\n\t\t*/\n\t\tif (n >= k) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tid[i] = 0;\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; ok && i < k; i++) {\n\t\t\t\tint x = b[n - k + i];\n\t\t\t\tok &= !id[x];\n\t\t\t\tid[x] = 1;\n\t\t\t}\n\t\t\tif (ok) lastP = n;\n\t\t}\n\t\t//printf(\"lastP = %d\\n\", lastP);\n\t\tint mx = 0;\n\t\tfor (int i = 0; mx >= 0 && i < k; i++) {\n\t\t\tif (aa[i] == 0) continue;\n\t\t\tmx = max(mx, aa[i]);\n\t\t\tb[n++] = i;\n\t\t\taa[i]--;\n\t\t\tif (canCont(n)) {\n\t\t\t\tmx = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn--;\n\t\t\taa[i]++;\n\t\t}\n\t\tif (mx == -1) continue;\n\t\tif (mx == 0) break;\n\t\tassert(false);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", b[i] + 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) cin>>A[i];\n\t\n\tvector<string> VA;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tstring V;\n\t\t\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\t\n\t\tvector<pair<int,int>> C;\n\t\t\n\t\t\n\t\tif(x==2*y) {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tC.push_back({i,1});\n\t\t\t\t}\n\t\t\t\telse if(A[i]>y) {\n\t\t\t\t\tC.push_back({i,0});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(C.size() && C.back().second==0) C.pop_back();\n\t\t\tint first[101]={};\n\t\t\tFORR(c,C) {\n\t\t\t\tfirst[c.first]=1;\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t\tFOR(i,K) if(first[i]==0) V.push_back(i), A[i]--;\n\t\t\tFORR(c,C) {\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t}\n\t\telse if(x==y) {\n\t\t\tFOR(i,K) V.push_back(i), A[i]--;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]!=y) {\n\t\t\t\t\tV.push_back(i);\n\t\t\t\t\tA[i]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j,K) V.push_back((i+j)%K), A[(i+j)%K]--;\n\t\t}\n\t\tVA.push_back(V);\n\t}\n\t\n\tFOR(x,VA.size()) {\n\t\tFOR(y,VA.size()-1) {\n\t\t\tauto a=VA[y]+VA[y+1];\n\t\t\tauto b=VA[y+1]+VA[y];\n\t\t\tif(b<a) swap(VA[y],VA[y+1]);\n\t\t}\n\t}\n\tFORR(va,VA) {\n\t\tFORR(v,va) cout<<(int)(v+1)<<\" \";\n\t}\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\tvi prev(k, -1);\n\n\trep(i,0,len){\n\t\tmx = 0, mn = 1000;\n\t\ttrav(x, a) mx = max(mx, x);\n\t\ttrav(x, a) mn = min(mn, x);\n\t\tint imx = 1000;\n\t\trep(d,0,k) if(a[d] == mn) imx = min(imx, prev[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx && !(mx>=2*mn+1 && prev[d] > imx)){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans[i] < 0){\n\t\t\trep(j,0,i) cout << 1+ans[j] << \" \";\n\t\t\tcout << endl;\n\t\t\ttrav(x, a) cout << x << \" \";\n\t\t\tcout << endl;\n\n\t\t\tcout << mx << \" \" << mn << endl;\n\t\t\tcout << a[ans[i]] << endl;\n\t\t\tcout << imx << \" \" << prev[ans[i]] << endl;\n\t\t\tassert(false);\n\t\t}\n\t\tprev[ans[i]] = i;\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass EPermutationCover {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int K; cin >> K;\n        vector<int> A(K); cin >> A;\n        int mx = *max_element(A.begin(),A.end());\n        vector<vector<int>> Soln;\n\n        for (int t = mx; t <= 2*mx; ++t) {\n            if (*min_element(A.begin(),A.end()) < t - t/2) break;\n\n            vector<int> B = A;\n\n            vector<int> cur;\n            vector<bool> prevOver(K, false);\n            for (int a = 0; a < t; ++a) {\n                vector<bool> canOver(K, false);\n                vector<bool> mustOver(K, false);\n                for (int i = 0; i < K; ++i) {\n                    canOver[i] = !prevOver[i] && (B[i] < (t-a));\n                    mustOver[i] = !prevOver[i] && 2*B[i] == (t-a);\n                }\n\n                vector<bool> isOver(K, false);\n                int first = K;\n                int last = -1;\n                for (int i = 0; i < K; ++i) {\n                    if (mustOver[i]) {\n                        isOver[i] = true;\n                        first = min(i, first);\n                        last = i;\n                    }\n                }\n//                if (first == K) {\n                    int i = K-1;\n                    while (i >= 0 && (canOver[i] || mustOver[i])) {\n                        if (first != K && i < first) break;\n                        isOver[i] = true;\n                        --i;\n                    }\n//                } else {\n//                    for (int i = first; i < K; ++i) {\n//                        if (canOver[i]) {\n//                            isOver[i] = true;\n//                        }\n//                    }\n//                }\n                for (int i = 0; i < K; ++i) {\n                    if (!prevOver[i] && !isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n                for (int i = 0; i < K; ++i) {\n                    if (isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n//                cout << \"level \" << a << endl;\n//                cout << B;\n//                cout << \"canover \" << canOver;\n//                cout << \"mustover \" << mustOver;\n//                cout << \"isover \" << isOver;\n\n                prevOver = isOver;\n            }\n\n            Soln.push_back(cur);\n        }\n\n//        cout << Soln;\n\n        if (Soln.empty()) {\n            cout << \"-1\\n\";\n        } else {\n            cout << *min_element(Soln.begin(),Soln.end());\n        }\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEPermutationCover solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\tsort(h.begin(), h.end(), cmp);\n\tint mino = h.size()? a[h[0]] : inf;\n\tfor (int i : v) \n\t\tmino = min(mino, a[i]);\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\tif (!stp) {\n\t\treverse(h.begin(), h.end());\n\t\tfor (int i : h) \n\t\t\tif (a[i] == mino) {\n\t\t\t\tstp = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse --a[i];\n\t}\n//\tcerr << \"P1 check \\n\";\n//\tfor (int i : v) \n//\t\tcerr << i << ' ';\n//\tcerr << \"Cnt \\n\";\n//\tfor (int i = 0;i < k;++i)\n//\t\tcerr << a[i] << ' ';\n//\tcerr << '\\n';\n\tbool res = stvalid();\n\t//cerr << (res?\"OK\":\"NO\") << endl;\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(res[h+j]);\n\t\t\t\t--a[res.back()];\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcerr << \"In To try \" << res[h+j] << '\\n';\n//\t\t\tcerr << \"MH \" << mh() << '\\n';\n\t\t\tif (mh() < res[h+j]) break;\n\t\t\tint v = res[h+j];\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t\t//cerr << '\\n';\n\t}\n\treturn true;\n}\n\n\n\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nint last[101];\nint R[1010];\n\nint ok(int len) {\n\tint i,j;\n\tint num[100]={};\n\tFOR(i,len) num[R[i]]++;\n\tint z=0;\n\tFOR(i,K) if(num[i]==0) z++;\n\tFOR(i,K) if(z&&num[i]>1) return 0;\n\t\n\tFOR(i,K) FOR(j,K) if(i!=j) {\n\t\tint na=A[i];\n\t\tint nb=A[j];\n\t\t\n\t\tif(last[i]<=last[j]) {\n\t\t\tif(na>2*nb+1) return 0;\n\t\t}\n\t\telse {\n\t\t\tif(na>2*nb) return 0;\n\t\t}\n\t\t\n\t}\n\treturn 1;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\tMINUS(last);\n\t\n\tFOR(i,N) {\n\t\tFOR(j,K) if(A[j]) {\n\t\t\tx=last[j];\n\t\t\tR[i]=j;\n\t\t\tlast[j]=i;\n\t\t\tA[j]--;\n\t\t\t\n\t\t\tif(ok(i+1)) break;\n\t\t\tA[j]++;\n\t\t\tlast[j]=x;\n\t\t}\n\t\tif(j==K) return _P(\"-1\\n\");\n\t}\n\t\n\tFOR(i,N) cout<<R[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 < *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n    abort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(i > last_2h) vis_2h_h = true;\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          // if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // 特殊形(単調増加)\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          times(x+1, i) {a[i] += c[i]-2;c[i]=2;}\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101],B[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) cin>>A[i], B[i]=A[i];\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tvector<pair<int,int>> C;\n\t\t\n\t\t\n\t\tif(x==2*y) {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tC.push_back({i,1});\n\t\t\t\t}\n\t\t\t\telse if(A[i]>y) {\n\t\t\t\t\tC.push_back({i,0});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(C.size() && C.back().second==0) C.pop_back();\n\t\t\tint first[101]={};\n\t\t\tFORR(c,C) {\n\t\t\t\tfirst[c.first]=1;\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t\tFOR(i,K) if(first[i]==0) V.push_back(i), A[i]--;\n\t\t\tFORR(c,C) {\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t}\n\t\telse if(x==y) {\n\t\t\tFOR(i,K) V.push_back(i), A[i]--;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tV.push_back(i);\n\t\t\t\t\tA[i]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j,K) V.push_back((i+j)%K), A[(i+j)%K]--;\n\t\t}\n\t}\n\t\n\tFORR(v,V) cout<<(v+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    int mn = a[0];\n    int mx = a[0];\n    for (int i = 0; i < n; i++) {\n        mn = min(mn, a[i]);\n        mx = max(mx, a[i]);\n    }\n    if (mx > mn * 2) {\n        cout << -1;\n        return 0;\n    }\n    vector<int> res;\n    while (mn > 0) {\n        for (int i = 0; i < n; i++) {\n            if (a[i] == mn * 2) {\n                res.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] != mn * 2) {\n                res.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] == mn * 2) {\n                res.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] == mn * 2) {\n                a[i] -= 2;\n            } else {\n                a[i]--;\n            }\n        }\n        mn--;\n    }\n    for (int x : res) {\n        cout << x + 1 << \" \";\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nll tail(vll &a, ll mx){\n\tdep(i, sz(a)-1, 0){\n\t\tif (a[i]==mx) return i;\n\t}\n\treturn -1;\n}\n\nvoid solve()\n{\n\tll k;  cin >> k;\n\tvector<ll> a = cinv<ll>(k);\n\n\tll mn=MinE(a);\n\tll mx=MaxE(a);\n\tif (mx>mn*2){\n\t\tcout << -1 << '\\n'; return;\n\t}\n\n\tvll ans;\n\t//phase1\n\twhile (mx<mn*2){\n\t\trep(i, 0, k-1) ans.push_back(i);\n\t\teach(e, a) e--;\n\t\tmn--; mx--;\n\n\t\tif (mx==mn*2 and a[0]==mn)break;\n\n\n\t\tans.push_back(0);\n\t\ta[0]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\n\t\tif (mx==mn*2)break;\n\t\tif (mx>mn*2){\n\t\t\tll t=tail(a, mx);\n\t\t\trep(i, 1, t){\n\t\t\t\ta[i]--;\n\t\t\t\tans.push_back(i);\n\t\t\t\tmx--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//phase2\n\twhile (a[0]>0){\n\t\tll t=tail(a, mx);\n\t\tvll fro, mid;\n\t\trep(i, 0, t){\n\t\t\tif (a[i]==mn){\n\t\t\t\tmid.push_back(i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfro.push_back(i);\n\t\t\t}\n\t\t}\n\t\trep(i, t+1, k-1){\n\t\t\tmid.push_back(i);\n\t\t}\n\t\teach(e, fro)ans.push_back(e);\n\t\teach(e, mid)ans.push_back(e);\n\t\teach(e, fro)ans.push_back(e);\n\t\t//カウントダウン\n\t\teach(e, fro)a[e]-=2;\n\t\teach(e, mid)a[e]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\t}\n\n\teach(e, ans)e++;\n\tcoutv(ans);\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint K;\nint A[111];\n\nbool valid() {\n    int ma = *max_element(A, A+K);\n    if (ma == 0) return true;\n    int mi = *min_element(A, A+K);\n    return mi * 2 >= ma;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &K);\n    REP (i, K) {\n\tint a;\n\tscanf(\"%d\", &a);\n\tA[i] = a;\n    }\n\n    if (!valid()) {\n\tputs(\"-1\");\n\treturn;\n    }\n\n    VI ans;\n    while (1) {\n\t// rprintf(\"%d\", ans.begin(), ans.end());\n\tif (*max_element(A, A+K) == 0) break;\n\n\tif (A[0] >= 2) {\n\t    REP (i, K) A[i]--;\n\t    A[0]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tans.push_back(0);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t\tA[0]++;\n\t    }\n\t}\n\n\t{\n\t    REP (i, K) A[i]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t    }\n\t}\n\t\t\n\tint ma = *max_element(A, A+K);\n\tint mii = min_element(A, A+K) - A;\n\tint mi = A[mii];\n\tint last_max = 0;\n\tREP (i, K) if (A[i] == ma) last_max = i;\n\n\tVI once, twice;\n\n\tREP (i, K) {\n\t    if (A[i] == ma) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else if (A[i] == mi) {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    } else if (i < mii || i < last_max) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    }\n\t}\n\n\n\t//rprintf(\"%d.\", A, A+K);\n\tassert(valid());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n\tans.insert(ans.end(), once.begin(), once.end());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n    }\n\n    EACH (e, ans) (*e)++;\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\nconst int maxK=100+5,maxn=1000+5;\nint n,K,a[maxK],an[maxn];\nbool vis[maxK];\ninline bool cmp(const vector<int> &a,const vector<int> &b) {\n\tfor(int i=0;i<a.size()&&i<b.size();++i) if(a[i]!=b[i]) return a[i]<b[i];\n\treturn a.size()<b.size();\n}\nvoid fail(vector<int> &re) {\n\tfor(int i=0;i<=K;++i) re.push_back(K+1);\n}\nvoid sol(int s,int m,vector<int> &re) {\n\tstatic int b[maxK]; memcpy(b,a,sizeof(b));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i+m<=K;++i) vis[an[s-i]]=1;\n\tfor(int i=1;i<=K;++i) if(!vis[i]) {\n\t\tif(!b[i]) {fail(re); return;}\n\t\t--b[i];\n\t}\n\tint x=*max_element(b+1,b+K+1),y=*min_element(b+1,b+K+1);\n\tif(x>2*y+1) {fail(re); return;}\n\tvector<int> A,B,C;\n\tif(x==2*y+1) {\n\t\tbool flag=0;\n\t\tfor(int i=1;i+m<=K;++i) {\n\t\t\tif(b[an[s-i]]==x) flag=1;\n\t\t\telse if(b[an[s-i]]=y) {\n\t\t\t\tif(flag) {fail(re); return;}\n\t\t\t}\n\t\t}\n\t\tfor(int i=K;i>=1;--i) if(!vis[i]) {\n\t\t\tif(b[i]==x) A.push_back(i);\n\t\t\telse if(b[i]==y) B.push_back(i);\n\t\t\telse C.push_back(i);\n\t\t}\n\t}\n\telse for(int i=K;i>=1;--i) if(!vis[i]) C.push_back(i);\n\tfor(int i=1;i<=m;++i) {\n\t\tif(A.size()) {\n\t\t\tint t=C.size()?C.back():K+1;\n\t\t\tif(A.back()<t) re.push_back(A.back()),A.pop_back();\n\t\t\telse re.push_back(t),C.pop_back();\n\t\t}\n\t\telse {\n\t\t\tint a=B.size()?B.back():K+1,b=C.size()?C.back():K+1;\n\t\t\tif(a<b) re.push_back(a),B.pop_back();\n\t\t\telse re.push_back(b),C.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\trd(K);\n\tfor(int i=1;i<=K;++i) rd(a[i]),n+=a[i];\n\tif(*max_element(a+1,a+K+1)>2*(*min_element(a+1,a+K+1))) {puts(\"-1\"); return 0;}\n\tfor(int i=1;i<=n;) {\n//\t\tdebug(\"---\\n\");\n\t\tvector<int> Q[maxK];\n\t\tif(i==1) sol(i,K,Q[1]);\n\t\telse {\n\t\t\tfor(int j=1;j<=K;++j) sol(i,j,Q[j]);\n\t\t\tint k=1;\n\t\t\tfor(int j=2;j<=K;++j) if(cmp(Q[j],Q[k])) k=j;\n\t\t\tif(k!=1) swap(Q[1],Q[k]);\n\t\t}\n\t\tfor(int j=0;j<Q[1].size();++j) an[i+j]=Q[1][j],--a[Q[1][j]];\n\t\ti+=Q[1].size();\n//\t\tfor(int j=1;j<i;++j) debug(\"%d \",an[j]); debug(\"\\n\");\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tif(i!=1) printf(\" \");\n\t\tprintf(\"%d\",an[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  vector<int> nie(n);\n  int ilnie = 0;\n  while(1){\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    debug(ilnie);\n    if(ma == 0)break;\n    R(i,n)if(!nie[i] && t[i] * 2 > ma && t[i]){\n      debug(ma,t[i],i);\n      res.PB(i);\n      t[i]--;\n      nie[i] = 1;\n      ilnie++;\n      goto ok;\n    }\n    debug(res);\n    assert(0);\n    ok:;\n    if(SZ(res) >= n){\n      vector<int> cz(n);\n      bool nope = 0;\n      R(i,n){\n        if(cz[res[SZ(res) - i - 1]]){\n          nope = 1;\n          break;\n        }\n        cz[res[SZ(res) - i - 1]] = 1;\n      }\n      if(!nope){\n        ilnie = 0;\n        R(i,n)nie[i] = 0;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint N;\n\nvoid generate(vector<int> &src, vector<int> &dest) {\n\tvector<bool> flag(N, true);\n\tsort(src.begin(), src.end());\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t\tflag[src[i]] = false;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (flag[i] == true) {\n\t\t\tdest.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint K; cin >> K;\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tN = a.size();\n\tint M = 100000;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tchmin(M, a[i]);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i] > M * 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\tset<int> st;\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<int> sizes(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsizes[j] = a[j];\n\t\t}\n\t\tsort(sizes.begin(), sizes.end());\n\n\t\tvector<int> v;\n\t\tfor (auto itr = st.begin(); itr != st.end(); itr++) {\n\t\t\tv.push_back(*itr);\n\t\t}\n\t\tint m = N;\n\t\tif (v.size() > 0) {\n\t\t\tm = v[v.size() - 1];\n\t\t}\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tif (st.find(c) != st.end()) { continue; }\n\t\t\tbool f = true;\n\n\t\t\tint _m = sizes[0];\n\t\t\tchmin(_m, a[c] - 1);\n\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (a[k] > 2 * _m) { f = false; }\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tv.push_back(c);\n\t\t\t\ta[c]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j]--;\n\t\t}\n\n\t\tm = 100000;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tchmin(m, a[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (a[j] == m * 2) {\n\t\t\t\tst.insert(j);\n\t\t\t}\n\t\t}\n\n\t\tgenerate(v, ans);\n\t}\n\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops, loopsm;\nUL P2[100];\nvector<UL> buf;\nvector<vector<UL>> ans;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloops = (loops + 1) / 2;\n\tloopsm = 1000; rep(i, K) loopsm = min(loopsm, P[i]);\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\n\tfor (UL L = loops; L <= loopsm; L++) {\n\t\trep(i, K) P2[i] = P[i] - L;\n\t\tvector<UL> ans;\n\t\trep(l, L) {\n\t\t\tvector<UL> S, T;\n\t\t\tUL p = 0;\n\t\t\trep(i, K) {\n\t\t\t\tif (P2[i] == L - l) {\n\t\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\t\telse T.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\t\tfor (; p < K; p++) {\n\t\t\t\tT.push_back(p);\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\tsort(T.begin(), T.end());\n\t\t\tconcat(ans, S);\n\t\t\tconcat(ans, T);\n\t\t\tconcat(ans, S);\n\t\t}\n\t\t::ans.push_back(ans);\n\t}\n\tsort(ans.begin(), ans.end());\n\trep(i, ans[0].size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[0][i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\nint pst=0;\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>pst){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tpst=curlen;\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tint idx = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tidx = i;\n\t\tfor (int i = 1; i <= idx; i++)\n\t\t\tif (a[i] != *min_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (i > idx or a[i] == *min_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\twhile (sz < sum){\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tvector<int> A;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.push_back(q[j]);\n\t\t\t}\n\t\t\tsort(A.begin(), A.end());\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tvector<int> me;\n\t\t\tif (2*mnm+1 == mxm){\n\t\t\t\tint idx = -1;\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (a[A[j]] == mxm)\n\t\t\t\t\t\tidx = j;\n\t\t\t\tfor (int j = 0; j <= idx; j++){\n\t\t\t\t\tif (a[A[j]] == mnm)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp[++now] = A[j];\n\t\t\t\t\tme.push_back(A[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (j > idx or a[A[j]] == mnm)\n\t\t\t\t\t\tp[++now] = A[j], me.push_back(A[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tme = A;\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tarr[i].first--;\n\t\t}\n\t}\n\n\tint u = 0;\n\twhile (true) {\n\n\t\tauto kek = arr;\n\t\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\t\tkek[i].first--;\n\t\t}\n\n\t\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\t\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\t\tif (2*minimum.first < maximum.first) break;\n\t\tcout << u+1 << \" \";\n\t\tu = (u+1)%n;\n\n\t\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\t\tarr = kek; \n\n\t}\n\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tsort(all(big));\n\t\tsort(all(small));\n\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\n\nint n, m;\nvector<int> c, p;\nvector<bool> cov;\nvector<int> vmi, vpmi;\n\nbool chk0() {\n  int mx = *max_element(c.begin(), c.end());\n  int mi = *min_element(c.begin(), c.end());\n  return mx <= 2 * mi;\n}\n\nint main() {\n  scanf(\"%d\", &m);\n  c.resize(m);\n  for (auto& x : c) {\n    scanf(\"%d\", &x);\n    n += x;\n  }\n  if (!chk0()) {\n    puts(\"-1\");\n    return 0;\n  }\n  p.resize(n);\n  cov.resize(n, false);\n  vmi.resize(n + 1, 0);\n  vpmi.resize(n + 1, 0);\n  for (int i = 0; i < n; i++) {\n    for (int x = 0; x < m; x++) {\n      if (!c[x]) continue;\n      auto bc = c;\n      auto bcov = cov;\n      bc[x]--;\n      p[i] = x;\n      if (i >= m - 1) {\n        vector<bool> vis(m, false);\n        for (int j = 0; j < m; j++) {\n          vis[p[i - j]] = true;\n        }\n        if (*min_element(vis.begin(), vis.end())) {\n          fill(bcov.begin() + (i - m + 1), bcov.begin() + i + 1, true);\n        }\n      }\n      int pr = i - 1;\n      while (~pr && p[pr] != x)\n        pr--;\n      if (pr >= 0 && !*min_element(bcov.begin(), bcov.begin() + pr + 1)) {\n        continue;\n      }\n      int R = i + 1;\n      while (R && !bcov[R - 1])\n        R--;\n      bool flg = false;\n      vector<bool> vis(m, false);\n      int L = i + 1;\n      while (L && !vis[p[L - 1]])\n        vis[p[--L]] = true;\n      int mi = 114514, mx = 0;\n      for (int j = 0; j < m; j++) {\n        mi = min(bc[j] - !vis[j], mi);\n        mx = max(bc[j] - 1, mx);\n      }\n      int mip = i + 1;\n      for (int j = L; j <= i; j++) {\n        int y = p[j];\n        if (bc[y] == mi) {\n          mip = min(mip, j);\n        }\n      }\n      vmi[L] = mi;\n      vpmi[L] = mip;\n      for (int j = L; j <= i; j++) {\n        int y = p[j];\n        if (bc[y] - 1 < mi) {\n          vmi[j + 1] = bc[y] - 1; \n          vpmi[j + 1] = i + 1;\n        } else {\n          vmi[j + 1] = vmi[j];\n          vpmi[j + 1] = vpmi[j];\n        }\n      }\n      int mxp = i + 1;\n      for (int j = i; j >= L; j--) {\n        int y = p[j];\n        if (bc[y] > mx) {\n          mxp = j;\n          mx = bc[y];\n        }\n        if (j <= R) {\n          if (vmi[j] >= 0 && mx <= 2 * vmi[j] || (mx == 2 * vmi[j] + 1 && mxp <= vpmi[j])) {\n            flg = true;\n            break;\n          }\n        }\n      }\n      if (L > i && *max_element(bc.begin(), bc.end()) <= 2 * *min_element(bc.begin(), bc.end())) {\n        flg = true;\n      }\n      if (flg) {\n        cov = bcov;\n        c = bc;  \n        break;\n      }\n    }\n  }\n  assert(!*max_element(c.begin(), c.end()));\n  assert(*min_element(cov.begin(), cov.end()));\n  for (auto x : p) {\n    printf(\"%d \", x + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  vector<int> innerSolve(int k, vector<int> a) {\n    int mn = a[0];\n    int mx = a[0];\n    for (int x : a) {\n      mn = min(mn, x);\n      mx = max(mx, x);\n    }\n    if (mx > 2 * mn) {\n      return {};\n    }\n    int total = 0;\n    for (int x : a) total += x;\n    vector<int> res(total, -1);\n    int permStart = 0;\n    int firstUncovered = 0;\n    vector<int> last(k, -1);\n    for (int pos = 0; pos < total; ++pos) {\n      if (pos >= permStart + k) {\n        firstUncovered = pos;\n      }\n      for (int val = 0; val < k; ++val) {\n        if (a[val] > 0) {\n          res[pos] = val;\n          --a[val];\n          vector<int> sa = a;\n          vector<bool> inPerm(k, false);\n          for (int i = permStart; i < pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n          bool ok = false;\n          if (last[val] < permStart) {\n            inPerm[val] = true;\n            for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n            vector<ii> avail;\n            for (int i = 0; i < k; ++i)\n              if (!inPerm[i]) {\n                avail.emplace_back(-a[i], i);\n              }\n            sort(avail.begin(), avail.end());\n            int ptr = 0;\n            for (int plen = k; plen < 2 * k; ++plen) {\n              if (plen > k) {\n                if (permStart + plen - k - 1 <= pos) {\n                  --a[res[permStart + plen - k - 1]];\n                } else {\n                  --a[avail[ptr++].second];\n                }\n              }\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n            }\n          } else if (last[val] == pos - k) {\n            for (int endAt = pos + 1; endAt <= total; ++endAt) {\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n              --a[res[(endAt - permStart) % k + permStart]];\n            }\n          } else {\n            int npermstart = last[val] + 1;\n            if (npermstart <= firstUncovered && total - npermstart >= k) {\n              int spermstart = permStart;\n              permStart = npermstart;\n              vector<bool> inPerm(k, false);\n              for (int i = permStart; i <= pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n              for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n              vector<ii> avail;\n              for (int i = 0; i < k; ++i)\n                if (!inPerm[i]) {\n                  avail.emplace_back(-a[i], i);\n                }\n              sort(avail.begin(), avail.end());\n              int ptr = 0;\n              for (int plen = k; plen < 2 * k; ++plen) {\n                if (plen > k) {\n                  if (permStart + plen - k - 1 <= pos) {\n                    --a[res[permStart + plen - k - 1]];\n                  } else {\n                    --a[avail[ptr++].second];\n                  }\n                }\n                mn = a[0];\n                mx = a[0];\n                for (int x : a) {\n                  mn = min(mn, x);\n                  mx = max(mx, x);\n                }\n                if (mn >= 0 && mx <= 2 * mn) {\n                  ok = true;\n                  break;\n                }\n              }\n              if (!ok) {\n                permStart = spermstart;\n              }\n            }\n          }\n          a = sa;\n          if (ok) {\n            last[val] = pos;\n            break;\n          } else {\n            ++a[val];\n            assert(val + 1 < k);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    /*int tried = 0;\n    while (true) {\n      ++tried;\n      if (tried % 10000 == 0) {\n        cerr << tried << endl;\n      }\n      int k = rand() % 5 + 1;\n      int n = k + rand() % 20;\n      vector<int> seq(n, -1);\n      int permStart = 0;\n      int firstUncovered = 0;\n      vector<int> last(k, -1);\n      for (int i = 0; i < n; ++i) {\n        int step = 0;\n        if (i - permStart >= k) {\n          firstUncovered = i;\n        }\n        while (true) {\n          seq[i] = rand() % k;\n          if (last[seq[i]] < permStart) {\n            break;\n          }\n          if (last[seq[i]] == i - k) {\n            break;\n          }\n          if (i - permStart >= k) {\n            int npermStart = last[seq[i]] + 1;\n            if (n - npermStart >= k && npermStart <= firstUncovered) {\n              permStart = npermStart;\n              break;\n            }\n          }\n          ++step;\n        }\n        last[seq[i]] = i;\n      }\n      vector<int> a(k);\n      for (int x : seq) ++a[x];\n      vector<int> got = innerSolve(k, a);\n      assert(!got.empty());\n      for (int& v : got) {\n        --a[v];\n      }\n      for (int x : a) assert(x == 0);\n      vector<bool> cover(n);\n      for (int i = 0; i + k <= n; ++i) {\n        vector<bool> seen(k);\n        bool ok = true;\n        for (int j = 0; j < k; ++j) {\n          if (seen[got[i + j]]) ok = false;\n          seen[got[i + j]] = true;\n        }\n        if (ok) {\n          for (int j = 0; j < k; ++j) {\n            cover[i + j] = true;\n          }\n        }\n      }\n      for (int i = 0; i < n; ++i) assert(cover[i]);\n      assert(got.size() == seq.size());\n      for (int i = 0; i < got.size(); ++i) {\n        if (seq[i] < got[i]) {\n          assert(false);\n        }\n        if (seq[i] > got[i]) {\n          break;\n        }\n      }\n    }*/\n    int k;\n    in >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) in >> a[i];\n    vector<int> res = innerSolve(k, a);\n    if (res.empty()) {\n      out << -1 << \"\\n\";\n    } else {\n      for (int x : res) out << x + 1 << \" \";\n      out << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nint n;\n\nint get_best(vector<pair<int, int> > arr) {\n\tvector<int> big, small;\n \n\tint Q = arr[0].first;\n\n\tfor (int j = 0; j < n; ++j) {\n\t\tif (2*Q == arr[j].first) {\n\t\t\tbig.push_back(arr[j].second);\n\t\t\tarr[j].first -= 2;\n\t\t}\n\t\telse {\n\t\t\tsmall.push_back(arr[j].second);\n\t\t\tarr[j].first--;\n\t\t}\n\t}\n\n\tsort(all(big));\n\tsort(all(small));\n\n\tif (big.size()) return big[0];\n\treturn small[0];\n\n}\n\n\nbool change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n \n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n \n\tif (2*minimum.first < maximum.first) {\n\t\treturn false;\n\t}\n\tcout << u+1 << \" \";\n \n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n\n\treturn true;\n\n}\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\nsort(all(arr));\n \n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n \n \n\twhile (arr.back().first > 0) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t\tvector<int> perm;\n\n\t\tfor (int e = 0; e < small.size(); ++e) perm.push_back(small[e]);\n\t\tfor (int e = 0; e < big.size(); ++e) perm.push_back(big[e]);\n\n\t\tint u = 0;\n\n\t\twhile (arr.back().first > 0) {\n\n\t\t\tint W = get_best(arr);\n\n\t\t\tif (W < perm[u]) break;\n\t\t\tif (!change(arr, perm[u])) break;\n\n\t\t\tu = (u+1)%n;\n\n\t\t}\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\n \ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            //cout<<x<<\"/\"<<y;\n            cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\n\nint main(){fastio\n    ll k;cin>>k;\n    ll a[k+1];rep(i,1,k)cin>>a[i];\n    cout<<-1<<endl;\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      pair<vi, int> best(solve(a, a.size()), 0);\n      for (int l = 1; l < a.size(); ++l) {\n        --a[v0[l - 1]];\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, a.size() - l, v0[l]);\n        if (v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n      }\n      best.first.resize(best.second);\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second == 0 ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 5; ++n) for (int test = 1; test <= 10000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      assert(v.size() == len(a));\n      for (int x : v) assert(x >= 0 && x < n);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 1e3 + 50;\ncs int INF = 1e9 + 7;\nvoid ckmn(int &a, int b){ if(a > b) a = b; }\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\nint n, a[N], m, ans[N];\nint now[N], nxt[N], my;\nbool cmp(cs int &i, cs int &j){\n\tint x=a[i]==my,y=a[j]==my;\n\tif(x!=y)return x<y; return i<j;\n}\nbool work(int len){\n\tfor(int i=1;i<=len;i++)--a[now[i]];\n\tint mn=INF,mx=0;\n\tfor(int i=1; i<=n; i++)\n\tmn=min(mn,a[i]),mx=max(mx,a[i]);\n\t\n\tif(mn*2>=mx){\n\t\tfor(int i=1; i<=len; i++)\n\t\t++a[nxt[i]=now[i]];\n\t\tsort(nxt+1,nxt+len+1);\n\t\treturn true;\n\t}\n\t\n\tif(mn*2+1<mx){\n\t\tfor(int i=1; i<=len; i++) ++a[now[i]];\n\t\treturn false;\n\t}\n\t\n\tstatic int t1[N], t2[N]; int z1=0, z2=0;\n\tfor(int i=1; i<=len; i++)\n\tif(a[now[i]]==mn||a[now[i]]==mx)\n\tt1[++z1]=now[i]; else t2[++z2]=now[i]; \n\t\n\tmy=mn;\n\tsort(t1+1,t1+z1+1,cmp);\n\tsort(t2+1,t2+z2+1);\n\t\n\tfor(int i=1,p=1,q=1; i<=len; i++)\n\tif((p<=z1 && t1[p]<t2[q])||q>z2) nxt[i]=t1[p++];\n\telse nxt[i]=t2[q++];\n\t\n\tbool ok=true;\n\tfor(int i=len+1;i<=n;i++)ok&=(a[now[i]]!=mn);\n\tok|=(z1==0)|(a[t1[1]]==mn);\n\t\n\tfor(int i=1; i<=len; i++)++a[now[i]];\n\treturn ok;\n}\nbool cmp(int *a, int *b){ \n\tint i=1;for(;a[i]==b[i];i++);\n\treturn a[i]<b[i];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tint mn=INF,mx=0,sm=0;\n\tfor(int i=1; i<=n; i++)\n\tscanf(\"%d\",&a[i]),sm+=a[i],\n\tckmn(mn,a[i]),ckmx(mx,a[i]);\n\tif(mn*2<mx) return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\t\n\tnow[i]=i; if(!work(n))return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\n\tnow[i]=ans[++m]=nxt[i],--a[now[i]];\n\twhile(m<sm){\n\t\tstatic int trs[N];\n\t\tint len=0;trs[1]=n+1;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(work(i)&&cmp(nxt,trs))\n\t\t\tlen=i,memcpy(trs,nxt,sizeof(int)*(len+1));\n\t\t}\n\t\tfor(int i=1; i+len<=n; i++)\n\t\tnow[i]=now[i+len];\n\t\tfor(int i=1; i<=len; i++)\n\t\tnow[i+n-len]=ans[++m]=trs[i],--a[trs[i]];\n\t} for(int i=1; i<=m; i++)cout<<ans[i]<<\" \";\n\tfor(int i=1; i<=n; i++)assert(a[i]==0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nbool possiblePrefix(vector<pair<int, int>> A, vector<int> prefix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n  for (int x : prefix) A[where[x]].first++;\n\n  sort(A.begin(), A.end());\n  if (A[0].first * 2 < A.back().first) return false;\n\n  vector<bool> isOne(K, false), isTwo(K, false);\n  int min = A[0].first, nTwos = 0;\n  for (int i = 0; i < K; ++i) {\n    if (min * 2 == A[i].first) {\n      isTwo[A[i].second] = true;\n      nTwos++;\n    }\n    if (min == A[i].first) isOne[A[i].second] = true;\n  }\n  reverse(prefix.begin(), prefix.end());\n  while (prefix.size() && isTwo[prefix.back()]) {\n    nTwos--;\n    prefix.pop_back();\n  }\n  if (!nTwos) return true;\n  for (int x : prefix)\n    if (isOne[x]) return false;\n  return true;\n}\n\nbool possible(vector<pair<int, int>> A, const vector<int>& suffix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n  for (int i = 0; i < K; ++i) {\n    if (possiblePrefix(A, {})) return true;\n    int j = where[suffix[i]];\n    if (A[j].first == 0) break;\n    A[j].first--;\n  }\n  return false;\n}\n\nbool possibleFinish(vector<pair<int, int>> A, vector<int>& B, int coveredUpTo) {\n  int K = A.size();\n  vector<bool> seen(K, false);\n  vector<int> prefix;\n  if (B.size()) {\n    for (int32_t i = B.size() - 1; i >= 0; --i) {\n      if (seen[B[i]]) {\n        if (coveredUpTo <= i) return false;\n        break;\n      }\n      prefix.push_back(B[i]);\n      seen[B[i]] = true;\n    }\n  }\n  reverse(prefix.begin(), prefix.end());\n\n  if ((int)prefix.size() == K) return possible(A, prefix);\n  return possiblePrefix(A, prefix);\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n  vector<int> B;\n\n  if (!possibleFinish(A, B, 0)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int coveredUpTo = 0;\n  while (true) {\n    int tot = 0;\n    for (auto& p : A) tot += p.first;\n    if (tot == 0) break;\n\n    vector<int> where(K);\n    for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n    int x = -1;\n    for (int i = 0; i < K; ++i) {\n      if (A[where[i]].first == 0) continue;\n\n      A[where[i]].first--;\n      B.push_back(i);\n      if (possibleFinish(A, B, coveredUpTo)) {\n        x = i;\n        break;\n      }\n      B.pop_back();\n      A[where[i]].first++;\n    }\n    assert(x != -1);\n    if (B.size() >= K) {\n      vector<int> p(B.end() - K, B.end());\n      sort(p.begin(), p.end());\n      bool isPerm = true;\n      for (int i = 0; i < K; ++i) isPerm &= p[i] == i;\n      if (isPerm) {\n        assert(coveredUpTo + K >= B.size());\n        coveredUpTo = B.size();\n      }\n    }\n  }\n\n  assert(coveredUpTo == B.size());\n  for (int x : B) cout << x + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint a[110],p[1010],pl[110];\nbool bl[110];\nint main()\n{\n\tre int n=0,k,mx=0,mm=0,mk=0;\n\tscanf(\"%d\",&k);\n\tfor(re int i=1;i<=k;i++)scanf(\"%d\",&a[i]),n+=a[i],mx=std::max(mx,a[i]);\n\tfor(re int i=1;i<=k;i++)if(a[i]*2<mx){puts(\"-1\");return 0;}\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tre int j=1;\n\t\tfor(;j<=k;j++)\n\t\t{\n\t\t\tif((!bl[j])&&a[j]*2-1>=mx)break;\n\t\t}\n\t\tbl[j]=1;p[i]=j;a[j]--;mx=0;mm++;mk=std::max(mk,pl[j]);\n\t\tif(i>=k&&(i==k||mm==mk))\n\t\t{\n\t\t\tfor(re int j=1;j<=k;j++)bl[j]=0,pl[p[i-k+j]]=j;mm=mk=0;\n\t\t}\n\t\tfor(re int j=1;j<=k;j++)mx=std::max(mx,a[j]);\n\t}\n\tfor(re int i=1;i<=n;i++)printf(\"%d \",p[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\ntypedef std::pair<std::vector<int>,std::vector<int> > stacks;\nstacks trans(stacks ss,int i,int K,bool&fl){\n\tstd::vector<int>s1,s2;\n\tfor(int j=ss.second.size();j--&&fl;)if(ss.second[j]==i)return fl=0,std::make_pair(s1,s2);\n\tint j=0;while(j<ss.first.size()&&ss.first[j]!=i)j++;\n\tif(j==ss.first.size()&&ss.first.size()+ss.second.size()+1==K||!j&&ss.first.size()==K){\n\t\tfor(j==ss.first.size()?j=0:++j;j<ss.first.size();j++)s1.push_back(ss.first[j]);\n\t\tfor(j=0;j<ss.second.size();j++)s1.push_back(ss.second[j]);\n\t\ts1.push_back(i);\n\t}\n\telse{\n\t\tfor(j==ss.first.size()?j=0:++j;j<ss.first.size();j++)s1.push_back(ss.first[j]);\n\t\ts2=ss.second;s2.push_back(i);\n\t}\n\treturn std::make_pair(s1,s2);\n}\nbool chk(std::pair<stacks,std::vector<int> >st){\n\tstacks ss=st.first;\n\tstd::vector<int>c=st.second;\n\tint N=0,K=c.size();\n\tfor(int i=ss.second.size();i--;)c[ss.second[i]]++;\n\tfor(int i=0;i<K;i++)N+=c[i];\n\tif(!N)return!ss.second.size();\n\tint ty[K],M=0;\n\tfor(int i=0;i<K;i++)ty[i]=0,c[i]>M?M=c[i]:1;\n\tfor(int i=0;i<ss.first.size();i++)ty[ss.first[i]]=1;\n\tfor(int i=0;i<ss.second.size();i++)ty[ss.second[i]]=2;\n\tbool fl=1;\n\tint p=ss.first.size(),q=ss.second.size();\n\twhile(p&&c[ss.first[p-1]]<M)--p;\n\tfor(int i=0;i<K;i++)if(!ty[i])ty[i]=c[i]==M?fl=0,3:2;\n\tfor(int i=0;i<p;i++)ty[ss.first[i]]=c[ss.first[i]]==M?fl=0,3:2;\n\tif(fl)while(q&&c[ss.second[q-1]]<M)--q;\n\telse fl=1;\n\tfor(int i=0;i<q;i++)ty[ss.second[i]]=3;\n\tfor(int i=0;i<K&&fl;i++)if(c[i]<M){\n\t\tif(ty[i]+(M-c[i]-1)*2>M)fl=0;\n\t}\n\treturn fl;\n}\nint main(){\n\tint K;\n\twhile(scanf(\"%d\",&K)==1){\n\t\tint N=0;\n\t\tstacks ss;\n\t\tstd::vector<int>c;\n\t\tfor(int i=0,x;i<K;i++)scanf(\"%d\",&x),c.push_back(x),N+=x;\n\t\tif(!chk(std::make_pair(ss,c)))puts(\"-1\");\n\t\telse while(N--){\n\t\t\tbool fl=0;\n\t\t\tfor(int i=0;i<K&&!fl;i++)if(c[i]){\n\t\t\t\tc[i]--;fl=1;\n\t\t\t\tstacks ns=trans(ss,i,K,fl);\n\t\t\t\tif(fl&&chk(std::make_pair(ns,c)))ss=ns,printf(\"%d%c\",i+1,\" \\n\"[!N]);\n\t\t\t\telse fl=0,c[i]++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,ll>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1005;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint k,a[MAXN],n,res[MAXN],len;\ninline bool check(){int Mn=a[1],Mx=a[1];Rep(i,1,k)Mn=min(Mn,a[i]),Mx=max(Mx,a[i]);return Mn*2>=Mx;}\ninline void Merge(int*x,int*y,int*z,int l1,int l2){\n\tint l=0,i=1,j=1;\n\tfor(;i<=l1&&j<=l2;)if(x[i]<=y[j])z[++l]=x[i++];else z[++l]=y[j++];\n\tfor(;i<=l1;z[++l]=x[i++]);for(;j<=l2;z[++l]=y[j++]);\n}\ninline vector<int>Solve(int le){\n\tint l1=0,l2=0,l3=0;static int x[MAXN],y[MAXN],z[MAXN],b[MAXN],vis[MAXN];\n\tRep(i,1,k)vis[i]=0,b[i]=a[i];\n\tRep(i,0,k-le-1)vis[res[len-i]]=1;\n\tRep(i,1,k){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint Mn=b[1],Mx=b[1];Rep(i,1,k)Mn=min(Mn,b[i]),Mx=max(Mx,b[i]);\n\tif(Mn*2>=Mx){vector<int>tmp;Rep(i,1,k)if(!vis[i])tmp.pb(i);return tmp;}\n\telse if(Mn*2+1==Mx){\n\t\tRep(i,1,k)if(!vis[i]&&b[i]==Mx)x[++l1]=i;\n\t\tRep(i,1,k)if(!vis[i]&&b[i]==Mn)x[++l1]=i;\n\t\tRep(i,1,k)if(!vis[i]&&b[i]!=Mx&&b[i]!=Mn)y[++l2]=i;\n\t\tMerge(x,y,z,l1,l2),l3=l1+l2;int p1=0,p2=0;vector<int>tmp(z+1,z+l3+1);\n\t\tRep(i,len-(k-le-1),len){if(b[res[i]]==Mx)p1=i;if(b[res[i]]==Mn&&!p2)p2=i;}\n\t\tRep(i,1,l3){if(b[z[i]]==Mx)p1=i+len;if(b[z[i]]==Mn&&!p2)p2=i+len;}\n\t\tif(p1<p2)return tmp;return vector<int>(1,k+1);\n\t}else return vector<int>(1,k+1);\n}\ninline bool cmp(vector<int>a,vector<int>b){for(int i=0;i<a.size();i++){if(i>=b.size()||a[i]>b[i])return 1;if(a[i]<b[i])return 0;}return 0;}\ninline void Ins(){\n\tvector<int>ext(1,k+1);\n\tfor(int i=1;i<=k&&i+len<=n;i++)if(len-k+i+1>0){\n\t\tvector<int>now=Solve(i);\n\t\tif(cmp(ext,now))ext=now;\n\t}for(auto o:ext)cout<<o<<' ',res[++len]=o,a[o]--;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tk=read();\n\tRep(i,1,k)a[i]=read(),n+=a[i];\n\tif(!check())return puts(\"-1\"),0;\n\twhile(len<n)Ins();\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e3+10;\nint n,cnt[N],s,m,ans[N];\n\nint b[N];\npoly res;\nbool vis[N];\ninline bool check(int len){\n\tint las=n-len;\n\tif (m-las+1<=0||m+len>s) return 0;\n\tFor(i,1,n) vis[i]=0;\n\tFor(i,m-las+1,m) vis[ans[i]]=1;\n\tint mn=1e9,mx=0;\n\tFor(i,1,n) b[i]=cnt[i]-(vis[i]^1),mn=min(mn,b[i]),mx=max(mx,b[i]);\n\tif (mn<0) return 0;\n\tres={};\n\tif (mn*2>=mx){\n\t\tFor(i,1,n) if (!vis[i]) res.pb(i);\n\t\treturn 1;\n\t} else if (mn*2+1==mx){\n\t\tint cnt=0;\n\t\tFor(i,1,n) if (!vis[i]) cnt+=b[i]==mx;\n\t\tpoly tmp;\n\t\tFor(i,1,n) if (!vis[i]){\n\t\t\tif (b[i]!=mx&&b[i]!=mn) res.pb(i),vis[i]=1;\n\t\t\telse if (b[i]==mx){\n\t\t\t\tres.pb(i),vis[i]=1,--cnt;\n\t\t\t\tif (cnt==0)\tfor (auto j:tmp) res.pb(j);\n\t\t\t} else if (b[i]==mn){\n\t\t\t\tif (cnt==0) res.pb(i),vis[i]=1;\n\t\t\t\t\telse tmp.pb(i);\n\t\t\t}\n\t\t}\n\t\tint r=0,l=0;\n\t\tFor(i,1,las){\n\t\t\tif (b[ans[m-i+1]]==mx) r=i;\n\t\t\tif (b[ans[m-i+1]]==mn&&!l) l=i;\n\t\t}\n\t\tFOR(i,0,siz(res)){\n\t\t\tif (b[res[i]]==mx) r=las+i+1;\n\t\t\tif (b[res[i]]==mn&&!l) l=las+i+1; \n\t\t}\n\t\tif (r<l) return 1;\n\t\t\telse return 0;\n\t} else return 0;\n}\ninline bool check(poly a,poly b){\n\tint n=max(siz(a),siz(b));\n\ta.resize(n),b.resize(n);\n\tFOR(i,0,n) if (a[i]!=b[i]) return a[i]<b[i];\n\treturn 0;\n}\ninline void insert(){\n\tpoly ret;\n\tFor(i,1,n)\n\t\tif (check(i))\n\t\t\tif (ret.empty()||check(res,ret)) ret=res;\n\tfor (auto i:ret) ans[++m]=i,cnt[i]--;\n}\n\nint main(){\n\tn=read();\n\tint mx=0,mn=1e9;\n\tFor(i,1,n){\n\t\tcnt[i]=read(),s+=cnt[i];\n\t\tmx=max(mx,cnt[i]),mn=min(mn,cnt[i]);\n\t}\n\tif (mn*2<mx) return puts(\"-1\"),0;\n\twhile (m<s) insert();\n\tFor(i,1,m) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<string>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    if (a[1] > 0) {\n        for (int i = 1; i <= k; ++i) {\n            for (int j = cr; j >= cl; --j) {\n                if (a[i] == 0) {\n                    cl = j + 1;\n                    break;\n                }\n                --a[i];\n                vs[j].insert(to_string(i));\n            }\n        }\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(to_string(i)) == 0) {\n                        --a[i];\n                        vs[ind].insert(to_string(i));\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(to_string(i)) == 0) {\n                        vs[cl].insert(to_string(i));\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<string> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(to_string(i));\n        }\n        for (string i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (string i : inv) {\n            cout << i << \" \";\n        }\n        for (string i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2020.06.28 19:33:21\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\nint main() {\n    int n, sum = 0, mi = INF, mx = -INF;\n    scanf(\"%d\", &n);\n    vector<int> a(n), ans;\n    for(auto &g : a) {\n        scanf(\"%d\", &g);\n        mi = min(mi, g);\n        mx = max(mx, g);\n        sum += g;\n    }\n    if(mi * 2 < mx) { puts(\"-1\"); return 0; }\n    while((int)ans.size() < sum) {\n        vector<int> add, left, vis, bestleft;\n        for(int len = 1; len <= n; ++len) {\n            if((int)ans.size() + len < n || (int)ans.size() + len > sum) continue;\n            vector<int> vals;\n            left = a, vis.assign(n, 1);\n            for(int j = 0; j < n - len; ++j)\n                vis[ans[ans.size()-j-1]] = 0;\n            for(int j = 0; j < n; ++j) if(vis[j])\n                left[j]--, vals.push_back(j);\n            mi = INF, mx = -INF;\n            for(int j = 0; j < n; ++j) {\n                mi = min(mi, left[j]);\n                mx = max(mx, left[j]);\n            }\n            if(mi < 0 || mi * 2 + 1 < mx) continue;\n            int idx = INF, xdx = -INF;\n            for(int j = (int)ans.size()-len+n; j < (int)ans.size(); ++j) {\n                if(left[ans[j]] == mi) idx = min(idx, j);\n                if(left[ans[j]] == mx) xdx = max(xdx, j);\n            }\n            if(mi * 2 + 1 == mx && idx < xdx) continue;\n            xdx = -INF;\n            for(int j = 0; j < n; ++j) if(left[j] == mx) xdx = j;\n#define key(x) (left[x] == mi ? pii(max(x, xdx), x+1) : pii(x, 0))\n            if(mi * 2 + 1 == mx)\n                sort(vals.begin(), vals.end(), [&](int x, int y) { return key(x) < key(y);} );\n            else sort(vals.begin(), vals.end());\n            if(add.empty() || add > vals) add = vals, bestleft = left;\n        }\n        assert(!add.empty());\n        a = bestleft, ans.insert(ans.end(), add.begin(), add.end());\n    }\n    for(auto g : ans)\n        printf(\"%d \", g + 1);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 110;\n\nint N;\nint arr[MAXN];\n\nint parr[MAXN];\nbool used[MAXN];\nbool pp[MAXN];\n\nvector <int> figure (int K)\n{\n    for (int i = 0; i < N; i++)\n        arr[i] = parr[i] - K;\n\n    vector <int> res;\n    for (int i = 0; i < K; i++)\n    {\n        int hneed = -1; // latest one we need\n        int lcant = 1e6; // earliest one we cant\n        for (int j = 0; j < N; j++)\n        {\n            if (!arr[j])\n                lcant = min (lcant, j);\n            if (arr[j] == K - i)\n                hneed = j;\n        }\n\n        if (hneed < lcant)\n        {\n            for (int j = 0; j < N; j++)\n                res.push_back(j);\n            if (hneed == -1 && lcant > 0)\n                hneed = 0;\n            for (int j = 0; j <= hneed; j++)\n            {\n                res.push_back(j);\n                arr[j]--;\n            }\n            continue;\n        }\n        else\n        {\n            for (int j = 0; j <= hneed; j++)\n            {\n                used[j] = false;\n                if (arr[j])\n                {\n                    used[j] = true;\n                    arr[j]--;\n                }\n            }\n\n            for (int j = 0; j < N; j++)\n                if (used[j]) res.push_back(j);\n            int fnum = N;\n            {\n                for (int k = 0; k < N; k++)\n                    pp[k] = false;\n                for (int k = max (0, (int) res.size() - N); k < res.size(); k++)\n                    pp[res[k]] = true;\n\n                bool good = true;\n                for (int k = 0; k < N; k++)\n                    if (!pp[k])\n                        good = false;\n                if (good)\n                {\n                    fnum = -1;\n                }\n            }\n\n            for (int j = 0; j < fnum; j++)\n            {\n                if (!used[j])\n                {\n                    res.push_back(j);\n                    for (int k = 0; k < N; k++)\n                        pp[k] = false;\n                    for (int k = max (0, (int) res.size() - N); k < res.size(); k++)\n                        pp[res[k]] = true;\n\n                    bool good = true;\n                    for (int k = 0; k < N; k++)\n                        if (!pp[k])\n                            good = false;\n                    if (good)\n                    {\n                        fnum = j;\n                        break;\n                    }\n                }\n            }\n            for (int j = 0; j < N; j++)\n                if (used[j] || j > fnum)\n                    res.push_back(j);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    int lo = 1e6, hi = 0;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        parr[i] = arr[i];\n        lo = min (lo, arr[i]);\n        hi = max (hi, arr[i]);\n    }\n\n    if (lo * 2 < hi)\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    vector <int> res;\n    for (int x = (hi + 1) / 2; x <= lo; x++)\n    {\n        vector <int> v = figure (x);\n        if (!v.size()) continue;\n        if (!res.size())\n            res = v;\n\n        bool f = false;\n        for (int i = 0; i < res.size(); i++)\n        {\n            if (v[i] != res[i])\n            {\n                if (v[i] < res[i])\n                {\n                    f = true;\n                }\n                break;\n            }\n        }\n        if (f)\n            res = v;\n    }\n\n    for (int i = 0; i < res.size(); i++)\n    {\n        if (i) cout << \" \";\n        cout << res[i] + 1;\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define N 1010\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N],k,now,ans[N];\nconst vector<int> inf(1,23333);\nbool check(){\n\tint x=*max_element(a+1,a+k+1);\n\tint y=*min_element(a+1,a+k+1);\n\treturn x<=(y<<1);\n}\nvoid Merge(vector<int> &a,vector<int> &b,vector<int> &c){\n\tint pa=0,pb=0;\n\twhile(pa<(int)a.size()&&pb<(int)b.size()){\n\t\tc.push_back(a[pa]<b[pb]?a[pa++]:b[pb++]);\n\t}\n\twhile(pa<(int)a.size())c.push_back(a[pa++]);\n\twhile(pb<(int)b.size())c.push_back(b[pb++]);\n}\nvector<int> Solve(int len){\n\tstatic int vis[N],b[N];\n\tfor(int i=1;i<=k;++i){\n\t\tvis[i]=0,b[i]=a[i];\n\t}\n\tfor(int i=now+len-k+1;i<=now;++i){\n\t\tvis[ans[i]]=1;\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\tif(!vis[i])if((--b[i])<0)return inf;\n\t}\n\tint mn=*min_element(b+1,b+k+1);\n\tint mx=*max_element(b+1,b+k+1);\n\tif(mn*2+1<mx)return inf;\n\tvector<int> res;\n\tif(mn*2>=mx){\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i])res.push_back(i);\n\t\t}\n\t}\n\telse{\n\t\tvector<int> A,B,all;\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mx)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mn)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]^mn&&b[i]^mx)B.push_back(i);\n\t\t}\n\t\tfor(int i=now+len-k+1;i<=now;++i)all.push_back(ans[i]);\n\t\tMerge(A,B,res);\n\t\tall.insert(all.end(),res.begin(),res.end());\n\t\tint pmx=-1,pmn=n+1;\n\t\tfor(int i=0;i<(int)all.size();++i){\n\t\t\tif(b[all[i]]==mx)pmx=max(pmx,i);\n\t\t\tif(b[all[i]]==mn)pmn=min(pmn,i);\n\t\t}\n\t\tif(pmx>pmn)res=inf;\n\t}\n\treturn res;\n}\nvoid Extend(){\n\tvector<int> ext=inf;\n\tfor(int len=1;len<=k&&len+now<=n;++len){\n\t\tif(len+now>=k){\n\t\t\text=min(ext,Solve(len));\n\t\t}\n\t}\n\tfor(auto x:ext){\n\t\tans[++now]=x;\n\t\t--a[x];\n\t}\n}\nint main(){\n\tk=read();\n\tfor(int i=1;i<=k;++i){\n\t\tn+=a[i]=read();\n\t}\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(now<n){\n\t\tExtend();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\nconst int N = 105; \n\nint n, a[N], s, mx_a, v[N];\nint main(int argc,char *argv[]){\n\t//freopen(\"d.in\", \"r\", stdin); \n\tcin >> n;\n\tvector<int> ans, cur_left(n); \n\tlop(i, 0, n) {\n\t\tcin >> cur_left[i]; \n\t\ts += cur_left[i]; \n\t\tcmax(mx_a, cur_left[i]); \n\t}\n\tlop(i, 0, n) if (mx_a > cur_left[i]*2) {\n\t\tcout << -1 << endl;\n\t\treturn 0; \n\t}\n\twhile (ans.size() < s) {\n\t\tint m = ans.size();\n\t\tvector<int> best_left, best_add;\n\t\trep(len, 1, n) {\n\t\t\tif (m+len < n || m+len > s) continue;\n\t\t\tauto left = cur_left; \n\t\t\tlop(i, 0, n) v[i] = 1;\n\t\t\tlop(i, m-(n-len), m) \n\t\t\t\tv[ans[i]] = 0;\t\n\t\t\tlop(i, 0, n) if (v[i]) --left[i]; \n\t\t\tint mn = left[0], mx = left[0];\n\t\t\tlop(i, 1, n) {\n\t\t\t\tcmin(mn, left[i]); \n\t\t\t\tcmax(mx, left[i]); \n\t\t\t}\n\t\t\tint mn_idx = n, mx_idx = -1, fail = 0, mx_r;\n\t\t\tlop(i, m-(n-len), m) {\n\t\t\t\tif (left[ans[i]] == mn) cmin(mn_idx, i-(m-(n-len))); \n\t\t\t\tif (left[ans[i]] == mx) cmax(mx_idx, i-(m-(n-len))); \n\t\t\t}\n\t\t\tif (mx <= mn*2) ;\n\t\t\telse if (mx == mn*2+1) {\n\t\t\t\tfail |= mn_idx < mx_idx; \n\t\t\t} else fail = 1;\n\t\t\tif (fail) continue;\n\t\t\tvector<int> add;\n\t\t\tif (mx == mn*2+1){\n\t\t\t\tlop(i, 0, n) if (v[i] && left[i] == mx) mx_r = i;\n\t\t\t\tvector<int> z;\n\t\t\t\tlop(i, 0, n) if (v[i]) {\n\t\t\t\t\tif ((i > mx_r) || (left[i] > mn)) add.pb(i); \n\t\t\t\t\telse z.pb(i); \n\t\t\t\t\tif (i == mx_r) {\n\t\t\t\t\t\tadd.insert(add.end(), z.begin(), z.end()); \n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t} else {\n\t\t\t\tlop(i, 0, n) if (v[i]) add.pb(i); \n\t\t\t}\n\t\t\tif (best_add.empty() || add < best_add) best_add = add, best_left = left;\n\t\t}\n\t\tcur_left = best_left; \n\t\tans.insert(ans.end(), best_add.begin(), best_add.end()); \n\t}\n\tfor (int x : ans) cout << x+1 << \" \"; \n\tcout << endl;\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass EPermutationCover {\npublic:\n    void solve() {\n        int k = in.readInt();\n        auto a = in.readIntArray(k);\n\n        if (*min_element(all(a)) * 2 < *max_element(all(a))) {\n            out.printLine(-1);\n            return;\n        }\n        vi p;\n        int lastPerm = 0;\n        arri last(k, -k);\n        while (true) {\n            int mx = *max_element(all(a));\n            if (mx == 0) {\n                break;\n            }\n            bool found = false;\n            for (int i : range(k)) {\n                if (a[i] == 0 || mx >= 2 * a[i]) {\n                    continue;\n                }\n                bool bad = false;\n                for (int j : range(lastPerm, p.size())) {\n                    if (p[j] == i + 1) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    continue;\n                }\n                found = true;\n                last[i] = p.size();\n                a[i]--;\n                p.push_back(i + 1);\n                break;\n            }\n            if (!found) {\n                throw \"Jopa\";\n            }\n            if (*min_element(all(last)) >= p.size() - k) {\n                lastPerm = p.size();\n            }\n        }\n        out.printLine(p);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    EPermutationCover solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tif (pre < len) {\n\t\tprintf(\"WA\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tif (pre < len) {\n\t\tprintf(\"WA\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[i] <= num && num <= (a[i] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) len = pre - i;\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 2111;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N], b[N];\nvector<int> s[N];\nbool f[N], pre[N];\nint main() {\n\tint k;\n\tscanf(\"%d\", &k);\n\tint x = 0;\n\tfor(int i = 1; i <= k; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx = max(x, a[i]);\n\t}\n\tmemcpy(b, a, sizeof(b));\n\tvector<int> aa;\n\tfor(;; x++) {\n\t\tbool flag = true;\n\t\tmemcpy(a, b, sizeof(a));\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tif(x - a[i] <= (x / 2)) {\n\n\t\t\t}else flag = false;\n\t\t}\n\t//\tcout << x << ' ' << flag << endl;\n\t\tif(!flag) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tfor(int i = 1; i < x; i++) s[i].clear();\n\t\tfor(int i = 1; i < x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(a[j] + (x - i) / 2 < x) {\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ta[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = k; j >= 1; j--) {\n\t\t\t\tif(a[j] < x && pre[j] == 0 && f[j] == 0 && !(s[i].size() == k - 1 && j == 1)) {\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\ta[j]++;\n\t\t\t\t}else if(f[j]) {\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tmemcpy(pre, f, sizeof(pre));\n\t\t}\n\t\tvector<int> ans;\n\t\tfor(int i = 1; i <= x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int k : s[i - 1]) f[k] = 1;\n\t\t\tfor(int k : s[i]) f[k] = 1;\n\t\t\tfor(int j = 1; j <= k; j++) if(!f[j]) ans.pb(j);\n\t\t\tif(i < x) {\n\t\t\t\tsort(s[i].begin(), s[i].end());\n\t\t\t\tfor(int j : s[i]) ans.pb(j);\n\t\t\t}\n\t\t}\n\t\tif(aa.empty() || ans < aa) aa = ans;\n\t}\n\tvector<int> ans;\n\tif(aa.empty()) {\n\n\t\tprintf(\"%d\\n\", -1);\n\t\treturn 0;\n\t}else ans = aa;\n\tfor(int i = 0; i < (int)ans.size(); i++) {\n\t\tprintf(\"%d%c\", ans[i], i == (int)ans.size() - 1 ? '\\n' : ' ');\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100, MP = 100000;\n\nint k, c[MX], p[MP], lastPos[MX];\n\nbool check(int a, int b, int n) {\n\tfor (int i = 0; i < k; i++)\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tif (i == j) continue;\n\t\t\t\n\t\t\tint cntI = c[i];\n\t\t\tint cntJ = c[j];\n\t\t\t\n\t\t\tif (lastPos[i] >= b) {\n\t\t\t\t// need to cover last 'i'\n\t\t\t\t\n\t\t\t\tif (lastPos[j] >= a) {\n\t\t\t\t\t// last 'j' can be used to cover last 'i'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// last 'j' can not be used anymore\n\t\t\t\t\tcntI++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (lastPos[j] > lastPos[i] && lastPos[j] >= a) {\n\t\t\t\t// can use last 'j' to cover the next 'i'\n\t\t\t\tcntI--;\n\t\t\t}\n\t\t\t\n\t\t\tif (cntI > 2 * cntJ) {\n//\t\t\t\tprintf(\"\\t%d %d %d -> %d %d | %d %d\\n\", a, b, n, i + 1, j + 1, cntI, cntJ);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\treturn true;\n}\n\npair<int, int> append(int a, int b, int n, int x) {\n\tp[n] = x;\n\tc[x]--;\n\ta = max(lastPos[x] + 1, a);\n\tlastPos[x] = n;\n\tn++;\n\t\n\tif (n - a == k) {\n\t\ta++;\n\t\tb = n;\n\t}\n\t\n\treturn {a, b};\n}\n\nbool tryAppend(int a, int b, int n, int x) {\n\tint xPos = lastPos[x];\n\t\n\tif (xPos >= b) return false;\n\t\n\tint aa, bb;\n\ttie(aa, bb) = append(a, b, n, x);\n\t\n\tbool res = check(aa, bb, n + 1);\n\t\n\tlastPos[x] = xPos;\n\tc[x]++;\n\t\n\treturn res;\n}\n\nint main() {\n\tignore = scanf(\"%d\", &k);\n\tfor (int i = 0; i < k; i++) ignore = scanf(\"%d\", c + i);\n\t\n\tfill(lastPos, lastPos + k, -1);\n\t\n\tif (check(0, 0, 0) == false) {\n\t\tprintf(\"%d\\n\", -1);\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint a = 0, b = 0, n = 0;\n\twhile (*max_element(c, c + k) > 0) {\n\t\tint x = 0;\n\t\twhile (x < k && tryAppend(a, b, n, x) == false) x++;\n\t\t\n\t\tif (x == k) {\n\t\t\tprintf(\"Fail\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\ttie(a, b) = append(a, b, n, x);\n\t\tn++;\n\t\t\n\t\tprintf(\"%d \", x + 1);\n\t}\n\t\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\tint ok=0;\n\trep(_,len){\n\t\tdmp2(ans,cur,ok);\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tvi tmp;\n\t\t\tint waf;\n\t\t\tif(p==si(cur)){\n\t\t\t\ttmp=cur;\n\t\t\t\twaf=ok;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ok<=p)continue;\n\t\t\t\ttmp=vi(cur.bg+p+1,cur.ed);\n\t\t\t\twaf=ok-(p+1);\n\t\t\t}\n\t\t\ttmp.pb(nx);\n\t\t\tif(si(tmp)==k)waf=k;\n\t\t\ta[nx]--;\n\t\t\tbool relka=false;\n\t\t\trep(j,waf+1){\n\t\t\t\tif(can(k,a,vi(tmp.bg+j,tmp.ed))){\n\t\t\t\t\tans.pb(nx);\n\t\t\t\t\tcur=tmp;\n\t\t\t\t\tok=waf;\n\t\t\t\t\tfound=true;\n\t\t\t\t\trelka=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(relka)break;\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    int m = *min_element(a.begin(), a.end());\n    if (2 * m < *max_element(a.begin(), a.end())) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    while (m > 0) {\n        vector<int> once;\n        vector<int> twice;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] == m) {\n                once.push_back(i + 1);\n                a[i] -= 1;\n            } else {\n                twice.push_back(i + 1);\n                a[i] -= 2;\n            }\n        }\n        --m;\n        for (int v: twice)\n            cout << v << \" \";\n        for (int v: once)\n            cout << v << \" \";\n        for (int v: twice)\n            cout << v << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint K,sum;\nvi _A,sol;\n\nint getSum(vi v) {\n\tint res = 0; trav(t,v) res += t;\n\treturn res;\n}\n\nbool initial(vi v) {\n\tvi A = _A; vector<bool> con(K);\n\t//dbg(\"OOPS\",sz(A),K);\n\ttrav(t,v) A[t] ++, con[t] = 1;\n\tvpi oops;\n\tF0R(i,K) if (!con[i]) oops.pb({A[i],i});\n\tsort(rall(oops));\n\ttrav(t,oops) v.pb(t.s);\n\tassert(sz(v) == K);\n\tint lef = getSum(A); assert(lef >= K);\n\tint l = MOD, r = -MOD;\n\ttrav(t,A) ckmin(l,t), ckmax(r,t);\n\tint lo = cdiv(lef,K), hi = lef/K*2;\n\tdbg(\"UHOH\",lef,v);\n\tFOR(num,lo,hi+1) {\n\t\tint LO = (num+1)/2, HI = num;\n\t\tif (LO <= l && r <= HI) {\n\t\t\tbool bad = 0;\n\t\t\tif (num > 1) {\n\t\t\t\tbool flag = 0;\n\t\t\t\ttrav(t,v) {\n\t\t\t\t\tflag |= A[t] == LO;\n\t\t\t\t\tif (A[t] == HI && flag) bad = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bad) {\n\t\t\t\tdbg(\"OK\",num,LO,HI);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\t/*vi con(K);\n\ttrav(t,v) {\n\t\tassert(!con[t]);\n\t\tcon[t] = 1;\n\t}\n\tF0R(i,K) if (!con[i]) {\n\t\tif (!A[i]) return 0;\n\t\tv.pb(i); A[i] --;\n\t}\n\tFOR(nex,1,K+1) {\n\n\t}\n\tdbg(\"AH\",v,A); exit(0);*/\n}\n\nbool ok() {\n\tvi cnt(K); int ok = 0;\n\tvi cool(sz(sol)+1);\n\tauto ad = [&](int r, int inc) {\n\t\tr = sol[r];\n\t\tok -= cnt[r] == 1;\n\t\tcnt[r] += inc;\n\t\tok += cnt[r] == 1;\n\t};\n\tint r = -1;\n\tF0R(l,sz(sol)-K+1) {\n\t\twhile (r < l+K-1) ad(++r,1);\n\t\tif (ok == K) cool[l] ++, cool[r+1] --;\n\t\tad(l,-1);\n\t}\n\tFOR(i,1,sz(sol)+1) cool[i] += cool[i-1];\n\tint fst = 0; while (cool[fst]) fst ++;\n\tif (sz(sol) == sum)  return fst == sum;\n\tcnt = vi(K);\n\tFOR(i,fst,sz(sol)) if (cnt[sol[i]]++) return 0;\n\tdbg(\"HA\",fst,sol);\n\t// fst to sz(sol)-1\n\tfor (int i = fst; i+K >= sz(sol); --i) {\n\t\t//dbg(\"TRYING\",i);\n\t\tif (i+K <= sum && initial(vi(begin(sol)+i,end(sol)))) return 1;\n\t\tif (i == 0) break;\n\t\tif (cnt[sol[i-1]]++) break;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tsetIO(); re(K); _A.rsz(K); re(_A);\n\ttrav(t,_A) sum += t;\n\tif (!ok()) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\twhile (sz(sol) < sum) {\n\t\tdbg(\"SOL\",sol);\n\t\tbool done = 0;\n\t\tF0R(i,K) if (_A[i]) {\n\t\t\t_A[i] --; sol.pb(i);\n\t\t\tif (ok()) { done = 1; break; }\n\t\t\t_A[i] ++; sol.pop_back();\n\t\t}\n\t\tassert(done);\n\t}\n\ttrav(t,sol) pr(t+1,' ');\n\tps();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,T y){\n\tif (y<x)\n\t\tx=y;\n}\n/*\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\n*/\nconst int N=1005;\nint k,n;\nint a[N],baka[N],b[N];\nint check_permutation(int L,int R){\n\tif (R>n||L<1||R-L+1!=k)\n\t\treturn 0;\n\tstatic int vis[N],Time=0;\n\tTime++;\n\tFor(i,L,R)\n\t\tif (vis[b[i]]==Time)\n\t\t\treturn 0;\n\t\telse\n\t\t\tvis[b[i]]=Time;\n\treturn 1;\n}\nint checkpos(int *pos){\n\tint mi=n,mx=-1;\n\tFor(i,1,k)\n\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\tif (mi*2+1<mx)\n\t\treturn 0;\n\tif (mi*2>=mx)\n\t\treturn 1;\n\t//mi * 2 + 1 == mx\n\tint mip=n+1,mxp=-1;\n\tFor(i,1,k)\n\t\tif (a[i]==mi)\n\t\t\tckmin(mip,pos[i]);\n\t\telse if (a[i]==mx)\n\t\t\tckmax(mxp,pos[i]);\n\treturn mxp<=mip;\n}\nint check(int p,int las){\n\tstatic int pos[N];\n\tFor(i,1,k)\n\t\tpos[i]=p+1;\n\tif (las==p)\n\t\treturn checkpos(pos);\n\tint cut=p;\n\t{\n\t\tvi vis(k+1,0);\n\t\tvis[b[cut]]=1;\n\t\twhile (cut-1>0&&!vis[b[cut-1]])\n\t\t\tcut--,vis[b[cut]]=1;\n\t}\n//\toutarr(b,1,n);\n//\toutval(cut);\n//\toutarr(a,1,k);\n\tif (cut>las+1)\n\t\treturn 0;\n\tFor(i,cut,p)\n\t\tpos[b[i]]=i;\n\tFor(i,1,k)\n\t\tif (pos[i]==p+1)\n\t\t\ta[i]--;\n//\toutarr(pos,1,k);\n//\toutarr(a,1,k);\n\tif (checkpos(pos))\n\t\treturn 1;\n\tFor(i,cut,las){\n\t\ta[b[i]]--;\n\t\tpos[b[i]]=p+1;\n\t\tif (checkpos(pos))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tk=read(),n=0;\n\tFor(i,1,k)\n\t\ta[i]=read(),n+=a[i];\n\t{\n\t\tint mi=n,mx=0;\n\t\tFor(i,1,k)\n\t\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\t\tif (mi*2<mx)\n\t\t\treturn puts(\"-1\"),0;\n\t}\n\tmemset(b,-1,sizeof b);\n\tint las=0;\n\tFor(i,1,n){\n\t\tFor(j,1,k)\n\t\t\tif (a[j]){\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\tbaka[t]=a[t];\n\t\t\t\ta[j]--,b[i]=j;\n\t\t\t\tint nextlas=check_permutation(i-k+1,i)?i:las;\n//\t\t\t\toutarr(b,1,n);outval(nextlas);\n\t\t\t\tif (check(i,nextlas)){\n\t\t\t\t\tlas=nextlas;\n\t\t\t\t\tFor(t,1,k)\n\t\t\t\t\t\ta[t]=baka[t];\n\t\t\t\t\ta[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb[i]=-1;\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\ta[t]=baka[t];\n\t\t\t}\n//\t\tprintf(\"b[%d] = %d\\n\",i,b[i]);\n\t\tassert(~b[i]);\n\t}\n\tFor(i,1,n)\n\t\tprintf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:45:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  {\n    int mn = *min_element(a.begin(), a.end());\n    int mx = *max_element(a.begin(), a.end());\n    if (2 * mn < mx) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  vector<int> b(n);\n  auto Can = [&]() {\n    debug(a, b);\n    vector<int> c(n);\n    int mn = 787788;\n    int mx = -787788;\n    for (int i = 0; i < n; i++) {\n      if (b[i] == 0) {\n        c[i] = -1;\n        mn = min(mn, a[i] - 1);\n        mx = max(mx, a[i] - 2);\n      } else {\n        c[i] = a[i] - b[i];\n        mn = min(mn, c[i]);\n        mx = max(mx, c[i]);\n      }\n    }\n    if (mn < 0 || mx < 0 || 2 * mn < mx) {\n      return false;\n    }\n    return true;\n  };\n  vector<int> ret;\n  while (*max_element(a.begin(), a.end()) > 0) {\n    bool done = false;\n    for (int cut = 1; cut < n; cut++) {\n      for (int i = 0; i < cut; i++) {\n        b[i] = 2;\n      }\n      for (int i = cut; i < n; i++) {\n        b[i] = 1;\n      }\n      if (Can()) {\n        done = true;\n        break;\n      }\n    }\n    if (!done) {\n      fill(b.begin(), b.end(), 1);\n      if (Can()) {\n        done = true;\n      }\n    }\n    if (!done) {\n      fill(b.begin(), b.end(), 0);\n      int pos = 0;\n      while (true) {\n        for (int i = pos; i < n; i++) {\n          b[i] = 1;\n        }\n        if (Can()) {\n          break;\n        }\n        for (int i = pos; i < n; i++) {\n          b[i] = 0;\n        }\n        bool found = false;\n        for (int i = pos; i < n; i++) {\n          b[i] = 2;\n          if (Can()) {\n            pos = i + 1;\n            found = true;\n            break;\n          }\n          b[i] = 1;\n        }\n        assert(found);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      a[i] -= b[i];\n    }\n    for (int x : {2, 1, 2}) {\n      for (int i = 0; i < n; i++) {\n        if (b[i] == x) {\n          ret.push_back(i);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < (int) ret.size(); i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << ret[i] + 1;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n \ntypedef long long ll;\n\ntypedef long double ld;\n \nusing namespace std;\n \nconst ll maxn = 1e3 + 10;\nconst ll inf = 998244353;\n\nll n, m, k, t;\n\nvector <ll> C;\n\nvector <ll> ANS;\n\nvoid make_move() {\n    vector <ll> bad;\n    vector <bool> used(n, 0);\n    ll q, w;\n    ll mn = inf, mx = 0, mni = 0;\n    for (q = 0; q < n; q++) {\n        used[q] = 0;\n        // mn = min(mn, C[q]);\n        if (C[q] < mn) {\n            mn = C[q];\n            mni = q;\n        }\n        mx = max(mx, C[q]);\n    }\n    for (q = 0; q < n; q++) {\n        if (C[q] == 2 * mn) {\n            bad.pb(q);\n            used[q] = 1;\n        }\n    }\n    for (q = 0; q < mni; q++) {\n        if (used[q]) {\n            continue;\n        }\n        bad.pb(q);\n        used[q] = 1;\n    }\n    sort(all(bad));\n    for (auto x : bad) {\n        ANS.pb(x);\n        C[x]--;\n    }\n    for (q = 0; q < n; q++) {\n        if (!used[q]) {\n            C[q]--;\n            ANS.pb(q);\n        }\n    }\n    for (auto x : bad) {\n        ANS.pb(x);\n        C[x]--;\n    }\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    cin >> n;\n    C.resize(n);\n    ll mn = inf, mx = 0;\n    for (q = 0; q < n; q++) {\n        cin >> C[q];\n        mn = min(mn, C[q]);\n        mx = max(mx, C[q]);\n    }\n    if (mx > 2 * mn) {\n        cout << -1;\n        return 0;\n    }\n    while (1) {\n        ll mn = inf, mx = 0;\n        for (q = 0; q < n; q++) {\n            mn = min(mn, C[q]);\n            mx = max(mx, C[q]);\n        }\n        if (mx == 0) {\n            break;\n        }\n        make_move();\n    }\n    for (q = 0; q < ANS.size(); q++) {\n        cout << ANS[q] + 1 << \" \";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10;\n\nint ans[N],k,a[110],n;\nbool cov[N],print;\n\nbool isdiff(int l,int r) {\n\tstatic bool vis[110];\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=l;i<=r;i++) {\n\t\tif(vis[ans[i]]) return 0;\n\t\tvis[ans[i]]=1;\n\t}\n\treturn 1;\n}\n\nbool check(int len) {\n\tstatic int aa[110];\n\tint st=0;\n\tif(len-k+1>0&&isdiff(len-k+1,len)) {\n\t\tst=len+1;\n\t\tif(len==n) return 1;\n\t}\n\telse {\n\t\tst=len;while(st>1&&!cov[st-1]) --st;\n\t\t//for(int i=st;i<=len;i++) ++aa[ans[i]];\n\t}\n\twhile(isdiff(st,len)) {\n\t\tint l=1,r=1e9;memcpy(aa,a,sizeof(a));\n\t\tfor(int i=st;i<=len;i++) ++aa[ans[i]];\n\t\tfor(int i=1;i<=k;i++) {\n\t\t\tl=max(l,aa[i]);\n\t\t\tr=min(r,2*aa[i]);\n\t\t}\n\t\tif(l>r) { --st; continue; }\n\t\tif(r-l>1||(l&1)||len==0) return 1;\n\t\tstatic bool vis[110];\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=st;i<=len;i++) vis[ans[i]]=1;\n\t\tbool fl=1;\n\t\tfor(int i=st;i<=len;i++)\n\t\t\tif(l-aa[ans[i]]==l/2) {\n\t\t\t\tfor(int j=i+1;j<=len;j++)\n\t\t\t\t\tif(l-aa[ans[j]]==0) { fl=0;break; }\n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t\tif(!vis[j]&&l-aa[j]==0) { fl=0;break; }\n\t\t\t\tif(!fl) break;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\tif(fl) return 1;\n\t\t--st;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>k;\n\tfor(int i=1;i<=k;i++) cin>>a[i],n+=a[i];\n\tif(!check(0)) return cout<<-1,0;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=k;j++) {\n\t\t\tans[i]=j;--a[j];\n\t\t\t/*if(i==3&&j==3) {\n\t\t\tfor(int j=1;j<=k;j++) cerr<<a[j]<<' ';\n\t\t\treturn 0;\n\t\t\t}*/\n\t\t\t//print=(i==3&&j==3);\n\t\t\tif(check(i)) break;\n\t\t\t++a[j];\n\t\t}\n\t\tif(i>=k&&isdiff(i-k+1,i))\n\t\t\tfor(int j=i-k+1;j<=i;j++) cov[j]=1;\n\t}\n\tfor(int i=1;i<=n;i++) cout<<ans[i]<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\tint ok=0;\n\trep(_,len){\n\t\tdmp2(ans,cur,ok);\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tvi tmp;\n\t\t\tint waf;\n\t\t\tif(p==si(cur)){\n\t\t\t\ttmp=cur;\n\t\t\t\twaf=ok;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ok<=p)continue;\n\t\t\t\ttmp=vi(cur.bg+p+1,cur.ed);\n\t\t\t\twaf=ok-(p+1);\n\t\t\t}\n\t\t\ttmp.pb(nx);\n\t\t\tif(si(tmp)==k)waf=k;\n\t\t\ta[nx]--;\n\t\t\tbool relka=false;\n\t\t\tper(j,waf+1){\n\t\t\t\tif(can(k,a,vi(tmp.bg+j,tmp.ed))){\n\t\t\t\t\tans.pb(nx);\n\t\t\t\t\tcur=tmp;\n\t\t\t\t\tok=waf;\n\t\t\t\t\tfound=true;\n\t\t\t\t\trelka=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(relka)break;\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nbool suc = false;\n\nint n;\n \nvoid change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n\n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\tif (2*minimum.first < maximum.first) {\n\t\tsuc = false;\n\t\treturn;\n\t}\n\tcout << u+1 << \" \";\n\tsuc = true;\n\n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n}\n \nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n \n\tsort(all(arr));\n \n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n \n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tchange(arr, i);\n\t\t}\n\n\t\tchange(arr, 0);\n\t\tif (!suc) break;\n\n\t}\n \n\tint u = 0;\n\twhile (true) {\n \n\t\tchange(arr, u);\n\t\tif (suc) u = (u+1)%n;\n\t\telse break;\n \n\t}\n \n \n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n \n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    for (int i = 0; i < a[1]; ++i) {\n        vs[i].insert(1);\n    }\n    if (a[1] > 0) {\n        for (int i = 2; i <= k; ++i) {\n            if (a[i] > 0) {\n                --a[i];\n                vs[a[1] - 1].insert(i);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < len && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\n\nint state[MAXVALS];\nint nrem[MAXVALS];\n\n\nbool solve() {\n\tans.clear();\n\tREP(i, nvals) rem[i] = cnt[i];\n\twhile (true) {\n\t\t//printf(\"prefix:\"); REPSZ(i, ans) printf(\" %d\", ans[i] + 1); puts(\"\");\n\t\tbool done = true; REP(i, nvals) if (rem[i] > 0) done = false; if (done) break;\n\t\tvector<int> best;\n\t\tREPE(overlap, nvals - 1) {\n\t\t\tif (overlap > SZ(ans)) continue;\n\t\t\tREP(i, nvals) state[i] = nvals;\n\t\t\tREP(i, overlap) state[ans[SZ(ans) - overlap + i]] = i;\n\t\t\tREP(i, nvals) nrem[i] = rem[i] - (state[i] == nvals ? 1 : 0);\n\t\t\tint mn = nrem[0], mx = nrem[0]; FOR(i, 1, nvals) { if (nrem[i] < mn) mn = nrem[i]; if (nrem[i] > mx) mx = nrem[i]; }\n\t\t\tif (mn < 0) continue;\n\t\t\tif (mx > 2 * mn + 1) continue;\n\t\t\tvector<int> cur;\n\t\t\tif (mx == 2 * mn + 1) {\n\t\t\t\tint firstmn = nvals + 1, lastmx = -1;\n\t\t\t\tREP(i, nvals) { if (nrem[i] == mn && state[i] < firstmn) firstmn = state[i]; if (nrem[i] == mx && state[i] > lastmx) lastmx = state[i]; }\n\t\t\t\tif (firstmn < lastmx) continue;\n\t\t\t\tint nmx = 0; REP(i, nvals) if (state[i] == nvals && nrem[i] == mx) ++nmx;\n\t\t\t\tREP(i, nvals) if (state[i] == nvals && (nrem[i] != mn || nmx == 0)) { cur.PB(i); if (nrem[i] == mx) { --nmx; if (nmx == 0) REP(j, i) if (state[j] == nvals && nrem[j] == mn) cur.PB(j); } }\n\t\t\t\tassert(nmx == 0);\n\t\t\t} else {\n\t\t\t\tREP(i, nvals) if (state[i] == nvals) cur.PB(i);\n\t\t\t}\n\t\t\tassert(SZ(cur) == nvals - overlap);\n\t\t\t//if (SZ(ans) == 5) { printf(\"%d:\", overlap); REPSZ(i, cur) printf(\" %d\", cur[i] + 1); printf(\" [%d,%d]\\n\", mn, mx); }\n\t\t\tif (SZ(best) == 0 || cur < best) best = cur;\n\t\t}\n\t\tif (SZ(best) == 0) return false;\n\t\tREPSZ(i, best) ans.PB(best[i]);\n\t\tREPSZ(i, best) --rem[best[i]];\n\t}\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(i > last_2h) vis_2h_h = true;\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          // if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // 特殊形(単調増加)\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          times(x+1, i) a[i] += c[i]-2;c[i]=2;\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define ll long long\n\nconst int N = 303;\nconst int Q = N * 2;\nconst int mod = 998244353;\n\nusing namespace std;\n\nint n;\nint a[N];\nint b[N];\nint c[N];\n\nbool good()\n{\n        int mn = a[1], mx = a[1];\n        for(int i = 2; i <= n; i++){\n                mn = min(mn, a[i]);\n                mx = max(mx, a[i]);\n        }\n        return mn * 2 >= mx;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        if(!good()){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n\n        while(a[1] > 0){\n                int mn = a[1], mx = a[1];\n                for(int i = 2; i <= n; i++){\n                        mn = min(mn, a[i]);\n                        mx = max(mx, a[i]);\n                }\n                for(int i = 1; i <= n; i++){\n                        if(a[i] == mn * 2){\n                                b[i] = 2;\n                        } else{\n                                b[i] = 1;\n                        }\n                }\n                int x = 0;\n                for(int i = 1; i <= n; i++){\n                        for(int j = 1; j <= n; j++){\n                                c[j] = b[j];\n                        }\n                        for(int j = 1; j <= i; j++){\n                                c[j] = 2;\n                        }\n                        for(int j = 1; j <= n; j++){\n                                a[j] -= c[j];\n                        }\n                        if(good()){\n                                x = i;\n                        }\n                        for(int j = 1; j <= n; j++){\n                                a[j] += c[j];\n                        }\n                }\n                for(int i = 1; i <= x; i++){\n                        b[i] = 2;\n                }\n                vector < int > S1, S2;\n                for(int i = 1; i <= n; i++) if(b[i] == 1) S2.push_back(i);\n                for(int i = 1; i <= n; i++) if(b[i] == 2) S1.push_back(i);\n                sort(S1.begin(), S1.end());\n                for(int x: S1) cout << x << \" \";\n                for(int x: S2) cout << x << \" \";\n                for(int x: S1) cout << x << \" \";\n                for(int i = 1; i <= n; i++) a[i] -= b[i];\n\n                assert(good());\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() <= res[h+j]) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvector<int> ori;\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)ori.push_back(i);\n\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint num = 10000;\n\trep(i, n)num = min(num, a[i]);\n\trep(i, n)if (a[i] > 2 * num) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tvector<vector<int>> ads(num);\n\tint le = 0;\n\trep(i, n) {\n\t\tint ma = 0;\n\t\tRep(j, i, n) {\n\t\t\tma = max(ma, a[j] - num);\n\t\t}\n\t\tle = min(le, num - ma);\n\t\tint ad = a[i] - num;\n\t\trep(j, ad) {\n\t\t\tads[j+le].push_back(i);\n\t\t}\n\t\tle += ad;\n\t}\n\tvector<int> ans;\n\trep(i, num) {\n\t\tint memo = ans.size();\n\t\tfor (int ad : ads[i]) {\n\t\t\tans.push_back(ad);\n\t\t}\n\t\tint las = 0;\n\t\trep(j, ads[i].size()) {\n\t\t\tvector<int> v;\n\t\t\tint g = memo + j;\n\t\t\tbool valid = false;\n\t\t\tif (g >= n - 1) {\n\t\t\t\trep(t, n) {\n\t\t\t\t\tv.push_back(ans[g - t]);\n\t\t\t\t}\n\t\t\t\tsort(all(v));\n\t\t\t\tif (v == ori)valid = true;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tlas++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvector<bool> skip(n,false);\n\t\trep(j, ads[i].size()) {\n\t\t\tif (j >= las)skip[ads[i][j]] = true;\n\t\t}\n\t\trep(i, n)if (!skip[i])ans.push_back(i);\n\t\trep(i, n)if (skip[i])ans.push_back(i);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tstring R;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\t\n\t\tstring cand;\n\t\t\n\t\tFOR(i,K+1) if(i==0 || A[i-1]>=2) {\n\t\t\tstring cand2,cand3,cand4;\n\t\t\t\n\t\t\tint am=0;\n\t\t\tint B[100];\n\t\t\tFOR(j,K) {\n\t\t\t\tB[j]=A[j];\n\t\t\t\tif(j<i && B[j]>=2) {\n\t\t\t\t\tcand2.push_back(j);\n\t\t\t\t\tcand4.push_back(j);\n\t\t\t\t\tB[j]--;\n\t\t\t\t\tB[j]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tB[j]--;\n\t\t\t\t\tcand3.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(*max_element(B,B+K)>*min_element(B,B+K)*2) {\n\t\t\t\tcand2=cand3=cand4=\"\";\n\t\t\t\tFOR(j,K) {\n\t\t\t\t\tB[j]=A[j];\n\t\t\t\t\tif(j<i && B[j]>y) {\n\t\t\t\t\t\tcand2.push_back(j);\n\t\t\t\t\t\tcand4.push_back(j);\n\t\t\t\t\t\tB[j]--;\n\t\t\t\t\t\tB[j]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tB[j]--;\n\t\t\t\t\t\tcand3.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(*max_element(B,B+K)>*min_element(B,B+K)*2) continue;\n\t\t\t}\n\t\t\tcand2=cand2+cand3+cand4;\n\t\t\t\n\t\t\t/*cout<<\"!\"<<i<<\" \";\n\t\t\tFORR(c,cand2) cout<<((int)c+1)<<\" \";\n\t\t\tcout<<endl;*/\n\t\t\tif(cand==\"\" || cand2+cand<cand+cand2) cand=cand2;\n\t\t}\n\t\t\n\t\t//FORR(c,cand) cout<<((int)c+1)<<\" \";\n\t\t//cout<<endl;\n\t\tFORR(c,cand) R+=c, A[c]--;\n\t\t\n\t}\n\t\n\tFORR(c,R) cout<<((int)c+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nbool validarray(vector<int>& a) {\n\tint mi = mod, ma = 0;\n\trep(i, a.size()) {\n\t\tif (a[i] < 0)return false;\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\treturn ma <= mi * 2;\n}\n\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\tif (!validarray(a)) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tint sum = 0;\n\trep(i, k)sum += a[i];\n\n\tint las = 0;\n\tvector<int> ans;\n\trep(i, sum) {\n\t\tvector<bool> b(k);\n\t\tfor (int j = las; j < ans.size(); j++) {\n\t\t\tb[ans[j]] = true;\n\t\t}\n\t\tint chk = -1;\n\t\tvector<bool> b2(k);\n\t\trep(j, k) {\n\t\t\tbool valid = false;\n\t\t\tif (b[j])continue;\n\t\t\tb2 = b;\n\t\t\tb2[j] = true;\n\t\t\tfor (int ex = 0; ex <= k; ex++) {\n\t\t\t\tif (las - ex < 0)break;\n\t\t\t\tif (ex > 0) {\n\t\t\t\t\tif (b2[ans[las - ex]])break;\n\t\t\t\t\tb2[ans[las - ex]] = true;\n\t\t\t\t}\n\n\n\t\t\t\t//cout << \"?! \" << i << \" \" << j <<\" \"<<ex<< \"\\n\";\n\t\t\t\tvector<int> cop = a;\n\n\t\t\t\tvector<int> cs;\n\t\t\t\tfor (int loc = las - ex; loc < ans.size();loc++)cs.push_back(ans[loc]);\n\t\t\t\tcs.push_back(j); cop[j]--;\n\n\t\t\t\tvector<P> v;\n\t\t\t\trep(x, k)if (!b2[x]) {\n\t\t\t\t\tv.push_back({ a[x],x });\n\t\t\t\t}\n\t\t\t\tsort(all(v), greater<P>());\n\t\t\t\tfor (P p : v) {\n\t\t\t\t\tcs.push_back(p.second);\n\t\t\t\t\tcop[p.second]--;\n\t\t\t\t}\n\t\t\t\tbool exivalid = false;\n\t\t\t\tfor (int x = 0; x < k; x++) {\n\n\t\t\t\t\tif (validarray(cop)) {\n\t\t\t\t\t\texivalid = true; break;\n\t\t\t\t\t}\n\t\t\t\t\tcop[cs[x]]--;\n\t\t\t\t}\n\t\t\t\tif (exivalid) {\n\t\t\t\t\tvalid = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tchk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << chk+1 << \" \"<<las<<\"\\n\";\n\t\tassert(chk >= 0);\n\t\tans.push_back(chk);\n\t\ta[chk]--;\n\t\tif (ans.size() >= k) {\n\t\t\tvector<int> cnt(k, 0);\n\t\t\trep(j, k) {\n\t\t\t\tcnt[ans[ans.size() - 1 - j]]++;\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tif (valid) {\n\t\t\t\tlas = ans.size();\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 <= *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n    abort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 1005\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nbool use[SIZE];\nint ans[SIZE];\nint n,sz;\n\nint get_first()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\tif(mn*2>mx) return 0;\n\tfor(int i=0;i<n;i++) if(A[i]>mn) return i;\n\treturn -1;\n}\nbool impossible()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\treturn mn*2<mx;\n}\nbool check()//when sz>=n\n{\n\tmultiset <int> st;\n\tmultiset <int>::iterator it;\n\tfor(int i=0;i<n;i++) st.insert(A[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a=*st.begin();\n\t\tit=st.end();it--;\n\t\tint b=*it;\n\t\tif(2*a>=b) return true;\n\t\tint v=ans[sz-n+i];\n\t\tit=st.lower_bound(A[v]);\n\t\tst.erase(it);\n\t\tst.insert(A[v]-1);\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tif(impossible())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsz=0;\n\twhile(A[0]>0)\n\t{\n\t\tint mn=1000;\n\t\tfor(int i=0;i<n;i++) mn=min(mn,A[i]);\n\t\tvector <int> vx;\n\t\tint mx=-1;\n\t\tmemset(use,false,sizeof(use));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(A[i]==mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t\tmx=max(mx,i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<mx;i++)\n\t\t{\n\t\t\tif(A[i]>mn&&A[i]<mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t}\n\t\t}\n\t\tsort(vx.begin(),vx.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!use[i]) vx.push_back(i);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tans[sz++]=vx[i];\n\t\t\tA[vx[i]]--;\n\t\t}\n\t\tint p=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint v=vx[p];\n\t\t\tif(A[v]==0) break;\n\t\t\tif(get_first()<v) break;\n\t\t\tA[v]--;\n\t\t\tans[sz++]=v;\n\t\t\tif(!check())\n\t\t\t{\n\t\t\t\tsz--;\n\t\t\t\tA[v]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++) printf(\"%d \",ans[i]+1);\n\tputs(\"\");\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nvector<int> makev(vector<int> &pre,vector<bool>& b) {\n\tvector<int> res;\n\tif (pre.empty()) {\n\t\trep(i, k)if (b[i])res.push_back(i);\n\t\trep(i, k)if (!b[i])res.push_back(i);\n\t\trep(i, k)if (b[i])res.push_back(i);\n\t}\n\telse {\n\t\tvector<int> cnt(k, 0);\n\n\t\tvector<bool> bs;\n\t\trep(i, k)if (b[i]) {\n\t\t\tint id = res.size();\n\t\t\tres.push_back(i);\n\n\t\t\tfill(all(cnt), 0);\n\t\t\trep(j, k) {\n\t\t\t\tint x = id - j;\n\t\t\t\tif (x >= 0)cnt[res[x]]++;\n\t\t\t\telse {\n\t\t\t\t\tcnt[pre[pre.size() + x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tbs.push_back(valid);\n\t\t}\n\n\t\tint tmp = 0;\n\t\trep(i, k) {\n\t\t\tif (!b[i]) {\n\t\t\t\tint id = res.size();\n\t\t\t\tres.push_back(i);\n\n\t\t\t\tfill(all(cnt), 0);\n\t\t\t\trep(j, k) {\n\t\t\t\t\tint x = id - j;\n\t\t\t\t\tif (x >= 0)cnt[res[x]]++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tcnt[pre[pre.size() + x]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool valid = true;\n\t\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\t\tbs.push_back(valid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool isad = false;\n\t\t\t\trep(j, k) {\n\t\t\t\t\tif (j + tmp < bs.size()&&bs[j+tmp]) {\n\t\t\t\t\t\tisad = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isad) {\n\t\t\t\t\tb[i] = false;\n\t\t\t\t\tint id = res.size();\n\t\t\t\t\tres.push_back(i);\n\n\t\t\t\t\tfill(all(cnt), 0);\n\t\t\t\t\trep(j, k) {\n\t\t\t\t\t\tint x = id - j;\n\t\t\t\t\t\tif (x >= 0)cnt[res[x]]++;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcnt[pre[pre.size() + x]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool valid = true;\n\t\t\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\t\t\tbs.push_back(valid);\n\t\t\t\t}\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n\n\t\trep(i, k) {\n\t\t\tif (b[i])res.push_back(i);\n\t\t}\n\t}\n\t/*cout << \"??\";\n\trep(i, k)cout << \" \" << b[i];\n\tcout << \"\\n\";*/\n\treturn res;\n}\nvector<int> calc (vector<int> &pre,vector<int>& a) {\n\tvector<int> ans;\n\tint mi = mod;\n\tint ma = 0;\n\trep(i, k) {\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\tif (mi == 0)return {};\n\tvector<int> ts;\n\trep(i, k)if (a[i] == 2 * mi) {\n\t\tts.push_back(i);\n\t}\n\tif (ts.empty()) {\n\t\trep(i, k)ans.push_back(i);\n\t}\n\telse {\n\t\tint las = ts.back();\n\n\t\tbool onm2 = false;\n\t\tvector<bool> t2(k);\n\t\tfor (int id : ts)t2[id] = true;\n\t\trep(i, las) {\n\t\t\tif (t2[i])continue;\n\t\t\tif (ma >= 2 * a[i] - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\tt2[i] = true;\n\t\t\t\tonm2 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\t\tif (onm2) {\n\t\t\trep(i, k)if (a[i] == ma) {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> ad = makev(pre, t2);\n\t\tfor (int id : ad)ans.push_back(id);\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\trep(i, k)rep(j, k) {\n\t\tif (a[j] > 2 * a[i]) {\n\t\t\tcout << -1 << \"\\n\"; return;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\twhile (a[0]>0) {\n\t\tint mi = mod;\n\t\tint ma = 0;\n\t\trep(i, k) {\n\t\t\tmi = min(mi, a[i]);\n\t\t\tma = max(ma, a[i]);\n\t\t}\n\t\tvector<int> ts;\n\t\trep(i, k)if (a[i] == 2 * mi) {\n\t\t\tts.push_back(i);\n\t\t}\n\t\tif (ts.empty()) {\n\t\t\tvector<int> cop = a;\n\t\t\trep(i, k)cop[i]--;\n\t\t\t\n\t\t\tvector<bool> is2(k, false);\n\t\t\tvector<int> nt = makev(ans,is2);\n\t\t\tvector<int> ad = calc(nt,cop);\n\t\t\tvector<int> nnt = nt;\n\t\t\tfor (int id : ad)nnt.push_back(id);\n\n\t\t\tbool ald = false;\n\t\t\trep(i, k) {\n\t\t\t\tif (is2[i])continue;\n\t\t\t\tif (ma >= 2 * a[i] - 1)continue;\n\t\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\t\tif (!ald) {\n\t\t\t\t\t\tald = true;\n\t\t\t\t\t\trep(j, k)if (a[j] == ma) {\n\t\t\t\t\t\t\tif (!is2[j]) {\n\t\t\t\t\t\t\t\tis2[j] = true;\n\t\t\t\t\t\t\t\tcop[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis2[i] = true;\n\t\t\t\t\tcop[i]--;\n\t\t\t\t}\n\t\t\t\tvector<int> cur = makev(ans,is2);\n\t\t\t\tad = calc(cur,cop);\n\t\t\t\tvector<int> ccur = cur;\n\t\t\t\tfor (int id : ad)ccur.push_back(id);\n\t\t\t\tif (nnt > ccur) {\n\t\t\t\t\tswap(nt, cur);\n\t\t\t\t\tswap(nnt, ccur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int id : nt) {\n\t\t\t\tans.push_back(id);\n\t\t\t\ta[id]--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvector<int> nex = calc(ans,a);\n\t\t\tfor (int id : nex) {\n\t\t\t\ta[id]--;\n\t\t\t\tans.push_back(id);\n\t\t\t}\n\t\t}\n\t\t/*rep(i, ans.size()) {\n\t\t\tif (i > 0) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << ans[i] + 1;\n\t\t}cout << \"\\n\";*/\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint k;\n\tcin >> k;\n\tvector<int> freq(k);\n\tfor(int& x : freq) cin >> x;\n\tint minv = 1000000, maxv = -1;\n\tfor(int x : freq){\n\t\tminv = min(minv, x); maxv = max(maxv, x);\n\t}\n\tint sum = 0;\n\tfor(int x : freq) sum += x;\n\tif(minv * 2 < maxv){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> ans;\n\tint maxworks = 0;\n\twhile((int)ans.size() < sum){\n\t\tbool found = false;\n\t\tfor(int nxt = 0; nxt < k; nxt++){\n\t\t\tvector<int> cans = ans;\n\t\t\tcans.push_back(nxt);\n\t\t\tint cmaxworks = maxworks;\n\t\t\t{\n\t\t\t\tif((int)cans.size() >= k){\n\t\t\t\t\tvector<int> d(k, 0);\n\t\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\t\td[cans[(int)cans.size() - 1 - i]]++;\n\t\t\t\t\t}\n\t\t\t\t\tbool works = true;\n\t\t\t\t\tfor(int i = 0; i < k; i++) if(!d[i]) works = false;\n\t\t\t\t\tif(works) cmaxworks = (int)cans.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cfreq = freq;\n\t\t\tcfreq[nxt]--;\n\t\t\tif(cfreq[nxt] < 0) continue;\n\t\t\tvector<int> known;\n\t\t\tfor(int f = cmaxworks; f < (int)cans.size(); f++) known.push_back(cans[f]);\n\t\t\tvector<int> zk = known;\n\t\t\tsort(zk.begin(), zk.end());\n\t\t\tif(unique(zk.begin(), zk.end()) != zk.end()) continue;\n\t\t\tbool ok = false;\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t}\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tfor(int b = cmaxworks - 1; b >= 0; b--){\n\t\t\t\t\tif(cur[cans[b]]) break;\n\t\t\t\t\tcur[cans[b]] = 1;\n\t\t\t\t\tint a = cans[b];\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tint minval = 1000000;\n\t\t\t\tfor(int b : dfreq) minval = min(minval, b);\n\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\tif(cur[i]) continue;\n\t\t\t\t\tif(dfreq[i] > 2 * minval){\n\t\t\t\t\t\tdfreq[i]--;\n\t\t\t\t\t\tcur[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ming = 100000, maxg = 0;\n\t\t\t\tfor(int b : dfreq) ming = min(ming, b);\n\t\t\t\tfor(int b : dfreq) maxg = max(maxg, b);\n\t\t\t\tif(ming * 2 >= maxg){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(nxt);\n\t\t\t\tmaxworks = cmaxworks;\n\t\t\t\tfound = true;\n\t\t\t\tfreq[nxt]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for(int b : ans) cerr << b << ' ';\n\t\t// cerr << '\\n';\n\t\tassert(found);\n\t}\n\tfor(int b : ans) cout << b+1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\n\tif(mn*2+1==mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tret=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n//\t\tfor(int i=1;i<=l3;i++){\n//\t\t\tcerr << z[i] << \" \";\n//\t\t}\n//\t\tputs(\"\");\n\t\tif(p1<p2)return ret;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tcerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";puts(\"\");\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n//\t\tcout << ext[i] << \" \";\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n//\tputs(\"\");\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, s, a[MAXN];\nint x, y, cur[MAXN], res[MAXN], ans[MAXN];\nbool cnp(int s, int t) {\n\tif ((a[s] == x) == (a[t] == x)) return s < t;\n\telse return (a[s] == x) < (a[t] == x);\n}\nvoid work(int len) {\n\tbool valid = true, found = false;\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]--;\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\tif (Min * 2 >= Max) {\n\t\tfound = true;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tres[i] = cur[i];\n\t\tsort(res + 1, res + len + 1);\n\t} else if (Min * 2 + 1 == Max) {\n\t\tx = Min, y = Max;\n\t\tint k1 = 0, k2 = 0, k = 0;\n\t\tstatic int res1[MAXN], res2[MAXN];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (a[cur[i]] == Min || a[cur[i]] == Max) res1[++k1] = cur[i];\n\t\t\telse res2[++k2] = cur[i];\n\t\tsort(res1 + 1, res1 + k1 + 1, cnp);\n\t\tsort(res2 + 1, res2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2) {\n\t\t\t\tif (res1[x1] < res2[x2]) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t} else {\n\t\t\t\tif (x1 <= k1) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t}\n\t\tfound = true;\n\t\tfor (int i = len + 1; i <= n; i++)\n\t\t\tif (a[cur[i]] == Min) found = false;\n\t\tfound |= (x1 == 0) || (a[res1[1]] == Max);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]++;\n\tif (!valid || !found) res[1] = 0;\n}\nbool cmp(int *a, int *b) {\n\tint pos = 1;\n\twhile (a[pos] == b[pos]) pos++;\n\treturn a[pos] < b[pos];\n}\nbool check() {\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\treturn Min * 2 >= Max;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tif (!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcur[i] = i;\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[res[i]]--;\n\t\tcur[i] = res[i];\n\t\tans[m] = res[i];\n\t}\n\twhile (m != s) {\n\t\tstatic int inc[MAXN];\n\t\tmemset(inc, 0, sizeof(inc));\n\t\tint len = 0; inc[1] = n + 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (res[1] != 0 && cmp(res, inc)) {\n\t\t\t\tlen = i;\n\t\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\t\tinc[j] = res[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i + len <= n; i++)\n\t\t\tcur[i] = cur[i + len];\n\t\tfor (int i = 1; i <= len; i++) {\n\t\t\tans[++m] = inc[i];\n\t\t\tcur[n - len + i] = inc[i], a[inc[i]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 1005\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nint cnt[SIZE];\nbool use[SIZE];\nbool use2[SIZE];\nint ans[SIZE];\nint n,sz;\n\nint get_first()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\tif(mn*2<mx) return SIZE;\n\tif(mn*2>mx) return 0;\n\tfor(int i=0;i<n;i++) if(A[i]>mn) return i;\n\treturn -1;\n}\nbool impossible()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\treturn mn*2<mx;\n}\nbool check()\n{\n\tfor(int i=0;i<n;i++) use[i]=use2[i]=false;\n\tint from=sz-1;\n\twhile(from>=0)\n\t{\n\t\tif(use[ans[from]]) break;\n\t\tuse[ans[from]]=true;\n\t\tfrom--;\n\t}\n\tfrom++;\n\t//printf(\"%d %d : %d\\n\",sz,ans[sz-1],from);\n\t\n\tint s=0,e=0;\n\tint last=0;\n\twhile(last<from)\n\t{\n\t\twhile(e<sz&&!use2[ans[e]])\n\t\t{\n\t\t\tuse2[ans[e]]=true;\n\t\t\te++;\n\t\t}\n\t\tif(s==last&&e-s<n) return false;\n\t\tif(e-s==n) last=e;\n\t\tuse2[ans[s]]=false;\n\t\ts++;\n\t}\n\tfor(int i=0;i<n;i++) cnt[i]=A[i];\n\tfor(int i=from;i<sz;i++) cnt[ans[i]]++;\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmn=min(mn,cnt[i]);\n\t\tmx=max(mx,cnt[i]);\n\t}\n\t//printf(\"%d %d : %d %d %d\\n\",sz,ans[sz-1],mn,mx,from);\n\tif(mn*2<mx) return false;\n\tif(mn*2>mx) return true;\n\tint f=SIZE;\n\tfor(int i=from;i<sz;i++)\n\t{\n\t\tif(cnt[ans[i]]==mn)\n\t\t{\n\t\t\tf=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(f==SIZE) return true;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(A[i]==mx&&!use[i]) return false;\n\t}\n\tfor(int i=f;i<sz;i++)\n\t{\n\t\tif(cnt[ans[i]]==mx)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tsum+=A[i];\n\t}\n\tif(impossible())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsz=0;\n\tfor(int i=0;i<sum;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(A[j]>0)\n\t\t\t{\n\t\t\t\tA[j]--;\n\t\t\t\tans[sz++]=j;\n\t\t\t\tif(check()) break;\n\t\t\t\tA[j]++;\n\t\t\t\tsz--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++) printf(\"%d \",ans[i]+1);\n\tputs(\"\");\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint a[105], type[105], cur[205];\nvoid pr(int x) {\n\tprintf(\"%d \", x);\n\t--a[x];\n}\nint main() {\n\tint k, min=-1, max=0, active=0;\n\tscanf(\"%d\", &k);\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(a[i]<1u*min) min=a[i];\n\t\tif(a[i]>max) max=a[i];\n\t}\n\tif(max>2*min) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(; min; --min) {\n\t\tfor(int x=0; x<=active; pr(++x)) {\n\t\t\tint min1=k+1, max2=0;\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(a[i]==min) {\n\t\t\t\t\ttype[i]=1;\n\t\t\t\t\tif(min1==k+1) min1=i;\n\t\t\t\t} else if(a[i]==2*min) {\n\t\t\t\t\ttype[i]=2;\n\t\t\t\t\tmax2=i;\n\t\t\t\t} else {\n\t\t\t\t\ttype[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==0) {\n\t\t\t\t\tif(i<max2)\n\t\t\t\t\t\ttype[i]=2;\n\t\t\t\t\telse\n\t\t\t\t\t\ttype[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt=0;\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==2)\n\t\t\t\t\tcur[++cnt]=i;\n\t\t\t}\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==1)\n\t\t\t\t\tcur[++cnt]=i;\n\t\t\t}\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==2)\n\t\t\t\t\tcur[++cnt]=i;\n\t\t\t}\n\t\t\tif(x==active || cur[1]<=x) {\n\t\t\t\tfor(int i=1; i<=cnt; ++i) pr(cur[i]);\n\t\t\t\tactive=max2?0:min1-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int K=105,N=1005;\nint k,n;\nint a[K];\nvector<int>merge(const vector<int>&a,const vector<int>&b)\n{\n\tvector<int>res;\n\tsize_t i=0,j=0;\n\twhile(i<a.size()&&j<b.size())\n\t{\n\t\tif(a[i]<b[j]) res.push_back(a[i]),i++;\n\t\telse res.push_back(b[j]),j++;\n\t}\n\twhile(i<a.size())\n\t\tres.push_back(a[i]),i++;\n\twhile(j<b.size())\n\t\tres.push_back(b[j]),j++;\n\treturn res;\n}\nint ans[N],tot;\nint b[K];\nbool pos[K];\nvector<int>add(int len)\n{\n\tfor(int i=1;i<=k;i++)\n\t\tpos[i]=false,b[i]=a[i];\n\tvector<int>pre;\n\tfor(int i=tot,j=1;i>=1&&j<=k-len;i--,j++)\n\t\tpre.push_back(ans[i]);\n\tfor(int u:pre)         \n\t\tpos[u]=true;        \n\tfor(int i=1;i<=k;i++)\n\t\tif(!pos[i]) b[i]--;\n\tfor(int i=1;i<=k;i++)\n\t\tif(b[i]<0) return {k+1};\n\tint Min=*min_element(b+1,b+k+1),Max=*max_element(b+1,b+k+1);\n\tif(Min*2>=Max)\n\t{\n\t\tvector<int>res;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]) res.push_back(i);\n\t\treturn res;\n\t}\n\telse if(Min*2+1==Max)\n\t{\n\t\tvector<int>x,y;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Max) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Min) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]!=Min&&b[i]!=Max) y.push_back(i);\n\t\tvector<int>res=merge(x,y);\n\t\tpre.insert(pre.end(),res.begin(),res.end());\n\t\tint L=0,R=(int)(pre.size())-1;\n\t\tfor(int i=0;i<pre.size();i++)\n\t\t{                  \n\t\t\tif(b[pre[i]]==Max) L=max(L,i);\n\t\t\tif(b[pre[i]]==Min) R=min(R,i);\n\t\t}\n\t\tif(L<R) return res;\n\t\telse return {k+1};\n\t}\n\telse return {k+1};\n}\nvoid solve()\n{\n\tvector<int>res={k+1};\n\tfor(int len=1;len<=k&&tot+len<=n;len++)\n\t{\n\t\tint d=k-len;\n\t\tif(tot-d>=0)\n\t\t{\n\t\t\tvector<int>now=add(len);\n\t\t\tres=min(res,now);\n\t\t}\n\t}\n\tfor(int u:res)\n\t{\n\t\tans[++tot]=u;\n\t\ta[u]--;\n\t\tprintf(\"%d \",u);\n\t}\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++)\n\t\tscanf(\"%d\",&a[i]),n+=a[i];\n\tint Min=*min_element(a+1,a+k+1),Max=*max_element(a+1,a+k+1);\n\tif(2*Min+1<=Max)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(tot<n)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tvi Ans;\n\t\tset<pii> S;\n\t\tfor(int i=1;i<=k;i++) S.insert({H[i],i});\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tset<pii> NS;\n\t\t\tint min = (*S.begin()).first;\n\t\t\tif(min==0) break;\n\t\t\tfor(auto p:S)\n\t\t\t{\n\t\t\t\tif(p.first==min)\n\t\t\t\t{\n\t\t\t\t\tD.push_back(p.second);\n\t\t\t\t\tNS.insert({p.first-1,p.second});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tD.push_back(p.second);\n\t\t\t\t\tD.push_front(p.second);\n\t\t\t\t\tNS.insert({p.first-2,p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prin(D);\n\t\t\tfor(auto d:D) Ans.push_back(d);\n\t\t\tS=NS;\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[la] < sb[lb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[sa[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= ansptr; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\nbool seen[MAXVALS];\n\nvector<int> calc(int nblock) {\n\tREP(i, nvals) rem[i] = cnt[i] - nblock;\n\tREP(i, nvals) if (rem[i] > nblock) return vector<int>();\n\n\tvector<vector<int>> suff(nblock);\n\tREP(i, rem[0]) suff[i].PB(0);\n\trem[0] = 0;\n\twhile (true) {\n\t\tint mxidx = -1;\n\t\tREP(i, nvals) if (rem[i] > 0 && (mxidx == -1 || rem[i] > rem[mxidx])) mxidx = i;\n\t\tif (mxidx == -1) break;\n\t\tREP(i, nvals) if (i <= mxidx) {\n\t\t\tREP(j, rem[i]) suff[nblock - rem[mxidx] + j].PB(i);\n\t\t\trem[i] = 0;\n\t\t}\n\t}\n\tvector<vector<int>> perm(nblock);\n\tREP(i, nblock) {\n\t\tperm[i] = suff[i];\n\t\tREP(j, nvals) seen[j] = false;\n\t\tREPSZ(j, perm[i]) seen[perm[i][j]] = true;\n\t\tREP(j, nvals) if (!seen[j]) perm[i].PB(j);\n\t}\n\tvector<int> ret;\n\tREP(i, nblock) {\n\t\tREPSZ(j, perm[i]) ret.PB(perm[i][j]);\n\t\tREPSZ(j, suff[i]) ret.PB(suff[i][j]);\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tbool ret = false;\n\tint mxblock = cnt[0]; FOR(i, 1, nvals) mxblock = min(mxblock, cnt[i]);\n\tFORE(i, 1, mxblock) {\n\t\tvector<int> cur = calc(i);\n\t\tif (SZ(cur) == 0) continue;\n\t\tif (ret == false || cur < ans) ret = true, ans = cur;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\n\tif(mn*2+1==mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tret=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n//\t\tfor(int i=1;i<=l3;i++){\n//\t\t\tcerr << z[i] << \" \";\n//\t\t}\n//\t\tputs(\"\");\n\t\tif(p1<p2)return ret;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tcerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";puts(\"\");\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tcerr << ext[i] << \" \";\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n//\tputs(\"\");\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            //ここの優先順位の付け方が甘い\n\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nbool possiblePrefix(vector<pair<int, int>> A, vector<int> prefix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n  for (int x : prefix) A[where[x]].first++;\n\n  sort(A.begin(), A.end());\n  if (A[0].first * 2 < A.back().first) return false;\n\n  vector<bool> isOne(K, false), isTwo(K, false);\n  int min = A[0].first, nTwos = 0;\n  for (int i = 0; i < K; ++i) {\n    if (min * 2 == A[i].first) {\n      isTwo[A[i].second] = true;\n      nTwos++;\n    }\n    if (min == A[i].first) isOne[A[i].second] = true;\n  }\n  reverse(prefix.begin(), prefix.end());\n  while (prefix.size() && isTwo[prefix.back()]) {\n    nTwos--;\n    prefix.pop_back();\n  }\n  if (!nTwos) return true;\n  for (int x : prefix)\n    if (isOne[x]) return false;\n  return true;\n}\n\nbool possible(vector<pair<int, int>> A, const vector<int>& suffix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n  for (int i = 0; i < K; ++i) {\n    if (possiblePrefix(A, {})) return true;\n    int j = where[suffix[i]];\n    if (A[j].first == 0) break;\n    A[j].first--;\n  }\n  return false;\n}\n\nbool possibleFinish(vector<pair<int, int>> A, vector<int>& B, int coveredUpTo) {\n  int K = A.size();\n  vector<bool> seen(K, false);\n  vector<int> prefix;\n  if (B.size()) {\n    for (int32_t i = B.size() - 1; i >= 0; --i) {\n      if (seen[B[i]]) {\n        if (coveredUpTo <= i) return false;\n        break;\n      }\n      prefix.push_back(B[i]);\n      seen[B[i]] = true;\n    }\n  }\n  reverse(prefix.begin(), prefix.end());\n  if ((int)prefix.size() == K) return possible(A, prefix);\n  while (coveredUpTo + prefix.size() >= B.size()) {\n    if (possiblePrefix(A, prefix)) return true;\n    if (prefix.size()) {\n      prefix.erase(prefix.begin());\n    } else {\n      break;\n    }\n  }\n  return false;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n  vector<int> B;\n\n  if (!possibleFinish(A, B, 0)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int coveredUpTo = 0;\n  while (true) {\n    int tot = 0;\n    for (auto& p : A) tot += p.first;\n    if (tot == 0) break;\n\n    vector<int> where(K);\n    for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n    int x = -1;\n    for (int i = 0; i < K; ++i) {\n      if (A[where[i]].first == 0) continue;\n\n      A[where[i]].first--;\n      B.push_back(i);\n      if (possibleFinish(A, B, coveredUpTo)) {\n        x = i;\n        break;\n      }\n      B.pop_back();\n      A[where[i]].first++;\n    }\n    assert(x != -1);\n    if (B.size() >= K) {\n      vector<int> p(B.end() - K, B.end());\n      sort(p.begin(), p.end());\n      bool isPerm = true;\n      for (int i = 0; i < K; ++i) isPerm &= p[i] == i;\n      if (isPerm) {\n        assert(coveredUpTo + K >= B.size());\n        coveredUpTo = B.size();\n      }\n    }\n  }\n\n  assert(coveredUpTo == B.size());\n  for (int x : B) cout << x + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repn(i, n) for(int i=1;i<=n;i++)\n\nint n, k, a[105], b[105], ans[1005], mn=100000, mx=-100000;\nint main(){\n\tcin >> k;\n\trepn(i, k){\n\t\tcin >> a[i];\n\t\tn += a[i];\n\t\tmn = min(mn, a[i]);\n\t\tmx = max(mx, a[i]);\n\t}\n\tif(2*mn < mx){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tint las = 0;\n\trepn(id, n){\n\t\trepn(i, k){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tbool OK = 0;\n\t\t\tfor(int add=0;add<k;add++){\n\t\t\t\tif(n-id < add || add+id-las > k) break;\n\t\t\t\tif(add+id < k) continue;\n\t\t\t\tmemcpy(b, a, sizeof(a));\n\t\t\t\tb[i]--;\n\t\t\t\tbool ex[105] = {};\n\t\t\t\tfor(int x=id+add-k+1;x<id;x++) ex[ans[x]] = 1;\n\t\t\t\tex[i] = 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\trepn(x, k){\n\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\tcnt++; if(a[x] == 0) cnt++; b[x]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt != add) continue;\n\t\t\t\tif(n-id-add <= k){\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] > 1) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\t\tif(b[x] == 0) b[x]++;\n\t\t\t\t\t\t\t\telse bad = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(b[v] >= 1) break;\n\t\t\t\t\t\t\telse b[v]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k) if(b[x] != 1) bad = 1;\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmn = 100000, mx = -100000;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tmn = min(mn, b[x]);\n\t\t\t\t\t\tmx = max(mx, b[x]);\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn >= mx){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn+1 < mx){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbool need[105] = {};\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] == mx) need[x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\tif(need[x] == 1) bad = 1;\n\t\t\t\t\t\t\tneed[x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(need[v]) break;\n\t\t\t\t\t\t\tneed[v] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!need[x] && mn == b[x]) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t\t\tans[id] = i;\n\t\t\t\tif(id >= k){\n\t\t\t\t\tunordered_set<int>S;\n\t\t\t\t\tfor(int i=id-k+1;i<=id;i++) S.insert(ans[i]);\n\t\t\t\t\tif(S.size() == k) las = id;\n\t\t\t\t}\n\t\t\t\ta[i]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans[id] << ' ';\n\t}\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,k,a[N],pos[N],cnt[N],b[N],pmx[N],pmn[N];\nbool check(int l) {\n\tint mx=0;\n\trep(i,0,k) mx=max(mx,b[i]+(l<i));\n\tfor (int j=l-1;j>=0;j--) {\n\t\tmx=max(mx,b[j+1]+1);\n\t\tpmx[j]=mx;\n\t}\n\tint mn=(1<<20);\n\trep(i,0,k) mn=min(mn,2*b[i]);\n\trep(i,0,l-1) {\n\t\tmn=min(mn,2*b[i]-1);\n\t\tpmn[i]=mn;\n\t}\n\tfor (int j=l-2;j>=0;j--) {\n\t\tif (pmx[j]<=pmn[j]) return 1;\n\t}\n\tmx=0,mn=1<<20;\n\trep(i,0,k) {\n\t\tmx=max(mx,b[i]);\n\t\tmn=min(mn,2*b[i]-(i<l));\n\t}\n\tif (mx<=mn) return 1;\n\treturn 0;\n}\nbool check(int l,int r) {\n\trep(z,0,k) cnt[z]=0;\n\trep(z,l+1,r+1) cnt[pos[z]]++;\n\trep(z,0,k) if (cnt[z]>=2) return 0;\n\tfor (int i=l;i>=0;i--) {\n\t\tcnt[pos[i]]++;\n\t\tif (cnt[pos[i]]>=2) return 0;\n\t\tint t=0;\n\t\trep(j,i,r+1) b[t++]=a[pos[j]]+1;\n\t\trep(j,0,k) if (!cnt[j]) b[t++]=a[j];\n\t\tif (check(r-i+1)) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\",&k);\n\trep(i,0,k) scanf(\"%d\",a+i),n+=a[i];\n\tif (*max_element(a,a+k)>*min_element(a,a+k)*2) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint lastp=-1;\n\trep(i,0,n) {\n\t\tbool vv=0;\n\t\trep(j,0,k) if (a[j]>0) {\n\t\t\ta[j]--;\n\t\t\tpos[i]=j;\n\t\t\tif (check(lastp+1,i)) {\n\t\t\t\tif (i>=k-1) {\n\t\t\t\t\trep(z,0,k) cnt[z]=0;\n\t\t\t\t\trep(z,i-k+1,i+1) cnt[pos[z]]++;\n\t\t\t\t\tbool val=1;\n\t\t\t\t\trep(z,0,k) if (cnt[z]==0) val=0;\n\t\t\t\t\tif (val) lastp=i;\n\t\t\t\t}\n\t\t\t\t//printf(\"valid %d %d\\n\",i,j);\n\t\t\t\tvv=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta[j]++;\n\t\t}\n\t\tassert(vv);\n\t}\n\trep(i,0,n) printf(\"%d \",pos[i]+1); puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 2333\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\npii a[sz];\n\nint main()\n{\n\tfile();\n\tread(n);\n\trep(i,1,n) read(a[i].fir),a[i].sec=i;\n\tsort(a+1,a+n+1);\n\tif (a[1].fir*2<a[n].fir) return puts(\"-1\"),0;\n\tfor (int l=n;l;--l)\n\t{\n\t\twhile (l!=1&&a[l-1].fir==a[l].fir) --l;\n\t\twhile (a[l].fir!=a[l-1].fir)\n\t\t{\n\t\t\trep(i,l,n) printf(\"%d \",a[i].sec),--a[i].fir;\n\t\t\tif (l!=1) rep(i,1,n) printf(\"%d \",a[i].sec),--a[i].fir;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[109];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint k;cin>>k;\n\trepA(i,1,k) cin>>a[i];\n\tint x = 1009,y=0;\n\trepA(i,1,k) x = min(x,a[i]),y=max(y,a[i]);\n\tif(y>2*x){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tvi ans;\n\trep(qq,x){\n\t\tvi cur;\n\t\tbool fg[109];\n\t\tfill(fg);\n\t\trepA(i,1,k){\n\t\t\tif(i==1&&a[i]>x-qq){\n\t\t\t\tcur.pb(1);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[1]=1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t\telse if(a[i]==2*(x-qq)){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i] = 1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k) if(!fg[i]) a[i]--,ans.pb(i);\n\t\ttrav(i,cur) ans.pb(i);\n\t}\n\ttrav(i,ans) cout<<i<<' ';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint k, a[105], p[1005], last[105], l=1, sat;\nbool chk(int x, int y) {\n\tif(last[x]<l) {\n\t\tif(last[y]<=sat) {\n\t\t\treturn 2*a[x]>=a[y];\n\t\t} else {\n\t\t\treturn 2*a[x]>=a[y]+1;\n\t\t}\n\t} else {\n\t\tif(last[y]<=sat) {\n\t\t\treturn 2*a[x]+1>=a[y];\n\t\t} else {\n\t\t\tif(last[x]<last[y])\n\t\t\t\treturn 2*a[x]>=a[y];\n\t\t\telse\n\t\t\t\treturn 2*a[x]+1>=a[y];\n\t\t}\n\t}\n}\nbool check() {\n\tfor(int x=1; x<=k; ++x) {\n\t\tfor(int y=1; y<=k; ++y) {\n\t\t\tif(x==y) continue;\n\t\t\tif(!chk(x, y)) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint n=0;\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tn+=a[i];\n\t}\n\tif(!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tint &P=p[i], lsave=l;\n\t\tif(i-l==k) {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=last[P]+1;\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t\tif(i-l+1==k) sat=i;\n\t\t} else {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0 || last[P]>sat) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=std::max(l, last[P]+1);\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) printf(\"%d \", p[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      pair<vi, int> best(solve(a, a.size()), 0);\n      for (int l = 1; l < a.size(); ++l) {\n        --a[v0[l - 1]];\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, a.size() - l, v0[l]);\n        if (v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n      }\n      best.first.resize(best.second);\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second == 0 ? -1 : v0[best.second - 1]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] != *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\twhile (sz < sum){\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tset<int> A, B;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.insert(q[j]);\n\t\t\t}\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tbool flag = (mxm == 2*mnm+1);\n\t\t\tvector<int> me;\n\t\t\twhile (!A.empty()){\n\t\t\t\tint x = *A.begin();\n\t\t\t\tA.erase(A.begin());\n\t\t\t\tif (a[x] == mnm and flag){\n\t\t\t\t\tB.insert(x);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[++now] = x;\n\t\t\t\tme.push_back(x);\n\t\t\t}\n\t\t\tfor (auto it : B){\n\t\t\t\tp[++now] = it;\n\t\t\t\tme.push_back(it);\n\t\t\t}\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n        rep(k,best_js_size) {\n\n        }\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, s, a[MAXN];\nint x, y, cur[MAXN], res[MAXN], ans[MAXN];\nbool cnp(int s, int t) {\n\tif ((a[s] == x) == (a[t] == x)) return s < t;\n\telse return (a[s] == x) < (a[t] == x);\n}\nvoid work(int len) {\n\tbool valid = true, found = false;\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]--;\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\tif (Min * 2 >= Max) {\n\t\tfound = true;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tres[i] = cur[i];\n\t\tsort(res + 1, res + len + 1);\n\t} else if (Min * 2 + 1 == Max) {\n\t\tx = Min, y = Max;\n\t\tint k1 = 0, k2 = 0, k = 0;\n\t\tstatic int res1[MAXN], res2[MAXN];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (a[cur[i]] == Min || a[cur[i]] == Max) res1[++k1] = cur[i];\n\t\t\telse res2[++k2] = cur[i];\n\t\tsort(res1 + 1, res1 + k1 + 1, cnp);\n\t\tsort(res2 + 1, res2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2) {\n\t\t\t\tif (res1[x1] < res2[x2]) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t} else {\n\t\t\t\tif (x1 <= k1) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t}\n\t\tfound = true;\n\t\tfor (int i = len + 1; i <= n; i++)\n\t\t\tif (a[cur[i]] == Min) found = false;\n\t\tfound |= (x1 == 0) || (a[res1[1]] == Max);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]++;\n\tif (!valid || !found) res[1] = 0;\n}\nbool cmp(int *a, int *b) {\n\tint pos = 1;\n\twhile (a[pos] == b[pos]) pos++;\n\treturn a[pos] < b[pos];\n}\nbool check() {\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\treturn Min * 2 >= Max;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tif (!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcur[i] = i;\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[res[i]]--;\n\t\tcur[i] = res[i];\n\t\tans[m] = res[i];\n\t}\n\twhile (m != s) {\n\t\tstatic int inc[MAXN];\n\t\tmemset(inc, 0, sizeof(inc));\n\t\tint len = 0; inc[1] = n + 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (res[1] != 0 && cmp(res, inc)) {\n\t\t\t\tlen = i;\n\t\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\t\tinc[j] = res[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i + len <= n; i++)\n\t\t\tcur[i] = cur[i + len];\n\t\tfor (int i = 1; i <= len; i++) {\n\t\t\tans[++m] = inc[i];\n\t\t\tcur[n - len + i] = inc[i], a[inc[i]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[109];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint k;cin>>k;\n\trepA(i,1,k) cin>>a[i];\n\tint x = 1009,y=0;\n\trepA(i,1,k) x = min(x,a[i]),y=max(y,a[i]);\n\tif(y>2*x){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tvi ans;\n\trep(qq,x){\n\t\tvi cur;\n\t\tbool fg[109];\n\t\tfill(fg);\n\t\tint gg = 1;\n\t\tif(a[1]<=(x-qq)+1){\n\t\t\trepA(i,1,k) if(a[i]>=2*(x-qq)-1) {\n\t\t\t\tgg=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k){\n\t\t\tif(i<=gg&&a[i]>x-qq){\n\t\t\t\tcur.pb(1);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[1]=1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t\telse if(a[i]==2*(x-qq)){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i] = 1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k) if(!fg[i]) a[i]--,ans.pb(i);\n\t\ttrav(i,cur) ans.pb(i);\n\t}\n\ttrav(i,ans) cout<<i<<' ';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2020.06.28 19:33:21\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\nint main() {\n    int n, sum = 0, mi = INF, mx = -INF;\n    scanf(\"%d\", &n);\n    vector<int> a(n), ans;\n    for(auto &g : a) {\n        scanf(\"%d\", &g);\n        mi = min(mi, g);\n        mx = max(mx, g);\n        sum += g;\n    }\n    if(mi * 2 < mx) { puts(\"-1\"); return 0; }\n    while((int)ans.size() < sum) {\n        vector<int> add, left, vis, bestleft;\n        for(int len = 1; len <= n; ++len) {\n            if((int)ans.size() + len < n || (int)ans.size() + len > sum) continue;\n            vector<int> vals;\n            left = a, vis.assign(n, 1);\n            for(int j = 0; j < n - len; ++j)\n                vis[ans[ans.size()-j-1]] = 0;\n            for(int j = 0; j < n; ++j) if(vis[j])\n                left[j]--, vals.push_back(j);\n            mi = INF, mx = -INF;\n            for(int j = 0; j < n; ++j) {\n                mi = min(mi, left[j]);\n                mx = max(mx, left[j]);\n            }\n            if(mi < 0 || mi * 2 + 1 < mx) continue;\n            int idx = INF, xdx = -INF;\n            for(int j = (int)ans.size()-len+n; j < (int)ans.size(); ++j) {\n                if(left[ans[j]] == mi) idx = min(idx, j);\n                if(left[ans[j]] == mx) xdx = max(xdx, j);\n            }\n            if(mi * 2 + 1 == mx && idx < xdx) continue;\n            xdx = -INF;\n            for(int j = 0; j < n; ++j) if(left[j] == mx) xdx = j;\n#define key(x) (left[x] == mi ? pii(max(x, xdx), 1) : pii(x, 0))\n            if(mi * 2 + 1 == mx)\n                sort(vals.begin(), vals.end(), [&](int x, int y) { return key(x) < key(y);} );\n            else sort(vals.begin(), vals.end());\n            if(add.empty() || add > vals) add = vals, bestleft = left;\n        }\n        assert(!add.empty());\n        a = bestleft, ans.insert(ans.end(), add.begin(), add.end());\n    }\n    for(auto g : ans)\n        printf(\"%d \", g + 1);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    for (int i = K - 1; i >= 0; --i) cout << A[i].second + 1 << ' ';\n    for (int i = K - 1; i > 0; --i) {\n      if (A[0].first * 2 == A[i].first) {\n        cout << A[i].second + 1 << ' ';\n        --A[i].first;\n      }\n    }\n    for (int i = 0; i < K; ++i) --A[i].first;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t//\tif (mh() == v) {\n\t\t//\t\t--a[res[h+j+1]];\n\t\t//\t\tbool pn = stvalid();\n\t\t//\t\t++a[res[h+j+1]];\n\n\t\t//\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t//\t\tvector<int> tst{v};\n\t\t//\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t//\t\t\t--a[nv];\n\t\t//\t\t\ttst.pb(nv);\n\t\t//\t\t\tbool ok = p1valid(tst);\n\t\t//\t\t\ttst.pop_back();\n\t\t//\t\t\t++a[nv];\n\t\t//\t\t\tif (ok) {\n\t\t//\t\t\t\tnh = nv;\n\t\t//\t\t\t\tbreak;\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t\tif (nh < nxt)\n\t\t//\t\t\tcontinue;\n\t\t//\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt n;\nvector<Int> a;\nvector<Int> ans;\nInt mx, mn;\nset<int> maxs, mins;\nbool ok[1100];\n\nInt min_initial(Int from, Int to)\n{\n    auto aa = a;\n    vector<int> used(n, 0);\n    for (int i = from; i < to; i++) {\n        if (used[ans[i]])\n            return n;\n        used[ans[i]] = 1;\n        aa[ans[i]]++;\n    }\n\n    Int tmpmx = *max_element(aa.begin(), aa.end());\n    Int tmpmn = *min_element(aa.begin(), aa.end());\n    if (tmpmn * 2 < tmpmx)\n        return n;\n    if (tmpmn * 2 > tmpmx) {\n        for (int i = 0; i < n; i++)\n            if (!used[i])\n                return i;\n        return n;\n    }\n    Int max_cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == tmpmx)\n            max_cnt++;\n    }\n\n    for (int i = from; i < to; i++) {\n        if (aa[ans[i]] == tmpmx)\n            max_cnt--;\n        if (aa[ans[i]] == tmpmn) {\n            if (max_cnt != 0)\n                return n;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == 0)\n            continue;\n        if (used[i])\n            continue;\n        if (max_cnt == 0 && !used[i])\n            return i;\n        if (max_cnt > 0 && aa[i] != tmpmn && !used[i])\n            return i;\n    }\n    return ans[from];\n}\n\nint main()\n{\n    Int as = 0;\n    cin >> n;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        as += a[i];\n    }\n\n    Int mx = *max_element(a.begin(), a.end());\n    Int mn = *min_element(a.begin(), a.end());\n    if (mn * 2 < mx) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < as; i++) {\n        Int nxt = n;\n        for (int j = max(0ll, i - n + 1); j <= i; j++) {\n            nxt = min(nxt, min_initial(j, i));\n            if (!ok[j])\n                break;\n        }\n\n        a[nxt]--;\n        ans.push_back(nxt);\n        if (ans.size() >= n) {\n            set<int> hoge;\n            for (int j = 0; j < n; j++) {\n                hoge.insert(ans[ans.size() - 1 - j]);\n            }\n            if (hoge.size() == n) {\n                for (int j = 0; j < n; j++)\n                    ok[ans.size() - 1 - j] = true;\n            }\n        }\n    }\n\n    for (auto elem : ans)\n        cout << elem + 1 << \" \";\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>     \nusing namespace std;\ntypedef complex<double> base;\ntypedef long double ld;\ntypedef long long ll;\n\t\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair< ll , ll >\n#define vi vector<int>\n#define vvi vector< vi >\n\t\nconst int maxn=(int)(505);\nconst ll mod=(ll)(1e9+7);\nll a[maxn],pre[maxn];\nll dp[maxn][maxn];\nint n;\n     \nll getSum(int l,int r) {\n\tif(l<=r)\treturn pre[r]-(l==0?0:pre[l-1]);\n\treturn pre[n-1]-pre[l-1]+pre[r];\n}\n     \nint main()\t{\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\tcin>>a[i];\n\tpre[0]=a[0];\n\tfor(int i=1;i<n;i++)\tpre[i]=pre[i-1]+a[i];\n\tfor(int i=0;i<n;i++)\tfor(int j=0;j<n;j++) \tdp[i][j]=LLONG_MAX;\n\tfor(int i=0;i<n;i++)\tdp[i][i]=0;\n\tfor(int size=2;size<=n;size++)\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint l=i,r=(i+size-1)%n;\n\t\t\tfor(int j=l;j!=r;j=(j+1)%n)\n\t\t\t\tdp[l][r]=min(dp[l][r],dp[l][j]+dp[(j+1)%n][r]+getSum(l,r));\n\t\t}\n\tll res=LLONG_MAX;\n\tfor(int i=0;i<n;i++) {\n\t\tint l=i,r=(i-1+n)%n;\n\t\tres=min(res,dp[l][r]);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  vector<int> innerSolve(int k, vector<int> a) {\n    int mn = a[0];\n    int mx = a[0];\n    for (int x : a) {\n      mn = min(mn, x);\n      mx = max(mx, x);\n    }\n    if (mx > 2 * mn) {\n      return {};\n    }\n    int total = 0;\n    for (int x : a) total += x;\n    vector<int> res(total, -1);\n    int permStart = 0;\n    int firstUncovered = 0;\n    vector<int> last(k, -1);\n    for (int pos = 0; pos < total; ++pos) {\n      if (pos >= permStart + k) {\n        firstUncovered = pos;\n      }\n      for (int val = 0; val < k; ++val) {\n        if (a[val] > 0) {\n          res[pos] = val;\n          --a[val];\n          vector<int> sa = a;\n          vector<bool> inPerm(k, false);\n          for (int i = permStart; i < pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n          bool ok = false;\n          if (last[val] < permStart) {\n            inPerm[val] = true;\n            for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n            vector<ii> avail;\n            for (int i = 0; i < k; ++i)\n              if (!inPerm[i]) {\n                avail.emplace_back(-a[i], i);\n              }\n            sort(avail.begin(), avail.end());\n            int ptr = 0;\n            for (int plen = k; plen < 2 * k; ++plen) {\n              if (plen > k) {\n                if (permStart + plen - k - 1 <= pos) {\n                  --a[res[permStart + plen - k - 1]];\n                } else {\n                  --a[avail[ptr++].second];\n                }\n              }\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n            }\n          } else if (last[val] == pos - k) {\n            for (int endAt = pos + 1; endAt <= total; ++endAt) {\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n              --a[res[(endAt - permStart) % k + permStart]];\n            }\n          } else {\n            int npermstart = last[val] + 1;\n            if (npermstart <= firstUncovered) {\n              int spermstart = permStart;\n              permStart = npermstart;\n              vector<bool> inPerm(k, false);\n              for (int i = permStart; i <= pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n              for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n              vector<ii> avail;\n              for (int i = 0; i < k; ++i)\n                if (!inPerm[i]) {\n                  avail.emplace_back(-a[i], i);\n                }\n              sort(avail.begin(), avail.end());\n              int ptr = 0;\n              for (int plen = k; plen < 2 * k; ++plen) {\n                if (plen > k) {\n                  if (permStart + plen - k - 1 <= pos) {\n                    --a[res[permStart + plen - k - 1]];\n                  } else {\n                    --a[avail[ptr++].second];\n                  }\n                }\n                mn = a[0];\n                mx = a[0];\n                for (int x : a) {\n                  mn = min(mn, x);\n                  mx = max(mx, x);\n                }\n                if (mn >= 0 && mx <= 2 * mn) {\n                  ok = true;\n                  break;\n                }\n              }\n              if (!ok) {\n                permStart = spermstart;\n              }\n            }\n          }\n          a = sa;\n          if (ok) {\n            last[val] = pos;\n            break;\n          } else {\n            ++a[val];\n            assert(val + 1 < k);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    int tried = 0;\n    while (false) {\n      ++tried;\n      if (tried % 100000 == 0) {\n        cerr << tried << endl;\n      }\n      int k = rand() % 3 + 1;\n      int n = k + rand() % 5;\n      vector<int> seq(n, -1);\n      int permStart = 0;\n      int firstUncovered = 0;\n      vector<int> last(k, -1);\n      for (int i = 0; i < n; ++i) {\n        int step = 0;\n        if (i - permStart >= k) {\n          firstUncovered = i;\n        }\n        while (true) {\n          seq[i] = rand() % k;\n          if (last[seq[i]] < permStart) {\n            break;\n          }\n          if (last[seq[i]] == i - k) {\n            break;\n          }\n          if (i - permStart >= k) {\n            int npermStart = last[seq[i]] + 1;\n            if (n - npermStart >= k && npermStart <= firstUncovered) {\n              permStart = npermStart;\n              break;\n            }\n          }\n          ++step;\n        }\n        last[seq[i]] = i;\n      }\n      vector<int> a(k);\n      for (int x : seq) ++a[x];\n      vector<int> got = innerSolve(k, a);\n      assert(!got.empty());\n      for (int& v : got) {\n        --a[v];\n      }\n      for (int x : a) assert(x == 0);\n      vector<bool> cover(n);\n      for (int i = 0; i + k <= n; ++i) {\n        vector<bool> seen(k);\n        bool ok = true;\n        for (int j = 0; j < k; ++j) {\n          if (seen[got[i + j]]) ok = false;\n          seen[got[i + j]] = true;\n        }\n        if (ok) {\n          for (int j = 0; j < k; ++j) {\n            cover[i + j] = true;\n          }\n        }\n      }\n      for (int i = 0; i < n; ++i) assert(cover[i]);\n      assert(got.size() == seq.size());\n      for (int i = 0; i < got.size(); ++i) {\n        if (seq[i] < got[i]) {\n          assert(false);\n        }\n        if (seq[i] > got[i]) {\n          break;\n        }\n      }\n    }\n    int k;\n    in >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) in >> a[i];\n    vector<int> res = innerSolve(k, a);\n    if (res.empty()) {\n      out << -1 << \"\\n\";\n    } else {\n      for (int x : res) out << x + 1 << \" \";\n      out << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nint main() {\n  std::cin.tie(0); std::ios::sync_with_stdio(false);\n  using P = std::pair<int,int>;\n  int K; std::cin >> K;\n  std::vector<P> p(K);\n  for(int i = 0; i < K; ++i) {\n    std::cin >> p[i].first;\n    p[i].second = i+1;\n  }\n  std::sort(p.begin(), p.end(), std::greater<P>());\n  if(p.front().first > 2*p.back().first) {\n    std::cout << \"-1\\n\";\n    return 0;\n  }\n  for(;;) {\n    for(int i = 0; i < K-1; ++i) {\n      --p[i].first;\n      std::cout << p[i].second << \" \";\n    }\n    --p.back().first;\n    std::cout << p.back().second;\n    int v = p.front().first;\n    if(v < 1) break;\n    auto last = std::partition_point(p.begin(), p.end(),\n      [&](auto const& x){ return x.first == v; });\n    for(auto it = p.begin(); it != last; ++it) {\n      --it->first;\n      std::cout << \" \" << it->second;\n    }\n    if(p.front().first < 1) break;\n    std::cout << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\tvi prev(k, -1);\n\n\trep(i,0,len){\n\t\tmx = 0, mn = 1000;\n\t\ttrav(x, a) mx = max(mx, x);\n\t\ttrav(x, a) mn = min(mn, x);\n\t\tint imx = 1000;\n\t\trep(d,0,k) if(a[d] == mn) imx = min(imx, prev[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx && !(mx>=2*mn && a[d] < mx && prev[d] > imx)){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans[i] < 0){\n\t\t\trep(j,0,i) cout << 1+ans[j] << \" \";\n\t\t\tcout << endl;\n\t\t\ttrav(x, a) cout << x << \" \";\n\t\t\tcout << endl;\n\n\t\t\tcout << mx << \" \" << mn << endl;\n\t\t\tcout << a[ans[i]] << endl;\n\t\t\tcout << imx << \" \" << prev[ans[i]] << endl;\n\t\t\tassert(false);\n\t\t}\n\t\tprev[ans[i]] = i;\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 110;\n\nint N;\nint arr[MAXN];\n\nint parr[MAXN];\nbool used[MAXN];\n\nvector <int> figure (int K)\n{\n    for (int i = 0; i < N; i++)\n        arr[i] = parr[i] - K;\n\n    vector <int> res;\n    for (int i = 0; i < K; i++)\n    {\n        int hneed = -1; // latest one we need\n        int lcant = 1e6; // earliest one we cant\n        for (int j = 0; j < N; j++)\n        {\n            if (!arr[j])\n                lcant = min (lcant, j);\n            if (arr[j] == K - i)\n                hneed = j;\n        }\n\n        if (hneed < lcant)\n        {\n            for (int j = 0; j < N; j++)\n                res.push_back(j);\n            if (hneed == -1 && lcant > 0)\n                hneed = 0;\n            for (int j = 0; j <= hneed; j++)\n            {\n                res.push_back(j);\n                arr[j]--;\n            }\n            continue;\n        }\n        else\n        {\n            for (int j = 0; j <= hneed; j++)\n            {\n                used[j] = false;\n                if (arr[j])\n                {\n                    used[j] = true;\n                    arr[j]--;\n                }\n            }\n\n            for (int j = 0; j < N; j++)\n                if (used[j]) res.push_back(j);\n            for (int j = 0; j < N; j++)\n                if (!used[j]) res.push_back(j);\n            for (int j = 0; j < N; j++)\n                if (used[j]) res.push_back(j);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    int lo = 1e6, hi = 0;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        parr[i] = arr[i];\n        lo = min (lo, arr[i]);\n        hi = max (hi, arr[i]);\n    }\n\n    if (lo * 2 < hi)\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    vector <int> res;\n    for (int x = (hi + 1) / 2; x <= lo; x++)\n    {\n        vector <int> v = figure (x);\n        if (!res.size())\n            res = v;\n\n        bool f = false;\n        for (int i = 0; i < res.size(); i++)\n        {\n            if (v[i] != res[i])\n            {\n                if (v[i] < res[i])\n                {\n                    f = true;\n                }\n                break;\n            }\n        }\n        if (f)\n            res = v;\n    }\n\n    for (int i = 0; i < res.size(); i++)\n    {\n        if (i) cout << \" \";\n        cout << res[i] + 1;\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass EPermutationCover {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int K; cin >> K;\n        vector<int> A(K); cin >> A;\n        int mx = *max_element(A.begin(),A.end());\n        vector<vector<int>> Soln;\n\n        for (int t = mx; t <= 2*mx; ++t) {\n            if (*min_element(A.begin(),A.end()) < t - t/2) break;\n\n            vector<int> B = A;\n\n            vector<int> cur;\n            vector<bool> prevOver(K, false);\n            for (int a = 0; a < t; ++a) {\n                vector<bool> canOver(K, false);\n                vector<bool> mustOver(K, false);\n                for (int i = 0; i < K; ++i) {\n                    canOver[i] = !prevOver[i] && (B[i] < (t-a));\n                    mustOver[i] = 2*B[i] == (t-a);\n                }\n\n                vector<bool> isOver(K, false);\n                int first = K;\n                int last = -1;\n                for (int i = 0; i < K; ++i) {\n                    if (mustOver[i]) {\n                        isOver[i] = true;\n                        first = min(i, first);\n                        last = i;\n                    }\n                }\n                for (int i = first; i < K; ++i) {\n                    if (canOver[i]) {\n                        isOver[i] = true;\n                    }\n                }\n                for (int i = 0; i < K; ++i) {\n                    if (!prevOver[i] && !isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n                for (int i = 0; i < K; ++i) {\n                    if (isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n//                cout << \"level \" << a << endl;\n//                cout << \"canover \" << canOver;\n//                cout << \"mustover \" << mustOver;\n//                cout << \"isover \" << isOver;\n\n                prevOver = isOver;\n            }\n\n\n\n            Soln.push_back(cur);\n        }\n\n        if (Soln.empty()) {\n            cout << \"-1\\n\";\n        } else {\n            cout << *min_element(Soln.begin(),Soln.end());\n        }\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEPermutationCover solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops;\nUL P2[100];\nvector<UL> buf;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloops = (loops + 1) / 2;\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\tvector<UL> ans;\n\trep(l, loops) {\n\t\tvector<UL> S, T;\n\t\tUL p = 0;\n\t\trep(i, K) {\n\t\t\tif (P2[i] == loops - l) {\n\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\telse T.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\tfor (; p < K; p++) {\n\t\t\tT.push_back(p);\n\t\t}\n\t\tsort(S.begin(), S.end());\n\t\tsort(T.begin(), T.end());\n\t\tconcat(ans, S);\n\t\tconcat(ans, T);\n\t\tconcat(ans, S);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\tif (p1valid({i})) return i;\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass EPermutationCover {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int K; cin >> K;\n        vector<int> A(K); cin >> A;\n        int mx = *max_element(A.begin(),A.end());\n        vector<vector<int>> Soln;\n\n        for (int t = mx; t <= 2*mx; ++t) {\n            if (*min_element(A.begin(),A.end()) < t - t/2) break;\n\n            vector<int> B = A;\n\n            vector<int> cur;\n            vector<bool> prevOver(K, false);\n            for (int a = 0; a < t; ++a) {\n                vector<bool> canOver(K, false);\n                vector<bool> mustOver(K, false);\n                for (int i = 0; i < K; ++i) {\n                    canOver[i] = !prevOver[i] && (B[i] < (t-a));\n                    mustOver[i] = !prevOver[i] && 2*B[i] == (t-a);\n                }\n\n                vector<bool> isOver(K, false);\n                int first = K;\n                int last = -1;\n                for (int i = 0; i < K; ++i) {\n                    if (mustOver[i]) {\n                        isOver[i] = true;\n                        first = min(i, first);\n                        last = i;\n                    }\n                }\n                if (first == K) {\n                    int i = K-1;\n                    while (i >= 0 && canOver[i]) {\n                        isOver[i] = true;\n                        --i;\n                    }\n                } else {\n                    for (int i = first; i < K; ++i) {\n                        if (canOver[i]) {\n                            isOver[i] = true;\n                        }\n                    }\n                }\n                for (int i = 0; i < K; ++i) {\n                    if (!prevOver[i] && !isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n                for (int i = 0; i < K; ++i) {\n                    if (isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n//                cout << \"level \" << a << endl;\n//                cout << B;\n//                cout << \"canover \" << canOver;\n//                cout << \"mustover \" << mustOver;\n//                cout << \"isover \" << isOver;\n\n                prevOver = isOver;\n            }\n\n            Soln.push_back(cur);\n        }\n\n//        cout << Soln;\n\n        if (Soln.empty()) {\n            cout << \"-1\\n\";\n        } else {\n            cout << *min_element(Soln.begin(),Soln.end());\n        }\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEPermutationCover solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[ptra] < sb[ptrb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[sa[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= ansptr; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int K=105,N=1005;\nint k,n;\nint a[K];\nbool operator<(const vector<int>&a,const vector<int>&b)\n{\n\tfor(size_t i=0;i<min(a.size(),b.size());i++)\n\t{\n\t\tif(a[i]<b[i]) return true;\n\t\tif(a[i]>b[i]) return false;\n\t}\n\treturn a.size()<b.size(); \n}\nvector<int>merge(const vector<int>&a,const vector<int>&b)\n{\n\tvector<int>res;\n\tsize_t i=0,j=0;\n\twhile(i<a.size()&&j<b.size())\n\t{\n\t\tif(a[i]<b[j]) res.push_back(a[i]),i++;\n\t\telse res.push_back(b[j]),j++;\n\t}\n\twhile(i<a.size())\n\t\tres.push_back(a[i]),i++;\n\twhile(j<b.size())\n\t\tres.push_back(b[j]),j++;\n\treturn res;\n}\nint ans[N],tot;\nint b[K];\nbool pos[K];\nvector<int>add(int len)\n{\n\tfor(int i=1;i<=k;i++)\n\t\tpos[i]=false,b[i]=a[i];\n\tvector<int>pre; \n\tfor(int i=tot,j=1;i>=1&&j<=k-len;i--,j++)\n\t\tpre.push_back(ans[i]);\n\tfor(int u:pre)\n\t\tpos[u]=true;\n\tfor(int i=1;i<=k;i++)\n\t\tif(!pos[i]) b[i]--;\n\tfor(int i=1;i<=k;i++)\n\t\tif(b[i]<0) return {k+1};\n\tint Min=*min_element(b+1,b+k+1),Max=*max_element(b+1,b+k+1);\n\tif(Min*2>=Max)\n\t{\n\t\tvector<int>res;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]) res.push_back(i);\n\t\treturn res;\n\t}\n\telse if(Min*2+1==Max)\n\t{\n\t\tvector<int>x,y;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Max) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Min) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]!=Min&&b[i]!=Max) y.push_back(i);\n\t\tvector<int>res=merge(x,y);\n\t\tpre.insert(pre.end(),res.begin(),res.end());\n\t\tint L=0,R=pre.size();\n\t\tfor(int i=0;i<pre.size();i++)\n\t\t{\n\t\t\tif(b[i]==Min) L=max(L,i);\n\t\t\tif(b[i]==Max) R=min(R,i);\n\t\t}\n\t\tif(L<R) return res;\n\t\telse return {k+1};\n\t}\n\telse return {k+1};\n}\nvoid solve()\n{\n\tvector<int>res={k+1};\n\tfor(int len=1;len<=k&&tot+len<=n;len++)\n\t{\n\t\tint d=k-len;\n\t\tif(tot-d>=0)\n\t\t{\n\t\t\tvector<int>now=add(len);\n\t\t\tres=min(res,now);\n\t\t}\n\t}\n\tfor(int u:res)\n\t{\n\t\tans[++tot]=u;\n\t\ta[u]--;\n\t\tprintf(\"%d \",u);\n\t}\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++)\n\t\tscanf(\"%d\",&a[i]),n+=a[i];\n\tint Min=*min_element(a+1,a+k+1),Max=*max_element(a+1,a+k+1);\n\tif(2*Min+1<=Max)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(tot<n)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) {\n\t\t\tlen = pre - i;\n\t\t\tbreak;\n\t\t}\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\t// if (pre == 6) debug(len);\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// for (int i = 1; i <= n; i++) debug(i), debug(b[i]);\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 1005\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nbool use[SIZE];\nint ans[SIZE];\nint n,sz;\n\nint get_first()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\tif(mn*2<mx) return SIZE;\n\tif(mn*2>mx) return 0;\n\tfor(int i=0;i<n;i++) if(A[i]>mn) return i;\n\treturn -1;\n}\nbool impossible()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\treturn mn*2<mx;\n}\nbool check()//when sz>=n\n{\n\tmultiset <int> st;\n\tmultiset <int>::iterator it;\n\tfor(int i=0;i<n;i++) st.insert(A[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a=*st.begin();\n\t\tit=st.end();it--;\n\t\tint b=*it;\n\t\tif(2*a>=b) return true;\n\t\tint v=ans[sz-n+i];\n\t\tit=st.lower_bound(A[v]);\n\t\tst.erase(it);\n\t\tst.insert(A[v]-1);\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tif(impossible())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsz=0;\n\twhile(A[0]>0)\n\t{\n\t\tint mn=1000;\n\t\tfor(int i=0;i<n;i++) mn=min(mn,A[i]);\n\t\tvector <int> vx;\n\t\tint mx=-1;\n\t\tmemset(use,false,sizeof(use));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(A[i]==mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t\tmx=max(mx,i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<mx;i++)\n\t\t{\n\t\t\tif(A[i]>mn&&A[i]<mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t}\n\t\t}\n\t\tsort(vx.begin(),vx.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!use[i]) vx.push_back(i);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tans[sz++]=vx[i];\n\t\t\tA[vx[i]]--;\n\t\t}\n\t\tint p=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint v=vx[p];\n\t\t\tif(A[v]==0) break;\n\t\t\tif(get_first()<v) break;\n\t\t\tA[v]--;\n\t\t\tans[sz++]=v;\n\t\t\tif(!check())\n\t\t\t{\n\t\t\t\tsz--;\n\t\t\t\tA[v]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tif(p==n) p=0;\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++) printf(\"%d \",ans[i]+1);\n\tputs(\"\");\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, s, a[MAXN];\nint x, y, cur[MAXN], res[MAXN], ans[MAXN];\nbool cnp(int s, int t) {\n\tif ((a[s] == x) == (a[t] == x)) return s < t;\n\telse return (a[s] == x) < (a[t] == x);\n}\nvoid work(int len) {\n\tbool valid = true, found = false;\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]--;\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\tif (Min * 2 >= Max) {\n\t\tfound = true;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tres[i] = cur[i];\n\t\tsort(res + 1, res + len + 1);\n\t} else if (Min * 2 + 1 == Max) {\n\t\tx = Min, y = Max;\n\t\tint k1 = 0, k2 = 0, k = 0;\n\t\tstatic int res1[MAXN], res2[MAXN];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (a[cur[i]] == Min || a[cur[i]] == Max) res1[++k1] = cur[i];\n\t\t\telse res2[++k2] = cur[i];\n\t\tsort(res1 + 1, res1 + k1 + 1, cnp);\n\t\tsort(res2 + 1, res2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2) {\n\t\t\t\tif (res1[x1] < res2[x2]) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t} else {\n\t\t\t\tif (x1 <= k1) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t}\n\t\tfound = true;\n\t\tfor (int i = len + 1; i <= n; i++)\n\t\t\tif (a[cur[i]] == Min) found = false;\n\t\t//found |= (x1 == 0) || (a[res1[1]] == Max);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]++;\n\tif (!valid || !found) res[1] = 0;\n}\nbool cmp(int *a, int *b) {\n\tint pos = 1;\n\twhile (a[pos] == b[pos]) pos++;\n\treturn a[pos] < b[pos];\n}\nbool check() {\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\treturn Min * 2 >= Max;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tif (!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcur[i] = i;\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[res[i]]--;\n\t\tcur[i] = res[i];\n\t\tans[m] = res[i];\n\t}\n\twhile (m != s) {\n\t\tstatic int inc[MAXN];\n\t\tmemset(inc, 0, sizeof(inc));\n\t\tint len = 0; inc[1] = n + 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (res[1] != 0 && cmp(res, inc)) {\n\t\t\t\tlen = i;\n\t\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\t\tinc[j] = res[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i + len <= n; i++)\n\t\t\tcur[i] = cur[i + len];\n\t\tfor (int i = 1; i <= len; i++) {\n\t\t\tans[++m] = inc[i];\n\t\t\tcur[n - len + i] = inc[i], a[inc[i]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\nconst int N=1005;\nint n,a[N],s,ans[N],top,vis[N];\nvoid getv(int &v1,int &v2){\n\tv1=1e9,v2=0;\n\tFor(i,1,n){\n\t\tv1=min(v1,a[i]);\n\t\tv2=max(v2,a[i]);\n\t}\n}\nvoid construct1(){\n\tint v1,v2,p=0;\n\tFor(i,1,n){\n\t\t--a[ans[top+i-n]];\n\t\tgetv(v1,v2);\n\t\tif (v1>=0&&v1*2>=v2) p=i;\n\t\telse if (v1*2+1==v2&&v1>=0){\n\t\t\tint p1=1e9,p2=0;\n\t\t\tFor(j,top+i-n+1,top+i){\n\t\t\t\tif (a[ans[j]]==v1) p1=min(p1,j);\n\t\t\t\tif (a[ans[j]]==v2) p2=max(p2,j);\n\t\t\t}\n\t\t\tif (p1>p2) p=i;\n\t\t}\n\t}\n\tFor(i,p+1,n) ++a[ans[top+i-n]];\n\tassert(p);\n\tmemset(vis,0,sizeof(vis));\n\tFor(i,1,p) vis[ans[top+i-n]]=1;\n\tgetv(v1,v2);\n\tif (v1*2>=v2){\n\t\tFor(i,1,n) if (vis[i]) ans[++top]=i;\n\t}\n\telse{\n\t\tint p=0;\n\t\tFor(i,1,n) if (vis[i]&&a[i]==v2) p=i;\n\t\tFor(i,1,p) if (vis[i]&&a[i]!=v1) ans[++top]=i;\n\t\tFor(i,1,p) if (vis[i]&&a[i]==v1) ans[++top]=i;\n\t\tFor(i,p+1,n) if (vis[i]) ans[++top]=i;\n\t}\n\tint v=n,pp=top;\n\tmemset(vis,0,sizeof(vis));\n\tRep(i,top,top-p+2){\n\t\tv-=(vis[ans[i]]==0);\n\t\tv-=(vis[ans[i-n]]==0);\n\t\t--vis[ans[i]];\n\t\t++vis[ans[i-n]];\n\t\tv+=(vis[ans[i]]==0);\n\t\tv+=(vis[ans[i-n]]==0);\n\t\tif (v==n) pp=i-1;\n\t}\n\tfor (;top>pp;top--)\n\t\t++a[ans[top]];\n\t/*cout<<p<<' '<<pp<<' '<<top<<endl;\n\tFor(i,1,n) cout<<a[i]<<' '; cout<<endl;\n\tFor(i,1,top) cout<<ans[i]<<' '; cout<<endl;*/\n}\nvoid construct2(){\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]-1),v2=max(v2,a[i]-1);\n\tassert(v1*2+1>=v2);\n\tFor(i,1,n) a[i]--;\n\tif (v1*2>=v2){\n\t\tFor(i,1,n) ans[++top]=i;\n\t}\n\telse{\n\t\tint p=0;\n\t\tFor(i,1,n) if (a[i]==v2) p=i;\n\t\tFor(i,1,p) if (a[i]!=v1) ans[++top]=i;\n\t\tFor(i,1,p) if (a[i]==v1) ans[++top]=i;\n\t\tFor(i,p+1,n) ans[++top]=i;\n\t}\n\t//For(i,1,n) cout<<ans[i]<<' '; cout<<endl;\n\t//For(i,1,n) cout<<a[i]<<' '; cout<<endl;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) s+=a[i];\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]),v2=max(v2,a[i]);\n\tif (v1*2<v2) return puts(\"-1\"),0;\n\tconstruct2();\n\tfor (;top!=s;) construct1();\n\tFor(i,1,s) cout<<ans[i]<<' '; cout<<endl;\n}\n/*\n1 2 3 4 5 6 2 1 3 4 5 6 2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nbool ok(vector<int> a){\n\twhile(1){\n\t\tconst int mn=*min_element(all(a));\n\t\tif(mn<0) return false;\n\t\tif(mn==*max_element(all(a))) return true;\n\t\tif(mn==0) return false;\n\t\tfor(auto &x:a){\n\t\t\tif(x==mn) --x;\n\t\t\telse x-=2;\n\t\t}\n\t}\n}\n\nvector<int> solve(vector<int> a){\n\tconst int n=a.size();\n\tif(!ok(a)){\n\t\treturn {};\n\t}\n\tvv<int> ls;\n\twhile(*min_element(all(a))<*max_element(all(a))){\n\t\tvector<int> large;\n\t\tint mn=*min_element(all(a));\n\t\tbool yametai=0;\n\t\trep(i,n){\n\t\t\tif(a[i]!=mn){\n\t\t\t\tlarge.pb(i);\n\t\t\t}else{\n\t\t\t\tyametai=1;\n\t\t\t}\n\t\t\tif(yametai){\n\t\t\t\tif(large.empty()) continue;\n\t\t\t\tauto b=a;\n\t\t\t\tfor(auto &x:b) --x;\n\t\t\t\tfor(auto i:large) b[i]--;\n\t\t\t\tif(ok(b)){\n\t\t\t\t\ta=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// out(large,1);\n\t\tls.eb(large);\n\t}\n\tconst int m=ls.size();\n\tvector<int> re;\n\trep(_,a[0])rep(i,n) re.pb(i);\n\trep(i,m){\n\t\tconst auto &large=ls[i];\n\t\tvector<int> small;\n\t\t{\n\t\t\tvector<int> usd(n);\n\t\t\tfor(int i:large) usd[i]=1;\n\t\t\trep(i,n)if(!usd[i]) small.pb(i);\n\t\t}\n\t\t// if(t && (i+1==m || small[0]<ls[i+1][0])){\n\t\t// \trep(_,t){\n\t\t// \t\tfor(auto i:large) re.pb(i);\n\t\t// \t\tfor(auto i:small) re.pb(i);\n\t\t// \t}\n\t\t// \tt=0;\n\t\t// }\n\t\tfor(auto i:large) re.pb(i);\n\t\tfor(auto i:small) re.pb(i);\n\t\tfor(auto i:large) re.pb(i);\n\t\t// out(i,re,1);\n\t}\n\treturn re;\n}\n\nint main(){\n\tif(1){\n\t\trep(_,1000){\n\t\t\tconst int n=rand()%6+1;\n\t\t\tconst int t=rand()%10+1;\n\t\t\tvector<int> ans;\n\t\t\trep(_,t){\n\t\t\t\tvector<int> p(n); iota(all(p),0); random_shuffle(all(p));\n\t\t\t\tint r=rand()%n;\n\t\t\t\tint t=rand()%2+1;\n\t\t\t\trep(_,t)for(int x:p) ans.pb(x);\n\t\t\t\trep(i,r) ans.pb(p[i]);\n\t\t\t}\n\t\t\tvector<int> a(n);\n\t\t\tfor(int x:ans) ++a[x];\n\t\t\tauto act=solve(a);\n\t\t\tif(act.empty()){\n\t\t\t\tout(ans,a,1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvector<int> b(n);\n\t\t\tfor(auto x:act) ++b[x];\n\t\t\tif(a!=b){\n\t\t\t\tout(ans,a,b,1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tout(\"done\",1);\n\t\treturn 0;\n\t}\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(auto &x:a) cin>>x;\n\tauto re=solve(a);\n\tif(re.empty()){\n\t\tcout<<(n/0) NL;\n\t\tcout<<-1 NL;\n\t}else{\n\t\trep(i,re.size()) cout<<re[i]+1<<\" \\n\"[i+1==re.size()];\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\n\nconst int N=2005;\nint n,s,a[N],la[N];\nint vis[N],vv[N],ans[N];\nbool jud(int p){\n\tint v=0;\n\tmemset(vis,0,sizeof(vis));\n\tmemset(vv,0,sizeof(vv));\n\tFor(i,1,p+n){\n\t\tif (!(vis[ans[i]])&&ans[i]) ++v;\n\t\t++vis[ans[i]];\n\t\tif (i>n){\n\t\t\t--vis[ans[i-n]];\n\t\t\tif (!vis[ans[i-n]]&&ans[i-n]) --v;\n\t\t}\n\t\tif (i>=n&&v==min(i,p)-(i-n))\n\t\t\t++vv[i-n+1],--vv[min(i,p)+1];\n\t}\n\tFor(i,1,p){\n\t\tvv[i]+=vv[i-1];\n\t\tif (!vv[i]) return 0;\n\t}\n\tint p1=1e9,p2=0;\n\tFor(i,1,n) p1=min(p1,a[i]),p2=max(p2,a[i]);\n\tif (p2>p1*2+1) return 0;\n\tif (p2<=p1*2) return 1;\n\t//cout<<p1<<' '<<p2<<endl;\n\tint p3=1e9,p4=0;\n\tmemset(vis,0,sizeof(vis));\n\tFor(i,1,s) vis[ans[i]]=i;\n\tFor(i,1,n){\n\t\tif (a[i]==p1) p3=min(p3,vis[i]);\n\t\tif (a[i]==p2) p4=max(p4,vis[i]);\n\t}\n\t//cout<<p1<<' '<<p2<<' '<<p3<<' '<<p4<<endl;\n\treturn p3>p4;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) s+=a[i];\n\tif (!jud(0))\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,s) For(j,1,n) if (a[j]){\n\t\tans[i]=j; --a[j];\n\t\tif (jud(i)){\n\t\t\t//cout<<\"F \"<<i<<' '<<j<<endl;\n\t\t\tbreak;\n\t\t}\n\t\t++a[j];\n\t}\n\tFor(i,1,s) cout<<ans[i]<<' ';cout<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n      printf(\"-1\");\n      return 0;\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else assert(false);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value>* = nullptr>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    int read_unsafe() { return 0; }\n    template <class H, class... T> int read_unsafe(H& h, T&... t) {\n        bool f = read_single(h);\n        if (!f) return 0;\n        return 1 + read_unsafe(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value>* = nullptr>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(__int128 val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    int k;\n    sc.read(k);\n    V<int> a(k);\n    int n = 0;\n    for (int i = 0; i < k; i++) {\n        sc.read(a[i]);\n        n += a[i];\n    }\n\n    auto check = [&](V<int> v, int s) {\n        V<int> cnt = a;\n        V<int> last(k, -1);\n        int p = 0, l = 0, ok = 0;\n        auto inc = [&](int x) -> bool {\n            if (!cnt[x]) return false;\n            cnt[x]--;\n            l = max(l, last[x] + 1);\n            last[x] = p;\n            p++;\n            if (p - l == k) ok = p;\n            if (p - ok == k) return false;\n            return true;\n        };\n        for (int i = 0; i < s; i++) {\n            if (!inc(v[i])) return false;\n        }\n        for (int i = s; i < n; i++) {\n            using P = tuple<int, int, int>;\n            P ma = P(-1, -1, -1);\n            for (int j = 0; j < k; j++) {\n                if (cnt[j] == 0) continue;\n                if (ok <= last[j]) continue;\n                ma = max(ma, P(cnt[j], -last[j], j));\n            }\n            int j = get<2>(ma);\n            if (j == -1) return false;\n            if (!inc(j)) return false;\n        }\n        if (ok != n) return false;\n        return true;\n    };\n    V<int> v(n, -1);\n    if (!check(v, 0)) {\n        pr.writeln(-1);\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            v[i] = j;\n            if (check(v, i + 1)) break;\n        }\n    }\n    for (int x: v) {\n        pr.write(x + 1);\n        pr.write(' ');\n    }\n    pr.writeln();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(i > last_2h) vis_2h_h = true;\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          // if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // 特殊形(単調増加)\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\trep(_,len){\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tif(p<si(cur)&&si(cur)<k)continue;\n\t\t\tvi tmp;\n\t\t\tif(p==si(cur))tmp=cur;\n\t\t\telse if(p==0)tmp=vi(cur.bg+1,cur.ed);\n\t\t\ttmp.pb(nx);\n\t\t\ta[nx]--;\n\t\t\tif(can(k,a,tmp)){\n\t\t\t\tans.pb(nx);\n\t\t\t\tcur=tmp;\n\t\t\t\tfound=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      pair<vi, int> best(solve(a, a.size()), 0);\n      for (int l = 1; l < a.size(); ++l) {\n        --a[v0[l - 1]];\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, a.size() - l, v0[l]);\n        if (v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n      }\n      best.first.resize(best.second);\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second == 0 ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nvoid validate(vi v, vi a) {\n  int n = a.size();\n  assert(v.size() == len(a));\n  vi c(n);\n  for (int x : v) {\n    assert(x >= 0 && x < n);\n    ++c[x];\n  }\n  assert(a == c);\n  vi f(v.size());\n  for (int i = 0; i + n <= v.size(); ++i) {\n    vi w(n);\n    for (int j = i; j < i + n; ++j) w[v[j]] = 1;\n    bool ok = 1;\n    for (int x : w) if (!x) ok = 0;\n    if (ok) for (int j = i; j < i + n; ++j) f[j] = 1;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    assert(f[i]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 9; ++n) for (int test = 1; test <= 100000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      validate(v, a);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  validate(res, a);\n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      int len1 = min((int)a.size(), len - (int)a.size());\n      pair<vi, int> best(solve(a, len1), -1);\n      for (int l = 0; l < a.size(); ++l) {\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, len1 - l, l < v0.size() ? v0[l] : -1);\n        if (v2.empty() || v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n        --a[v0[l]];\n      }\n      best.first.resize(max(0, best.second));\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second >= 0 && best.second < v0.size() ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nvoid validate(vi v, vi a) {\n  int n = a.size();\n  assert(v.size() == len(a));\n  vi c(n);\n  for (int x : v) {\n    assert(x >= 0 && x < n);\n    ++c[x];\n  }\n  assert(a == c);\n  vi f(v.size());\n  for (int i = 0; i + n <= v.size(); ++i) {\n    vi w(n);\n    for (int j = i; j < i + n; ++j) w[v[j]] = 1;\n    bool ok = 1;\n    for (int x : w) if (!x) ok = 0;\n    if (ok) for (int j = i; j < i + n; ++j) f[j] = 1;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    assert(f[i]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 9; ++n) for (int test = 1; test <= 100000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      validate(v, a);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  validate(res, a);\n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (false && mh() == v) {\n\t\t\t\tint nxt = min(mh(), j==k-1? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh <= nxt) {\n\t\t\t\t\t++a[v];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\tj=-1;\n\t\tFOR(i,K) if(A[i]==2*y) j=i;\n\t\tif(j==-1 && A[0]>y) j=0;\n\t\tvector<int> X,Y;\n\t\tFOR(i,K) {\n\t\t\tif(i<=j && A[i]>y) X.push_back(i),A[i]-=2;\n\t\t\telse Y.push_back(i),A[i]--;\n\t\t}\n\t\tFORR(c,X) V.push_back(c);\n\t\tFORR(c,Y) V.push_back(c);\n\t\tFORR(c,X) V.push_back(c);\n\t}\n\t\n\tFOR(i,N) cout<<V[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nconst int N = 200000;\nbitset<N> v, odd, pref;\nll X = 0;\n\nvoid inc() {\n  X += (v & odd).count();\n}\n\nconst int DEBUG = 0;\n\nll stupid(string s) {\n  int n = s.size();\n  vi ord(n);\n  for (int i = 0; i < n; ++i) ord[i] = i;\n  int ma = 0;\n  do {\n    vi used(n);\n    int sum = 0;\n    for (int x : ord) {\n      used[x] = 1;\n      int c = 0, l = 0;\n      for (int i = 0; i < n; ++i) if (used[i]) {\n        ++l;\n        if (l % 2 && s[i] == '1') ++c;\n      }\n      sum += c;\n    }\n    ma = max(ma, sum);\n  } while (next_permutation(ord.begin(), ord.end()));\n  return ma;\n}\n\nvoid solve(string s) {\n  X = 0;\n  int n = s.size();\n  int c = 0;\n  vi used(n);\n  for (int i = 0; i < n; ++i) if (s[i] == '1') {\n    ++c;\n    used[i] = 1;\n  }\n  int cur = 0;\n  for (int i = 0; i < c; ++i) {\n    v[i] = 1;\n    if (i % 2 == 0) ++cur;\n    X += cur;\n  }\n  int p = 0;\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '0') {\n      if (p % 2) {\n        used[i] = 1;\n        ++c;\n        if (c % 2) ++cur;\n        X += cur;\n        ++p;\n      }\n    } else {\n      ++p;\n    }\n  }\n  vi x(2);\n  int l = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (!used[i]) {\n      vi nx = x;\n      swap(nx[0], nx[1]);\n      cur += nx[0] - x[0];\n      x = nx;\n      X += cur;\n      ++c;\n      ++l;\n    } else {\n      int j = c - l - 1;\n      if (s[i] == '1') x[j % 2]++;\n      ++l;\n    }\n  }\n/*  for (int i = 0; i < n; i += 2) odd[i] = 1;\n  for (int i = 0; i < c; ++i) {\n    pref[i] = v[i] = 1;\n    inc();\n  }\n  int pc = c;\n  for (int i = n - 1; i >= 0; --i) if (s[i] == '0') {\n    int l = n - i - 1;\n    while (pc > c - l) {\n      --pc;\n      pref[pc] = 0;\n    }\n    auto prefv = v & pref;\n    v = prefv | ((v ^ prefv) << 1);\n    ++c;\n    inc();\n  }*/\n  cout << X << endl;\n  if (DEBUG) {\n    ll res = stupid(s);\n    if (res != X) {\n      cerr << s << ' ' << res << ' ' << X << endl;\n      assert(0);\n    }\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s(N, '0');\n  if (!DEBUG) {\n    cin >> s;\n    solve(s);\n  } else {\n    for (int n = 1; n <= 10; ++n) {\n      s.resize(n);\n      for (int mask = 0; mask < (1 << n); ++mask) {\n        for (int i = 0; i < n; ++i) {\n          if (mask & (1 << i)) s[i] = '1';\n          else s[i] = '0';\n        }\n        solve(s);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\n\nint K;\nint A[111];\n\nint l[111];//label\n\n\n/*\nfloor((m+1-l[i])/2)>A[i]\n(m-l[i])/2>A[i]\nm-l[i]>2*A[i]\nm>2*A[i]+l[i]\n*/\nbool check(){\n\tint m=0;\n\trep(i,K)chmax(m,A[i]+l[i]);\n\trep(i,K)if(m>2*A[i]+l[i])return false;\n\treturn true;\n}\n\nbool ex[111];\nint pos[111];\nsigned main(){\n\tcin>>K;\n\trep(i,K)cin>>A[i];\n\n\tif(!check()){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\n\tvint ans;\n\tint rem=0;\n\n\twhile(*max_element(A,A+K)){\n\t\tint len=ans.size();\n\t\tfor(int i=0;i<K;i++){\n\t\t\tif(A[i]==0)continue;\n\n\t\t\tif(find(ans.end()-rem,ans.end(),i)!=ans.end())continue;\n\t\t\tans.pb(i);\n\t\t\tA[i]--;\n\t\t\tint memrem=rem;\n\t\t\trem++;\n\n\t\t\tif(ans.size()>=K){\n\t\t\t\tbool isperm=true;\n\t\t\t\tmemset(ex,0,sizeof(ex));\n\t\t\t\tfor(int j=0;j<K;j++){\n\t\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\t\tif(ex[a])isperm=false;\n\t\t\t\t\tex[a]=true;\n\t\t\t\t}\n\t\t\t\tif(isperm)rem=0;\n\t\t\t}\n\n\n\n\t\t\tmemset(l,0,sizeof(l));\n\t\t\trep(j,rem){\n\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\tl[a]=1;\n\t\t\t}\n\n\t\t\tint ma=-1001001001,mi=1001001001;\n\t\t\trep(j,K){\n\t\t\t\tchmax(ma,A[j]-1+l[j]);\n\t\t\t\tchmin(mi,2*(A[j]-1+l[j]));\n\t\t\t}\n\n\t\t\tint argma=1001001001,argmi=-2;\n\t\t\trep(j,rem){\n\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\tif(ma==A[a])chmin(argma,j);\n\t\t\t\tif(mi==2*A[a])chmax(argmi,j);\n\t\t\t}\n\t\t\trep(j,K)if(!l[j]&&A[j]-1==ma)argma=-1;\n\n\n\t\t\tif(ma<=mi)break;\n\t\t\tif(ma-mi==1&&argma>argmi)break;\n\n\n\t\t\tfor(int j=rem;j<K&&j<ans.size();j++){\n\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\tif(l[a])break;\n\t\t\t\tif(ma==A[a]-1)break;\n\t\t\t\tl[a]=1;\n\t\t\t}\n\t\t\tif(check())break;\n\n\n\t\t\tA[i]++;\n\t\t\trem=memrem;\n\t\t\tans.pop_back();\t\t\t\n\t\t}\n\t\tif(len==ans.size())break;\n\t}\n\n\trep(i,ans.size()){\n\t\tif(i)cout<<\" \";\n\t\tcout<<ans[i]+1;\n\t}cout<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nbool suc = false;\n\nint n;\n \nvoid change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n\n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\tif (2*minimum.first < maximum.first) {\n\t\tsuc = false;\n\t\treturn;\n\t}\n\tcout << u+1 << \" \";\n\tsuc = true;\n\n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n}\n \nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n \n\tsort(all(arr));\n \n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n \n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tarr[i].first--;\n\t\t}\n\n\t\tchange(arr, 0);\n\n\t}\n \n\tint u = 0;\n\twhile (true) {\n \n\t\tchange(arr, u);\n\t\tif (suc) u = (u+1)%n;\n\t\telse break;\n \n\t}\n \n \n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n \n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass EPermutationCover {\npublic:\n    void solve() {\n        int k = in.readInt();\n        auto a = in.readIntArray(k);\n\n        if (*min_element(all(a)) * 2 < *max_element(all(a))) {\n            out.printLine(-1);\n            return;\n        }\n        vi p;\n        vi lastPerm(1);\n        arri last(k, -k);\n        int from = 0;\n        while (true) {\n            while (from == k) {\n                if (lastPerm.back() == p.size()) {\n                    lastPerm.pop_back();\n                }\n                a[p.back() - 1]++;\n                from = p.back();\n                p.pop_back();\n            }\n            int mx = *max_element(all(a));\n            if (mx == 0) {\n                break;\n            }\n            bool found = false;\n            for (int i : range(from, k)) {\n                if (a[i] == 0 || mx >= 2 * a[i]) {\n                    continue;\n                }\n                bool bad = false;\n                for (int j : range(lastPerm.back(), p.size())) {\n                    if (p[j] == i + 1) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    continue;\n                }\n                found = true;\n                from = 0;\n                last[i] = p.size();\n                a[i]--;\n                p.push_back(i + 1);\n                break;\n            }\n            if (!found) {\n                from = k;\n                continue;\n            }\n            if (*min_element(all(last)) >= p.size() - k) {\n                lastPerm.push_back(p.size());\n            }\n        }\n        out.printLine(p);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    EPermutationCover solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n        }\n        if (flag[i] && flag[j]) {\n            if (j < K-1) {\n                if (li < lj) flag[j] = false;\n                else flag [i] = false;\n            }\n            else {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      int len1 = min(2 * (int)a.size(), len - (int)a.size());\n      pair<vi, int> best(solve(a, len1), -1);\n      for (int l = 0; l <= a.size(); ++l) {\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, len1 - l, l < v0.size() ? v0[l] : -1);\n        if (v2.empty() || v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n        if (l < v0.size()) --a[v0[l]];\n      }\n      best.first.resize(max(0, best.second));\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second >= 0 && best.second < v0.size() ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nvoid validate(vi v, vi a) {\n  int n = a.size();\n  assert(v.size() == len(a));\n  vi c(n);\n  for (int x : v) {\n    assert(x >= 0 && x < n);\n    ++c[x];\n  }\n  assert(a == c);\n  vi f(v.size());\n  for (int i = 0; i + n <= v.size(); ++i) {\n    vi w(n);\n    for (int j = i; j < i + n; ++j) w[v[j]] = 1;\n    bool ok = 1;\n    for (int x : w) if (!x) ok = 0;\n    if (ok) for (int j = i; j < i + n; ++j) f[j] = 1;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    assert(f[i]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 9; ++n) for (int test = 1; test <= 100000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      validate(v, a);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  validate(res, a);\n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint k;\nint a[100];\nint b[100];\nint f[100];\n\nvector<int> calc(int x) {\n    int i, j;\n    vector<int> v;\n    \n    for (i = 0; i < k; i++) b[i] = a[i];\n    \n    for (i = x - 1; i >= 0; i--) {\n        vector<int> w, z;\n        \n        for (j = 0; j < k; j++) {\n            b[j]--;\n            \n            if (b[j] > i * 2) {\n                w.push_back(j);\n                b[j]--;\n            } else if (b[j] > i) {\n                z.push_back(j);\n            }\n        }\n        \n        if (w.size() > 0) {\n            int m = w.back();\n            \n            for (j = 0; j < z.size(); j++) {\n                if (z[j] > m) break;\n                \n                w.push_back(z[j]);\n                b[z[j]]--;\n            }\n        } else {\n            for (j = 0; j < z.size(); j++) {\n                if (z[j] > j) break;\n                \n                w.push_back(z[j]);\n                b[z[j]]--;\n            }\n        }\n        \n        for (j = 0; j < k; j++) f[j] = 1;\n        \n        for (j = 0; j < w.size(); j++) f[w[j]] = 2;\n        \n        for (j = 0; j < k; j++) {\n            if (f[j] == 2) v.push_back(j);\n        }\n        \n        for (j = 0; j < k; j++) {\n            if (f[j] == 1) v.push_back(j);\n        }\n        \n        for (j = 0; j < k; j++) {\n            if (f[j] == 2) v.push_back(j);\n        }\n    }\n    \n    return v;\n}\n\nint main() {\n    int m1 = 1e9, m2 = 0, i;\n    vector<int> v;\n    \n    scanf(\"%d\", &k);\n    \n    for (i = 0; i < k; i++) scanf(\"%d\", &a[i]);\n    \n    for (i = 0; i < k; i++) {\n        if (a[i] < m1) m1 = a[i];\n        if (a[i] > m2) m2 = a[i];\n    }\n    \n    if (m1 * 2 < m2) {\n        puts(\"-1\");\n        \n        return 0;\n    }\n    \n    for (i = (m2 + 1) / 2; i <= m1; i++) {\n        vector<int> w = calc(i);\n        \n        if (v.size() == 0 || w < v) v = w;\n    }\n    \n    for (i = 0; i < v.size(); i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", v[i] + 1);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] != *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\tint tmp = 0;\n\twhile (sz < sum){\n\t\tassert(tmp != sz);\n\t\ttmp = sz;\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tset<int> A, B;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.insert(q[j]);\n\t\t\t}\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tbool flag = (mxm == 2*mnm+1);\n\t\t\tvector<int> me;\n\t\t\twhile (!A.empty()){\n\t\t\t\tint x = *A.begin();\n\t\t\t\tA.erase(A.begin());\n\t\t\t\tif (a[x] == mnm and flag){\n\t\t\t\t\tB.insert(x);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[++now] = x;\n\t\t\t\tme.push_back(x);\n\t\t\t}\n\t\t\tfor (auto it : B){\n\t\t\t\tp[++now] = it;\n\t\t\t\tme.push_back(it);\n\t\t\t}\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>  \n#include <complex>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 998244353;\ndouble eps = 1e-12;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e18\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n \nll mpow(ll a, ll b){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2);\n\tt1 *= t1;\n\tt1 %= MOD;\n\tif(b%2) t1 *= a;\n\tt1 %= MOD;\n\treturn t1;\n}\n \nll mpow(ll a, ll b, ll p){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2,p);\n\tt1 *= t1;\n\tt1 %= p;\n\tif(b%2) t1 *= a;\n\tt1 %= p;\n\treturn t1;\n}\n \nll modinverse(ll a, ll m){\n\tll m0 = m; \n    ll y = 0, x = 1; \n    if (m == 1) return 0; \n    while (a > 1){\n        ll q = a / m; \n        ll t = m; \n        m = a % m, a = t; \n        t = y; \n        y = x - q * y; \n        x = t; \n    }\n    if (x < 0) x += m0; \n    return x; \n}\n\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n \nll range(ll l, ll r){\n\treturn l + mt()%(r-l+1);\n}\n \nll rev(ll v){\n\treturn mpow(v,MOD-2);\n}\n\nvoid solve(){\n\tll n;\n\tcin >> n;\n\tll a[n];\n\tll mn = 1000;\n\tll mx = 0;\n\tll mx1 = 0;\n\tll l=0;\n\tforn(i,n){\n\t\tcin >> a[i];\n\t\tl+=a[i];\n\t\tmn = min(mn,a[i]);\n\t\tmx = max(mx,a[i]);\n\t\tif(i) mx1 = max(mx1,a[i]);\n\t}\n\tif(mx>2*mn){\n\t\tcout << -1 << ln;\n\t\treturn;\n\t}\n\tbool pr[n];\n\tforn(i,n) pr[i]=1;\n\tll ans[l];\n\tll c = 0;\n\tbool cmp[n];\n\tforn(i,n) cmp[i]=0;\n\tv64 vec;\n\tforn(i,l){\n\t\t// cout << i << ln;\n\t\tll val=-1;\n\t\tforn(j,n){\n\t\t\tif(pr[j]){\n\t\t\t\t// cout << j << \" \" << j << ln;\n\t\t\t\tbool bo = 0;\n\t\t\t\tv64 temp;\n\t\t\t\tforn(k,n){\n\t\t\t\t\tif(a[k]>(2*a[j]-1)){\n\t\t\t\t\t\tbo=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[k]==(2*a[j]-1)){\n\t\t\t\t\t\ttemp.pb(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!bo){\n\t\t\t\t\tval = j;\n\t\t\t\t\tif(sz(temp)){\n\t\t\t\t\t\tc = sz(temp);\n\t\t\t\t\t\tfor(auto it : temp) cmp[it]=1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(val!=-1);\n\t\ta[val]--;\n\t\tans[i]=val;\n\t\tif(c) vec.pb(val);\n\t\tif(cmp[val]){\n\t\t\tc--;\n\t\t\tcmp[val]=0;\n\t\t\tif(c==0) vec.clear();\n\t\t}\n\t\t// cout << c << ln;\n\t\tcout << val+1 << \" \";\n\t\tpr[val]=0;\n\t\tif(i>=n-1){\n\t\t\tbool pr1[n];\n\t\t\tforn(i,n) pr1[i]=0;\n\t\t\tbool bo = 1;\n\t\t\tforsn(j,i-n+1,i+1){\n\t\t\t\tif(pr1[ans[j]]){\n\t\t\t\t\tbo=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr1[ans[j]]=1;\n\t\t\t}\n\t\t\tif(bo){\n\t\t\t\tforn(j,n) pr[j]=1;\n\t\t\t\tfor(auto it : vec) pr[it]=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ln;\n}\n \nint main()\n{\n\tfast_cin();\n    ll t=1;\n    // cin >> t;\n    forn(i,t) {\n    \t// cout << \"Case #\" << i+1 << \": \";\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tset<int> MIN;\n\t\tfor(int i=1;i<=k;i++) if(A[i]==mn) MIN.insert(i);\n\t\tvi Ans;\n\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tH[i]-=diff;\n\t\t}\n\t\tmn-=diff;\n\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tint smol = (*(MIN.begin()));\n\t\t\tif(H[smol]==0) break;\n\t\t\t\n\t\t\tfor(auto m:MIN) {D.push_back(m);H[m]--;}\n\t\t\tfor(int i=k;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(!MIN.count(i))\n\t\t\t\t{\n\t\t\t\t\tD.push_front(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tif(!MIN.count(i))\n\t\t\t\t{\n\t\t\t\t\tD.push_back(i);\n\t\t\t\t\tH[i]-=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmn--;\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tif(H[i]==mn) MIN.insert(i);\n\t\t\t}\n\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Ans.size()==0)\n\t\t\t{\n\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t}\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nint n;\n\nint get_best(vector<pair<int, int> > arr) {\n\tvector<int> big, small;\n \n\tint Q = arr[0].first;\n\n\tfor (int j = 0; j < n; ++j) {\n\t\tif (2*Q == arr[j].first) {\n\t\t\tbig.push_back(arr[j].second);\n\t\t\tarr[j].first -= 2;\n\t\t}\n\t\telse {\n\t\t\tsmall.push_back(arr[j].second);\n\t\t\tarr[j].first--;\n\t\t}\n\t}\n\n\tsort(all(big));\n\tsort(all(small));\n\n\tif (big.size()) return big[0];\n\treturn small[0];\n\n}\n\n\nbool change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n \n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n \n\tif (2*minimum.first < maximum.first) {\n\t\treturn false;\n\t}\n\tcout << u+1 << \" \";\n \n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n\n\treturn true;\n\n}\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n \n \n\twhile (arr.back().first > 0) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n \n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t\tvector<int> perm;\n\n\t\tfor (int e = 0; e < small.size(); ++e) perm.push_back(small[e]);\n\t\tfor (int e = 0; e < big.size(); ++e) perm.push_back(big[e]);\n\n\t\tint u = 0;\n\n\t\twhile (arr.back().first > 0) {\n\n\t\t\tint W = get_best(arr);\n\n\t\t\tif (W < perm[u]) break;\n\t\t\tif (!change(arr, perm[u])) break;\n\n\t\t\tu = (u+1)%n;\n\n\t\t}\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Q=1<<10;\nint ans[Q],owo[Q],rem[Q];\nint a[Q],kk,now;\nint b[Q],had[Q];\nvector<int> nw,as;\nbool New(int len)\n{\n    fill(had+1,had+kk+1,0);\n    for(int i=1;i<=kk;i++)\n        b[i]=a[i];\n    for(int i=0;i<(kk-len);i++)\n        had[ans[now-i]]=1;\n    int mn=1e9,mx=0;\n    for(int i=1;i<=kk;i++){\n        if(!had[i])--b[i];\n        mx=max(mx,b[i]),mn=min(mn,b[i]);\n    }\n    if((mn<<1)+1<mx)return 0;\n    if((mn<<1)>=mx){\n        int tp=0;\n        for(int i=1;i<=kk;i++)\n            if(!had[i])owo[++tp]=i;\n        return 1;\n    }\n    nw.clear(),as.clear();\n    for(int i=1;i<=kk;i++)\n        if(!had[i]){\n            if(b[i]==mx)nw.push_back(i);\n            else if(b[i]!=mn)as.push_back(i);\n        }\n    for(int i=1;i<=kk;i++)\n        if((!had[i])&&b[i]==mn)nw.push_back(i);\n    merge(nw.begin(),nw.end(),as.begin(),as.end(),owo+1);\n    return 1;\n}\nint main()\n{\n    scanf(\"%d\",&kk);\n    int mn=1e9,mx=0,sm=0;\n    for(int i=1;i<=kk;i++)\n        scanf(\"%d\",&a[i]),sm+=a[i],mx=max(mx,a[i]),mn=min(mn,a[i]);\n    if((mn<<1)<mx)return 0&puts(\"-1\");\n    New(kk),now=kk;\n    for(int i=1;i<=kk;i++)\n        ans[i]=owo[i],--a[i];\n    while(now<sm){\n        rem[1]=1e9;\n        int len=0;\n        for(int p=1;p<=kk&&p<=sm-now;p++){\n            if(!New(p))continue;\n            for(int i=1;;i++)\n                if(owo[i]!=rem[i]){\n                    if(owo[i]<rem[i]){\n                        len=p;\n                        for(int i=1;i<=p;i++)\n                            rem[i]=owo[i];\n                        rem[p+1]=0;\n                    }\n                    break;\n                }\n        }\n        for(int i=1;i<=len;i++)\n            ans[++now]=rem[i],--a[rem[i]];\n    }\n    for(int i=1;i<=sm;i++)\n        printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 105;\n\nint n, a[N], s;\nint m, ans[1005];\nint b[N];\nint p[N], q[N], t[N];\n\nbool work(int k) {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tb[i] = a[i];\n\t}\n\tfor (int i = 1; i <= k; ++i) {\n\t\t--b[p[i]];\n\t}\n\tint mn = *std::min_element(b + 1, b + 1 + n);\n\tint mx = *std::max_element(b + 1, b + 1 + n);\n\tif (2 * mn + 1 < mx) {\n\t\treturn false;\n\t}\n\tif (2 * mn >= mx) {\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tq[i] = p[i];\n\t\t}\n\t\tstd::sort(q + 1, q + 1 + k);\n\t\treturn true;\n\t}\n\tstd::vector<int> f1, f2;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tif (b[p[i]] == mn || b[p[i]] == mx) {\n\t\t\tf1.push_back(p[i]);\n\t\t} else {\n\t\t\tf2.push_back(p[i]);\n\t\t}\n\t}\n\tstd::sort(f1.begin(), f1.end(), [&](int i, int j) {\n\t\tint x = b[i] == mn, y = b[j] == mn;\n\t\treturn x < y || (x == y && i < j);\n\t});\n\tstd::sort(f2.begin(), f2.end());\n\tstd::merge(f1.begin(), f1.end(), f2.begin(), f2.end(), q + 1);\n\tint pos = n + 1;\n\tfor (int i = k + 1; i <= n; ++i) {\n\t\tif (b[p[i]] == mn) {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = pos; i <= n; ++i) {\n\t\tif (b[p[i]] == mx) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (pos <= n && !f1.empty() && b[f1[0]] == mx) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool cmp(int *a, int *b) {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] != b[i]) {\n\t\t\treturn a[i] < b[i];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i] = i;\n\t}\n\tint mx = *std::max_element(a + 1, a + 1 + n);\n\tint mn = *std::min_element(a + 1, a + 1 + n);\n\tif (mx > 2 * mn) {\n\t\tprint(-1);\n\t\treturn 0;\n\t}\n\tm = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i] = i;\n\t}\n\twork(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans[++m] = p[i] = q[i];\n\t\t--a[q[i]];\n\t}\n\twhile (m < s) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tt[i] = 0;\n\t\t}\n\t\tt[1] = n + 1;\n\t\tint k = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (work(i) && cmp(q, t)) {\n\t\t\t\tk = i;\n\t\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\t\tt[j] = q[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n - k; ++i) {\n\t\t\tp[i] = p[i + k];\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tp[n - k + i] = t[i];\n\t\t\tans[++m] = t[i];\n\t\t\t--a[t[i]];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tprint(ans[i], \" \\n\"[i == m]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define N 1010\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N],k,now,ans[N];\nconst vector<int> inf(1,23333);\nbool check(){\n\tint x=*max_element(a+1,a+k+1);\n\tint y=*min_element(a+1,a+k+1);\n\treturn x<=(y<<1);\n}\nvoid Merge(vector<int> &a,vector<int> &b,vector<int> &c){\n\tint pa=0,pb=0;\n\twhile(pa<(int)a.size()&&pb<(int)b.size()){\n\t\tc.push_back(a[pa]<b[pb]?a[pa++]:b[pb++]);\n\t}\n\twhile(pa<(int)a.size())c.push_back(a[pa++]);\n\twhile(pb<(int)b.size())c.push_back(b[pb++]);\n}\nvector<int> Solve(int len){\n\tstatic int vis[N],b[N];\n\tfor(int i=1;i<=k;++i){\n\t\tvis[i]=0,b[i]=a[i];\n\t}\n\tfor(int i=now+len-k+1;i<=now;++i){\n\t\tvis[ans[i]]=1;\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\tif(!vis[i])if((--b[i])<0)return inf;\n\t}\n\tint mn=*min_element(b+1,b+k+1);\n\tint mx=*max_element(b+1,b+k+1);\n\tif(mn*2+1<mx)return inf;\n\tvector<int> res;\n\tif(mn*2>=mx){\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i])res.push_back(i);\n\t\t}\n\t}\n\telse{\n\t\tvector<int> A,B;\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mx)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mn)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]^mn&&b[i]^mx)B.push_back(i);\n\t\t}\n\t\tMerge(A,B,res);\n\t\tint pmx=0,pmn=n+1;\n\t\tfor(int i=now+len-k+1;i<=now;++i){\n\t\t\tif(b[ans[i]]==mx)pmx=max(pmx,i);\n\t\t\tif(b[ans[i]]==mn)pmn=min(pmn,i);\n\t\t}\n\t\tfor(int i=0;i<(int)res.size();++i){\n\t\t\tif(b[res[i]]==mx)pmx=max(pmx,i+now+1);\n\t\t\tif(b[res[i]]==mn)pmn=min(pmn,i+now+1);\n\t\t}\n\t\tif(pmx>pmn)res=inf;\n\t}\n\treturn res;\n}\nvoid Extend(){\n\tvector<int> ext=inf;\n\tfor(int len=1;len<=k&&len+now<=n;++len){\n\t\tif(len+now>=k){\n\t\t\text=min(ext,Solve(len));\n\t\t}\n\t}\n\tfor(auto x:ext){\n\t\tans[++now]=x;\n\t\t--a[x];\n\t}\n}\nint main(){\n\tk=read();\n\tfor(int i=1;i<=k;++i){\n\t\tn+=a[i]=read();\n\t}\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(now<n){\n\t\tExtend();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint k;\n\tcin >> k;\n\tvector<int> freq(k);\n\tfor(int& x : freq) cin >> x;\n\tint minv = 1000000, maxv = -1;\n\tfor(int x : freq){\n\t\tminv = min(minv, x); maxv = max(maxv, x);\n\t}\n\tint sum = 0;\n\tfor(int x : freq) sum += x;\n\tif(minv * 2 < maxv){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> ans;\n\tint maxworks = 0;\n\twhile((int)ans.size() < sum){\n\t\tbool found = false;\n\t\tfor(int nxt = 0; nxt < k; nxt++){\n\t\t\tvector<int> cans = ans;\n\t\t\tcans.push_back(nxt);\n\t\t\tint cmaxworks = maxworks;\n\t\t\t{\n\t\t\t\tif((int)cans.size() >= k){\n\t\t\t\t\tvector<int> d(k, 0);\n\t\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\t\td[cans[(int)cans.size() - 1 - i]]++;\n\t\t\t\t\t}\n\t\t\t\t\tbool works = true;\n\t\t\t\t\tfor(int i = 0; i < k; i++) if(!d[i]) works = false;\n\t\t\t\t\tif(works) cmaxworks = (int)cans.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cfreq = freq;\n\t\t\tcfreq[nxt]--;\n\t\t\tif(cfreq[nxt] < 0) continue;\n\t\t\tvector<int> known;\n\t\t\tfor(int f = cmaxworks; f < (int)cans.size(); f++) known.push_back(cans[f]);\n\t\t\tvector<int> zk = known;\n\t\t\tsort(zk.begin(), zk.end());\n\t\t\tif(unique(zk.begin(), zk.end()) != zk.end()) continue;\n\t\t\tbool ok = false;\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\treverse(known.begin(), known.end());\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t}\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tfor(int b = cmaxworks - 1; b >= 0; b--){\n\t\t\t\t\tif(cur[cans[b]]) break;\n\t\t\t\t\tcur[cans[b]] = 1;\n\t\t\t\t\tint a = cans[b];\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tint minval = 1000000;\n\t\t\t\tfor(int b : dfreq) minval = min(minval, b);\n\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\tif(cur[i]) continue;\n\t\t\t\t\tif(dfreq[i] > 2 * minval){\n\t\t\t\t\t\tdfreq[i]--;\n\t\t\t\t\t\tcur[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ming = 100000, maxg = 0;\n\t\t\t\tfor(int b : dfreq) ming = min(ming, b);\n\t\t\t\tfor(int b : dfreq) maxg = max(maxg, b);\n\t\t\t\tif(ming * 2 >= maxg){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(nxt);\n\t\t\t\tmaxworks = cmaxworks;\n\t\t\t\tfound = true;\n\t\t\t\tfreq[nxt]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for(int b : ans) cerr << b << ' ';\n\t\t// cerr << '\\n';\n\t\tassert(found);\n\t}\n\tfor(int b : ans) cout << b+1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  void solveOne(istream &in, ostream &out) {\n    int k;\n    in >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) in >> a[i];\n    int mn = a[0];\n    int mx = a[0];\n    for (int x : a) {\n      mn = min(mn, x);\n      mx = max(mx, x);\n    }\n    if (mx > 2 * mn) {\n      out << -1 << \"\\n\";\n      return;\n    }\n    int total = 0;\n    for (int x : a) total += x;\n    vector<int> res(total, -1);\n    int permStart = 0;\n    for (int pos = 0; pos < total; ++pos) {\n      for (int val = 0; val < k; ++val) if (a[val] > 0) {\n        res[pos] = val;\n        --a[val];\n        vector<int> sa = a;\n        vector<bool> inPerm(k, false);\n        for (int i = permStart; i < pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n        bool ok = false;\n        if (pos - k >= permStart) {\n          if (val == res[pos - k]) {\n            for (int endAt = pos + 1; endAt <= total; ++endAt) {\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n              --a[res[(endAt - permStart) % k + permStart]];\n            }\n          } else {\n            // Start new permutation\n            for (int i = 0; i < k; ++i) if (i != val) --a[i];\n            vector<ii> avail;\n            for (int i = 0; i < k; ++i) if (i != val) {\n              avail.emplace_back(-a[i], i);\n            }\n            sort(avail.begin(), avail.end());\n            int ptr = 0;\n            for (int plen = k; plen < 2 * k; ++plen) {\n              if (plen > k) {\n                if (plen == k + 1) {\n                  --a[val];\n                } else {\n                  --a[avail[ptr++].second];\n                }\n              }\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                permStart = pos;\n                break;\n              }\n            }\n          }\n        } else if (!inPerm[val]) {\n          inPerm[val] = true;\n          for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n          vector<ii> avail;\n          for (int i = 0; i < k; ++i) if (!inPerm[i]) {\n              avail.emplace_back(-a[i], i);\n            }\n          sort(avail.begin(), avail.end());\n          int ptr = 0;\n          for (int plen = k; plen < 2 * k; ++plen) {\n            if (plen > k) {\n              if (permStart + plen - k - 1 <= pos) {\n                --a[res[permStart + plen - k - 1]];\n              } else {\n                --a[avail[ptr++].second];\n              }\n            }\n            mn = a[0];\n            mx = a[0];\n            for (int x : a) {\n              mn = min(mn, x);\n              mx = max(mx, x);\n            }\n            if (mn >= 0 && mx <= 2 * mn) {\n              ok = true;\n              break;\n            }\n          }\n        }\n        a = sa;\n        if (ok) {\n          break;\n        } else {\n          ++a[val];\n          assert(val + 1 < k);\n        }\n      }\n    }\n    for (int x : res) out << x + 1 << \" \";\n    out << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 >= *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n    abort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops, loopsm;\nUL P2[100];\nvector<UL> buf;\nvector<vector<UL>> ans;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloopsm = 1000; rep(i, K) loopsm = min(loopsm, P[i]);\n\tloops = (loops + 1) / 2;\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\n\tfor (UL L = loops; L <= loopsm; L++) {\n\t\tvector<UL> ans;\n\t\trep(l, L) {\n\t\t\tvector<UL> S, T;\n\t\t\tUL p = 0;\n\t\t\trep(i, K) {\n\t\t\t\tif (P2[i] == L - l) {\n\t\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\t\telse T.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\t\tfor (; p < K; p++) {\n\t\t\t\tT.push_back(p);\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\tsort(T.begin(), T.end());\n\t\t\tconcat(ans, S);\n\t\t\tconcat(ans, T);\n\t\t\tconcat(ans, S);\n\t\t}\n\t\t::ans.push_back(ans);\n\t}\n\tsort(ans.begin(), ans.end());\n\trep(i, ans[0].size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[0][i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 1e3 + 50;\ncs int INF = 1e9 + 7;\nvoid ckmn(int &a, int b){ if(a > b) a = b; }\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\nint n, a[N], m, ans[N];\nint now[N], nxt[N], my;\nbool cmp(cs int &i, cs int &j){\n\tint x=a[i]==my,y=a[j]==my;\n\tif(x!=y)return x<y; return i<j;\n}\nbool work(int len){\n\tfor(int i=1;i<=len;i++)--a[now[i]];\n\tint mn=INF,mx=0;\n\tfor(int i=1; i<=n; i++)\n\tmn=min(mn,a[i]),mx=max(mx,a[i]);\n\t\n\tif(mn*2>=mx){\n\t\tfor(int i=1; i<=len; i++)\n\t\t++a[nxt[i]=now[i]];\n\t\tsort(nxt+1,nxt+len+1);\n\t\tnxt[len+1]=0;\n\t\treturn true;\n\t}\n\t\n\tif(mn*2+1<mx){\n\t\tfor(int i=1; i<=len; i++) ++a[now[i]];\n\t\treturn false;\n\t}\n\t\n\tstatic int t1[N], t2[N]; int z1=0, z2=0;\n\tfor(int i=1; i<=len; i++)\n\tif(a[now[i]]==mn||a[now[i]]==mx)\n\tt1[++z1]=now[i]; else t2[++z2]=now[i]; \n\t\n\tmy=mn;\n\tsort(t1+1,t1+z1+1,cmp);\n\tsort(t2+1,t2+z2+1);\n\t\n\tfor(int i=1,p=1,q=1; i<=len; i++)\n\tif((p<=z1 && t1[p]<t2[q])||q>z2) nxt[i]=t1[p++];\n\telse nxt[i]=t2[q++]; nxt[len+1]=0;\n\n\tbool ok=true;\n\tfor(int i=len+1;i<=n;i++)ok&=(a[now[i]]!=mn);\n\tok|=(z1==0)|(a[t1[1]]==mn);\n\t\n\tfor(int i=1; i<=len; i++)++a[now[i]];\n\treturn ok;\n}\nbool cmp(int *a, int *b){ \n\tint i=1;for(;a[i]==b[i];i++);\n\treturn a[i]<b[i];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"my.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tint mn=INF,mx=0,sm=0;\n\tfor(int i=1; i<=n; i++)\n\tscanf(\"%d\",&a[i]),sm+=a[i],\n\tckmn(mn,a[i]),ckmx(mx,a[i]);\n\tif(mn*2<mx) return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\t\n\tnow[i]=i; if(!work(n))return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\n\tnow[i]=ans[++m]=nxt[i],--a[now[i]];\n\twhile(m<sm){\n\t\tstatic int trs[N];\n\t\tint len=0;trs[1]=n+1;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(work(i)&&cmp(nxt,trs))\n\t\t\tlen=i,memcpy(trs,nxt,sizeof(int)*(len+2));\n\t\t}\n\t\tfor(int i=1; i+len<=n; i++)\n\t\tnow[i]=now[i+len];\n\t\tfor(int i=1; i<=len; i++)\n\t\tnow[i+n-len]=ans[++m]=trs[i],--a[trs[i]];\n\t}\n\tfor(int i=1; i<=m; i++)cout<<ans[i]<<\" \";\n\tfor(int i=1; i<=n; i++)assert(a[i]==0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 1010;\nint n, k;\nint a[N];\nint b[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(\"%d\", &a[i]);\n\twhile(true) {\n\t\tint mx = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (a[i] < 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmx = max(mx, a[i]);\n\t\t}\n\t\tif (mx == 0) break;\n\t\tvector<pii> c;\n\t\tif (n == 0) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tc.push_back(mp(a[i], i));\n\t\t} else {\n\t\t\tfor (int i = 0; ; i++) {\n\t\t\t\tint v = b[n - k + i];\n\t\t\t\tc.push_back(mp(a[v], v));\n\t\t\t\tif (a[v] == mx) break;\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\treverse(all(c));\n\t\tfor (auto t : c) {\n\t\t\tint v = t.second;\n\t\t\tif (a[v] == 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[v]--;\n\t\t\tb[n++] = v;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", b[i] + 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\nconst int maxK=100+5,maxn=1000+5;\nint n,K,a[maxK],an[maxn];\nbool vis[maxK];\ninline bool cmp(const vector<int> &a,const vector<int> &b) {\n\tfor(int i=0;i<a.size()&&i<b.size();++i) if(a[i]!=b[i]) return a[i]<b[i];\n\treturn a.size()<b.size();\n}\nvoid fail(vector<int> &re) {\n\tfor(int i=0;i<=K;++i) re.push_back(K+1);\n}\nvoid sol(int s,int m,vector<int> &re) {\n\tstatic int b[maxK]; memcpy(b,a,sizeof(b));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i+m<=K;++i) vis[an[s-i]]=1;\n\tfor(int i=1;i<=K;++i) if(!vis[i]) {\n\t\tif(!b[i]) {fail(re); return;}\n\t\t--b[i];\n\t}\n\tint x=*max_element(b+1,b+K+1),y=*min_element(b+1,b+K+1);\n\tif(x>2*y+1) {fail(re); return;}\n\tvector<int> A,B,C;\n\tif(x==2*y+1) {\n\t\tbool flag=0;\n\t\tfor(int i=1;i+m<=K;++i) {\n\t\t\tif(b[an[s-i]]==x) flag=1;\n\t\t\telse if(b[an[s-i]]==y) {\n\t\t\t\tif(flag) {fail(re); return;}\n\t\t\t}\n\t\t}\n\t\tfor(int i=K;i>=1;--i) if(!vis[i]) {\n\t\t\tif(b[i]==x) A.push_back(i);\n\t\t\telse if(b[i]==y) B.push_back(i);\n\t\t\telse C.push_back(i);\n\t\t}\n\t}\n\telse for(int i=K;i>=1;--i) if(!vis[i]) C.push_back(i);\n\tfor(int i=1;i<=m;++i) {\n\t\tif(A.size()) {\n\t\t\tint t=C.size()?C.back():K+1;\n\t\t\tif(A.back()<t) re.push_back(A.back()),A.pop_back();\n\t\t\telse re.push_back(t),C.pop_back();\n\t\t}\n\t\telse {\n\t\t\tint a=B.size()?B.back():K+1,b=C.size()?C.back():K+1;\n\t\t\tif(a<b) re.push_back(a),B.pop_back();\n\t\t\telse re.push_back(b),C.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\trd(K);\n\tfor(int i=1;i<=K;++i) rd(a[i]),n+=a[i];\n\tif(*max_element(a+1,a+K+1)>2*(*min_element(a+1,a+K+1))) {puts(\"-1\"); return 0;}\n\tfor(int i=1;i<=n;) {\n//\t\tdebug(\"---\\n\");\n\t\tvector<int> Q[maxK];\n\t\tif(i==1) sol(i,K,Q[1]);\n\t\telse {\n\t\t\tfor(int j=1;j<=K;++j) sol(i,j,Q[j]);\n\t\t\tint k=1;\n\t\t\tfor(int j=2;j<=K;++j) if(cmp(Q[j],Q[k])) k=j;\n\t\t\tif(k!=1) swap(Q[1],Q[k]);\n\t\t}\n\t\tfor(int j=0;j<Q[1].size();++j) an[i+j]=Q[1][j],--a[Q[1][j]];\n\t\ti+=Q[1].size();\n//\t\tfor(int j=1;j<i;++j) debug(\"%d \",an[j]); debug(\"\\n\");\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tif(i!=1) printf(\" \");\n\t\tprintf(\"%d\",an[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntemplate <typename T> void setmax(T& a, const T& b) { if (b > a) a = b; }\ntemplate <typename T> void setmin(T& a, const T& b) { if (b < a) a = b; }\n\nstruct interval {\n\tint lo, hi;\n\tinterval() : lo(0), hi(0) {}\n\tinterval(int lo_, int hi_) : lo(lo_), hi(hi_) {}\n\tinterval& operator &= (const interval& o) {\n\t\tsetmax(lo, o.lo);\n\t\tsetmin(hi, o.hi);\n\t\treturn *this;\n\t}\n\tfriend interval operator & (const interval& a, const interval& b) {\n\t\treturn interval(std::max(a.lo, b.lo), std::min(a.hi, b.hi));\n\t}\n\texplicit operator bool () const {\n\t\treturn lo <= hi;\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint K; cin >> K;\n\tvector<int> A(K);\n\tfor (int i = 0; i < K; i++) cin >> A[i];\n\tif (*min_element(A.begin(), A.end()) * 2 < *max_element(A.begin(), A.end())) {\n\t\tcout << -1 << '\\n';\n\t\texit(0);\n\t}\n\n\tint L = accumulate(A.begin(), A.end(), 0);\n\tvector<int> res; res.reserve(L);\n\tauto is_good = [&K, &res, &A]() -> bool {\n\t\tvector<bool> seen(K);\n\t\tint N = int(res.size());\n\t\tint st = N;\n\t\twhile (st > 0 && !seen[res[st-1]]) {\n\t\t\t--st;\n\t\t\tseen[res[st]] = true;\n\t\t}\n\n\t\tint en;\n\t\tif (N - st == K) {\n\t\t\ten = N;\n\t\t} else if (st == 0) {\n\t\t\ten = 0;\n\t\t} else {\n\t\t\tint l = st, r = N;\n\t\t\twhile (r - l < K) {\n\t\t\t\tif (l == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seen[res[l-1]]) {\n\t\t\t\t\tseen[res[--r]] = false;\n\t\t\t\t\tif (r < st) return false;\n\t\t\t\t} else {\n\t\t\t\t\tseen[res[--l]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ten = r;\n\t\t}\n\n\t\tseen.assign(K, 0);\n\t\tfor (int i = st; i < N; i++) seen[res[i]] = true;\n\n\t\tauto can_make = [&](interval base, vector<pair<interval, interval>> opts) {\n\t\t\tvector<interval> pref(opts.size()+1);\n\t\t\tpref[0] = base;\n\t\t\tfor (int i = 0; i < int(opts.size()); i++) {\n\t\t\t\tpref[i+1] = pref[i] & opts[i].first;\n\t\t\t}\n\t\t\tinterval suff = base;\n\t\t\tif (pref.back()) return true;\n\t\t\tfor (int i = int(opts.size())-1; i >= 0; i--) {\n\t\t\t\tsuff &= opts[i].second;\n\t\t\t\tif (pref[i] & suff) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t{\n\t\t\tinterval fixed(0, int(1e9));\n\t\t\tfor (int v = 0; v < K; v++) {\n\t\t\t\tif (!seen[v]) {\n\t\t\t\t\tfixed &= interval(A[v], 2*A[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = en; i < N; i++) {\n\t\t\t\tint v = res[i];\n\t\t\t\tfixed &= interval(A[v]+1, 2*A[v]+1);\n\t\t\t}\n\t\t\tvector<pair<interval, interval>> opts; opts.reserve(en-st);\n\t\t\tfor (int i = st; i < en; i++) {\n\t\t\t\tint v = res[i];\n\t\t\t\topts.push_back({{A[v],2*A[v]}, {A[v]+1, 2*A[v]+1}});\n\t\t\t}\n\t\t\tif (can_make(fixed, opts)) return true;\n\t\t}\n\n\t\t{\n\t\t\tinterval fixed(0, int(1e9));\n\t\t\tfor (int v = 0; v < K; v++) {\n\t\t\t\tif (!seen[v]) {\n\t\t\t\t\tfixed &= interval(A[v]+1, 2*A[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<pair<interval, interval>> opts; opts.reserve(N-st);\n\t\t\tfor (int i = st; i < N; i++) {\n\t\t\t\tint v = res[i];\n\t\t\t\topts.push_back({{A[v]+1, 2*A[v]+1}, {A[v]+2, 2*A[v]+2}});\n\t\t\t}\n\t\t\tif (can_make(fixed, opts)) return true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tfor (int curL = 1; curL <= L; curL++) {\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tif (A[i]) {\n\t\t\t\tA[i]--;\n\t\t\t\tres.push_back(i);\n\t\t\t\tif (is_good()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres.pop_back();\n\t\t\t\tA[i]++;\n\t\t\t}\n\t\t}\n\t\tassert(int(res.size()) == curL);\n\t}\n\n\tfor (int z = 0; z < L; z++) {\n\t\tcout << res[z]+1 << \" \\n\"[z+1==L];\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\nconst int N=1005;\nint n,a[N],s,ans[N],top;\nbool construct1(bool flag){\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]-1),v2=max(v2,a[i]-1);\n\tif (v1*2+1<v2||v1<0) return 0;\n\tFor(i,1,n) a[i]--;\n\tif (v1*2>=v2){\n\t\tFor(i,1,n) ans[++top]=i;\n\t}\n\telse{\n\t\tint p=0;\n\t\tFor(i,1,n) if (a[i]==v2) p=i;\n\t\tFor(i,1,p) if (a[i]!=v1) ans[++top]=i;\n\t\tFor(i,1,p) if (a[i]==v1) ans[++top]=i;\n\t\tFor(i,p+1,n) ans[++top]=i;\n\t}\n\tif (flag==1){\n\t\tFor(i,1,n) a[i]++;\n\t\ttop-=n;\n\t}\n\treturn 1;\n}\nbool construct2(int flag){\n\tint v=ans[top+1]=ans[top+1-n];\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]-(i==v)),v2=max(v2,a[i]-(i==v));\n\tif (v1*2+1<v2||v1<0) return 0;\n\tif (v1*2+1==v2){\n\t\tint p1=1e9,p2=0; --a[v];\n\t\tFor(i,top+2-n,top+1){\n\t\t\tif (a[ans[i]]==v1) p1=min(p1,i);\n\t\t\tif (a[ans[i]]==v2) p2=max(p2,i);\n\t\t}\n\t\t++a[v];\n\t\tif (p1<p2) return 0;\n\t}\n\t//cout<<top<<' '<<v<<' '<<ans[top+1]<<endl;\n\tif (!flag){\n\t\t++top; --a[v];\n\t}\n\treturn 1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) s+=a[i];\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]),v2=max(v2,a[i]);\n\tif (v1*2<v2) return puts(\"-1\"),0;\n\tconstruct1(0);\n\tfor (;top!=s;){\n\t\tint v1=(construct1(1)?ans[top+1]:1e9);\n\t\tint v2=(construct2(1)?ans[top+1]:1e9);\n\t\t//cout<<v1<<' '<<v2<<' '<<top<<' '<<a[1]<<' '<<a[2]<<' '<<a[3]<<endl;\n\t\tassert(min(v1,v2)<=n);\n\t\tv1<v2?construct1(0):construct2(0);\n\t}\n\tFor(i,1,s) cout<<ans[i]<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[233];\nvector<int> ans,tx,ty;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(1)\n\t{\n\t\tint minn=114514,maxx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tminn=min(minn,a[i]);\n\t\t\tmaxx=max(maxx,a[i]);\n\t\t}\n\t\tif(maxx==0)break;\n\t\telse if(maxx>2*minn)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttx.clear();ty.clear();\n\t\tint zz=0;\n\t\tfor(int i=n;i>=1;i--)\n\t\t{\n\t\t\tif(a[i]>2*minn-1)tx.push_back(i),zz=2;\n\t\t\telse if(a[i]>minn&&!zz)tx.push_back(i),zz=1;\n\t\t\telse ty.push_back(i);\n\t\t}\n\t\tfor(auto x:tx)ans.push_back(x),a[x]--;\n\t\tfor(auto x:ty)ans.push_back(x),a[x]--;\n\t\tfor(auto x:tx)ans.push_back(x),a[x]--;\n\t}\n\treverse(ans.begin(),ans.end());\n\tfor(auto x:ans)cout<<x<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) {\n\t\t\tlen = pre - i;\n\t\t\tbreak;\n\t\t}\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j && j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    for (int i = 0; i < a[1]; ++i) {\n        vs[i].insert(1);\n    }\n    if (a[1] > 0) {\n        for (int i = 2; i <= k; ++i) {\n            if (a[i] > 0) {\n                --a[i];\n                vs[a[1] - 1].insert(i);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nvector<int> makev(vector<bool>& b) {\n\tvector<int> res;\n\trep(i, k)if (b[i])res.push_back(i);\n\trep(i, k)if (!b[i])res.push_back(i);\n\trep(i, k)if (b[i])res.push_back(i);\n\treturn res;\n}\nvector<int> calc (vector<int>& a) {\n\tvector<int> ans;\n\tint mi = mod;\n\tint ma = 0;\n\trep(i, k) {\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\tif (mi == 0)return {};\n\tvector<int> ts;\n\trep(i, k)if (a[i] == 2 * mi) {\n\t\tts.push_back(i);\n\t}\n\tif (ts.empty()) {\n\t\trep(i, k)ans.push_back(i);\n\t}\n\telse {\n\t\tint las = ts.back();\n\n\t\tbool onm2 = false;\n\t\tvector<bool> t2(k);\n\t\tfor (int id : ts)t2[id] = true;\n\t\trep(i, las) {\n\t\t\tif (t2[i])continue;\n\t\t\tif (ma >= 2 * a[i] - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\tt2[i] = true;\n\t\t\t\tonm2 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\t\tif (onm2) {\n\t\t\trep(i, k)if (a[i] == ma) {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\n\t\trep(i, k)if (t2[i]) {\n\t\t\tans.push_back(i);\n\t\t}\n\t\trep(i, k)if (!t2[i]) {\n\t\t\tans.push_back(i); \n\t\t}\n\t\trep(i, k)if (t2[i]) {\n\t\t\tans.push_back(i); \n\t\t}\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\trep(i, k)rep(j, k) {\n\t\tif (a[j] > 2 * a[i]) {\n\t\t\tcout << -1 << \"\\n\"; return;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\twhile (a[0]>0) {\n\t\tint mi = mod;\n\t\tint ma = 0;\n\t\trep(i, k) {\n\t\t\tmi = min(mi, a[i]);\n\t\t\tma = max(ma, a[i]);\n\t\t}\n\t\tvector<int> ts;\n\t\trep(i, k)if (a[i] == 2 * mi) {\n\t\t\tts.push_back(i);\n\t\t}\n\t\tif (ts.empty()) {\n\t\t\tvector<int> cop = a;\n\t\t\trep(i, k)cop[i]--;\n\t\t\t\n\t\t\tvector<bool> is2(k, false);\n\t\t\tvector<int> nt = makev(is2);\n\t\t\tvector<int> ad = calc(cop);\n\t\t\tvector<int> nnt = nt;\n\t\t\tfor (int id : ad)nnt.push_back(id);\n\n\t\t\tbool ald = false;\n\t\t\trep(i, k) {\n\t\t\t\tif (is2[i])continue;\n\t\t\t\tif (ma >= 2 * a[i] - 1)continue;\n\t\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\t\tif (!ald) {\n\t\t\t\t\t\tald = true;\n\t\t\t\t\t\trep(j, k)if (a[j] == ma) {\n\t\t\t\t\t\t\tif (!is2[j]) {\n\t\t\t\t\t\t\t\tis2[j] = true;\n\t\t\t\t\t\t\t\tcop[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis2[i] = true;\n\t\t\t\t\tcop[i]--;\n\t\t\t\t}\n\t\t\t\tvector<int> cur = makev(is2);\n\t\t\t\tad = calc(cop);\n\t\t\t\tvector<int> ccur = cur;\n\t\t\t\tfor (int id : ad)ccur.push_back(id);\n\t\t\t\tif (nnt > ccur) {\n\t\t\t\t\tswap(nt, cur);\n\t\t\t\t\tswap(nnt, ccur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int id : nt) {\n\t\t\t\tans.push_back(id);\n\t\t\t\ta[id]--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvector<int> nex = calc(a);\n\t\t\tfor (int id : nex) {\n\t\t\t\ta[id]--;\n\t\t\t\tans.push_back(id);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint K;\nint A[111];\n\nbool valid() {\n    int ma = *max_element(A, A+K);\n    if (ma == 0) return true;\n    int mi = *min_element(A, A+K);\n    return mi * 2 >= ma;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &K);\n    REP (i, K) {\n\tint a;\n\tscanf(\"%d\", &a);\n\tA[i] = a;\n    }\n\n    if (!valid()) {\n\tputs(\"-1\");\n\treturn;\n    }\n\n    VI ans;\n    while (1) {\n\tint ma = *max_element(A, A+K);\n\tint mii = min_element(A, A+K) - A;\n\tint mi = A[mii];\n\n\t// rprintf(\"%d\", ans.begin(), ans.end());\n\tif (ma == 0) break;\n\n\tif (A[0] >= 2) {\n\t    REP (i, K) A[i]--;\n\t    A[0]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tans.push_back(0);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t\tA[0]++;\n\t    }\n\t}\n\n\tif (ma == mi) {\n\t    REP (i, K) A[i]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t    }\n\t}\n\t\t\n\tint last_max = 0;\n\tREP (i, K) if (A[i] == ma) last_max = i;\n\n\tVI once, twice;\n\n\tREP (i, K) {\n\t    if (A[i] == ma) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else if (A[i] == mi) {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    } else if (i < mii || i < last_max) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    }\n\t}\n\n\n\t//rprintf(\"%d.\", A, A+K);\n\tassert(valid());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n\tans.insert(ans.end(), once.begin(), once.end());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n    }\n\n    EACH (e, ans) (*e)++;\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#define RI register int\n#define CI const int&\n#define pb push_back\nusing namespace std;\nconst int N=1005,K=105;\nusing namespace std;\nint k,n,a[K],b[K],ans[N]; vector <int> q[K]; bool vis[K];\ninline bool cmp(vector <int> A,vector <int> B)\n{\n\tfor (RI i=0;i<A.size()&&i<B.size();++i)\n\tif (A[i]!=B[i]) return A[i]<B[i]; return A.size()<B.size();\n}\ninline void fail(vector <int>& v)\n{\n\tfor (RI i=1;i<=k;++i) v.pb(k+1);\n}\ninline void solve(CI st,CI num,vector <int>& res)\n{\n\tres.clear(); memset(vis,0,sizeof(vis)); memcpy(b,a,sizeof(b));\n\tRI i; for (i=1;i+num<=k;++i) vis[ans[st-i]]=1;\n\tfor (i=1;i<=k;++i) if (!vis[i])\n\t{\n\t\tif (b[i]) --b[i]; else return fail(res);\n\t}\n\tint x=*max_element(b+1,b+k+1),y=*min_element(b+1,b+k+1);\n\tif (x>2*y+1) return fail(res); vector <int> A,B,C; //A:b[i]=x; B:b[i]=y; C:otherwise\n\tif (x==2*y+1)\n\t{\n\t\tbool exist=0; for (i=1;i+num<=k;++i) \n\t\tif (b[ans[st-i]]==x) exist=1; else if (b[ans[st-i]]==y&&exist) return fail(res);\n\t\tfor (i=k;i;--i) if (!vis[i])\n\t\t{\n\t\t\tif (b[i]==x) A.pb(i); else if (b[i]==y) B.pb(i); else C.pb(i);\n\t\t}\n\t} else for (i=k;i;--i) if (!vis[i]) C.pb(i);\n\tfor (i=1;i<=num;++i) if (A.size())\n\t{\n\t\tint x=C.size()?C.back():k+1; if (A.back()<x) res.pb(A.back()),A.pop_back();\n\t\telse res.pb(x),C.pop_back();\n\t} else\n\t{\n\t\tint x=B.size()?B.back():k+1,y=C.size()?C.back():k+1;\n\t\tif (x<y) res.pb(x),B.pop_back(); else res.pb(y),C.pop_back();\n\t}\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&k),i=1;i<=k;++i) scanf(\"%d\",&a[i]),n+=a[i];\n\tif (*max_element(a+1,a+k+1)>2*(*min_element(a+1,a+k+1))) return puts(\"-1\"),0;\n\tint num; for (i=1;i<=n;i+=q[num].size())\n\t{\n\t\tif (i==1) solve(i,k,q[num=1]); else\n\t\t{\n\t\t\tfor (j=1;j<=k;++j) solve(i,j,q[j]); num=1;\n\t\t\tfor (j=2;j<=k;++j) if (cmp(q[j],q[num])) num=j;\n\t\t}\n\t\tfor (j=0;j<q[num].size();++j) ans[i+j]=q[num][j],--a[q[num][j]];\n\t}\n\tfor (i=1;i<=n;++i) printf(\"%d \",ans[i]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nbool possiblePrefix(vector<pair<int, int>> A, vector<int> prefix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n  for (int x : prefix) A[where[x]].first++;\n\n  sort(A.begin(), A.end());\n  if (A[0].first * 2 < A.back().first) return false;\n\n  vector<bool> isOne(K, false), isTwo(K, false);\n  int min = A[0].first, nTwos = 0;\n  for (int i = 0; i < K; ++i) {\n    if (min * 2 == A[i].first) {\n      isTwo[A[i].second] = true;\n      nTwos++;\n    }\n    if (min == A[i].first) isOne[A[i].second] = true;\n  }\n  reverse(prefix.begin(), prefix.end());\n  while (prefix.size() && !isOne[prefix.back()]) {\n    if (isTwo[prefix.back()]) nTwos--;\n    prefix.pop_back();\n  }\n  if (!nTwos) return true;\n  for (int x : prefix)\n    if (isOne[x]) return false;\n  return true;\n}\n\nbool possible(vector<pair<int, int>> A, const vector<int>& suffix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n  for (int i = 0; i < K; ++i) {\n    if (possiblePrefix(A, {})) return true;\n    int j = where[suffix[i]];\n    if (A[j].first == 0) break;\n    A[j].first--;\n  }\n  return false;\n}\n\nbool possibleFinish(vector<pair<int, int>> A, vector<int>& B, int coveredUpTo) {\n  int K = A.size();\n  vector<bool> seen(K, false);\n  vector<int> prefix;\n  if (B.size()) {\n    for (int32_t i = B.size() - 1; i >= 0; --i) {\n      if (seen[B[i]]) {\n        if (coveredUpTo <= i) return false;\n        break;\n      }\n      prefix.push_back(B[i]);\n      seen[B[i]] = true;\n    }\n  }\n  reverse(prefix.begin(), prefix.end());\n  if ((int)prefix.size() == K) return possible(A, prefix);\n  while (coveredUpTo + prefix.size() >= B.size()) {\n    if (possiblePrefix(A, prefix)) return true;\n    if (prefix.size()) {\n      prefix.erase(prefix.begin());\n    } else {\n      break;\n    }\n  }\n  return false;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n  vector<int> B;\n\n  if (!possibleFinish(A, B, 0)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int coveredUpTo = 0;\n  while (true) {\n    int tot = 0;\n    for (auto& p : A) tot += p.first;\n    if (tot == 0) break;\n\n    vector<int> where(K);\n    for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n    int x = -1;\n    for (int i = 0; i < K; ++i) {\n      if (A[where[i]].first == 0) continue;\n\n      A[where[i]].first--;\n      B.push_back(i);\n      if (possibleFinish(A, B, coveredUpTo)) {\n        x = i;\n        break;\n      }\n      B.pop_back();\n      A[where[i]].first++;\n    }\n    assert(x != -1);\n    if (B.size() >= K) {\n      vector<int> p(B.end() - K, B.end());\n      sort(p.begin(), p.end());\n      bool isPerm = true;\n      for (int i = 0; i < K; ++i) isPerm &= p[i] == i;\n      if (isPerm) {\n        assert(coveredUpTo + K >= B.size());\n        coveredUpTo = B.size();\n      }\n    }\n  }\n\n  assert(coveredUpTo == B.size());\n  for (int x : B) cout << x + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) cin>>A[i];\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\t\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\t\n\t\tvector<pair<int,int>> C;\n\t\t\n\t\t\n\t\tif(x==2*y) {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tC.push_back({i,1});\n\t\t\t\t}\n\t\t\t\telse if(A[i]>y) {\n\t\t\t\t\tC.push_back({i,0});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(C.size() && C.back().second==0) C.pop_back();\n\t\t\tint first[101]={};\n\t\t\tFORR(c,C) {\n\t\t\t\tfirst[c.first]=1;\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t\tFOR(i,K) if(first[i]==0) V.push_back(i), A[i]--;\n\t\t\tFORR(c,C) {\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t}\n\t\telse if(x==y) {\n\t\t\tFOR(i,K) V.push_back(i), A[i]--;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tV.push_back(i);\n\t\t\t\t\tA[i]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j,K) V.push_back((i+j)%K), A[(i+j)%K]--;\n\t\t}\n\t}\n\t\n\tFORR(v,V) cout<<(v+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,T y){\n\tif (y<x)\n\t\tx=y;\n}\n/*\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\n*/\nconst int N=1005;\nint k,n;\nint a[N],baka[N],b[N];\nint check_permutation(int L,int R){\n\tif (R>n||L<1||R-L+1!=k)\n\t\treturn 0;\n\tstatic int vis[N],Time=0;\n\tTime++;\n\tFor(i,L,R)\n\t\tif (vis[b[i]]==Time)\n\t\t\treturn 0;\n\t\telse\n\t\t\tvis[b[i]]=Time;\n\treturn 1;\n}\nint checkpos(int *pos){\n\tint mi=n,mx=-1;\n\tFor(i,1,k)\n\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\tif (mi*2+1<mx)\n\t\treturn 0;\n\tif (mi*2>=mx)\n\t\treturn 1;\n\t//mi * 2 + 1 == mx\n\tint mip=n+1,mxp=-1;\n\tFor(i,1,k)\n\t\tif (a[i]==mi)\n\t\t\tckmin(mip,pos[i]);\n\t\telse if (a[i]==mx)\n\t\t\tckmax(mxp,pos[i]);\n\treturn mxp<=mip;\n}\nint check(int p,int las){\n\tstatic int pos[N];\n\tFor(i,1,k)\n\t\tpos[i]=p+1;\n\tif (las==p)\n\t\treturn checkpos(pos);\n\tint cut=p;\n\t{\n\t\tvi vis(k+1,0);\n\t\tvis[b[cut]]=1;\n\t\twhile (cut-1>0&&!vis[b[cut-1]])\n\t\t\tcut--,vis[b[cut]]=1;\n\t}\n\tif (cut>las+1)\n\t\treturn 0;\n\tFor(i,cut,p)\n\t\tpos[b[i]]=i;\n\tFor(i,1,k)\n\t\tif (pos[i]==p+1)\n\t\t\ta[i]--;\n\tif (checkpos(pos))\n\t\treturn 1;\n\tFor(i,cut,las){\n\t\ta[b[i]]--;\n\t\tpos[b[i]]=p+1;\n\t\tif (checkpos(pos))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tk=read(),n=0;\n\tFor(i,1,k)\n\t\ta[i]=read(),n+=a[i];\n\t{\n\t\tint mi=n,mx=0;\n\t\tFor(i,1,k)\n\t\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\t\tif (mi*2<mx)\n\t\t\treturn puts(\"-1\"),0;\n\t}\n\tmemset(b,-1,sizeof b);\n\tint las=0;\n\tFor(i,1,n){\n\t\tFor(j,1,k)\n\t\t\tif (a[j]){\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\tbaka[t]=a[t];\n\t\t\t\ta[j]--,b[i]=j;\n\t\t\t\tint nextlas=check_permutation(i-k+1,i)?i:las;\n\t\t\t\tif (check(i,nextlas)){\n\t\t\t\t\tlas=nextlas;\n\t\t\t\t\tFor(t,1,k)\n\t\t\t\t\t\ta[t]=baka[t];\n\t\t\t\t\ta[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb[i]=-1;\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\ta[t]=baka[t];\n\t\t\t}\n\t}\n\tFor(i,1,n)\n\t\tprintf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops;\nUL P2[100];\nvector<UL> buf;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 1000; rep(i, K) loops = min(loops, P[i]);\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\tvector<UL> ans;\n\trep(l, loops) {\n\t\tvector<UL> S, T;\n\t\tUL p = 0;\n\t\trep(i, K) {\n\t\t\tif (P2[i] == loops - l) {\n\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\telse T.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\tfor (; p < K; p++) {\n\t\t\tT.push_back(p);\n\t\t}\n\t\tconcat(ans, S);\n\t\tconcat(ans, T);\n\t\tconcat(ans, S);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  vector<int> nie(n);\n  int ilnie = 0;\n  while(1){\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    debug(ilnie);\n    \n    vector<int> zle(n);\n    R(i,n){\n      if(t[i] * 2 < ma){\n        zle[i] = 1;\n      }\n    }\n    int naj = -1;\n    R(i,min(SZ(res),n)){\n      if(zle[res[SZ(res) - i - 1]]){\n        naj = i;\n        zle[res[SZ(res) - i - 1]] = 0;\n      }\n    }\n    R(i,naj + 1){\n      zle[res[SZ(res) - i - 1]] = 1;\n    }\n    \n    \n    if(ma == 0)break;\n    R(i,n)if(!nie[i] && t[i] * 2 > ma && t[i] && !zle[i]){\n      debug(ma,t[i],i);\n      res.PB(i);\n      t[i]--;\n      nie[i] = 1;\n      ilnie++;\n      goto ok;\n    }\n    debug(res);\n    assert(0);\n    ok:;\n    if(SZ(res) >= n){\n      vector<int> cz(n);\n      bool nope = 0;\n      R(i,n){\n        if(cz[res[SZ(res) - i - 1]]){\n          nope = 1;\n          break;\n        }\n        cz[res[SZ(res) - i - 1]] = 1;\n      }\n      if(!nope){\n        ilnie = 0;\n        R(i,n)nie[i] = 0;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 110;\nconst int maxs = 1010;\n\ntypedef pair<int,int> seg;\n\nseg operator+(const seg &s1, const seg &s2) {\n\treturn seg(max(s1.first, s2.first), min(s1.second, s2.second));\n}\n\nint n, sum, lastp;\nint ans[maxs], a[maxn], cur_a[maxn], vis[maxn], _vis[maxn], ok[maxn];\nseg pre[maxn], suf[maxn], s[maxn];\n\n// 是否第一步必须 -1\nseg calseg(int x, int ty) {\n\tif (!ty) {\n\t\treturn seg(x, 2 * x);\n\t} else {\n\t\treturn seg(x, 2 * x - 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\tfor (int i = 1; i <= sum; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tvis[j] = 0;\n\t\t\tcur_a[j] = a[j];\n\t\t\tok[j] = 0;\n\t\t}\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (i - j <= lastp + 1) {\n\t\t\t\tfor (int k = 1; k <= n; k++) s[k] = calseg(cur_a[k], vis[k]);\n\t\t\t\tpre[0] = suf[n+1] = seg(0, 0x3f3f3f3f);\n\t\t\t\tfor (int k = 1; k <= n; k++) pre[k] = pre[k-1] + s[k];\n\t\t\t\tfor (int k = n; k >= 1; k--) suf[k] = suf[k+1] + s[k];\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tseg t = pre[k-1] + suf[k+1] + calseg(cur_a[k], 1);\n\t\t\t\t\tif (!vis[k] && t.first <= t.second) {\n\t\t\t\t\t\tok[k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < i-1) {\n\t\t\t\tif (vis[ans[i - 1 - j]]) break;\n\t\t\t\tvis[ans[i - 1 - j]] = 1;\n\t\t\t\t++ cur_a[ans[i - 1 - j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tvis[j] = 0;\n\t\t\tcur_a[j] = a[j];\n\t\t}\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = 1; k <= n; k++) _vis[k] = 0;\n\t\t\tint t = i-j-1;\n\t\t\twhile (t > 0 && !vis[ans[t]] && !_vis[ans[t]]) {\n\t\t\t\t_vis[ans[t]] = 1;\n\t\t\t\t-- t;\n\t\t\t}\n\t\t\tfor (int k = 1; k <= n; k++) s[k] = calseg(cur_a[k], vis[k] || !_vis[k]);\n\t\t\tseg total = seg(0, 0x3f3f3f3f);\n\t\t\tfor (int k = 1; k <= n; k++) total = total + s[k];\n\t\t\tif (total.first <= total.second) {\n\t\t\t\tint mn = 0x3f3f3f3f;\n\t\t\t\tfor (int k = n; k >= 1; k--) if (!vis[k] && !_vis[k] && cur_a[k] * 2 - 1 >= total.first) mn = min(mn, k);\n\t\t\t\tfor (int x = t+1; x <= i-j-1; x++) {\n\t\t\t\t\tif (x > lastp+1) break;\n\t\t\t\t\tif (mn < 0x3f3f3f3f) ok[mn] = 1;\n\t\t\t\t\t_vis[ans[x]] = 0; if (2 * cur_a[ans[x]] - 1 < total.first) break;\n\t\t\t\t\tmn = min(mn, ans[x]);\n\t\t\t\t}\n\t\t\t} \n\t\t\tif (j < i-1) {\n\t\t\t\tif (vis[ans[i - 1 - j]]) break;\n\t\t\t\tvis[ans[i - 1 - j]] = 1;\n\t\t\t\t++ cur_a[ans[i - 1 - j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (ok[j]) {\n\t\t\t\tans[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t-- a[ans[i]];\n\t\tif (!ans[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) vis[j] = 0;\n\t\tif (i >= n) {\n\t\t\tint flag = 1;\n\t\t\tfor (int j = i; j >= i-n+1; j--) {\n\t\t\t\tif (vis[ans[j]]) {\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvis[ans[j]] = 1;\n\t\t\t}\n\t\t\tif (flag) lastp = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sum; i++) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 1005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nint k;\nint a[maxn];\nint b[maxn];\nint tp[maxn];\nint s = 0;\nint x[maxn];\nint hv[105];\nint ltp[maxn];\nint check(int pl) {\n\tfor (int i = 1; i <= k; i++)\n\t\tb[i] = a[i];\n\tfor (int i = 1; i <= pl; i++) {\n\t\tb[x[i]]--;\n\t\tif (b[x[i]] < 0) return 0;\n\t}\n\tfor (int i = 1; i < pl; i++)\n\t\tif (x[i] == x[pl] && !tp[i]) return 0;\n/*\tcout << \"CUR_CHECK\" << endl;\n\tfor (int i = 1; i <= pl; i++)\n\t\tcout << x[i] << ' ';\n\tcout << endl;\n*/\t\n\t// update tp\n\tfor (int i = 1; i <= pl; i++)\n\t\tltp[i] = tp[i];\n\t// before return 0 : \n\tif (pl >= k) {\n\t\tmemset(hv, 0, sizeof(hv));\n\t\tint fl = 1;\n\t\tfor (int i = pl; i >= pl - k + 1; i--)\n\t\t\tif (hv[x[i]]) fl = 0;\n\t\t\telse hv[x[i]] = 1;\n\t\tif (fl)\n\t\t\tfor (int i = pl; i >= pl - k + 1; i--)\n\t\t\t\ttp[i] = 1;\n\t}\n\tmemset(hv, 0, sizeof(hv));\n\tfor (int i = pl; i >= 1; i--)\n\t\tif (hv[x[i]]) break;\n\t\telse hv[x[i]] = i;\n\tint nd[105] = {0};\n\tfor (int i = 1; i <= k; i++) {\n\t\tint cr = b[i];\n\t\tint ud[2] = {0, 0};\n\t\tfor (int t = 1; t <= k; t++)\n\t\t\tif (hv[t] > hv[i]) chkmax(nd[t], cr / 2);\n\t\t\telse chkmax(nd[t], (cr + 1) / 2);\n\t}\n\tint res = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (b[i] < nd[i]) res = 0;//, cout << \"!!!\" << i << ' ' << b[i] << ' ' << nd[i] << endl;\n\t}\n\tif (!res) {\n\t\tfor (int i = 1; i <= pl; i++)\n\t\t\ttp[i] = ltp[i];\n\t\treturn 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tcin >> k;\n\tfor (int i = 1; i <= k; i++)\n\t\tcin >> a[i], s += a[i];\n\tif (!check(0)) cout << -1 << endl;\n\telse {\n\t\tfor (int p = 1; p <= s; p++) {\n\t\t\tfor (int i = 1; i <= k; i++) {\n\t\t\t\tx[p] = i;\n\t\t\t\tif (!check(p)) continue;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tfor (int p = 1; p <= s; p++)\n\t\t\tcout << x[p] << ' ';\n\t\tcout << endl;\n\t}\n\t\t\t \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nint n, m;\nvi a;\n\nbool f(vi s) {\n  int w = sz(s);\n  vi c = a;\n  vi e(m);\n  int li = 0, pre = 0;\n  rep(i,w) {\n    c[s[i]]--;\n    e[s[i]]++;\n    if (e[s[i]] == 2) {\n      while (e[s[i]] > 1) {\n        e[s[li]]--;\n        ++li;\n      }\n    }\n    if (pre < li) return false;\n    if (i-li == m-1) pre = i+1;\n  }\n  rep(i,m) if (c[i] < 0) return false;\n  vi d(m);\n  srep(i,li,pre) d[s[i]]++;\n  // cerr<<c<<endl;\n  // cerr<<e<<endl;\n  // cerr<<d<<endl;\n\n  {\n    int l = INF, r = 0;\n    rep(i,m) {\n      int na = c[i];\n      if (!e[i]) --na;\n      maxs(r,na);\n      if (d[i]) ++na;\n      mins(l,na);\n    }\n    if (l*2 >= r) return true;\n  }\n\n  {\n    int l = INF, r = 0;\n    rep(i,m) {\n      int na = c[i];\n      na--;\n      int naa = na;\n      if (d[i]) ++naa;\n      mins(l,naa);\n      if (!e[i]) --na;\n      maxs(r,na);\n    }\n    if (l*2 >= r) return true;\n  }\n\n  // cerr<<\"a\"<<\" \"<<s<<endl;\n\n  return false;\n}\n\nint main() {\n  scanf(\"%d\",&m);\n  a = vi(m);\n  cin>>a;\n  n = suma(a);\n  vi ans;\n  if (!f(ans)) dame;\n  while (sz(ans) < n) {\n    ans.pb(0);\n    while (!f(ans)) ans.back()++;\n    // cerr<<ans<<endl;\n  }\n  rep(i,n) ans[i]++;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n        rep(k,best_js_size) {\n        }\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    bool flag2 = false;\n    int ans_size = ans.size();\n    if (ans_size >= K-1) {\n        set<int> s_next;\n        rep1(i,K) s_next.insert(i);\n        rep1(i,K-1) {\n            auto ite = s_next.find(ans[ans_size-i]);\n            if (ite != s_next.end()) {\n                s_next.erase(ans[ans_size-i]);\n            }\n        }\n        if (s_next.size() == 1) {\n            int best_next = *s_next.begin();\n            if (best_next < tempv[best_j][0]) {\n                bool flag3 = true;\n                rep(i,K) {\n                    if ((a[i] - 1) > (a[best_next-1] - 1) * 2) {\n                        flag3 = false;\n                    }\n                }\n                if (flag3) {\n                    ans.push_back(best_next);\n                    a[best_next]--;\n                    flag2 = true;\n                }\n            }\n        }\n    }\n\n    if (!flag2) {\n        int best_j_size = tempv[best_j].size();\n        rep(i,best_j_size) {\n            ans.push_back(tempv[best_j][i]);\n        }\n\n        rep(i,K) a[i] -= now[best_j][i];\n    }\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100,M=1000;\n\nint n,a[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n}\nint mx,mn;\n\nvoid Get_mxn(){\n  mx=0;mn=M;\n  for (int i=1;i<=n;++i) mx=max(mx,a[i]),mn=min(mn,a[i]);\n}\n\nint last[N+9],tmp[N+9];\nint ta[N+9],tb[N+9],tc[N+9],cta,ctb,ctc;\n\nbool Get_tmp(int m){\n  int flag=1;\n  for (int i=1;i<=m;++i) --a[last[i]],tmp[i]=0;\n  Get_mxn();\n  if (mn<<1>=mx){\n\tfor (int i=1;i<=m;++i) tmp[i]=last[i];\n\tsort(tmp+1,tmp+m+1);\n  }else if (mn*2+1==mx){\n\tint flagmn=0,flagmx=0;\n\tcta=ctb=ctc=0;\n\tfor (int i=m+1;i<=n;++i)\n\t  if (a[last[i]]==mn) flagmn=1;\n      else if (a[last[i]]==mx&&flagmn) flagmx=1;\n\tfor (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mx) ta[++cta]=last[i],flagmx=1;\n    sort(ta+1,ta+cta+1);\n    if (flagmn&&flagmx) flag=0;\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mn) tc[++ctc]=last[i];\n    sort(tc+1,tc+ctc+1);\n\tfor (int i=1;i<=ctc;++i) ta[++cta]=tc[i];\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]<mx&&a[last[i]]>mn) tb[++ctb]=last[i];\n    sort(tb+1,tb+ctb+1);\n    merge(ta+1,ta+cta+1,tb+1,tb+ctb+1,tmp+1);\n  }else flag=0;\n  for (int i=1;i<=m;++i) ++a[last[i]];\n  return flag;\n}\n\nint now[N+9],cn;\n\nbool Check_cmp(){\n  for (int i=1;2333;++i)\n\tif (tmp[i]^now[i]) return tmp[i]<now[i];\n}\n\nint ans[N*M+9],ca;\n\nvoid Get_ans(){\n  Get_mxn();\n  if (mn<<1<mx) return;\n  for (int i=1;i<=n;++i) ca+=a[i],last[i]=i;\n  Get_tmp(n);\n  for (int i=1;i<=n;++i) --a[ans[i]=last[i]=tmp[i]],tmp[i]=0;\n  for (int i=n+1;i<=ca;){\n\tfor (int j=1;j<=n;++j) now[j]=0;\n\tnow[1]=n+1;cn=0;\n\tfor (int j=1;j<=n;++j){\n\t  if (i+j-1>ca) continue;\n\t  if (!Get_tmp(j)) continue;\n\t  if (Check_cmp()){\n\t\tcn=j;\n\t\tfor (int k=1;k<=j;++k) now[k]=tmp[k];\n\t  }\n\t}\n\tfor (int j=1;j<=cn;++j) --a[ans[i++]=now[j]];\n    for (int j=1;j<=n;++j) last[j]=ans[i-n+j-1];\n  }\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  if (!ca) puts(\"-1\");\n  else{\n\tfor (int i=1;i<=ca;++i)\n\t  printf(\"%d \",ans[i]);\n    puts(\"\");\n  }\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) len = pre - i;\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n        rep(k,best_js_size) {\n        }\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    bool flag2 = false;\n    int ans_size = ans.size();\n    if (ans_size >= K-1) {\n        set<int> s_next;\n        rep1(i,K) s_next.insert(i);\n        rep1(i,K-1) {\n            auto ite = s_next.find(ans[ans_size-i]);\n            if (ite != s_next.end()) {\n                s_next.erase(ans[ans_size-i]);\n            }\n        }\n        if (s_next.size() == 1) {\n            int best_next = *s_next.begin();\n            if (best_next < tempv[best_j][0]) {\n                bool flag3 = true;\n                rep(i,K) {\n                    if (a[i] > (a[best_next-1] - 1) * 2) {\n                        flag3 = false;\n                    }\n                }\n                if (flag3) {\n                    ans.push_back(best_next);\n                    a[best_next]--;\n                    flag2 = true;\n                }\n            }\n        }\n    }\n\n    if (!flag2) {\n        int best_j_size = tempv[best_j].size();\n        rep(i,best_j_size) {\n            ans.push_back(tempv[best_j][i]);\n        }\n\n        rep(i,K) a[i] -= now[best_j][i];\n    }\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,j,cnt,lst,nxt,fi,a[1111],k[1111],st[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  for (j=cnt; j>=1; j--) {\n    lst=0;\n    for (i=1; i<=n; i++) if (a[i]==j) lst=i;\n    if (lst==0) {\n      if (j==1) {\n        for (i=1; i<=n; i++) printf(\"%d \",i);\n      } else {\n        nxt=0;\n        for (i=1; i<=n; i++) if (a[i]==j-1) nxt=i;\n        if (nxt) {\n          for (i=1; i<=nxt; i++) if (a[i]>1) { fi=i; break; }\n        } else fi=1;\n        for (i=1; i<=fi; i++) if (a[i]>0) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]<=0) printf(\"%d \",i);\n        for (; i<=n; i++) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n      }\n    } else {\n      for (i=1; i<=lst; i++) if (a[i]>0) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]<=0) printf(\"%d \",i);\n      for (; i<=n; i++) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[109];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint k;cin>>k;\n\trepA(i,1,k) cin>>a[i];\n\tint x = 1009,y=0;\n\trepA(i,1,k) x = min(x,a[i]),y=max(y,a[i]);\n\tif(y>2*x){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tvi ans;\n\trep(qq,x){\n\t\tvi cur;\n\t\tbool fg[109];\n\t\tfill(fg);\n\t\tint gg = 1;\n\t\tif(a[1]==(x-qq)+1){\n\t\t\trepA(i,1,k) if(a[i]>=2*(x-qq)-1) {\n\t\t\t\tgg=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(a[1]==(x-qq)){\n\t\t\trepA(i,1,k) if(a[i]>=2*(x-qq)) {\n\t\t\t\tgg=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t\trepA(i,1,k){\n\t\t\tif(i<=gg&&a[i]>x-qq){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i]=1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t\telse if(a[i]==2*(x-qq)){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i] = 1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k) if(!fg[i]) a[i]--,ans.pb(i);\n\t\ttrav(i,cur) ans.pb(i);\n\t}\n\ttrav(i,ans) cout<<i<<' ';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else if (flag1) {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n            else {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint K;\n\tcin>>K;\n\tvector<int> V(K);\n\tfor(auto &a: V)\n\t\tcin>>a;\n\tint N = 0;\n\tfor(auto a: V)\n\t\tN+=a;\n\tvector<int> A;\n\twhile(A.size()<N)\n\t{\n\t\t\n\t\tint m1 = N;\n\t\tint m2 = 0;\n\t\tfor(auto a: V)\n\t\t{\n\t\t\tm1 = min(m1,a);\n\t\t\tm2 = max(m2,a);\n\t\t}\n\t\tif(m1*2<m2)\n\t\t{\n\t\t\tV.resize(1);\n\t\t\tV[0]=-2;\n\t\t\tbreak;\n\t\t}\n\t\t//cerr<<m1<<\" \"<<m2<<endl;\n\t\tvector<int> side, center, opt;\n\t\tif(m2 == m1*2)\n\t\t{\n\t\t\tfor(int i=0; i<K; ++i)\n\t\t\t{\n\t\t\t\tif(m2 == V[i])\n\t\t\t\t\tside.push_back(i);\n\t\t\t\telse if(m1 == V[i])\n\t\t\t\t\tcenter.push_back(i);\n\t\t\t\telse\n\t\t\t\t\topt.push_back(i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0; i<K; ++i)\n\t\t\t\topt.push_back(i);\n\t\t}\n\t\tsort(center.begin(),center.end());\n\t\tsort(opt.begin(),opt.end());\n\t\tsort(side.begin(),side.end());\n\t\tint s1 = 0, o1 = 0, c1 = 0;\n\t\twhile(s1<side.size())\n\t\t{\n\t\t\tif(o1<opt.size() && opt[o1]<side[s1])\n\t\t\t{\n\t\t\t\tA.push_back(opt[o1]);\n\t\t\t\t--V[opt[o1++]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA.push_back(side[s1]);\n\t\t\t\t--V[side[s1++]];\n\t\t\t}\n\t\t}\n\t\twhile(c1<center.size())\n\t\t{\n\t\t\tif(o1<opt.size() && opt[o1]<center[c1])\n\t\t\t{\n\t\t\t\tA.push_back(opt[o1]);\n\t\t\t\t--V[opt[o1++]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA.push_back(center[c1]);\n\t\t\t\t--V[center[c1++]];\n\t\t\t}\n\t\t}\n\t\twhile(o1<opt.size())\n\t\t{\n\t\t\tA.push_back(opt[o1]);\n\t\t\t--V[opt[o1++]];\n\t\t}\n\t\to1 = 0;\n\t\ts1 = 0;\n\t\twhile(s1<side.size())\n\t\t{\n\t\t\tif(o1<opt.size() && (center.size()==0 || opt[o1]<center[0]) && opt[o1]<side[s1])\n\t\t\t{\n\t\t\t\tA.push_back(opt[o1]);\n\t\t\t\t--V[opt[o1++]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA.push_back(side[s1]);\n\t\t\t\t--V[side[s1++]];\n\t\t\t}\n\t\t}\n\t\t\n\n\n\n\t}\n\tfor(auto a: A)\n\t\tcout<<a+1<<\" \";\n\tcout<<endl;\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << (x) << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f1, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f1 = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f1 = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f1;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 1e3 + 7;\nint n, m, s, a[N], p[N], q[N], ans[N];\n\nvoid work(int k) {\n\tbool ok1 = 1, ok2 = 0;\n\tfor (int i = 1; i <= k; i++) --a[p[i]];\n\tint mn = *min_element(a + 1, a + n + 1);\n\tint mx = *max_element(a + 1, a + n + 1);\n\tif (mn * 2 >= mx) {\n\t\tok2 = 1;\n\t\tcopy(p + 1, p + k + 1, q + 1);\n\t\tsort(q + 1, q + k + 1);\n\t} else if (mn * 2 + 1 == mx) {\n\t\tint k1 = 0, k2 = 0;\n\t\tstatic int f1[N], f2[N];\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\t((a[p[i]] == mn || a[p[i]] == mx) ? f1[++k1] : f2[++k2]) = p[i];\n\t\tsort(f1 + 1, f1 + k1 + 1, [&](int i, int j) {\n\t\t\tif ((a[i] == mn) == (a[j] == mn)) return i < j;\n\t\t\treturn (a[i] == mn) < (a[j] == mn);\n\t\t});\n\t\tsort(f2 + 1, f2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2)\n\t\t\t\tq[i] = f1[x1] < f2[x2] ? f1[x1++] : f2[x2++];\n\t\t\telse q[i] = x1 <= k1 ? f1[x1++] : f2[x2++];\n\t\tok2 = 1;\n\t\tfor (int i = k + 1; i <= n; i++)\n\t\t\tif (a[p[i]] == mn) ok2 = 0;\n\t\tok2 |= !x1 || (a[f1[1]] == mx);\n\t}\n\tfor (int i = 1; i <= k; i++) ++a[p[i]];\n\tif (!ok1 || !ok2) q[1] = 0;\n}\n\ninline bool pd(int *a, int *b) {\n\tint p = 1;\n\twhile (a[p] == b[p]) ++p;\n\treturn a[p] < b[p];\n}\n\nint main() {\n\trd(n), rda(a, n);\n\tfor (int i = 1; i <= n; i++) s += a[i];\n\tint mn = *min_element(a + 1, a + n + 1);\n\tint mx = *max_element(a + 1, a + n + 1);\n\tif (mn * 2 < mx) return print(-1), 0;\n\tiota(p + 1, p + n + 1, 1), work(n);\n\tfor (int i = 1; i <= n; i++) --a[q[i]], ans[++m] = p[i] = q[i];\n\twhile (m != s) {\n\t\tstatic int t[N];\n\t\tmemset(t, 0, sizeof(t)), t[1] = n + 1;\n\t\tint k = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (q[1] && pd(q, t))\n\t\t\t\tk = i, copy(q + 1, q + i + 1, t + 1);\n\t\t}\n\t\tfor (int i = 1; i + k <= n; i++) p[i] = p[i+k];\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tans[++m] = p[n-k+i] = t[i], --a[t[i]];\n\t}\n\tprinta(ans, m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt n;\nvector<Int> a;\nvector<Int> ans;\nInt mx, mn;\nset<int> maxs, mins;\nbool ok[1100];\n\nInt min_initial(Int from, Int to)\n{\n    auto aa = a;\n    vector<int> used(n, 0);\n    for (int i = from; i < to; i++) {\n        if (used[ans[i]])\n            return n;\n        used[ans[i]] = 1;\n        aa[ans[i]]++;\n    }\n\n    Int tmpmx = *max_element(aa.begin(), aa.end());\n    Int tmpmn = *min_element(aa.begin(), aa.end());\n    if (tmpmn * 2 < tmpmx)\n        return n;\n    if (tmpmn * 2 > tmpmx) {\n        for (int i = 0; i < n; i++)\n            if (!used[i])\n                return i;\n        return n;\n    }\n    Int max_cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == tmpmx)\n            max_cnt++;\n    }\n\n    for (int i = from; i < to; i++) {\n        if (aa[ans[i]] == tmpmx)\n            max_cnt--;\n        if (aa[ans[i]] == tmpmn) {\n            if (max_cnt != 0)\n                return n;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == 0)\n            continue;\n        if (used[i])\n            continue;\n        if (max_cnt == 0 && !used[i])\n            return i;\n        if (max_cnt > 0 && aa[i] != tmpmn && !used[i])\n            return i;\n    }\n    return ans[from];\n}\n\nint main()\n{\n    Int as = 0;\n    cin >> n;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        as += a[i];\n    }\n\n    Int mx = *max_element(a.begin(), a.end());\n    Int mn = *max_element(a.begin(), a.end());\n\n    if (mn * 2 < mx) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < as; i++) {\n        Int nxt = n;\n        for (int j = max(0ll, i - n + 1); j <= i; j++) {\n            nxt = min(nxt, min_initial(j, i));\n            if (!ok[j])\n                break;\n        }\n\n        a[nxt]--;\n        ans.push_back(nxt);\n        if (ans.size() >= n) {\n            set<int> hoge;\n            for (int j = 0; j < n; j++) {\n                hoge.insert(ans[ans.size() - 1 - j]);\n            }\n            if (hoge.size() == n) {\n                for (int j = 0; j < n; j++)\n                    ok[ans.size() - 1 - j] = true;\n            }\n        }\n    }\n\n    for (auto elem : ans)\n        cout << elem + 1 << \" \";\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops, loopsm;\nUL P2[100];\nvector<UL> buf;\nvector<vector<UL>> ans;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloops = (loops + 1) / 2;\n\tloopsm = 1000; rep(i, K) loopsm = min(loopsm, P[i]);\n\n\tfor (UL L = loops; L <= loopsm; L++) {\n\t\trep(i, K) P2[i] = P[i] - L;\n\t\trep(i, K) if (P2[i] > L) { cout << -1 << endl; return 0; }\n\t\tvector<UL> ans;\n\t\trep(l, L) {\n\t\t\tvector<UL> S, T;\n\t\t\tUL p = 0;\n\t\t\trep(i, K) {\n\t\t\t\tif (P2[i] == L - l) {\n\t\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\t\telse T.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\t\tfor (; p < K; p++) {\n\t\t\t\tT.push_back(p);\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\tsort(T.begin(), T.end());\n\t\t\tconcat(ans, S);\n\t\t\tconcat(ans, T);\n\t\t\tconcat(ans, S);\n\t\t}\n\t\t::ans.push_back(ans);\n\t}\n\tsort(ans.begin(), ans.end());\n\trep(i, ans[0].size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[0][i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    while(a[1] > 0) {\n        --a[1];\n        vs[a[1]].insert(1);\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n//\t\t\tif(len==29)cerr << ret[curlen] << \":\" << k-len-1 << \" \" << i << \":\" << ret[i] << endl;\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n//\tcerr << ret[curlen] << \"!!!\" ;\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n//\t\t\tif(extlen==29)cerr << ret[curlen] << \"!\" << endl;\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tif(extlen==29){cerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";cerr << endl;}\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint cnt[maxn], n;\nvector<int> res;\nvector<int> operator + (vector<int> a, vector<int> b) {\n\ta.insert(a.end(), b.begin(), b.end());\n\treturn a;\n}\nbool stvalid() { return *min_element(cnt, cnt+n) * 2 >= *max_element(cnt, cnt+n); }\nvector<int> minimize(vector<int> a) {\n\tstatic int backup[maxn];\n\tcopy(cnt, cnt+n, backup);\n\tvector<bool> vis(n);\n\tfor (int i : a) if (vis[i])\n\t\treturn vector<int>{inf};\n\telse vis[i] = true;\n\tint m = a.size();\n\n\tvector<int> b;\n\tfor (int i = 0;i < n;++i)\n\t\tif (!vis[i]) b.pb(i), a.pb(i), --cnt[i];\n\n\tassert(a.size() == n);\n\tint mx = *max_element(cnt, cnt+n), mn = *min_element(cnt, cnt+n);\n\n\tif (mn * 2 >= mx) {\n\t\tcopy(backup, backup+n, cnt);\n\t\tsort(b.begin(), b.end());\n\t\treturn b;\n\t}\n\tif (mn < 0) {\n\t\tcopy(backup, backup+n, cnt);\n\t\treturn vector<int> {inf};\n\t}\n\n\tif (mn * 2 + 1 == mx) {\n\t\t//cerr << \"in \\n\";\n\t\tint fstmin = inf, lstmax = -inf;\n\t\tfor (int i = 0;i < n && fstmin == inf;++i)\n\t\t\tif (cnt[i] == mn) fstmin = i;\n\t\tfor (int i = n-1;i >= 0 && lstmax == inf;++i)\n\t\t\tif (cnt[i] == mx) lstmax = i;\n\t\tif (fstmin < m && lstmax > fstmin) {\n\t\t\tcopy(backup, backup+n, cnt);\n\t\t\treturn vector<int>{inf};\n\t\t}\n\t\t//cerr << \"AA\";\n\t\tvector<int> c, d, e, res;\n\t\tfor (int i : b) if (cnt[i] == mx)\n\t\t\tc.pb(i);\n\t\telse if (cnt[i] == mn)\n\t\t\td.pb(i);\n\t\telse\n\t\t\te.pb(i);\n\t\t\t\t\n\t\tcopy(backup, backup+n, cnt);\n\t\tsort(c.begin(), c.end(), greater<>());\n\t\tsort(d.begin(), d.end(), greater<>());\n\t\tsort(e.begin(), e.end(), greater<>());\n\n#define GB(v) (v.size()?v.back():inf)\n\t\twhile (c.size()+d.size()+e.size()) {\n\t\t\tif (c.size()) {\n\t\t\t\tint x = c.back(), y = GB(e);\n\t\t\t\tif (x < y) {\n\t\t\t\t\tres.pb(x);\n\t\t\t\t\tc.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres.pb(y);\n\t\t\t\t\te.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x = GB(d), y = GB(e);\n\t\t\t\tif (x < y) {\n\t\t\t\t\tres.pb(x);\n\t\t\t\t\td.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres.pb(y);\n\t\t\t\t\te.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tcopy(backup, backup+n, cnt);\n\tassert(mn * 2 < mx);\n\treturn vector<int>{ inf };\n}\nvoid solve() {\n\tint sum = accumulate(cnt, cnt+n, 0);\n\tif (!stvalid())\n\t\tputs(\"-1\"), exit(0);\n\tres = minimize(vector<int>());\n\tfor (int i : res)\n\t\t--cnt[i];\n\twhile (res.size() < sum) {\n//\tfor (int i : res)\n//\t\tcout << i+1 << ' ';\n//\tcout << '\\n';\n\t\tvector<int> ad = minimize(vector<int>());\n\t\tfor (int i = 1;i < n;++i)\n\t\t\tad = min(ad, minimize(vector<int>(res.end()-i, res.end())));\n\t\tassert(ad != vector<int>{inf});\n\t\tres.insert(res.end(), ad.begin(), ad.end());\n\t\tfor (int i : ad) --cnt[i];\n\t}\n}\n\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0;i < n;++i)\n\t\tcin >> cnt[i];\n\tsolve();\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n      assert(false);\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100,M=1000;\n\nint n,a[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n}\nint mx,mn;\n\nvoid Get_mxn(){\n  mx=0;mn=M;\n  for (int i=1;i<=n;++i) mx=max(mx,a[i]),mn=min(mn,a[i]);\n}\n\nint last[N+9],tmp[N+9];\nint ta[N+9],tb[N+9],tc[N+9],cta,ctb,ctc;\n\nbool Get_tmp(int m){\n  int flag=1;\n  for (int i=1;i<=m;++i) --a[last[i]],tmp[i]=0;\n  Get_mxn();\n  if (mn<<1>=mx){\n\tfor (int i=1;i<=m;++i) tmp[i]=last[i];\n\tsort(tmp+1,tmp+m+1);\n  }else if (mn*2+1==mx){\n\tint flagmn=0,flagmx=0;\n\tcta=ctb=ctc=0;\n\tfor (int i=m+1;i<=n;++i)\n\t  if (a[last[i]]==mn) flagmn=1;\n      else if (a[last[i]]==mx&&flagmn) flagmx=1;\n\tfor (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mx) ta[++cta]=last[i],flagmx=1;\n    sort(ta+1,ta+cta+1);\n    if (flagmn&&flagmx) flag=0;\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mn) tc[++ctc]=last[i];\n    sort(tc+1,tc+ctc+1);\n\tfor (int i=1;i<=ctc;++i) ta[++cta]=tc[i];\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]<mx&&a[last[i]]>mn) tb[++ctb]=last[i];\n    merge(ta+1,ta+cta+1,tb+1,tb+ctb+1,tmp+1);\n  }else flag=0;\n  for (int i=1;i<=m;++i) ++a[last[i]];\n  return flag;\n}\n\nint now[N+9],cn;\n\nbool Check_cmp(){\n  for (int i=1;2333;++i)\n\tif (tmp[i]^now[i]) return tmp[i]<now[i];\n}\n\nint ans[N*M+9],ca;\n\nvoid Get_ans(){\n  Get_mxn();\n  if (mn<<1<mx) return;\n  for (int i=1;i<=n;++i) ca+=a[i],last[i]=i;\n  Get_tmp(n);\n  for (int i=1;i<=n;++i) --a[ans[i]=last[i]=tmp[i]],tmp[i]=0;\n  for (int i=n+1;i<=ca;){\n\tfor (int j=1;j<=n;++j) now[j]=0;\n\tnow[1]=n+1;cn=0;\n\tfor (int j=1;j<=n;++j){\n\t  if (i+j-1>ca) continue;\n\t  if (!Get_tmp(j)) continue;\n\t  if (Check_cmp()){\n\t\tcn=j;\n\t\tfor (int k=1;k<=j;++k) now[k]=tmp[k];\n\t  }\n\t}\n\tfor (int j=1;j<=cn;++j) --a[ans[i++]=now[j]];\n    for (int j=1;j<=n;++j) last[j]=ans[i-n+j-1];\n  }\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  if (!ca) puts(\"-1\");\n  else{\n\tfor (int i=1;i<=ca;++i)\n\t  printf(\"%d \",ans[i]);\n    puts(\"\");\n  }\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tset<int> MIN;\n\t\tfor(int i=1;i<=k;i++) if(A[i]==mn) MIN.insert(i);\n\t\tvi Ans;\n\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tH[i]-=diff;\n\t\t}\n\t\tmn-=diff;\n\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tint smol = (*(MIN.begin()));\n\t\t\tif(H[smol]==0) break;\n\t\t\t\n\t\t\tfor(auto m:MIN) {D.push_back(m);H[m]--;}\n\t\t\tfor(int i=k;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(!MIN.count(i))\n\t\t\t\t{\n\t\t\t\t\tD.push_back(i);\n\t\t\t\t\tD.push_front(i);\n\t\t\t\t\tH[i]-=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmn--;\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tif(H[i]==mn) MIN.insert(i);\n\t\t\t}\n\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Ans.size()==0)\n\t\t\t{\n\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t}\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint a[110],p[1010],pl[110],pr[110];\nbool bl[110];\nint main()\n{\n\tre int n=0,k,mx=0,mm=0,mk=0;\n\tscanf(\"%d\",&k);\n\tfor(re int i=1;i<=k;i++)scanf(\"%d\",&a[i]),n+=a[i],mx=std::max(mx,a[i]),pl[i]=k,pr[i]=i;\n\tfor(re int i=1;i<=k;i++)if(a[i]*2<mx){puts(\"-1\");return 0;}\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tre int j=1;\n\t\tfor(;j<=k;j++)\n\t\t{\n\t\t\tif(bl[j])continue;\n\t\t\tre bool bb=1;mx=0;\n\t\t\tfor(re int i=1;i<=k;i++)mx=std::max(mx,a[i]);\n\t\t\tfor(re int i1=1;i1<=pl[j];i1++)if(!bl[pr[i1]])a[pr[i1]]--;\n\t\t\tfor(re int i=1;i<=k;i++)if(a[i]*2+2<mx){bb=0;break;}\n\t\t\tif(a[j]*2+1<mx)bb=0;\n\t\t\tfor(re int i1=1;i1<=pl[j];i1++)if(!bl[pr[i1]])a[pr[i1]]++;\n\t\t\tif(bb)break;\n\t\t}\n\t\tassert(j<=k);\n\t\tbl[j]=1;p[i]=j;a[j]--;mm++;mk=std::max(mk,pl[j]);\n\t\tif(i>=k&&(i==k||mm==mk))\n\t\t{\n\t\t\tfor(re int j=1;j<=k;j++)bl[j]=0,pl[p[i-k+j]]=j,pr[j]=p[i-k+j];mm=mk=0;\n\t\t}\n\t}\n\tfor(re int i=1;i<=n;i++)printf(\"%d \",p[i]);\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1だけ特殊\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // 他で使用されるブロックの個数\n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451にするブロックの個数\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // 残り\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO デバッグコード\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\tfor (int i = 0;i < K;++ i) { // 不可能を消しておく\n\t\t\ta[i] -= min;\n\t\t\tif (a[i] > min) {\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint max = Arrays.stream(a).max().getAsInt(); // 最初を埋めなきゃいけない個数\n\t\tfor (int i = 0;i < max;++ i) {\n\t\t\tfor (int j = 0;j < K;++ j) {\n\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\tblock.get(i).add(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ // 1だけ特殊\n\t\t\tfor (int i = 0;i < a[0];++ i) {\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO デバッグコード\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\tfor (int i = 0;i < K;++ i) { // 不可能を消しておく\n\t\t\ta[i] -= min;\n\t\t\tif (a[i] > min) {\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint max = Arrays.stream(a).max().getAsInt(); // 最初を埋めなきゃいけない個数\n\t\tfor (int i = 0;i < max;++ i) {\n\t\t\tfor (int j = 0;j < K;++ j) {\n\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\tblock.get(i).add(j);\n\t\t\t\t\t-- a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ // 1だけ特殊\n\t\t\tfor (int i = 0;i < a[0];++ i) {\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO デバッグコード\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > min && !got || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void solve() throws Exception {\n\t\tint k = scanInt();\n\t\tint a[] = new int[k];\n\t\tint minA = Integer.MAX_VALUE, maxA = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\ta[i] = scanInt();\n\t\t\tminA = min(minA, a[i]);\n\t\t\tmaxA = max(maxA, a[i]);\n\t\t}\n\t\tif (maxA > minA * 2) {\n\t\t\tout.print(-1);\n\t\t\treturn;\n\t\t}\n\t\tboolean groupExtra[][] = new boolean[minA][k];\n\t\tint groupNext[] = new int[minA];\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint have = a[i] - minA;\n\t\t\tfor (int j = 0; j < minA; j++) {\n\t\t\t\tif (j + have == minA || (have > 0 && groupNext[j] == i)) {\n\t\t\t\t\tgroupExtra[j][i] = true;\n\t\t\t\t\t--have;\n\t\t\t\t\tif (groupNext[j] == i) {\n\t\t\t\t\t\tgroupNext[j] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < minA; i++) {\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (groupExtra[i][j]) {\n\t\t\t\t\tout.print((j + 1) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (!groupExtra[i][j]) {\n\t\t\t\t\tout.print((j + 1) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (groupExtra[i][j]) {\n\t\t\t\t\tout.print((j + 1) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\tfor (int i = 0;i < K;++ i) { // 不可能を消しておく\n\t\t\ta[i] -= min;\n\t\t\tif (a[i] > min) {\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint max = 0; // 最初を埋めなきゃいけない個数\n\t\tfor (int i = 1;i < K;++ i) max = Math.max(max, a[i]);\n\t\t{ // 1だけ特殊\n\t\t\tint X = Math.min(a[0], min - max); // 123451が作れる個数\n\t\t\tfor (int i = 0;i < X;++ i) {\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\ta[0] -= X;\n\t\t}\n\t\tfor (int i = 1;i < max;++ i) {\n\t\t\tfor (int j = 0;j < K;++ j) {\n\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\tblock.get(i).add(j);\n\t\t\t\t\t-- a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO デバッグコード\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tint K = io.nextInt();\n\t\tint[] a = io.nextInt(K);\n\t\tint min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1だけ特殊\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // 他で使用されるブロックの個数\n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451にするブロックの個数\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // 残り\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tSystem.exit(1);\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == l.size() + 1) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == r.size() + 1) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * (min - 1)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tif (max - 1 <= 2 * (vals[1] - 1)) {\n\t\t\t\t\tret[idx++] = 1;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tint firstDup = -1, lastDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min) lastDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (i < lastDup && vals[i] > min || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * Math.min(min - 1, vals[1] -2)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tret[idx++] = 1;\n\t\t\t\tvals[1]--;\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tint firstDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (firstDup != -1 && lastNoDup > firstDup && vals[i] > min && !got || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * Math.min(min - 1, vals[1] -2)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tret[idx++] = 1;\n\t\t\t\tvals[1]--;\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tint firstDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (firstDup != -1 && lastNoDup > firstDup && vals[i] > min || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tint K = io.nextInt();\n\t\tint[] a = io.nextInt(K);\n\t\tint min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1だけ特殊\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // 他で使用されるブロックの個数\n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451にするブロックの個数\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - (min - X);++ i) block.get(i).add(0); // 残り\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == l.size() + 1) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == r.size() + 1) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1だけ特殊\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // 他で使用されるブロックの個数\n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451にするブロックの個数\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // 残り\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO デバッグコード\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i] = sc.nextInt();\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * (min - 1)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tif (max - 1 <= 2 * (vals[1] - 1)) {\n\t\t\t\t\tret[idx++] = 1;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tint firstDup = -1, lastDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min) lastDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (i < lastNoDup && vals[i] > min || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1だけ特殊\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // 他で使用されるブロックの個数\n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451にするブロックの個数\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // 残り\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == K + 1) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == K + 1) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tint firstDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (firstDup != -1 && lastNoDup > firstDup && vals[i] > min && !got || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E問題\n\t\t * 考察メモ\n\t\t * xをnを除く順列として、最大でもnxnnxn...なので2倍を超えると無理そう\n\t\t * 1231123112311231...が限界ということね、2|P|/(K+1)だね\n\t\t * とりあえず、順列は123...で並べるのが最適に感じるので殆どこれで並べていく\n\t\t * 次に溢れるものを考える\n\t\t * サンプル1だと123123はとりあえず作る\n\t\t * で、2が溢れるので21322132と書き換える\n\t\t * で、3が溢れるので213223123と書き換える\n\t\t * これは要するに後ろから順に、小さい方の数字から順に変えていった訳\n\t\t * サンプル2もやるね\n\t\t * 12341234 まず全部を2つ使う\n\t\t * 123412341 溢れた1を後ろに繋ぐ\n\t\t * 1234132413 ……あれ？\n\t\t * あー、1を繋ぐ時は話が変わるのか、面倒だね\n\t\t *\n\t\t * えーと、基本的に順列を考察の手順に置くのは正しそうなので\n\t\t * 12341234→12341/2341はおっけーとしよう\n\t\t * ちなみに1を更に増やすと12341/12341になるよ\n\t\t * これ、2341は順列で、かつ2~4の順は好きに弄れることに注意するよ\n\t\t * すると、3を追加するときは12341/2341→12341/31243/になるのね\n\t\t * 要するに先頭から、nxnのブロックを固定していく感じにしていけば良さそう？\n\t\t * で、1x1以外は前に置くと損するから完成したブロックは後ろに持ち込む感じで\n\t\t * サンプル1だと、123123を2132 2132の2つのブロックにして、3を更にくっ付けるの\n\t\t * これは後ろのブロック2132を使って23123にすると、2132/23123 になると\n\t\t *\n\t\t * 次のアルゴリズムを考える\n\t\t * ・まず、どれかが0になるまでは順列を作って123123...が最適\n\t\t * ・次に、1が溢れているならば先に処理、1231の形のブロックを増やしていく(不足したら-1)\n\t\t * ・次に、2以降に関しては後ろに置きたいので、後ろに繋げる形にする\n\t\t * 具体的には、12345だったら213452、のようにする\n\t\t * 123451なら1234512、だね\n\t\t * つまり、今順列+追加の数字(例えば13524678135)になっているはずなので、ここに7を追加したいなら、\n\t\t * 追加の数字+7+それ以外で順列を構成している数を昇順+追加の数字+7、にすれば矛盾せず構築できる\n\t\t * 13524678135→135724681357、のように 勿論これは辞書順最小になってるよ\n\t\t * さて、これで作った列だけど、ブロック順は？→辞書順に並び替えればよくね？\n\t\t * ブロックごとは独立に並び替えられるので\n\t\t * 123451 < 12345 ... (123451だけはこっちの方が嬉しい)\n\t\t * < 213452 < 312453 < ... (追加数列の辞書順)\n\t\t * 従って、追加数列は少ない方が嬉しい\n\t\t * また、同じ個数ならなるべく均等に1→2→…を割り振りたい\n\t\t * 何故なら1は前に、次に2……となるのは明白\n\t\t * ただ、123451だけ12345より優先度が高いのよね\n\t\t * つまり、次のように考えられる\n\t\t * ・X = max(a_2 - min(a), ..., a_n - min(a))のブロックは追加順列が付く\n\t\t * 従って、min(a_1, min(a) - X)個のブロックは123451にして、\n\t\t * 残りは普通に順列構成をさせれば良いのでは？\n\t\t */\n\t\tint K = io.nextInt();\n\t\tint[] a = io.nextInt(K);\n\t\tint min = Arrays.stream(a).min().getAsInt(); // 順列の個数 = ブロックの個数\n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // ブロックに分割！\n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1だけ特殊\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // 他で使用されるブロックの個数\n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451にするブロックの個数\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // 残り\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // 不可能なのではい\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // まずこの順に先頭を置くのが最適\n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // 残りを置く(順列になる)\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // 更に既に置いていたものを置く(ブロック完成！)\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == l.size() + 1) return 1; // rの方が小さい\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == r.size() + 1) return -1; // lの方が小さい\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// 以下、ライブラリ\n\n\t/**\n\t * 高速な入出力を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * 区間スケジューリングを行います。<br>\n\t\t * 計算量は要素数Nに対してO(NlogN)です。\n\t\t * @param ranges 区間の集合\n\t\t * @return 区間スケジューリングを行った際の一つの解\n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * 演算が整閉整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算がGCD整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * 素元を提供します。\n\t * @author 31536000\n\t *\n\t * @param <T> 演算の型\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * 演算が一意分解整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * 演算が主イデアル整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * 演算がユークリッド整域であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * 演算が体であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(plogn, n-k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * 第一種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * 第二種スターリング数S(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return S(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return B(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * ベル数B(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいベル数の番号\n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n, k)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(nk)です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return P(n, k)をmodで割った余り\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * 分割数P(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n sqrt(n))です。 // TODO NTTを使うとO(n log n)、未実装\n\t\t * @param n 求めたい分割数の番号\n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 区間における素数を保持する関数です。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * このクラスが持つ区間の範囲を返します。\n\t\t * @return 素数を保持している区間\n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * 素数かどうかを判定します。\n\t\t * @param n 素数かどうか判定したい数\n\t\t * @return 素数ならばtrue\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた数を素因数分解します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 素因数分解したい数\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * 整数の素因数分解表現を保持します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * 素因数分解のリスト表現を返します。\n\t\t * @return 素因数分解のリスト\n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * nとgcdを取った値を保持します。\n\t\t * @param n gcdを取りたい値\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)を返します。\n\t\t * @param n gcdを取りたい値\n\t\t * @param m gcdを取りたい値\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nとlcmを取った値を保持します。\n\t\t * @param n lcmを取りたい値\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)を返します。\n\t\t * @param n lcmを取りたい値\n\t\t * @param m lcmを取りたい値\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * 区間における素数を列挙します。<br>\n\t\t * この実装はエラトステネスの篩に基づきます。\n\t\t * @param n 素数を求める範囲\n\t\t * @return 1以上n以下の素数を保持する区間素数\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値を素因数分解した結果を返します。\n\t\t * @param x 素因数分解する値\n\t\t * @return 素因数分解した結果\n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // 素因数分解が終わってる\n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // 失敗したので\n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// dは約数の一つ\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを管理するクラスです。\n\t * @author 31536000\n\t *\n\t * @param <E> 保持する要素\n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * 要素とそのindexを渡します。<br>\n\t\t * indexは必ずしも元の配列またはコレクションのindexと一致する必要はありませんが、一致する値を返すことが推奨されます。\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * 要素を返します。\n\t\t * @return 要素\n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * indexを返します。\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * 要素とそのindexを効率的に取得する関数を提供します。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * 配列の各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> 配列の型\n\t\t * @param array 配列\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * Iteratorの各要素とそのindexを順に返すIteratorを生成します。\n\t\t * @param <E> Iteratorの型\n\t\t * @param iter Iterator\n\t\t * @param start 添字の初期値、この値だけindexが足されたものが返る\n\t\t * @return Enumerate&lt;E&gt;のIterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing System.Collections.Generic;\n\nclass Myon\n\n{\n    public Myon() { }\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Myon().calc();\n        return 0;\n    }\n    static Scanner cin;\n    int mod = 998244353;\n\n    void calc()\n    {\n        int K = cin.nextInt();\n        int[] A = cin.ArrayInt(K);\n        int min = 999999;\n        int max = 0;\n        for (int i = 0; i < A.Length; i++)\n        {\n            min = Math.Min(min, A[i]);\n            max = Math.Max(max, A[i]);\n        }\n        if(min * 2 < max)\n        {\n            Console.WriteLine(-1);\n            return;\n        }\n        List<int> ans = new List<int>();\n\n        for (int t = 0; t < min; t++)\n        {\n            int nokori = min - t;\n            List<int> over = new List<int>();\n            List<int> under = new List<int>();\n\n            int overMax = -1;\n            for (int i = 0; i < K; i++)\n            {\n                if(A[i] == nokori * 2)\n                {\n                    overMax = i;\n                }\n            }\n\n            bool first = true;\n            for (int i = 0; i < K; i++)\n            {\n                if((A[i] > nokori && (first || i <= overMax)))\n                {\n                    A[i] -= 2;\n                    over.Add(i + 1);\n                    if (A[i] > nokori - 1) first = false;\n                }\n                else\n                {\n                    A[i]--;\n                    under.Add(i + 1);\n                    first = false;\n                }\n            }\n            foreach (var item in over)\n            {\n                ans.Add(item);\n            }\n\n            foreach (var item in under)\n            {\n                ans.Add(item);\n            }\n\n            foreach (var item in over)\n            {\n                ans.Add(item);\n            }\n        }\n\n        Console.WriteLine(string.Join(\" \", ans));\n\n    }\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "k = gets.to_i\na = gets.split.map(&:to_i).zip(1..k).sort_by { |a| a[0] }\n\n# n個のブロックに分割を試みる\n# ブロックはそれぞれの個数がd個もしくはd+1個\n# ブロックの個数の合計はk以上\n\nresult = []\n\nn = min = a[0][0]\n\nn.times do\n  b = []\n  temp = 1000000\n  (1..k).each do |i|\n    c = a[i-1][0] > min ? 2 : 1\n    b << [c, i]\n    a[i-1][0] -= c\n    temp = a[i-1][0] if temp > a[i-1][0]\n  end\n  min = temp\n  if min == 0\n    puts \"-1\"\n    exit\n  end\n  \n  b.sort_by! { |a| a[0] }\n  \n  i = b.index { |a| a[0] == 2 }\n  \n  b.each { |a| result << a[1] }\n  (i...k).reverse_each { |j| result << b[j][1] }\n  \nend\n\nputs result.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "k = gets.to_i\na = gets.split.map(&:to_i).zip(1..k).sort_by { |a| a[0] }\n\n# n個のブロックに分割を試みる\n# ブロックはそれぞれの個数がd個もしくはd+1個\n# ブロックの個数の合計はk以上\n\nresult = []\n\nn = min = a[0][0]\n\nn.times do\n  b = []\n  temp = 1000000\n  (1..k).each do |i|\n    c = i > min ? 2 : 1\n    b << [c, i]\n    a[i-1][0] -= c\n    temp = a[i-1][0] if temp > a[i-1][0]\n  end\n  min = temp\n  if min == 0\n    puts \"-1\"\n    exit\n  end\n  \n  b.sort_by! { |a| a[0] }\n  \n  i = b.index { |a| a[0] == 2 }\n  \n  b.each { |a| result << a[1] }\n  (i...k).reverse_each { |j| result << b[j][1] }\n  \nend\n\nputs result.join(\" \")"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heapreplace\nfrom itertools import chain\n\n\ndef solve(k, aaa):\n    aaa_idx = [(-a, i) for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = -aaa_idx[-1][0]\n    max_a = -aaa_idx[0][0]\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = set()\n\n        while True:\n            while aaa[aaa_idx[0][1] - 1] != -aaa_idx[0][0]:\n                heapreplace(aaa_idx, (-aaa[aaa_idx[0][1] - 1], aaa_idx[0][1]))\n            if (min_a - 1) * 2 < (-aaa_idx[0][0] - 1):\n                a, i = aaa_idx[0]\n                double.add(i)\n                aaa[i - 1] -= 2\n                heapreplace(aaa_idx, (a + 2, i))\n            else:\n                break\n\n        if aaa[0] > min_a and 1 not in double:\n            double.add(1)\n            aaa[0] -= 2\n\n        double_sorted = sorted(double)\n\n        ans.extend(double_sorted)\n        for i in range(1, k + 1):\n            if i in double:\n                continue\n            ans.append(i)\n            aaa[i - 1] -= 1\n        ans.extend(double_sorted)\n\n        min_a -= 1\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    aaa_idx = [[a, i] for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = aaa_idx[0][0]\n    if min_a * 2 < aaa_idx[-1][1]:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = []\n        single = []\n        for j in range(k):\n            a, i = aaa_idx[j]\n            if a > min_a:\n                double.append(i)\n                aaa_idx[j][0] -= 2\n            else:\n                single.append(i)\n                aaa_idx[j][0] -= 1\n        double.sort()\n        single.sort()\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n        min_a -= 1\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=len_f:\n      index_i=len_f-k\nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    aaa_idx = [[a, i] for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = aaa_idx[0][0]\n    if min_a * 2 < aaa_idx[-1][1]:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = []\n        single = []\n        for j in range(k):\n            a, i = aaa_idx[j]\n            if a > min_a:\n                double.append(i)\n                aaa_idx[j][0] -= 2\n            else:\n                single.append(i)\n                aaa_idx[j][0] -= 1\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n        min_a -= 1\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "K = int(input())\nA = [int(a) for a in input().split()]\nm = min(A)\nif max(A) > m * 2:\n    print(-1)\n    exit()\nL = [i for i in range(K) if A[i] == m]\nX = [[[], L[:], []]  for _ in range(m)]\nL = [i for i in range(K)[::-1] if A[i] != m]\n\ndef ins(li, v):\n    for j, l in enumerate(li):\n        if l > v:\n            li.append(li[-1])\n            for k in range(j + 1, len(li) - 1)[::-1]:\n                li[k] = li[k-1]\n            li[j] = v\n            break\n    else:\n        li.append(v)\n\nfor l in L:\n    c = A[l]\n    for i in range(m):\n        if c == m - i:\n            ins(X[i][1], l)\n            c -= 1\n        elif c == (m - i) * 2:\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        elif len(X[i][0]) and l < X[i][0][-1]:\n            ins(X[i][1], l)\n            c -= 1\n        elif l > X[i][1][0]:\n            ins(X[i][1], l)\n            c -= 1\n        elif l < (X[i+1][0][0] if len(X[i+1][0]) else X[i+1][1][0]):\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        else:\n            ins(X[i][1], l)\n            c -= 1\n\nANS = []\nfor i in range(m):\n    for j in range(3):\n        for k in range(len(X[i][j])):\n            ANS.append(X[i][j][k] + 1)\nprint(*ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef find_permutation(aaa, use):\n    \"\"\"\n    iの残り使用数がaaa[i-1]の状態で\n    集合useにある文字群(1～k)を後ろに繋げる方法で\n    それよりさらに後が破綻しないような繋げ方のうち\n    辞書順最小のものを求める。\n\n    ただし（この関数からは見えないが）現在確定済み配列の\n    末尾 (k - |use|) 個は、useに含まれない要素が1回ずつ登場することを前提とする。\n    （つまり、この関数の結果を繋げると、末尾 k 個が順列になる）\n\n    どうやっても破綻する場合はNoneを返す。\n\n    :param aaa:\n    :param use:\n    :return:\n    \"\"\"\n\n    max_a = -1\n    min_a = 1005\n    max_fixed = -1\n\n    for i in range(k):\n        a = aaa[i]\n        if i + 1 in use:\n            min_a = min(min_a, a)\n            max_a = max(max_a, a)\n        else:\n            max_fixed = max(max_fixed, a)\n\n    if max(max_a, max_fixed + 1) > 2 * min_a:\n        return None\n\n    if max_a < 2 * min_a:\n        return sorted(use)\n\n    front = []\n    rear = []\n    either = []\n    for i in use:\n        if aaa[i - 1] == max_a:\n            front.append(i)\n        elif aaa[i - 1] == min_a:\n            rear.append(i)\n        else:\n            either.append(i)\n\n    max_front = front[-1]\n    for i in either:\n        if i < max_front:\n            front.append(i)\n        else:\n            rear.append(i)\n    front.sort()\n    rear.sort()\n    front.extend(rear)\n\n    return front\n\n\ndef solve(k, aaa):\n    if k == 1:\n        return [1] * aaa[0]\n\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    ans.extend(find_permutation(aaa, set(range(1, k + 1))))\n    for i in range(k):\n        aaa[i] -= 1\n\n    remaining = sum(aaa)\n    while remaining:\n        use = set(range(1, k + 1))\n        candidates = []\n        for r in range(k):\n            result = find_permutation(aaa, use)\n            if result is not None:\n                candidates.append(result)\n\n            use.remove(ans[-r - 1])\n        adopted = min(candidates)\n        ans.extend(adopted)\n        for i in adopted:\n            aaa[i - 1] -= 1\n        remaining -= len(adopted)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a = max(aaa)\n\n        if min_a == 0:\n            assert max_a == 0\n            break\n\n        next_max = max_a - (1 if min_a * 2 > max_a else 2)\n\n        single = []\n        double = []\n        for i in range(k):\n            if len(double) == 0 and (aaa[i] - 2) * 2 >= next_max:\n                double.append(i + 1)\n                aaa[i] -= 2\n            elif min_a * 2 == aaa[i]:\n                double.append(i + 1)\n                aaa[i] -= 2\n            else:\n                single.append(i + 1)\n                aaa[i] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a1 = max(aaa[1:])\n        max_a = max(aaa[0], max_a1)\n\n        if min_a == 0:\n            assert max_a == 0\n            break\n\n        if min_a * 2 == max_a:\n            must_use = [i for i, a in enumerate(aaa) if a == max_a]\n            next_max = max_a - 2\n        elif (aaa[0] - 2) * 2 >= max_a1 - 1:\n            must_use = []\n            next_max = max(aaa[0] - 2, max_a1 - 1)\n        else:\n            ans.extend(range(1, k + 1))\n            for i in range(k):\n                aaa[i] -= 1\n            continue\n\n        can_use = []\n        cant_use = []\n\n        for i in range(k):\n            if min_a * 2 == aaa[i]:\n                pass\n            elif (aaa[i] - 2) * 2 >= next_max:\n                can_use.append(i)\n            else:\n                cant_use.append(i)\n\n        double = []\n        if len(must_use) == 0:\n            double.append(can_use[0] + 1)\n        else:\n            max_use = must_use[-1]\n            use = must_use + can_use\n            use.sort()\n            double = [i + 1 for i in use if i <= max_use]\n        single = [i for i in range(1, k + 1) if i not in double]\n\n        for i in double:\n            aaa[i - 1] -= 2\n        for i in single:\n            aaa[i - 1] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import chain\n\n\ndef solve(k, aaa):\n    aaa_idx = [[a, i] for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = aaa_idx[0][0]\n    if min_a * 2 < aaa_idx[-1][1]:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = []\n        single = []\n        for j in range(k):\n            a, i = aaa_idx[j]\n            if a > min_a:\n                double.append(i)\n                aaa_idx[j][0] -= 2\n            else:\n                single.append(i)\n                aaa_idx[j][0] -= 1\n        double.sort()\n        single.sort()\n        single.extend(double)\n        double.extend(single)\n        ans.append(double)\n        min_a -= 1\n    ans.sort()\n\n    return chain.from_iterable(ans)\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": " "
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nK = input()\ncounts = np.array(list(map(int, input().split())))\n\nget_bin = lambda x, n: format(x, 'b').zfill(n)\n\ndef get_block_list(counts: np.ndarray):\n    if counts.max() - counts.min() == 0: return [np.ones_like(counts)]\n    blocks = [(counts == counts.max()).astype(int) + 1]\n    if counts.max() - counts.min() > 1: return blocks\n    indices = np.arange(len(counts))[counts == counts.max()]\n    blocks = []\n    for i in range(2 ** len(indices)):\n        block = np.ones_like(counts)\n        binary = get_bin(i, len(indices))\n        for k, j in enumerate(indices):\n            block[j] += int(binary[k])\n        blocks.append(block)\n    return blocks\n\n\ndef block_to_str(block):\n    arange = np.arange(1, len(block) + 1)\n    if block.max() == 1: return \" \".join(map(str, arange))\n    twice = list(arange[block == block.max()])\n    once = list(arange[block != block.max()])\n    return \" \".join(map(str, twice + once + twice))\n\n\ndef solution(block_list, counts):\n    if counts.min() < 0:\n        return -1\n    if counts.max() == 0:\n        sorted_strs = sorted([block_to_str(block) for block in block_list])\n        return \" \".join(sorted_strs)\n    blocks = get_block_list(counts)\n    sols = [solution(block_list + [block], counts - block) for block in blocks]\n    sols = list(filter(lambda x: x != -1, sols))\n    if sols: return sorted(sols)[0]\n    else: return -1\n\n\nprint(solution([], counts))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=len_f:\n      index_i=len_f-k\nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nK = input()\ncounts = np.array(list(map(int, input().split())))\n\n\ndef subtract_count(counts: np.ndarray):\n    if counts.max() == 1: block = np.ones_like(counts)\n    else: block = (counts == counts.max()).astype(int) + 1\n    return counts - block, block\n\n\ndef block_to_str(block):\n    arange = np.arange(1, len(block) + 1)\n    if block.max() == 1: return \" \".join(map(str, arange))\n    twice = list(arange[block == block.max()])\n    once = list(arange[block != block.max()])\n    return \" \".join(map(str, twice + once + twice))\n\n\ndef greedy_solution(counts):\n    blocks = []\n    while counts.max() > 0:\n        counts, block = subtract_count(counts)\n        blocks.append(block)\n    # print(blocks, counts)\n    if counts.min() < 0:\n        return -1\n    sorted_strs = sorted([block_to_str(block) for block in blocks])\n    return \" \".join(sorted_strs)\n\n\ndef solution(counts):\n    candidates = []\n    candidates.append(greedy_solution(counts))\n    alt = np.ones_like(counts)\n    alt[0] = 2\n    alts = [alt]\n    for alt in alts:\n        alt = np.array(alt)\n        sol = greedy_solution(counts - alt)\n        if sol == -1:\n            continue\n        candidates.append(block_to_str(alt) + \" \" + sol)\n    return sorted(candidates)[0]\n\n\nprint(solution(counts))"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    if k == 1:\n        return [1] * aaa[0]\n\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a1 = max(aaa[1:])\n        max_a = max(aaa[0], max_a1)\n\n        if min_a <= 0:\n            assert max_a == 0\n            break\n\n        if (min_a - 1) * 2 < max_a - 1:\n            must_use = [i for i, a in enumerate(aaa) if a - 1 > (min_a - 1) * 2]\n            next_max = max_a - 2\n        elif (aaa[0] - 2) * 2 >= max_a1 - 1:\n            must_use = []\n            next_max = max(aaa[0] - 2, max_a1 - 1)\n        else:\n            ans.extend(range(1, k + 1))\n            for i in range(k):\n                aaa[i] -= 1\n            continue\n\n        can_use = []\n        cant_use = []\n\n        for i in range(k):\n            if i in must_use:\n                pass\n            elif (aaa[i] - 2) * 2 >= next_max:\n                can_use.append(i)\n            else:\n                cant_use.append(i)\n\n        double = []\n        if len(must_use) == 0:\n            double.append(can_use[0] + 1)\n        else:\n            max_use = must_use[-1]\n            use = must_use + can_use\n            use.sort()\n            double = [i + 1 for i in use if i <= max_use]\n        single = [i for i in range(1, k + 1) if i not in double]\n\n        for i in double:\n            aaa[i - 1] -= 2\n        for i in single:\n            aaa[i - 1] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a = max(aaa)\n\n        if min_a == 0:\n            assert max_a == 0\n            break\n\n        if aaa[0] == min_a and min_a * 2 - 1 == max_a:\n            ans.extend(range(1, k + 1))\n            for i in range(k):\n                aaa[i] -= 1\n            continue\n\n        next_max = max_a - (1 if min_a * 2 > max_a else 2)\n\n        must_use = []\n        can_use = []\n        cant_use = []\n        for i in range(k):\n            if min_a * 2 == aaa[i]:\n                must_use.append(i)\n            elif (aaa[i] - 2) * 2 >= next_max:\n                can_use.append(i)\n            else:\n                cant_use.append(i)\n\n        double = []\n        if len(must_use) == 0:\n            double.append(can_use[0] + 1)\n        else:\n            max_use = must_use[-1]\n            use = must_use + can_use\n            use.sort()\n            double = [i + 1 for i in use if i <= max_use]\n        single = [i for i in range(1, k + 1) if i not in double]\n\n        for i in double:\n            aaa[i - 1] -= 2\n        for i in single:\n            aaa[i - 1] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nK = input()\ncounts = np.array(list(map(int, input().split())))\n\nget_bin = lambda x, n: format(x, 'b').zfill(n)\n\n\ndef get_block_list(counts: np.ndarray):\n    if counts.max() - counts.min() == 0: return [np.ones_like(counts)]\n    blocks = [(counts == counts.max()).astype(int) + 1]\n    if counts.max() - counts.min() > 1: return blocks\n    # indices = np.arange(len(counts))[counts == counts.max()]\n    # blocks = []\n    # for i in range(2 ** len(indices)):\n    #     block = np.ones_like(counts)\n    #     binary = get_bin(i, len(indices))\n    #     for k, j in enumerate(indices):\n    #         block[j] += int(binary[k])\n    #     blocks.append(block)\n    return blocks\n\n\ndef block_to_str(block):\n    arange = np.arange(1, len(block) + 1)\n    if block.max() == 1: return \" \".join(map(str, arange))\n    twice = list(arange[block == block.max()])\n    once = list(arange[block != block.max()])\n    return \" \".join(map(str, twice + once + twice))\n\n\ndef solution(block_list, counts):\n    if counts.min() < 0:\n        return -1\n    if counts.max() == 0:\n        sorted_strs = sorted([block_to_str(block) for block in block_list])\n        return \" \".join(sorted_strs)\n    blocks = get_block_list(counts)\n    sols = [solution(block_list + [block], counts - block) for block in blocks]\n    sols = list(filter(lambda x: x != -1, sols))\n    if sols: return sorted(sols)[0]\n    else: return -1\n\n\nprint(solution([], counts))"
  },
  {
    "language": "Python",
    "code": "K = int(input())\nA = [int(a) for a in input().split()]\nm = min(A)\nif max(A) > m * 2:\n    print(-1)\n    exit()\nL = [i for i in range(K) if A[i] == m]\nX = [[[], L[:], []]  for _ in range(m)]\nL = [i for i in range(K)[::-1] if A[i] != m]\n\ndef ins(li, v):\n    for j, l in enumerate(li):\n        if l > v:\n            li.append(li[-1])\n            for k in range(j + 1, len(li) - 1)[::-1]:\n                li[k] = li[k-1]\n            li[j] = v\n            break\n    else:\n        li.append(v)\n\nfor l in L:\n    c = A[l]\n    for i in range(m):\n        if c == m - i:\n            ins(X[i][1], l)\n            c -= 1\n        elif c == (m - i) * 2:\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        elif len(X[i][0]) and l < X[i][0][-1]:\n            ins(X[i][1], l)\n            c -= 1\n        elif l < (X[i+1][0][0] if len(X[i+1][0]) else X[i+1][1][0]):\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        else:\n            ins(X[i][1], l)\n            c -= 1\n\nANS = []\nfor i in range(m):\n    for j in range(3):\n        for k in range(len(X[i][j])):\n            ANS.append(X[i][j][k] + 1)\nprint(*ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heapreplace\nfrom itertools import chain\n\n\ndef solve(k, aaa):\n    aaa_idx = [(-a, i) for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = -aaa_idx[-1][0]\n    max_a = -aaa_idx[0][0]\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while min_a:\n        double = set()\n\n        while True:\n            while aaa[aaa_idx[0][1] - 1] != -aaa_idx[0][0]:\n                heapreplace(aaa_idx, (-aaa[aaa_idx[0][1] - 1], aaa_idx[0][1]))\n            if (min_a - 1) * 2 < (-aaa_idx[0][0] - 1):\n                a, i = aaa_idx[0]\n                double.add(i)\n                aaa[i - 1] -= 2\n                heapreplace(aaa_idx, (a + 2, i))\n            else:\n                break\n\n        max_a = -aaa_idx[0][0]\n        if len(double) == 0:\n            max_a -= 1\n\n        if 1 not in double and (aaa[0] - 2) * 2 >= max_a:\n            double.add(1)\n            aaa[0] -= 2\n\n        double_sorted = sorted(double)\n\n        ans.extend(double_sorted)\n        for i in range(1, k + 1):\n            if i in double:\n                continue\n            ans.append(i)\n            aaa[i - 1] -= 1\n        ans.extend(double_sorted)\n\n        min_a = min(min_a - 1, aaa[0])\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  if temp1 + temp0 < temp3 + temp2:\n    for l in range(len_f,sum_a-len_e):\n      p[l]=fronts[index_i]\n      index_i+=1\n      if index_i >=len_f:\n        index_i=len_f-k\n  else:\n    index_i=len_e-k\n    for l in range(len_e,sum_a-len_e):\n      p[l]=ends[index_i]\n      index_i+=1\n      if index_i >=len_e:\n        index_i=len_e-k  \nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  if sum(temp1) < sum(temp3):\n    for l in range(len_f,sum_a-len_e):\n      p[l]=fronts[index_i]\n      index_i+=1\n      if index_i >=len_f:\n        index_i=len_f-k\n  else:\n    index_i=0\n    for l in range(len_e,sum_a-len_e):\n      p[l]=ends[index_i]\n      index_i+=1\n      if index_i >=len_e:\n        index_i=0  \nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  if sum(temp1) < sum(temp3):\n    for l in range(len_f,sum_a-len_e):\n      p[l]=fronts[index_i]\n      index_i+=1\n      if index_i >=len_f:\n        index_i=len_f-k\n  else:\n    index_i=len_e-k\n    for l in range(len_e,sum_a-len_e):\n      p[l]=ends[index_i]\n      index_i+=1\n      if index_i >=len_e:\n        index_i=len_e-k  \nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input,fastout};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    }\n    else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i-1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i-1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i-1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j+1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    }\n    else {\n        true\n    }\n}\n\n\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n    /*let mut now: Vec<usize> = make_seq(&a);\n    let n: usize = now.len();\n    for i in 0..(n-1) {\n        print!(\"{} \", now[i]);\n    }\n    println!(\"{}\", now[n-1]);*/\n\n    loop{\n        if !ok(&a) {\n            let n: usize = ans.len();\n            let b: usize = ans[n-k];\n            ans.push(b);\n            a[b-1] -= 1;\n            num += 1;\n        }\n        else {\n            let mut now: Vec<usize> = make_seq(&a);\n            if ans.len() == 0 {\n                ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n                num += k;\n            }\n            else {\n                let n: usize = ans.len();\n                let b: usize = ans[n-k];\n                let mut c = a.clone();\n                c[b-1] -= 1;\n                if (ok(&a) && now[0] < b) || !ok(&c) {\n                    ans.append(&mut now);\n                    for i in 0..k {\n                        a[i] -= 1;\n                    }\n                    num += k;\n                }\n                else {\n                    ans.push(b);\n                    a[b-1] -= 1;\n                    num += 1;\n                }\n            }\n        }\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all-1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all-1]);\n    \n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\nfn vecmax(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n    }\n    mx\n}\n\nfn vecmin(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mn = cmp::min(mn, v[i]);\n    }\n    mn\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mx: usize = vecmax(&a);\n    let mn: usize = vecmin(&a);\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(all);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::with_capacity(k+1);\n            let mut flag: bool;\n            for i in 0..(k-1) {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if ok(&c) {\n                    v_tmp.sort();\n                    v.push(v_tmp);\n                }\n                else {//この場合もうまくいくかもしれない\n                    let cmx: usize = vecmax(&c);\n                    let cmn: usize = vecmin(&c);\n\n                    if cmx == cmn * 2 + 1 {\n                        let mut v_tmp2: Vec<usize> = Vec::with_capacity(k);\n                        for j in (i+1)..k {\n                            v_tmp2.push(ans[n - k + j]);\n                        }\n                        let mut j: usize = 0;\n                        for i in 1..=k {\n                            if c[i - 1] == cmx {\n                                j = i;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] != cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] == cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        if j < k {\n                            for i in (j + 1)..=k {\n                                if v_tmp.contains(&i) {\n                                    v_tmp2.push(i);\n                                }\n                            }\n                        }\n                        let mut lastcmx: usize = 0;\n                        let mut firstcmn: usize = 0;\n                        for i in 0..k {\n                            if c[v_tmp2[i]-1] == cmx {\n                                lastcmx = i;\n                            }\n                        }\n                        for i in 0..k {\n                            if c[v_tmp2[i]-1] == cmn {\n                                firstcmn = i;\n                                break;\n                            }\n                        }\n                        if lastcmx < firstcmn {\n                            for _ in (i+1)..k {\n                                v_tmp2.remove(0);\n                            }\n                            v.push(v_tmp2);\n                        }\n                    }\n                }\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        \n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::new();\n            let mut flag: bool;\n            for i in 0..k {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                /*if !ok(&c) {\n                    continue;\n                }*/\n                v_tmp.sort();\n                v.push(v_tmp);\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        \n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::new();\n            let mut flag: bool;\n            for i in 0..k {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if !ok(&c) {\n                    continue;\n                }\n                v_tmp.sort();\n                v.push(v_tmp);\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        \n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n            num += k;\n        }\n        else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::new();\n            let mut flag: bool;\n            for i in 0..k {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n-k+j]);\n                    if a[ans[n-k+j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n-k+j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if !ok(&c) {\n                    continue;\n                }\n                v_tmp.sort();\n                v.push(v_tmp);\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n\n        /*\n        if !ok(&a) {\n            let n: usize = ans.len();\n            let b: usize = ans[n - k];\n            ans.push(b);\n            a[b - 1] -= 1;\n            num += 1;\n        } else {\n            let mut now: Vec<usize> = make_seq(&a);\n            if ans.len() == 0 {\n                ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n                num += k;\n            } else {\n                let n: usize = ans.len();\n                let b: usize = ans[n - k];\n                let mut c = a.clone();\n                c[b - 1] -= 1;\n                if (ok(&a) && now[0] < b) || !ok(&c) {\n                    ans.append(&mut now);\n                    for i in 0..k {\n                        a[i] -= 1;\n                    }\n                    num += k;\n                } else {\n                    ans.push(b);\n                    a[b - 1] -= 1;\n                    num += 1;\n                }\n            }\n        }\n        */\n\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\nfn vecmax(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n    }\n    mx\n}\n\nfn vecmin(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mn = cmp::min(mn, v[i]);\n    }\n    mn\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mx: usize = vecmax(&a);\n    let mn: usize = vecmin(&a);\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(all);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::with_capacity(k + 1);\n            let mut flag: bool;\n            for i in 0..(k - 1) {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if ok(&c) {\n                    v_tmp.sort();\n                    v.push(v_tmp);\n                } else {\n                    //この場合もうまくいくかもしれない\n                    let cmx: usize = vecmax(&c);\n                    let cmn: usize = vecmin(&c);\n\n                    if cmx == cmn * 2 + 1 {\n                        let mut v_tmp2: Vec<usize> = Vec::with_capacity(k);\n                        for j in (i + 1)..k {\n                            v_tmp2.push(ans[n - k + j]);\n                        }\n                        let mut j: usize = 0;\n                        for i in 1..=k {\n                            if c[i - 1] == cmx {\n                                j = i;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] != cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] == cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        if j < k {\n                            for i in (j + 1)..=k {\n                                if v_tmp.contains(&i) {\n                                    v_tmp2.push(i);\n                                }\n                            }\n                        }\n                        let mut lastcmx: usize = 0;\n                        let mut firstcmn: usize = 0;\n                        for i in 0..k {\n                            if c[v_tmp2[i] - 1] == cmx {\n                                lastcmx = i;\n                            }\n                        }\n                        for i in 0..k {\n                            if c[v_tmp2[i] - 1] == cmn {\n                                firstcmn = i;\n                                break;\n                            }\n                        }\n                        if lastcmx < firstcmn {\n                            for _ in (i + 1)..k {\n                                v_tmp2.remove(0);\n                            }\n                            v.push(v_tmp2);\n                        }\n                    }\n                }\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //可能かどうかの判定\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //不可能な場合を除外\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n\n    loop {\n        if !ok(&a) {\n            let n: usize = ans.len();\n            let b: usize = ans[n - k];\n            ans.push(b);\n            a[b - 1] -= 1;\n            num += 1;\n        } else {\n            let mut now: Vec<usize> = make_seq(&a);\n            if ans.len() == 0 {\n                ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n                num += k;\n            } else {\n                let n: usize = ans.len();\n                let b: usize = ans[n - k];\n                let mut c = a.clone();\n                c[b - 1] -= 1;\n                if (ok(&a) && now[0] < b) || !ok(&c) {\n                    ans.append(&mut now);\n                    for i in 0..k {\n                        a[i] -= 1;\n                    }\n                    num += k;\n                } else {\n                    ans.push(b);\n                    a[b - 1] -= 1;\n                    num += 1;\n                }\n            }\n        }\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  }
]