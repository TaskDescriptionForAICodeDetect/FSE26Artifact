[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define it register int\n#define ct const int\n#define il inline\nusing namespace std;\ntypedef long long ll;\n#define rll register ll\n#define cll const ll\n#define P 998244353\nconst int N=1005;\nint a[N],pl[N],pr[N],K,n,mx,m,mk,p[N];\nbool tag[N];\nint main(){ \n\tscanf(\"%d\",&K);it i,j;\n\tfor(i=1;i<=K;++i) scanf(\"%d\",&a[i]),n+=a[i],mx=(a[i]>mx?a[i]:mx),pl[i]=K,pr[i]=i;\n\tfor(i=1;i<=K;++i) if((a[i]<<1)<mx) return puts(\"-1\"),0;\n\tfor(i=1;i<=n;++i){\n\t\tfor(j=1;j<=K;++j)\n\t\t\tif(!tag[j]){\n\t\t\t\tmx=0;it flag=1;\n\t\t\t\tfor(it k=1;k<=K;++k) mx=(a[k]>mx?a[k]:mx);\n\t\t\t\tfor(it k=1;k<=pl[j];++k) a[pr[k]]-=(!tag[pr[k]]);\n\t\t\t\tfor(it k=1;k<=K;++k) if((a[k]<<1)+2<mx){flag=0;break;}\n\t\t\t\tif((a[j]<<1|1)<mx) flag=0;\n\t\t\t\tfor(it k=1;k<=pl[j];++k) a[pr[k]]+=(!tag[pr[k]]);\n\t\t\t\tif(flag) break;\n\t\t\t}\n\t\ttag[j]=1,p[i]=j,--a[j],++m,mk=(mk>pl[j]?mk:pl[j]);\n\t\tif(i>=K&&(i==K||m==mk)){for(j=1;j<=K;++j) tag[j]=0,pl[p[i+j-K]]=j,pr[j]=p[i+j-K];m=mk=0;}\n\t} \n\tfor(i=1;i<=n;++i) printf(\"%d \",p[i]);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[233];\nvector<int> ans,tx,ty;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(1)\n\t{\n\t\tint minn=114514,maxx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tminn=min(minn,a[i]);\n\t\t\tmaxx=max(maxx,a[i]);\n\t\t}\n\t\tif(maxx==0)break;\n\t\telse if(minn==0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttx.clear();ty.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]!=minn)tx.push_back(i),a[i]-=2;\n\t\t\telse ty.push_back(i),a[i]--;\n\t\t}\n\t\tfor(auto x:tx)ans.push_back(x);\n\t\tfor(auto x:ty)ans.push_back(x);\n\t\tfor(auto x:tx)ans.push_back(x);\n\t}\n\tfor(auto x:ans)cout<<x<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nbool validarray(vector<int>& a) {\n\tint mi = mod, ma = 0;\n\trep(i, a.size()) {\n\t\tif (a[i] < 0)return false;\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\treturn ma <= mi * 2;\n}\n\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\tif (!validarray(a)) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tint sum = 0;\n\trep(i, k)sum += a[i];\n\n\tint las = 0;\n\tvector<int> ans;\n\trep(i, sum) {\n\t\tvector<bool> b(k);\n\t\tfor (int j = las; j < ans.size(); j++) {\n\t\t\tb[ans[j]] = true;\n\t\t}\n\t\tint chk = -1;\n\t\tvector<bool> b2(k);\n\t\trep(j, k) {\n\t\t\tbool valid = false;\n\t\t\tif (b[j])continue;\n\t\t\tb2 = b;\n\t\t\tb2[j] = true;\n\t\t\tfor (int ex = 0; ex <= k; ex++) {\n\t\t\t\tif (las - ex < 0)break;\n\t\t\t\tif (ex > 0) {\n\t\t\t\t\tif (b2[ans[las - ex]])break;\n\t\t\t\t\tb2[ans[las - ex]] = true;\n\t\t\t\t}\n\n\n\t\t\t\t//cout << \"?! \" << i << \" \" << j <<\" \"<<ex<< \"\\n\";\n\t\t\t\tvector<int> cop = a;\n\n\t\t\t\tcop[j]--;\n\t\t\t\trep(x, k) {\n\t\t\t\t\tif (!b2[x])\n\t\t\t\t\tcop[x]--;\n\t\t\t\t}\n\n\n\t\t\t\tint mi = mod;\n\t\t\t\trep(x, k)mi = min(mi, cop[x]);\n\t\t\t\tif (mi < 0)continue;\n\n\t\t\t\tint len = ans.size() - (las - ex);\n\t\t\t\tint fl = 0;\n\t\t\t\tbool e = false;\n\t\t\t\trep(x, k)if (!b2[x]) {\n\t\t\t\t\tif (cop[x] > 2 * mi) {\n\t\t\t\t\t\tfl = len;\n\t\t\t\t\t\tcop[x]--;\n\t\t\t\t\t\te = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e)cop[j]--;\n\t\t\t\telse {\n\t\t\t\t\tif (cop[j] > 2 * mi) {\n\t\t\t\t\t\tfl = len;\n\t\t\t\t\t\tcop[j]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//cout << \"hello\\n\";\n\t\t\t\t\t\trep1(t, len) {\n\t\t\t\t\t\t\tif (cop[ans[ans.size() - t]] > 2 * mi) {\n\t\t\t\t\t\t\t\tfl = len+1 - t; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(t, fl)cop[ans[las - ex + t]]--;\n\t\t\t\t//cout << i << \" \" << j << \" \" << ex << \" \" << fl << \"\\n\";\n\t\t\t\tif (validarray(cop)) {\n\t\t\t\t\tvalid = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tchk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << chk+1 << \" \"<<las<<\"\\n\";\n\t\tassert(chk >= 0);\n\t\tans.push_back(chk);\n\t\ta[chk]--;\n\t\tif (ans.size() >= k) {\n\t\t\tvector<int> cnt(k, 0);\n\t\t\trep(j, k) {\n\t\t\t\tcnt[ans[ans.size() - 1 - j]]++;\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tif (valid) {\n\t\t\t\tlas = ans.size();\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint main(){\n  cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\nint last[101];\nstring R;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tif(*max_element(A,A+K)>*min_element(A,A+K)*2) return _P(\"-1\\n\");\n\tMINUS(last);\n\twhile(R.size()<N) {\n\t\t/*\n\t\tcout<<\"!\"<<R.size()<<\" \";\n\t\tFOR(i,4) cout<<A[i]<<\" \";\n\t\tcout<<endl;\n\t\t*/\n\t\tstring tar;\n\t\ttar.push_back(120);\n\t\tfor(int len=1;len<=K;len++) {\n\t\t\tif(R.size()+len<K) continue;\n\t\t\tif(R.size()+len>N) continue;\n\t\t\t\n\t\t\tint B[101];\n\t\t\tint did[101]={};\n\t\t\tFOR(i,K) B[i]=A[i];\n\t\t\tFOR(i,K-len) did[R[R.size()-1-i]]=1;\n\t\t\tstring cand;\n\t\t\tFOR(i,K) if(did[i]==0) cand.push_back(i),B[i]--;\n\t\t\tx=*max_element(B,B+K);\n\t\t\ty=*min_element(B,B+K);\n\t\t\tif(y<0 || x>2*y+1) continue;\n\t\t\t\n\t\t\tif(x==2*y+1) {\n\t\t\t\tstring AA,BB,CC;\n\t\t\t\tFOR(i,K) if(did[i]==0) {\n\t\t\t\t\tif(B[i]==x) AA.push_back(i);\n\t\t\t\t\telse if(B[i]==y) BB.push_back(i);\n\t\t\t\t\telse CC.push_back(i);\n\t\t\t\t}\n\t\t\t\tint ok=1;\n\t\t\t\tFOR(i,K) if(did[i]==0 && B[i]==x) {\n\t\t\t\t\tFOR(j,K) if(did[i]&&B[j]==y) ok=0;\n\t\t\t\t}\n\t\t\t\tif(ok==0) continue;\n\t\t\t\tcand.clear();\n\t\t\t\twhile(AA.size()+BB.size()+CC.size()) {\n\t\t\t\t\tif(AA.size()) {\n\t\t\t\t\t\tif(CC.size()&&CC[0]<AA[0]) {\n\t\t\t\t\t\t\tcand+=CC[0];\n\t\t\t\t\t\t\tCC.erase(CC.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcand+=AA[0];\n\t\t\t\t\t\t\tAA.erase(AA.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(BB.size()) {\n\t\t\t\t\t\tif(CC.size()&&CC[0]<BB[0]) {\n\t\t\t\t\t\t\tcand+=CC[0];\n\t\t\t\t\t\t\tCC.erase(CC.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcand+=BB[0];\n\t\t\t\t\t\t\tBB.erase(BB.begin());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcand+=CC[0];\n\t\t\t\t\t\tCC.erase(CC.begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\ttar=min(tar,cand);\n\t\t}\n\t\t\n\t\t//cout<<\"#\"<<tar.size()<<endl;\n\t\tR+=tar;\n\t\tFORR(a,tar) A[a]--;\n\t}\n\t\n\tFORR(c,R) cout<<((int)c+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint K;\nint A[111];\n\nbool valid() {\n    int ma = *max_element(A, A+K);\n    if (ma == 0) return true;\n    int mi = *min_element(A, A+K);\n    return mi * 2 >= ma;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &K);\n    REP (i, K) {\n\tint a;\n\tscanf(\"%d\", &a);\n\tA[i] = a;\n    }\n\n    if (!valid()) {\n\tputs(\"-1\");\n\treturn;\n    }\n\n    VI ans;\n    while (1) {\n\t// rprintf(\"%d\", A, A+K);\n\tif (*max_element(A, A+K) == 0) break;\n\n\tif (A[0] >= 2) {\n\t    REP (i, K) A[i]--;\n\t    A[0]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tans.push_back(0);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t\tA[0]++;\n\t    }\n\t}\n\n\t{\n\t    REP (i, K) A[i]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t    }\n\t}\n\t\t\n\tint ma = *max_element(A, A+K);\n\tVI once, twice;\n\tREP (i, K) {\n\t    if (A[i] == ma) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    }\n\t}\n\n\tassert(valid());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n\tans.insert(ans.end(), once.begin(), once.end());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n    }\n\n    EACH (e, ans) (*e)++;\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\tj=-1;\n\t\tFOR(i,K) if(A[i]==2*y) j=i;\n\t\tif(j==-1 && A[0]>y && (A[0]-2)*2>=y-1) j=0;\n\t\tvector<int> X,Y;\n\t\tFOR(i,K) {\n\t\t\tif(i<=j && A[i]>=2 && (A[i]-2)*2>=y-1) X.push_back(i),A[i]-=2;\n\t\t\telse Y.push_back(i),A[i]--;\n\t\t}\n\t\tFORR(c,X) V.push_back(c);\n\t\tFORR(c,Y) V.push_back(c);\n\t\tFORR(c,X) V.push_back(c);\n\t}\n\t\n\tFOR(i,N) cout<<V[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvector<int> ori;\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)ori.push_back(i);\n\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint num = 10000;\n\trep(i, n)num = min(num, a[i]);\n\trep(i, n)if (a[i] > 2 * num) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tassert(false);\n\tvector<vector<int>> ads(num);\n\trep(i, n) {\n\t\tint ad = a[i] - num;\n\t\trep(j, ad) {\n\t\t\tads[num - 1 - j].push_back(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(i, num) {\n\t\tint memo = ans.size();\n\t\tfor (int ad : ads[i]) {\n\t\t\tans.push_back(ad);\n\t\t}\n\t\tint las = 0;\n\t\trep(j, ads[i].size()) {\n\t\t\tvector<int> v;\n\t\t\tint g = memo + j;\n\t\t\tbool valid = false;\n\t\t\tif (g >= n - 1) {\n\t\t\t\trep(t, n) {\n\t\t\t\t\tv.push_back(ans[g - t]);\n\t\t\t\t}\n\t\t\t\tsort(all(v));\n\t\t\t\tif (v == ori)valid = true;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tlas++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvector<bool> skip(n,false);\n\t\trep(j, ads[i].size()) {\n\t\t\tif (j >= las)skip[ads[i][j]] = true;\n\t\t}\n\t\trep(i, n)if (!skip[i])ans.push_back(i);\n\t\trep(i, n)if (skip[i])ans.push_back(i);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\tvector<int> tet;\n\n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ttet.push_back(i+1);\n\t\t\tarr[i].first--;\n\t\t}\n\t}\n\n\tvector<vector<int> > blocks;\n\n\tint u = 0;\n\n\twhile (true) {\n\n\t\tauto kek = arr;\n\t\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\t\tkek[i].first--;\n\t\t}\n\n\t\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\t\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\t\tif (2*minimum.first < maximum.first) break;\n\t\ttet.push_back(u+1);\n\t\tu = (u+1)%n;\n\n\t\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\t\tarr = kek; \n\n\t}\n\n\tblocks.push_back(tet);\n\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\ttet.clear();\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tsort(all(big));\n\t\tsort(all(small));\n\n\t\tfor (int e = 0; e < big.size(); ++e) tet.push_back(big[e]+1);\n\t\tfor (int e = 0; e < small.size(); ++e) tet.push_back(small[e]+1);\n\t\tfor (int e = 0; e < big.size(); ++e) tet.push_back(big[e]+1);\n\n\t\tblocks.push_back(tet);\n\n\t}\n\n\tsort(all(blocks));\n\n\tfor (int i = 0; i < blocks.size(); ++i) for (int j = 0; j < blocks[i].size(); ++j) {\n\t\tcout << blocks[i][j] << \" \";\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    vector<int> two, one;\n    int min = A[0].first;\n    for (int i = 0; i < K; ++i) {\n      if (min * 2 == A[i].first) {\n        two.push_back(A[i].second);\n      }\n    }\n\n    sort(two.begin(), two.end());\n    if (two.size()) {\n      int max_two = two.back();\n      for (int i = 0; i < K; ++i) {\n        if (min < A[i].first && A[i].first < min * 2 && A[i].second < max_two) {\n          two.push_back(A[i].second);\n        }\n      }\n    }\n\n    sort(two.begin(), two.end());\n    set<int> S(two.begin(), two.end());\n    for (int i = 0; i < K; ++i) {\n      if (!S.count(A[i].second)) {\n        one.push_back(A[i].second);\n        A[i].first--;\n      } else {\n        A[i].first -= 2;\n      }\n    }\n\n    sort(one.begin(), one.end());\n    for (int x : two) cout << x + 1 << ' ';\n    for (int x : one) cout << x + 1 << ' ';\n    for (int x : two) cout << x + 1 << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\tint nxt = min(mh(), j==k-1? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tif (!p1valid(tst)) ++a[v], tst.pop_back();\n\t\t\t\t\telse {\n\t\t\t\t\t\t++a[v], nh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 111;\n\nint a[maxn], p[1111], n, k, tot, mn, mx;\n\nbool have[maxn];\nstd::vector<int> try_extend(std::vector<int> pre)\n{\n\tstatic int b[maxn], have[maxn];\n\t\n\tstd::vector<int> ret;\n\tfor(int i=1; i<=k; i++)\n\t{\n\t\tb[i] = a[i];\n\t\thave[i] = 0;\n\t}\n\tfor(auto v : pre) have[v] = 1;\n\tfor(int i=1; i<=k; i++) if(!have[i]) ret.pb(i);\n\t// printf(\"try size= %d mx= %d mn= %d\\n\", ret.size(), mx, mn);\n\t// for(int i=1; i<=k; i++) printf(\"i= %d c= %d\\n\", i, a[i]);\n\tfor(auto v : ret)\n\t{\n\t\tb[v]--;\n\t\tif(b[v] < 0) return std::vector<int>();\n\t}\n\tmx = *std::max_element(b+1, b+k+1);\n\tmn = *std::min_element(b+1, b+k+1);\n\tif(mx > mn * 2 + 1) return std::vector<int>();\n\t\n\tif(mx <= mn * 2) std::sort(ret.begin(), ret.end());\n\telse\n\t{\n\t\tstd::vector<int> good, other;\n\t\tfor(auto v : ret) if(b[v] != mx && b[v] != mn) good.pb(v); else if(b[v] == mx) other.pb(v);\n\t\tfor(auto v : ret) if(b[v] == mn) other.pb(v);\n\t\tint it1 = 0, it2 = 0;\n\t\t\n\t\tret.clear();\n\t\twhile(it1 < good.size() && it2 < other.size())\n\t\t{\n\t\t\tif(good[it1] < other[it2]) ret.pb(good[it1++]);\n\t\t\telse ret.pb(other[it2++]);\n\t\t}\n\t\twhile(it1 < good.size()) ret.pb(good[it1++]);\n\t\twhile(it2 < other.size()) ret.pb(other[it2++]);\n\t}\n\t\n\tif(mx == mn * 2 + 1)\n\t{\n\t\tbool haveMN = 0;\n\t\tfor(auto v : pre)\n\t\t{\n\t\t\tif(b[v] == mn) haveMN = 1;\n\t\t\telse if(b[v] == mx && haveMN) return std::vector<int>();\n\t\t}\n\t\tfor(auto v : ret)\n\t\t{\n\t\t\tif(b[v] == mn) haveMN = 1;\n\t\t\telse if(b[v] == mx && haveMN) return std::vector<int>();\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nvoid extend()\n{\n\tstd::vector<int> ext, tmp;\n\tif(tot == 0) ext = try_extend(std::vector<int>());\n\telse\n\t{\n\t\tfor(int i=std::max(0, tot + k - n); i < k; i++)\n\t\t{\n\t\t\ttmp.clear();\n\t\t\tfor(int j=tot-i+1; j<=tot; j++) tmp.pb(p[j]);\n\t\t\ttmp = try_extend(tmp);\n\t\t\tif(tmp.size() && (ext.size() == 0 || tmp < ext)) ext = tmp;\n\t\t}\n\t}\n\tassert(ext.size());\n\tfor(auto v : ext)\n\t{\n\t\tp[++tot] = v;\n\t\ta[v]--;\n\t}\n}\n\nint main()\n{\n\tget1(k);\n\tfor(int i=1; i<=k; i++)\n\t{\n\t\tget1(a[i]);\n\t\tn += a[i];\n\t}\n\t\n\tint mx = *std::max_element(a+1, a+k+1), mn = *std::min_element(a+1, a+k+1);\n\tif(mx > mn * 2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(tot < n) extend();\n\tfor(int i=1; i<=n; i++) printf(\"%d \", p[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\nbool seen[MAXVALS];\n\nvoid makeperm(vector<int>& perm,const vector<int> &suff) {\n\tperm = suff;\n\tREP(j, nvals) seen[j] = false;\n\tREPSZ(j, perm) seen[perm[j]] = true;\n\tREP(j, nvals) if (!seen[j]) perm.PB(j);\n}\n\nvector<int> calc(int nblock) {\n\tREP(i, nvals) rem[i] = cnt[i] - nblock;\n\tREP(i, nvals) if (rem[i] > nblock) return vector<int>();\n\n\tvector<vector<int>> suff(nblock);\n\tREP(i, rem[0]) suff[i].PB(0);\n\trem[0] = 0;\n\tvector<vector<int>> perm(nblock);\n\twhile (true) {\n\t\tint mxidx = -1;\n\t\tREP(i, nvals) if (rem[i] > 0 && (mxidx == -1 || rem[i] > rem[mxidx])) mxidx = i;\n\t\tif (mxidx == -1) break;\n\t\tint start = nblock - rem[mxidx];\n\t\tREP(i,start) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\n\t\tif (start - 1 >= 0) {\n\t\t\twhile (SZ(suff[start - 1]) < SZ(perm[start - 1])) {\n\t\t\t\tint x = perm[start - 1][SZ(suff[start - 1])];\n\t\t\t\tif (rem[x] == 0 || x > mxidx) break;\n\t\t\t\tsuff[start - 1].PB(x);\n\t\t\t\t--rem[x];\n\t\t\t}\n\t\t}\n\t\tREP(i, nvals) if (i <= mxidx) {\n\t\t\tREP(j, rem[i]) suff[start + j].PB(i);\n\t\t\trem[i] = 0;\n\t\t}\n\t}\n\tREP(i, nblock) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\tvector<int> ret;\n\tREP(i, nblock) {\n\t\tREPSZ(j, perm[i]) ret.PB(perm[i][j]);\n\t\tREPSZ(j, suff[i]) ret.PB(suff[i][j]);\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tbool ret = false;\n\tint mxblock = cnt[0]; FOR(i, 1, nvals) mxblock = min(mxblock, cnt[i]);\n\tFORE(i, 1, mxblock) {\n\t\tvector<int> cur = calc(i);\n\t\tif (SZ(cur) == 0) continue;\n\t\tif (ret == false || cur < ans) ret = true, ans = cur;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\tvi prev(k, -1);\n\n\trep(i,0,len){\n\t\tmx = 0, mn = 1000;\n\t\ttrav(x, a) mx = max(mx, x);\n\t\ttrav(x, a) mn = min(mn, x);\n\t\tint imx = 1000;\n\t\trep(d,0,k) if(a[d] == mn) imx = min(imx, prev[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx && !(mx=2*mn+1 && a[d] < mx && prev[d] > imx)){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans[i] < 0){\n\t\t\trep(j,0,i) cout << 1+ans[j] << \" \";\n\t\t\tcout << endl;\n\t\t\ttrav(x, a) cout << x << \" \";\n\t\t\tcout << endl;\n\n\t\t\tcout << mx << \" \" << mn << endl;\n\t\t\tcout << a[ans[i]] << endl;\n\t\t\tcout << imx << \" \" << prev[ans[i]] << endl;\n\t\t\tassert(false);\n\t\t}\n\t\tprev[ans[i]] = i;\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt) {\n\t\t\t\t\t++a[v];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,m,cnt,a[1111],k[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  while (cnt>0) {\n    m=0;\n    //printf(\"cnt=%d: \",cnt);\n    //for (i=1; i<=n; i++) printf(\"%d,\",a[i]);\n    for (i=1; a[i]>0; i++);\n    m=i-1;\n    for (; i<=n; i++) if (a[i]==cnt) m=i;\n    //printf(\"m=%d\\n\",m);\n    for (i=1; i<=m; i++) if (a[i]>0) printf(\"%d \",i);\n    for (i=1; i<=m; i++) if (a[i]==0) printf(\"%d \",i);\n    for (; i<=n; i++) printf(\"%d \",i);\n    for (i=1; i<=m; i++) if (a[i]>0) {\n      --a[i];\n      printf(\"%d \",i);\n    }\n    cnt--;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint N;\n\nvoid generate(vector<int> &src, vector<int> &dest) {\n\tvector<bool> flag(N, true);\n\tsort(src.begin(), src.end());\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t\tflag[src[i]] = false;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (flag[i] == true) {\n\t\t\tdest.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint K; cin >> K;\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tN = a.size();\n\tint M = 100000;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tchmin(M, a[i]);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i] > M * 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\tset<int> st;\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<int> sizes(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsizes[j] = a[j];\n\t\t}\n\t\tsort(sizes.begin(), sizes.end());\n\n\t\tvector<int> v;\n\t\tfor (auto itr = st.begin(); itr != st.end(); itr++) {\n\t\t\tv.push_back(*itr);\n\t\t}\n\t\tint m = N;\n\t\tif (v.size() > 0) {\n\t\t\tm = v[v.size() - 1];\n\t\t}\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tif (st.find(c) != st.end()) { continue; }\n\t\t\tbool f = true;\n\n\t\t\tint _m = sizes[0];\n\t\t\tchmin(_m, a[c] - 1);\n\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (a[k] > 2 * _m) { f = false; }\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tv.push_back(c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\ta[v[j]]--;\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j]--;\n\t\t}\n\n\t\tm = 100000;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tchmin(m, a[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (a[j] == m * 2) {\n\t\t\t\tst.insert(j);\n\t\t\t}\n\t\t}\n\n\t\tgenerate(v, ans);\n\t}\n\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1005;\nvector<int> inf;\nint n,k,a[N],b[N],ans[N],vis[N],now;\nbool check(){\n\tint x=*max_element(a+1,a+k+1);\n\tint y=*min_element(a+1,a+k+1);\n\treturn x<=2*y;\n}\nvoid merge(vector<int> &a,vector<int> &b,vector<int> &c){\n\tint posa=0,posb=0;\n\twhile(posa<a.size() && posb<b.size()){\n\t\tif(a[posa]<b[posb]) c.push_back(a[posa++]);\n\t\telse c.push_back(b[posb++]);\n\t}\n\twhile(posa<a.size()) c.push_back(a[posa++]);\n\twhile(posb<b.size()) c.push_back(b[posb++]);\n}\nvector<int> calc(int len){\n\t//cout<<len<<endl;\n\tfor(int i=1;i<=k;++i)\n\t\tb[i]=a[i],vis[i]=0;\n\tfor(int i=now+len-k+1;i<=now;++i)\n\t\tvis[ans[i]]=1;\n\tfor(int i=1;i<=k;++i)\n\t\tif(vis[i]==0){\n\t\t\t--b[i];\n\t\t\tif(b[i]<0) return inf;\n\t\t}\n\tint x=*max_element(b+1,b+k+1),\n\t\ty=*min_element(b+1,b+k+1);\n\t//cout<<x<<\" \"<<y<<endl;\n\tvector<int> res;\n\tif(x>2*y+1) return inf;\n\tif(x<=2*y){\n\t\tfor(int i=1;i<=k;++i)\n\t\t\tif(!vis[i]) res.push_back(i);\n\t\treturn res;\n\t}\n\tvector<int> A,B,all;\n\tfor(int i=1;i<=k;++i)\n\t\tif(!vis[i] && b[i]==x) A.push_back(i);\n\tfor(int i=1;i<=k;++i)\n\t\tif(!vis[i] && b[i]==y) A.push_back(i);\n\tfor(int i=1;i<=k;++i)\n\t\tif(!vis[i] && b[i]!=x && b[i]!=y) B.push_back(i);\n\tmerge(A,B,res);\n\tfor(int i=now+len-k+1;i<=now;++i)\n\t\tall.push_back(ans[i]);\n\tall.insert(all.end(),res.begin(),res.end());\n\tint pos_mx=-1,pos_mn=n+1;\n\tfor(int i=0;i<all.size();++i)\n\t\tif(b[all[i]]==x) pos_mx=max(pos_mx,i);\n\t\telse if(b[all[i]]==y) pos_mn=min(pos_mn,i);\n//\tfor(int i=0;i<all.size();++i)\n//\t\tcout<<all[i]<<\" \";cout<<endl;\n\tif(pos_mx>pos_mn) return inf;\n\telse return res;\n}\nint main(){\n\tcin>>k;\n\tfor(int i=1;i<=k;++i)\n\t\tcin>>a[i],n+=a[i];\n\tif(!check()) return puts(\"-1\"),0;\n\tinf.push_back(23333);\n\twhile(now<n){\n\t\tvector<int> S=inf;\n\t\tfor(int len=1;now+len<=n && len<=k;++len)\n\t\t\tif(now+len>=k) S=min(S,calc(len));\n\t\t//cout<<S.size()<<endl;\n\t\tfor(int i=0;i<S.size();++i)\n\t\t\tans[++now]=S[i],--a[S[i]];\n\t}\n\tfor(int i=1;i<=now;++i)cout<<ans[i]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"[DEBUG] \");W(__VA_ARGS__);}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1<<10;\nint a[101],n,K,now[101];\nint an[SIZE];\nint u[SIZE],tt;\nint u2[SIZE],tt2;\nbool good[SIZE];\nbool valid(int sep_pos){\n    tt++;\n    int ll=sep_pos;\n    for(int i=0;i<=sep_pos&&i<K;i++){\n        if(u[an[sep_pos-i]]==tt) break;\n        u[an[sep_pos-i]]=tt;\n        ll=sep_pos-i;\n    }\n    if(ll){\n        if(!good[ll-1])return 0;\n    }\n    memcpy(now,a,sizeof(int)*(K+1));\n    int mi=1001,ma=-1;\n    int ma_cnt=0;\n    FOR(i,1,K){\n        if(u[i]!=tt){\n            if(!now[i])return 0;\n            now[i]--;\n        }\n        mi=min(mi,now[i]);\n        if(ma<now[i]){\n            ma=now[i];\n            ma_cnt=1;\n        }\n        else if(ma==now[i]){\n            ma_cnt++;\n        }\n    }\n    if(mi*2>=ma)return 1;\n    FOR(i,ll,sep_pos){\n        if(!good[i]){\n            ll=i;\n            break;\n        }\n        int x=an[i];\n        if(!now[x])return 0;\n        if(now[x]==ma){\n            ma_cnt--;\n        }\n        u[x]=0;\n        now[x]--;\n        mi=min(mi,now[x]);\n        if(mi*2>=ma-(ma_cnt==0))return 1;\n    }\n    FOR(i,ll,sep_pos){\n        int x=an[i];\n        if(!now[x])return 0;\n        if(now[x]==ma){\n            ma_cnt--;\n        }\n        now[x]--;\n        mi=min(mi,now[x]);\n        if(mi*2>=ma-(ma_cnt==0))return 1;\n    }\n\n    \n    mi=1001,ma=-1;\n    ma_cnt=0;\n    FOR(i,1,K){\n        mi=min(mi,now[i]);\n        if(ma<now[i]){\n            ma=now[i];\n            ma_cnt=1;\n        }\n        else if(ma==now[i]){\n            ma_cnt++;\n        }\n    }\n\n    FOR(i,1,K){\n        if(u[i]!=tt&&now[i]==ma){\n            ma_cnt--;\n            if(mi*2>=ma-(ma_cnt==0))return 1;\n        }\n    }\n    return 0;\n}\nvoid solve() {\n    R(K);\n    FOR(i,1,K){\n        R(a[i]);\n        n+=a[i];\n    }\n    if(*max_element(a+1,a+1+K)>2*(*min_element(a+1,a+1+K))){\n        W(-1);\n        return;\n    }\n    REP(i,n){\n        FOR(j,1,K){\n            if(a[j]){\n                a[j]--;\n                an[i]=j;\n                if(valid(i))break;\n                a[j]++;\n            }\n        }\n        if(i>=K-1){\n            vector<int>ker(K+1);\n            REP(j,K){\n                ker[an[i-j]]=1;\n            }\n            if(count(ALL(ker),1)==K){\n                REP(j,K)good[i-j]=1;\n            }\n        }\n    }\n    W(VI(an,an+n));\n}\nint main(){\n#define MULTITEST 0\n#if MULTITEST    \n    CASET{\n        solve();\n    }\n#else\n    solve();\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[233];\nvector<int> ans,tx,ty;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(1)\n\t{\n\t\tint minn=114514,maxx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tminn=min(minn,a[i]);\n\t\t\tmaxx=max(maxx,a[i]);\n\t\t}\n\t\tif(maxx==0)break;\n\t\telse if(maxx>2*minn)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttx.clear();ty.clear();\n\t\tint zz=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]>2*minn-1)tx.push_back(i),a[i]-=2,zz=1;\n\t\t\telse if(a[i]>minn&&!zz)tx.push_back(i),a[i]-=2,zz=1;\n\t\t\telse ty.push_back(i),a[i]--;\n\t\t}\n\t\tfor(auto x:tx)ans.push_back(x);\n\t\tfor(auto x:ty)ans.push_back(x);\n\t\tfor(auto x:tx)ans.push_back(x);\n\t}\n\tfor(auto x:ans)cout<<x<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    for (int i = 0; i < K; ++i) cout << A[i].second + 1 << ' ';\n    for (int i = 1; i < K; ++i) {\n      if (A[0].first * 2 == A[i].first) {\n        cout << A[i].second + 1 << ' ';\n        --A[i].first;\n      }\n    }\n    for (int i = 0; i < K; ++i) --A[i].first;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint a[105], type[105];\nint main() {\n\tint k, m=0, max=0;\n\tscanf(\"%d\", &k);\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(m==0 || a[i]<a[m]) m=i;\n\t\tif(a[i]>max) max=a[i];\n\t}\n\tif(max>2*a[m]) return 0;\n\twhile(a[m]) {\n\t\tint max2=0;\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(a[i]==2*a[m]) {\n\t\t\t\ttype[i]=2;\n\t\t\t\tmax2=i;\n\t\t\t} else if(a[i]==a[m]) {\n\t\t\t\ttype[i]=1;\n\t\t\t} else {\n\t\t\t\ttype[i]=0;\n\t\t\t}\n\t\t}\n\t\tif(max2==0 && type[1]==0) {\n\t\t\tmax2=1;\n\t\t\ttype[1]=2;\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==0)\n\t\t\t\ttype[i] = i<max2?2:1;\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==2)\n\t\t\t\tprintf(\"%d \", i);\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==1)\n\t\t\t\tprintf(\"%d \", i);\n\t\t}\n\t\tfor(int i=1; i<=k; ++i) {\n\t\t\tif(type[i]==2)\n\t\t\t\tprintf(\"%d \", i);\n\t\t}\n\t\tfor(int i=1; i<=k; ++i)\n\t\t\ta[i]-=type[i];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nbool ok(vector<int> a){\n\twhile(1){\n\t\tconst int mn=*min_element(all(a));\n\t\tif(mn<0) return false;\n\t\tif(mn==*max_element(all(a))) return true;\n\t\tif(mn==0) return false;\n\t\tfor(auto &x:a){\n\t\t\tif(x==mn) --x;\n\t\t\telse x-=2;\n\t\t}\n\t}\n}\n\nvector<int> solve(vector<int> a){\n\tconst int n=a.size();\n\tif(!ok(a)){\n\t\treturn {};\n\t}\n\tvv<int> ls;\n\twhile(*min_element(all(a))<*max_element(all(a))){\n\t\tvector<int> large;\n\t\tint mn=*min_element(all(a));\n\t\tbool yametai=0;\n\t\trep(i,n){\n\t\t\tif(a[i]!=mn){\n\t\t\t\tlarge.pb(i);\n\t\t\t}else{\n\t\t\t\tyametai=1;\n\t\t\t}\n\t\t\tif(yametai){\n\t\t\t\tif(large.empty()) continue;\n\t\t\t\tauto b=a;\n\t\t\t\tfor(auto &x:b) --x;\n\t\t\t\tfor(auto i:large) b[i]--;\n\t\t\t\tif(ok(b)){\n\t\t\t\t\ta=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// out(large,1);\n\t\tls.eb(large);\n\t}\n\tconst int m=ls.size();\n\tvector<int> re;\n\trep(_,a[0])rep(i,n) re.pb(i);\n\trep(i,m){\n\t\tconst auto &large=ls[i];\n\t\tvector<int> small;\n\t\t{\n\t\t\tvector<int> usd(n);\n\t\t\tfor(int i:large) usd[i]=1;\n\t\t\trep(i,n)if(!usd[i]) small.pb(i);\n\t\t}\n\t\t// if(t && (i+1==m || small[0]<ls[i+1][0])){\n\t\t// \trep(_,t){\n\t\t// \t\tfor(auto i:large) re.pb(i);\n\t\t// \t\tfor(auto i:small) re.pb(i);\n\t\t// \t}\n\t\t// \tt=0;\n\t\t// }\n\t\tfor(auto i:large) re.pb(i);\n\t\tfor(auto i:small) re.pb(i);\n\t\tfor(auto i:large) re.pb(i);\n\t\t// out(i,re,1);\n\t}\n\treturn re;\n}\n\nint main(){\n\tif(0){\n\t\trep(_,1000){\n\t\tconst int n=rand()%6+1;\n\t\tconst int t=rand()%10+1;\n\t\tvector<int> ans;\n\t\trep(_,t){\n\t\t\tvector<int> p(n); iota(all(p),0); random_shuffle(all(p));\n\t\t\tint r=rand()%n;\n\t\t\tint t=rand()%2+1;\n\t\t\trep(_,t)for(int x:p) ans.pb(x);\n\t\t\trep(i,r) ans.pb(p[i]);\n\t\t}\n\t\tvector<int> a(n);\n\t\tfor(int x:ans) ++a[x];\n\t\tauto act=solve(a);\n\t\tif(act.empty()){\n\t\t\tout(ans,a,1);\n\t\t\treturn 0;\n\t\t}\n\t\t}\n\t\tout(\"done\",1);\n\t\treturn 0;\n\t}\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(auto &x:a) cin>>x;\n\tauto re=solve(a);\n\tif(re.empty()){\n\t\tcout<<-1 NL;\n\t}else{\n\t\trep(i,re.size()) cout<<re[i]+1<<\" \\n\"[i+1==re.size()];\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint N;\n\nvoid generate(vector<int> &src, vector<int> &dest) {\n\tvector<bool> flag(N, true);\n\tsort(src.begin(), src.end());\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t\tflag[src[i]] = false;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (flag[i] == true) {\n\t\t\tdest.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint K; cin >> K;\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tN = a.size();\n\tint M = 100000;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tchmin(M, a[i]);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i] > M * 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\tset<int> st;\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<int> sizes(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsizes[j] = a[j];\n\t\t}\n\t\tsort(sizes.begin(), sizes.end());\n\n\t\tvector<int> v;\n\t\tfor (auto itr = st.begin(); itr != st.end(); itr++) {\n\t\t\tv.push_back(*itr);\n\t\t}\n\t\tint m = N;\n\t\tif (v.size() > 0) {\n\t\t\tm = v[v.size() - 1];\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\ta[v[j]]--;\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tif (st.find(c) != st.end()) { continue; }\n\t\t\tbool f = true;\n\n\t\t\tint _m = sizes[0];\n\t\t\tchmin(_m, a[c] - 1);\n\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (a[k] > 2 * _m) { f = false; }\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tv.push_back(c);\n\t\t\t\ta[c]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j]--;\n\t\t}\n\n\t\tm = 100000;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tchmin(m, a[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (a[j] == m * 2) {\n\t\t\t\tst.insert(j);\n\t\t\t}\n\t\t}\n\n\t\tgenerate(v, ans);\n\t}\n\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[la] < sb[lb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[res[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= sum; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  while(1){\n    debug(t,res);\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    if(ma == 0)break;\n    int il = 0;\n    if(mi * 2 == ma){\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] != ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n          il++;\n          t[i]-=2;\n        }else{\n          t[i]--;\n        }\n      }\n    }else{\n      R(i,n){\n        res.PB(i);\n        t[i]--;\n      }\n    }\n//     int xx = n - il;\n//     int naj = 0;\n//     R(i,xx){\n//       \n//     }\n    while(il < n){\n      int pom = dajmi();\n      t[res[SZ(res) - n]]--;\n      int pom2 = dajmi();\n      debug(il,pom,pom2,res[SZ(res) - n]);\n      if(pom2 != MAX && res[SZ(res) - n] <= pom){\n        res.PB(res[SZ(res) - n]);\n        il++;\n      }else{\n        t[res[SZ(res) - n]]++;\n        break;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            //\n\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,j,cnt,lst,a[1111],k[1111],st[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  lst=cnt;\n  for (i=n; i>0; i--) if (a[i]>0) {\n    st[i]=min(lst,cnt-a[i]+1);\n    lst=min(lst,st[i]);\n  }\n  if (st[1]!=0) st[1]=1;\n  for (j=1; j<=cnt; j++) {\n    for (i=1; i<=n; i++) if (st[i]!=0 && j>=st[i] && j<st[i]+a[i]) printf(\"%d \",i);\n    for (i=1; i<=n; i++) if (!(st[i]!=0 && j>=st[i] && j<st[i]+a[i])) printf(\"%d \",i);\n    for (i=1; i<=n; i++) if (st[i]!=0 && j>=st[i] && j<st[i]+a[i]) printf(\"%d \",i);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[la] < sb[lb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[sa[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= sum; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\tj=-1;\n\t\tFOR(i,K) if(A[i]==2*y) j=i;\n\t\tif(j==-1 && A[0]>y && (A[0]-2)*2<=y-1) j=0;\n\t\tvector<int> X,Y;\n\t\tFOR(i,K) {\n\t\t\tif(i<=j && A[i]>y) X.push_back(i),A[i]-=2;\n\t\t\telse Y.push_back(i),A[i]--;\n\t\t}\n\t\tFORR(c,X) V.push_back(c);\n\t\tFORR(c,Y) V.push_back(c);\n\t\tFORR(c,X) V.push_back(c);\n\t}\n\t\n\tFOR(i,N) cout<<V[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e3+10;\nint n,cnt[N],s,m,ans[N];\n\nint b[N];\npoly res;\nbool vis[N];\ninline bool check(int len){\n\tint las=n-len;\n\tif (m-las+1<=0||m+len>s) return 0;\n\tFor(i,1,n) vis[i]=0;\n\tFor(i,m-las+1,m) vis[ans[i]]=1;\n\tint mn=1e9,mx=0;\n\tFor(i,1,n) b[i]=cnt[i]-(vis[i]^1),mn=min(mn,b[i]),mx=max(mx,b[i]);\n\tif (mn<0) return 0;\n\tres={};\n\tif (mn*2>=mx){\n\t\tFor(i,1,n) if (!vis[i]) res.pb(i);\n\t\treturn 1;\n\t} else if (mn*2+1==mx){\n\t\tpoly A,B;\n\t\tFor(i,1,n) if (!vis[i]&&b[i]==mx) A.pb(i);\n\t\tFor(i,1,n) if (!vis[i]&&b[i]==mn) A.pb(i);\n\t\tFor(i,1,n) if (!vis[i]&&b[i]!=mx&&b[i]!=mn) B.pb(i);\n\t\tint l1=0,l2=0;\n\t\twhile (l1<siz(A)||l2<siz(B)){\n\t\t\tif (l2==siz(B)) res.pb(A[l1++]);\n\t\t\telse if (l1==siz(A)) res.pb(B[l2++]);\n\t\t\telse if (A[l1]<B[l2]) res.pb(A[l1++]);\n\t\t\telse res.pb(B[l2++]);\n\t\t}\n\t\tint r=0,l=0;\n\t\tFor(i,1,las){\n\t\t\tif (b[ans[m-i+1]]==mx) r=i;\n\t\t\tif (b[ans[m-i+1]]==mn&&!l) l=i;\n\t\t}\n\t\tFOR(i,0,siz(res)){\n\t\t\tif (b[res[i]]==mx) r=las+i+1;\n\t\t\tif (b[res[i]]==mn&&!l) l=las+i+1; \n\t\t}\n\t\tif (r<l) return 1;\n\t\t\telse return 0;\n\t} else return 0;\n}\ninline bool check(poly a,poly b){\n\tint n=max(siz(a),siz(b));\n\ta.resize(n),b.resize(n);\n\tFOR(i,0,n) if (a[i]!=b[i]) return a[i]<b[i];\n\treturn 0;\n}\ninline void insert(){\n\tpoly ret;\n\tFor(i,1,n)\n\t\tif (check(i))\n\t\t\tif (ret.empty()||check(res,ret)) ret=res;\n\tfor (auto i:ret) ans[++m]=i,cnt[i]--;\n}\n\nint main(){\n\tn=read();\n\tint mx=0,mn=1e9;\n\tFor(i,1,n){\n\t\tcnt[i]=read(),s+=cnt[i];\n\t\tmx=max(mx,cnt[i]),mn=min(mn,cnt[i]);\n\t}\n\tif (mn*2<mx) return puts(\"-1\"),0;\n\twhile (m<s) insert();\n\tFor(i,1,m) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,j,cnt,lst,nxt,fi,a[1111],k[1111],st[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  for (j=cnt; j>=1; j--) {\n    lst=0;\n    for (i=1; i<=n; i++) if (a[i]==j) lst=i;\n    if (lst==0) {\n      if (j==1) {\n        for (i=1; i<=n; i++) printf(\"%d \",i);\n      } else {\n        nxt=0;\n        for (i=1; i<=n; i++) if (a[i]==j-1) nxt=i;\n        if (nxt) {\n          for (i=1; i<=nxt; i++) if (a[i]>1) { fi=i; break; }\n\t\t  if (fi==0 && a[1]>0) fi=1;\n        } else fi=1;\n        for (i=1; i<=fi; i++) if (a[i]>0) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]<=0) printf(\"%d \",i);\n        for (; i<=n; i++) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n      }\n    } else {\n      for (i=1; i<=lst; i++) if (a[i]>0) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]<=0) printf(\"%d \",i);\n      for (; i<=n; i++) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint k, a[105], p[1005], last[105], l=1;\nbool chk(int x, int y) {\n\tif(last[x]<l) {\n\t\tif(last[y]<l) {\n\t\t\treturn 2*a[x]>=a[y];\n\t\t} else {\n\t\t\treturn 2*a[x]>=a[y]+1;\n\t\t}\n\t} else {\n\t\tif(last[y]<l) {\n\t\t\treturn 2*a[x]+1>=a[y];\n\t\t} else {\n\t\t\tif(last[x]<last[y])\n\t\t\t\treturn 2*a[x]>=a[y];\n\t\t\telse\n\t\t\t\treturn 2*a[x]+1>=a[y];\n\t\t}\n\t}\n}\nbool check() {\n\tfor(int x=1; x<=k; ++x) {\n\t\tfor(int y=1; y<=k; ++y) {\n\t\t\tif(x==y) continue;\n\t\t\tif(!chk(x, y)) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint n=0;\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tn+=a[i];\n\t}\n\tif(!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint sat=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tint &P=p[i], lsave=l;\n\t\tif(i-l==k) {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=last[P]+1;\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t\tif(i-l+1==k) sat=i;\n\t\t} else {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0 || last[P]>sat) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=std::max(l, last[P]+1);\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) printf(\"%d \", p[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " /*\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\n\nusing namespace std;\ntemplate<typename T1, typename T2> inline void chkmin(T1 &a, T2 b) {if (a > b) a = b;}\ntemplate<typename T1, typename T2> inline void chkmax(T1 &a, T2 b) {if (a < b) a = b;}\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define left left228\n#define right right228\n#define y1 y1228\n#define mp make_pair\n#define pb push_back\n#define y2 y2228\n#define rank rank228\nusing ll = long long;\nusing ld = long double; \nconst string FILENAME = \"input\";\nconst int MAXN = 1028;\n\n\n\nint n, k;\nint a[MAXN];\nint pl[MAXN], pr[MAXN], p[MAXN];\nbool bl[MAXN];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n \t//read(FILENAME);\n \tcin >> k;\n \tint mx = 0;\n \tfor (int i = 1; i <= k; i++) {\n \t\tcin >> a[i];\n \t\tn += a[i];\n \t\tpl[i] = k, pr[i] = i;\n \t\tchkmax(mx, a[i]);\n \t}\n \tfor (int i = 1; i <= k; i++) {\n \t\tif (a[i] * 2 < mx) {\n \t\t\tcout << -1 << endl;\n \t\t\treturn 0;\n \t\t}\n \t}\n \tint mm = 0, mk = 0;\n \tfor (int i = 1; i <= n; i++) {\n \t\tint j = 1;\n \t\tfor (; j <= k; j++) {\n \t\t\tif (bl[j]) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbool bb = 1;\n \t\t\tmx = 0;\n \t\t\tfor (int is = 1; is <= k; is++) {\n \t\t\t\tchkmax(mx, a[is]);\n \t\t\t}\n \t\t\tfor (int is = 1; is <= pl[j]; is++) {\n \t\t\t\tif (!bl[pr[is]]) {\n \t\t\t\t\ta[pr[is]]--;\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor (int is = 1; is <= k; is++) {\n \t\t\t\tif (a[is] * 2 + 2 < mx) {\n \t\t\t\t\tbb = 0;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (a[j] * 2 + 1 < mx) {\n \t\t\t\tbb = 0;\n \t\t\t}\n \t\t\tfor (int is = 1; is <= pl[j]; is++) {\n \t\t\t\tif (!bl[pr[is]]) {\n \t\t\t\t\ta[pr[is]]++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (bb) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tbl[j] = 1;\n \t\tp[i] = j;\n \t\ta[j]--;\n \t\tmm++;\n \t\tchkmax(mk, pl[j]);\n \t\tif (i >= k && (i == k || mm == mk)) {\n \t\t\tfor (int j = 1; j <= k; j++) {\n \t\t\t\tbl[j] = 0;\n \t\t\t\tpl[p[i - k + j]] = j;\n \t\t\t\tpr[j] = p[i - k + j];\n \t\t\t}\n \t\t\tmm = 0;\n \t\t\tmk = 0;\n \t\t}\n \t}\n \tfor (int i = 1; i <= n; i++) {\n \t\tcout << p[i] << ' ';\n \t}\n \tcout << '\\n';\n\treturn 0;\t \t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\n\trep(i,0,len){\n\t\tmx = 0;\n\t\trep(d,0,k) mx = max(mx, a[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tassert(ans[i] >= 0);\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 1e3 + 50;\ncs int INF = 1e9 + 7;\nvoid ckmn(int &a, int b){ if(a > b) a = b; }\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\nint n, a[N], m, ans[N];\nint now[N], nxt[N], my;\nbool cmp(cs int &i, cs int &j){\n\tint x=a[i]==my,y=a[j]==my;\n\tif(x!=y)return x<y; return i<j;\n}\nbool work(int len){\n\tfor(int i=1;i<=len;i++)--a[now[i]];\n\tint mn=INF,mx=0;\n\tfor(int i=1; i<=n; i++)\n\tmn=min(mn,a[i]),mx=max(mx,a[i]);\n\t\n\tif(mn*2>=mx){\n\t\tfor(int i=1; i<=len; i++)\n\t\t++a[nxt[i]=now[i]];\n\t\tsort(nxt+1,nxt+len+1);\n\t\treturn true;\n\t}\n\t\n\tif(mn*2+1<mx){\n\t\tfor(int i=1; i<=len; i++) ++a[now[i]];\n\t\treturn false;\n\t}\n\t\n\tstatic int t1[N], t2[N]; int z1=0, z2=0;\n\tfor(int i=1; i<=len; i++)\n\tif(a[now[i]]==mn||a[now[i]]==mx)\n\tt1[++z1]=now[i]; else t2[++z2]=now[i]; \n\t\n\tmy=mn;\n\tsort(t1+1,t1+z1+1,cmp);\n\tsort(t2+1,t2+z2+1);\n\t\n\tfor(int i=1,p=1,q=1; i<=len; i++)\n\tif((p<=z1 && t1[p]<t2[q])||q>z2) nxt[i]=t1[p++];\n\telse nxt[i]=t2[q++];\n\t\n\tbool ok=true;\n\tfor(int i=len+1;i<=n;i++)ok&=(a[now[i]]!=mn);\n\tok|=(z1==0)|(a[t1[1]]==mn);\n\t\n\tfor(int i=1; i<=len; i++)++a[now[i]];\n\treturn ok;\n}\nbool cmp(int *a, int *b){ \n\tint i=1;for(;a[i]==b[i];i++);\n\treturn a[i]<b[i];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tint mn=INF,mx=0,sm=0;\n\tfor(int i=1; i<=n; i++)\n\tscanf(\"%d\",&a[i]),sm+=a[i],\n\tckmn(mn,a[i]),ckmx(mx,a[i]);\n\tfor(int i=1; i<=n; i++)\t\n\tnow[i]=i; if(!work(n))return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\n\tnow[i]=ans[++m]=nxt[i],--a[now[i]];\n\twhile(m<sm){\n\t\tstatic int trs[N];\n\t\tint len=0;trs[1]=n+1;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(work(i)&&cmp(nxt,trs))\n\t\t\tlen=i,memcpy(trs,nxt,sizeof(int)*(len+1));\n\t\t}\n\t\tfor(int i=1; i+len<=n; i++)\n\t\tnow[i]=now[i+len];\n\t\tfor(int i=1; i<=len; i++)\n\t\tnow[i+n-len]=ans[++m]=trs[i],--a[trs[i]];\n\t} for(int i=1; i<=m; i++)cout<<ans[i]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid swap(int *a, int *b)\n{\n\tint temp=*a;\n\t*a=*b;\n\t*b=temp;\n}\n\nint main() {\n\tint n;\n\tcin>>n;\n\tint arr[n];\n\tfor(int i=0;i<n;i++)\n\t\tcin>>arr[i];\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(i%2==0 && arr[i] > arr[i+1])\n\t\t\tswap(arr[i],arr[i+1]);\n\t\tif(i%2!=0 && arr[i] < arr[i+1])\n\t\t\tswap(arr[i],arr[i+1]);\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcout<<arr[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\nbool seen[MAXVALS];\n\nvoid makeperm(vector<int>& perm,const vector<int> &suff) {\n\tperm = suff;\n\tREP(j, nvals) seen[j] = false;\n\tREPSZ(j, perm) seen[perm[j]] = true;\n\tREP(j, nvals) if (!seen[j]) perm.PB(j);\n}\n\nvector<int> calc(int nblock) {\n\tREP(i, nvals) rem[i] = cnt[i] - nblock;\n\tREP(i, nvals) if (rem[i] > nblock) return vector<int>();\n\n\tvector<vector<int>> suff(nblock);\n\tREP(i, rem[0]) suff[i].PB(0);\n\trem[0] = 0;\n\tvector<vector<int>> perm(nblock);\n\twhile (true) {\n\t\tint mxidx = -1;\n\t\tREP(i, nvals) if (rem[i] > 0 && (mxidx == -1 || rem[i] > rem[mxidx])) mxidx = i;\n\t\tif (mxidx == -1) break;\n\t\tint start = nblock - rem[mxidx];\n\t\tREP(i,start) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\n\t\tif (start - 1 >= 0) {\n\t\t\twhile (SZ(suff[start - 1]) < SZ(perm[start - 1])) {\n\t\t\t\tint x = perm[start - 1][SZ(suff[start - 1])];\n\t\t\t\tif (rem[x] == 0) break;\n\t\t\t\tsuff[start - 1].PB(x);\n\t\t\t\t--rem[x];\n\t\t\t}\n\t\t}\n\t\tREP(i, nvals) if (i <= mxidx) {\n\t\t\tREP(j, rem[i]) suff[start + j].PB(i);\n\t\t\trem[i] = 0;\n\t\t}\n\t}\n\tREP(i, nblock) if (SZ(perm[i]) == 0) makeperm(perm[i], suff[i]);\n\tvector<int> ret;\n\tREP(i, nblock) {\n\t\tREPSZ(j, perm[i]) ret.PB(perm[i][j]);\n\t\tREPSZ(j, suff[i]) ret.PB(suff[i][j]);\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tbool ret = false;\n\tint mxblock = cnt[0]; FOR(i, 1, nvals) mxblock = min(mxblock, cnt[i]);\n\tFORE(i, 1, mxblock) {\n\t\tvector<int> cur = calc(i);\n\t\tif (SZ(cur) == 0) continue;\n\t\tif (ret == false || cur < ans) ret = true, ans = cur;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    while(a[1] > 0) {\n        --a[1];\n        vs[a[1]].insert(1);\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; a[i] > 0; ++ind) {\n                    --a[i];\n                    vs[ind].insert(i);\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tarr[i].first--;\n\t\t}\n\t}\n\n\tint u = 0;\n\twhile (true) {\n\n\t\tauto kek = arr;\n\t\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\t\tkek[i].first--;\n\t\t}\n\n\t\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\t\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\t\tif (2*minimum.first < maximum.first) break;\n\t\tcout << u+1 << \" \";\n\t\tu = (u+1)%n;\n\n\t\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\t\tarr = kek; \n\n\t}\n\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, deque<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\n\n\n\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  li n; cin>>n;\n  vi A(n); for(li i = 0; i < (li)(n); ++i) cin>>A[i];\n\n  vi I(n); iota(begin(I), end(I), 0);\n  sort(begin(I), end(I), [&](int i, int j) { return A[i] < A[j]; });\n\n  if(A[I[0]] > 2*A[I[n-1]]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int m = A[I[0]];\n  vector<vi> V(2*m);\n  for(li i = 0; i < (li)(n); ++i) {\n    if(i < I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*j+1].push_back(i);\n    } else if(i > I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j+1].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*m - 2*j - 2].push_back(i);\n    }\n  }\n\n  for(li i = 0; i < (li)(m); ++i) {\n    vector<int> seen1(n);\n    for(int a : V[2*i+1]) seen1[a] = 1;\n    vector<int> seen2(n);\n    for(int a : V[2*i]) seen2[a] = 1;\n    vi v2, w2, v1, w1;\n    for(int a : V[2*i]) if(seen[a]) v1.push_back(a); else w1.push_back(a);\n    for(int a : V[2*i+1]) if(seen[a]) v2.push_back(a); else w2.push_back(a);\n\n    sort(begin(v1), end(v1));\n    sort(begin(w1), end(w1));\n    sort(begin(v2), end(v2));\n    sort(begin(w2), end(w2));\n\n    for(int x : v1) cout << x+1 << ' ';\n    for(int x : w1) cout << x+1 << ' ';\n    cout << I[0]+1 << ' ';\n    for(int x : w2) cout << x+1 << ' ';\n    for(int x : v2) cout << x+1 << ' ';\n  }\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] != *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\twhile (sz < sum){\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tvector<int> A;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.push_back(q[j]);\n\t\t\t}\n\t\t\tsort(A.begin(), A.end());\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tvector<int> me;\n\t\t\tif (2*mnm+1 == mxm){\n\t\t\t\tint idx = -1;\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (a[A[j]] == mxm)\n\t\t\t\t\t\tidx = j;\n\t\t\t\tfor (int j = 0; j <= idx; j++){\n\t\t\t\t\tif (a[A[j]] == mnm)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp[++now] = A[j];\n\t\t\t\t\tme.push_back(A[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (j > idx or a[A[j]] == mnm)\n\t\t\t\t\t\tp[++now] = A[j], me.push_back(A[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tme = A;\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map> \n#define fr first\n#include<algorithm>\n#include<vector>\n#define sc second\nusing namespace std;\nconst int N=1100,inf=1e9;\nint n,k,a[N],ans[N],curlen;\ntypedef vector<int> vi;\nvoid merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1,l=0;\n\twhile(i<=len1&&j<=len2){if(x[i]<y[j])z[++l]=x[i++];else z[++l]=y[j++];}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[N], x[N], y[N], z[N], l1, l2, l3;bool vis[N];\nvi solve_ext(int exlen){l1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-exlen;i++){\n\t\t//if(vis[ans[curlen-i]])return vi(1,k+1);\n\t\tvis[ans[curlen-i]]=1;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vi(1,k+1);}\n\tint mn=inf,mx=0;\n\tfor(int i=1;i<=k;i++)mn=min(mn,b[i]),mx=max(mx,b[i]);\n\tif(mn*2>=mx){\n\t\tvi ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\n\t}else if(mn*2+1==mx){\n\t\tvi res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i]&&b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i]&&b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i]&&b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-exlen-1);i<=curlen;i++){\n\t\t\tif(b[ans[i]]==mx)p1=i;\n\t\t\tif(b[ans[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\t\t\t\n}\nbool bigger(vi a,vi b){\n\tfor(int i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;if(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\nvoid extend(){vi ext(1,k+1);\n\tfor(int exlen=1;exlen<=k&&exlen+curlen<=n;exlen++){\n\t\tint need=k-exlen;\n\t\tif(curlen-need+1>0){\n\t\t\tvi nw=solve_ext(exlen);\n\t\t\tif(bigger(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(int i=0;i<ext.size();i++)\n\t\tprintf(\"%d \",ext[i]),ans[++curlen]=ext[i],a[ext[i]]--;\n}\nbool check(){\n\tint mn=inf,mx=0;\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]),mn=min(mn,a[i]);\n\treturn mn*2>=mx;\t\n}\nint main(){//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){puts(\"-1\");return 0;}\n\twhile(curlen<n)extend();\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    if (a[1] > 0) {\n        for (int i = 1; i <= k; ++i) {\n            vs[i].insert(1);\n        }\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 10005, K = 10005;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) {\n\t\t\tlen = pre - i;\n\t\t\tbreak;\n\t\t}\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\t// if (pre == 6) debug(len);\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// for (int i = 1; i <= n; i++) debug(i), debug(b[i]);\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]v[E]\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]v[E]\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //N\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^n2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//s0ibit\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sortvx\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sortvx\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nll tail(vll &a, ll mx){\n\tdep(i, sz(a)-1, 0){\n\t\tif (a[i]==mx) return i;\n\t}\n\treturn -1;\n}\n\nvoid dump(vll &ans, vll &a, ll mn, ll mx){\n\tcoutv(a);\n\tcout << mn << \" \"<<mx<<'\\n';\n\tvll an=ans;\n\teach(e, an)e++;\n\tcoutv(an);\n}\n\n\nvoid solve()\n{\n\tll k;  cin >> k;\n\tvector<ll> a = cinv<ll>(k);\n\n\tll mn=MinE(a);\n\tll mx=MaxE(a);\n\tif (mx>mn*2){\n\t\tcout << -1 << '\\n'; return;\n\t}\n\n\tvll ans;\n\t//phase1\n\twhile (mx<mn*2){\n\t\trep(i, 0, k-1) ans.push_back(i);\n\t\teach(e, a) e--;\n\t\tmn--; mx--;\n\t\t//dump(ans, a, mn, mx);\n\t\tif (mx==mn*2 and a[0]==mn)break;\n\n\n\t\tans.push_back(0);\n\t\ta[0]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\t\t//dump(ans, a, mn, mx);\n\n\t\tif (mx==mn*2)break;\n\t\tif (mx>mn*2){\n\t\t\tll t=tail(a, mx);\n\t\t\trep(i, 1, t){\n\t\t\t\ta[i]--;\n\t\t\t\tans.push_back(i);\n\t\t\t}\n\t\t\tmx--;\n\t\t\t//dump(ans, a, mn, mx);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//phase2\n\twhile (a[0]>0){\n\t\tll t=tail(a, mx);\n\t\tvll fro, mid;\n\t\trep(i, 0, t){\n\t\t\tif (a[i]==mn){\n\t\t\t\tmid.push_back(i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfro.push_back(i);\n\t\t\t}\n\t\t}\n\t\trep(i, t+1, k-1){\n\t\t\tmid.push_back(i);\n\t\t}\n\t\teach(e, fro)ans.push_back(e);\n\t\teach(e, mid)ans.push_back(e);\n\t\teach(e, fro)ans.push_back(e);\n\t\t//\n\t\teach(e, fro)a[e]-=2;\n\t\teach(e, mid)a[e]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\t\t//dump(ans, a, mn, mx);\n\t}\n\n\teach(e, ans)e++;\n\tcoutv(ans);\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\n\tif(mn*2+1==mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tret=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n//\t\tfor(int i=1;i<=l3;i++){\n//\t\t\tcerr << z[i] << \" \";\n//\t\t}\n//\t\tputs(\"\");\n\t\tif(p1<p2)return ret;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tcerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";puts(\"\");\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n//\t\tcout << ext[i] << \" \";\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n//\tputs(\"\");\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nvoid ok()\n{\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng()\n{\n    cout << -1 << endl;\n    exit(0);\n}\n\nInt n;\nvector<Int> a(n + 1, INF);\nInt extra[110];\n\nint min_initial()\n{\n    Int mn = *min_element(a.begin(), a.end());\n    Int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        extra[i] = a[i] - mn;\n        if (extra[i] > mn)\n            return INF;\n        mx = max(mx, extra[i]);\n    }\n    if (mx <= mn)\n        return 1;\n    for (int i = 1; i <= n; i++)\n        if (extra[i] > 0)\n            return i;\n    exit(1);\n}\n\nvector<Int> ans;\nInt aa[110];\nInt cnt[1100];\nInt use[110];\n\nvoid push_min_permutation()\n{\n    Int mn = *min_element(a.begin(), a.end());\n    Int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        extra[i] = a[i] - mn;\n        if (extra[i] > mn)\n            return;\n        mx = max(mx, extra[i]);\n        use[i] = false;\n    }\n    if (mx < mn) {\n        for (int i = 1; i <= n; i++) {\n            a[i]--;\n            ans.push_back(i);\n        }\n        return;\n    }\n    int mxmx = n;\n    while (extra[mxmx] != mx)\n        mxmx--;\n    for (int i = 1; i <= mxmx; i++) {\n        if (extra[i] > 0)\n            use[i] = true;\n    }\n    for (int i = 1; i <= n; i++) {\n        a[i]--;\n        if (use[i])\n            ans.push_back(i);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!use[i])\n            ans.push_back(i);\n    }\n    return;\n}\n\nint min_initial2()\n{\n    if (ans.size() < n)\n        return INF;\n    Int mx = 0, mn = INF;\n    fill(cnt, cnt + 1001, 0);\n    for (int i = 1; i <= n; i++) {\n        aa[i] = a[i];\n        cnt[a[i]]++;\n        mx = max(mx, a[i]);\n        mn = min(mn, a[i]);\n    }\n    Int from = ans.size() - n;\n    for (int i = from; i < ans.size(); i++) {\n        cnt[aa[ans[i]]]--;\n        cnt[--aa[ans[i]]]++;\n        mn = min(mn, aa[ans[i]]);\n        if (cnt[mx] == 0)\n            mx--;\n        if (mn * 2 >= mx)\n            return ans[from];\n    }\n    return INF;\n}\n\nint main()\n{\n\n    cin >> n;\n    a.resize(n + 1, INF);\n    int as = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        as += a[i];\n    }\n\n    Int mn = *min_element(a.begin(), a.end());\n    vector<vector<Int>> block(mn);\n    for (int i = 1; i <= n; i++) {\n        extra[i] = a[i] - mn;\n        if (extra[i] > mn)\n            ng();\n    }\n    while (ans.size() < as) {\n        int initial1 = min_initial();\n        int initial2 = min_initial2();\n\n        if (initial1 < initial2) {\n            push_min_permutation();\n        }\n        else {\n            ans.push_back(initial2);\n            a[initial2]--;\n        }\n    }\n\n    for (auto elem : ans)\n        cout << elem << \" \";\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass EPermutationCover {\npublic:\n    vi solve(int k, arri a) {\n        vi p;\n        int lastPerm = 0;\n        arri last(k, -k);\n        while (true) {\n            int mx = *max_element(all(a));\n            if (mx == 0) {\n                break;\n            }\n            int minLast = p.size();\n            for (int i : range(k)) {\n                for (int j : range(k)) {\n                    if (a[i] > 2 * a[j]) {\n                        minim(minLast, last[j]);\n                    }\n                }\n            }\n            bool found = false;\n            for (int i : range(k)) {\n                if (a[i] == 0 || mx >= 2 * a[i] || last[i] > minLast) {\n                    continue;\n                }\n                bool bad = false;\n                for (int j : range(lastPerm, p.size())) {\n                    if (p[j] == i + 1) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    continue;\n                }\n                found = true;\n                last[i] = p.size();\n                a[i]--;\n                p.push_back(i + 1);\n                break;\n            }\n            if (!found) {\n                throw \"Jopa\";\n            }\n            if (*min_element(all(last)) >= p.size() - k) {\n                lastPerm = p.size();\n            }\n        }\n        return p;\n    }\n\n    void solve() {\n        int k = in.readInt();\n        auto a = in.readIntArray(k);\n\n        if (*min_element(all(a)) * 2 < *max_element(all(a))) {\n            out.printLine(-1);\n            return;\n        }\n        out.printLine(solve(k, a));\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    EPermutationCover solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n      assert(false);\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[i] <= num && num <= (a[i] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) len = pre - i;\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 1;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  while(1){\n    debug(t,res);\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    if(ma == 0)break;\n    int il = 0;\n    if(mi * 2 == ma){\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] != ma){\n          res.PB(i);\n        }\n      }\n      R(i,n){\n        if(t[i] == ma){\n          res.PB(i);\n          il++;\n          t[i]-=2;\n        }else{\n          t[i]--;\n        }\n      }\n    }else{\n      R(i,n){\n        res.PB(i);\n        t[i]--;\n      }\n    }\n    while(il < n){\n      int pom = dajmi();\n      t[res[SZ(res) - n]]--;\n      int pom2 = dajmi();\n      if(pom2 != MAX && res[SZ(res) - n] <= pom){\n        res.PB(res[SZ(res) - n]);\n        il++;\n      }else{\n        t[res[SZ(res) - n]]++;\n        break;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint k, a[105], p[1005], last[105], l=1, sat;\nbool chk(int x, int y) {\n\tif(last[x]<l) {\n\t\tif(last[y]<=sat) {\n\t\t\treturn 2*a[x]>=a[y];\n\t\t} else {\n\t\t\treturn 2*a[x]>=a[y]+1;\n\t\t}\n\t} else {\n\t\tif(last[x]<last[y])\n\t\t\treturn 2*a[x]>=a[y];\n\t\telse\n\t\t\treturn 2*a[x]+1>=a[y];\n\t}\n}\nbool check() {\n\tfor(int x=1; x<=k; ++x) {\n\t\tfor(int y=1; y<=k; ++y) {\n\t\t\tif(x==y) continue;\n\t\t\tif(!chk(x, y)) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint n=0;\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tn+=a[i];\n\t}\n\tif(!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tint &P=p[i], lsave=l;\n\t\tif(i-l==k) {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=last[P]+1;\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t\tif(i-l+1==k) sat=i;\n\t\t} else {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0 || last[P]>sat) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=std::max(l, last[P]+1);\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) printf(\"%d \", p[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 1111;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N], b[N];\nvector<int> s[N];\nbool f[N], pre[N];\nint main() {\n\tint k;\n\tscanf(\"%d\", &k);\n\tint x = 0;\n\tfor(int i = 1; i <= k; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx = max(x, a[i]);\n\t}\n\tmemcpy(b, a, sizeof(b));\n\tvector<int> aa;\n\tfor(;; x++) {\n\t\tbool flag = true;\n\t\tmemcpy(a, b, sizeof(a));\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tif(x - a[i] <= (x / 2)) {\n\n\t\t\t}else flag = false;\n\t\t}\n\t//\tcout << x << ' ' << flag << endl;\n\t\tif(!flag) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tfor(int i = 1; i < x; i++) s[i].clear();\n\t\tfor(int i = 1; i < x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(a[j] + (x - i) / 2 < x) {\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ta[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = k; j >= 1; j--) {\n\t\t\t\tif(a[j] < x && pre[j] == 0 && f[j] == 0 && !(s[i].size() == k - 1 && j == 1)) {\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\ta[j]++;\n\t\t\t\t}else if(f[j]) {\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tmemcpy(pre, f, sizeof(pre));\n\t\t}\n\t\tvector<int> ans;\n\t\tfor(int i = 1; i <= x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int k : s[i - 1]) f[k] = 1;\n\t\t\tfor(int k : s[i]) f[k] = 1;\n\t\t\tfor(int j = 1; j <= k; j++) if(!f[j]) ans.pb(j);\n\t\t\tif(i < x) {\n\t\t\t\tsort(s[i].begin(), s[i].end());\n\t\t\t\tfor(int j : s[i]) ans.pb(j);\n\t\t\t}\n\t\t}\n\t\tif(aa.empty() || ans < aa) aa = ans;\n\t}\n\tvector<int> ans;\n\tif(aa.empty()) {\n\n\t\tprintf(\"%d\\n\", -1);\n\t\treturn 0;\n\t}else ans = aa;\n\tfor(int i = 0; i < (int)ans.size(); i++) {\n\t\tprintf(\"%d%c\", ans[i], i == (int)ans.size() - 1 ? '\\n' : ' ');\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define ll long long\n\nconst int N = 303;\nconst int Q = N * 2;\nconst int mod = 998244353;\n\nusing namespace std;\n\nint n;\nint a[N];\nint b[N];\n\nbool good()\n{\n        int mn = a[1], mx = a[1];\n        for(int i = 2; i <= n; i++){\n                mn = min(mn, a[i]);\n                mx = max(mx, a[i]);\n        }\n        return mn * 2 >= mx;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        if(!good()){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n\n        while(a[1] > 0){\n                int mn = a[1], mx = a[1];\n                for(int i = 2; i <= n; i++){\n                        mn = min(mn, a[i]);\n                        mx = max(mx, a[i]);\n                }\n                vector < int > S1, S2;\n                for(int i = 1; i <= n; i++){\n                        if(a[i] == mn * 2){\n                                S1.push_back(i);\n                                b[i] = 2;\n                        } else{\n                                b[i] = 1;\n                        }\n                }\n                for(int i = 1; i <= n; i++){\n                        if(b[i] == 2){\n                                continue;\n                        }\n                        if((a[i] - 2) * 2 < mx - 1){\n                                break;\n                        }\n                        b[i] = 2;\n                        S1.push_back(i);\n                }\n                for(int i = 1; i <= n; i++) if(b[i] == 1) S2.push_back(i);\n                sort(S1.begin(), S1.end());\n                for(int x: S1) cout << x << \" \";\n                for(int x: S2) cout << x << \" \";\n                for(int x: S1) cout << x << \" \";\n                for(int i = 1; i <= n; i++) a[i] -= b[i];\n\n                assert(good());\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else if (!flag1) {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n            else {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tvi Ans;\n\t\tset<pii> S;\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=1;i<=k;i++) S.insert({H[i]-diff,-i});\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tset<pii> NS;\n\t\t\tint mn = (*S.begin()).first;\n\t\t\tif(mn==0) break;\n\t\t\tfor(auto p:S)\n\t\t\t{\n\t\t\t\tif(p.first==mn)\n\t\t\t\t{\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-1,p.second});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tD.push_back(-p.second);\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-2,p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Ans.size()==0)\n\t\t\t{\n\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t}\n\n\t\t\tS=NS;\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 2111;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N], b[N];\nvector<int> s[N];\nint k, L;\nint ans[N];\nint mm = 0;\nint f[105], cc[105], cnt[105], rmn[N], pos[N];\nbool check(int ed) {\n\tfor(int i = 1; i <= k; i++) {\n\t\trmn[i] = a[i] - cc[i] - (ans[ed] == i);\n\t\tif(rmn < 0) return false;\n\t}\n\tmemset(f, 0, sizeof(f));\n\tmemset(cnt, 0, sizeof(cnt));\n\tcnt[0] = k;\n\tif(ed - mm > k) return false;\n\tint mx = 0;\n\tmemset(f, 0, sizeof(f));\n\tfor(int i = ed; i >= 1; i--) {\n\t\tf[ans[i]]++;\n\t\tif(f[ans[i]] == 2) {mx = i; break; }\n\t}\n\tif(mx > mm) return false;\n\tmemset(f, 0, sizeof(f));\n\tfor(int i = mx + 1; i <= ed; i++) {\n\t\tf[ans[i]]++;\n\t\tpos[ans[i]] = i;\n\t\trmn[ans[i]]++;\n\t}\n//\tprintf(\"try a[%d] = %d\\n\", ed, ans[ed]);\n//\tcout << ed << ' ' << mx << ' ' << mm << endl;\n\tint x = 0;\n\tfor(int i = 1; i <= k; i++) x = max(x, rmn[i]);\n\tfor(int i = 1; i <= k; i++) {\n\t\tif(x - rmn[i] > x / 2) return false;\n\t}\n\t//cout << '?' << endl;\n\tfor(int j = mx + 2; j <= ed + 1; j++) {\n\t\tbool flag = true;\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tif((f[i] && pos[i] >= j || !f[i] && j != ed + 1) && x == rmn[i]) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tif(f[i] && pos[i] < j && x % 2 == 0 && x - rmn[i] == x / 2) flag = false;\n\t\t}\n\t\tif(flag) return true;\n\t}\n\treturn false;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint x = 0;\n\tL = 0;\n\tfor(int i = 1; i <= k; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx = max(x, a[i]);\n\t\tL += a[i];\n\t}\n\tmemcpy(b, a, sizeof(b));\n\tvector<int> aa;\n\tfor(int i = 1; i <= L; i++) {\n\t\tbool flag = false;\n\t\tfor(int j = 1; j <= k; j++) {\n\t\t\tans[i] = j;\n\t\t\tif(check(i)) {\n\t\t\t//\tprintf(\"%d!%d\\n\", i, ans[i]);\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcc[ans[i]]++;\n\t\tif(i >= k) {\n\t\t\tmemset(cnt, 0, sizeof(cnt));\n\t\t\tfor(int j = 1; j <= k; j++) cnt[ans[i - j + 1]]++;\n\t\t\tbool flag = true;\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(cnt[j] == 0) flag = false;\n\t\t\t}\n\t\t\tif(flag == true) mm = i;\n\t\t}\n\t\tif(!flag) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i <= L; i++) {\n\t\tprintf(\"%d%c\", ans[i], i == L ? '\\n' : ' ');\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010;\nint n, a[maxn], id[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0;i < n;++i)\n\t\tcin >> a[i];\n\tiota(id, id+n, 0);\n\tsort(id, id+n, [&](int x, int y) {\n\t\treturn a[x] > a[y];\n\t});\n\tif (a[id[n-1]] * 2 < a[id[0]])\n\t\treturn puts(\"-1\"), 0;\n\tvector<int> res;\n\tfor (int l = 1, r = a[id[0]];l <= a[id[n-1]];++l) {\n\t\tfor (int i = 0;i < n;++i)\n\t\t\tres.pb(id[i]);\n\t\tif (r > l) {\n\t\t\tfor (int i = 0;i < n;++i)\n\t\t\t\tif (a[id[i]] >= r)\n\t\t\t\t\tres.pb(id[i]);\n\t\t\t--r;\n\t\t}\n\t}\n\tfor (int i = 0;i < res.size();++i)\n\t\tcout << res[i] +1 << \" \\n\"[i+1==res.size()];\n\t\t\t\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 < *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n\n    unsigned long N{accumulate(begin(a), end(a), 0UL)};\n    unsigned long upb{N / (K + 1)}, lwb{(N + 2 * K - 2) / (2 * K - 1)};\n\n    vector<unsigned long> ans(N, K + 1);\n    for(unsigned long i{lwb}; i <= upb; ++i)[&]{\n        vector<unsigned long> yobun(K);\n        for(unsigned long j{0}; j < K; ++j){\n            if(a[j] < i)return;\n            if(a[j] > 2 * i)return;\n            yobun[j] = a[j] - i;\n        }\n        vector<unsigned long> tmp(N);\n        unsigned long now{0};\n        for(unsigned long j{0}; j < i; ++j){\n            vector<unsigned long> mae, naka;\n            for(unsigned long k{0}; k < K; ++k){\n                if(yobun[k] == 0)naka.push_back(k);\n                else if(yobun[k] == (i - j)){\n                    mae.push_back(k);\n                    --yobun[k];\n                }\n                else if(naka.empty()){\n                    mae.push_back(k);\n                    --yobun[k];\n                }\n                else naka.push_back(k);\n            }\n            copy(begin(mae), end(mae), begin(tmp) + now);\n            now += mae.size();\n            copy(begin(naka), end(naka), begin(tmp) + now);\n            now += naka.size();\n            copy(begin(mae), end(mae), begin(tmp) + now);\n            now += mae.size();\n        }\n        if(ans > tmp){\n            copy(begin(tmp), end(tmp), begin(ans));\n        }\n    }();\n\n    for(const auto& i : ans)cout << i + 1 << \" \";\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // ()\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  vector<int> nie(n);\n  int ilnie = 0;\n  while(1){\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    debug(ilnie);\n    \n    vector<int> zle(n);\n    R(i,n){\n      if(t[i] * 2 < ma){\n        zle[i] = 1;\n      }\n    }\n    int naj = 0;\n    R(i,min(SZ(res),n)){\n      if(zle[res[SZ(res) - i - 1]]){\n        naj = i;\n      }\n    }\n    R(i,naj){\n      zle[res[SZ(res) - i - 1]] = 1;\n    }\n    \n    \n    if(ma == 0)break;\n    R(i,n)if(!nie[i] && t[i] * 2 > ma && t[i] && !zle[i]){\n      debug(ma,t[i],i);\n      res.PB(i);\n      t[i]--;\n      nie[i] = 1;\n      ilnie++;\n      goto ok;\n    }\n    debug(res);\n    assert(0);\n    ok:;\n    if(SZ(res) >= n){\n      vector<int> cz(n);\n      bool nope = 0;\n      R(i,n){\n        if(cz[res[SZ(res) - i - 1]]){\n          nope = 1;\n          break;\n        }\n        cz[res[SZ(res) - i - 1]] = 1;\n      }\n      if(!nope){\n        ilnie = 0;\n        R(i,n)nie[i] = 0;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"[DEBUG] \");W(__VA_ARGS__);}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1<<10;\nint a[101],n,K,now[101];\nint an[SIZE];\nint u[SIZE],tt;\nint u2[SIZE],tt2;\nbool invalid(int id,int rr){\n    tt2++;\n    int v=0;\n    int it;\n    for(it=id;it<=rr;it++){\n        if(u2[an[it]]==tt2)break;\n        u2[an[it]]=tt2;\n        v++;\n    }\n    if(v==K)return 0;\n    for(int i=id-1;i>=0;i--){\n        if(u2[an[i]]==tt2){\n            bool suc=0;\n            while(it>id+1){\n                it--;\n                u2[an[it]]=0;\n                v--;\n                if(an[it]==an[i]){\n                    suc=1;\n                    break;\n                }\n            }\n            if(!suc)return 1;\n        }\n        v++;\n        u2[an[i]]=tt2;\n        if(v==K)return 0;\n    }\n    return 1;\n}\nbool valid(int sep_pos){\n    tt++;\n    int ll=sep_pos;\n    for(int i=0;i<=sep_pos&&i<K;i++){\n        if(u[an[sep_pos-i]]==tt) break;\n        u[an[sep_pos-i]]=tt;\n        ll=sep_pos-i;\n    }\n    if(ll){\n        if(invalid(ll-1,sep_pos))return 0;\n    }\n    memcpy(now,a,sizeof(int)*(K+1));\n    int mi=1001,ma=-1;\n    int ma_cnt=0;\n    FOR(i,1,K){\n        if(u[i]!=tt){\n            if(!now[i])return 0;\n            now[i]--;\n        }\n        mi=min(mi,now[i]);\n        if(ma<now[i]){\n            ma=now[i];\n            ma_cnt=1;\n        }\n        else if(ma==now[i]){\n            ma_cnt++;\n        }\n    }\n    if(mi*2>=ma)return 1;\n    FOR(i,ll,sep_pos){\n        int x=an[i];\n        if(!now[x])return 0;\n        if(now[x]==ma){\n            ma_cnt--;\n        }\n        now[x]--;\n        mi=min(mi,now[x]);\n        if(mi*2>=ma-(ma_cnt==0))return 1;\n    }\n    FOR(i,1,K){\n        if(u[i]!=tt&&now[i]==ma){\n            ma_cnt--;\n            if(mi*2>=ma-(ma_cnt==0))return 1;\n        }\n    }\n    return 0;\n}\nvoid solve() {\n    R(K);\n    FOR(i,1,K){\n        R(a[i]);\n        n+=a[i];\n    }\n    if(*max_element(a+1,a+1+K)>2*(*min_element(a+1,a+1+K))){\n        W(-1);\n        return;\n    }\n    REP(i,n){\n        FOR(j,1,K){\n            if(a[j]){\n                a[j]--;\n                an[i]=j;\n                if(valid(i))break;\n                a[j]++;\n            }\n        }\n    }\n    W(VI(an,an+n));\n}\nint main(){\n#define MULTITEST 0\n#if MULTITEST    \n    CASET{\n        solve();\n    }\n#else\n    solve();\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>0){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvector<int> ori;\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)ori.push_back(i);\n\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint num = 10000;\n\trep(i, n)num = min(num, a[i]);\n\trep(i, n)if (a[i] > 2 * num) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tvector<vector<int>> ads(num);\n\trep(i, n) {\n\t\tint ad = a[i] - num;\n\t\trep(j, ad) {\n\t\t\tads[num - 1 - j].push_back(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(i, num) {\n\t\tint memo = ans.size();\n\t\tfor (int ad : ads[i]) {\n\t\t\tans.push_back(ad);\n\t\t}\n\t\tint las = 0;\n\t\trep(j, ads[i].size()) {\n\t\t\tvector<int> v;\n\t\t\tint g = memo + j;\n\t\t\tbool valid = false;\n\t\t\tif (g >= n - 1) {\n\t\t\t\trep(t, n) {\n\t\t\t\t\tv.push_back(ans[g - t]);\n\t\t\t\t}\n\t\t\t\tsort(all(v));\n\t\t\t\tif (v == ori)valid = true;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tlas++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvector<bool> skip(n,false);\n\t\trep(j, ads[i].size()) {\n\t\t\tif (j >= las)skip[ads[i][j]] = true;\n\t\t}\n\t\trep(i, n)if (!skip[i])ans.push_back(i);\n\t\trep(i, n)if (skip[i])ans.push_back(i);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:45:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  {\n    int mn = *min_element(a.begin(), a.end());\n    int mx = *max_element(a.begin(), a.end());\n    if (2 * mn < mx) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  vector<int> b(n);\n  auto Can = [&]() {\n//    debug(a, b);\n    vector<int> c(n);\n    int mn = 787788;\n    int mx = -787788;\n    for (int i = 0; i < n; i++) {\n      if (b[i] == 0) {\n        c[i] = -1;\n        mn = min(mn, a[i] - 1);\n        mx = max(mx, a[i] - 2);\n      } else {\n        c[i] = a[i] - b[i];\n        mn = min(mn, c[i]);\n        mx = max(mx, c[i]);\n      }\n    }\n    if (mn < 0 || mx < 0 || 2 * mn < mx) {\n      return false;\n    }\n    return true;\n  };\n  auto One = [&]() {\n    if (*max_element(a.begin(), a.end()) == 0) {\n      return vector<int>();\n    }\n    int pos = 0;\n    while (true) {\n      for (int i = pos; i < n; i++) {\n        b[i] = 1;\n      }\n      if (Can()) {\n        break;\n      }\n      for (int i = pos; i < n; i++) {\n        b[i] = 0;\n      }\n      bool found = false;\n      for (int i = pos; i < n; i++) {\n        b[i] = 2;\n        if (Can()) {\n          pos = i + 1;\n          found = true;\n          break;\n        }\n        b[i] = 1;\n      }\n      assert(found);\n    }\n    vector<int> ter;\n    for (int x : {2, 1, 2}) {\n      for (int i = 0; i < n; i++) {\n        if (b[i] == x) {\n          ter.push_back(i);\n        }\n      }\n    }\n    return ter;\n  };\n  vector<int> ret;\n  while (*max_element(a.begin(), a.end()) > 0) {\n    bool done = false;\n    vector<int> best;\n    int bcut = -1;\n    for (int cut = 1; cut < n; cut++) {\n      for (int i = 0; i < cut; i++) {\n        b[i] = 2;\n      }\n      for (int i = cut; i < n; i++) {\n        b[i] = 1;\n      }\n      if (Can()) {\n        auto bb = b;\n        for (int i = 0; i < n; i++) {\n          a[i] -= bb[i];\n        }\n        auto help = One();\n        for (int i = 0; i < n; i++) {\n          a[i] += bb[i];\n        }\n        vector<int> cur;\n        for (int i = 0; i < n; i++) {\n          cur.push_back(i);\n        }\n        for (int i = 0; i < cut; i++) {\n          cur.push_back(i);\n        }\n        for (int x : help) {\n          cur.push_back(x);\n        }\n        debug(cut, cur);\n        if (best.empty() || cur < best) {\n          best = cur;\n          bcut = cut;\n        }\n      }\n    }\n    if (bcut != -1) {\n      for (int i = 0; i < bcut; i++) {\n        b[i] = 2;\n      }\n      for (int i = bcut; i < n; i++) {\n        b[i] = 1;\n      }\n      done = true;\n    }\n    if (!done) {\n      fill(b.begin(), b.end(), 0);\n      int pos = 0;\n      while (true) {\n        for (int i = pos; i < n; i++) {\n          b[i] = 1;\n        }\n        if (Can()) {\n          break;\n        }\n        for (int i = pos; i < n; i++) {\n          b[i] = 0;\n        }\n        bool found = false;\n        for (int i = pos; i < n; i++) {\n          b[i] = 2;\n          if (Can()) {\n            pos = i + 1;\n            found = true;\n            break;\n          }\n          b[i] = 1;\n        }\n        assert(found);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      a[i] -= b[i];\n    }\n    for (int x : {2, 1, 2}) {\n      for (int i = 0; i < n; i++) {\n        if (b[i] == x) {\n          ret.push_back(i);\n        }\n      }\n    }\n  }\n  int sz = (int) ret.size();\n  vector<int> was(n, 0);\n  bool changed = true;\n  while (changed) {\n    changed = false;\n    for (int i = 0; i < sz - 1; i++) {\n      if (ret[i] > ret[i + 1]) {\n        swap(ret[i], ret[i + 1]);\n        for (int j = 0; j < n; j++) {\n          was[j] = 0;\n        }\n        bool ok = true;\n        int R = -1;\n        for (int j = 0; j < n; j++) {\n          if (was[ret[j]] == 1) {\n            ok = false;\n            break;\n          }\n          was[ret[j]] = 1;\n        }\n        int zeros = 0;\n        if (ok) {\n          R = n - 1;\n          for (int j = n; j < sz; j++) {\n            --was[ret[j - n]];\n            if (was[ret[j - n]] == 0) {\n              ++zeros;\n            }\n            if (was[ret[j]] == 0) {\n              --zeros;\n            }\n            ++was[ret[j]];\n            if (zeros == 0) {\n              int nL = j - n + 1;\n              int nR = j;\n              if (nL > R + 1) {\n                ok = false;\n                break;\n              }\n              R = nR;\n            }\n          }\n          if (R < sz - 1) {\n            ok = false;\n          }\n        }\n        if (ok) {\n          changed = true;\n        } else {\n          swap(ret[i], ret[i + 1]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < (int) ret.size(); i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << ret[i] + 1;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\nint pst=0;\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>pst){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tpst=curlen;\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nvoid ok()\n{\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng()\n{\n    cout << -1 << endl;\n    exit(0);\n}\n\nstruct Trie {\n    map<Int, Trie *> edge;\n    bool exist = false;\n};\n\nbool used[110];\n\nInt n;\nvector<Int> ans;\n\nint main()\n{\n\n    cin >> n;\n    vector<Int> a(n + 1, INF);\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n\n    Int mn = *min_element(a.begin(), a.end());\n    vector<vector<Int>> block(mn);\n    for (int i = 1; i <= n; i++) {\n        if (a[i] - mn > mn)\n            ng();\n        for (int j = 0; j < a[i] - mn; j++) {\n            block[j].push_back(i);\n        }\n    }\n\n    sort(block.begin(), block.end());\n\n    for (auto b : block) {\n        for (auto elem : b) {\n            used[elem] = true;\n            ans.push_back(elem);\n        }\n        for (int i = 1; i <= n; i++) {\n            if (!used[i])\n                ans.push_back(i);\n        }\n        for (auto elem : b) {\n            used[elem] = false;\n            ans.push_back(elem);\n        }\n    }\n    for (auto elem : ans)\n        cout << elem << \" \";\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>  \n#include <complex>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 998244353;\ndouble eps = 1e-12;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e18\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n \nll mpow(ll a, ll b){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2);\n\tt1 *= t1;\n\tt1 %= MOD;\n\tif(b%2) t1 *= a;\n\tt1 %= MOD;\n\treturn t1;\n}\n \nll mpow(ll a, ll b, ll p){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2,p);\n\tt1 *= t1;\n\tt1 %= p;\n\tif(b%2) t1 *= a;\n\tt1 %= p;\n\treturn t1;\n}\n \nll modinverse(ll a, ll m){\n\tll m0 = m; \n    ll y = 0, x = 1; \n    if (m == 1) return 0; \n    while (a > 1){\n        ll q = a / m; \n        ll t = m; \n        m = a % m, a = t; \n        t = y; \n        y = x - q * y; \n        x = t; \n    }\n    if (x < 0) x += m0; \n    return x; \n}\n\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n \nll range(ll l, ll r){\n\treturn l + mt()%(r-l+1);\n}\n \nll rev(ll v){\n\treturn mpow(v,MOD-2);\n}\n\nvoid solve(){\n\tll n;\n\tcin >> n;\n\tll a[n];\n\tll mn = 1000;\n\tforn(i,n){\n\t\tcin >> a[i];\n\t\tmn = min(mn,a[i]);\n\t}\n\tv64 arr[mn];\n\tll st = mn;\n\trforn(i,n-1){\n\t\tif(a[i]>2*mn){\n\t\t\tcout << -1 << ln;\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tst = min(st,2*mn-a[i]);\n\t\t\tif(i==0) st=0;\n\t\t\tforsn(j,st,st+a[i]-mn) arr[j].pb(i);\n\t\t}\n\t}\n\tforn(i,mn){\n\t\tv64 pr(n,0);\n\t\trforn(j,sz(arr[i])-1){\n\t\t\tcout << arr[i][j]+1 << \" \";\n\t\t\tpr[arr[i][j]]=1;\n\t\t}\n\t\tforn(j,n) if(!pr[j]) cout << j+1 << \" \";\n\t\trforn(j,sz(arr[i])-1){\n\t\t\tcout << arr[i][j]+1 << \" \";\n\t\t}\n\t}\n\tcout << ln;\n}\n \nint main()\n{\n\tfast_cin();\n    ll t=1;\n    // cin >> t;\n    forn(i,t) {\n    \t// cout << \"Case #\" << i+1 << \": \";\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,cnt,a[1111],k[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  while (cnt--) {\n    for (i=0; i<n; i++) printf(\"%d \",k[i]);\n    for (i=0; i<n; i++) if (a[k[i]]>0) {\n      --a[k[i]];\n      printf(\"%d \",k[i]);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, deque<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\n\n\n\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  li n; cin>>n;\n  vi A(n); for(li i = 0; i < (li)(n); ++i) cin>>A[i];\n\n  vi I(n); iota(begin(I), end(I), 0);\n  sort(begin(I), end(I), [&](int i, int j) { return A[i] < A[j]; });\n\n  if(A[I[0]] > 2*A[I[n-1]]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int m = A[I[0]];\n  vector<vi> V(2*m);\n  for(li i = 0; i < (li)(n); ++i) {\n    if(i < I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*j+1].push_back(i);\n    } else if(i > I[0]) {\n      for(li j = 0; j < (li)(m); ++j) V[2*j+1].push_back(i);\n      for(li j = 0; j < (li)(A[i]-m); ++j) V[2*m - 2*j - 2].push_back(i);\n    }\n  }\n\n  for(li i = 0; i < (li)(m); ++i) {\n    vector<int> seen1(n);\n    for(int a : V[2*i+1]) seen1[a] = 1;\n    vector<int> seen2(n);\n    for(int a : V[2*i]) seen2[a] = 1;\n    vi v2, w2, v1, w1;\n    for(int a : V[2*i]) if(seen1[a]) v1.push_back(a); else w1.push_back(a);\n    for(int a : V[2*i+1]) if(seen2[a]) v2.push_back(a); else w2.push_back(a);\n\n    sort(begin(v1), end(v1));\n    sort(begin(w1), end(w1));\n    sort(begin(v2), end(v2));\n    sort(begin(w2), end(w2));\n\n    for(int x : v1) cout << x+1 << ' ';\n    for(int x : w1) cout << x+1 << ' ';\n    cout << I[0]+1 << ' ';\n    for(int x : w2) cout << x+1 << ' ';\n    for(int x : v2) cout << x+1 << ' ';\n  }\n  cout << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repn(i, n) for(int i=1;i<=n;i++)\n\nint n, k, a[105], b[105], ans[1005], mn=100000, mx=-100000;\nint main(){\n\tcin >> k;\n\trepn(i, k){\n\t\tcin >> a[i];\n\t\tn += a[i];\n\t\tmn = min(mn, a[i]);\n\t\tmx = max(mx, a[i]);\n\t}\n\tif(2*mn < mx){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tint las = 0;\n\trepn(id, n){\n\t\trepn(i, k){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tbool OK = 0;\n\t\t\tfor(int add=0;;add++){\n\t\t\t\tif(n-id < add || add+id-las > k) break;\n\t\t\t\tmemcpy(b, a, sizeof(a));\n\t\t\t\tb[i]--;\n\t\t\t\tbool ex[105] = {};\n\t\t\t\tfor(int x=id+add-k+1;x<id;x++) ex[ans[x]] = 1;\n\t\t\t\tex[i] = 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\trepn(x, k){\n\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\tcnt++; if(a[x] == 0) cnt++; b[x]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt != add) continue;\n\t\t\t\tif(n-id-add <= k){\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] > 1) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\t\tif(b[x] == 0) b[x]++;\n\t\t\t\t\t\t\t\telse bad = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(b[v] >= 1) break;\n\t\t\t\t\t\t\telse b[v]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k) if(b[x] != 1) bad = 1;\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmn = 100000, mx = -100000;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tmn = min(mn, b[x]);\n\t\t\t\t\t\tmx = max(mx, b[x]);\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn >= mx){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn+1 < mx){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbool need[105] = {};\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] == mx) need[x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\tif(need[x] == 1) bad = 1;\n\t\t\t\t\t\t\tneed[x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(need[v]) break;\n\t\t\t\t\t\t\tneed[v] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!need[x] && mn == b[x]) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t\t\tans[id] = i;\n\t\t\t\tif(id >= k){\n\t\t\t\t\tunordered_set<int>S;\n\t\t\t\t\tfor(int i=id-k+1;i<=id;i++) S.insert(ans[i]);\n\t\t\t\t\tif(S.size() == k) las = id;\n\t\t\t\t}\n\t\t\t\ta[i]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans[id] << ' ';\n\t}\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    if (a[1] > 0) {\n        for (int i = 1; i <= k; ++i) {\n            for (int j = cr; j >= cl; --j) {\n                if (a[i] == 0) {\n                    cl = j + 1;\n                    break;\n                }\n                --a[i];\n                vs[j].insert(i);\n            }\n        }\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    vector<int> two, one;\n    int min = A[0].first;\n    for (int i = 0; i < K; ++i) {\n      if (min * 2 == A[i].first) {\n        two.push_back(A[i].second);\n        A[i].first -= 2;\n      } else {\n        A[i].first -= 1;\n        one.push_back(A[i].second);\n      }\n    }\n    sort(two.begin(), two.end());\n    sort(one.begin(), one.end());\n    for (int x : two) cout << x + 1 << ' ';\n    for (int x : one) cout << x + 1 << ' ';\n    for (int x : two) cout << x + 1 << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nbool validarray(vector<int>& a) {\n\tint mi = mod, ma = 0;\n\trep(i, a.size()) {\n\t\tif (a[i] < 0)return false;\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\treturn ma <= mi * 2;\n}\n\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\tif (!validarray(a)) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tint sum = 0;\n\trep(i, k)sum += a[i];\n\n\tint las = 0;\n\tvector<int> ans;\n\trep(i, sum) {\n\t\tvector<bool> b(k);\n\t\tfor (int j = las; j < ans.size(); j++) {\n\t\t\tb[ans[j]] = true;\n\t\t}\n\t\tint chk = -1;\n\t\tvector<bool> b2(k);\n\t\trep(j, k) {\n\t\t\tbool valid = false;\n\t\t\tif (b[j])continue;\n\t\t\tb2 = b;\n\t\t\tb2[j] = true;\n\t\t\tfor (int ex = 0; ex <= k; ex++) {\n\t\t\t\tif (las - ex < 0)break;\n\t\t\t\tif (ex > 0) {\n\t\t\t\t\tif (b2[ans[las - ex]])break;\n\t\t\t\t\tb2[ans[las - ex]] = true;\n\t\t\t\t}\n\n\n\t\t\t\t//cout << \"?! \" << i << \" \" << j <<\" \"<<ex<< \"\\n\";\n\t\t\t\tvector<int> cop = a;\n\n\t\t\t\tvector<int> cs;\n\t\t\t\tfor (int loc = las - ex; loc < ans.size();loc++)cs.push_back(ans[loc]);\n\t\t\t\tcs.push_back(j); cop[j]--;\n\n\t\t\t\tvector<P> v;\n\t\t\t\trep(x, k)if (!b2[x]) {\n\t\t\t\t\tv.push_back({ a[x],x });\n\t\t\t\t}\n\t\t\t\tsort(all(v), greater<P>());\n\t\t\t\tfor (P p : v) {\n\t\t\t\t\tcs.push_back(p.second);\n\t\t\t\t\tcop[p.second]--;\n\t\t\t\t}\n\t\t\t\tint mi = mod;\n\t\t\t\trep(x, k)mi = min(mi, cop[x]);\n\t\t\t\tif (mi < 0)continue;\n\n\t\t\t\tint pre = 0;\n\t\t\t\trep(x, k) {\n\t\t\t\t\tif (cop[cs[x]] > 2 * mi) {\n\t\t\t\t\t\tfor (int y = pre; y <= x; y++) {\n\t\t\t\t\t\t\tcop[cs[y]]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpre = x + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (validarray(cop)) {\n\t\t\t\t\tvalid = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tchk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << chk+1 << \" \"<<las<<\"\\n\";\n\t\tassert(chk >= 0);\n\t\tans.push_back(chk);\n\t\ta[chk]--;\n\t\tif (ans.size() >= k) {\n\t\t\tvector<int> cnt(k, 0);\n\t\t\trep(j, k) {\n\t\t\t\tcnt[ans[ans.size() - 1 - j]]++;\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tif (valid) {\n\t\t\t\tlas = ans.size();\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint k;\n\tcin >> k;\n\tvector<int> freq(k);\n\tfor(int& x : freq) cin >> x;\n\tint minv = 1000000, maxv = -1;\n\tfor(int x : freq){\n\t\tminv = min(minv, x); maxv = max(maxv, x);\n\t}\n\tint sum = 0;\n\tfor(int x : freq) sum += x;\n\tif(minv * 2 < maxv){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> ans;\n\tint maxworks = 0;\n\twhile((int)ans.size() < sum){\n\t\tbool found = false;\n\t\tfor(int nxt = 0; nxt < k; nxt++){\n\t\t\tvector<int> cans = ans;\n\t\t\tcans.push_back(nxt);\n\t\t\tint cmaxworks = maxworks;\n\t\t\t{\n\t\t\t\tif((int)cans.size() >= k){\n\t\t\t\t\tvector<int> d(k, 0);\n\t\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\t\td[cans[(int)cans.size() - 1 - i]]++;\n\t\t\t\t\t}\n\t\t\t\t\tbool works = true;\n\t\t\t\t\tfor(int i = 0; i < k; i++) if(!d[i]) works = false;\n\t\t\t\t\tif(works) cmaxworks = (int)cans.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cfreq = freq;\n\t\t\tcfreq[nxt]--;\n\t\t\tif(cfreq[nxt] < 0) continue;\n\t\t\tvector<int> known;\n\t\t\tfor(int f = cmaxworks; f < (int)cans.size(); f++) known.push_back(cans[f]);\n\t\t\tvector<int> zk = known;\n\t\t\tsort(zk.begin(), zk.end());\n\t\t\tif(unique(zk.begin(), zk.end()) != zk.end()) continue;\n\t\t\tbool ok = false;\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\treverse(known.begin(), known.end());\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t\treverse(known.begin(), known.end());\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t}\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tfor(int b = cmaxworks - 1; b >= 0; b--){\n\t\t\t\t\tif(cur[cans[b]]) break;\n\t\t\t\t\tcur[cans[b]] = 1;\n\t\t\t\t\tint a = cans[b];\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tint minval = 1000000;\n\t\t\t\tfor(int b : dfreq) minval = min(minval, b);\n\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\tif(cur[i]) continue;\n\t\t\t\t\tif(dfreq[i] > 2 * minval){\n\t\t\t\t\t\tdfreq[i]--;\n\t\t\t\t\t\tcur[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ming = 100000, maxg = 0;\n\t\t\t\tfor(int b : dfreq) ming = min(ming, b);\n\t\t\t\tfor(int b : dfreq) maxg = max(maxg, b);\n\t\t\t\tif(ming * 2 >= maxg){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(nxt);\n\t\t\t\tmaxworks = cmaxworks;\n\t\t\t\tfound = true;\n\t\t\t\tfreq[nxt]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for(int b : ans) cerr << b << ' ';\n\t\t// cerr << '\\n';\n\t\tassert(found);\n\t}\n\tfor(int b : ans) cout << b+1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint K,sum;\nvi _A,sol;\n\nint getSum(vi v) {\n\tint res = 0; trav(t,v) res += t;\n\treturn res;\n}\n\nbool initial(vi v) {\n\tvi A = _A; vector<bool> con(K);\n\t//dbg(\"OOPS\",sz(A),K);\n\ttrav(t,v) A[t] ++, con[t] = 1;\n\tint lef = getSum(A); assert(lef >= K);\n\tint l = MOD, r = -MOD;\n\ttrav(t,A) ckmin(l,t), ckmax(r,t);\n\tint lo = cdiv(lef,K), hi = lef/K*2;\n\tdbg(\"UHOH\",lef,v);\n\tFOR(num,lo,hi+1) {\n\t\tint LO = (num+1)/2, HI = num;\n\t\tif (LO <= l && r <= HI) {\n\t\t\tif (num == 1 || LO < l || r < HI) return 1;\n\t\t\tbool bad = 0, flag = 0;\n\t\t\ttrav(t,v) {\n\t\t\t\tflag |= A[t] == LO;\n\t\t\t\tif (A[t] == HI && flag) {\n\t\t\t\t\tbad = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tF0R(i,K) if (!con[i] && A[i] == HI) {\n\t\t\t\t\tbad = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bad) {\n\t\t\t\tdbg(\"OK\",num,LO,HI);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\t/*vi con(K);\n\ttrav(t,v) {\n\t\tassert(!con[t]);\n\t\tcon[t] = 1;\n\t}\n\tF0R(i,K) if (!con[i]) {\n\t\tif (!A[i]) return 0;\n\t\tv.pb(i); A[i] --;\n\t}\n\tFOR(nex,1,K+1) {\n\n\t}\n\tdbg(\"AH\",v,A); exit(0);*/\n}\n\nbool ok() {\n\tvi cnt(K); int ok = 0;\n\tvi cool(sz(sol)+1);\n\tauto ad = [&](int r, int inc) {\n\t\tr = sol[r];\n\t\tok -= cnt[r] == 1;\n\t\tcnt[r] += inc;\n\t\tok += cnt[r] == 1;\n\t};\n\tint r = -1;\n\tF0R(l,sz(sol)-K+1) {\n\t\twhile (r < l+K-1) ad(++r,1);\n\t\tif (ok == K) cool[l] ++, cool[r+1] --;\n\t\tad(l,-1);\n\t}\n\tFOR(i,1,sz(sol)+1) cool[i] += cool[i-1];\n\tint fst = 0; while (cool[fst]) fst ++;\n\tif (sz(sol) == sum)  return fst == sum;\n\tcnt = vi(K);\n\tFOR(i,fst,sz(sol)) if (cnt[sol[i]]++) return 0;\n\tdbg(\"HA\",fst,sol);\n\t// fst to sz(sol)-1\n\tfor (int i = fst; i+K >= sz(sol); --i) {\n\t\t//dbg(\"TRYING\",i);\n\t\tif (i+K <= sum && initial(vi(begin(sol)+i,end(sol)))) return 1;\n\t\tif (i == 0) break;\n\t\tif (cnt[sol[i-1]]++) break;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tsetIO(); re(K); _A.rsz(K); re(_A);\n\ttrav(t,_A) sum += t;\n\tif (!ok()) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\twhile (sz(sol) < sum) {\n\t\tdbg(\"SOL\",sol);\n\t\tbool done = 0;\n\t\tF0R(i,K) if (_A[i]) { // K*sum\n\t\t\t_A[i] --; sol.pb(i);\n\t\t\tif (ok()) { done = 1; break; }\n\t\t\t_A[i] ++; sol.pop_back();\n\t\t}\n\t\tassert(done);\n\t}\n\ttrav(t,sol) pr(t+1,' ');\n\tps();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n        }\n        if (flag[i] && flag[j]) {\n            //if (j < K-1) {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            //}\n            //else {\n                //if (li < lj) flag[i] = false;\n                //else flag[j] = false;\n            //}\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    for (int i = 0; i < a[1]; ++i) {\n        vs[i].insert(1);\n    }\n    if (a[1] > 0) {\n        for (int i = 2; i <= k; ++i) {\n            if (a[i] > 0) {\n                --a[i];\n                vs[a[1] - 1].insert(i);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; a[i] > 0; ++ind) {\n                    --a[i];\n                    vs[ind].insert(i);\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tvi Ans;\n\t\tset<pii> S;\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=1;i<=k;i++) S.insert({H[i]-diff,-i});\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tset<pii> NS;\n\t\t\tint min = (*S.begin()).first;\n\t\t\tif(min==0) break;\n\t\t\tfor(auto p:S)\n\t\t\t{\n\t\t\t\tif(p.first==min)\n\t\t\t\t{\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-1,p.second});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tD.push_back(-p.second);\n\t\t\t\t\tD.push_front(-p.second);\n\t\t\t\t\tNS.insert({p.first-2,p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tS=NS;\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\nconst int N = 1e3 + 5;\nint _w;\n\nint dat[N] , n , m , _mx , _mn , ans[N] , cur , vis[N] , vis_t;\nVI inf;\n\nVI solve( int len ) {\n  static int dat[N];\n  if( cur + len - n < 0 ) return inf;\n  if( cur + len > m ) return inf;\n  _mx = 0 , _mn = 0x3f3f3f3f , ++vis_t;\n  memcpy( dat + 1 , ::dat + 1 , sizeof( int ) * n );\n  for( int i = cur + len - n + 1 ; i <= cur ; ++i ) vis[ans[i]] = vis_t;\n  for( int i = 1 ; i <= n ; ++i ) {\n    if( vis[i] ^ vis_t ) {\n      if( dat[i] == 0 ) return inf;\n      --dat[i];\n    }\n    _mx = max( _mx , dat[i] );\n    _mn = min( _mn , dat[i] );\n  }\n  if( _mn * 2 + 1 < _mx ) return inf;\n  if( _mn * 2 >= _mx ) {\n    VI res;\n    for( int i = 1 ; i <= n ; ++i ) if( vis[i] ^ vis_t ) res.push_back( i );\n    return res;\n  }\n  VI a , b , c;\n  for( int i = 1 ; i <= n ; ++i ) if( (vis[i]^vis_t) && dat[i] == _mx ) a.push_back( i );\n  for( int i = 1 ; i <= n ; ++i ) if( (vis[i]^vis_t) && dat[i] == _mn ) a.push_back( i );\n  for( int i = 1 ; i <= n ; ++i ) if( (vis[i]^vis_t) && (dat[i]^_mn) && (dat[i]^_mx) ) b.push_back( i );\n  int p = 0 , q = 0;\n  while( p < a.size() && q < b.size() ) \n    if( a[p] < b[q] ) c.push_back( a[p++] );\n    else c.push_back( b[q++] );\n  while( p < a.size() ) c.push_back( a[p++] );\n  while( q < b.size() ) c.push_back( b[q++] );\n  int fi = 0 , se = 0;\n  for( int i = cur + len - n + 1 ; i <= cur ; ++i ) {\n    if( dat[ans[i]] == _mn && !se ) se = i;\n    if( dat[ans[i]] == _mx ) fi = i;\n  }\n  for( int i = 0 ; i < c.size() ; ++i ) {\n    if( dat[c[i]] == _mn && !se ) se = i + cur + 1;\n    if( dat[c[i]] == _mx ) fi = i + cur + 1;\n  }\n  if( fi > se ) return inf;\n  return c;\n}\n\nint main( void ) {\n  _w = scanf(\"%d\",&n); _mx = 0 , _mn = 0x3f3f3f3f;\n  inf = VI( n , n );\n  for( int i = 1 ; i <= n ; ++i ) _w = scanf(\"%d\",dat+i) , m += dat[i] , _mx = max( _mx , dat[i] ) , _mn = min( _mn , dat[i] );\n  if( _mn * 2  < _mx ) {\n    puts(\"-1\");\n    return 0;\n  }\n  int l;\n  VI res;\n  while( cur < m ) {\n    res = inf;\n    for( l = n ; l ; --l ) {\n      VI tmp = solve( l );\n      if( res > tmp ) res = tmp;\n    }\n    for( const int & v : res )\n      ans[++cur] = v , --dat[v];\n  }\n  for( int i = 1 ; i <= m ; ++i )\n    printf(\"%d \",ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\tint ok=0;\n\trep(_,len){\n\t\tdmp2(ans,cur,ok);\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tvi tmp;\n\t\t\tint waf;\n\t\t\tif(p==si(cur)){\n\t\t\t\ttmp=cur;\n\t\t\t\twaf=ok;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ok<=p)continue;\n\t\t\t\ttmp=vi(cur.bg+p+1,cur.ed);\n\t\t\t\twaf=ok-(p+1);\n\t\t\t}\n\t\t\ttmp.pb(nx);\n\t\t\tif(si(tmp)==k)waf=k;\n\t\t\ta[nx]--;\n\t\t\tbool relka=false;\n\t\t\trep(j,waf+1){\n\t\t\t\tif(inc(1,j,waf-1))continue;\n\t\t\t\tif(can(k,a,vi(tmp.bg+j,tmp.ed))){\n\t\t\t\t\tans.pb(nx);\n\t\t\t\t\tcur=tmp;\n\t\t\t\t\tok=waf;\n\t\t\t\t\tfound=true;\n\t\t\t\t\trelka=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(relka)break;\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\nconst int N = 105; \n\nint n, a[N], s, mx_a, v[N];\nint main(int argc,char *argv[]){\n\tfreopen(\"d.in\", \"r\", stdin); \n\tcin >> n;\n\tvector<int> ans, cur_left(n); \n\tlop(i, 0, n) {\n\t\tcin >> cur_left[i]; \n\t\ts += cur_left[i]; \n\t\tcmax(mx_a, cur_left[i]); \n\t}\n\tlop(i, 0, n) if (mx_a > cur_left[i]*2) {\n\t\tcout << -1 << endl;\n\t\treturn 0; \n\t}\n\twhile (ans.size() < s) {\n\t\tint m = ans.size();\n\t\tvector<int> best_left, best_add;\n\t\trep(len, 1, n) {\n\t\t\tif (m+len < n || m+len > s) continue;\n\t\t\tauto left = cur_left; \n\t\t\tlop(i, 0, n) v[i] = 1;\n\t\t\tlop(i, m-(n-len), m) \n\t\t\t\tv[ans[i]] = 0;\t\n\t\t\tlop(i, 0, n) if (v[i]) --left[i]; \n\t\t\tint mn = left[0], mx = left[0];\n\t\t\tlop(i, 1, n) {\n\t\t\t\tcmin(mn, left[i]); \n\t\t\t\tcmax(mx, left[i]); \n\t\t\t}\n\t\t\tint mn_idx = n, mx_idx = -1, fail = 0, mx_r;\n\t\t\tlop(i, m-(n-len), m) {\n\t\t\t\tif (left[ans[i]] == mn) cmin(mn_idx, i-(m-(n-len))); \n\t\t\t\tif (left[ans[i]] == mx) cmax(mx_idx, i-(m-(n-len))); \n\t\t\t}\n\t\t\tif (mx <= mn*2) ;\n\t\t\telse if (mx == mn*2+1) {\n\t\t\t\tfail |= mn_idx < mx_idx; \n\t\t\t} else fail = 1;\n\t\t\tif (fail) continue;\n\t\t\tvector<int> add;\n\t\t\tif (mx == mn*2+1){\n\t\t\t\tlop(i, 0, n) if (v[i] && left[i] == mx) mx_r = i;\n\t\t\t\tvector<int> z;\n\t\t\t\tlop(i, 0, n) if (v[i]) {\n\t\t\t\t\tif ((i > mx_r) || (left[i] > mn)) add.pb(i); \n\t\t\t\t\telse z.pb(i); \n\t\t\t\t\tif (i == mx_r) {\n\t\t\t\t\t\tadd.insert(add.end(), z.begin(), z.end()); \n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t} else {\n\t\t\t\tlop(i, 0, n) if (v[i]) add.pb(i); \n\t\t\t}\n\t\t\tif (best_add.empty() || add < best_add) best_add = add, best_left = left;\n\t\t}\n\t\tcur_left = best_left; \n\t\tans.insert(ans.end(), best_add.begin(), best_add.end()); \n\t}\n\tfor (int x : ans) cout << x+1 << \" \"; \n\tcout << endl;\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int K = 101;\nconst int N = 1010;\nint k;\nint a[K];\nint aa[K];\nint b[N];\nint id[K];\nint lastP = 0;\n\n/*\n\n\t\tvector<pii> c;\n\t\tif (n == 0) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tc.push_back(mp(a[i], i));\n\t\t} else {\n\t\t\tfor (int i = 0; ; i++) {\n\t\t\t\tint v = b[n - k + i];\n\t\t\t\tc.push_back(mp(a[v], v));\n\t\t\t\tif (a[v] == mx) break;\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\treverse(all(c));\n\t\tfor (auto t : c) {\n\t\t\tint v = t.second;\n\t\t\tif (a[v] == 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[v]--;\n\t\t\tb[n++] = v;\n\t\t}\n*/\n\nbool canCont(int n) {\n\tint oldn = n;\n\tfor (int i = 0; i < k; i++)\n\t\ta[i] = aa[i];\n\tfor (int i = lastP; i < oldn; i++)\n\t\ta[b[i]]++;\n\tint z = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tid[i] = 0;\n\t}\n\tfor (int i = lastP; i < n; i++) {\n\t\tif (id[b[i]]) return false;\n\t\tid[b[i]] = 1;\n\t}\n\tif (lastP == 0) {\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tid[i] = i;\n\t\t}\n\t\tz = k;\n\t} else {\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tid[b[lastP - k + i]] = i;\n\t\tfor (int i = lastP; i < n; i++)\n\t\t\tz = max(z, id[b[i]] + 1);\n\t}\n\tint mx = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (a[i] < 0) return false;\n\t\tmx = max(mx, a[i]);\n\t}\n\tif (mx == 0) return true;\n\tfor (int i = 0; i < k; i++)\n\t\tif (a[i] == mx)\n\t\t\tz = max(z, id[i] + 1);\n\tfor (int i = lastP; i < n; i++)\n\t\tid[b[i]] = k + 1;\n\tvector<pii> c;\n\tfor (int i = 0; i < k; i++)\n\t\tif (id[i] < z)\n\t\t\tc.push_back(mp(a[i], i));\n\tsort(all(c));\n\treverse(all(c));\n\tfor (auto t : c) {\n\t\tint v = t.second;\n\t\tif (a[v] == 0) {\n\t\t\treturn false;\n\t\t}\n\t\ta[v]--;\n\t\tb[n++] = v;\n\t}\n\tfor (int i = lastP; i < oldn; i++)\n\t\ta[b[i]]--;\n\twhile(true) {\n\t\tc.clear();\n\t\tint cntMax = 0;\n\t\tint mx = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (a[i] > mx) {\n\t\t\t\tmx = a[i];\n\t\t\t\tcntMax = 0;\n\t\t\t}\n\t\t\tif (a[i] == mx) cntMax++;\n\t\t}\n\t\tif (mx == 0) return true;\n\t\tfor (int i = 0; ; i++) {\n\t\t\tint v = b[n - k + i];\n\t\t\tc.push_back(mp(a[v], v));\n\t\t\tif (a[v] == mx) cntMax--;\n\t\t\tif (cntMax == 0) break;\n\t\t}\n\t\tsort(all(c));\n\t\treverse(all(c));\n\t\tfor (auto t : c) {\n\t\t\tint v = t.second;\n\t\t\tif (a[v] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ta[v]--;\n\t\t\tb[n++] = v;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(\"%d\", &aa[i]);\n\tint n = 0;\n\tif (!canCont(n)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\twhile(true) {\n\t\t/*\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d \", b[i]);\n\t\tprintf(\"\\n\");\n\t\t*/\n\t\tif (n >= k) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tid[i] = 0;\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; ok && i < k; i++) {\n\t\t\t\tint x = b[n - k + i];\n\t\t\t\tok &= !id[x];\n\t\t\t\tid[x] = 1;\n\t\t\t}\n\t\t\tif (ok) lastP = n;\n\t\t}\n\t\t//printf(\"lastP = %d\\n\", lastP);\n\t\tint mx = 0;\n\t\tfor (int i = 0; mx >= 0 && i < k; i++) {\n\t\t\tif (aa[i] == 0) continue;\n\t\t\tmx = max(mx, aa[i]);\n\t\t\tb[n++] = i;\n\t\t\taa[i]--;\n\t\t\tif (canCont(n)) {\n\t\t\t\tmx = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn--;\n\t\t\taa[i]++;\n\t\t}\n\t\tif (mx == -1) continue;\n\t\tif (mx == 0) break;\n\t\tassert(false);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", b[i] + 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) cin>>A[i];\n\t\n\tvector<string> VA;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tstring V;\n\t\t\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\t\n\t\tvector<pair<int,int>> C;\n\t\t\n\t\t\n\t\tif(x==2*y) {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tC.push_back({i,1});\n\t\t\t\t}\n\t\t\t\telse if(A[i]>y) {\n\t\t\t\t\tC.push_back({i,0});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(C.size() && C.back().second==0) C.pop_back();\n\t\t\tint first[101]={};\n\t\t\tFORR(c,C) {\n\t\t\t\tfirst[c.first]=1;\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t\tFOR(i,K) if(first[i]==0) V.push_back(i), A[i]--;\n\t\t\tFORR(c,C) {\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t}\n\t\telse if(x==y) {\n\t\t\tFOR(i,K) V.push_back(i), A[i]--;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]!=y) {\n\t\t\t\t\tV.push_back(i);\n\t\t\t\t\tA[i]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j,K) V.push_back((i+j)%K), A[(i+j)%K]--;\n\t\t}\n\t\tVA.push_back(V);\n\t}\n\t\n\tFOR(x,VA.size()) {\n\t\tFOR(y,VA.size()-1) {\n\t\t\tauto a=VA[y]+VA[y+1];\n\t\t\tauto b=VA[y+1]+VA[y];\n\t\t\tif(b<a) swap(VA[y],VA[y+1]);\n\t\t}\n\t}\n\tFORR(va,VA) {\n\t\tFORR(v,va) cout<<(int)(v+1)<<\" \";\n\t}\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\tvi prev(k, -1);\n\n\trep(i,0,len){\n\t\tmx = 0, mn = 1000;\n\t\ttrav(x, a) mx = max(mx, x);\n\t\ttrav(x, a) mn = min(mn, x);\n\t\tint imx = 1000;\n\t\trep(d,0,k) if(a[d] == mn) imx = min(imx, prev[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx && !(mx>=2*mn+1 && prev[d] > imx)){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans[i] < 0){\n\t\t\trep(j,0,i) cout << 1+ans[j] << \" \";\n\t\t\tcout << endl;\n\t\t\ttrav(x, a) cout << x << \" \";\n\t\t\tcout << endl;\n\n\t\t\tcout << mx << \" \" << mn << endl;\n\t\t\tcout << a[ans[i]] << endl;\n\t\t\tcout << imx << \" \" << prev[ans[i]] << endl;\n\t\t\tassert(false);\n\t\t}\n\t\tprev[ans[i]] = i;\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass EPermutationCover {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int K; cin >> K;\n        vector<int> A(K); cin >> A;\n        int mx = *max_element(A.begin(),A.end());\n        vector<vector<int>> Soln;\n\n        for (int t = mx; t <= 2*mx; ++t) {\n            if (*min_element(A.begin(),A.end()) < t - t/2) break;\n\n            vector<int> B = A;\n\n            vector<int> cur;\n            vector<bool> prevOver(K, false);\n            for (int a = 0; a < t; ++a) {\n                vector<bool> canOver(K, false);\n                vector<bool> mustOver(K, false);\n                for (int i = 0; i < K; ++i) {\n                    canOver[i] = !prevOver[i] && (B[i] < (t-a));\n                    mustOver[i] = !prevOver[i] && 2*B[i] == (t-a);\n                }\n\n                vector<bool> isOver(K, false);\n                int first = K;\n                int last = -1;\n                for (int i = 0; i < K; ++i) {\n                    if (mustOver[i]) {\n                        isOver[i] = true;\n                        first = min(i, first);\n                        last = i;\n                    }\n                }\n//                if (first == K) {\n                    int i = K-1;\n                    while (i >= 0 && (canOver[i] || mustOver[i])) {\n                        if (first != K && i < first) break;\n                        isOver[i] = true;\n                        --i;\n                    }\n//                } else {\n//                    for (int i = first; i < K; ++i) {\n//                        if (canOver[i]) {\n//                            isOver[i] = true;\n//                        }\n//                    }\n//                }\n                for (int i = 0; i < K; ++i) {\n                    if (!prevOver[i] && !isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n                for (int i = 0; i < K; ++i) {\n                    if (isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n//                cout << \"level \" << a << endl;\n//                cout << B;\n//                cout << \"canover \" << canOver;\n//                cout << \"mustover \" << mustOver;\n//                cout << \"isover \" << isOver;\n\n                prevOver = isOver;\n            }\n\n            Soln.push_back(cur);\n        }\n\n//        cout << Soln;\n\n        if (Soln.empty()) {\n            cout << \"-1\\n\";\n        } else {\n            cout << *min_element(Soln.begin(),Soln.end());\n        }\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEPermutationCover solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\tsort(h.begin(), h.end(), cmp);\n\tint mino = h.size()? a[h[0]] : inf;\n\tfor (int i : v) \n\t\tmino = min(mino, a[i]);\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\tif (!stp) {\n\t\treverse(h.begin(), h.end());\n\t\tfor (int i : h) \n\t\t\tif (a[i] == mino) {\n\t\t\t\tstp = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse --a[i];\n\t}\n//\tcerr << \"P1 check \\n\";\n//\tfor (int i : v) \n//\t\tcerr << i << ' ';\n//\tcerr << \"Cnt \\n\";\n//\tfor (int i = 0;i < k;++i)\n//\t\tcerr << a[i] << ' ';\n//\tcerr << '\\n';\n\tbool res = stvalid();\n\t//cerr << (res?\"OK\":\"NO\") << endl;\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(res[h+j]);\n\t\t\t\t--a[res.back()];\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcerr << \"In To try \" << res[h+j] << '\\n';\n//\t\t\tcerr << \"MH \" << mh() << '\\n';\n\t\t\tif (mh() < res[h+j]) break;\n\t\t\tint v = res[h+j];\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t\t//cerr << '\\n';\n\t}\n\treturn true;\n}\n\n\n\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nint last[101];\nint R[1010];\n\nint ok(int len) {\n\tint i,j;\n\tint num[100]={};\n\tFOR(i,len) num[R[i]]++;\n\tint z=0;\n\tFOR(i,K) if(num[i]==0) z++;\n\tFOR(i,K) if(z&&num[i]>1) return 0;\n\t\n\tFOR(i,K) FOR(j,K) if(i!=j) {\n\t\tint na=A[i];\n\t\tint nb=A[j];\n\t\t\n\t\tif(last[i]<=last[j]) {\n\t\t\tif(na>2*nb+1) return 0;\n\t\t}\n\t\telse {\n\t\t\tif(na>2*nb) return 0;\n\t\t}\n\t\t\n\t}\n\treturn 1;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\tMINUS(last);\n\t\n\tFOR(i,N) {\n\t\tFOR(j,K) if(A[j]) {\n\t\t\tx=last[j];\n\t\t\tR[i]=j;\n\t\t\tlast[j]=i;\n\t\t\tA[j]--;\n\t\t\t\n\t\t\tif(ok(i+1)) break;\n\t\t\tA[j]++;\n\t\t\tlast[j]=x;\n\t\t}\n\t\tif(j==K) return _P(\"-1\\n\");\n\t}\n\t\n\tFOR(i,N) cout<<R[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 < *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n    abort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(i > last_2h) vis_2h_h = true;\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          // if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // ()\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          times(x+1, i) {a[i] += c[i]-2;c[i]=2;}\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101],B[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) cin>>A[i], B[i]=A[i];\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tvector<pair<int,int>> C;\n\t\t\n\t\t\n\t\tif(x==2*y) {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tC.push_back({i,1});\n\t\t\t\t}\n\t\t\t\telse if(A[i]>y) {\n\t\t\t\t\tC.push_back({i,0});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(C.size() && C.back().second==0) C.pop_back();\n\t\t\tint first[101]={};\n\t\t\tFORR(c,C) {\n\t\t\t\tfirst[c.first]=1;\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t\tFOR(i,K) if(first[i]==0) V.push_back(i), A[i]--;\n\t\t\tFORR(c,C) {\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t}\n\t\telse if(x==y) {\n\t\t\tFOR(i,K) V.push_back(i), A[i]--;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tV.push_back(i);\n\t\t\t\t\tA[i]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j,K) V.push_back((i+j)%K), A[(i+j)%K]--;\n\t\t}\n\t}\n\t\n\tFORR(v,V) cout<<(v+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    int mn = a[0];\n    int mx = a[0];\n    for (int i = 0; i < n; i++) {\n        mn = min(mn, a[i]);\n        mx = max(mx, a[i]);\n    }\n    if (mx > mn * 2) {\n        cout << -1;\n        return 0;\n    }\n    vector<int> res;\n    while (mn > 0) {\n        for (int i = 0; i < n; i++) {\n            if (a[i] == mn * 2) {\n                res.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] != mn * 2) {\n                res.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] == mn * 2) {\n                res.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] == mn * 2) {\n                a[i] -= 2;\n            } else {\n                a[i]--;\n            }\n        }\n        mn--;\n    }\n    for (int x : res) {\n        cout << x + 1 << \" \";\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]v[E]\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]v[E]\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //N\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^n2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//s0ibit\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sortvx\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sortvx\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nll tail(vll &a, ll mx){\n\tdep(i, sz(a)-1, 0){\n\t\tif (a[i]==mx) return i;\n\t}\n\treturn -1;\n}\n\nvoid solve()\n{\n\tll k;  cin >> k;\n\tvector<ll> a = cinv<ll>(k);\n\n\tll mn=MinE(a);\n\tll mx=MaxE(a);\n\tif (mx>mn*2){\n\t\tcout << -1 << '\\n'; return;\n\t}\n\n\tvll ans;\n\t//phase1\n\twhile (mx<mn*2){\n\t\trep(i, 0, k-1) ans.push_back(i);\n\t\teach(e, a) e--;\n\t\tmn--; mx--;\n\n\t\tif (mx==mn*2 and a[0]==mn)break;\n\n\n\t\tans.push_back(0);\n\t\ta[0]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\n\t\tif (mx==mn*2)break;\n\t\tif (mx>mn*2){\n\t\t\tll t=tail(a, mx);\n\t\t\trep(i, 1, t){\n\t\t\t\ta[i]--;\n\t\t\t\tans.push_back(i);\n\t\t\t\tmx--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//phase2\n\twhile (a[0]>0){\n\t\tll t=tail(a, mx);\n\t\tvll fro, mid;\n\t\trep(i, 0, t){\n\t\t\tif (a[i]==mn){\n\t\t\t\tmid.push_back(i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfro.push_back(i);\n\t\t\t}\n\t\t}\n\t\trep(i, t+1, k-1){\n\t\t\tmid.push_back(i);\n\t\t}\n\t\teach(e, fro)ans.push_back(e);\n\t\teach(e, mid)ans.push_back(e);\n\t\teach(e, fro)ans.push_back(e);\n\t\t//\n\t\teach(e, fro)a[e]-=2;\n\t\teach(e, mid)a[e]--;\n\t\tmn=MinE(a);\n\t\tmx=MaxE(a);\n\t}\n\n\teach(e, ans)e++;\n\tcoutv(ans);\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint K;\nint A[111];\n\nbool valid() {\n    int ma = *max_element(A, A+K);\n    if (ma == 0) return true;\n    int mi = *min_element(A, A+K);\n    return mi * 2 >= ma;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &K);\n    REP (i, K) {\n\tint a;\n\tscanf(\"%d\", &a);\n\tA[i] = a;\n    }\n\n    if (!valid()) {\n\tputs(\"-1\");\n\treturn;\n    }\n\n    VI ans;\n    while (1) {\n\t// rprintf(\"%d\", ans.begin(), ans.end());\n\tif (*max_element(A, A+K) == 0) break;\n\n\tif (A[0] >= 2) {\n\t    REP (i, K) A[i]--;\n\t    A[0]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tans.push_back(0);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t\tA[0]++;\n\t    }\n\t}\n\n\t{\n\t    REP (i, K) A[i]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t    }\n\t}\n\t\t\n\tint ma = *max_element(A, A+K);\n\tint mii = min_element(A, A+K) - A;\n\tint mi = A[mii];\n\tint last_max = 0;\n\tREP (i, K) if (A[i] == ma) last_max = i;\n\n\tVI once, twice;\n\n\tREP (i, K) {\n\t    if (A[i] == ma) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else if (A[i] == mi) {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    } else if (i < mii || i < last_max) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    }\n\t}\n\n\n\t//rprintf(\"%d.\", A, A+K);\n\tassert(valid());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n\tans.insert(ans.end(), once.begin(), once.end());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n    }\n\n    EACH (e, ans) (*e)++;\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\nconst int maxK=100+5,maxn=1000+5;\nint n,K,a[maxK],an[maxn];\nbool vis[maxK];\ninline bool cmp(const vector<int> &a,const vector<int> &b) {\n\tfor(int i=0;i<a.size()&&i<b.size();++i) if(a[i]!=b[i]) return a[i]<b[i];\n\treturn a.size()<b.size();\n}\nvoid fail(vector<int> &re) {\n\tfor(int i=0;i<=K;++i) re.push_back(K+1);\n}\nvoid sol(int s,int m,vector<int> &re) {\n\tstatic int b[maxK]; memcpy(b,a,sizeof(b));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i+m<=K;++i) vis[an[s-i]]=1;\n\tfor(int i=1;i<=K;++i) if(!vis[i]) {\n\t\tif(!b[i]) {fail(re); return;}\n\t\t--b[i];\n\t}\n\tint x=*max_element(b+1,b+K+1),y=*min_element(b+1,b+K+1);\n\tif(x>2*y+1) {fail(re); return;}\n\tvector<int> A,B,C;\n\tif(x==2*y+1) {\n\t\tbool flag=0;\n\t\tfor(int i=1;i+m<=K;++i) {\n\t\t\tif(b[an[s-i]]==x) flag=1;\n\t\t\telse if(b[an[s-i]]=y) {\n\t\t\t\tif(flag) {fail(re); return;}\n\t\t\t}\n\t\t}\n\t\tfor(int i=K;i>=1;--i) if(!vis[i]) {\n\t\t\tif(b[i]==x) A.push_back(i);\n\t\t\telse if(b[i]==y) B.push_back(i);\n\t\t\telse C.push_back(i);\n\t\t}\n\t}\n\telse for(int i=K;i>=1;--i) if(!vis[i]) C.push_back(i);\n\tfor(int i=1;i<=m;++i) {\n\t\tif(A.size()) {\n\t\t\tint t=C.size()?C.back():K+1;\n\t\t\tif(A.back()<t) re.push_back(A.back()),A.pop_back();\n\t\t\telse re.push_back(t),C.pop_back();\n\t\t}\n\t\telse {\n\t\t\tint a=B.size()?B.back():K+1,b=C.size()?C.back():K+1;\n\t\t\tif(a<b) re.push_back(a),B.pop_back();\n\t\t\telse re.push_back(b),C.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\trd(K);\n\tfor(int i=1;i<=K;++i) rd(a[i]),n+=a[i];\n\tif(*max_element(a+1,a+K+1)>2*(*min_element(a+1,a+K+1))) {puts(\"-1\"); return 0;}\n\tfor(int i=1;i<=n;) {\n//\t\tdebug(\"---\\n\");\n\t\tvector<int> Q[maxK];\n\t\tif(i==1) sol(i,K,Q[1]);\n\t\telse {\n\t\t\tfor(int j=1;j<=K;++j) sol(i,j,Q[j]);\n\t\t\tint k=1;\n\t\t\tfor(int j=2;j<=K;++j) if(cmp(Q[j],Q[k])) k=j;\n\t\t\tif(k!=1) swap(Q[1],Q[k]);\n\t\t}\n\t\tfor(int j=0;j<Q[1].size();++j) an[i+j]=Q[1][j],--a[Q[1][j]];\n\t\ti+=Q[1].size();\n//\t\tfor(int j=1;j<i;++j) debug(\"%d \",an[j]); debug(\"\\n\");\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tif(i!=1) printf(\" \");\n\t\tprintf(\"%d\",an[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  vector<int> nie(n);\n  int ilnie = 0;\n  while(1){\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    debug(ilnie);\n    if(ma == 0)break;\n    R(i,n)if(!nie[i] && t[i] * 2 > ma && t[i]){\n      debug(ma,t[i],i);\n      res.PB(i);\n      t[i]--;\n      nie[i] = 1;\n      ilnie++;\n      goto ok;\n    }\n    debug(res);\n    assert(0);\n    ok:;\n    if(SZ(res) >= n){\n      vector<int> cz(n);\n      bool nope = 0;\n      R(i,n){\n        if(cz[res[SZ(res) - i - 1]]){\n          nope = 1;\n          break;\n        }\n        cz[res[SZ(res) - i - 1]] = 1;\n      }\n      if(!nope){\n        ilnie = 0;\n        R(i,n)nie[i] = 0;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n#define endl '\\n'\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint N;\n\nvoid generate(vector<int> &src, vector<int> &dest) {\n\tvector<bool> flag(N, true);\n\tsort(src.begin(), src.end());\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t\tflag[src[i]] = false;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (flag[i] == true) {\n\t\t\tdest.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < src.size(); i++) {\n\t\tdest.push_back(src[i]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint K; cin >> K;\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tN = a.size();\n\tint M = 100000;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tchmin(M, a[i]);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (a[i] > M * 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\tset<int> st;\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<int> sizes(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tsizes[j] = a[j];\n\t\t}\n\t\tsort(sizes.begin(), sizes.end());\n\n\t\tvector<int> v;\n\t\tfor (auto itr = st.begin(); itr != st.end(); itr++) {\n\t\t\tv.push_back(*itr);\n\t\t}\n\t\tint m = N;\n\t\tif (v.size() > 0) {\n\t\t\tm = v[v.size() - 1];\n\t\t}\n\t\tfor (int c = 0; c < m; c++) {\n\t\t\tif (st.find(c) != st.end()) { continue; }\n\t\t\tbool f = true;\n\n\t\t\tint _m = sizes[0];\n\t\t\tchmin(_m, a[c] - 1);\n\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (a[k] > 2 * _m) { f = false; }\n\t\t\t}\n\n\t\t\tif (f) {\n\t\t\t\tv.push_back(c);\n\t\t\t\ta[c]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j]--;\n\t\t}\n\n\t\tm = 100000;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tchmin(m, a[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (a[j] == m * 2) {\n\t\t\t\tst.insert(j);\n\t\t\t}\n\t\t}\n\n\t\tgenerate(v, ans);\n\t}\n\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] + 1 << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops, loopsm;\nUL P2[100];\nvector<UL> buf;\nvector<vector<UL>> ans;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloops = (loops + 1) / 2;\n\tloopsm = 1000; rep(i, K) loopsm = min(loopsm, P[i]);\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\n\tfor (UL L = loops; L <= loopsm; L++) {\n\t\trep(i, K) P2[i] = P[i] - L;\n\t\tvector<UL> ans;\n\t\trep(l, L) {\n\t\t\tvector<UL> S, T;\n\t\t\tUL p = 0;\n\t\t\trep(i, K) {\n\t\t\t\tif (P2[i] == L - l) {\n\t\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\t\telse T.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\t\tfor (; p < K; p++) {\n\t\t\t\tT.push_back(p);\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\tsort(T.begin(), T.end());\n\t\t\tconcat(ans, S);\n\t\t\tconcat(ans, T);\n\t\t\tconcat(ans, S);\n\t\t}\n\t\t::ans.push_back(ans);\n\t}\n\tsort(ans.begin(), ans.end());\n\trep(i, ans[0].size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[0][i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\nint pst=0;\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>pst){\n\t\t\tvector<int> nw=solve_ext(extlen);\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tpst=curlen;\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tint idx = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tidx = i;\n\t\tfor (int i = 1; i <= idx; i++)\n\t\t\tif (a[i] != *min_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (i > idx or a[i] == *min_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\twhile (sz < sum){\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tvector<int> A;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.push_back(q[j]);\n\t\t\t}\n\t\t\tsort(A.begin(), A.end());\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tvector<int> me;\n\t\t\tif (2*mnm+1 == mxm){\n\t\t\t\tint idx = -1;\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (a[A[j]] == mxm)\n\t\t\t\t\t\tidx = j;\n\t\t\t\tfor (int j = 0; j <= idx; j++){\n\t\t\t\t\tif (a[A[j]] == mnm)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp[++now] = A[j];\n\t\t\t\t\tme.push_back(A[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\t\tif (j > idx or a[A[j]] == mnm)\n\t\t\t\t\t\tp[++now] = A[j], me.push_back(A[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tme = A;\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tarr[i].first--;\n\t\t}\n\t}\n\n\tint u = 0;\n\twhile (true) {\n\n\t\tauto kek = arr;\n\t\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\t\tkek[i].first--;\n\t\t}\n\n\t\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\t\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\t\tif (2*minimum.first < maximum.first) break;\n\t\tcout << u+1 << \" \";\n\t\tu = (u+1)%n;\n\n\t\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\t\tarr = kek; \n\n\t}\n\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tsort(all(big));\n\t\tsort(all(small));\n\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\n\nint n, m;\nvector<int> c, p;\nvector<bool> cov;\nvector<int> vmi, vpmi;\n\nbool chk0() {\n  int mx = *max_element(c.begin(), c.end());\n  int mi = *min_element(c.begin(), c.end());\n  return mx <= 2 * mi;\n}\n\nint main() {\n  scanf(\"%d\", &m);\n  c.resize(m);\n  for (auto& x : c) {\n    scanf(\"%d\", &x);\n    n += x;\n  }\n  if (!chk0()) {\n    puts(\"-1\");\n    return 0;\n  }\n  p.resize(n);\n  cov.resize(n, false);\n  vmi.resize(n + 1, 0);\n  vpmi.resize(n + 1, 0);\n  for (int i = 0; i < n; i++) {\n    for (int x = 0; x < m; x++) {\n      if (!c[x]) continue;\n      auto bc = c;\n      auto bcov = cov;\n      bc[x]--;\n      p[i] = x;\n      if (i >= m - 1) {\n        vector<bool> vis(m, false);\n        for (int j = 0; j < m; j++) {\n          vis[p[i - j]] = true;\n        }\n        if (*min_element(vis.begin(), vis.end())) {\n          fill(bcov.begin() + (i - m + 1), bcov.begin() + i + 1, true);\n        }\n      }\n      int pr = i - 1;\n      while (~pr && p[pr] != x)\n        pr--;\n      if (pr >= 0 && !*min_element(bcov.begin(), bcov.begin() + pr + 1)) {\n        continue;\n      }\n      int R = i + 1;\n      while (R && !bcov[R - 1])\n        R--;\n      bool flg = false;\n      vector<bool> vis(m, false);\n      int L = i + 1;\n      while (L && !vis[p[L - 1]])\n        vis[p[--L]] = true;\n      int mi = 114514, mx = 0;\n      for (int j = 0; j < m; j++) {\n        mi = min(bc[j] - !vis[j], mi);\n        mx = max(bc[j] - 1, mx);\n      }\n      int mip = i + 1;\n      for (int j = L; j <= i; j++) {\n        int y = p[j];\n        if (bc[y] == mi) {\n          mip = min(mip, j);\n        }\n      }\n      vmi[L] = mi;\n      vpmi[L] = mip;\n      for (int j = L; j <= i; j++) {\n        int y = p[j];\n        if (bc[y] - 1 < mi) {\n          vmi[j + 1] = bc[y] - 1; \n          vpmi[j + 1] = i + 1;\n        } else {\n          vmi[j + 1] = vmi[j];\n          vpmi[j + 1] = vpmi[j];\n        }\n      }\n      int mxp = i + 1;\n      for (int j = i; j >= L; j--) {\n        int y = p[j];\n        if (bc[y] > mx) {\n          mxp = j;\n          mx = bc[y];\n        }\n        if (j <= R) {\n          if (vmi[j] >= 0 && mx <= 2 * vmi[j] || (mx == 2 * vmi[j] + 1 && mxp <= vpmi[j])) {\n            flg = true;\n            break;\n          }\n        }\n      }\n      if (L > i && *max_element(bc.begin(), bc.end()) <= 2 * *min_element(bc.begin(), bc.end())) {\n        flg = true;\n      }\n      if (flg) {\n        cov = bcov;\n        c = bc;  \n        break;\n      }\n    }\n  }\n  assert(!*max_element(c.begin(), c.end()));\n  assert(*min_element(cov.begin(), cov.end()));\n  for (auto x : p) {\n    printf(\"%d \", x + 1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  vector<int> innerSolve(int k, vector<int> a) {\n    int mn = a[0];\n    int mx = a[0];\n    for (int x : a) {\n      mn = min(mn, x);\n      mx = max(mx, x);\n    }\n    if (mx > 2 * mn) {\n      return {};\n    }\n    int total = 0;\n    for (int x : a) total += x;\n    vector<int> res(total, -1);\n    int permStart = 0;\n    int firstUncovered = 0;\n    vector<int> last(k, -1);\n    for (int pos = 0; pos < total; ++pos) {\n      if (pos >= permStart + k) {\n        firstUncovered = pos;\n      }\n      for (int val = 0; val < k; ++val) {\n        if (a[val] > 0) {\n          res[pos] = val;\n          --a[val];\n          vector<int> sa = a;\n          vector<bool> inPerm(k, false);\n          for (int i = permStart; i < pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n          bool ok = false;\n          if (last[val] < permStart) {\n            inPerm[val] = true;\n            for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n            vector<ii> avail;\n            for (int i = 0; i < k; ++i)\n              if (!inPerm[i]) {\n                avail.emplace_back(-a[i], i);\n              }\n            sort(avail.begin(), avail.end());\n            int ptr = 0;\n            for (int plen = k; plen < 2 * k; ++plen) {\n              if (plen > k) {\n                if (permStart + plen - k - 1 <= pos) {\n                  --a[res[permStart + plen - k - 1]];\n                } else {\n                  --a[avail[ptr++].second];\n                }\n              }\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n            }\n          } else if (last[val] == pos - k) {\n            for (int endAt = pos + 1; endAt <= total; ++endAt) {\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n              --a[res[(endAt - permStart) % k + permStart]];\n            }\n          } else {\n            int npermstart = last[val] + 1;\n            if (npermstart <= firstUncovered && total - npermstart >= k) {\n              int spermstart = permStart;\n              permStart = npermstart;\n              vector<bool> inPerm(k, false);\n              for (int i = permStart; i <= pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n              for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n              vector<ii> avail;\n              for (int i = 0; i < k; ++i)\n                if (!inPerm[i]) {\n                  avail.emplace_back(-a[i], i);\n                }\n              sort(avail.begin(), avail.end());\n              int ptr = 0;\n              for (int plen = k; plen < 2 * k; ++plen) {\n                if (plen > k) {\n                  if (permStart + plen - k - 1 <= pos) {\n                    --a[res[permStart + plen - k - 1]];\n                  } else {\n                    --a[avail[ptr++].second];\n                  }\n                }\n                mn = a[0];\n                mx = a[0];\n                for (int x : a) {\n                  mn = min(mn, x);\n                  mx = max(mx, x);\n                }\n                if (mn >= 0 && mx <= 2 * mn) {\n                  ok = true;\n                  break;\n                }\n              }\n              if (!ok) {\n                permStart = spermstart;\n              }\n            }\n          }\n          a = sa;\n          if (ok) {\n            last[val] = pos;\n            break;\n          } else {\n            ++a[val];\n            assert(val + 1 < k);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    /*int tried = 0;\n    while (true) {\n      ++tried;\n      if (tried % 10000 == 0) {\n        cerr << tried << endl;\n      }\n      int k = rand() % 5 + 1;\n      int n = k + rand() % 20;\n      vector<int> seq(n, -1);\n      int permStart = 0;\n      int firstUncovered = 0;\n      vector<int> last(k, -1);\n      for (int i = 0; i < n; ++i) {\n        int step = 0;\n        if (i - permStart >= k) {\n          firstUncovered = i;\n        }\n        while (true) {\n          seq[i] = rand() % k;\n          if (last[seq[i]] < permStart) {\n            break;\n          }\n          if (last[seq[i]] == i - k) {\n            break;\n          }\n          if (i - permStart >= k) {\n            int npermStart = last[seq[i]] + 1;\n            if (n - npermStart >= k && npermStart <= firstUncovered) {\n              permStart = npermStart;\n              break;\n            }\n          }\n          ++step;\n        }\n        last[seq[i]] = i;\n      }\n      vector<int> a(k);\n      for (int x : seq) ++a[x];\n      vector<int> got = innerSolve(k, a);\n      assert(!got.empty());\n      for (int& v : got) {\n        --a[v];\n      }\n      for (int x : a) assert(x == 0);\n      vector<bool> cover(n);\n      for (int i = 0; i + k <= n; ++i) {\n        vector<bool> seen(k);\n        bool ok = true;\n        for (int j = 0; j < k; ++j) {\n          if (seen[got[i + j]]) ok = false;\n          seen[got[i + j]] = true;\n        }\n        if (ok) {\n          for (int j = 0; j < k; ++j) {\n            cover[i + j] = true;\n          }\n        }\n      }\n      for (int i = 0; i < n; ++i) assert(cover[i]);\n      assert(got.size() == seq.size());\n      for (int i = 0; i < got.size(); ++i) {\n        if (seq[i] < got[i]) {\n          assert(false);\n        }\n        if (seq[i] > got[i]) {\n          break;\n        }\n      }\n    }*/\n    int k;\n    in >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) in >> a[i];\n    vector<int> res = innerSolve(k, a);\n    if (res.empty()) {\n      out << -1 << \"\\n\";\n    } else {\n      for (int x : res) out << x + 1 << \" \";\n      out << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nint n;\n\nint get_best(vector<pair<int, int> > arr) {\n\tvector<int> big, small;\n \n\tint Q = arr[0].first;\n\n\tfor (int j = 0; j < n; ++j) {\n\t\tif (2*Q == arr[j].first) {\n\t\t\tbig.push_back(arr[j].second);\n\t\t\tarr[j].first -= 2;\n\t\t}\n\t\telse {\n\t\t\tsmall.push_back(arr[j].second);\n\t\t\tarr[j].first--;\n\t\t}\n\t}\n\n\tsort(all(big));\n\tsort(all(small));\n\n\tif (big.size()) return big[0];\n\treturn small[0];\n\n}\n\n\nbool change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n \n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n \n\tif (2*minimum.first < maximum.first) {\n\t\treturn false;\n\t}\n\tcout << u+1 << \" \";\n \n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n\n\treturn true;\n\n}\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\nsort(all(arr));\n \n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n \n \n\twhile (arr.back().first > 0) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t\tvector<int> perm;\n\n\t\tfor (int e = 0; e < small.size(); ++e) perm.push_back(small[e]);\n\t\tfor (int e = 0; e < big.size(); ++e) perm.push_back(big[e]);\n\n\t\tint u = 0;\n\n\t\twhile (arr.back().first > 0) {\n\n\t\t\tint W = get_best(arr);\n\n\t\t\tif (W < perm[u]) break;\n\t\t\tif (!change(arr, perm[u])) break;\n\n\t\t\tu = (u+1)%n;\n\n\t\t}\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 1024(TLE)\n\n \ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"  //\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            //cout<<x<<\"/\"<<y;\n            cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\n\nint main(){fastio\n    ll k;cin>>k;\n    ll a[k+1];rep(i,1,k)cin>>a[i];\n    cout<<-1<<endl;\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      pair<vi, int> best(solve(a, a.size()), 0);\n      for (int l = 1; l < a.size(); ++l) {\n        --a[v0[l - 1]];\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, a.size() - l, v0[l]);\n        if (v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n      }\n      best.first.resize(best.second);\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second == 0 ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 5; ++n) for (int test = 1; test <= 10000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      assert(v.size() == len(a));\n      for (int x : v) assert(x >= 0 && x < n);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 1e3 + 50;\ncs int INF = 1e9 + 7;\nvoid ckmn(int &a, int b){ if(a > b) a = b; }\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\nint n, a[N], m, ans[N];\nint now[N], nxt[N], my;\nbool cmp(cs int &i, cs int &j){\n\tint x=a[i]==my,y=a[j]==my;\n\tif(x!=y)return x<y; return i<j;\n}\nbool work(int len){\n\tfor(int i=1;i<=len;i++)--a[now[i]];\n\tint mn=INF,mx=0;\n\tfor(int i=1; i<=n; i++)\n\tmn=min(mn,a[i]),mx=max(mx,a[i]);\n\t\n\tif(mn*2>=mx){\n\t\tfor(int i=1; i<=len; i++)\n\t\t++a[nxt[i]=now[i]];\n\t\tsort(nxt+1,nxt+len+1);\n\t\treturn true;\n\t}\n\t\n\tif(mn*2+1<mx){\n\t\tfor(int i=1; i<=len; i++) ++a[now[i]];\n\t\treturn false;\n\t}\n\t\n\tstatic int t1[N], t2[N]; int z1=0, z2=0;\n\tfor(int i=1; i<=len; i++)\n\tif(a[now[i]]==mn||a[now[i]]==mx)\n\tt1[++z1]=now[i]; else t2[++z2]=now[i]; \n\t\n\tmy=mn;\n\tsort(t1+1,t1+z1+1,cmp);\n\tsort(t2+1,t2+z2+1);\n\t\n\tfor(int i=1,p=1,q=1; i<=len; i++)\n\tif((p<=z1 && t1[p]<t2[q])||q>z2) nxt[i]=t1[p++];\n\telse nxt[i]=t2[q++];\n\t\n\tbool ok=true;\n\tfor(int i=len+1;i<=n;i++)ok&=(a[now[i]]!=mn);\n\tok|=(z1==0)|(a[t1[1]]==mn);\n\t\n\tfor(int i=1; i<=len; i++)++a[now[i]];\n\treturn ok;\n}\nbool cmp(int *a, int *b){ \n\tint i=1;for(;a[i]==b[i];i++);\n\treturn a[i]<b[i];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tint mn=INF,mx=0,sm=0;\n\tfor(int i=1; i<=n; i++)\n\tscanf(\"%d\",&a[i]),sm+=a[i],\n\tckmn(mn,a[i]),ckmx(mx,a[i]);\n\tif(mn*2<mx) return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\t\n\tnow[i]=i; if(!work(n))return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\n\tnow[i]=ans[++m]=nxt[i],--a[now[i]];\n\twhile(m<sm){\n\t\tstatic int trs[N];\n\t\tint len=0;trs[1]=n+1;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(work(i)&&cmp(nxt,trs))\n\t\t\tlen=i,memcpy(trs,nxt,sizeof(int)*(len+1));\n\t\t}\n\t\tfor(int i=1; i+len<=n; i++)\n\t\tnow[i]=now[i+len];\n\t\tfor(int i=1; i<=len; i++)\n\t\tnow[i+n-len]=ans[++m]=trs[i],--a[trs[i]];\n\t} for(int i=1; i<=m; i++)cout<<ans[i]<<\" \";\n\tfor(int i=1; i<=n; i++)assert(a[i]==0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nbool possiblePrefix(vector<pair<int, int>> A, vector<int> prefix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n  for (int x : prefix) A[where[x]].first++;\n\n  sort(A.begin(), A.end());\n  if (A[0].first * 2 < A.back().first) return false;\n\n  vector<bool> isOne(K, false), isTwo(K, false);\n  int min = A[0].first, nTwos = 0;\n  for (int i = 0; i < K; ++i) {\n    if (min * 2 == A[i].first) {\n      isTwo[A[i].second] = true;\n      nTwos++;\n    }\n    if (min == A[i].first) isOne[A[i].second] = true;\n  }\n  reverse(prefix.begin(), prefix.end());\n  while (prefix.size() && isTwo[prefix.back()]) {\n    nTwos--;\n    prefix.pop_back();\n  }\n  if (!nTwos) return true;\n  for (int x : prefix)\n    if (isOne[x]) return false;\n  return true;\n}\n\nbool possible(vector<pair<int, int>> A, const vector<int>& suffix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n  for (int i = 0; i < K; ++i) {\n    if (possiblePrefix(A, {})) return true;\n    int j = where[suffix[i]];\n    if (A[j].first == 0) break;\n    A[j].first--;\n  }\n  return false;\n}\n\nbool possibleFinish(vector<pair<int, int>> A, vector<int>& B, int coveredUpTo) {\n  int K = A.size();\n  vector<bool> seen(K, false);\n  vector<int> prefix;\n  if (B.size()) {\n    for (int32_t i = B.size() - 1; i >= 0; --i) {\n      if (seen[B[i]]) {\n        if (coveredUpTo <= i) return false;\n        break;\n      }\n      prefix.push_back(B[i]);\n      seen[B[i]] = true;\n    }\n  }\n  reverse(prefix.begin(), prefix.end());\n\n  if ((int)prefix.size() == K) return possible(A, prefix);\n  return possiblePrefix(A, prefix);\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n  vector<int> B;\n\n  if (!possibleFinish(A, B, 0)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int coveredUpTo = 0;\n  while (true) {\n    int tot = 0;\n    for (auto& p : A) tot += p.first;\n    if (tot == 0) break;\n\n    vector<int> where(K);\n    for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n    int x = -1;\n    for (int i = 0; i < K; ++i) {\n      if (A[where[i]].first == 0) continue;\n\n      A[where[i]].first--;\n      B.push_back(i);\n      if (possibleFinish(A, B, coveredUpTo)) {\n        x = i;\n        break;\n      }\n      B.pop_back();\n      A[where[i]].first++;\n    }\n    assert(x != -1);\n    if (B.size() >= K) {\n      vector<int> p(B.end() - K, B.end());\n      sort(p.begin(), p.end());\n      bool isPerm = true;\n      for (int i = 0; i < K; ++i) isPerm &= p[i] == i;\n      if (isPerm) {\n        assert(coveredUpTo + K >= B.size());\n        coveredUpTo = B.size();\n      }\n    }\n  }\n\n  assert(coveredUpTo == B.size());\n  for (int x : B) cout << x + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint a[110],p[1010],pl[110];\nbool bl[110];\nint main()\n{\n\tre int n=0,k,mx=0,mm=0,mk=0;\n\tscanf(\"%d\",&k);\n\tfor(re int i=1;i<=k;i++)scanf(\"%d\",&a[i]),n+=a[i],mx=std::max(mx,a[i]);\n\tfor(re int i=1;i<=k;i++)if(a[i]*2<mx){puts(\"-1\");return 0;}\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tre int j=1;\n\t\tfor(;j<=k;j++)\n\t\t{\n\t\t\tif((!bl[j])&&a[j]*2-1>=mx)break;\n\t\t}\n\t\tbl[j]=1;p[i]=j;a[j]--;mx=0;mm++;mk=std::max(mk,pl[j]);\n\t\tif(i>=k&&(i==k||mm==mk))\n\t\t{\n\t\t\tfor(re int j=1;j<=k;j++)bl[j]=0,pl[p[i-k+j]]=j;mm=mk=0;\n\t\t}\n\t\tfor(re int j=1;j<=k;j++)mx=std::max(mx,a[j]);\n\t}\n\tfor(re int i=1;i<=n;i++)printf(\"%d \",p[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\ntypedef std::pair<std::vector<int>,std::vector<int> > stacks;\nstacks trans(stacks ss,int i,int K,bool&fl){\n\tstd::vector<int>s1,s2;\n\tfor(int j=ss.second.size();j--&&fl;)if(ss.second[j]==i)return fl=0,std::make_pair(s1,s2);\n\tint j=0;while(j<ss.first.size()&&ss.first[j]!=i)j++;\n\tif(j==ss.first.size()&&ss.first.size()+ss.second.size()+1==K||!j&&ss.first.size()==K){\n\t\tfor(j==ss.first.size()?j=0:++j;j<ss.first.size();j++)s1.push_back(ss.first[j]);\n\t\tfor(j=0;j<ss.second.size();j++)s1.push_back(ss.second[j]);\n\t\ts1.push_back(i);\n\t}\n\telse{\n\t\tfor(j==ss.first.size()?j=0:++j;j<ss.first.size();j++)s1.push_back(ss.first[j]);\n\t\ts2=ss.second;s2.push_back(i);\n\t}\n\treturn std::make_pair(s1,s2);\n}\nbool chk(std::pair<stacks,std::vector<int> >st){\n\tstacks ss=st.first;\n\tstd::vector<int>c=st.second;\n\tint N=0,K=c.size();\n\tfor(int i=ss.second.size();i--;)c[ss.second[i]]++;\n\tfor(int i=0;i<K;i++)N+=c[i];\n\tif(!N)return!ss.second.size();\n\tint ty[K],M=0;\n\tfor(int i=0;i<K;i++)ty[i]=0,c[i]>M?M=c[i]:1;\n\tfor(int i=0;i<ss.first.size();i++)ty[ss.first[i]]=1;\n\tfor(int i=0;i<ss.second.size();i++)ty[ss.second[i]]=2;\n\tbool fl=1;\n\tint p=ss.first.size(),q=ss.second.size();\n\twhile(p&&c[ss.first[p-1]]<M)--p;\n\tfor(int i=0;i<K;i++)if(!ty[i])ty[i]=c[i]==M?fl=0,3:2;\n\tfor(int i=0;i<p;i++)ty[ss.first[i]]=c[ss.first[i]]==M?fl=0,3:2;\n\tif(fl)while(q&&c[ss.second[q-1]]<M)--q;\n\telse fl=1;\n\tfor(int i=0;i<q;i++)ty[ss.second[i]]=3;\n\tfor(int i=0;i<K&&fl;i++)if(c[i]<M){\n\t\tif(ty[i]+(M-c[i]-1)*2>M)fl=0;\n\t}\n\treturn fl;\n}\nint main(){\n\tint K;\n\twhile(scanf(\"%d\",&K)==1){\n\t\tint N=0;\n\t\tstacks ss;\n\t\tstd::vector<int>c;\n\t\tfor(int i=0,x;i<K;i++)scanf(\"%d\",&x),c.push_back(x),N+=x;\n\t\tif(!chk(std::make_pair(ss,c)))puts(\"-1\");\n\t\telse while(N--){\n\t\t\tbool fl=0;\n\t\t\tfor(int i=0;i<K&&!fl;i++)if(c[i]){\n\t\t\t\tc[i]--;fl=1;\n\t\t\t\tstacks ns=trans(ss,i,K,fl);\n\t\t\t\tif(fl&&chk(std::make_pair(ns,c)))ss=ns,printf(\"%d%c\",i+1,\" \\n\"[!N]);\n\t\t\t\telse fl=0,c[i]++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,ll>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1005;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint k,a[MAXN],n,res[MAXN],len;\ninline bool check(){int Mn=a[1],Mx=a[1];Rep(i,1,k)Mn=min(Mn,a[i]),Mx=max(Mx,a[i]);return Mn*2>=Mx;}\ninline void Merge(int*x,int*y,int*z,int l1,int l2){\n\tint l=0,i=1,j=1;\n\tfor(;i<=l1&&j<=l2;)if(x[i]<=y[j])z[++l]=x[i++];else z[++l]=y[j++];\n\tfor(;i<=l1;z[++l]=x[i++]);for(;j<=l2;z[++l]=y[j++]);\n}\ninline vector<int>Solve(int le){\n\tint l1=0,l2=0,l3=0;static int x[MAXN],y[MAXN],z[MAXN],b[MAXN],vis[MAXN];\n\tRep(i,1,k)vis[i]=0,b[i]=a[i];\n\tRep(i,0,k-le-1)vis[res[len-i]]=1;\n\tRep(i,1,k){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint Mn=b[1],Mx=b[1];Rep(i,1,k)Mn=min(Mn,b[i]),Mx=max(Mx,b[i]);\n\tif(Mn*2>=Mx){vector<int>tmp;Rep(i,1,k)if(!vis[i])tmp.pb(i);return tmp;}\n\telse if(Mn*2+1==Mx){\n\t\tRep(i,1,k)if(!vis[i]&&b[i]==Mx)x[++l1]=i;\n\t\tRep(i,1,k)if(!vis[i]&&b[i]==Mn)x[++l1]=i;\n\t\tRep(i,1,k)if(!vis[i]&&b[i]!=Mx&&b[i]!=Mn)y[++l2]=i;\n\t\tMerge(x,y,z,l1,l2),l3=l1+l2;int p1=0,p2=0;vector<int>tmp(z+1,z+l3+1);\n\t\tRep(i,len-(k-le-1),len){if(b[res[i]]==Mx)p1=i;if(b[res[i]]==Mn&&!p2)p2=i;}\n\t\tRep(i,1,l3){if(b[z[i]]==Mx)p1=i+len;if(b[z[i]]==Mn&&!p2)p2=i+len;}\n\t\tif(p1<p2)return tmp;return vector<int>(1,k+1);\n\t}else return vector<int>(1,k+1);\n}\ninline bool cmp(vector<int>a,vector<int>b){for(int i=0;i<a.size();i++){if(i>=b.size()||a[i]>b[i])return 1;if(a[i]<b[i])return 0;}return 0;}\ninline void Ins(){\n\tvector<int>ext(1,k+1);\n\tfor(int i=1;i<=k&&i+len<=n;i++)if(len-k+i+1>0){\n\t\tvector<int>now=Solve(i);\n\t\tif(cmp(ext,now))ext=now;\n\t}for(auto o:ext)cout<<o<<' ',res[++len]=o,a[o]--;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tk=read();\n\tRep(i,1,k)a[i]=read(),n+=a[i];\n\tif(!check())return puts(\"-1\"),0;\n\twhile(len<n)Ins();\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e3+10;\nint n,cnt[N],s,m,ans[N];\n\nint b[N];\npoly res;\nbool vis[N];\ninline bool check(int len){\n\tint las=n-len;\n\tif (m-las+1<=0||m+len>s) return 0;\n\tFor(i,1,n) vis[i]=0;\n\tFor(i,m-las+1,m) vis[ans[i]]=1;\n\tint mn=1e9,mx=0;\n\tFor(i,1,n) b[i]=cnt[i]-(vis[i]^1),mn=min(mn,b[i]),mx=max(mx,b[i]);\n\tif (mn<0) return 0;\n\tres={};\n\tif (mn*2>=mx){\n\t\tFor(i,1,n) if (!vis[i]) res.pb(i);\n\t\treturn 1;\n\t} else if (mn*2+1==mx){\n\t\tint cnt=0;\n\t\tFor(i,1,n) if (!vis[i]) cnt+=b[i]==mx;\n\t\tpoly tmp;\n\t\tFor(i,1,n) if (!vis[i]){\n\t\t\tif (b[i]!=mx&&b[i]!=mn) res.pb(i),vis[i]=1;\n\t\t\telse if (b[i]==mx){\n\t\t\t\tres.pb(i),vis[i]=1,--cnt;\n\t\t\t\tif (cnt==0)\tfor (auto j:tmp) res.pb(j);\n\t\t\t} else if (b[i]==mn){\n\t\t\t\tif (cnt==0) res.pb(i),vis[i]=1;\n\t\t\t\t\telse tmp.pb(i);\n\t\t\t}\n\t\t}\n\t\tint r=0,l=0;\n\t\tFor(i,1,las){\n\t\t\tif (b[ans[m-i+1]]==mx) r=i;\n\t\t\tif (b[ans[m-i+1]]==mn&&!l) l=i;\n\t\t}\n\t\tFOR(i,0,siz(res)){\n\t\t\tif (b[res[i]]==mx) r=las+i+1;\n\t\t\tif (b[res[i]]==mn&&!l) l=las+i+1; \n\t\t}\n\t\tif (r<l) return 1;\n\t\t\telse return 0;\n\t} else return 0;\n}\ninline bool check(poly a,poly b){\n\tint n=max(siz(a),siz(b));\n\ta.resize(n),b.resize(n);\n\tFOR(i,0,n) if (a[i]!=b[i]) return a[i]<b[i];\n\treturn 0;\n}\ninline void insert(){\n\tpoly ret;\n\tFor(i,1,n)\n\t\tif (check(i))\n\t\t\tif (ret.empty()||check(res,ret)) ret=res;\n\tfor (auto i:ret) ans[++m]=i,cnt[i]--;\n}\n\nint main(){\n\tn=read();\n\tint mx=0,mn=1e9;\n\tFor(i,1,n){\n\t\tcnt[i]=read(),s+=cnt[i];\n\t\tmx=max(mx,cnt[i]),mn=min(mn,cnt[i]);\n\t}\n\tif (mn*2<mx) return puts(\"-1\"),0;\n\twhile (m<s) insert();\n\tFor(i,1,m) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<string>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    if (a[1] > 0) {\n        for (int i = 1; i <= k; ++i) {\n            for (int j = cr; j >= cl; --j) {\n                if (a[i] == 0) {\n                    cl = j + 1;\n                    break;\n                }\n                --a[i];\n                vs[j].insert(to_string(i));\n            }\n        }\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(to_string(i)) == 0) {\n                        --a[i];\n                        vs[ind].insert(to_string(i));\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(to_string(i)) == 0) {\n                        vs[cl].insert(to_string(i));\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<string> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(to_string(i));\n        }\n        for (string i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (string i : inv) {\n            cout << i << \" \";\n        }\n        for (string i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2020.06.28 19:33:21\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\nint main() {\n    int n, sum = 0, mi = INF, mx = -INF;\n    scanf(\"%d\", &n);\n    vector<int> a(n), ans;\n    for(auto &g : a) {\n        scanf(\"%d\", &g);\n        mi = min(mi, g);\n        mx = max(mx, g);\n        sum += g;\n    }\n    if(mi * 2 < mx) { puts(\"-1\"); return 0; }\n    while((int)ans.size() < sum) {\n        vector<int> add, left, vis, bestleft;\n        for(int len = 1; len <= n; ++len) {\n            if((int)ans.size() + len < n || (int)ans.size() + len > sum) continue;\n            vector<int> vals;\n            left = a, vis.assign(n, 1);\n            for(int j = 0; j < n - len; ++j)\n                vis[ans[ans.size()-j-1]] = 0;\n            for(int j = 0; j < n; ++j) if(vis[j])\n                left[j]--, vals.push_back(j);\n            mi = INF, mx = -INF;\n            for(int j = 0; j < n; ++j) {\n                mi = min(mi, left[j]);\n                mx = max(mx, left[j]);\n            }\n            if(mi < 0 || mi * 2 + 1 < mx) continue;\n            int idx = INF, xdx = -INF;\n            for(int j = (int)ans.size()-len+n; j < (int)ans.size(); ++j) {\n                if(left[ans[j]] == mi) idx = min(idx, j);\n                if(left[ans[j]] == mx) xdx = max(xdx, j);\n            }\n            if(mi * 2 + 1 == mx && idx < xdx) continue;\n            xdx = -INF;\n            for(int j = 0; j < n; ++j) if(left[j] == mx) xdx = j;\n#define key(x) (left[x] == mi ? pii(max(x, xdx), x+1) : pii(x, 0))\n            if(mi * 2 + 1 == mx)\n                sort(vals.begin(), vals.end(), [&](int x, int y) { return key(x) < key(y);} );\n            else sort(vals.begin(), vals.end());\n            if(add.empty() || add > vals) add = vals, bestleft = left;\n        }\n        assert(!add.empty());\n        a = bestleft, ans.insert(ans.end(), add.begin(), add.end());\n    }\n    for(auto g : ans)\n        printf(\"%d \", g + 1);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 110;\n\nint N;\nint arr[MAXN];\n\nint parr[MAXN];\nbool used[MAXN];\nbool pp[MAXN];\n\nvector <int> figure (int K)\n{\n    for (int i = 0; i < N; i++)\n        arr[i] = parr[i] - K;\n\n    vector <int> res;\n    for (int i = 0; i < K; i++)\n    {\n        int hneed = -1; // latest one we need\n        int lcant = 1e6; // earliest one we cant\n        for (int j = 0; j < N; j++)\n        {\n            if (!arr[j])\n                lcant = min (lcant, j);\n            if (arr[j] == K - i)\n                hneed = j;\n        }\n\n        if (hneed < lcant)\n        {\n            for (int j = 0; j < N; j++)\n                res.push_back(j);\n            if (hneed == -1 && lcant > 0)\n                hneed = 0;\n            for (int j = 0; j <= hneed; j++)\n            {\n                res.push_back(j);\n                arr[j]--;\n            }\n            continue;\n        }\n        else\n        {\n            for (int j = 0; j <= hneed; j++)\n            {\n                used[j] = false;\n                if (arr[j])\n                {\n                    used[j] = true;\n                    arr[j]--;\n                }\n            }\n\n            for (int j = 0; j < N; j++)\n                if (used[j]) res.push_back(j);\n            int fnum = N;\n            {\n                for (int k = 0; k < N; k++)\n                    pp[k] = false;\n                for (int k = max (0, (int) res.size() - N); k < res.size(); k++)\n                    pp[res[k]] = true;\n\n                bool good = true;\n                for (int k = 0; k < N; k++)\n                    if (!pp[k])\n                        good = false;\n                if (good)\n                {\n                    fnum = -1;\n                }\n            }\n\n            for (int j = 0; j < fnum; j++)\n            {\n                if (!used[j])\n                {\n                    res.push_back(j);\n                    for (int k = 0; k < N; k++)\n                        pp[k] = false;\n                    for (int k = max (0, (int) res.size() - N); k < res.size(); k++)\n                        pp[res[k]] = true;\n\n                    bool good = true;\n                    for (int k = 0; k < N; k++)\n                        if (!pp[k])\n                            good = false;\n                    if (good)\n                    {\n                        fnum = j;\n                        break;\n                    }\n                }\n            }\n            for (int j = 0; j < N; j++)\n                if (used[j] || j > fnum)\n                    res.push_back(j);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    int lo = 1e6, hi = 0;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        parr[i] = arr[i];\n        lo = min (lo, arr[i]);\n        hi = max (hi, arr[i]);\n    }\n\n    if (lo * 2 < hi)\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    vector <int> res;\n    for (int x = (hi + 1) / 2; x <= lo; x++)\n    {\n        vector <int> v = figure (x);\n        if (!v.size()) continue;\n        if (!res.size())\n            res = v;\n\n        bool f = false;\n        for (int i = 0; i < res.size(); i++)\n        {\n            if (v[i] != res[i])\n            {\n                if (v[i] < res[i])\n                {\n                    f = true;\n                }\n                break;\n            }\n        }\n        if (f)\n            res = v;\n    }\n\n    for (int i = 0; i < res.size(); i++)\n    {\n        if (i) cout << \" \";\n        cout << res[i] + 1;\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define N 1010\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N],k,now,ans[N];\nconst vector<int> inf(1,23333);\nbool check(){\n\tint x=*max_element(a+1,a+k+1);\n\tint y=*min_element(a+1,a+k+1);\n\treturn x<=(y<<1);\n}\nvoid Merge(vector<int> &a,vector<int> &b,vector<int> &c){\n\tint pa=0,pb=0;\n\twhile(pa<(int)a.size()&&pb<(int)b.size()){\n\t\tc.push_back(a[pa]<b[pb]?a[pa++]:b[pb++]);\n\t}\n\twhile(pa<(int)a.size())c.push_back(a[pa++]);\n\twhile(pb<(int)b.size())c.push_back(b[pb++]);\n}\nvector<int> Solve(int len){\n\tstatic int vis[N],b[N];\n\tfor(int i=1;i<=k;++i){\n\t\tvis[i]=0,b[i]=a[i];\n\t}\n\tfor(int i=now+len-k+1;i<=now;++i){\n\t\tvis[ans[i]]=1;\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\tif(!vis[i])if((--b[i])<0)return inf;\n\t}\n\tint mn=*min_element(b+1,b+k+1);\n\tint mx=*max_element(b+1,b+k+1);\n\tif(mn*2+1<mx)return inf;\n\tvector<int> res;\n\tif(mn*2>=mx){\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i])res.push_back(i);\n\t\t}\n\t}\n\telse{\n\t\tvector<int> A,B,all;\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mx)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mn)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]^mn&&b[i]^mx)B.push_back(i);\n\t\t}\n\t\tfor(int i=now+len-k+1;i<=now;++i)all.push_back(ans[i]);\n\t\tMerge(A,B,res);\n\t\tall.insert(all.end(),res.begin(),res.end());\n\t\tint pmx=-1,pmn=n+1;\n\t\tfor(int i=0;i<(int)all.size();++i){\n\t\t\tif(b[all[i]]==mx)pmx=max(pmx,i);\n\t\t\tif(b[all[i]]==mn)pmn=min(pmn,i);\n\t\t}\n\t\tif(pmx>pmn)res=inf;\n\t}\n\treturn res;\n}\nvoid Extend(){\n\tvector<int> ext=inf;\n\tfor(int len=1;len<=k&&len+now<=n;++len){\n\t\tif(len+now>=k){\n\t\t\text=min(ext,Solve(len));\n\t\t}\n\t}\n\tfor(auto x:ext){\n\t\tans[++now]=x;\n\t\t--a[x];\n\t}\n}\nint main(){\n\tk=read();\n\tfor(int i=1;i<=k;++i){\n\t\tn+=a[i]=read();\n\t}\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(now<n){\n\t\tExtend();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\nconst int N = 105; \n\nint n, a[N], s, mx_a, v[N];\nint main(int argc,char *argv[]){\n\t//freopen(\"d.in\", \"r\", stdin); \n\tcin >> n;\n\tvector<int> ans, cur_left(n); \n\tlop(i, 0, n) {\n\t\tcin >> cur_left[i]; \n\t\ts += cur_left[i]; \n\t\tcmax(mx_a, cur_left[i]); \n\t}\n\tlop(i, 0, n) if (mx_a > cur_left[i]*2) {\n\t\tcout << -1 << endl;\n\t\treturn 0; \n\t}\n\twhile (ans.size() < s) {\n\t\tint m = ans.size();\n\t\tvector<int> best_left, best_add;\n\t\trep(len, 1, n) {\n\t\t\tif (m+len < n || m+len > s) continue;\n\t\t\tauto left = cur_left; \n\t\t\tlop(i, 0, n) v[i] = 1;\n\t\t\tlop(i, m-(n-len), m) \n\t\t\t\tv[ans[i]] = 0;\t\n\t\t\tlop(i, 0, n) if (v[i]) --left[i]; \n\t\t\tint mn = left[0], mx = left[0];\n\t\t\tlop(i, 1, n) {\n\t\t\t\tcmin(mn, left[i]); \n\t\t\t\tcmax(mx, left[i]); \n\t\t\t}\n\t\t\tint mn_idx = n, mx_idx = -1, fail = 0, mx_r;\n\t\t\tlop(i, m-(n-len), m) {\n\t\t\t\tif (left[ans[i]] == mn) cmin(mn_idx, i-(m-(n-len))); \n\t\t\t\tif (left[ans[i]] == mx) cmax(mx_idx, i-(m-(n-len))); \n\t\t\t}\n\t\t\tif (mx <= mn*2) ;\n\t\t\telse if (mx == mn*2+1) {\n\t\t\t\tfail |= mn_idx < mx_idx; \n\t\t\t} else fail = 1;\n\t\t\tif (fail) continue;\n\t\t\tvector<int> add;\n\t\t\tif (mx == mn*2+1){\n\t\t\t\tlop(i, 0, n) if (v[i] && left[i] == mx) mx_r = i;\n\t\t\t\tvector<int> z;\n\t\t\t\tlop(i, 0, n) if (v[i]) {\n\t\t\t\t\tif ((i > mx_r) || (left[i] > mn)) add.pb(i); \n\t\t\t\t\telse z.pb(i); \n\t\t\t\t\tif (i == mx_r) {\n\t\t\t\t\t\tadd.insert(add.end(), z.begin(), z.end()); \n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t} else {\n\t\t\t\tlop(i, 0, n) if (v[i]) add.pb(i); \n\t\t\t}\n\t\t\tif (best_add.empty() || add < best_add) best_add = add, best_left = left;\n\t\t}\n\t\tcur_left = best_left; \n\t\tans.insert(ans.end(), best_add.begin(), best_add.end()); \n\t}\n\tfor (int x : ans) cout << x+1 << \" \"; \n\tcout << endl;\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass EPermutationCover {\npublic:\n    void solve() {\n        int k = in.readInt();\n        auto a = in.readIntArray(k);\n\n        if (*min_element(all(a)) * 2 < *max_element(all(a))) {\n            out.printLine(-1);\n            return;\n        }\n        vi p;\n        int lastPerm = 0;\n        arri last(k, -k);\n        while (true) {\n            int mx = *max_element(all(a));\n            if (mx == 0) {\n                break;\n            }\n            bool found = false;\n            for (int i : range(k)) {\n                if (a[i] == 0 || mx >= 2 * a[i]) {\n                    continue;\n                }\n                bool bad = false;\n                for (int j : range(lastPerm, p.size())) {\n                    if (p[j] == i + 1) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    continue;\n                }\n                found = true;\n                last[i] = p.size();\n                a[i]--;\n                p.push_back(i + 1);\n                break;\n            }\n            if (!found) {\n                throw \"Jopa\";\n            }\n            if (*min_element(all(last)) >= p.size() - k) {\n                lastPerm = p.size();\n            }\n        }\n        out.printLine(p);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    EPermutationCover solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tif (pre < len) {\n\t\tprintf(\"WA\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tif (pre < len) {\n\t\tprintf(\"WA\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[i] <= num && num <= (a[i] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) len = pre - i;\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 2111;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N], b[N];\nvector<int> s[N];\nbool f[N], pre[N];\nint main() {\n\tint k;\n\tscanf(\"%d\", &k);\n\tint x = 0;\n\tfor(int i = 1; i <= k; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx = max(x, a[i]);\n\t}\n\tmemcpy(b, a, sizeof(b));\n\tvector<int> aa;\n\tfor(;; x++) {\n\t\tbool flag = true;\n\t\tmemcpy(a, b, sizeof(a));\n\t\tfor(int i = 1; i <= k; i++) {\n\t\t\tif(x - a[i] <= (x / 2)) {\n\n\t\t\t}else flag = false;\n\t\t}\n\t//\tcout << x << ' ' << flag << endl;\n\t\tif(!flag) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(pre, 0, sizeof(pre));\n\t\tfor(int i = 1; i < x; i++) s[i].clear();\n\t\tfor(int i = 1; i < x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(a[j] + (x - i) / 2 < x) {\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ta[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = k; j >= 1; j--) {\n\t\t\t\tif(a[j] < x && pre[j] == 0 && f[j] == 0 && !(s[i].size() == k - 1 && j == 1)) {\n\t\t\t\t\tf[j] = 1;\n\t\t\t\t\ts[i].pb(j);\n\t\t\t\t\ta[j]++;\n\t\t\t\t}else if(f[j]) {\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tmemcpy(pre, f, sizeof(pre));\n\t\t}\n\t\tvector<int> ans;\n\t\tfor(int i = 1; i <= x; i++) {\n\t\t\tmemset(f, false, sizeof(f));\n\t\t\tfor(int k : s[i - 1]) f[k] = 1;\n\t\t\tfor(int k : s[i]) f[k] = 1;\n\t\t\tfor(int j = 1; j <= k; j++) if(!f[j]) ans.pb(j);\n\t\t\tif(i < x) {\n\t\t\t\tsort(s[i].begin(), s[i].end());\n\t\t\t\tfor(int j : s[i]) ans.pb(j);\n\t\t\t}\n\t\t}\n\t\tif(aa.empty() || ans < aa) aa = ans;\n\t}\n\tvector<int> ans;\n\tif(aa.empty()) {\n\n\t\tprintf(\"%d\\n\", -1);\n\t\treturn 0;\n\t}else ans = aa;\n\tfor(int i = 0; i < (int)ans.size(); i++) {\n\t\tprintf(\"%d%c\", ans[i], i == (int)ans.size() - 1 ? '\\n' : ' ');\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100, MP = 100000;\n\nint k, c[MX], p[MP], lastPos[MX];\n\nbool check(int a, int b, int n) {\n\tfor (int i = 0; i < k; i++)\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tif (i == j) continue;\n\t\t\t\n\t\t\tint cntI = c[i];\n\t\t\tint cntJ = c[j];\n\t\t\t\n\t\t\tif (lastPos[i] >= b) {\n\t\t\t\t// need to cover last 'i'\n\t\t\t\t\n\t\t\t\tif (lastPos[j] >= a) {\n\t\t\t\t\t// last 'j' can be used to cover last 'i'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// last 'j' can not be used anymore\n\t\t\t\t\tcntI++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (lastPos[j] > lastPos[i] && lastPos[j] >= a) {\n\t\t\t\t// can use last 'j' to cover the next 'i'\n\t\t\t\tcntI--;\n\t\t\t}\n\t\t\t\n\t\t\tif (cntI > 2 * cntJ) {\n//\t\t\t\tprintf(\"\\t%d %d %d -> %d %d | %d %d\\n\", a, b, n, i + 1, j + 1, cntI, cntJ);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\treturn true;\n}\n\npair<int, int> append(int a, int b, int n, int x) {\n\tp[n] = x;\n\tc[x]--;\n\ta = max(lastPos[x] + 1, a);\n\tlastPos[x] = n;\n\tn++;\n\t\n\tif (n - a == k) {\n\t\ta++;\n\t\tb = n;\n\t}\n\t\n\treturn {a, b};\n}\n\nbool tryAppend(int a, int b, int n, int x) {\n\tint xPos = lastPos[x];\n\t\n\tif (xPos >= b) return false;\n\t\n\tint aa, bb;\n\ttie(aa, bb) = append(a, b, n, x);\n\t\n\tbool res = check(aa, bb, n + 1);\n\t\n\tlastPos[x] = xPos;\n\tc[x]++;\n\t\n\treturn res;\n}\n\nint main() {\n\tignore = scanf(\"%d\", &k);\n\tfor (int i = 0; i < k; i++) ignore = scanf(\"%d\", c + i);\n\t\n\tfill(lastPos, lastPos + k, -1);\n\t\n\tif (check(0, 0, 0) == false) {\n\t\tprintf(\"%d\\n\", -1);\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint a = 0, b = 0, n = 0;\n\twhile (*max_element(c, c + k) > 0) {\n\t\tint x = 0;\n\t\twhile (x < k && tryAppend(a, b, n, x) == false) x++;\n\t\t\n\t\tif (x == k) {\n\t\t\tprintf(\"Fail\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\ttie(a, b) = append(a, b, n, x);\n\t\tn++;\n\t\t\n\t\tprintf(\"%d \", x + 1);\n\t}\n\t\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\tint ok=0;\n\trep(_,len){\n\t\tdmp2(ans,cur,ok);\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tvi tmp;\n\t\t\tint waf;\n\t\t\tif(p==si(cur)){\n\t\t\t\ttmp=cur;\n\t\t\t\twaf=ok;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ok<=p)continue;\n\t\t\t\ttmp=vi(cur.bg+p+1,cur.ed);\n\t\t\t\twaf=ok-(p+1);\n\t\t\t}\n\t\t\ttmp.pb(nx);\n\t\t\tif(si(tmp)==k)waf=k;\n\t\t\ta[nx]--;\n\t\t\tbool relka=false;\n\t\t\trep(j,waf+1){\n\t\t\t\tif(can(k,a,vi(tmp.bg+j,tmp.ed))){\n\t\t\t\t\tans.pb(nx);\n\t\t\t\t\tcur=tmp;\n\t\t\t\t\tok=waf;\n\t\t\t\t\tfound=true;\n\t\t\t\t\trelka=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(relka)break;\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    int m = *min_element(a.begin(), a.end());\n    if (2 * m < *max_element(a.begin(), a.end())) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    while (m > 0) {\n        vector<int> once;\n        vector<int> twice;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] == m) {\n                once.push_back(i + 1);\n                a[i] -= 1;\n            } else {\n                twice.push_back(i + 1);\n                a[i] -= 2;\n            }\n        }\n        --m;\n        for (int v: twice)\n            cout << v << \" \";\n        for (int v: once)\n            cout << v << \" \";\n        for (int v: twice)\n            cout << v << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint K,sum;\nvi _A,sol;\n\nint getSum(vi v) {\n\tint res = 0; trav(t,v) res += t;\n\treturn res;\n}\n\nbool initial(vi v) {\n\tvi A = _A; vector<bool> con(K);\n\t//dbg(\"OOPS\",sz(A),K);\n\ttrav(t,v) A[t] ++, con[t] = 1;\n\tvpi oops;\n\tF0R(i,K) if (!con[i]) oops.pb({A[i],i});\n\tsort(rall(oops));\n\ttrav(t,oops) v.pb(t.s);\n\tassert(sz(v) == K);\n\tint lef = getSum(A); assert(lef >= K);\n\tint l = MOD, r = -MOD;\n\ttrav(t,A) ckmin(l,t), ckmax(r,t);\n\tint lo = cdiv(lef,K), hi = lef/K*2;\n\tdbg(\"UHOH\",lef,v);\n\tFOR(num,lo,hi+1) {\n\t\tint LO = (num+1)/2, HI = num;\n\t\tif (LO <= l && r <= HI) {\n\t\t\tbool bad = 0;\n\t\t\tif (num > 1) {\n\t\t\t\tbool flag = 0;\n\t\t\t\ttrav(t,v) {\n\t\t\t\t\tflag |= A[t] == LO;\n\t\t\t\t\tif (A[t] == HI && flag) bad = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bad) {\n\t\t\t\tdbg(\"OK\",num,LO,HI);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\t/*vi con(K);\n\ttrav(t,v) {\n\t\tassert(!con[t]);\n\t\tcon[t] = 1;\n\t}\n\tF0R(i,K) if (!con[i]) {\n\t\tif (!A[i]) return 0;\n\t\tv.pb(i); A[i] --;\n\t}\n\tFOR(nex,1,K+1) {\n\n\t}\n\tdbg(\"AH\",v,A); exit(0);*/\n}\n\nbool ok() {\n\tvi cnt(K); int ok = 0;\n\tvi cool(sz(sol)+1);\n\tauto ad = [&](int r, int inc) {\n\t\tr = sol[r];\n\t\tok -= cnt[r] == 1;\n\t\tcnt[r] += inc;\n\t\tok += cnt[r] == 1;\n\t};\n\tint r = -1;\n\tF0R(l,sz(sol)-K+1) {\n\t\twhile (r < l+K-1) ad(++r,1);\n\t\tif (ok == K) cool[l] ++, cool[r+1] --;\n\t\tad(l,-1);\n\t}\n\tFOR(i,1,sz(sol)+1) cool[i] += cool[i-1];\n\tint fst = 0; while (cool[fst]) fst ++;\n\tif (sz(sol) == sum)  return fst == sum;\n\tcnt = vi(K);\n\tFOR(i,fst,sz(sol)) if (cnt[sol[i]]++) return 0;\n\tdbg(\"HA\",fst,sol);\n\t// fst to sz(sol)-1\n\tfor (int i = fst; i+K >= sz(sol); --i) {\n\t\t//dbg(\"TRYING\",i);\n\t\tif (i+K <= sum && initial(vi(begin(sol)+i,end(sol)))) return 1;\n\t\tif (i == 0) break;\n\t\tif (cnt[sol[i-1]]++) break;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tsetIO(); re(K); _A.rsz(K); re(_A);\n\ttrav(t,_A) sum += t;\n\tif (!ok()) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\twhile (sz(sol) < sum) {\n\t\tdbg(\"SOL\",sol);\n\t\tbool done = 0;\n\t\tF0R(i,K) if (_A[i]) {\n\t\t\t_A[i] --; sol.pb(i);\n\t\t\tif (ok()) { done = 1; break; }\n\t\t\t_A[i] ++; sol.pop_back();\n\t\t}\n\t\tassert(done);\n\t}\n\ttrav(t,sol) pr(t+1,' ');\n\tps();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,T y){\n\tif (y<x)\n\t\tx=y;\n}\n/*\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\n*/\nconst int N=1005;\nint k,n;\nint a[N],baka[N],b[N];\nint check_permutation(int L,int R){\n\tif (R>n||L<1||R-L+1!=k)\n\t\treturn 0;\n\tstatic int vis[N],Time=0;\n\tTime++;\n\tFor(i,L,R)\n\t\tif (vis[b[i]]==Time)\n\t\t\treturn 0;\n\t\telse\n\t\t\tvis[b[i]]=Time;\n\treturn 1;\n}\nint checkpos(int *pos){\n\tint mi=n,mx=-1;\n\tFor(i,1,k)\n\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\tif (mi*2+1<mx)\n\t\treturn 0;\n\tif (mi*2>=mx)\n\t\treturn 1;\n\t//mi * 2 + 1 == mx\n\tint mip=n+1,mxp=-1;\n\tFor(i,1,k)\n\t\tif (a[i]==mi)\n\t\t\tckmin(mip,pos[i]);\n\t\telse if (a[i]==mx)\n\t\t\tckmax(mxp,pos[i]);\n\treturn mxp<=mip;\n}\nint check(int p,int las){\n\tstatic int pos[N];\n\tFor(i,1,k)\n\t\tpos[i]=p+1;\n\tif (las==p)\n\t\treturn checkpos(pos);\n\tint cut=p;\n\t{\n\t\tvi vis(k+1,0);\n\t\tvis[b[cut]]=1;\n\t\twhile (cut-1>0&&!vis[b[cut-1]])\n\t\t\tcut--,vis[b[cut]]=1;\n\t}\n//\toutarr(b,1,n);\n//\toutval(cut);\n//\toutarr(a,1,k);\n\tif (cut>las+1)\n\t\treturn 0;\n\tFor(i,cut,p)\n\t\tpos[b[i]]=i;\n\tFor(i,1,k)\n\t\tif (pos[i]==p+1)\n\t\t\ta[i]--;\n//\toutarr(pos,1,k);\n//\toutarr(a,1,k);\n\tif (checkpos(pos))\n\t\treturn 1;\n\tFor(i,cut,las){\n\t\ta[b[i]]--;\n\t\tpos[b[i]]=p+1;\n\t\tif (checkpos(pos))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tk=read(),n=0;\n\tFor(i,1,k)\n\t\ta[i]=read(),n+=a[i];\n\t{\n\t\tint mi=n,mx=0;\n\t\tFor(i,1,k)\n\t\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\t\tif (mi*2<mx)\n\t\t\treturn puts(\"-1\"),0;\n\t}\n\tmemset(b,-1,sizeof b);\n\tint las=0;\n\tFor(i,1,n){\n\t\tFor(j,1,k)\n\t\t\tif (a[j]){\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\tbaka[t]=a[t];\n\t\t\t\ta[j]--,b[i]=j;\n\t\t\t\tint nextlas=check_permutation(i-k+1,i)?i:las;\n//\t\t\t\toutarr(b,1,n);outval(nextlas);\n\t\t\t\tif (check(i,nextlas)){\n\t\t\t\t\tlas=nextlas;\n\t\t\t\t\tFor(t,1,k)\n\t\t\t\t\t\ta[t]=baka[t];\n\t\t\t\t\ta[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb[i]=-1;\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\ta[t]=baka[t];\n\t\t\t}\n//\t\tprintf(\"b[%d] = %d\\n\",i,b[i]);\n\t\tassert(~b[i]);\n\t}\n\tFor(i,1,n)\n\t\tprintf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 16:45:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  {\n    int mn = *min_element(a.begin(), a.end());\n    int mx = *max_element(a.begin(), a.end());\n    if (2 * mn < mx) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  vector<int> b(n);\n  auto Can = [&]() {\n    debug(a, b);\n    vector<int> c(n);\n    int mn = 787788;\n    int mx = -787788;\n    for (int i = 0; i < n; i++) {\n      if (b[i] == 0) {\n        c[i] = -1;\n        mn = min(mn, a[i] - 1);\n        mx = max(mx, a[i] - 2);\n      } else {\n        c[i] = a[i] - b[i];\n        mn = min(mn, c[i]);\n        mx = max(mx, c[i]);\n      }\n    }\n    if (mn < 0 || mx < 0 || 2 * mn < mx) {\n      return false;\n    }\n    return true;\n  };\n  vector<int> ret;\n  while (*max_element(a.begin(), a.end()) > 0) {\n    bool done = false;\n    for (int cut = 1; cut < n; cut++) {\n      for (int i = 0; i < cut; i++) {\n        b[i] = 2;\n      }\n      for (int i = cut; i < n; i++) {\n        b[i] = 1;\n      }\n      if (Can()) {\n        done = true;\n        break;\n      }\n    }\n    if (!done) {\n      fill(b.begin(), b.end(), 1);\n      if (Can()) {\n        done = true;\n      }\n    }\n    if (!done) {\n      fill(b.begin(), b.end(), 0);\n      int pos = 0;\n      while (true) {\n        for (int i = pos; i < n; i++) {\n          b[i] = 1;\n        }\n        if (Can()) {\n          break;\n        }\n        for (int i = pos; i < n; i++) {\n          b[i] = 0;\n        }\n        bool found = false;\n        for (int i = pos; i < n; i++) {\n          b[i] = 2;\n          if (Can()) {\n            pos = i + 1;\n            found = true;\n            break;\n          }\n          b[i] = 1;\n        }\n        assert(found);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      a[i] -= b[i];\n    }\n    for (int x : {2, 1, 2}) {\n      for (int i = 0; i < n; i++) {\n        if (b[i] == x) {\n          ret.push_back(i);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < (int) ret.size(); i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << ret[i] + 1;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n \ntypedef long long ll;\n\ntypedef long double ld;\n \nusing namespace std;\n \nconst ll maxn = 1e3 + 10;\nconst ll inf = 998244353;\n\nll n, m, k, t;\n\nvector <ll> C;\n\nvector <ll> ANS;\n\nvoid make_move() {\n    vector <ll> bad;\n    vector <bool> used(n, 0);\n    ll q, w;\n    ll mn = inf, mx = 0, mni = 0;\n    for (q = 0; q < n; q++) {\n        used[q] = 0;\n        // mn = min(mn, C[q]);\n        if (C[q] < mn) {\n            mn = C[q];\n            mni = q;\n        }\n        mx = max(mx, C[q]);\n    }\n    for (q = 0; q < n; q++) {\n        if (C[q] == 2 * mn) {\n            bad.pb(q);\n            used[q] = 1;\n        }\n    }\n    for (q = 0; q < mni; q++) {\n        if (used[q]) {\n            continue;\n        }\n        bad.pb(q);\n        used[q] = 1;\n    }\n    sort(all(bad));\n    for (auto x : bad) {\n        ANS.pb(x);\n        C[x]--;\n    }\n    for (q = 0; q < n; q++) {\n        if (!used[q]) {\n            C[q]--;\n            ANS.pb(q);\n        }\n    }\n    for (auto x : bad) {\n        ANS.pb(x);\n        C[x]--;\n    }\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    cin >> n;\n    C.resize(n);\n    ll mn = inf, mx = 0;\n    for (q = 0; q < n; q++) {\n        cin >> C[q];\n        mn = min(mn, C[q]);\n        mx = max(mx, C[q]);\n    }\n    if (mx > 2 * mn) {\n        cout << -1;\n        return 0;\n    }\n    while (1) {\n        ll mn = inf, mx = 0;\n        for (q = 0; q < n; q++) {\n            mn = min(mn, C[q]);\n            mx = max(mx, C[q]);\n        }\n        if (mx == 0) {\n            break;\n        }\n        make_move();\n    }\n    for (q = 0; q < ANS.size(); q++) {\n        cout << ANS[q] + 1 << \" \";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10;\n\nint ans[N],k,a[110],n;\nbool cov[N],print;\n\nbool isdiff(int l,int r) {\n\tstatic bool vis[110];\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=l;i<=r;i++) {\n\t\tif(vis[ans[i]]) return 0;\n\t\tvis[ans[i]]=1;\n\t}\n\treturn 1;\n}\n\nbool check(int len) {\n\tstatic int aa[110];\n\tint st=0;\n\tif(len-k+1>0&&isdiff(len-k+1,len)) {\n\t\tst=len+1;\n\t\tif(len==n) return 1;\n\t}\n\telse {\n\t\tst=len;while(st>1&&!cov[st-1]) --st;\n\t\t//for(int i=st;i<=len;i++) ++aa[ans[i]];\n\t}\n\twhile(isdiff(st,len)) {\n\t\tint l=1,r=1e9;memcpy(aa,a,sizeof(a));\n\t\tfor(int i=st;i<=len;i++) ++aa[ans[i]];\n\t\tfor(int i=1;i<=k;i++) {\n\t\t\tl=max(l,aa[i]);\n\t\t\tr=min(r,2*aa[i]);\n\t\t}\n\t\tif(l>r) { --st; continue; }\n\t\tif(r-l>1||(l&1)||len==0) return 1;\n\t\tstatic bool vis[110];\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=st;i<=len;i++) vis[ans[i]]=1;\n\t\tbool fl=1;\n\t\tfor(int i=st;i<=len;i++)\n\t\t\tif(l-aa[ans[i]]==l/2) {\n\t\t\t\tfor(int j=i+1;j<=len;j++)\n\t\t\t\t\tif(l-aa[ans[j]]==0) { fl=0;break; }\n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t\tif(!vis[j]&&l-aa[j]==0) { fl=0;break; }\n\t\t\t\tif(!fl) break;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\tif(fl) return 1;\n\t\t--st;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>k;\n\tfor(int i=1;i<=k;i++) cin>>a[i],n+=a[i];\n\tif(!check(0)) return cout<<-1,0;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=k;j++) {\n\t\t\tans[i]=j;--a[j];\n\t\t\t/*if(i==3&&j==3) {\n\t\t\tfor(int j=1;j<=k;j++) cerr<<a[j]<<' ';\n\t\t\treturn 0;\n\t\t\t}*/\n\t\t\t//print=(i==3&&j==3);\n\t\t\tif(check(i)) break;\n\t\t\t++a[j];\n\t\t}\n\t\tif(i>=k&&isdiff(i-k+1,i))\n\t\t\tfor(int j=i-k+1;j<=i;j++) cov[j]=1;\n\t}\n\tfor(int i=1;i<=n;i++) cout<<ans[i]<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\tint ok=0;\n\trep(_,len){\n\t\tdmp2(ans,cur,ok);\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tvi tmp;\n\t\t\tint waf;\n\t\t\tif(p==si(cur)){\n\t\t\t\ttmp=cur;\n\t\t\t\twaf=ok;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ok<=p)continue;\n\t\t\t\ttmp=vi(cur.bg+p+1,cur.ed);\n\t\t\t\twaf=ok-(p+1);\n\t\t\t}\n\t\t\ttmp.pb(nx);\n\t\t\tif(si(tmp)==k)waf=k;\n\t\t\ta[nx]--;\n\t\t\tbool relka=false;\n\t\t\tper(j,waf+1){\n\t\t\t\tif(can(k,a,vi(tmp.bg+j,tmp.ed))){\n\t\t\t\t\tans.pb(nx);\n\t\t\t\t\tcur=tmp;\n\t\t\t\t\tok=waf;\n\t\t\t\t\tfound=true;\n\t\t\t\t\trelka=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(relka)break;\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nbool suc = false;\n\nint n;\n \nvoid change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n\n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\tif (2*minimum.first < maximum.first) {\n\t\tsuc = false;\n\t\treturn;\n\t}\n\tcout << u+1 << \" \";\n\tsuc = true;\n\n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n}\n \nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n \n\tsort(all(arr));\n \n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n \n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tchange(arr, i);\n\t\t}\n\n\t\tchange(arr, 0);\n\t\tif (!suc) break;\n\n\t}\n \n\tint u = 0;\n\twhile (true) {\n \n\t\tchange(arr, u);\n\t\tif (suc) u = (u+1)%n;\n\t\telse break;\n \n\t}\n \n \n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n \n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    for (int i = 0; i < a[1]; ++i) {\n        vs[i].insert(1);\n    }\n    if (a[1] > 0) {\n        for (int i = 2; i <= k; ++i) {\n            if (a[i] > 0) {\n                --a[i];\n                vs[a[1] - 1].insert(i);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < len && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\n\nint state[MAXVALS];\nint nrem[MAXVALS];\n\n\nbool solve() {\n\tans.clear();\n\tREP(i, nvals) rem[i] = cnt[i];\n\twhile (true) {\n\t\t//printf(\"prefix:\"); REPSZ(i, ans) printf(\" %d\", ans[i] + 1); puts(\"\");\n\t\tbool done = true; REP(i, nvals) if (rem[i] > 0) done = false; if (done) break;\n\t\tvector<int> best;\n\t\tREPE(overlap, nvals - 1) {\n\t\t\tif (overlap > SZ(ans)) continue;\n\t\t\tREP(i, nvals) state[i] = nvals;\n\t\t\tREP(i, overlap) state[ans[SZ(ans) - overlap + i]] = i;\n\t\t\tREP(i, nvals) nrem[i] = rem[i] - (state[i] == nvals ? 1 : 0);\n\t\t\tint mn = nrem[0], mx = nrem[0]; FOR(i, 1, nvals) { if (nrem[i] < mn) mn = nrem[i]; if (nrem[i] > mx) mx = nrem[i]; }\n\t\t\tif (mn < 0) continue;\n\t\t\tif (mx > 2 * mn + 1) continue;\n\t\t\tvector<int> cur;\n\t\t\tif (mx == 2 * mn + 1) {\n\t\t\t\tint firstmn = nvals + 1, lastmx = -1;\n\t\t\t\tREP(i, nvals) { if (nrem[i] == mn && state[i] < firstmn) firstmn = state[i]; if (nrem[i] == mx && state[i] > lastmx) lastmx = state[i]; }\n\t\t\t\tif (firstmn < lastmx) continue;\n\t\t\t\tint nmx = 0; REP(i, nvals) if (state[i] == nvals && nrem[i] == mx) ++nmx;\n\t\t\t\tREP(i, nvals) if (state[i] == nvals && (nrem[i] != mn || nmx == 0)) { cur.PB(i); if (nrem[i] == mx) { --nmx; if (nmx == 0) REP(j, i) if (state[j] == nvals && nrem[j] == mn) cur.PB(j); } }\n\t\t\t\tassert(nmx == 0);\n\t\t\t} else {\n\t\t\t\tREP(i, nvals) if (state[i] == nvals) cur.PB(i);\n\t\t\t}\n\t\t\tassert(SZ(cur) == nvals - overlap);\n\t\t\t//if (SZ(ans) == 5) { printf(\"%d:\", overlap); REPSZ(i, cur) printf(\" %d\", cur[i] + 1); printf(\" [%d,%d]\\n\", mn, mx); }\n\t\t\tif (SZ(best) == 0 || cur < best) best = cur;\n\t\t}\n\t\tif (SZ(best) == 0) return false;\n\t\tREPSZ(i, best) ans.PB(best[i]);\n\t\tREPSZ(i, best) --rem[best[i]];\n\t}\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(i > last_2h) vis_2h_h = true;\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          // if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // ()\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          times(x+1, i) a[i] += c[i]-2;c[i]=2;\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define ll long long\n\nconst int N = 303;\nconst int Q = N * 2;\nconst int mod = 998244353;\n\nusing namespace std;\n\nint n;\nint a[N];\nint b[N];\nint c[N];\n\nbool good()\n{\n        int mn = a[1], mx = a[1];\n        for(int i = 2; i <= n; i++){\n                mn = min(mn, a[i]);\n                mx = max(mx, a[i]);\n        }\n        return mn * 2 >= mx;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        if(!good()){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n\n        while(a[1] > 0){\n                int mn = a[1], mx = a[1];\n                for(int i = 2; i <= n; i++){\n                        mn = min(mn, a[i]);\n                        mx = max(mx, a[i]);\n                }\n                for(int i = 1; i <= n; i++){\n                        if(a[i] == mn * 2){\n                                b[i] = 2;\n                        } else{\n                                b[i] = 1;\n                        }\n                }\n                int x = 0;\n                for(int i = 1; i <= n; i++){\n                        for(int j = 1; j <= n; j++){\n                                c[j] = b[j];\n                        }\n                        for(int j = 1; j <= i; j++){\n                                c[j] = 2;\n                        }\n                        for(int j = 1; j <= n; j++){\n                                a[j] -= c[j];\n                        }\n                        if(good()){\n                                x = i;\n                        }\n                        for(int j = 1; j <= n; j++){\n                                a[j] += c[j];\n                        }\n                }\n                for(int i = 1; i <= x; i++){\n                        b[i] = 2;\n                }\n                vector < int > S1, S2;\n                for(int i = 1; i <= n; i++) if(b[i] == 1) S2.push_back(i);\n                for(int i = 1; i <= n; i++) if(b[i] == 2) S1.push_back(i);\n                sort(S1.begin(), S1.end());\n                for(int x: S1) cout << x << \" \";\n                for(int x: S2) cout << x << \" \";\n                for(int x: S1) cout << x << \" \";\n                for(int i = 1; i <= n; i++) a[i] -= b[i];\n\n                assert(good());\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() <= res[h+j]) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvector<int> ori;\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n)ori.push_back(i);\n\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tint num = 10000;\n\trep(i, n)num = min(num, a[i]);\n\trep(i, n)if (a[i] > 2 * num) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tvector<vector<int>> ads(num);\n\tint le = 0;\n\trep(i, n) {\n\t\tint ma = 0;\n\t\tRep(j, i, n) {\n\t\t\tma = max(ma, a[j] - num);\n\t\t}\n\t\tle = min(le, num - ma);\n\t\tint ad = a[i] - num;\n\t\trep(j, ad) {\n\t\t\tads[j+le].push_back(i);\n\t\t}\n\t\tle += ad;\n\t}\n\tvector<int> ans;\n\trep(i, num) {\n\t\tint memo = ans.size();\n\t\tfor (int ad : ads[i]) {\n\t\t\tans.push_back(ad);\n\t\t}\n\t\tint las = 0;\n\t\trep(j, ads[i].size()) {\n\t\t\tvector<int> v;\n\t\t\tint g = memo + j;\n\t\t\tbool valid = false;\n\t\t\tif (g >= n - 1) {\n\t\t\t\trep(t, n) {\n\t\t\t\t\tv.push_back(ans[g - t]);\n\t\t\t\t}\n\t\t\t\tsort(all(v));\n\t\t\t\tif (v == ori)valid = true;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tlas++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvector<bool> skip(n,false);\n\t\trep(j, ads[i].size()) {\n\t\t\tif (j >= las)skip[ads[i][j]] = true;\n\t\t}\n\t\trep(i, n)if (!skip[i])ans.push_back(i);\n\t\trep(i, n)if (skip[i])ans.push_back(i);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tstring R;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\t\n\t\tstring cand;\n\t\t\n\t\tFOR(i,K+1) if(i==0 || A[i-1]>=2) {\n\t\t\tstring cand2,cand3,cand4;\n\t\t\t\n\t\t\tint am=0;\n\t\t\tint B[100];\n\t\t\tFOR(j,K) {\n\t\t\t\tB[j]=A[j];\n\t\t\t\tif(j<i && B[j]>=2) {\n\t\t\t\t\tcand2.push_back(j);\n\t\t\t\t\tcand4.push_back(j);\n\t\t\t\t\tB[j]--;\n\t\t\t\t\tB[j]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tB[j]--;\n\t\t\t\t\tcand3.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(*max_element(B,B+K)>*min_element(B,B+K)*2) {\n\t\t\t\tcand2=cand3=cand4=\"\";\n\t\t\t\tFOR(j,K) {\n\t\t\t\t\tB[j]=A[j];\n\t\t\t\t\tif(j<i && B[j]>y) {\n\t\t\t\t\t\tcand2.push_back(j);\n\t\t\t\t\t\tcand4.push_back(j);\n\t\t\t\t\t\tB[j]--;\n\t\t\t\t\t\tB[j]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tB[j]--;\n\t\t\t\t\t\tcand3.push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(*max_element(B,B+K)>*min_element(B,B+K)*2) continue;\n\t\t\t}\n\t\t\tcand2=cand2+cand3+cand4;\n\t\t\t\n\t\t\t/*cout<<\"!\"<<i<<\" \";\n\t\t\tFORR(c,cand2) cout<<((int)c+1)<<\" \";\n\t\t\tcout<<endl;*/\n\t\t\tif(cand==\"\" || cand2+cand<cand+cand2) cand=cand2;\n\t\t}\n\t\t\n\t\t//FORR(c,cand) cout<<((int)c+1)<<\" \";\n\t\t//cout<<endl;\n\t\tFORR(c,cand) R+=c, A[c]--;\n\t\t\n\t}\n\t\n\tFORR(c,R) cout<<((int)c+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nbool validarray(vector<int>& a) {\n\tint mi = mod, ma = 0;\n\trep(i, a.size()) {\n\t\tif (a[i] < 0)return false;\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\treturn ma <= mi * 2;\n}\n\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\tif (!validarray(a)) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tint sum = 0;\n\trep(i, k)sum += a[i];\n\n\tint las = 0;\n\tvector<int> ans;\n\trep(i, sum) {\n\t\tvector<bool> b(k);\n\t\tfor (int j = las; j < ans.size(); j++) {\n\t\t\tb[ans[j]] = true;\n\t\t}\n\t\tint chk = -1;\n\t\tvector<bool> b2(k);\n\t\trep(j, k) {\n\t\t\tbool valid = false;\n\t\t\tif (b[j])continue;\n\t\t\tb2 = b;\n\t\t\tb2[j] = true;\n\t\t\tfor (int ex = 0; ex <= k; ex++) {\n\t\t\t\tif (las - ex < 0)break;\n\t\t\t\tif (ex > 0) {\n\t\t\t\t\tif (b2[ans[las - ex]])break;\n\t\t\t\t\tb2[ans[las - ex]] = true;\n\t\t\t\t}\n\n\n\t\t\t\t//cout << \"?! \" << i << \" \" << j <<\" \"<<ex<< \"\\n\";\n\t\t\t\tvector<int> cop = a;\n\n\t\t\t\tvector<int> cs;\n\t\t\t\tfor (int loc = las - ex; loc < ans.size();loc++)cs.push_back(ans[loc]);\n\t\t\t\tcs.push_back(j); cop[j]--;\n\n\t\t\t\tvector<P> v;\n\t\t\t\trep(x, k)if (!b2[x]) {\n\t\t\t\t\tv.push_back({ a[x],x });\n\t\t\t\t}\n\t\t\t\tsort(all(v), greater<P>());\n\t\t\t\tfor (P p : v) {\n\t\t\t\t\tcs.push_back(p.second);\n\t\t\t\t\tcop[p.second]--;\n\t\t\t\t}\n\t\t\t\tbool exivalid = false;\n\t\t\t\tfor (int x = 0; x < k; x++) {\n\n\t\t\t\t\tif (validarray(cop)) {\n\t\t\t\t\t\texivalid = true; break;\n\t\t\t\t\t}\n\t\t\t\t\tcop[cs[x]]--;\n\t\t\t\t}\n\t\t\t\tif (exivalid) {\n\t\t\t\t\tvalid = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tchk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << chk+1 << \" \"<<las<<\"\\n\";\n\t\tassert(chk >= 0);\n\t\tans.push_back(chk);\n\t\ta[chk]--;\n\t\tif (ans.size() >= k) {\n\t\t\tvector<int> cnt(k, 0);\n\t\t\trep(j, k) {\n\t\t\t\tcnt[ans[ans.size() - 1 - j]]++;\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tif (valid) {\n\t\t\t\tlas = ans.size();\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 <= *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n    abort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 1005\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nbool use[SIZE];\nint ans[SIZE];\nint n,sz;\n\nint get_first()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\tif(mn*2>mx) return 0;\n\tfor(int i=0;i<n;i++) if(A[i]>mn) return i;\n\treturn -1;\n}\nbool impossible()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\treturn mn*2<mx;\n}\nbool check()//when sz>=n\n{\n\tmultiset <int> st;\n\tmultiset <int>::iterator it;\n\tfor(int i=0;i<n;i++) st.insert(A[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a=*st.begin();\n\t\tit=st.end();it--;\n\t\tint b=*it;\n\t\tif(2*a>=b) return true;\n\t\tint v=ans[sz-n+i];\n\t\tit=st.lower_bound(A[v]);\n\t\tst.erase(it);\n\t\tst.insert(A[v]-1);\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tif(impossible())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsz=0;\n\twhile(A[0]>0)\n\t{\n\t\tint mn=1000;\n\t\tfor(int i=0;i<n;i++) mn=min(mn,A[i]);\n\t\tvector <int> vx;\n\t\tint mx=-1;\n\t\tmemset(use,false,sizeof(use));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(A[i]==mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t\tmx=max(mx,i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<mx;i++)\n\t\t{\n\t\t\tif(A[i]>mn&&A[i]<mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t}\n\t\t}\n\t\tsort(vx.begin(),vx.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!use[i]) vx.push_back(i);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tans[sz++]=vx[i];\n\t\t\tA[vx[i]]--;\n\t\t}\n\t\tint p=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint v=vx[p];\n\t\t\tif(A[v]==0) break;\n\t\t\tif(get_first()<v) break;\n\t\t\tA[v]--;\n\t\t\tans[sz++]=v;\n\t\t\tif(!check())\n\t\t\t{\n\t\t\t\tsz--;\n\t\t\t\tA[v]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++) printf(\"%d \",ans[i]+1);\n\tputs(\"\");\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nvector<int> makev(vector<int> &pre,vector<bool>& b) {\n\tvector<int> res;\n\tif (pre.empty()) {\n\t\trep(i, k)if (b[i])res.push_back(i);\n\t\trep(i, k)if (!b[i])res.push_back(i);\n\t\trep(i, k)if (b[i])res.push_back(i);\n\t}\n\telse {\n\t\tvector<int> cnt(k, 0);\n\n\t\tvector<bool> bs;\n\t\trep(i, k)if (b[i]) {\n\t\t\tint id = res.size();\n\t\t\tres.push_back(i);\n\n\t\t\tfill(all(cnt), 0);\n\t\t\trep(j, k) {\n\t\t\t\tint x = id - j;\n\t\t\t\tif (x >= 0)cnt[res[x]]++;\n\t\t\t\telse {\n\t\t\t\t\tcnt[pre[pre.size() + x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool valid = true;\n\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\tbs.push_back(valid);\n\t\t}\n\n\t\tint tmp = 0;\n\t\trep(i, k) {\n\t\t\tif (!b[i]) {\n\t\t\t\tint id = res.size();\n\t\t\t\tres.push_back(i);\n\n\t\t\t\tfill(all(cnt), 0);\n\t\t\t\trep(j, k) {\n\t\t\t\t\tint x = id - j;\n\t\t\t\t\tif (x >= 0)cnt[res[x]]++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tcnt[pre[pre.size() + x]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool valid = true;\n\t\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\t\tbs.push_back(valid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool isad = false;\n\t\t\t\trep(j, k) {\n\t\t\t\t\tif (j + tmp < bs.size()&&bs[j+tmp]) {\n\t\t\t\t\t\tisad = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isad) {\n\t\t\t\t\tb[i] = false;\n\t\t\t\t\tint id = res.size();\n\t\t\t\t\tres.push_back(i);\n\n\t\t\t\t\tfill(all(cnt), 0);\n\t\t\t\t\trep(j, k) {\n\t\t\t\t\t\tint x = id - j;\n\t\t\t\t\t\tif (x >= 0)cnt[res[x]]++;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcnt[pre[pre.size() + x]]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbool valid = true;\n\t\t\t\t\trep(j, k)if (cnt[j] != 1)valid = false;\n\t\t\t\t\tbs.push_back(valid);\n\t\t\t\t}\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n\n\t\trep(i, k) {\n\t\t\tif (b[i])res.push_back(i);\n\t\t}\n\t}\n\t/*cout << \"??\";\n\trep(i, k)cout << \" \" << b[i];\n\tcout << \"\\n\";*/\n\treturn res;\n}\nvector<int> calc (vector<int> &pre,vector<int>& a) {\n\tvector<int> ans;\n\tint mi = mod;\n\tint ma = 0;\n\trep(i, k) {\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\tif (mi == 0)return {};\n\tvector<int> ts;\n\trep(i, k)if (a[i] == 2 * mi) {\n\t\tts.push_back(i);\n\t}\n\tif (ts.empty()) {\n\t\trep(i, k)ans.push_back(i);\n\t}\n\telse {\n\t\tint las = ts.back();\n\n\t\tbool onm2 = false;\n\t\tvector<bool> t2(k);\n\t\tfor (int id : ts)t2[id] = true;\n\t\trep(i, las) {\n\t\t\tif (t2[i])continue;\n\t\t\tif (ma >= 2 * a[i] - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\tt2[i] = true;\n\t\t\t\tonm2 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\t\tif (onm2) {\n\t\t\trep(i, k)if (a[i] == ma) {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> ad = makev(pre, t2);\n\t\tfor (int id : ad)ans.push_back(id);\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\trep(i, k)rep(j, k) {\n\t\tif (a[j] > 2 * a[i]) {\n\t\t\tcout << -1 << \"\\n\"; return;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\twhile (a[0]>0) {\n\t\tint mi = mod;\n\t\tint ma = 0;\n\t\trep(i, k) {\n\t\t\tmi = min(mi, a[i]);\n\t\t\tma = max(ma, a[i]);\n\t\t}\n\t\tvector<int> ts;\n\t\trep(i, k)if (a[i] == 2 * mi) {\n\t\t\tts.push_back(i);\n\t\t}\n\t\tif (ts.empty()) {\n\t\t\tvector<int> cop = a;\n\t\t\trep(i, k)cop[i]--;\n\t\t\t\n\t\t\tvector<bool> is2(k, false);\n\t\t\tvector<int> nt = makev(ans,is2);\n\t\t\tvector<int> ad = calc(nt,cop);\n\t\t\tvector<int> nnt = nt;\n\t\t\tfor (int id : ad)nnt.push_back(id);\n\n\t\t\tbool ald = false;\n\t\t\trep(i, k) {\n\t\t\t\tif (is2[i])continue;\n\t\t\t\tif (ma >= 2 * a[i] - 1)continue;\n\t\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\t\tif (!ald) {\n\t\t\t\t\t\tald = true;\n\t\t\t\t\t\trep(j, k)if (a[j] == ma) {\n\t\t\t\t\t\t\tif (!is2[j]) {\n\t\t\t\t\t\t\t\tis2[j] = true;\n\t\t\t\t\t\t\t\tcop[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis2[i] = true;\n\t\t\t\t\tcop[i]--;\n\t\t\t\t}\n\t\t\t\tvector<int> cur = makev(ans,is2);\n\t\t\t\tad = calc(cur,cop);\n\t\t\t\tvector<int> ccur = cur;\n\t\t\t\tfor (int id : ad)ccur.push_back(id);\n\t\t\t\tif (nnt > ccur) {\n\t\t\t\t\tswap(nt, cur);\n\t\t\t\t\tswap(nnt, ccur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int id : nt) {\n\t\t\t\tans.push_back(id);\n\t\t\t\ta[id]--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvector<int> nex = calc(ans,a);\n\t\t\tfor (int id : nex) {\n\t\t\t\ta[id]--;\n\t\t\t\tans.push_back(id);\n\t\t\t}\n\t\t}\n\t\t/*rep(i, ans.size()) {\n\t\t\tif (i > 0) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << ans[i] + 1;\n\t\t}cout << \"\\n\";*/\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint k;\n\tcin >> k;\n\tvector<int> freq(k);\n\tfor(int& x : freq) cin >> x;\n\tint minv = 1000000, maxv = -1;\n\tfor(int x : freq){\n\t\tminv = min(minv, x); maxv = max(maxv, x);\n\t}\n\tint sum = 0;\n\tfor(int x : freq) sum += x;\n\tif(minv * 2 < maxv){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> ans;\n\tint maxworks = 0;\n\twhile((int)ans.size() < sum){\n\t\tbool found = false;\n\t\tfor(int nxt = 0; nxt < k; nxt++){\n\t\t\tvector<int> cans = ans;\n\t\t\tcans.push_back(nxt);\n\t\t\tint cmaxworks = maxworks;\n\t\t\t{\n\t\t\t\tif((int)cans.size() >= k){\n\t\t\t\t\tvector<int> d(k, 0);\n\t\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\t\td[cans[(int)cans.size() - 1 - i]]++;\n\t\t\t\t\t}\n\t\t\t\t\tbool works = true;\n\t\t\t\t\tfor(int i = 0; i < k; i++) if(!d[i]) works = false;\n\t\t\t\t\tif(works) cmaxworks = (int)cans.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cfreq = freq;\n\t\t\tcfreq[nxt]--;\n\t\t\tif(cfreq[nxt] < 0) continue;\n\t\t\tvector<int> known;\n\t\t\tfor(int f = cmaxworks; f < (int)cans.size(); f++) known.push_back(cans[f]);\n\t\t\tvector<int> zk = known;\n\t\t\tsort(zk.begin(), zk.end());\n\t\t\tif(unique(zk.begin(), zk.end()) != zk.end()) continue;\n\t\t\tbool ok = false;\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t}\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tfor(int b = cmaxworks - 1; b >= 0; b--){\n\t\t\t\t\tif(cur[cans[b]]) break;\n\t\t\t\t\tcur[cans[b]] = 1;\n\t\t\t\t\tint a = cans[b];\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tint minval = 1000000;\n\t\t\t\tfor(int b : dfreq) minval = min(minval, b);\n\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\tif(cur[i]) continue;\n\t\t\t\t\tif(dfreq[i] > 2 * minval){\n\t\t\t\t\t\tdfreq[i]--;\n\t\t\t\t\t\tcur[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ming = 100000, maxg = 0;\n\t\t\t\tfor(int b : dfreq) ming = min(ming, b);\n\t\t\t\tfor(int b : dfreq) maxg = max(maxg, b);\n\t\t\t\tif(ming * 2 >= maxg){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(nxt);\n\t\t\t\tmaxworks = cmaxworks;\n\t\t\t\tfound = true;\n\t\t\t\tfreq[nxt]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for(int b : ans) cerr << b << ' ';\n\t\t// cerr << '\\n';\n\t\tassert(found);\n\t}\n\tfor(int b : ans) cout << b+1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\n\tif(mn*2+1==mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tret=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n//\t\tfor(int i=1;i<=l3;i++){\n//\t\t\tcerr << z[i] << \" \";\n//\t\t}\n//\t\tputs(\"\");\n\t\tif(p1<p2)return ret;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tcerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";puts(\"\");\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n//\t\tcout << ext[i] << \" \";\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n//\tputs(\"\");\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, s, a[MAXN];\nint x, y, cur[MAXN], res[MAXN], ans[MAXN];\nbool cnp(int s, int t) {\n\tif ((a[s] == x) == (a[t] == x)) return s < t;\n\telse return (a[s] == x) < (a[t] == x);\n}\nvoid work(int len) {\n\tbool valid = true, found = false;\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]--;\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\tif (Min * 2 >= Max) {\n\t\tfound = true;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tres[i] = cur[i];\n\t\tsort(res + 1, res + len + 1);\n\t} else if (Min * 2 + 1 == Max) {\n\t\tx = Min, y = Max;\n\t\tint k1 = 0, k2 = 0, k = 0;\n\t\tstatic int res1[MAXN], res2[MAXN];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (a[cur[i]] == Min || a[cur[i]] == Max) res1[++k1] = cur[i];\n\t\t\telse res2[++k2] = cur[i];\n\t\tsort(res1 + 1, res1 + k1 + 1, cnp);\n\t\tsort(res2 + 1, res2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2) {\n\t\t\t\tif (res1[x1] < res2[x2]) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t} else {\n\t\t\t\tif (x1 <= k1) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t}\n\t\tfound = true;\n\t\tfor (int i = len + 1; i <= n; i++)\n\t\t\tif (a[cur[i]] == Min) found = false;\n\t\tfound |= (x1 == 0) || (a[res1[1]] == Max);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]++;\n\tif (!valid || !found) res[1] = 0;\n}\nbool cmp(int *a, int *b) {\n\tint pos = 1;\n\twhile (a[pos] == b[pos]) pos++;\n\treturn a[pos] < b[pos];\n}\nbool check() {\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\treturn Min * 2 >= Max;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tif (!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcur[i] = i;\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[res[i]]--;\n\t\tcur[i] = res[i];\n\t\tans[m] = res[i];\n\t}\n\twhile (m != s) {\n\t\tstatic int inc[MAXN];\n\t\tmemset(inc, 0, sizeof(inc));\n\t\tint len = 0; inc[1] = n + 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (res[1] != 0 && cmp(res, inc)) {\n\t\t\t\tlen = i;\n\t\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\t\tinc[j] = res[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i + len <= n; i++)\n\t\t\tcur[i] = cur[i + len];\n\t\tfor (int i = 1; i <= len; i++) {\n\t\t\tans[++m] = inc[i];\n\t\t\tcur[n - len + i] = inc[i], a[inc[i]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 1005\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nint cnt[SIZE];\nbool use[SIZE];\nbool use2[SIZE];\nint ans[SIZE];\nint n,sz;\n\nint get_first()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\tif(mn*2<mx) return SIZE;\n\tif(mn*2>mx) return 0;\n\tfor(int i=0;i<n;i++) if(A[i]>mn) return i;\n\treturn -1;\n}\nbool impossible()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\treturn mn*2<mx;\n}\nbool check()\n{\n\tfor(int i=0;i<n;i++) use[i]=use2[i]=false;\n\tint from=sz-1;\n\twhile(from>=0)\n\t{\n\t\tif(use[ans[from]]) break;\n\t\tuse[ans[from]]=true;\n\t\tfrom--;\n\t}\n\tfrom++;\n\t//printf(\"%d %d : %d\\n\",sz,ans[sz-1],from);\n\t\n\tint s=0,e=0;\n\tint last=0;\n\twhile(last<from)\n\t{\n\t\twhile(e<sz&&!use2[ans[e]])\n\t\t{\n\t\t\tuse2[ans[e]]=true;\n\t\t\te++;\n\t\t}\n\t\tif(s==last&&e-s<n) return false;\n\t\tif(e-s==n) last=e;\n\t\tuse2[ans[s]]=false;\n\t\ts++;\n\t}\n\tfor(int i=0;i<n;i++) cnt[i]=A[i];\n\tfor(int i=from;i<sz;i++) cnt[ans[i]]++;\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmn=min(mn,cnt[i]);\n\t\tmx=max(mx,cnt[i]);\n\t}\n\t//printf(\"%d %d : %d %d %d\\n\",sz,ans[sz-1],mn,mx,from);\n\tif(mn*2<mx) return false;\n\tif(mn*2>mx) return true;\n\tint f=SIZE;\n\tfor(int i=from;i<sz;i++)\n\t{\n\t\tif(cnt[ans[i]]==mn)\n\t\t{\n\t\t\tf=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(f==SIZE) return true;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(A[i]==mx&&!use[i]) return false;\n\t}\n\tfor(int i=f;i<sz;i++)\n\t{\n\t\tif(cnt[ans[i]]==mx)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tsum+=A[i];\n\t}\n\tif(impossible())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsz=0;\n\tfor(int i=0;i<sum;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(A[j]>0)\n\t\t\t{\n\t\t\t\tA[j]--;\n\t\t\t\tans[sz++]=j;\n\t\t\t\tif(check()) break;\n\t\t\t\tA[j]++;\n\t\t\t\tsz--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++) printf(\"%d \",ans[i]+1);\n\tputs(\"\");\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint a[105], type[105], cur[205];\nvoid pr(int x) {\n\tprintf(\"%d \", x);\n\t--a[x];\n}\nint main() {\n\tint k, min=-1, max=0, active=0;\n\tscanf(\"%d\", &k);\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(a[i]<1u*min) min=a[i];\n\t\tif(a[i]>max) max=a[i];\n\t}\n\tif(max>2*min) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(; min; --min) {\n\t\tfor(int x=0; x<=active; pr(++x)) {\n\t\t\tint min1=k+1, max2=0;\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(a[i]==min) {\n\t\t\t\t\ttype[i]=1;\n\t\t\t\t\tif(min1==k+1) min1=i;\n\t\t\t\t} else if(a[i]==2*min) {\n\t\t\t\t\ttype[i]=2;\n\t\t\t\t\tmax2=i;\n\t\t\t\t} else {\n\t\t\t\t\ttype[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==0) {\n\t\t\t\t\tif(i<max2)\n\t\t\t\t\t\ttype[i]=2;\n\t\t\t\t\telse\n\t\t\t\t\t\ttype[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt=0;\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==2)\n\t\t\t\t\tcur[++cnt]=i;\n\t\t\t}\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==1)\n\t\t\t\t\tcur[++cnt]=i;\n\t\t\t}\n\t\t\tfor(int i=1; i<=k; ++i) {\n\t\t\t\tif(type[i]==2)\n\t\t\t\t\tcur[++cnt]=i;\n\t\t\t}\n\t\t\tif(x==active || cur[1]<=x) {\n\t\t\t\tfor(int i=1; i<=cnt; ++i) pr(cur[i]);\n\t\t\t\tactive=max2?0:min1-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int K=105,N=1005;\nint k,n;\nint a[K];\nvector<int>merge(const vector<int>&a,const vector<int>&b)\n{\n\tvector<int>res;\n\tsize_t i=0,j=0;\n\twhile(i<a.size()&&j<b.size())\n\t{\n\t\tif(a[i]<b[j]) res.push_back(a[i]),i++;\n\t\telse res.push_back(b[j]),j++;\n\t}\n\twhile(i<a.size())\n\t\tres.push_back(a[i]),i++;\n\twhile(j<b.size())\n\t\tres.push_back(b[j]),j++;\n\treturn res;\n}\nint ans[N],tot;\nint b[K];\nbool pos[K];\nvector<int>add(int len)\n{\n\tfor(int i=1;i<=k;i++)\n\t\tpos[i]=false,b[i]=a[i];\n\tvector<int>pre;\n\tfor(int i=tot,j=1;i>=1&&j<=k-len;i--,j++)\n\t\tpre.push_back(ans[i]);\n\tfor(int u:pre)         \n\t\tpos[u]=true;        \n\tfor(int i=1;i<=k;i++)\n\t\tif(!pos[i]) b[i]--;\n\tfor(int i=1;i<=k;i++)\n\t\tif(b[i]<0) return {k+1};\n\tint Min=*min_element(b+1,b+k+1),Max=*max_element(b+1,b+k+1);\n\tif(Min*2>=Max)\n\t{\n\t\tvector<int>res;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]) res.push_back(i);\n\t\treturn res;\n\t}\n\telse if(Min*2+1==Max)\n\t{\n\t\tvector<int>x,y;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Max) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Min) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]!=Min&&b[i]!=Max) y.push_back(i);\n\t\tvector<int>res=merge(x,y);\n\t\tpre.insert(pre.end(),res.begin(),res.end());\n\t\tint L=0,R=(int)(pre.size())-1;\n\t\tfor(int i=0;i<pre.size();i++)\n\t\t{                  \n\t\t\tif(b[pre[i]]==Max) L=max(L,i);\n\t\t\tif(b[pre[i]]==Min) R=min(R,i);\n\t\t}\n\t\tif(L<R) return res;\n\t\telse return {k+1};\n\t}\n\telse return {k+1};\n}\nvoid solve()\n{\n\tvector<int>res={k+1};\n\tfor(int len=1;len<=k&&tot+len<=n;len++)\n\t{\n\t\tint d=k-len;\n\t\tif(tot-d>=0)\n\t\t{\n\t\t\tvector<int>now=add(len);\n\t\t\tres=min(res,now);\n\t\t}\n\t}\n\tfor(int u:res)\n\t{\n\t\tans[++tot]=u;\n\t\ta[u]--;\n\t\tprintf(\"%d \",u);\n\t}\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++)\n\t\tscanf(\"%d\",&a[i]),n+=a[i];\n\tint Min=*min_element(a+1,a+k+1),Max=*max_element(a+1,a+k+1);\n\tif(2*Min+1<=Max)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(tot<n)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tvi Ans;\n\t\tset<pii> S;\n\t\tfor(int i=1;i<=k;i++) S.insert({H[i],i});\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tset<pii> NS;\n\t\t\tint min = (*S.begin()).first;\n\t\t\tif(min==0) break;\n\t\t\tfor(auto p:S)\n\t\t\t{\n\t\t\t\tif(p.first==min)\n\t\t\t\t{\n\t\t\t\t\tD.push_back(p.second);\n\t\t\t\t\tNS.insert({p.first-1,p.second});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tD.push_back(p.second);\n\t\t\t\t\tD.push_front(p.second);\n\t\t\t\t\tNS.insert({p.first-2,p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prin(D);\n\t\t\tfor(auto d:D) Ans.push_back(d);\n\t\t\tS=NS;\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[la] < sb[lb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[sa[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= ansptr; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXVALS = 100;\n\nint nvals;\nint cnt[MAXVALS];\nvector<int> ans;\n\nint rem[MAXVALS];\nbool seen[MAXVALS];\n\nvector<int> calc(int nblock) {\n\tREP(i, nvals) rem[i] = cnt[i] - nblock;\n\tREP(i, nvals) if (rem[i] > nblock) return vector<int>();\n\n\tvector<vector<int>> suff(nblock);\n\tREP(i, rem[0]) suff[i].PB(0);\n\trem[0] = 0;\n\twhile (true) {\n\t\tint mxidx = -1;\n\t\tREP(i, nvals) if (rem[i] > 0 && (mxidx == -1 || rem[i] > rem[mxidx])) mxidx = i;\n\t\tif (mxidx == -1) break;\n\t\tREP(i, nvals) if (i <= mxidx) {\n\t\t\tREP(j, rem[i]) suff[nblock - rem[mxidx] + j].PB(i);\n\t\t\trem[i] = 0;\n\t\t}\n\t}\n\tvector<vector<int>> perm(nblock);\n\tREP(i, nblock) {\n\t\tperm[i] = suff[i];\n\t\tREP(j, nvals) seen[j] = false;\n\t\tREPSZ(j, perm[i]) seen[perm[i][j]] = true;\n\t\tREP(j, nvals) if (!seen[j]) perm[i].PB(j);\n\t}\n\tvector<int> ret;\n\tREP(i, nblock) {\n\t\tREPSZ(j, perm[i]) ret.PB(perm[i][j]);\n\t\tREPSZ(j, suff[i]) ret.PB(suff[i][j]);\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tbool ret = false;\n\tint mxblock = cnt[0]; FOR(i, 1, nvals) mxblock = min(mxblock, cnt[i]);\n\tFORE(i, 1, mxblock) {\n\t\tvector<int> cur = calc(i);\n\t\tif (SZ(cur) == 0) continue;\n\t\tif (ret == false || cur < ans) ret = true, ans = cur;\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &nvals);\n\tREP(i, nvals) scanf(\"%d\", &cnt[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i] + 1); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\n\tif(mn*2+1==mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tret=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n//\t\tfor(int i=1;i<=l3;i++){\n//\t\t\tcerr << z[i] << \" \";\n//\t\t}\n//\t\tputs(\"\");\n\t\tif(p1<p2)return ret;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n\tfor(int extlen=1;extlen<=k;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tcerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";puts(\"\");\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tcerr << ext[i] << \" \";\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n//\tputs(\"\");\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            //\n\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nbool possiblePrefix(vector<pair<int, int>> A, vector<int> prefix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n  for (int x : prefix) A[where[x]].first++;\n\n  sort(A.begin(), A.end());\n  if (A[0].first * 2 < A.back().first) return false;\n\n  vector<bool> isOne(K, false), isTwo(K, false);\n  int min = A[0].first, nTwos = 0;\n  for (int i = 0; i < K; ++i) {\n    if (min * 2 == A[i].first) {\n      isTwo[A[i].second] = true;\n      nTwos++;\n    }\n    if (min == A[i].first) isOne[A[i].second] = true;\n  }\n  reverse(prefix.begin(), prefix.end());\n  while (prefix.size() && isTwo[prefix.back()]) {\n    nTwos--;\n    prefix.pop_back();\n  }\n  if (!nTwos) return true;\n  for (int x : prefix)\n    if (isOne[x]) return false;\n  return true;\n}\n\nbool possible(vector<pair<int, int>> A, const vector<int>& suffix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n  for (int i = 0; i < K; ++i) {\n    if (possiblePrefix(A, {})) return true;\n    int j = where[suffix[i]];\n    if (A[j].first == 0) break;\n    A[j].first--;\n  }\n  return false;\n}\n\nbool possibleFinish(vector<pair<int, int>> A, vector<int>& B, int coveredUpTo) {\n  int K = A.size();\n  vector<bool> seen(K, false);\n  vector<int> prefix;\n  if (B.size()) {\n    for (int32_t i = B.size() - 1; i >= 0; --i) {\n      if (seen[B[i]]) {\n        if (coveredUpTo <= i) return false;\n        break;\n      }\n      prefix.push_back(B[i]);\n      seen[B[i]] = true;\n    }\n  }\n  reverse(prefix.begin(), prefix.end());\n  if ((int)prefix.size() == K) return possible(A, prefix);\n  while (coveredUpTo + prefix.size() >= B.size()) {\n    if (possiblePrefix(A, prefix)) return true;\n    if (prefix.size()) {\n      prefix.erase(prefix.begin());\n    } else {\n      break;\n    }\n  }\n  return false;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n  vector<int> B;\n\n  if (!possibleFinish(A, B, 0)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int coveredUpTo = 0;\n  while (true) {\n    int tot = 0;\n    for (auto& p : A) tot += p.first;\n    if (tot == 0) break;\n\n    vector<int> where(K);\n    for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n    int x = -1;\n    for (int i = 0; i < K; ++i) {\n      if (A[where[i]].first == 0) continue;\n\n      A[where[i]].first--;\n      B.push_back(i);\n      if (possibleFinish(A, B, coveredUpTo)) {\n        x = i;\n        break;\n      }\n      B.pop_back();\n      A[where[i]].first++;\n    }\n    assert(x != -1);\n    if (B.size() >= K) {\n      vector<int> p(B.end() - K, B.end());\n      sort(p.begin(), p.end());\n      bool isPerm = true;\n      for (int i = 0; i < K; ++i) isPerm &= p[i] == i;\n      if (isPerm) {\n        assert(coveredUpTo + K >= B.size());\n        coveredUpTo = B.size();\n      }\n    }\n  }\n\n  assert(coveredUpTo == B.size());\n  for (int x : B) cout << x + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repn(i, n) for(int i=1;i<=n;i++)\n\nint n, k, a[105], b[105], ans[1005], mn=100000, mx=-100000;\nint main(){\n\tcin >> k;\n\trepn(i, k){\n\t\tcin >> a[i];\n\t\tn += a[i];\n\t\tmn = min(mn, a[i]);\n\t\tmx = max(mx, a[i]);\n\t}\n\tif(2*mn < mx){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tint las = 0;\n\trepn(id, n){\n\t\trepn(i, k){\n\t\t\tif(a[i] == 0) continue;\n\t\t\tbool OK = 0;\n\t\t\tfor(int add=0;add<k;add++){\n\t\t\t\tif(n-id < add || add+id-las > k) break;\n\t\t\t\tif(add+id < k) continue;\n\t\t\t\tmemcpy(b, a, sizeof(a));\n\t\t\t\tb[i]--;\n\t\t\t\tbool ex[105] = {};\n\t\t\t\tfor(int x=id+add-k+1;x<id;x++) ex[ans[x]] = 1;\n\t\t\t\tex[i] = 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\trepn(x, k){\n\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\tcnt++; if(a[x] == 0) cnt++; b[x]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnt != add) continue;\n\t\t\t\tif(n-id-add <= k){\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] > 1) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\t\tif(b[x] == 0) b[x]++;\n\t\t\t\t\t\t\t\telse bad = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(b[v] >= 1) break;\n\t\t\t\t\t\t\telse b[v]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k) if(b[x] != 1) bad = 1;\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmn = 100000, mx = -100000;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tmn = min(mn, b[x]);\n\t\t\t\t\t\tmx = max(mx, b[x]);\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn >= mx){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t\tif(2*mn+1 < mx){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbool need[105] = {};\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(b[x] == mx) need[x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbool bad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!ex[x]){\n\t\t\t\t\t\t\tif(need[x] == 1) bad = 1;\n\t\t\t\t\t\t\tneed[x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tfor(int x=id;x>=1;x--){\n\t\t\t\t\t\t\tint v = (x==id?i:ans[x]);\n\t\t\t\t\t\t\tif(need[v]) break;\n\t\t\t\t\t\t\tneed[v] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbad = 0;\n\t\t\t\t\trepn(x, k){\n\t\t\t\t\t\tif(!need[x] && mn == b[x]) bad = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(!bad){\n\t\t\t\t\t\tOK = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(OK){\n\t\t\t\tans[id] = i;\n\t\t\t\tif(id >= k){\n\t\t\t\t\tunordered_set<int>S;\n\t\t\t\t\tfor(int i=id-k+1;i<=id;i++) S.insert(ans[i]);\n\t\t\t\t\tif(S.size() == k) las = id;\n\t\t\t\t}\n\t\t\t\ta[i]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans[id] << ' ';\n\t}\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,k,a[N],pos[N],cnt[N],b[N],pmx[N],pmn[N];\nbool check(int l) {\n\tint mx=0;\n\trep(i,0,k) mx=max(mx,b[i]+(l<i));\n\tfor (int j=l-1;j>=0;j--) {\n\t\tmx=max(mx,b[j+1]+1);\n\t\tpmx[j]=mx;\n\t}\n\tint mn=(1<<20);\n\trep(i,0,k) mn=min(mn,2*b[i]);\n\trep(i,0,l-1) {\n\t\tmn=min(mn,2*b[i]-1);\n\t\tpmn[i]=mn;\n\t}\n\tfor (int j=l-2;j>=0;j--) {\n\t\tif (pmx[j]<=pmn[j]) return 1;\n\t}\n\tmx=0,mn=1<<20;\n\trep(i,0,k) {\n\t\tmx=max(mx,b[i]);\n\t\tmn=min(mn,2*b[i]-(i<l));\n\t}\n\tif (mx<=mn) return 1;\n\treturn 0;\n}\nbool check(int l,int r) {\n\trep(z,0,k) cnt[z]=0;\n\trep(z,l+1,r+1) cnt[pos[z]]++;\n\trep(z,0,k) if (cnt[z]>=2) return 0;\n\tfor (int i=l;i>=0;i--) {\n\t\tcnt[pos[i]]++;\n\t\tif (cnt[pos[i]]>=2) return 0;\n\t\tint t=0;\n\t\trep(j,i,r+1) b[t++]=a[pos[j]]+1;\n\t\trep(j,0,k) if (!cnt[j]) b[t++]=a[j];\n\t\tif (check(r-i+1)) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d\",&k);\n\trep(i,0,k) scanf(\"%d\",a+i),n+=a[i];\n\tif (*max_element(a,a+k)>*min_element(a,a+k)*2) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint lastp=-1;\n\trep(i,0,n) {\n\t\tbool vv=0;\n\t\trep(j,0,k) if (a[j]>0) {\n\t\t\ta[j]--;\n\t\t\tpos[i]=j;\n\t\t\tif (check(lastp+1,i)) {\n\t\t\t\tif (i>=k-1) {\n\t\t\t\t\trep(z,0,k) cnt[z]=0;\n\t\t\t\t\trep(z,i-k+1,i+1) cnt[pos[z]]++;\n\t\t\t\t\tbool val=1;\n\t\t\t\t\trep(z,0,k) if (cnt[z]==0) val=0;\n\t\t\t\t\tif (val) lastp=i;\n\t\t\t\t}\n\t\t\t\t//printf(\"valid %d %d\\n\",i,j);\n\t\t\t\tvv=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta[j]++;\n\t\t}\n\t\tassert(vv);\n\t}\n\trep(i,0,n) printf(\"%d \",pos[i]+1); puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 2333\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\npii a[sz];\n\nint main()\n{\n\tfile();\n\tread(n);\n\trep(i,1,n) read(a[i].fir),a[i].sec=i;\n\tsort(a+1,a+n+1);\n\tif (a[1].fir*2<a[n].fir) return puts(\"-1\"),0;\n\tfor (int l=n;l;--l)\n\t{\n\t\twhile (l!=1&&a[l-1].fir==a[l].fir) --l;\n\t\twhile (a[l].fir!=a[l-1].fir)\n\t\t{\n\t\t\trep(i,l,n) printf(\"%d \",a[i].sec),--a[i].fir;\n\t\t\tif (l!=1) rep(i,1,n) printf(\"%d \",a[i].sec),--a[i].fir;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[109];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint k;cin>>k;\n\trepA(i,1,k) cin>>a[i];\n\tint x = 1009,y=0;\n\trepA(i,1,k) x = min(x,a[i]),y=max(y,a[i]);\n\tif(y>2*x){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tvi ans;\n\trep(qq,x){\n\t\tvi cur;\n\t\tbool fg[109];\n\t\tfill(fg);\n\t\trepA(i,1,k){\n\t\t\tif(i==1&&a[i]>x-qq){\n\t\t\t\tcur.pb(1);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[1]=1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t\telse if(a[i]==2*(x-qq)){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i] = 1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k) if(!fg[i]) a[i]--,ans.pb(i);\n\t\ttrav(i,cur) ans.pb(i);\n\t}\n\ttrav(i,ans) cout<<i<<' ';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\nint k, a[105], p[1005], last[105], l=1, sat;\nbool chk(int x, int y) {\n\tif(last[x]<l) {\n\t\tif(last[y]<=sat) {\n\t\t\treturn 2*a[x]>=a[y];\n\t\t} else {\n\t\t\treturn 2*a[x]>=a[y]+1;\n\t\t}\n\t} else {\n\t\tif(last[y]<=sat) {\n\t\t\treturn 2*a[x]+1>=a[y];\n\t\t} else {\n\t\t\tif(last[x]<last[y])\n\t\t\t\treturn 2*a[x]>=a[y];\n\t\t\telse\n\t\t\t\treturn 2*a[x]+1>=a[y];\n\t\t}\n\t}\n}\nbool check() {\n\tfor(int x=1; x<=k; ++x) {\n\t\tfor(int y=1; y<=k; ++y) {\n\t\t\tif(x==y) continue;\n\t\t\tif(!chk(x, y)) return false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\", &k);\n\tint n=0;\n\tfor(int i=1; i<=k; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tn+=a[i];\n\t}\n\tif(!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tint &P=p[i], lsave=l;\n\t\tif(i-l==k) {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=last[P]+1;\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t\tif(i-l+1==k) sat=i;\n\t\t} else {\n\t\t\tfor(P=1; P<=k; ++P) {\n\t\t\t\tif(a[P]==0 || last[P]>sat) continue;\n\t\t\t\tint save=last[P];\n\t\t\t\t--a[P];\n\t\t\t\tl=std::max(l, last[P]+1);\n\t\t\t\tlast[P]=i;\n\t\t\t\tif(check()) break;\n\t\t\t\t++a[P];\n\t\t\t\tl=lsave;\n\t\t\t\tlast[P]=save;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) printf(\"%d \", p[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      pair<vi, int> best(solve(a, a.size()), 0);\n      for (int l = 1; l < a.size(); ++l) {\n        --a[v0[l - 1]];\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, a.size() - l, v0[l]);\n        if (v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n      }\n      best.first.resize(best.second);\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second == 0 ? -1 : v0[best.second - 1]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] != *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\twhile (sz < sum){\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tset<int> A, B;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.insert(q[j]);\n\t\t\t}\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tbool flag = (mxm == 2*mnm+1);\n\t\t\tvector<int> me;\n\t\t\twhile (!A.empty()){\n\t\t\t\tint x = *A.begin();\n\t\t\t\tA.erase(A.begin());\n\t\t\t\tif (a[x] == mnm and flag){\n\t\t\t\t\tB.insert(x);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[++now] = x;\n\t\t\t\tme.push_back(x);\n\t\t\t}\n\t\t\tfor (auto it : B){\n\t\t\t\tp[++now] = it;\n\t\t\t\tme.push_back(it);\n\t\t\t}\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n        rep(k,best_js_size) {\n\n        }\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, s, a[MAXN];\nint x, y, cur[MAXN], res[MAXN], ans[MAXN];\nbool cnp(int s, int t) {\n\tif ((a[s] == x) == (a[t] == x)) return s < t;\n\telse return (a[s] == x) < (a[t] == x);\n}\nvoid work(int len) {\n\tbool valid = true, found = false;\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]--;\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\tif (Min * 2 >= Max) {\n\t\tfound = true;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tres[i] = cur[i];\n\t\tsort(res + 1, res + len + 1);\n\t} else if (Min * 2 + 1 == Max) {\n\t\tx = Min, y = Max;\n\t\tint k1 = 0, k2 = 0, k = 0;\n\t\tstatic int res1[MAXN], res2[MAXN];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (a[cur[i]] == Min || a[cur[i]] == Max) res1[++k1] = cur[i];\n\t\t\telse res2[++k2] = cur[i];\n\t\tsort(res1 + 1, res1 + k1 + 1, cnp);\n\t\tsort(res2 + 1, res2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2) {\n\t\t\t\tif (res1[x1] < res2[x2]) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t} else {\n\t\t\t\tif (x1 <= k1) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t}\n\t\tfound = true;\n\t\tfor (int i = len + 1; i <= n; i++)\n\t\t\tif (a[cur[i]] == Min) found = false;\n\t\tfound |= (x1 == 0) || (a[res1[1]] == Max);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]++;\n\tif (!valid || !found) res[1] = 0;\n}\nbool cmp(int *a, int *b) {\n\tint pos = 1;\n\twhile (a[pos] == b[pos]) pos++;\n\treturn a[pos] < b[pos];\n}\nbool check() {\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\treturn Min * 2 >= Max;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tif (!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcur[i] = i;\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[res[i]]--;\n\t\tcur[i] = res[i];\n\t\tans[m] = res[i];\n\t}\n\twhile (m != s) {\n\t\tstatic int inc[MAXN];\n\t\tmemset(inc, 0, sizeof(inc));\n\t\tint len = 0; inc[1] = n + 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (res[1] != 0 && cmp(res, inc)) {\n\t\t\t\tlen = i;\n\t\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\t\tinc[j] = res[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i + len <= n; i++)\n\t\t\tcur[i] = cur[i + len];\n\t\tfor (int i = 1; i <= len; i++) {\n\t\t\tans[++m] = inc[i];\n\t\t\tcur[n - len + i] = inc[i], a[inc[i]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[109];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint k;cin>>k;\n\trepA(i,1,k) cin>>a[i];\n\tint x = 1009,y=0;\n\trepA(i,1,k) x = min(x,a[i]),y=max(y,a[i]);\n\tif(y>2*x){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tvi ans;\n\trep(qq,x){\n\t\tvi cur;\n\t\tbool fg[109];\n\t\tfill(fg);\n\t\tint gg = 1;\n\t\tif(a[1]<=(x-qq)+1){\n\t\t\trepA(i,1,k) if(a[i]>=2*(x-qq)-1) {\n\t\t\t\tgg=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k){\n\t\t\tif(i<=gg&&a[i]>x-qq){\n\t\t\t\tcur.pb(1);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[1]=1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t\telse if(a[i]==2*(x-qq)){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i] = 1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k) if(!fg[i]) a[i]--,ans.pb(i);\n\t\ttrav(i,cur) ans.pb(i);\n\t}\n\ttrav(i,ans) cout<<i<<' ';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2020.06.28 19:33:21\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\nint main() {\n    int n, sum = 0, mi = INF, mx = -INF;\n    scanf(\"%d\", &n);\n    vector<int> a(n), ans;\n    for(auto &g : a) {\n        scanf(\"%d\", &g);\n        mi = min(mi, g);\n        mx = max(mx, g);\n        sum += g;\n    }\n    if(mi * 2 < mx) { puts(\"-1\"); return 0; }\n    while((int)ans.size() < sum) {\n        vector<int> add, left, vis, bestleft;\n        for(int len = 1; len <= n; ++len) {\n            if((int)ans.size() + len < n || (int)ans.size() + len > sum) continue;\n            vector<int> vals;\n            left = a, vis.assign(n, 1);\n            for(int j = 0; j < n - len; ++j)\n                vis[ans[ans.size()-j-1]] = 0;\n            for(int j = 0; j < n; ++j) if(vis[j])\n                left[j]--, vals.push_back(j);\n            mi = INF, mx = -INF;\n            for(int j = 0; j < n; ++j) {\n                mi = min(mi, left[j]);\n                mx = max(mx, left[j]);\n            }\n            if(mi < 0 || mi * 2 + 1 < mx) continue;\n            int idx = INF, xdx = -INF;\n            for(int j = (int)ans.size()-len+n; j < (int)ans.size(); ++j) {\n                if(left[ans[j]] == mi) idx = min(idx, j);\n                if(left[ans[j]] == mx) xdx = max(xdx, j);\n            }\n            if(mi * 2 + 1 == mx && idx < xdx) continue;\n            xdx = -INF;\n            for(int j = 0; j < n; ++j) if(left[j] == mx) xdx = j;\n#define key(x) (left[x] == mi ? pii(max(x, xdx), 1) : pii(x, 0))\n            if(mi * 2 + 1 == mx)\n                sort(vals.begin(), vals.end(), [&](int x, int y) { return key(x) < key(y);} );\n            else sort(vals.begin(), vals.end());\n            if(add.empty() || add > vals) add = vals, bestleft = left;\n        }\n        assert(!add.empty());\n        a = bestleft, ans.insert(ans.end(), add.begin(), add.end());\n    }\n    for(auto g : ans)\n        printf(\"%d \", g + 1);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n\n  if (A[0].first * 2 < A.back().first) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  while (true) {\n    sort(A.begin(), A.end());\n    assert(A[0].first * 2 >= A.back().first);\n    if (A[0].first == 0) break;\n\n    for (int i = K - 1; i >= 0; --i) cout << A[i].second + 1 << ' ';\n    for (int i = K - 1; i > 0; --i) {\n      if (A[0].first * 2 == A[i].first) {\n        cout << A[i].second + 1 << ' ';\n        --A[i].first;\n      }\n    }\n    for (int i = 0; i < K; ++i) --A[i].first;\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t//\tif (mh() == v) {\n\t\t//\t\t--a[res[h+j+1]];\n\t\t//\t\tbool pn = stvalid();\n\t\t//\t\t++a[res[h+j+1]];\n\n\t\t//\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t//\t\tvector<int> tst{v};\n\t\t//\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t//\t\t\t--a[nv];\n\t\t//\t\t\ttst.pb(nv);\n\t\t//\t\t\tbool ok = p1valid(tst);\n\t\t//\t\t\ttst.pop_back();\n\t\t//\t\t\t++a[nv];\n\t\t//\t\t\tif (ok) {\n\t\t//\t\t\t\tnh = nv;\n\t\t//\t\t\t\tbreak;\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t\tif (nh < nxt)\n\t\t//\t\t\tcontinue;\n\t\t//\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt n;\nvector<Int> a;\nvector<Int> ans;\nInt mx, mn;\nset<int> maxs, mins;\nbool ok[1100];\n\nInt min_initial(Int from, Int to)\n{\n    auto aa = a;\n    vector<int> used(n, 0);\n    for (int i = from; i < to; i++) {\n        if (used[ans[i]])\n            return n;\n        used[ans[i]] = 1;\n        aa[ans[i]]++;\n    }\n\n    Int tmpmx = *max_element(aa.begin(), aa.end());\n    Int tmpmn = *min_element(aa.begin(), aa.end());\n    if (tmpmn * 2 < tmpmx)\n        return n;\n    if (tmpmn * 2 > tmpmx) {\n        for (int i = 0; i < n; i++)\n            if (!used[i])\n                return i;\n        return n;\n    }\n    Int max_cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == tmpmx)\n            max_cnt++;\n    }\n\n    for (int i = from; i < to; i++) {\n        if (aa[ans[i]] == tmpmx)\n            max_cnt--;\n        if (aa[ans[i]] == tmpmn) {\n            if (max_cnt != 0)\n                return n;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == 0)\n            continue;\n        if (used[i])\n            continue;\n        if (max_cnt == 0 && !used[i])\n            return i;\n        if (max_cnt > 0 && aa[i] != tmpmn && !used[i])\n            return i;\n    }\n    return ans[from];\n}\n\nint main()\n{\n    Int as = 0;\n    cin >> n;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        as += a[i];\n    }\n\n    Int mx = *max_element(a.begin(), a.end());\n    Int mn = *min_element(a.begin(), a.end());\n    if (mn * 2 < mx) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < as; i++) {\n        Int nxt = n;\n        for (int j = max(0ll, i - n + 1); j <= i; j++) {\n            nxt = min(nxt, min_initial(j, i));\n            if (!ok[j])\n                break;\n        }\n\n        a[nxt]--;\n        ans.push_back(nxt);\n        if (ans.size() >= n) {\n            set<int> hoge;\n            for (int j = 0; j < n; j++) {\n                hoge.insert(ans[ans.size() - 1 - j]);\n            }\n            if (hoge.size() == n) {\n                for (int j = 0; j < n; j++)\n                    ok[ans.size() - 1 - j] = true;\n            }\n        }\n    }\n\n    for (auto elem : ans)\n        cout << elem + 1 << \" \";\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>     \nusing namespace std;\ntypedef complex<double> base;\ntypedef long double ld;\ntypedef long long ll;\n\t\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair< ll , ll >\n#define vi vector<int>\n#define vvi vector< vi >\n\t\nconst int maxn=(int)(505);\nconst ll mod=(ll)(1e9+7);\nll a[maxn],pre[maxn];\nll dp[maxn][maxn];\nint n;\n     \nll getSum(int l,int r) {\n\tif(l<=r)\treturn pre[r]-(l==0?0:pre[l-1]);\n\treturn pre[n-1]-pre[l-1]+pre[r];\n}\n     \nint main()\t{\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\tcin>>a[i];\n\tpre[0]=a[0];\n\tfor(int i=1;i<n;i++)\tpre[i]=pre[i-1]+a[i];\n\tfor(int i=0;i<n;i++)\tfor(int j=0;j<n;j++) \tdp[i][j]=LLONG_MAX;\n\tfor(int i=0;i<n;i++)\tdp[i][i]=0;\n\tfor(int size=2;size<=n;size++)\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint l=i,r=(i+size-1)%n;\n\t\t\tfor(int j=l;j!=r;j=(j+1)%n)\n\t\t\t\tdp[l][r]=min(dp[l][r],dp[l][j]+dp[(j+1)%n][r]+getSum(l,r));\n\t\t}\n\tll res=LLONG_MAX;\n\tfor(int i=0;i<n;i++) {\n\t\tint l=i,r=(i-1+n)%n;\n\t\tres=min(res,dp[l][r]);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  vector<int> innerSolve(int k, vector<int> a) {\n    int mn = a[0];\n    int mx = a[0];\n    for (int x : a) {\n      mn = min(mn, x);\n      mx = max(mx, x);\n    }\n    if (mx > 2 * mn) {\n      return {};\n    }\n    int total = 0;\n    for (int x : a) total += x;\n    vector<int> res(total, -1);\n    int permStart = 0;\n    int firstUncovered = 0;\n    vector<int> last(k, -1);\n    for (int pos = 0; pos < total; ++pos) {\n      if (pos >= permStart + k) {\n        firstUncovered = pos;\n      }\n      for (int val = 0; val < k; ++val) {\n        if (a[val] > 0) {\n          res[pos] = val;\n          --a[val];\n          vector<int> sa = a;\n          vector<bool> inPerm(k, false);\n          for (int i = permStart; i < pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n          bool ok = false;\n          if (last[val] < permStart) {\n            inPerm[val] = true;\n            for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n            vector<ii> avail;\n            for (int i = 0; i < k; ++i)\n              if (!inPerm[i]) {\n                avail.emplace_back(-a[i], i);\n              }\n            sort(avail.begin(), avail.end());\n            int ptr = 0;\n            for (int plen = k; plen < 2 * k; ++plen) {\n              if (plen > k) {\n                if (permStart + plen - k - 1 <= pos) {\n                  --a[res[permStart + plen - k - 1]];\n                } else {\n                  --a[avail[ptr++].second];\n                }\n              }\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n            }\n          } else if (last[val] == pos - k) {\n            for (int endAt = pos + 1; endAt <= total; ++endAt) {\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n              --a[res[(endAt - permStart) % k + permStart]];\n            }\n          } else {\n            int npermstart = last[val] + 1;\n            if (npermstart <= firstUncovered) {\n              int spermstart = permStart;\n              permStart = npermstart;\n              vector<bool> inPerm(k, false);\n              for (int i = permStart; i <= pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n              for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n              vector<ii> avail;\n              for (int i = 0; i < k; ++i)\n                if (!inPerm[i]) {\n                  avail.emplace_back(-a[i], i);\n                }\n              sort(avail.begin(), avail.end());\n              int ptr = 0;\n              for (int plen = k; plen < 2 * k; ++plen) {\n                if (plen > k) {\n                  if (permStart + plen - k - 1 <= pos) {\n                    --a[res[permStart + plen - k - 1]];\n                  } else {\n                    --a[avail[ptr++].second];\n                  }\n                }\n                mn = a[0];\n                mx = a[0];\n                for (int x : a) {\n                  mn = min(mn, x);\n                  mx = max(mx, x);\n                }\n                if (mn >= 0 && mx <= 2 * mn) {\n                  ok = true;\n                  break;\n                }\n              }\n              if (!ok) {\n                permStart = spermstart;\n              }\n            }\n          }\n          a = sa;\n          if (ok) {\n            last[val] = pos;\n            break;\n          } else {\n            ++a[val];\n            assert(val + 1 < k);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    int tried = 0;\n    while (false) {\n      ++tried;\n      if (tried % 100000 == 0) {\n        cerr << tried << endl;\n      }\n      int k = rand() % 3 + 1;\n      int n = k + rand() % 5;\n      vector<int> seq(n, -1);\n      int permStart = 0;\n      int firstUncovered = 0;\n      vector<int> last(k, -1);\n      for (int i = 0; i < n; ++i) {\n        int step = 0;\n        if (i - permStart >= k) {\n          firstUncovered = i;\n        }\n        while (true) {\n          seq[i] = rand() % k;\n          if (last[seq[i]] < permStart) {\n            break;\n          }\n          if (last[seq[i]] == i - k) {\n            break;\n          }\n          if (i - permStart >= k) {\n            int npermStart = last[seq[i]] + 1;\n            if (n - npermStart >= k && npermStart <= firstUncovered) {\n              permStart = npermStart;\n              break;\n            }\n          }\n          ++step;\n        }\n        last[seq[i]] = i;\n      }\n      vector<int> a(k);\n      for (int x : seq) ++a[x];\n      vector<int> got = innerSolve(k, a);\n      assert(!got.empty());\n      for (int& v : got) {\n        --a[v];\n      }\n      for (int x : a) assert(x == 0);\n      vector<bool> cover(n);\n      for (int i = 0; i + k <= n; ++i) {\n        vector<bool> seen(k);\n        bool ok = true;\n        for (int j = 0; j < k; ++j) {\n          if (seen[got[i + j]]) ok = false;\n          seen[got[i + j]] = true;\n        }\n        if (ok) {\n          for (int j = 0; j < k; ++j) {\n            cover[i + j] = true;\n          }\n        }\n      }\n      for (int i = 0; i < n; ++i) assert(cover[i]);\n      assert(got.size() == seq.size());\n      for (int i = 0; i < got.size(); ++i) {\n        if (seq[i] < got[i]) {\n          assert(false);\n        }\n        if (seq[i] > got[i]) {\n          break;\n        }\n      }\n    }\n    int k;\n    in >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) in >> a[i];\n    vector<int> res = innerSolve(k, a);\n    if (res.empty()) {\n      out << -1 << \"\\n\";\n    } else {\n      for (int x : res) out << x + 1 << \" \";\n      out << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nint main() {\n  std::cin.tie(0); std::ios::sync_with_stdio(false);\n  using P = std::pair<int,int>;\n  int K; std::cin >> K;\n  std::vector<P> p(K);\n  for(int i = 0; i < K; ++i) {\n    std::cin >> p[i].first;\n    p[i].second = i+1;\n  }\n  std::sort(p.begin(), p.end(), std::greater<P>());\n  if(p.front().first > 2*p.back().first) {\n    std::cout << \"-1\\n\";\n    return 0;\n  }\n  for(;;) {\n    for(int i = 0; i < K-1; ++i) {\n      --p[i].first;\n      std::cout << p[i].second << \" \";\n    }\n    --p.back().first;\n    std::cout << p.back().second;\n    int v = p.front().first;\n    if(v < 1) break;\n    auto last = std::partition_point(p.begin(), p.end(),\n      [&](auto const& x){ return x.first == v; });\n    for(auto it = p.begin(); it != last; ++it) {\n      --it->first;\n      std::cout << \" \" << it->second;\n    }\n    if(p.front().first < 1) break;\n    std::cout << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint k;\n\tcin >> k;\n\tvi a(k);\n\ttrav(x, a) cin >> x;\n\n\tint mn = 1000, mx = 1;\n\ttrav(x, a) mn = min(mn, x);\n\ttrav(x, a) mx = max(mx, x);\n\n\tif(mn * 2 < mx){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tint len = 0;\n\ttrav(x, a) len += x;\n\tvi ans(len, -1);\n\n\tvi cnt(k, 0);\n\tvector<bool> happy(k, true);\n\tvi prev(k, -1);\n\n\trep(i,0,len){\n\t\tmx = 0, mn = 1000;\n\t\ttrav(x, a) mx = max(mx, x);\n\t\ttrav(x, a) mn = min(mn, x);\n\t\tint imx = 1000;\n\t\trep(d,0,k) if(a[d] == mn) imx = min(imx, prev[d]);\n\t\trep(d,0,k) if(happy[d] && a[d]*2 > mx && !(mx>=2*mn && a[d] < mx && prev[d] > imx)){\n\t\t\tans[i] = d;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans[i] < 0){\n\t\t\trep(j,0,i) cout << 1+ans[j] << \" \";\n\t\t\tcout << endl;\n\t\t\ttrav(x, a) cout << x << \" \";\n\t\t\tcout << endl;\n\n\t\t\tcout << mx << \" \" << mn << endl;\n\t\t\tcout << a[ans[i]] << endl;\n\t\t\tcout << imx << \" \" << prev[ans[i]] << endl;\n\t\t\tassert(false);\n\t\t}\n\t\tprev[ans[i]] = i;\n\t\thappy[ans[i]] = false;\n\t\t--a[ans[i]];\n\t\t++cnt[ans[i]];\n\t\tif(i >= k) --cnt[ans[i-k]];\n\t\tif(count(all(cnt), 0) == 0){\n\t\t\trep(d,0,k) happy[d] = true;\n\t\t}\n\t}\n\n\ttrav(x, ans) cout << x+1 << \" \";\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 110;\n\nint N;\nint arr[MAXN];\n\nint parr[MAXN];\nbool used[MAXN];\n\nvector <int> figure (int K)\n{\n    for (int i = 0; i < N; i++)\n        arr[i] = parr[i] - K;\n\n    vector <int> res;\n    for (int i = 0; i < K; i++)\n    {\n        int hneed = -1; // latest one we need\n        int lcant = 1e6; // earliest one we cant\n        for (int j = 0; j < N; j++)\n        {\n            if (!arr[j])\n                lcant = min (lcant, j);\n            if (arr[j] == K - i)\n                hneed = j;\n        }\n\n        if (hneed < lcant)\n        {\n            for (int j = 0; j < N; j++)\n                res.push_back(j);\n            if (hneed == -1 && lcant > 0)\n                hneed = 0;\n            for (int j = 0; j <= hneed; j++)\n            {\n                res.push_back(j);\n                arr[j]--;\n            }\n            continue;\n        }\n        else\n        {\n            for (int j = 0; j <= hneed; j++)\n            {\n                used[j] = false;\n                if (arr[j])\n                {\n                    used[j] = true;\n                    arr[j]--;\n                }\n            }\n\n            for (int j = 0; j < N; j++)\n                if (used[j]) res.push_back(j);\n            for (int j = 0; j < N; j++)\n                if (!used[j]) res.push_back(j);\n            for (int j = 0; j < N; j++)\n                if (used[j]) res.push_back(j);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    int lo = 1e6, hi = 0;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        parr[i] = arr[i];\n        lo = min (lo, arr[i]);\n        hi = max (hi, arr[i]);\n    }\n\n    if (lo * 2 < hi)\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    vector <int> res;\n    for (int x = (hi + 1) / 2; x <= lo; x++)\n    {\n        vector <int> v = figure (x);\n        if (!res.size())\n            res = v;\n\n        bool f = false;\n        for (int i = 0; i < res.size(); i++)\n        {\n            if (v[i] != res[i])\n            {\n                if (v[i] < res[i])\n                {\n                    f = true;\n                }\n                break;\n            }\n        }\n        if (f)\n            res = v;\n    }\n\n    for (int i = 0; i < res.size(); i++)\n    {\n        if (i) cout << \" \";\n        cout << res[i] + 1;\n    }\n    cout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass EPermutationCover {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int K; cin >> K;\n        vector<int> A(K); cin >> A;\n        int mx = *max_element(A.begin(),A.end());\n        vector<vector<int>> Soln;\n\n        for (int t = mx; t <= 2*mx; ++t) {\n            if (*min_element(A.begin(),A.end()) < t - t/2) break;\n\n            vector<int> B = A;\n\n            vector<int> cur;\n            vector<bool> prevOver(K, false);\n            for (int a = 0; a < t; ++a) {\n                vector<bool> canOver(K, false);\n                vector<bool> mustOver(K, false);\n                for (int i = 0; i < K; ++i) {\n                    canOver[i] = !prevOver[i] && (B[i] < (t-a));\n                    mustOver[i] = 2*B[i] == (t-a);\n                }\n\n                vector<bool> isOver(K, false);\n                int first = K;\n                int last = -1;\n                for (int i = 0; i < K; ++i) {\n                    if (mustOver[i]) {\n                        isOver[i] = true;\n                        first = min(i, first);\n                        last = i;\n                    }\n                }\n                for (int i = first; i < K; ++i) {\n                    if (canOver[i]) {\n                        isOver[i] = true;\n                    }\n                }\n                for (int i = 0; i < K; ++i) {\n                    if (!prevOver[i] && !isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n                for (int i = 0; i < K; ++i) {\n                    if (isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n//                cout << \"level \" << a << endl;\n//                cout << \"canover \" << canOver;\n//                cout << \"mustover \" << mustOver;\n//                cout << \"isover \" << isOver;\n\n                prevOver = isOver;\n            }\n\n\n\n            Soln.push_back(cur);\n        }\n\n        if (Soln.empty()) {\n            cout << \"-1\\n\";\n        } else {\n            cout << *min_element(Soln.begin(),Soln.end());\n        }\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEPermutationCover solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops;\nUL P2[100];\nvector<UL> buf;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloops = (loops + 1) / 2;\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\tvector<UL> ans;\n\trep(l, loops) {\n\t\tvector<UL> S, T;\n\t\tUL p = 0;\n\t\trep(i, K) {\n\t\t\tif (P2[i] == loops - l) {\n\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\telse T.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\tfor (; p < K; p++) {\n\t\t\tT.push_back(p);\n\t\t}\n\t\tsort(S.begin(), S.end());\n\t\tsort(T.begin(), T.end());\n\t\tconcat(ans, S);\n\t\tconcat(ans, T);\n\t\tconcat(ans, S);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\tif (p1valid({i})) return i;\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass EPermutationCover {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int K; cin >> K;\n        vector<int> A(K); cin >> A;\n        int mx = *max_element(A.begin(),A.end());\n        vector<vector<int>> Soln;\n\n        for (int t = mx; t <= 2*mx; ++t) {\n            if (*min_element(A.begin(),A.end()) < t - t/2) break;\n\n            vector<int> B = A;\n\n            vector<int> cur;\n            vector<bool> prevOver(K, false);\n            for (int a = 0; a < t; ++a) {\n                vector<bool> canOver(K, false);\n                vector<bool> mustOver(K, false);\n                for (int i = 0; i < K; ++i) {\n                    canOver[i] = !prevOver[i] && (B[i] < (t-a));\n                    mustOver[i] = !prevOver[i] && 2*B[i] == (t-a);\n                }\n\n                vector<bool> isOver(K, false);\n                int first = K;\n                int last = -1;\n                for (int i = 0; i < K; ++i) {\n                    if (mustOver[i]) {\n                        isOver[i] = true;\n                        first = min(i, first);\n                        last = i;\n                    }\n                }\n                if (first == K) {\n                    int i = K-1;\n                    while (i >= 0 && canOver[i]) {\n                        isOver[i] = true;\n                        --i;\n                    }\n                } else {\n                    for (int i = first; i < K; ++i) {\n                        if (canOver[i]) {\n                            isOver[i] = true;\n                        }\n                    }\n                }\n                for (int i = 0; i < K; ++i) {\n                    if (!prevOver[i] && !isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n                for (int i = 0; i < K; ++i) {\n                    if (isOver[i]) {\n                        B[i]--;\n                        cur.push_back(i+1);\n                    }\n                }\n\n//                cout << \"level \" << a << endl;\n//                cout << B;\n//                cout << \"canover \" << canOver;\n//                cout << \"mustover \" << mustOver;\n//                cout << \"isover \" << isOver;\n\n                prevOver = isOver;\n            }\n\n            Soln.push_back(cur);\n        }\n\n//        cout << Soln;\n\n        if (Soln.empty()) {\n            cout << \"-1\\n\";\n        } else {\n            cout << *min_element(Soln.begin(),Soln.end());\n        }\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEPermutationCover solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1050;\n\nint n, sum, ai[MAX_N], res[MAX_N], candid[MAX_N], pos[MAX_N];\nint upper, lower, sa[MAX_N], sb[MAX_N], ans[MAX_N], ansptr;\n\nbool compare(const int &x, const int &y)\n{\n    if ((ai[x] == lower) == (ai[y] == lower))\n        return x < y;\n    else\n        return (ai[x] == lower) < (ai[y] == lower);\n}\n\nvoid solve(int len)\n{\n    bool found = false;\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]--;\n    int min_val = *min_element(ai + 1, ai + 1 + n), max_val = *max_element(ai + 1, ai + 1 + n);\n    if ((min_val << 1) >= max_val)\n    {\n        for (int i = 1; i <= len; i++)\n            res[i] = pos[i];\n        sort(res + 1, res + 1 + len), found = true;\n    }\n    else if (((min_val << 1) | 1) == max_val)\n    {\n        upper = max_val, lower = min_val;\n        int ptra = 1, ptrb = 1, la = 0, lb = 0, ptr = 0;\n        for (int i = 1; i <= len; i++)\n            if (ai[pos[i]] == min_val || ai[pos[i]] == max_val)\n                sa[++la] = pos[i];\n            else\n                sb[++lb] = pos[i];\n        sort(sa + 1, sa + 1 + la, compare), sort(sb + 1, sb + 1 + lb);\n        // merge;\n        while (ptra <= la && ptrb <= lb)\n            if (sa[ptra] < sb[ptrb])\n                res[++ptr] = sa[ptra++];\n            else\n                res[++ptr] = sb[ptrb++];\n        while (ptra <= la)\n            res[++ptr] = sa[ptra++];\n        while (ptrb <= lb)\n            res[++ptr] = sb[ptrb++];\n        found = true;\n        for (int i = len + 1; i <= n; i++)\n            if (ai[pos[i]] == min_val)\n                found = false;\n        found |= (ai[sa[1]] == max_val);\n    }\n    for (int i = 1; i <= len; i++)\n        ai[pos[i]]++;\n    if (!found)\n        res[1] = 0;\n}\n\nbool lexicographicalCompare(int *s1, int *s2)\n{\n    int ptr = 1;\n    while (s1[ptr] == s2[ptr])\n        ptr++;\n    return s1[ptr] < s2[ptr];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &ai[i]), sum += ai[i], pos[i] = i;\n    if (((*min_element(ai + 1, ai + 1 + n)) << 1) < *max_element(ai + 1, ai + 1 + n))\n        puts(\"-1\"), exit(0);\n    solve(n);\n    for (int i = 1; i <= n; i++)\n        ans[++ansptr] = res[i], ai[res[i]]--, pos[i] = res[i];\n    while (ansptr < sum)\n    {\n        memset(candid, 0, sizeof(candid)), candid[1] = n + 1;\n        int len = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            solve(i);\n            if (res[1] != 0 && lexicographicalCompare(res, candid))\n            {\n                len = i;\n                for (int j = 1; j <= i; j++)\n                    candid[j] = res[j];\n            }\n        }\n        for (int i = 1; i + len <= n; i++)\n            pos[i] = pos[i + len];\n        for (int i = 1; i <= len; i++)\n            ans[++ansptr] = pos[n - len + i] = candid[i], ai[candid[i]]--;\n    }\n    for (int i = 1; i <= ansptr; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int K=105,N=1005;\nint k,n;\nint a[K];\nbool operator<(const vector<int>&a,const vector<int>&b)\n{\n\tfor(size_t i=0;i<min(a.size(),b.size());i++)\n\t{\n\t\tif(a[i]<b[i]) return true;\n\t\tif(a[i]>b[i]) return false;\n\t}\n\treturn a.size()<b.size(); \n}\nvector<int>merge(const vector<int>&a,const vector<int>&b)\n{\n\tvector<int>res;\n\tsize_t i=0,j=0;\n\twhile(i<a.size()&&j<b.size())\n\t{\n\t\tif(a[i]<b[j]) res.push_back(a[i]),i++;\n\t\telse res.push_back(b[j]),j++;\n\t}\n\twhile(i<a.size())\n\t\tres.push_back(a[i]),i++;\n\twhile(j<b.size())\n\t\tres.push_back(b[j]),j++;\n\treturn res;\n}\nint ans[N],tot;\nint b[K];\nbool pos[K];\nvector<int>add(int len)\n{\n\tfor(int i=1;i<=k;i++)\n\t\tpos[i]=false,b[i]=a[i];\n\tvector<int>pre; \n\tfor(int i=tot,j=1;i>=1&&j<=k-len;i--,j++)\n\t\tpre.push_back(ans[i]);\n\tfor(int u:pre)\n\t\tpos[u]=true;\n\tfor(int i=1;i<=k;i++)\n\t\tif(!pos[i]) b[i]--;\n\tfor(int i=1;i<=k;i++)\n\t\tif(b[i]<0) return {k+1};\n\tint Min=*min_element(b+1,b+k+1),Max=*max_element(b+1,b+k+1);\n\tif(Min*2>=Max)\n\t{\n\t\tvector<int>res;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]) res.push_back(i);\n\t\treturn res;\n\t}\n\telse if(Min*2+1==Max)\n\t{\n\t\tvector<int>x,y;\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Max) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]==Min) x.push_back(i);\n\t\tfor(int i=1;i<=k;i++)\n\t\t\tif(!pos[i]&&b[i]!=Min&&b[i]!=Max) y.push_back(i);\n\t\tvector<int>res=merge(x,y);\n\t\tpre.insert(pre.end(),res.begin(),res.end());\n\t\tint L=0,R=pre.size();\n\t\tfor(int i=0;i<pre.size();i++)\n\t\t{\n\t\t\tif(b[i]==Min) L=max(L,i);\n\t\t\tif(b[i]==Max) R=min(R,i);\n\t\t}\n\t\tif(L<R) return res;\n\t\telse return {k+1};\n\t}\n\telse return {k+1};\n}\nvoid solve()\n{\n\tvector<int>res={k+1};\n\tfor(int len=1;len<=k&&tot+len<=n;len++)\n\t{\n\t\tint d=k-len;\n\t\tif(tot-d>=0)\n\t\t{\n\t\t\tvector<int>now=add(len);\n\t\t\tres=min(res,now);\n\t\t}\n\t}\n\tfor(int u:res)\n\t{\n\t\tans[++tot]=u;\n\t\ta[u]--;\n\t\tprintf(\"%d \",u);\n\t}\n\treturn;\n}\nint main()\n{\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++)\n\t\tscanf(\"%d\",&a[i]),n+=a[i];\n\tint Min=*min_element(a+1,a+k+1),Max=*max_element(a+1,a+k+1);\n\tif(2*Min+1<=Max)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(tot<n)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\t// if (pre == 6 && b[pre] == 1) debug(pre), debug(last), debug(len), debug(num);\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) {\n\t\t\tlen = pre - i;\n\t\t\tbreak;\n\t\t}\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\t// if (pre == 6) debug(len);\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// for (int i = 1; i <= n; i++) debug(i), debug(b[i]);\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 1005\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint A[SIZE];\nbool use[SIZE];\nint ans[SIZE];\nint n,sz;\n\nint get_first()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\tif(mn*2<mx) return SIZE;\n\tif(mn*2>mx) return 0;\n\tfor(int i=0;i<n;i++) if(A[i]>mn) return i;\n\treturn -1;\n}\nbool impossible()\n{\n\tint mn=1000,mx=0;\n\tfor(int i=0;i<n;i++) mn=min(mn,A[i]),mx=max(mx,A[i]);\n\treturn mn*2<mx;\n}\nbool check()//when sz>=n\n{\n\tmultiset <int> st;\n\tmultiset <int>::iterator it;\n\tfor(int i=0;i<n;i++) st.insert(A[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint a=*st.begin();\n\t\tit=st.end();it--;\n\t\tint b=*it;\n\t\tif(2*a>=b) return true;\n\t\tint v=ans[sz-n+i];\n\t\tit=st.lower_bound(A[v]);\n\t\tst.erase(it);\n\t\tst.insert(A[v]-1);\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tif(impossible())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsz=0;\n\twhile(A[0]>0)\n\t{\n\t\tint mn=1000;\n\t\tfor(int i=0;i<n;i++) mn=min(mn,A[i]);\n\t\tvector <int> vx;\n\t\tint mx=-1;\n\t\tmemset(use,false,sizeof(use));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(A[i]==mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t\tmx=max(mx,i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<mx;i++)\n\t\t{\n\t\t\tif(A[i]>mn&&A[i]<mn*2)\n\t\t\t{\n\t\t\t\tvx.push_back(i);\n\t\t\t\tuse[i]=true;\n\t\t\t}\n\t\t}\n\t\tsort(vx.begin(),vx.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!use[i]) vx.push_back(i);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tans[sz++]=vx[i];\n\t\t\tA[vx[i]]--;\n\t\t}\n\t\tint p=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint v=vx[p];\n\t\t\tif(A[v]==0) break;\n\t\t\tif(get_first()<v) break;\n\t\t\tA[v]--;\n\t\t\tans[sz++]=v;\n\t\t\tif(!check())\n\t\t\t{\n\t\t\t\tsz--;\n\t\t\t\tA[v]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tif(p==n) p=0;\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++) printf(\"%d \",ans[i]+1);\n\tputs(\"\");\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, s, a[MAXN];\nint x, y, cur[MAXN], res[MAXN], ans[MAXN];\nbool cnp(int s, int t) {\n\tif ((a[s] == x) == (a[t] == x)) return s < t;\n\telse return (a[s] == x) < (a[t] == x);\n}\nvoid work(int len) {\n\tbool valid = true, found = false;\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]--;\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\tif (Min * 2 >= Max) {\n\t\tfound = true;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tres[i] = cur[i];\n\t\tsort(res + 1, res + len + 1);\n\t} else if (Min * 2 + 1 == Max) {\n\t\tx = Min, y = Max;\n\t\tint k1 = 0, k2 = 0, k = 0;\n\t\tstatic int res1[MAXN], res2[MAXN];\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (a[cur[i]] == Min || a[cur[i]] == Max) res1[++k1] = cur[i];\n\t\t\telse res2[++k2] = cur[i];\n\t\tsort(res1 + 1, res1 + k1 + 1, cnp);\n\t\tsort(res2 + 1, res2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= len; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2) {\n\t\t\t\tif (res1[x1] < res2[x2]) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t} else {\n\t\t\t\tif (x1 <= k1) res[i] = res1[x1++];\n\t\t\t\telse res[i] = res2[x2++];\n\t\t\t}\n\t\tfound = true;\n\t\tfor (int i = len + 1; i <= n; i++)\n\t\t\tif (a[cur[i]] == Min) found = false;\n\t\t//found |= (x1 == 0) || (a[res1[1]] == Max);\n\t}\n\tfor (int i = 1; i <= len; i++)\n\t\ta[cur[i]]++;\n\tif (!valid || !found) res[1] = 0;\n}\nbool cmp(int *a, int *b) {\n\tint pos = 1;\n\twhile (a[pos] == b[pos]) pos++;\n\treturn a[pos] < b[pos];\n}\nbool check() {\n\tint Min = a[1], Max = a[1];\n\tfor (int i = 2; i <= n; i++) {\n\t\tchkmin(Min, a[i]);\n\t\tchkmax(Max, a[i]);\n\t}\n\treturn Min * 2 >= Max;\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tif (!check()) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcur[i] = i;\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tm++, a[res[i]]--;\n\t\tcur[i] = res[i];\n\t\tans[m] = res[i];\n\t}\n\twhile (m != s) {\n\t\tstatic int inc[MAXN];\n\t\tmemset(inc, 0, sizeof(inc));\n\t\tint len = 0; inc[1] = n + 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (res[1] != 0 && cmp(res, inc)) {\n\t\t\t\tlen = i;\n\t\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\t\tinc[j] = res[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i + len <= n; i++)\n\t\t\tcur[i] = cur[i + len];\n\t\tfor (int i = 1; i <= len; i++) {\n\t\t\tans[++m] = inc[i];\n\t\t\tcur[n - len + i] = inc[i], a[inc[i]]--;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\nconst int N=1005;\nint n,a[N],s,ans[N],top,vis[N];\nvoid getv(int &v1,int &v2){\n\tv1=1e9,v2=0;\n\tFor(i,1,n){\n\t\tv1=min(v1,a[i]);\n\t\tv2=max(v2,a[i]);\n\t}\n}\nvoid construct1(){\n\tint v1,v2,p=0;\n\tFor(i,1,n){\n\t\t--a[ans[top+i-n]];\n\t\tgetv(v1,v2);\n\t\tif (v1>=0&&v1*2>=v2) p=i;\n\t\telse if (v1*2+1==v2&&v1>=0){\n\t\t\tint p1=1e9,p2=0;\n\t\t\tFor(j,top+i-n+1,top+i){\n\t\t\t\tif (a[ans[j]]==v1) p1=min(p1,j);\n\t\t\t\tif (a[ans[j]]==v2) p2=max(p2,j);\n\t\t\t}\n\t\t\tif (p1>p2) p=i;\n\t\t}\n\t}\n\tFor(i,p+1,n) ++a[ans[top+i-n]];\n\tassert(p);\n\tmemset(vis,0,sizeof(vis));\n\tFor(i,1,p) vis[ans[top+i-n]]=1;\n\tgetv(v1,v2);\n\tif (v1*2>=v2){\n\t\tFor(i,1,n) if (vis[i]) ans[++top]=i;\n\t}\n\telse{\n\t\tint p=0;\n\t\tFor(i,1,n) if (vis[i]&&a[i]==v2) p=i;\n\t\tFor(i,1,p) if (vis[i]&&a[i]!=v1) ans[++top]=i;\n\t\tFor(i,1,p) if (vis[i]&&a[i]==v1) ans[++top]=i;\n\t\tFor(i,p+1,n) if (vis[i]) ans[++top]=i;\n\t}\n\tint v=n,pp=top;\n\tmemset(vis,0,sizeof(vis));\n\tRep(i,top,top-p+2){\n\t\tv-=(vis[ans[i]]==0);\n\t\tv-=(vis[ans[i-n]]==0);\n\t\t--vis[ans[i]];\n\t\t++vis[ans[i-n]];\n\t\tv+=(vis[ans[i]]==0);\n\t\tv+=(vis[ans[i-n]]==0);\n\t\tif (v==n) pp=i-1;\n\t}\n\tfor (;top>pp;top--)\n\t\t++a[ans[top]];\n\t/*cout<<p<<' '<<pp<<' '<<top<<endl;\n\tFor(i,1,n) cout<<a[i]<<' '; cout<<endl;\n\tFor(i,1,top) cout<<ans[i]<<' '; cout<<endl;*/\n}\nvoid construct2(){\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]-1),v2=max(v2,a[i]-1);\n\tassert(v1*2+1>=v2);\n\tFor(i,1,n) a[i]--;\n\tif (v1*2>=v2){\n\t\tFor(i,1,n) ans[++top]=i;\n\t}\n\telse{\n\t\tint p=0;\n\t\tFor(i,1,n) if (a[i]==v2) p=i;\n\t\tFor(i,1,p) if (a[i]!=v1) ans[++top]=i;\n\t\tFor(i,1,p) if (a[i]==v1) ans[++top]=i;\n\t\tFor(i,p+1,n) ans[++top]=i;\n\t}\n\t//For(i,1,n) cout<<ans[i]<<' '; cout<<endl;\n\t//For(i,1,n) cout<<a[i]<<' '; cout<<endl;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) s+=a[i];\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]),v2=max(v2,a[i]);\n\tif (v1*2<v2) return puts(\"-1\"),0;\n\tconstruct2();\n\tfor (;top!=s;) construct1();\n\tFor(i,1,s) cout<<ans[i]<<' '; cout<<endl;\n}\n/*\n1 2 3 4 5 6 2 1 3 4 5 6 2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nbool ok(vector<int> a){\n\twhile(1){\n\t\tconst int mn=*min_element(all(a));\n\t\tif(mn<0) return false;\n\t\tif(mn==*max_element(all(a))) return true;\n\t\tif(mn==0) return false;\n\t\tfor(auto &x:a){\n\t\t\tif(x==mn) --x;\n\t\t\telse x-=2;\n\t\t}\n\t}\n}\n\nvector<int> solve(vector<int> a){\n\tconst int n=a.size();\n\tif(!ok(a)){\n\t\treturn {};\n\t}\n\tvv<int> ls;\n\twhile(*min_element(all(a))<*max_element(all(a))){\n\t\tvector<int> large;\n\t\tint mn=*min_element(all(a));\n\t\tbool yametai=0;\n\t\trep(i,n){\n\t\t\tif(a[i]!=mn){\n\t\t\t\tlarge.pb(i);\n\t\t\t}else{\n\t\t\t\tyametai=1;\n\t\t\t}\n\t\t\tif(yametai){\n\t\t\t\tif(large.empty()) continue;\n\t\t\t\tauto b=a;\n\t\t\t\tfor(auto &x:b) --x;\n\t\t\t\tfor(auto i:large) b[i]--;\n\t\t\t\tif(ok(b)){\n\t\t\t\t\ta=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// out(large,1);\n\t\tls.eb(large);\n\t}\n\tconst int m=ls.size();\n\tvector<int> re;\n\trep(_,a[0])rep(i,n) re.pb(i);\n\trep(i,m){\n\t\tconst auto &large=ls[i];\n\t\tvector<int> small;\n\t\t{\n\t\t\tvector<int> usd(n);\n\t\t\tfor(int i:large) usd[i]=1;\n\t\t\trep(i,n)if(!usd[i]) small.pb(i);\n\t\t}\n\t\t// if(t && (i+1==m || small[0]<ls[i+1][0])){\n\t\t// \trep(_,t){\n\t\t// \t\tfor(auto i:large) re.pb(i);\n\t\t// \t\tfor(auto i:small) re.pb(i);\n\t\t// \t}\n\t\t// \tt=0;\n\t\t// }\n\t\tfor(auto i:large) re.pb(i);\n\t\tfor(auto i:small) re.pb(i);\n\t\tfor(auto i:large) re.pb(i);\n\t\t// out(i,re,1);\n\t}\n\treturn re;\n}\n\nint main(){\n\tif(1){\n\t\trep(_,1000){\n\t\t\tconst int n=rand()%6+1;\n\t\t\tconst int t=rand()%10+1;\n\t\t\tvector<int> ans;\n\t\t\trep(_,t){\n\t\t\t\tvector<int> p(n); iota(all(p),0); random_shuffle(all(p));\n\t\t\t\tint r=rand()%n;\n\t\t\t\tint t=rand()%2+1;\n\t\t\t\trep(_,t)for(int x:p) ans.pb(x);\n\t\t\t\trep(i,r) ans.pb(p[i]);\n\t\t\t}\n\t\t\tvector<int> a(n);\n\t\t\tfor(int x:ans) ++a[x];\n\t\t\tauto act=solve(a);\n\t\t\tif(act.empty()){\n\t\t\t\tout(ans,a,1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvector<int> b(n);\n\t\t\tfor(auto x:act) ++b[x];\n\t\t\tif(a!=b){\n\t\t\t\tout(ans,a,b,1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tout(\"done\",1);\n\t\treturn 0;\n\t}\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(auto &x:a) cin>>x;\n\tauto re=solve(a);\n\tif(re.empty()){\n\t\tcout<<(n/0) NL;\n\t\tcout<<-1 NL;\n\t}else{\n\t\trep(i,re.size()) cout<<re[i]+1<<\" \\n\"[i+1==re.size()];\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\n\nconst int N=2005;\nint n,s,a[N],la[N];\nint vis[N],vv[N],ans[N];\nbool jud(int p){\n\tint v=0;\n\tmemset(vis,0,sizeof(vis));\n\tmemset(vv,0,sizeof(vv));\n\tFor(i,1,p+n){\n\t\tif (!(vis[ans[i]])&&ans[i]) ++v;\n\t\t++vis[ans[i]];\n\t\tif (i>n){\n\t\t\t--vis[ans[i-n]];\n\t\t\tif (!vis[ans[i-n]]&&ans[i-n]) --v;\n\t\t}\n\t\tif (i>=n&&v==min(i,p)-(i-n))\n\t\t\t++vv[i-n+1],--vv[min(i,p)+1];\n\t}\n\tFor(i,1,p){\n\t\tvv[i]+=vv[i-1];\n\t\tif (!vv[i]) return 0;\n\t}\n\tint p1=1e9,p2=0;\n\tFor(i,1,n) p1=min(p1,a[i]),p2=max(p2,a[i]);\n\tif (p2>p1*2+1) return 0;\n\tif (p2<=p1*2) return 1;\n\t//cout<<p1<<' '<<p2<<endl;\n\tint p3=1e9,p4=0;\n\tmemset(vis,0,sizeof(vis));\n\tFor(i,1,s) vis[ans[i]]=i;\n\tFor(i,1,n){\n\t\tif (a[i]==p1) p3=min(p3,vis[i]);\n\t\tif (a[i]==p2) p4=max(p4,vis[i]);\n\t}\n\t//cout<<p1<<' '<<p2<<' '<<p3<<' '<<p4<<endl;\n\treturn p3>p4;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) s+=a[i];\n\tif (!jud(0))\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,s) For(j,1,n) if (a[j]){\n\t\tans[i]=j; --a[j];\n\t\tif (jud(i)){\n\t\t\t//cout<<\"F \"<<i<<' '<<j<<endl;\n\t\t\tbreak;\n\t\t}\n\t\t++a[j];\n\t}\n\tFor(i,1,s) cout<<ans[i]<<' ';cout<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n      printf(\"-1\");\n      return 0;\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else assert(false);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value>* = nullptr>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    int read_unsafe() { return 0; }\n    template <class H, class... T> int read_unsafe(H& h, T&... t) {\n        bool f = read_single(h);\n        if (!f) return 0;\n        return 1 + read_unsafe(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value>* = nullptr>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(__int128 val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    int k;\n    sc.read(k);\n    V<int> a(k);\n    int n = 0;\n    for (int i = 0; i < k; i++) {\n        sc.read(a[i]);\n        n += a[i];\n    }\n\n    auto check = [&](V<int> v, int s) {\n        V<int> cnt = a;\n        V<int> last(k, -1);\n        int p = 0, l = 0, ok = 0;\n        auto inc = [&](int x) -> bool {\n            if (!cnt[x]) return false;\n            cnt[x]--;\n            l = max(l, last[x] + 1);\n            last[x] = p;\n            p++;\n            if (p - l == k) ok = p;\n            if (p - ok == k) return false;\n            return true;\n        };\n        for (int i = 0; i < s; i++) {\n            if (!inc(v[i])) return false;\n        }\n        for (int i = s; i < n; i++) {\n            using P = tuple<int, int, int>;\n            P ma = P(-1, -1, -1);\n            for (int j = 0; j < k; j++) {\n                if (cnt[j] == 0) continue;\n                if (ok <= last[j]) continue;\n                ma = max(ma, P(cnt[j], -last[j], j));\n            }\n            int j = get<2>(ma);\n            if (j == -1) return false;\n            if (!inc(j)) return false;\n        }\n        if (ok != n) return false;\n        return true;\n    };\n    V<int> v(n, -1);\n    if (!check(v, 0)) {\n        pr.writeln(-1);\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            v[i] = j;\n            if (check(v, i + 1)) break;\n        }\n    }\n    for (int x: v) {\n        pr.write(x + 1);\n        pr.write(' ');\n    }\n    pr.writeln();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<type_traits>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n\n#define TLA TL<TN A>\n#define TLB TL<TN A,TN B>\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL decltype(end(C()))rightmost_le(CS C&set,CS D&d){auto l=set.leftmost_gt(d);\nRT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL decltype(end(C()))rightmost_lt(CS C&set,CS D&d){\nauto l=set.leftmost_ge(d);RT l==begin(set)?end(set):--l;}TL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_gt(from,to,d);RT l==from?to:--l;}TL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){\nauto l=leftmost_ge(from,to,d);RT l==from?to:--l;}namespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}\nTL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){RT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p);TL<TN T,TN U,TN V>IL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p);\nTL<TN T>IL ostream&OP<<(ostream&s,CS vec<T>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS set<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS map<T,S>&p);TL<TN T>IL ostream&OP<<(ostream&s,CS vvec<T>&p);TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS vec<map<T,S>>&p);TL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<TN T,TN S>IL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}TL<TN T,TN U,TN V>\nIL ostream&OP<<(ostream&s,CS tuple<T,U,V>&p){RT s<<\"(\"<<get<0>(p)<<\",\"<<get<1>(p)<<\",\"<<get<2>(p)<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T>Rdebug1(' ',set<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T>Rdebug1('\\n',vec<set<T>>)TL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)TL<TN T>Rdebug1('\\n',set<vec<T>>)\nTL<TN T>Rdebug1('\\n',set<set<T>>)TL<TN T,TN S>Rdebug1('\\n',set<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n// KK(A)\n/* <foxy.memo-area> */\nint K;cin>>K;VI A0(K);times(K,Ri_0){cin>>A0[Ri_0];}\n/* </foxy.memo-area> */\n\n  int amin = *min_element(iter(A0)), amax = *max_element(iter(A0));\n  if(amin * 2 < amax) {\n    cout << -1 ln;\n    return;\n  }\n\n  VI ans = {99999};\n\n  upto((amax + 1) / 2, amin, b) {\n    VI a = A0;\n    VI tmp;\n\n    times(b, g) {\n      int h = b - g;\n      int last_2h = -1;\n      times(K, i) if(a[i] == 2*h) last_2h = i;\n      bool vis_2h_h = false;\n      VI c(K);\n      times(K, i) {\n        if(i > last_2h) vis_2h_h = true;\n        if(a[i] == 2*h) {\n          c[i] = 2;\n        } else if(a[i] == h) {\n          c[i] = 1;\n          // if(i > last_2h) vis_2h_h = true;\n        } else {\n          c[i] = vis_2h_h ? 1 : 2;\n        }\n        a[i] -= c[i];\n      }\n\n      {\n        int state = 0;\n        times(K, i) {\n          {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:           \"<<(i)ln<<\"  state:       \"<<(state)ln<<\"  c[i]:        \"<<(c[i])ln<<\"  a[i] + c[i]: \"<<(a[i] + c[i])ln<<\"  2 * h:       \"<<(2 * h)ln;}\n          if(state == 0 && c[i] == 1) state = 1;\n          if(state == 1 && c[i] == 2 ||\n             i > 0 && a[i] + c[i] == 2 * h) {\n            state = -1;\n            break;\n          }\n        }\n        if(state >= 0) { // ()\n          int x = 0;\n          bool no_2h1 = true;\n          times(K, i) if(a[x] + c[x] >= 2 * h - 1) no_2h1 = false;\n          if(!no_2h1) {\n            while(x < K && a[x] + c[x] == h + 1) ++x;\n          }\n          uptil(x + 1, K, i) { a[i] += c[i] - 1; c[i] = 1; }\n        }\n        {if(debug)cerr<<\"state: \"<<(state)ln;}\n      }\n\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 1) tmp.PB(i + 1);\n      times(K, i) if(c[i] == 2) tmp.PB(i + 1);\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  a: \"<<(a)ln<<\"  c: \"<<(c)ln;}\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  b:   \"<<(b)ln<<\"  tmp: \"<<(tmp)ln;}\n    if(lexicographical_compare(iter(tmp), iter(ans))) ans = move(tmp);\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nbool can(int k,vi a,vi pre){\n\tvi u(k);\n\tfor(auto v:pre)u[v]=1;\n\tvc<pi> z;\n\trep(i,k)if(!u[i])z.eb(a[i],i);\n\tsort(all(z),greater<pi>());\n\tfor(auto w:z){\n\t\tif(--a[w.b]<0)return false;\n\t\tpre.pb(w.b);\n\t}\n\tvi mn(k+1),mx(k+1);\n\tmn[0]=*min_element(all(a));\n\trep(i,k){\n\t\tmn[i+1]=min(mn[i],--a[pre[i]]);\n\t}\n\tmx[k]=*max_element(all(a));\n\tper(i,k){\n\t\tmx[i]=max(mx[i+1],++a[pre[i]]);\n\t}\n\trep(i,k+1)if(mn[i]*2>=mx[i])return true;\n\treturn false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint k;cin>>k;\n\tvi a=readvi(k);\n\tint len=accumulate(all(a),0);\n\t\n\tvi ans,cur;\n\trep(_,len){\n\t\tbool found=false;\n\t\trep(nx,k)if(a[nx]){\n\t\t\tint p=find(all(cur),nx)-cur.bg;\n\t\t\tif(p<si(cur)&&si(cur)<k)continue;\n\t\t\tvi tmp;\n\t\t\tif(p==si(cur))tmp=cur;\n\t\t\telse if(p==0)tmp=vi(cur.bg+1,cur.ed);\n\t\t\ttmp.pb(nx);\n\t\t\ta[nx]--;\n\t\t\tif(can(k,a,tmp)){\n\t\t\t\tans.pb(nx);\n\t\t\t\tcur=tmp;\n\t\t\t\tfound=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta[nx]++;\n\t\t}\n\t\tif(!found){\n\t\t\tassert(_==0);\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(si(cur)==k);\n\tassert(si(ans)==len);\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      pair<vi, int> best(solve(a, a.size()), 0);\n      for (int l = 1; l < a.size(); ++l) {\n        --a[v0[l - 1]];\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, a.size() - l, v0[l]);\n        if (v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n      }\n      best.first.resize(best.second);\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second == 0 ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nvoid validate(vi v, vi a) {\n  int n = a.size();\n  assert(v.size() == len(a));\n  vi c(n);\n  for (int x : v) {\n    assert(x >= 0 && x < n);\n    ++c[x];\n  }\n  assert(a == c);\n  vi f(v.size());\n  for (int i = 0; i + n <= v.size(); ++i) {\n    vi w(n);\n    for (int j = i; j < i + n; ++j) w[v[j]] = 1;\n    bool ok = 1;\n    for (int x : w) if (!x) ok = 0;\n    if (ok) for (int j = i; j < i + n; ++j) f[j] = 1;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    assert(f[i]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 9; ++n) for (int test = 1; test <= 100000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      validate(v, a);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  validate(res, a);\n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      int len1 = min((int)a.size(), len - (int)a.size());\n      pair<vi, int> best(solve(a, len1), -1);\n      for (int l = 0; l < a.size(); ++l) {\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, len1 - l, l < v0.size() ? v0[l] : -1);\n        if (v2.empty() || v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n        --a[v0[l]];\n      }\n      best.first.resize(max(0, best.second));\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second >= 0 && best.second < v0.size() ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nvoid validate(vi v, vi a) {\n  int n = a.size();\n  assert(v.size() == len(a));\n  vi c(n);\n  for (int x : v) {\n    assert(x >= 0 && x < n);\n    ++c[x];\n  }\n  assert(a == c);\n  vi f(v.size());\n  for (int i = 0; i + n <= v.size(); ++i) {\n    vi w(n);\n    for (int j = i; j < i + n; ++j) w[v[j]] = 1;\n    bool ok = 1;\n    for (int x : w) if (!x) ok = 0;\n    if (ok) for (int j = i; j < i + n; ++j) f[j] = 1;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    assert(f[i]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 9; ++n) for (int test = 1; test <= 100000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      validate(v, a);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  validate(res, a);\n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (false && mh() == v) {\n\t\t\t\tint nxt = min(mh(), j==k-1? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh <= nxt) {\n\t\t\t\t\t++a[v];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) {\n\t\tcin>>A[i];\n\t\tN+=A[i];\n\t}\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\tj=-1;\n\t\tFOR(i,K) if(A[i]==2*y) j=i;\n\t\tif(j==-1 && A[0]>y) j=0;\n\t\tvector<int> X,Y;\n\t\tFOR(i,K) {\n\t\t\tif(i<=j && A[i]>y) X.push_back(i),A[i]-=2;\n\t\t\telse Y.push_back(i),A[i]--;\n\t\t}\n\t\tFORR(c,X) V.push_back(c);\n\t\tFORR(c,Y) V.push_back(c);\n\t\tFORR(c,X) V.push_back(c);\n\t}\n\t\n\tFOR(i,N) cout<<V[i]+1<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nconst int N = 200000;\nbitset<N> v, odd, pref;\nll X = 0;\n\nvoid inc() {\n  X += (v & odd).count();\n}\n\nconst int DEBUG = 0;\n\nll stupid(string s) {\n  int n = s.size();\n  vi ord(n);\n  for (int i = 0; i < n; ++i) ord[i] = i;\n  int ma = 0;\n  do {\n    vi used(n);\n    int sum = 0;\n    for (int x : ord) {\n      used[x] = 1;\n      int c = 0, l = 0;\n      for (int i = 0; i < n; ++i) if (used[i]) {\n        ++l;\n        if (l % 2 && s[i] == '1') ++c;\n      }\n      sum += c;\n    }\n    ma = max(ma, sum);\n  } while (next_permutation(ord.begin(), ord.end()));\n  return ma;\n}\n\nvoid solve(string s) {\n  X = 0;\n  int n = s.size();\n  int c = 0;\n  vi used(n);\n  for (int i = 0; i < n; ++i) if (s[i] == '1') {\n    ++c;\n    used[i] = 1;\n  }\n  int cur = 0;\n  for (int i = 0; i < c; ++i) {\n    v[i] = 1;\n    if (i % 2 == 0) ++cur;\n    X += cur;\n  }\n  int p = 0;\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '0') {\n      if (p % 2) {\n        used[i] = 1;\n        ++c;\n        if (c % 2) ++cur;\n        X += cur;\n        ++p;\n      }\n    } else {\n      ++p;\n    }\n  }\n  vi x(2);\n  int l = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (!used[i]) {\n      vi nx = x;\n      swap(nx[0], nx[1]);\n      cur += nx[0] - x[0];\n      x = nx;\n      X += cur;\n      ++c;\n      ++l;\n    } else {\n      int j = c - l - 1;\n      if (s[i] == '1') x[j % 2]++;\n      ++l;\n    }\n  }\n/*  for (int i = 0; i < n; i += 2) odd[i] = 1;\n  for (int i = 0; i < c; ++i) {\n    pref[i] = v[i] = 1;\n    inc();\n  }\n  int pc = c;\n  for (int i = n - 1; i >= 0; --i) if (s[i] == '0') {\n    int l = n - i - 1;\n    while (pc > c - l) {\n      --pc;\n      pref[pc] = 0;\n    }\n    auto prefv = v & pref;\n    v = prefv | ((v ^ prefv) << 1);\n    ++c;\n    inc();\n  }*/\n  cout << X << endl;\n  if (DEBUG) {\n    ll res = stupid(s);\n    if (res != X) {\n      cerr << s << ' ' << res << ' ' << X << endl;\n      assert(0);\n    }\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s(N, '0');\n  if (!DEBUG) {\n    cin >> s;\n    solve(s);\n  } else {\n    for (int n = 1; n <= 10; ++n) {\n      s.resize(n);\n      for (int mask = 0; mask < (1 << n); ++mask) {\n        for (int i = 0; i < n; ++i) {\n          if (mask & (1 << i)) s[i] = '1';\n          else s[i] = '0';\n        }\n        solve(s);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\n\nint K;\nint A[111];\n\nint l[111];//label\n\n\n/*\nfloor((m+1-l[i])/2)>A[i]\n(m-l[i])/2>A[i]\nm-l[i]>2*A[i]\nm>2*A[i]+l[i]\n*/\nbool check(){\n\tint m=0;\n\trep(i,K)chmax(m,A[i]+l[i]);\n\trep(i,K)if(m>2*A[i]+l[i])return false;\n\treturn true;\n}\n\nbool ex[111];\nint pos[111];\nsigned main(){\n\tcin>>K;\n\trep(i,K)cin>>A[i];\n\n\tif(!check()){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\n\tvint ans;\n\tint rem=0;\n\n\twhile(*max_element(A,A+K)){\n\t\tint len=ans.size();\n\t\tfor(int i=0;i<K;i++){\n\t\t\tif(A[i]==0)continue;\n\n\t\t\tif(find(ans.end()-rem,ans.end(),i)!=ans.end())continue;\n\t\t\tans.pb(i);\n\t\t\tA[i]--;\n\t\t\tint memrem=rem;\n\t\t\trem++;\n\n\t\t\tif(ans.size()>=K){\n\t\t\t\tbool isperm=true;\n\t\t\t\tmemset(ex,0,sizeof(ex));\n\t\t\t\tfor(int j=0;j<K;j++){\n\t\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\t\tif(ex[a])isperm=false;\n\t\t\t\t\tex[a]=true;\n\t\t\t\t}\n\t\t\t\tif(isperm)rem=0;\n\t\t\t}\n\n\n\n\t\t\tmemset(l,0,sizeof(l));\n\t\t\trep(j,rem){\n\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\tl[a]=1;\n\t\t\t}\n\n\t\t\tint ma=-1001001001,mi=1001001001;\n\t\t\trep(j,K){\n\t\t\t\tchmax(ma,A[j]-1+l[j]);\n\t\t\t\tchmin(mi,2*(A[j]-1+l[j]));\n\t\t\t}\n\n\t\t\tint argma=1001001001,argmi=-2;\n\t\t\trep(j,rem){\n\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\tif(ma==A[a])chmin(argma,j);\n\t\t\t\tif(mi==2*A[a])chmax(argmi,j);\n\t\t\t}\n\t\t\trep(j,K)if(!l[j]&&A[j]-1==ma)argma=-1;\n\n\n\t\t\tif(ma<=mi)break;\n\t\t\tif(ma-mi==1&&argma>argmi)break;\n\n\n\t\t\tfor(int j=rem;j<K&&j<ans.size();j++){\n\t\t\t\tint a=ans[ans.size()-1-j];\n\t\t\t\tif(l[a])break;\n\t\t\t\tif(ma==A[a]-1)break;\n\t\t\t\tl[a]=1;\n\t\t\t}\n\t\t\tif(check())break;\n\n\n\t\t\tA[i]++;\n\t\t\trem=memrem;\n\t\t\tans.pop_back();\t\t\t\n\t\t}\n\t\tif(len==ans.size())break;\n\t}\n\n\trep(i,ans.size()){\n\t\tif(i)cout<<\" \";\n\t\tcout<<ans[i]+1;\n\t}cout<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nbool suc = false;\n\nint n;\n \nvoid change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n\n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n\n\tif (2*minimum.first < maximum.first) {\n\t\tsuc = false;\n\t\treturn;\n\t}\n\tcout << u+1 << \" \";\n\tsuc = true;\n\n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n}\n \nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n \n\tsort(all(arr));\n \n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n \n\twhile (2*arr[0].first > arr.back().first) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tarr[i].first--;\n\t\t}\n\n\t\tchange(arr, 0);\n\n\t}\n \n\tint u = 0;\n\twhile (true) {\n \n\t\tchange(arr, u);\n\t\tif (suc) u = (u+1)%n;\n\t\telse break;\n \n\t}\n \n \n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n \n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass EPermutationCover {\npublic:\n    void solve() {\n        int k = in.readInt();\n        auto a = in.readIntArray(k);\n\n        if (*min_element(all(a)) * 2 < *max_element(all(a))) {\n            out.printLine(-1);\n            return;\n        }\n        vi p;\n        vi lastPerm(1);\n        arri last(k, -k);\n        int from = 0;\n        while (true) {\n            while (from == k) {\n                if (lastPerm.back() == p.size()) {\n                    lastPerm.pop_back();\n                }\n                a[p.back() - 1]++;\n                from = p.back();\n                p.pop_back();\n            }\n            int mx = *max_element(all(a));\n            if (mx == 0) {\n                break;\n            }\n            bool found = false;\n            for (int i : range(from, k)) {\n                if (a[i] == 0 || mx >= 2 * a[i]) {\n                    continue;\n                }\n                bool bad = false;\n                for (int j : range(lastPerm.back(), p.size())) {\n                    if (p[j] == i + 1) {\n                        bad = true;\n                        break;\n                    }\n                }\n                if (bad) {\n                    continue;\n                }\n                found = true;\n                from = 0;\n                last[i] = p.size();\n                a[i]--;\n                p.push_back(i + 1);\n                break;\n            }\n            if (!found) {\n                from = k;\n                continue;\n            }\n            if (*min_element(all(last)) >= p.size() - k) {\n                lastPerm.push_back(p.size());\n            }\n        }\n        out.printLine(p);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    EPermutationCover solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n        }\n        if (flag[i] && flag[j]) {\n            if (j < K-1) {\n                if (li < lj) flag[j] = false;\n                else flag [i] = false;\n            }\n            else {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint mi(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = min(res, x);\n  return res;\n}\n\nint ma(const vi& a) {\n  int res = a[0];\n  for (int x : a) res = max(res, x);\n  return res;\n}\n\nbool ok(const vi& a) {\n  return mi(a) * 2 >= ma(a);\n}\n\nint len(const vi& a) {\n  int l = 0;\n  for (int x : a) l += x;\n  return l;\n}\n\nvi conc(vi a, const vi& b) {\n  for (int x : b) a.push_back(x);\n  return a;\n}\n\nvi solve(vi a, int len, int bad = -1) {\n  if (len <= 0) return vi();\n  if (!ok(a)) return {-1};\n  vi v;\n  int m = mi(a);\n  if (ma(a) >= 2 * m) {\n    vi p, s;\n    for (int i = 0; i < a.size(); ++i) {\n      if (a[i] == m) s.push_back(i);\n      if (a[i] >= 2 * m) p.push_back(i);\n    }\n    int maxp = p.back(), mins = s[0];\n    for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] < 2 * m && (i < mins || i < maxp)) {\n      p.push_back(i);\n    }\n    sort(p.begin(), p.end());\n    if (p[0] == bad) {\n      if (p.size() > 1) swap(p[0], p[1]);\n      else {\n        for (int i = 0; i < a.size(); ++i) if (a[i] > m && a[i] != bad) {\n          p.insert(p.begin(), i);\n          break;\n        } \n      }\n      if (p[0] == bad) return {-1};\n    }\n    vi wasp(a.size());\n    for (int x : p) wasp[x] = 1;\n    s.clear();\n    for (int i = 0; i < a.size(); ++i) if (!wasp[i]) s.push_back(i);\n    for (int x : p) v.push_back(x);\n    for (int x : s) v.push_back(x);\n    for (int x : p) v.push_back(x);\n    if (v.size() < len) {\n      vi na = a;\n      for (int x : v) na[x]--;\n      assert(ok(na));\n      vi v1 = solve(na, len - v.size());\n      if (v1[0] < 0) return {-1};\n      for (int x : v1) v.push_back(x);\n    }\n  } else {\n    vi v0(a.size());\n    for (int i = 0; i < a.size(); ++i) {\n      v0[i] = i;\n      --a[i];\n    }\n    if (v0[0] == bad) swap(v0[0], v0[1]);\n    if (len > a.size()) {\n      vi a0 = a;\n      int len1 = min(2 * (int)a.size(), len - (int)a.size());\n      pair<vi, int> best(solve(a, len1), -1);\n      for (int l = 0; l <= a.size(); ++l) {\n        vi v1 = v0;\n        v1.resize(l);\n        vi v2 = solve(a, len1 - l, l < v0.size() ? v0[l] : -1);\n        if (v2.empty() || v2[0] >= 0) {\n          best = min(best, make_pair(conc(v1, v2), l));\n        }\n        if (l < v0.size()) --a[v0[l]];\n      }\n      best.first.resize(max(0, best.second));\n      if (best.first[0] < 0) return {-1};\n      a = a0;\n      for (int x : best.first) a[x]--;\n      v = conc(conc(v0, best.first), solve(a, len - v0.size() - best.first.size(), best.second >= 0 && best.second < v0.size() ? -1 : v0[best.second]));\n    } else v = v0;\n  }\n  v.resize(len);\n  return v;\n}\n\nvoid out(vi v) {\n  for (int x : v) cerr << x << ' ';\n  cerr << endl;\n}\n\nvoid validate(vi v, vi a) {\n  int n = a.size();\n  assert(v.size() == len(a));\n  vi c(n);\n  for (int x : v) {\n    assert(x >= 0 && x < n);\n    ++c[x];\n  }\n  assert(a == c);\n  vi f(v.size());\n  for (int i = 0; i + n <= v.size(); ++i) {\n    vi w(n);\n    for (int j = i; j < i + n; ++j) w[v[j]] = 1;\n    bool ok = 1;\n    for (int x : w) if (!x) ok = 0;\n    if (ok) for (int j = i; j < i + n; ++j) f[j] = 1;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    assert(f[i]);\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  if (0) for (int n = 2; n <= 9; ++n) for (int test = 1; test <= 100000; ++test) {\n    vi a(n);\n    for (int i = 0; i < n; ++i) a[i] = rand() % n + n - 1;\n    if (ok(a)) {\n      out(a);\n      vi v = solve(a, len(a));\n      validate(v, a);\n    }\n  }\n  int n;\n  cin >> n;\n  vi a(n);\n  int l = 0;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    l += a[i];\n  }\n  if (!ok(a)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  if (n == 1) {\n    for (int i = 0; i < a[0]; ++i) cout << 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vi res = solve(a, l);  \n  validate(res, a);\n  for (int x : res) cout << x + 1 << ' ';\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint k;\nint a[100];\nint b[100];\nint f[100];\n\nvector<int> calc(int x) {\n    int i, j;\n    vector<int> v;\n    \n    for (i = 0; i < k; i++) b[i] = a[i];\n    \n    for (i = x - 1; i >= 0; i--) {\n        vector<int> w, z;\n        \n        for (j = 0; j < k; j++) {\n            b[j]--;\n            \n            if (b[j] > i * 2) {\n                w.push_back(j);\n                b[j]--;\n            } else if (b[j] > i) {\n                z.push_back(j);\n            }\n        }\n        \n        if (w.size() > 0) {\n            int m = w.back();\n            \n            for (j = 0; j < z.size(); j++) {\n                if (z[j] > m) break;\n                \n                w.push_back(z[j]);\n                b[z[j]]--;\n            }\n        } else {\n            for (j = 0; j < z.size(); j++) {\n                if (z[j] > j) break;\n                \n                w.push_back(z[j]);\n                b[z[j]]--;\n            }\n        }\n        \n        for (j = 0; j < k; j++) f[j] = 1;\n        \n        for (j = 0; j < w.size(); j++) f[w[j]] = 2;\n        \n        for (j = 0; j < k; j++) {\n            if (f[j] == 2) v.push_back(j);\n        }\n        \n        for (j = 0; j < k; j++) {\n            if (f[j] == 1) v.push_back(j);\n        }\n        \n        for (j = 0; j < k; j++) {\n            if (f[j] == 2) v.push_back(j);\n        }\n    }\n    \n    return v;\n}\n\nint main() {\n    int m1 = 1e9, m2 = 0, i;\n    vector<int> v;\n    \n    scanf(\"%d\", &k);\n    \n    for (i = 0; i < k; i++) scanf(\"%d\", &a[i]);\n    \n    for (i = 0; i < k; i++) {\n        if (a[i] < m1) m1 = a[i];\n        if (a[i] > m2) m2 = a[i];\n    }\n    \n    if (m1 * 2 < m2) {\n        puts(\"-1\");\n        \n        return 0;\n    }\n    \n    for (i = (m2 + 1) / 2; i <= m1; i++) {\n        vector<int> w = calc(i);\n        \n        if (v.size() == 0 || w < v) v = w;\n    }\n    \n    for (i = 0; i < v.size(); i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", v[i] + 1);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\nconst int maxn = 100 + 5;\nconst int mod = 998244353; \n\nint k;\nint a[maxn], p[1000 + 10], q[maxn];\nint last[maxn];\n\nbool check(int sz){\n\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\tif (mxm < 2*mnm+1)\n\t\treturn true;\n\tif (mxm > 2*mnm+1)\n\t\treturn false;\n\tfor (int i = sz; i >= sz-k+1; i--)\n\t\tlast[p[i]] = i;\n\tint m1 = sz, m2 = sz-k+1;\n\tfor (int i = 1; i <= k; i++){\n\t\tif (a[i] == mnm)\n\t\t\tm1 = min(m1, last[i]);\n\t\tif (a[i] == mxm)\n\t\t\tm2 = max(m2, last[i]);\n\t}\n\treturn m2 < m1;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin >> k;\n\tint sum = 0;\n\tfor (int i = 1; i <= k; i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tif (*max_element(a+1,a+k+1) > 2 * (*min_element(a+1,a+k+1)))\n\t\treturn cout << -1 << endl, 0;\n\tint sz = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tp[++sz] = i;\n\tif (*max_element(a+1,a+k+1) == 2 * (*min_element(a+1,a+k+1))){\n\t\tsz = 0;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] == *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (a[i] != *max_element(a+1,a+k+1))\n\t\t\t\tp[++sz] = i;\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t\ta[i] --;\n\tint tmp = 0;\n\twhile (sz < sum){\n\t\tassert(tmp != sz);\n\t\ttmp = sz;\n\t\tfor (int i = sz-k+1; i <= sz; i++)\n\t\t\tq[i-(sz-k)] = p[i];\n\t\tvector<int> then;\n\t\tfor (int i = 1; i <= k; i++){\n\t\t\tset<int> A, B;\n\t\t\tfor (int j = 1; j <= i; j++){\n\t\t\t\ta[q[j]] --;\n\t\t\t\tA.insert(q[j]);\n\t\t\t}\n\t\t\tint now = sz;\n\t\t\tint mnm = *min_element(a+1,a+k+1), mxm = *max_element(a+1,a+k+1);\n\t\t\tbool flag = (mxm == 2*mnm+1);\n\t\t\tvector<int> me;\n\t\t\twhile (!A.empty()){\n\t\t\t\tint x = *A.begin();\n\t\t\t\tA.erase(A.begin());\n\t\t\t\tif (a[x] == mnm and flag){\n\t\t\t\t\tB.insert(x);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[++now] = x;\n\t\t\t\tme.push_back(x);\n\t\t\t}\n\t\t\tfor (auto it : B){\n\t\t\t\tp[++now] = it;\n\t\t\t\tme.push_back(it);\n\t\t\t}\n\t\t\tif (check(now) and (then.empty() or me < then))\n\t\t\t\tthen = me;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\ta[q[j]] ++;\n\t\t}\n\t\tfor (auto it : then){\n\t\t\tp[++sz] = it;\n\t\t\ta[it] --;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sz; i++)\n\t\tcout << p[i] << \" \\n\"[i == sz];\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>  \n#include <complex>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 998244353;\ndouble eps = 1e-12;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 2e18\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n \nll mpow(ll a, ll b){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2);\n\tt1 *= t1;\n\tt1 %= MOD;\n\tif(b%2) t1 *= a;\n\tt1 %= MOD;\n\treturn t1;\n}\n \nll mpow(ll a, ll b, ll p){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2,p);\n\tt1 *= t1;\n\tt1 %= p;\n\tif(b%2) t1 *= a;\n\tt1 %= p;\n\treturn t1;\n}\n \nll modinverse(ll a, ll m){\n\tll m0 = m; \n    ll y = 0, x = 1; \n    if (m == 1) return 0; \n    while (a > 1){\n        ll q = a / m; \n        ll t = m; \n        m = a % m, a = t; \n        t = y; \n        y = x - q * y; \n        x = t; \n    }\n    if (x < 0) x += m0; \n    return x; \n}\n\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n \nll range(ll l, ll r){\n\treturn l + mt()%(r-l+1);\n}\n \nll rev(ll v){\n\treturn mpow(v,MOD-2);\n}\n\nvoid solve(){\n\tll n;\n\tcin >> n;\n\tll a[n];\n\tll mn = 1000;\n\tll mx = 0;\n\tll mx1 = 0;\n\tll l=0;\n\tforn(i,n){\n\t\tcin >> a[i];\n\t\tl+=a[i];\n\t\tmn = min(mn,a[i]);\n\t\tmx = max(mx,a[i]);\n\t\tif(i) mx1 = max(mx1,a[i]);\n\t}\n\tif(mx>2*mn){\n\t\tcout << -1 << ln;\n\t\treturn;\n\t}\n\tbool pr[n];\n\tforn(i,n) pr[i]=1;\n\tll ans[l];\n\tll c = 0;\n\tbool cmp[n];\n\tforn(i,n) cmp[i]=0;\n\tv64 vec;\n\tforn(i,l){\n\t\t// cout << i << ln;\n\t\tll val=-1;\n\t\tforn(j,n){\n\t\t\tif(pr[j]){\n\t\t\t\t// cout << j << \" \" << j << ln;\n\t\t\t\tbool bo = 0;\n\t\t\t\tv64 temp;\n\t\t\t\tforn(k,n){\n\t\t\t\t\tif(a[k]>(2*a[j]-1)){\n\t\t\t\t\t\tbo=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[k]==(2*a[j]-1)){\n\t\t\t\t\t\ttemp.pb(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!bo){\n\t\t\t\t\tval = j;\n\t\t\t\t\tif(sz(temp)){\n\t\t\t\t\t\tc = sz(temp);\n\t\t\t\t\t\tfor(auto it : temp) cmp[it]=1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(val!=-1);\n\t\ta[val]--;\n\t\tans[i]=val;\n\t\tif(c) vec.pb(val);\n\t\tif(cmp[val]){\n\t\t\tc--;\n\t\t\tcmp[val]=0;\n\t\t\tif(c==0) vec.clear();\n\t\t}\n\t\t// cout << c << ln;\n\t\tcout << val+1 << \" \";\n\t\tpr[val]=0;\n\t\tif(i>=n-1){\n\t\t\tbool pr1[n];\n\t\t\tforn(i,n) pr1[i]=0;\n\t\t\tbool bo = 1;\n\t\t\tforsn(j,i-n+1,i+1){\n\t\t\t\tif(pr1[ans[j]]){\n\t\t\t\t\tbo=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr1[ans[j]]=1;\n\t\t\t}\n\t\t\tif(bo){\n\t\t\t\tforn(j,n) pr[j]=1;\n\t\t\t\tfor(auto it : vec) pr[it]=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ln;\n}\n \nint main()\n{\n\tfast_cin();\n    ll t=1;\n    // cin >> t;\n    forn(i,t) {\n    \t// cout << \"Case #\" << i+1 << \": \";\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tset<int> MIN;\n\t\tfor(int i=1;i<=k;i++) if(A[i]==mn) MIN.insert(i);\n\t\tvi Ans;\n\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tH[i]-=diff;\n\t\t}\n\t\tmn-=diff;\n\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tint smol = (*(MIN.begin()));\n\t\t\tif(H[smol]==0) break;\n\t\t\t\n\t\t\tfor(auto m:MIN) {D.push_back(m);H[m]--;}\n\t\t\tfor(int i=k;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(!MIN.count(i))\n\t\t\t\t{\n\t\t\t\t\tD.push_front(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tif(!MIN.count(i))\n\t\t\t\t{\n\t\t\t\t\tD.push_back(i);\n\t\t\t\t\tH[i]-=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmn--;\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tif(H[i]==mn) MIN.insert(i);\n\t\t\t}\n\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Ans.size()==0)\n\t\t\t{\n\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t}\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n \nusing namespace std;\n\nint n;\n\nint get_best(vector<pair<int, int> > arr) {\n\tvector<int> big, small;\n \n\tint Q = arr[0].first;\n\n\tfor (int j = 0; j < n; ++j) {\n\t\tif (2*Q == arr[j].first) {\n\t\t\tbig.push_back(arr[j].second);\n\t\t\tarr[j].first -= 2;\n\t\t}\n\t\telse {\n\t\t\tsmall.push_back(arr[j].second);\n\t\t\tarr[j].first--;\n\t\t}\n\t}\n\n\tsort(all(big));\n\tsort(all(small));\n\n\tif (big.size()) return big[0];\n\treturn small[0];\n\n}\n\n\nbool change(vector<pair<int, int> > &arr, int u) {\n\tauto kek = arr;\n\tfor (int i = 0; i < n; ++i) if (kek[i].second == u) {\n\t\tkek[i].first--;\n\t}\n \n\tauto minimum = *min_element(kek.begin(), kek.begin() + n); \n\tauto maximum = *max_element(kek.begin(), kek.begin() + n);\n \n\tif (2*minimum.first < maximum.first) {\n\t\treturn false;\n\t}\n\tcout << u+1 << \" \";\n \n\tfor (int i = n-2; i > 0; i--) if (kek[i] > kek[i+1]) swap(kek[i], kek[i+1]);\n\tarr = kek; \n\n\treturn true;\n\n}\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n \n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n \n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n \n \n\twhile (arr.back().first > 0) {\n \n\t\tvector<int> big, small;\n \n\t\tint Q = arr[0].first;\n \n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n \n\t\tsort(all(big));\n\t\tsort(all(small));\n \n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t\tvector<int> perm;\n\n\t\tfor (int e = 0; e < small.size(); ++e) perm.push_back(small[e]);\n\t\tfor (int e = 0; e < big.size(); ++e) perm.push_back(big[e]);\n\n\t\tint u = 0;\n\n\t\twhile (arr.back().first > 0) {\n\n\t\t\tint W = get_best(arr);\n\n\t\t\tif (W < perm[u]) break;\n\t\t\tif (!change(arr, perm[u])) break;\n\n\t\t\tu = (u+1)%n;\n\n\t\t}\n \n\t}\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Q=1<<10;\nint ans[Q],owo[Q],rem[Q];\nint a[Q],kk,now;\nint b[Q],had[Q];\nvector<int> nw,as;\nbool New(int len)\n{\n    fill(had+1,had+kk+1,0);\n    for(int i=1;i<=kk;i++)\n        b[i]=a[i];\n    for(int i=0;i<(kk-len);i++)\n        had[ans[now-i]]=1;\n    int mn=1e9,mx=0;\n    for(int i=1;i<=kk;i++){\n        if(!had[i])--b[i];\n        mx=max(mx,b[i]),mn=min(mn,b[i]);\n    }\n    if((mn<<1)+1<mx)return 0;\n    if((mn<<1)>=mx){\n        int tp=0;\n        for(int i=1;i<=kk;i++)\n            if(!had[i])owo[++tp]=i;\n        return 1;\n    }\n    nw.clear(),as.clear();\n    for(int i=1;i<=kk;i++)\n        if(!had[i]){\n            if(b[i]==mx)nw.push_back(i);\n            else if(b[i]!=mn)as.push_back(i);\n        }\n    for(int i=1;i<=kk;i++)\n        if((!had[i])&&b[i]==mn)nw.push_back(i);\n    merge(nw.begin(),nw.end(),as.begin(),as.end(),owo+1);\n    return 1;\n}\nint main()\n{\n    scanf(\"%d\",&kk);\n    int mn=1e9,mx=0,sm=0;\n    for(int i=1;i<=kk;i++)\n        scanf(\"%d\",&a[i]),sm+=a[i],mx=max(mx,a[i]),mn=min(mn,a[i]);\n    if((mn<<1)<mx)return 0&puts(\"-1\");\n    New(kk),now=kk;\n    for(int i=1;i<=kk;i++)\n        ans[i]=owo[i],--a[i];\n    while(now<sm){\n        rem[1]=1e9;\n        int len=0;\n        for(int p=1;p<=kk&&p<=sm-now;p++){\n            if(!New(p))continue;\n            for(int i=1;;i++)\n                if(owo[i]!=rem[i]){\n                    if(owo[i]<rem[i]){\n                        len=p;\n                        for(int i=1;i<=p;i++)\n                            rem[i]=owo[i];\n                        rem[p+1]=0;\n                    }\n                    break;\n                }\n        }\n        for(int i=1;i<=len;i++)\n            ans[++now]=rem[i],--a[rem[i]];\n    }\n    for(int i=1;i<=sm;i++)\n        printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 105;\n\nint n, a[N], s;\nint m, ans[1005];\nint b[N];\nint p[N], q[N], t[N];\n\nbool work(int k) {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tb[i] = a[i];\n\t}\n\tfor (int i = 1; i <= k; ++i) {\n\t\t--b[p[i]];\n\t}\n\tint mn = *std::min_element(b + 1, b + 1 + n);\n\tint mx = *std::max_element(b + 1, b + 1 + n);\n\tif (2 * mn + 1 < mx) {\n\t\treturn false;\n\t}\n\tif (2 * mn >= mx) {\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tq[i] = p[i];\n\t\t}\n\t\tstd::sort(q + 1, q + 1 + k);\n\t\treturn true;\n\t}\n\tstd::vector<int> f1, f2;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tif (b[p[i]] == mn || b[p[i]] == mx) {\n\t\t\tf1.push_back(p[i]);\n\t\t} else {\n\t\t\tf2.push_back(p[i]);\n\t\t}\n\t}\n\tstd::sort(f1.begin(), f1.end(), [&](int i, int j) {\n\t\tint x = b[i] == mn, y = b[j] == mn;\n\t\treturn x < y || (x == y && i < j);\n\t});\n\tstd::sort(f2.begin(), f2.end());\n\tstd::merge(f1.begin(), f1.end(), f2.begin(), f2.end(), q + 1);\n\tint pos = n + 1;\n\tfor (int i = k + 1; i <= n; ++i) {\n\t\tif (b[p[i]] == mn) {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = pos; i <= n; ++i) {\n\t\tif (b[p[i]] == mx) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (pos <= n && !f1.empty() && b[f1[0]] == mx) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool cmp(int *a, int *b) {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] != b[i]) {\n\t\t\treturn a[i] < b[i];\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]);\n\t\ts += a[i];\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i] = i;\n\t}\n\tint mx = *std::max_element(a + 1, a + 1 + n);\n\tint mn = *std::min_element(a + 1, a + 1 + n);\n\tif (mx > 2 * mn) {\n\t\tprint(-1);\n\t\treturn 0;\n\t}\n\tm = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i] = i;\n\t}\n\twork(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans[++m] = p[i] = q[i];\n\t\t--a[q[i]];\n\t}\n\twhile (m < s) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tt[i] = 0;\n\t\t}\n\t\tt[1] = n + 1;\n\t\tint k = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (work(i) && cmp(q, t)) {\n\t\t\t\tk = i;\n\t\t\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\t\t\tt[j] = q[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n - k; ++i) {\n\t\t\tp[i] = p[i + k];\n\t\t}\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t\tp[n - k + i] = t[i];\n\t\t\tans[++m] = t[i];\n\t\t\t--a[t[i]];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tprint(ans[i], \" \\n\"[i == m]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define N 1010\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N],k,now,ans[N];\nconst vector<int> inf(1,23333);\nbool check(){\n\tint x=*max_element(a+1,a+k+1);\n\tint y=*min_element(a+1,a+k+1);\n\treturn x<=(y<<1);\n}\nvoid Merge(vector<int> &a,vector<int> &b,vector<int> &c){\n\tint pa=0,pb=0;\n\twhile(pa<(int)a.size()&&pb<(int)b.size()){\n\t\tc.push_back(a[pa]<b[pb]?a[pa++]:b[pb++]);\n\t}\n\twhile(pa<(int)a.size())c.push_back(a[pa++]);\n\twhile(pb<(int)b.size())c.push_back(b[pb++]);\n}\nvector<int> Solve(int len){\n\tstatic int vis[N],b[N];\n\tfor(int i=1;i<=k;++i){\n\t\tvis[i]=0,b[i]=a[i];\n\t}\n\tfor(int i=now+len-k+1;i<=now;++i){\n\t\tvis[ans[i]]=1;\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\tif(!vis[i])if((--b[i])<0)return inf;\n\t}\n\tint mn=*min_element(b+1,b+k+1);\n\tint mx=*max_element(b+1,b+k+1);\n\tif(mn*2+1<mx)return inf;\n\tvector<int> res;\n\tif(mn*2>=mx){\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i])res.push_back(i);\n\t\t}\n\t}\n\telse{\n\t\tvector<int> A,B;\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mx)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]==mn)A.push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tif(!vis[i]&&b[i]^mn&&b[i]^mx)B.push_back(i);\n\t\t}\n\t\tMerge(A,B,res);\n\t\tint pmx=0,pmn=n+1;\n\t\tfor(int i=now+len-k+1;i<=now;++i){\n\t\t\tif(b[ans[i]]==mx)pmx=max(pmx,i);\n\t\t\tif(b[ans[i]]==mn)pmn=min(pmn,i);\n\t\t}\n\t\tfor(int i=0;i<(int)res.size();++i){\n\t\t\tif(b[res[i]]==mx)pmx=max(pmx,i+now+1);\n\t\t\tif(b[res[i]]==mn)pmn=min(pmn,i+now+1);\n\t\t}\n\t\tif(pmx>pmn)res=inf;\n\t}\n\treturn res;\n}\nvoid Extend(){\n\tvector<int> ext=inf;\n\tfor(int len=1;len<=k&&len+now<=n;++len){\n\t\tif(len+now>=k){\n\t\t\text=min(ext,Solve(len));\n\t\t}\n\t}\n\tfor(auto x:ext){\n\t\tans[++now]=x;\n\t\t--a[x];\n\t}\n}\nint main(){\n\tk=read();\n\tfor(int i=1;i<=k;++i){\n\t\tn+=a[i]=read();\n\t}\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(now<n){\n\t\tExtend();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\n\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"J_input.txt\", \"r\", stdin);\n\t//freopen(\"J_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; ++i) cin >> v[i];\n\n\tvector<pair<int, int> > arr;\n\tfor (int i = 0; i < n; ++i) arr.pb(mp(v[i], i));\n\n\tsort(all(arr));\n\n\tif (2*arr[0].first < arr.back().first) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\n\tint steps = arr[0].first;\n\tfor (int i = 0; i < steps; ++i) {\n\n\t\tvector<int> big, small;\n\n\t\tint Q = arr[0].first;\n\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (2*Q == arr[j].first) {\n\t\t\t\tbig.push_back(arr[j].second);\n\t\t\t\tarr[j].first -= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmall.push_back(arr[j].second);\n\t\t\t\tarr[j].first--;\n\t\t\t}\n\t\t}\n\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\t\tfor (int e = 0; e < small.size(); ++e) cout << small[e]+1 << \" \";\n\t\tfor (int e = 0; e < big.size(); ++e) cout << big[e]+1 << \" \";\n\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint k;\n\tcin >> k;\n\tvector<int> freq(k);\n\tfor(int& x : freq) cin >> x;\n\tint minv = 1000000, maxv = -1;\n\tfor(int x : freq){\n\t\tminv = min(minv, x); maxv = max(maxv, x);\n\t}\n\tint sum = 0;\n\tfor(int x : freq) sum += x;\n\tif(minv * 2 < maxv){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> ans;\n\tint maxworks = 0;\n\twhile((int)ans.size() < sum){\n\t\tbool found = false;\n\t\tfor(int nxt = 0; nxt < k; nxt++){\n\t\t\tvector<int> cans = ans;\n\t\t\tcans.push_back(nxt);\n\t\t\tint cmaxworks = maxworks;\n\t\t\t{\n\t\t\t\tif((int)cans.size() >= k){\n\t\t\t\t\tvector<int> d(k, 0);\n\t\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\t\td[cans[(int)cans.size() - 1 - i]]++;\n\t\t\t\t\t}\n\t\t\t\t\tbool works = true;\n\t\t\t\t\tfor(int i = 0; i < k; i++) if(!d[i]) works = false;\n\t\t\t\t\tif(works) cmaxworks = (int)cans.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cfreq = freq;\n\t\t\tcfreq[nxt]--;\n\t\t\tif(cfreq[nxt] < 0) continue;\n\t\t\tvector<int> known;\n\t\t\tfor(int f = cmaxworks; f < (int)cans.size(); f++) known.push_back(cans[f]);\n\t\t\tvector<int> zk = known;\n\t\t\tsort(zk.begin(), zk.end());\n\t\t\tif(unique(zk.begin(), zk.end()) != zk.end()) continue;\n\t\t\tbool ok = false;\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\treverse(known.begin(), known.end());\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tfor(int a : known){\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t}\n\t\t\t\tmultiset<int> g;\n\t\t\t\tfor(int f : dfreq) g.insert(f);\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tfor(int b = cmaxworks - 1; b >= 0; b--){\n\t\t\t\t\tif(cur[cans[b]]) break;\n\t\t\t\t\tcur[cans[b]] = 1;\n\t\t\t\t\tint a = cans[b];\n\t\t\t\t\tg.erase(g.find(dfreq[a]));\n\t\t\t\t\tdfreq[a]++;\n\t\t\t\t\tg.insert(dfreq[a]);\n\t\t\t\t\tif(*g.rbegin() <= 2 * *g.begin()) ok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dfreq = cfreq;\n\t\t\t\tfor(int i = 0; i < k; i++) dfreq[i]--;\n\t\t\t\tvector<int> cur(k, 0);\n\t\t\t\tfor(int a : known) cur[a] = 1;\n\t\t\t\tint minval = 1000000;\n\t\t\t\tfor(int b : dfreq) minval = min(minval, b);\n\t\t\t\tfor(int i = 0; i < k; i++){\n\t\t\t\t\tif(cur[i]) continue;\n\t\t\t\t\tif(dfreq[i] > 2 * minval){\n\t\t\t\t\t\tdfreq[i]--;\n\t\t\t\t\t\tcur[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ming = 100000, maxg = 0;\n\t\t\t\tfor(int b : dfreq) ming = min(ming, b);\n\t\t\t\tfor(int b : dfreq) maxg = max(maxg, b);\n\t\t\t\tif(ming * 2 >= maxg){\n\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans.push_back(nxt);\n\t\t\t\tmaxworks = cmaxworks;\n\t\t\t\tfound = true;\n\t\t\t\tfreq[nxt]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for(int b : ans) cerr << b << ' ';\n\t\t// cerr << '\\n';\n\t\tassert(found);\n\t}\n\tfor(int b : ans) cout << b+1 << ' ';\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  void solveOne(istream &in, ostream &out) {\n    int k;\n    in >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) in >> a[i];\n    int mn = a[0];\n    int mx = a[0];\n    for (int x : a) {\n      mn = min(mn, x);\n      mx = max(mx, x);\n    }\n    if (mx > 2 * mn) {\n      out << -1 << \"\\n\";\n      return;\n    }\n    int total = 0;\n    for (int x : a) total += x;\n    vector<int> res(total, -1);\n    int permStart = 0;\n    for (int pos = 0; pos < total; ++pos) {\n      for (int val = 0; val < k; ++val) if (a[val] > 0) {\n        res[pos] = val;\n        --a[val];\n        vector<int> sa = a;\n        vector<bool> inPerm(k, false);\n        for (int i = permStart; i < pos && i < permStart + k; ++i) inPerm[res[i]] = true;\n        bool ok = false;\n        if (pos - k >= permStart) {\n          if (val == res[pos - k]) {\n            for (int endAt = pos + 1; endAt <= total; ++endAt) {\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                break;\n              }\n              --a[res[(endAt - permStart) % k + permStart]];\n            }\n          } else {\n            // Start new permutation\n            for (int i = 0; i < k; ++i) if (i != val) --a[i];\n            vector<ii> avail;\n            for (int i = 0; i < k; ++i) if (i != val) {\n              avail.emplace_back(-a[i], i);\n            }\n            sort(avail.begin(), avail.end());\n            int ptr = 0;\n            for (int plen = k; plen < 2 * k; ++plen) {\n              if (plen > k) {\n                if (plen == k + 1) {\n                  --a[val];\n                } else {\n                  --a[avail[ptr++].second];\n                }\n              }\n              mn = a[0];\n              mx = a[0];\n              for (int x : a) {\n                mn = min(mn, x);\n                mx = max(mx, x);\n              }\n              if (mn >= 0 && mx <= 2 * mn) {\n                ok = true;\n                permStart = pos;\n                break;\n              }\n            }\n          }\n        } else if (!inPerm[val]) {\n          inPerm[val] = true;\n          for (int i = 0; i < k; ++i) if (!inPerm[i]) --a[i];\n          vector<ii> avail;\n          for (int i = 0; i < k; ++i) if (!inPerm[i]) {\n              avail.emplace_back(-a[i], i);\n            }\n          sort(avail.begin(), avail.end());\n          int ptr = 0;\n          for (int plen = k; plen < 2 * k; ++plen) {\n            if (plen > k) {\n              if (permStart + plen - k - 1 <= pos) {\n                --a[res[permStart + plen - k - 1]];\n              } else {\n                --a[avail[ptr++].second];\n              }\n            }\n            mn = a[0];\n            mx = a[0];\n            for (int x : a) {\n              mn = min(mn, x);\n              mx = max(mx, x);\n            }\n            if (mn >= 0 && mx <= 2 * mn) {\n              ok = true;\n              break;\n            }\n          }\n        }\n        a = sa;\n        if (ok) {\n          break;\n        } else {\n          ++a[val];\n          assert(val + 1 < k);\n        }\n      }\n    }\n    for (int x : res) out << x + 1 << \" \";\n    out << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    unsigned long K;\n    cin >> K;\n    vector<unsigned long> a(K);\n    for(auto&& i : a)cin >> i;\n    if(*min_element(begin(a), end(a)) * 2 >= *max_element(begin(a), end(a)))return 0 & puts(\"-1\");\n    abort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops, loopsm;\nUL P2[100];\nvector<UL> buf;\nvector<vector<UL>> ans;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloopsm = 1000; rep(i, K) loopsm = min(loopsm, P[i]);\n\tloops = (loops + 1) / 2;\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\n\tfor (UL L = loops; L <= loopsm; L++) {\n\t\tvector<UL> ans;\n\t\trep(l, L) {\n\t\t\tvector<UL> S, T;\n\t\t\tUL p = 0;\n\t\t\trep(i, K) {\n\t\t\t\tif (P2[i] == L - l) {\n\t\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\t\telse T.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\t\tfor (; p < K; p++) {\n\t\t\t\tT.push_back(p);\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\tsort(T.begin(), T.end());\n\t\t\tconcat(ans, S);\n\t\t\tconcat(ans, T);\n\t\t\tconcat(ans, S);\n\t\t}\n\t\t::ans.push_back(ans);\n\t}\n\tsort(ans.begin(), ans.end());\n\trep(i, ans[0].size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[0][i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 1e3 + 50;\ncs int INF = 1e9 + 7;\nvoid ckmn(int &a, int b){ if(a > b) a = b; }\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\nint n, a[N], m, ans[N];\nint now[N], nxt[N], my;\nbool cmp(cs int &i, cs int &j){\n\tint x=a[i]==my,y=a[j]==my;\n\tif(x!=y)return x<y; return i<j;\n}\nbool work(int len){\n\tfor(int i=1;i<=len;i++)--a[now[i]];\n\tint mn=INF,mx=0;\n\tfor(int i=1; i<=n; i++)\n\tmn=min(mn,a[i]),mx=max(mx,a[i]);\n\t\n\tif(mn*2>=mx){\n\t\tfor(int i=1; i<=len; i++)\n\t\t++a[nxt[i]=now[i]];\n\t\tsort(nxt+1,nxt+len+1);\n\t\tnxt[len+1]=0;\n\t\treturn true;\n\t}\n\t\n\tif(mn*2+1<mx){\n\t\tfor(int i=1; i<=len; i++) ++a[now[i]];\n\t\treturn false;\n\t}\n\t\n\tstatic int t1[N], t2[N]; int z1=0, z2=0;\n\tfor(int i=1; i<=len; i++)\n\tif(a[now[i]]==mn||a[now[i]]==mx)\n\tt1[++z1]=now[i]; else t2[++z2]=now[i]; \n\t\n\tmy=mn;\n\tsort(t1+1,t1+z1+1,cmp);\n\tsort(t2+1,t2+z2+1);\n\t\n\tfor(int i=1,p=1,q=1; i<=len; i++)\n\tif((p<=z1 && t1[p]<t2[q])||q>z2) nxt[i]=t1[p++];\n\telse nxt[i]=t2[q++]; nxt[len+1]=0;\n\n\tbool ok=true;\n\tfor(int i=len+1;i<=n;i++)ok&=(a[now[i]]!=mn);\n\tok|=(z1==0)|(a[t1[1]]==mn);\n\t\n\tfor(int i=1; i<=len; i++)++a[now[i]];\n\treturn ok;\n}\nbool cmp(int *a, int *b){ \n\tint i=1;for(;a[i]==b[i];i++);\n\treturn a[i]<b[i];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"my.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tint mn=INF,mx=0,sm=0;\n\tfor(int i=1; i<=n; i++)\n\tscanf(\"%d\",&a[i]),sm+=a[i],\n\tckmn(mn,a[i]),ckmx(mx,a[i]);\n\tif(mn*2<mx) return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\t\n\tnow[i]=i; if(!work(n))return puts(\"-1\"),0;\n\tfor(int i=1; i<=n; i++)\n\tnow[i]=ans[++m]=nxt[i],--a[now[i]];\n\twhile(m<sm){\n\t\tstatic int trs[N];\n\t\tint len=0;trs[1]=n+1;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(work(i)&&cmp(nxt,trs))\n\t\t\tlen=i,memcpy(trs,nxt,sizeof(int)*(len+2));\n\t\t}\n\t\tfor(int i=1; i+len<=n; i++)\n\t\tnow[i]=now[i+len];\n\t\tfor(int i=1; i<=len; i++)\n\t\tnow[i+n-len]=ans[++m]=trs[i],--a[trs[i]];\n\t}\n\tfor(int i=1; i<=m; i++)cout<<ans[i]<<\" \";\n\tfor(int i=1; i<=n; i++)assert(a[i]==0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 1010;\nint n, k;\nint a[N];\nint b[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = 0; i < k; i++)\n\t\tscanf(\"%d\", &a[i]);\n\twhile(true) {\n\t\tint mx = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (a[i] < 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmx = max(mx, a[i]);\n\t\t}\n\t\tif (mx == 0) break;\n\t\tvector<pii> c;\n\t\tif (n == 0) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tc.push_back(mp(a[i], i));\n\t\t} else {\n\t\t\tfor (int i = 0; ; i++) {\n\t\t\t\tint v = b[n - k + i];\n\t\t\t\tc.push_back(mp(a[v], v));\n\t\t\t\tif (a[v] == mx) break;\n\t\t\t}\n\t\t}\n\t\tsort(all(c));\n\t\treverse(all(c));\n\t\tfor (auto t : c) {\n\t\t\tint v = t.second;\n\t\t\tif (a[v] == 0) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta[v]--;\n\t\t\tb[n++] = v;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", b[i] + 1);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\nconst int maxK=100+5,maxn=1000+5;\nint n,K,a[maxK],an[maxn];\nbool vis[maxK];\ninline bool cmp(const vector<int> &a,const vector<int> &b) {\n\tfor(int i=0;i<a.size()&&i<b.size();++i) if(a[i]!=b[i]) return a[i]<b[i];\n\treturn a.size()<b.size();\n}\nvoid fail(vector<int> &re) {\n\tfor(int i=0;i<=K;++i) re.push_back(K+1);\n}\nvoid sol(int s,int m,vector<int> &re) {\n\tstatic int b[maxK]; memcpy(b,a,sizeof(b));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i+m<=K;++i) vis[an[s-i]]=1;\n\tfor(int i=1;i<=K;++i) if(!vis[i]) {\n\t\tif(!b[i]) {fail(re); return;}\n\t\t--b[i];\n\t}\n\tint x=*max_element(b+1,b+K+1),y=*min_element(b+1,b+K+1);\n\tif(x>2*y+1) {fail(re); return;}\n\tvector<int> A,B,C;\n\tif(x==2*y+1) {\n\t\tbool flag=0;\n\t\tfor(int i=1;i+m<=K;++i) {\n\t\t\tif(b[an[s-i]]==x) flag=1;\n\t\t\telse if(b[an[s-i]]==y) {\n\t\t\t\tif(flag) {fail(re); return;}\n\t\t\t}\n\t\t}\n\t\tfor(int i=K;i>=1;--i) if(!vis[i]) {\n\t\t\tif(b[i]==x) A.push_back(i);\n\t\t\telse if(b[i]==y) B.push_back(i);\n\t\t\telse C.push_back(i);\n\t\t}\n\t}\n\telse for(int i=K;i>=1;--i) if(!vis[i]) C.push_back(i);\n\tfor(int i=1;i<=m;++i) {\n\t\tif(A.size()) {\n\t\t\tint t=C.size()?C.back():K+1;\n\t\t\tif(A.back()<t) re.push_back(A.back()),A.pop_back();\n\t\t\telse re.push_back(t),C.pop_back();\n\t\t}\n\t\telse {\n\t\t\tint a=B.size()?B.back():K+1,b=C.size()?C.back():K+1;\n\t\t\tif(a<b) re.push_back(a),B.pop_back();\n\t\t\telse re.push_back(b),C.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\trd(K);\n\tfor(int i=1;i<=K;++i) rd(a[i]),n+=a[i];\n\tif(*max_element(a+1,a+K+1)>2*(*min_element(a+1,a+K+1))) {puts(\"-1\"); return 0;}\n\tfor(int i=1;i<=n;) {\n//\t\tdebug(\"---\\n\");\n\t\tvector<int> Q[maxK];\n\t\tif(i==1) sol(i,K,Q[1]);\n\t\telse {\n\t\t\tfor(int j=1;j<=K;++j) sol(i,j,Q[j]);\n\t\t\tint k=1;\n\t\t\tfor(int j=2;j<=K;++j) if(cmp(Q[j],Q[k])) k=j;\n\t\t\tif(k!=1) swap(Q[1],Q[k]);\n\t\t}\n\t\tfor(int j=0;j<Q[1].size();++j) an[i+j]=Q[1][j],--a[Q[1][j]];\n\t\ti+=Q[1].size();\n//\t\tfor(int j=1;j<i;++j) debug(\"%d \",an[j]); debug(\"\\n\");\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tif(i!=1) printf(\" \");\n\t\tprintf(\"%d\",an[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntemplate <typename T> void setmax(T& a, const T& b) { if (b > a) a = b; }\ntemplate <typename T> void setmin(T& a, const T& b) { if (b < a) a = b; }\n\nstruct interval {\n\tint lo, hi;\n\tinterval() : lo(0), hi(0) {}\n\tinterval(int lo_, int hi_) : lo(lo_), hi(hi_) {}\n\tinterval& operator &= (const interval& o) {\n\t\tsetmax(lo, o.lo);\n\t\tsetmin(hi, o.hi);\n\t\treturn *this;\n\t}\n\tfriend interval operator & (const interval& a, const interval& b) {\n\t\treturn interval(std::max(a.lo, b.lo), std::min(a.hi, b.hi));\n\t}\n\texplicit operator bool () const {\n\t\treturn lo <= hi;\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint K; cin >> K;\n\tvector<int> A(K);\n\tfor (int i = 0; i < K; i++) cin >> A[i];\n\tif (*min_element(A.begin(), A.end()) * 2 < *max_element(A.begin(), A.end())) {\n\t\tcout << -1 << '\\n';\n\t\texit(0);\n\t}\n\n\tint L = accumulate(A.begin(), A.end(), 0);\n\tvector<int> res; res.reserve(L);\n\tauto is_good = [&K, &res, &A]() -> bool {\n\t\tvector<bool> seen(K);\n\t\tint N = int(res.size());\n\t\tint st = N;\n\t\twhile (st > 0 && !seen[res[st-1]]) {\n\t\t\t--st;\n\t\t\tseen[res[st]] = true;\n\t\t}\n\n\t\tint en;\n\t\tif (N - st == K) {\n\t\t\ten = N;\n\t\t} else if (st == 0) {\n\t\t\ten = 0;\n\t\t} else {\n\t\t\tint l = st, r = N;\n\t\t\twhile (r - l < K) {\n\t\t\t\tif (l == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seen[res[l-1]]) {\n\t\t\t\t\tseen[res[--r]] = false;\n\t\t\t\t\tif (r < st) return false;\n\t\t\t\t} else {\n\t\t\t\t\tseen[res[--l]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ten = r;\n\t\t}\n\n\t\tseen.assign(K, 0);\n\t\tfor (int i = st; i < N; i++) seen[res[i]] = true;\n\n\t\tauto can_make = [&](interval base, vector<pair<interval, interval>> opts) {\n\t\t\tvector<interval> pref(opts.size()+1);\n\t\t\tpref[0] = base;\n\t\t\tfor (int i = 0; i < int(opts.size()); i++) {\n\t\t\t\tpref[i+1] = pref[i] & opts[i].first;\n\t\t\t}\n\t\t\tinterval suff = base;\n\t\t\tif (pref.back()) return true;\n\t\t\tfor (int i = int(opts.size())-1; i >= 0; i--) {\n\t\t\t\tsuff &= opts[i].second;\n\t\t\t\tif (pref[i] & suff) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\t{\n\t\t\tinterval fixed(0, int(1e9));\n\t\t\tfor (int v = 0; v < K; v++) {\n\t\t\t\tif (!seen[v]) {\n\t\t\t\t\tfixed &= interval(A[v], 2*A[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = en; i < N; i++) {\n\t\t\t\tint v = res[i];\n\t\t\t\tfixed &= interval(A[v]+1, 2*A[v]+1);\n\t\t\t}\n\t\t\tvector<pair<interval, interval>> opts; opts.reserve(en-st);\n\t\t\tfor (int i = st; i < en; i++) {\n\t\t\t\tint v = res[i];\n\t\t\t\topts.push_back({{A[v],2*A[v]}, {A[v]+1, 2*A[v]+1}});\n\t\t\t}\n\t\t\tif (can_make(fixed, opts)) return true;\n\t\t}\n\n\t\t{\n\t\t\tinterval fixed(0, int(1e9));\n\t\t\tfor (int v = 0; v < K; v++) {\n\t\t\t\tif (!seen[v]) {\n\t\t\t\t\tfixed &= interval(A[v]+1, 2*A[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<pair<interval, interval>> opts; opts.reserve(N-st);\n\t\t\tfor (int i = st; i < N; i++) {\n\t\t\t\tint v = res[i];\n\t\t\t\topts.push_back({{A[v]+1, 2*A[v]+1}, {A[v]+2, 2*A[v]+2}});\n\t\t\t}\n\t\t\tif (can_make(fixed, opts)) return true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tfor (int curL = 1; curL <= L; curL++) {\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tif (A[i]) {\n\t\t\t\tA[i]--;\n\t\t\t\tres.push_back(i);\n\t\t\t\tif (is_good()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres.pop_back();\n\t\t\t\tA[i]++;\n\t\t\t}\n\t\t}\n\t\tassert(int(res.size()) == curL);\n\t}\n\n\tfor (int z = 0; z < L; z++) {\n\t\tcout << res[z]+1 << \" \\n\"[z+1==L];\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\nconst int N=1005;\nint n,a[N],s,ans[N],top;\nbool construct1(bool flag){\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]-1),v2=max(v2,a[i]-1);\n\tif (v1*2+1<v2||v1<0) return 0;\n\tFor(i,1,n) a[i]--;\n\tif (v1*2>=v2){\n\t\tFor(i,1,n) ans[++top]=i;\n\t}\n\telse{\n\t\tint p=0;\n\t\tFor(i,1,n) if (a[i]==v2) p=i;\n\t\tFor(i,1,p) if (a[i]!=v1) ans[++top]=i;\n\t\tFor(i,1,p) if (a[i]==v1) ans[++top]=i;\n\t\tFor(i,p+1,n) ans[++top]=i;\n\t}\n\tif (flag==1){\n\t\tFor(i,1,n) a[i]++;\n\t\ttop-=n;\n\t}\n\treturn 1;\n}\nbool construct2(int flag){\n\tint v=ans[top+1]=ans[top+1-n];\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]-(i==v)),v2=max(v2,a[i]-(i==v));\n\tif (v1*2+1<v2||v1<0) return 0;\n\tif (v1*2+1==v2){\n\t\tint p1=1e9,p2=0; --a[v];\n\t\tFor(i,top+2-n,top+1){\n\t\t\tif (a[ans[i]]==v1) p1=min(p1,i);\n\t\t\tif (a[ans[i]]==v2) p2=max(p2,i);\n\t\t}\n\t\t++a[v];\n\t\tif (p1<p2) return 0;\n\t}\n\t//cout<<top<<' '<<v<<' '<<ans[top+1]<<endl;\n\tif (!flag){\n\t\t++top; --a[v];\n\t}\n\treturn 1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) s+=a[i];\n\tint v1=1e9,v2=0;\n\tFor(i,1,n) v1=min(v1,a[i]),v2=max(v2,a[i]);\n\tif (v1*2<v2) return puts(\"-1\"),0;\n\tconstruct1(0);\n\tfor (;top!=s;){\n\t\tint v1=(construct1(1)?ans[top+1]:1e9);\n\t\tint v2=(construct2(1)?ans[top+1]:1e9);\n\t\t//cout<<v1<<' '<<v2<<' '<<top<<' '<<a[1]<<' '<<a[2]<<' '<<a[3]<<endl;\n\t\tassert(min(v1,v2)<=n);\n\t\tv1<v2?construct1(0):construct2(0);\n\t}\n\tFor(i,1,s) cout<<ans[i]<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint a[233];\nvector<int> ans,tx,ty;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\twhile(1)\n\t{\n\t\tint minn=114514,maxx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tminn=min(minn,a[i]);\n\t\t\tmaxx=max(maxx,a[i]);\n\t\t}\n\t\tif(maxx==0)break;\n\t\telse if(maxx>2*minn)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttx.clear();ty.clear();\n\t\tint zz=0;\n\t\tfor(int i=n;i>=1;i--)\n\t\t{\n\t\t\tif(a[i]>2*minn-1)tx.push_back(i),zz=2;\n\t\t\telse if(a[i]>minn&&!zz)tx.push_back(i),zz=1;\n\t\t\telse ty.push_back(i);\n\t\t}\n\t\tfor(auto x:tx)ans.push_back(x),a[x]--;\n\t\tfor(auto x:ty)ans.push_back(x),a[x]--;\n\t\tfor(auto x:tx)ans.push_back(x),a[x]--;\n\t}\n\treverse(ans.begin(),ans.end());\n\tfor(auto x:ans)cout<<x<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) {\n\t\t\tlen = pre - i;\n\t\t\tbreak;\n\t\t}\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j && j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    int len;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    len = (amax + 1) / 2;\n    if (len > amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(len);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= len;\n    }\n    for (int i = 0; i < a[1]; ++i) {\n        vs[i].insert(1);\n    }\n    if (a[1] > 0) {\n        for (int i = 2; i <= k; ++i) {\n            if (a[i] > 0) {\n                --a[i];\n                vs[a[1] - 1].insert(i);\n            } else {\n                break;\n            }\n        }\n    }\n    \n    int cl;\n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = len - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < len; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint k;\nvector<int> makev(vector<bool>& b) {\n\tvector<int> res;\n\trep(i, k)if (b[i])res.push_back(i);\n\trep(i, k)if (!b[i])res.push_back(i);\n\trep(i, k)if (b[i])res.push_back(i);\n\treturn res;\n}\nvector<int> calc (vector<int>& a) {\n\tvector<int> ans;\n\tint mi = mod;\n\tint ma = 0;\n\trep(i, k) {\n\t\tmi = min(mi, a[i]);\n\t\tma = max(ma, a[i]);\n\t}\n\tif (mi == 0)return {};\n\tvector<int> ts;\n\trep(i, k)if (a[i] == 2 * mi) {\n\t\tts.push_back(i);\n\t}\n\tif (ts.empty()) {\n\t\trep(i, k)ans.push_back(i);\n\t}\n\telse {\n\t\tint las = ts.back();\n\n\t\tbool onm2 = false;\n\t\tvector<bool> t2(k);\n\t\tfor (int id : ts)t2[id] = true;\n\t\trep(i, las) {\n\t\t\tif (t2[i])continue;\n\t\t\tif (ma >= 2 * a[i] - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\tt2[i] = true;\n\t\t\t\tonm2 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\t\tif (onm2) {\n\t\t\trep(i, k)if (a[i] == ma) {\n\t\t\t\tt2[i] = true;\n\t\t\t}\n\t\t}\n\n\t\trep(i, k)if (t2[i]) {\n\t\t\tans.push_back(i);\n\t\t}\n\t\trep(i, k)if (!t2[i]) {\n\t\t\tans.push_back(i); \n\t\t}\n\t\trep(i, k)if (t2[i]) {\n\t\t\tans.push_back(i); \n\t\t}\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tcin >> k;\n\tvector<int> a(k);\n\trep(i, k) {\n\t\tcin >> a[i];\n\t}\n\trep(i, k)rep(j, k) {\n\t\tif (a[j] > 2 * a[i]) {\n\t\t\tcout << -1 << \"\\n\"; return;\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\twhile (a[0]>0) {\n\t\tint mi = mod;\n\t\tint ma = 0;\n\t\trep(i, k) {\n\t\t\tmi = min(mi, a[i]);\n\t\t\tma = max(ma, a[i]);\n\t\t}\n\t\tvector<int> ts;\n\t\trep(i, k)if (a[i] == 2 * mi) {\n\t\t\tts.push_back(i);\n\t\t}\n\t\tif (ts.empty()) {\n\t\t\tvector<int> cop = a;\n\t\t\trep(i, k)cop[i]--;\n\t\t\t\n\t\t\tvector<bool> is2(k, false);\n\t\t\tvector<int> nt = makev(is2);\n\t\t\tvector<int> ad = calc(cop);\n\t\t\tvector<int> nnt = nt;\n\t\t\tfor (int id : ad)nnt.push_back(id);\n\n\t\t\tbool ald = false;\n\t\t\trep(i, k) {\n\t\t\t\tif (is2[i])continue;\n\t\t\t\tif (ma >= 2 * a[i] - 1)continue;\n\t\t\t\telse if (ma == 2 * a[i] - 2) {\n\t\t\t\t\tif (!ald) {\n\t\t\t\t\t\tald = true;\n\t\t\t\t\t\trep(j, k)if (a[j] == ma) {\n\t\t\t\t\t\t\tif (!is2[j]) {\n\t\t\t\t\t\t\t\tis2[j] = true;\n\t\t\t\t\t\t\t\tcop[j]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tis2[i] = true;\n\t\t\t\t\tcop[i]--;\n\t\t\t\t}\n\t\t\t\tvector<int> cur = makev(is2);\n\t\t\t\tad = calc(cop);\n\t\t\t\tvector<int> ccur = cur;\n\t\t\t\tfor (int id : ad)ccur.push_back(id);\n\t\t\t\tif (nnt > ccur) {\n\t\t\t\t\tswap(nt, cur);\n\t\t\t\t\tswap(nnt, ccur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int id : nt) {\n\t\t\t\tans.push_back(id);\n\t\t\t\ta[id]--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvector<int> nex = calc(a);\n\t\t\tfor (int id : nex) {\n\t\t\t\ta[id]--;\n\t\t\t\tans.push_back(id);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << ans[i]+1;\n\t}\n\tcout << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint K;\nint A[111];\n\nbool valid() {\n    int ma = *max_element(A, A+K);\n    if (ma == 0) return true;\n    int mi = *min_element(A, A+K);\n    return mi * 2 >= ma;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &K);\n    REP (i, K) {\n\tint a;\n\tscanf(\"%d\", &a);\n\tA[i] = a;\n    }\n\n    if (!valid()) {\n\tputs(\"-1\");\n\treturn;\n    }\n\n    VI ans;\n    while (1) {\n\tint ma = *max_element(A, A+K);\n\tint mii = min_element(A, A+K) - A;\n\tint mi = A[mii];\n\n\t// rprintf(\"%d\", ans.begin(), ans.end());\n\tif (ma == 0) break;\n\n\tif (A[0] >= 2) {\n\t    REP (i, K) A[i]--;\n\t    A[0]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tans.push_back(0);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t\tA[0]++;\n\t    }\n\t}\n\n\tif (ma == mi) {\n\t    REP (i, K) A[i]--;\n\t    if (valid()) {\n\t\tREP (i, K) ans.push_back(i);\n\t\tcontinue;\n\t    } else {\n\t\tREP (i, K) A[i]++;\n\t    }\n\t}\n\t\t\n\tint last_max = 0;\n\tREP (i, K) if (A[i] == ma) last_max = i;\n\n\tVI once, twice;\n\n\tREP (i, K) {\n\t    if (A[i] == ma) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else if (A[i] == mi) {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    } else if (i < mii || i < last_max) {\n\t\ttwice.push_back(i);\n\t\tA[i] -= 2;\n\t    } else {\n\t\tonce.push_back(i);\n\t\tA[i]--;\n\t    }\n\t}\n\n\n\t//rprintf(\"%d.\", A, A+K);\n\tassert(valid());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n\tans.insert(ans.end(), once.begin(), once.end());\n\tans.insert(ans.end(), twice.begin(), twice.end());\n    }\n\n    EACH (e, ans) (*e)++;\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#define RI register int\n#define CI const int&\n#define pb push_back\nusing namespace std;\nconst int N=1005,K=105;\nusing namespace std;\nint k,n,a[K],b[K],ans[N]; vector <int> q[K]; bool vis[K];\ninline bool cmp(vector <int> A,vector <int> B)\n{\n\tfor (RI i=0;i<A.size()&&i<B.size();++i)\n\tif (A[i]!=B[i]) return A[i]<B[i]; return A.size()<B.size();\n}\ninline void fail(vector <int>& v)\n{\n\tfor (RI i=1;i<=k;++i) v.pb(k+1);\n}\ninline void solve(CI st,CI num,vector <int>& res)\n{\n\tres.clear(); memset(vis,0,sizeof(vis)); memcpy(b,a,sizeof(b));\n\tRI i; for (i=1;i+num<=k;++i) vis[ans[st-i]]=1;\n\tfor (i=1;i<=k;++i) if (!vis[i])\n\t{\n\t\tif (b[i]) --b[i]; else return fail(res);\n\t}\n\tint x=*max_element(b+1,b+k+1),y=*min_element(b+1,b+k+1);\n\tif (x>2*y+1) return fail(res); vector <int> A,B,C; //A:b[i]=x; B:b[i]=y; C:otherwise\n\tif (x==2*y+1)\n\t{\n\t\tbool exist=0; for (i=1;i+num<=k;++i) \n\t\tif (b[ans[st-i]]==x) exist=1; else if (b[ans[st-i]]==y&&exist) return fail(res);\n\t\tfor (i=k;i;--i) if (!vis[i])\n\t\t{\n\t\t\tif (b[i]==x) A.pb(i); else if (b[i]==y) B.pb(i); else C.pb(i);\n\t\t}\n\t} else for (i=k;i;--i) if (!vis[i]) C.pb(i);\n\tfor (i=1;i<=num;++i) if (A.size())\n\t{\n\t\tint x=C.size()?C.back():k+1; if (A.back()<x) res.pb(A.back()),A.pop_back();\n\t\telse res.pb(x),C.pop_back();\n\t} else\n\t{\n\t\tint x=B.size()?B.back():k+1,y=C.size()?C.back():k+1;\n\t\tif (x<y) res.pb(x),B.pop_back(); else res.pb(y),C.pop_back();\n\t}\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&k),i=1;i<=k;++i) scanf(\"%d\",&a[i]),n+=a[i];\n\tif (*max_element(a+1,a+k+1)>2*(*min_element(a+1,a+k+1))) return puts(\"-1\"),0;\n\tint num; for (i=1;i<=n;i+=q[num].size())\n\t{\n\t\tif (i==1) solve(i,k,q[num=1]); else\n\t\t{\n\t\t\tfor (j=1;j<=k;++j) solve(i,j,q[j]); num=1;\n\t\t\tfor (j=2;j<=k;++j) if (cmp(q[j],q[num])) num=j;\n\t\t}\n\t\tfor (j=0;j<q[num].size();++j) ans[i+j]=q[num][j],--a[q[num][j]];\n\t}\n\tfor (i=1;i<=n;++i) printf(\"%d \",ans[i]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nbool possiblePrefix(vector<pair<int, int>> A, vector<int> prefix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n  for (int x : prefix) A[where[x]].first++;\n\n  sort(A.begin(), A.end());\n  if (A[0].first * 2 < A.back().first) return false;\n\n  vector<bool> isOne(K, false), isTwo(K, false);\n  int min = A[0].first, nTwos = 0;\n  for (int i = 0; i < K; ++i) {\n    if (min * 2 == A[i].first) {\n      isTwo[A[i].second] = true;\n      nTwos++;\n    }\n    if (min == A[i].first) isOne[A[i].second] = true;\n  }\n  reverse(prefix.begin(), prefix.end());\n  while (prefix.size() && !isOne[prefix.back()]) {\n    if (isTwo[prefix.back()]) nTwos--;\n    prefix.pop_back();\n  }\n  if (!nTwos) return true;\n  for (int x : prefix)\n    if (isOne[x]) return false;\n  return true;\n}\n\nbool possible(vector<pair<int, int>> A, const vector<int>& suffix) {\n  int K = A.size();\n  vector<int> where(K);\n  for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n  for (int i = 0; i < K; ++i) {\n    if (possiblePrefix(A, {})) return true;\n    int j = where[suffix[i]];\n    if (A[j].first == 0) break;\n    A[j].first--;\n  }\n  return false;\n}\n\nbool possibleFinish(vector<pair<int, int>> A, vector<int>& B, int coveredUpTo) {\n  int K = A.size();\n  vector<bool> seen(K, false);\n  vector<int> prefix;\n  if (B.size()) {\n    for (int32_t i = B.size() - 1; i >= 0; --i) {\n      if (seen[B[i]]) {\n        if (coveredUpTo <= i) return false;\n        break;\n      }\n      prefix.push_back(B[i]);\n      seen[B[i]] = true;\n    }\n  }\n  reverse(prefix.begin(), prefix.end());\n  if ((int)prefix.size() == K) return possible(A, prefix);\n  while (coveredUpTo + prefix.size() >= B.size()) {\n    if (possiblePrefix(A, prefix)) return true;\n    if (prefix.size()) {\n      prefix.erase(prefix.begin());\n    } else {\n      break;\n    }\n  }\n  return false;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int K;\n  cin >> K;\n  vector<pair<int, int>> A;\n  for (int i = 0; i < K; ++i) {\n    int x;\n    cin >> x;\n    A.emplace_back(x, i);\n  }\n\n  sort(A.begin(), A.end());\n  vector<int> B;\n\n  if (!possibleFinish(A, B, 0)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  int coveredUpTo = 0;\n  while (true) {\n    int tot = 0;\n    for (auto& p : A) tot += p.first;\n    if (tot == 0) break;\n\n    vector<int> where(K);\n    for (int i = 0; i < K; ++i) where[A[i].second] = i;\n\n    int x = -1;\n    for (int i = 0; i < K; ++i) {\n      if (A[where[i]].first == 0) continue;\n\n      A[where[i]].first--;\n      B.push_back(i);\n      if (possibleFinish(A, B, coveredUpTo)) {\n        x = i;\n        break;\n      }\n      B.pop_back();\n      A[where[i]].first++;\n    }\n    assert(x != -1);\n    if (B.size() >= K) {\n      vector<int> p(B.end() - K, B.end());\n      sort(p.begin(), p.end());\n      bool isPerm = true;\n      for (int i = 0; i < K; ++i) isPerm &= p[i] == i;\n      if (isPerm) {\n        assert(coveredUpTo + K >= B.size());\n        coveredUpTo = B.size();\n      }\n    }\n  }\n\n  assert(coveredUpTo == B.size());\n  for (int x : B) cout << x + 1 << ' ';\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>K;\n\tFOR(i,K) cin>>A[i];\n\t\n\tvector<int> V;\n\twhile(*max_element(A,A+K)) {\n\t\tx=*max_element(A,A+K);\n\t\ty=*min_element(A,A+K);\n\t\t\n\t\tif(x>2*y) return _P(\"-1\\n\");\n\t\t\n\t\tvector<pair<int,int>> C;\n\t\t\n\t\t\n\t\tif(x==2*y) {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tC.push_back({i,1});\n\t\t\t\t}\n\t\t\t\telse if(A[i]>y) {\n\t\t\t\t\tC.push_back({i,0});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile(C.size() && C.back().second==0) C.pop_back();\n\t\t\tint first[101]={};\n\t\t\tFORR(c,C) {\n\t\t\t\tfirst[c.first]=1;\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t\tFOR(i,K) if(first[i]==0) V.push_back(i), A[i]--;\n\t\t\tFORR(c,C) {\n\t\t\t\tV.push_back(c.first);\n\t\t\t\tA[c.first]--;\n\t\t\t}\n\t\t}\n\t\telse if(x==y) {\n\t\t\tFOR(i,K) V.push_back(i), A[i]--;\n\t\t}\n\t\telse {\n\t\t\tFOR(i,K) {\n\t\t\t\tif(A[i]==x) {\n\t\t\t\t\tV.push_back(i);\n\t\t\t\t\tA[i]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(j,K) V.push_back((i+j)%K), A[(i+j)%K]--;\n\t\t}\n\t}\n\t\n\tFORR(v,V) cout<<(v+1)<<\" \";\n\tcout<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,T y){\n\tif (y<x)\n\t\tx=y;\n}\n/*\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\n*/\nconst int N=1005;\nint k,n;\nint a[N],baka[N],b[N];\nint check_permutation(int L,int R){\n\tif (R>n||L<1||R-L+1!=k)\n\t\treturn 0;\n\tstatic int vis[N],Time=0;\n\tTime++;\n\tFor(i,L,R)\n\t\tif (vis[b[i]]==Time)\n\t\t\treturn 0;\n\t\telse\n\t\t\tvis[b[i]]=Time;\n\treturn 1;\n}\nint checkpos(int *pos){\n\tint mi=n,mx=-1;\n\tFor(i,1,k)\n\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\tif (mi*2+1<mx)\n\t\treturn 0;\n\tif (mi*2>=mx)\n\t\treturn 1;\n\t//mi * 2 + 1 == mx\n\tint mip=n+1,mxp=-1;\n\tFor(i,1,k)\n\t\tif (a[i]==mi)\n\t\t\tckmin(mip,pos[i]);\n\t\telse if (a[i]==mx)\n\t\t\tckmax(mxp,pos[i]);\n\treturn mxp<=mip;\n}\nint check(int p,int las){\n\tstatic int pos[N];\n\tFor(i,1,k)\n\t\tpos[i]=p+1;\n\tif (las==p)\n\t\treturn checkpos(pos);\n\tint cut=p;\n\t{\n\t\tvi vis(k+1,0);\n\t\tvis[b[cut]]=1;\n\t\twhile (cut-1>0&&!vis[b[cut-1]])\n\t\t\tcut--,vis[b[cut]]=1;\n\t}\n\tif (cut>las+1)\n\t\treturn 0;\n\tFor(i,cut,p)\n\t\tpos[b[i]]=i;\n\tFor(i,1,k)\n\t\tif (pos[i]==p+1)\n\t\t\ta[i]--;\n\tif (checkpos(pos))\n\t\treturn 1;\n\tFor(i,cut,las){\n\t\ta[b[i]]--;\n\t\tpos[b[i]]=p+1;\n\t\tif (checkpos(pos))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tk=read(),n=0;\n\tFor(i,1,k)\n\t\ta[i]=read(),n+=a[i];\n\t{\n\t\tint mi=n,mx=0;\n\t\tFor(i,1,k)\n\t\t\tckmin(mi,a[i]),ckmax(mx,a[i]);\n\t\tif (mi*2<mx)\n\t\t\treturn puts(\"-1\"),0;\n\t}\n\tmemset(b,-1,sizeof b);\n\tint las=0;\n\tFor(i,1,n){\n\t\tFor(j,1,k)\n\t\t\tif (a[j]){\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\tbaka[t]=a[t];\n\t\t\t\ta[j]--,b[i]=j;\n\t\t\t\tint nextlas=check_permutation(i-k+1,i)?i:las;\n\t\t\t\tif (check(i,nextlas)){\n\t\t\t\t\tlas=nextlas;\n\t\t\t\t\tFor(t,1,k)\n\t\t\t\t\t\ta[t]=baka[t];\n\t\t\t\t\ta[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb[i]=-1;\n\t\t\t\tFor(t,1,k)\n\t\t\t\t\ta[t]=baka[t];\n\t\t\t}\n\t}\n\tFor(i,1,n)\n\t\tprintf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops;\nUL P2[100];\nvector<UL> buf;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 1000; rep(i, K) loops = min(loops, P[i]);\n\trep(i, K) P2[i] = P[i] - loops;\n\trep(i, K) if (P2[i] > loops) { cout << -1 << endl; return 0; }\n\tvector<UL> ans;\n\trep(l, loops) {\n\t\tvector<UL> S, T;\n\t\tUL p = 0;\n\t\trep(i, K) {\n\t\t\tif (P2[i] == loops - l) {\n\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\telse T.push_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\tfor (; p < K; p++) {\n\t\t\tT.push_back(p);\n\t\t}\n\t\tconcat(ans, S);\n\t\tconcat(ans, T);\n\t\tconcat(ans, S);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 101;\nint n;\nvector<int> t;\nint dajmi(){\n  int mi = 1e9;\n  int ma = 0;\n  R(i,n){\n    mini(mi, t[i]);\n    maxi(ma, t[i]);\n  }\n  if(ma > mi * 2){\n    return MAX;\n  }\n  if(ma == mi * 2){\n    R(i,n){\n      if(t[i] == ma){\n        return i;\n      }\n    }\n  }\n  return 0;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  t.resize(n);\n  R(i,n)cin >> t[i];\n  if(dajmi() == MAX){\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> res;\n  vector<int> nie(n);\n  int ilnie = 0;\n  while(1){\n    int mi = 1e9;\n    int ma = 0;\n    R(i,n){\n      mini(mi, t[i]);\n      maxi(ma, t[i]);\n    }\n    debug(ilnie);\n    \n    vector<int> zle(n);\n    R(i,n){\n      if(t[i] * 2 < ma){\n        zle[i] = 1;\n      }\n    }\n    int naj = -1;\n    R(i,min(SZ(res),n)){\n      if(zle[res[SZ(res) - i - 1]]){\n        naj = i;\n        zle[res[SZ(res) - i - 1]] = 0;\n      }\n    }\n    R(i,naj + 1){\n      zle[res[SZ(res) - i - 1]] = 1;\n    }\n    \n    \n    if(ma == 0)break;\n    R(i,n)if(!nie[i] && t[i] * 2 > ma && t[i] && !zle[i]){\n      debug(ma,t[i],i);\n      res.PB(i);\n      t[i]--;\n      nie[i] = 1;\n      ilnie++;\n      goto ok;\n    }\n    debug(res);\n    assert(0);\n    ok:;\n    if(SZ(res) >= n){\n      vector<int> cz(n);\n      bool nope = 0;\n      R(i,n){\n        if(cz[res[SZ(res) - i - 1]]){\n          nope = 1;\n          break;\n        }\n        cz[res[SZ(res) - i - 1]] = 1;\n      }\n      if(!nope){\n        ilnie = 0;\n        R(i,n)nie[i] = 0;\n      }\n    }\n  }\n  for(int ak:res){\n    cout << ak + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 110;\nconst int maxs = 1010;\n\ntypedef pair<int,int> seg;\n\nseg operator+(const seg &s1, const seg &s2) {\n\treturn seg(max(s1.first, s2.first), min(s1.second, s2.second));\n}\n\nint n, sum, lastp;\nint ans[maxs], a[maxn], cur_a[maxn], vis[maxn], _vis[maxn], ok[maxn];\nseg pre[maxn], suf[maxn], s[maxn];\n\n//  -1\nseg calseg(int x, int ty) {\n\tif (!ty) {\n\t\treturn seg(x, 2 * x);\n\t} else {\n\t\treturn seg(x, 2 * x - 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\tfor (int i = 1; i <= sum; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tvis[j] = 0;\n\t\t\tcur_a[j] = a[j];\n\t\t\tok[j] = 0;\n\t\t}\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (i - j <= lastp + 1) {\n\t\t\t\tfor (int k = 1; k <= n; k++) s[k] = calseg(cur_a[k], vis[k]);\n\t\t\t\tpre[0] = suf[n+1] = seg(0, 0x3f3f3f3f);\n\t\t\t\tfor (int k = 1; k <= n; k++) pre[k] = pre[k-1] + s[k];\n\t\t\t\tfor (int k = n; k >= 1; k--) suf[k] = suf[k+1] + s[k];\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tseg t = pre[k-1] + suf[k+1] + calseg(cur_a[k], 1);\n\t\t\t\t\tif (!vis[k] && t.first <= t.second) {\n\t\t\t\t\t\tok[k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < i-1) {\n\t\t\t\tif (vis[ans[i - 1 - j]]) break;\n\t\t\t\tvis[ans[i - 1 - j]] = 1;\n\t\t\t\t++ cur_a[ans[i - 1 - j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tvis[j] = 0;\n\t\t\tcur_a[j] = a[j];\n\t\t}\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = 1; k <= n; k++) _vis[k] = 0;\n\t\t\tint t = i-j-1;\n\t\t\twhile (t > 0 && !vis[ans[t]] && !_vis[ans[t]]) {\n\t\t\t\t_vis[ans[t]] = 1;\n\t\t\t\t-- t;\n\t\t\t}\n\t\t\tfor (int k = 1; k <= n; k++) s[k] = calseg(cur_a[k], vis[k] || !_vis[k]);\n\t\t\tseg total = seg(0, 0x3f3f3f3f);\n\t\t\tfor (int k = 1; k <= n; k++) total = total + s[k];\n\t\t\tif (total.first <= total.second) {\n\t\t\t\tint mn = 0x3f3f3f3f;\n\t\t\t\tfor (int k = n; k >= 1; k--) if (!vis[k] && !_vis[k] && cur_a[k] * 2 - 1 >= total.first) mn = min(mn, k);\n\t\t\t\tfor (int x = t+1; x <= i-j-1; x++) {\n\t\t\t\t\tif (x > lastp+1) break;\n\t\t\t\t\tif (mn < 0x3f3f3f3f) ok[mn] = 1;\n\t\t\t\t\t_vis[ans[x]] = 0; if (2 * cur_a[ans[x]] - 1 < total.first) break;\n\t\t\t\t\tmn = min(mn, ans[x]);\n\t\t\t\t}\n\t\t\t} \n\t\t\tif (j < i-1) {\n\t\t\t\tif (vis[ans[i - 1 - j]]) break;\n\t\t\t\tvis[ans[i - 1 - j]] = 1;\n\t\t\t\t++ cur_a[ans[i - 1 - j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (ok[j]) {\n\t\t\t\tans[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t-- a[ans[i]];\n\t\tif (!ans[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) vis[j] = 0;\n\t\tif (i >= n) {\n\t\t\tint flag = 1;\n\t\t\tfor (int j = i; j >= i-n+1; j--) {\n\t\t\t\tif (vis[ans[j]]) {\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvis[ans[j]] = 1;\n\t\t\t}\n\t\t\tif (flag) lastp = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= sum; i++) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 1005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nint k;\nint a[maxn];\nint b[maxn];\nint tp[maxn];\nint s = 0;\nint x[maxn];\nint hv[105];\nint ltp[maxn];\nint check(int pl) {\n\tfor (int i = 1; i <= k; i++)\n\t\tb[i] = a[i];\n\tfor (int i = 1; i <= pl; i++) {\n\t\tb[x[i]]--;\n\t\tif (b[x[i]] < 0) return 0;\n\t}\n\tfor (int i = 1; i < pl; i++)\n\t\tif (x[i] == x[pl] && !tp[i]) return 0;\n/*\tcout << \"CUR_CHECK\" << endl;\n\tfor (int i = 1; i <= pl; i++)\n\t\tcout << x[i] << ' ';\n\tcout << endl;\n*/\t\n\t// update tp\n\tfor (int i = 1; i <= pl; i++)\n\t\tltp[i] = tp[i];\n\t// before return 0 : \n\tif (pl >= k) {\n\t\tmemset(hv, 0, sizeof(hv));\n\t\tint fl = 1;\n\t\tfor (int i = pl; i >= pl - k + 1; i--)\n\t\t\tif (hv[x[i]]) fl = 0;\n\t\t\telse hv[x[i]] = 1;\n\t\tif (fl)\n\t\t\tfor (int i = pl; i >= pl - k + 1; i--)\n\t\t\t\ttp[i] = 1;\n\t}\n\tmemset(hv, 0, sizeof(hv));\n\tfor (int i = pl; i >= 1; i--)\n\t\tif (hv[x[i]]) break;\n\t\telse hv[x[i]] = i;\n\tint nd[105] = {0};\n\tfor (int i = 1; i <= k; i++) {\n\t\tint cr = b[i];\n\t\tint ud[2] = {0, 0};\n\t\tfor (int t = 1; t <= k; t++)\n\t\t\tif (hv[t] > hv[i]) chkmax(nd[t], cr / 2);\n\t\t\telse chkmax(nd[t], (cr + 1) / 2);\n\t}\n\tint res = 1;\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (b[i] < nd[i]) res = 0;//, cout << \"!!!\" << i << ' ' << b[i] << ' ' << nd[i] << endl;\n\t}\n\tif (!res) {\n\t\tfor (int i = 1; i <= pl; i++)\n\t\t\ttp[i] = ltp[i];\n\t\treturn 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tcin >> k;\n\tfor (int i = 1; i <= k; i++)\n\t\tcin >> a[i], s += a[i];\n\tif (!check(0)) cout << -1 << endl;\n\telse {\n\t\tfor (int p = 1; p <= s; p++) {\n\t\t\tfor (int i = 1; i <= k; i++) {\n\t\t\t\tx[p] = i;\n\t\t\t\tif (!check(p)) continue;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tfor (int p = 1; p <= s; p++)\n\t\t\tcout << x[p] << ' ';\n\t\tcout << endl;\n\t}\n\t\t\t \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nint n, m;\nvi a;\n\nbool f(vi s) {\n  int w = sz(s);\n  vi c = a;\n  vi e(m);\n  int li = 0, pre = 0;\n  rep(i,w) {\n    c[s[i]]--;\n    e[s[i]]++;\n    if (e[s[i]] == 2) {\n      while (e[s[i]] > 1) {\n        e[s[li]]--;\n        ++li;\n      }\n    }\n    if (pre < li) return false;\n    if (i-li == m-1) pre = i+1;\n  }\n  rep(i,m) if (c[i] < 0) return false;\n  vi d(m);\n  srep(i,li,pre) d[s[i]]++;\n  // cerr<<c<<endl;\n  // cerr<<e<<endl;\n  // cerr<<d<<endl;\n\n  {\n    int l = INF, r = 0;\n    rep(i,m) {\n      int na = c[i];\n      if (!e[i]) --na;\n      maxs(r,na);\n      if (d[i]) ++na;\n      mins(l,na);\n    }\n    if (l*2 >= r) return true;\n  }\n\n  {\n    int l = INF, r = 0;\n    rep(i,m) {\n      int na = c[i];\n      na--;\n      int naa = na;\n      if (d[i]) ++naa;\n      mins(l,naa);\n      if (!e[i]) --na;\n      maxs(r,na);\n    }\n    if (l*2 >= r) return true;\n  }\n\n  // cerr<<\"a\"<<\" \"<<s<<endl;\n\n  return false;\n}\n\nint main() {\n  scanf(\"%d\",&m);\n  a = vi(m);\n  cin>>a;\n  n = suma(a);\n  vi ans;\n  if (!f(ans)) dame;\n  while (sz(ans) < n) {\n    ans.pb(0);\n    while (!f(ans)) ans.back()++;\n    // cerr<<ans<<endl;\n  }\n  rep(i,n) ans[i]++;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n        rep(k,best_js_size) {\n        }\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    bool flag2 = false;\n    int ans_size = ans.size();\n    if (ans_size >= K-1) {\n        set<int> s_next;\n        rep1(i,K) s_next.insert(i);\n        rep1(i,K-1) {\n            auto ite = s_next.find(ans[ans_size-i]);\n            if (ite != s_next.end()) {\n                s_next.erase(ans[ans_size-i]);\n            }\n        }\n        if (s_next.size() == 1) {\n            int best_next = *s_next.begin();\n            if (best_next < tempv[best_j][0]) {\n                bool flag3 = true;\n                rep(i,K) {\n                    if ((a[i] - 1) > (a[best_next-1] - 1) * 2) {\n                        flag3 = false;\n                    }\n                }\n                if (flag3) {\n                    ans.push_back(best_next);\n                    a[best_next]--;\n                    flag2 = true;\n                }\n            }\n        }\n    }\n\n    if (!flag2) {\n        int best_j_size = tempv[best_j].size();\n        rep(i,best_j_size) {\n            ans.push_back(tempv[best_j][i]);\n        }\n\n        rep(i,K) a[i] -= now[best_j][i];\n    }\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100,M=1000;\n\nint n,a[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n}\nint mx,mn;\n\nvoid Get_mxn(){\n  mx=0;mn=M;\n  for (int i=1;i<=n;++i) mx=max(mx,a[i]),mn=min(mn,a[i]);\n}\n\nint last[N+9],tmp[N+9];\nint ta[N+9],tb[N+9],tc[N+9],cta,ctb,ctc;\n\nbool Get_tmp(int m){\n  int flag=1;\n  for (int i=1;i<=m;++i) --a[last[i]],tmp[i]=0;\n  Get_mxn();\n  if (mn<<1>=mx){\n\tfor (int i=1;i<=m;++i) tmp[i]=last[i];\n\tsort(tmp+1,tmp+m+1);\n  }else if (mn*2+1==mx){\n\tint flagmn=0,flagmx=0;\n\tcta=ctb=ctc=0;\n\tfor (int i=m+1;i<=n;++i)\n\t  if (a[last[i]]==mn) flagmn=1;\n      else if (a[last[i]]==mx&&flagmn) flagmx=1;\n\tfor (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mx) ta[++cta]=last[i],flagmx=1;\n    sort(ta+1,ta+cta+1);\n    if (flagmn&&flagmx) flag=0;\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mn) tc[++ctc]=last[i];\n    sort(tc+1,tc+ctc+1);\n\tfor (int i=1;i<=ctc;++i) ta[++cta]=tc[i];\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]<mx&&a[last[i]]>mn) tb[++ctb]=last[i];\n    sort(tb+1,tb+ctb+1);\n    merge(ta+1,ta+cta+1,tb+1,tb+ctb+1,tmp+1);\n  }else flag=0;\n  for (int i=1;i<=m;++i) ++a[last[i]];\n  return flag;\n}\n\nint now[N+9],cn;\n\nbool Check_cmp(){\n  for (int i=1;2333;++i)\n\tif (tmp[i]^now[i]) return tmp[i]<now[i];\n}\n\nint ans[N*M+9],ca;\n\nvoid Get_ans(){\n  Get_mxn();\n  if (mn<<1<mx) return;\n  for (int i=1;i<=n;++i) ca+=a[i],last[i]=i;\n  Get_tmp(n);\n  for (int i=1;i<=n;++i) --a[ans[i]=last[i]=tmp[i]],tmp[i]=0;\n  for (int i=n+1;i<=ca;){\n\tfor (int j=1;j<=n;++j) now[j]=0;\n\tnow[1]=n+1;cn=0;\n\tfor (int j=1;j<=n;++j){\n\t  if (i+j-1>ca) continue;\n\t  if (!Get_tmp(j)) continue;\n\t  if (Check_cmp()){\n\t\tcn=j;\n\t\tfor (int k=1;k<=j;++k) now[k]=tmp[k];\n\t  }\n\t}\n\tfor (int j=1;j<=cn;++j) --a[ans[i++]=now[j]];\n    for (int j=1;j<=n;++j) last[j]=ans[i-n+j-1];\n  }\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  if (!ca) puts(\"-1\");\n  else{\n\tfor (int i=1;i<=ca;++i)\n\t  printf(\"%d \",ans[i]);\n    puts(\"\");\n  }\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, K = 105;\n\ntemplate <class T>\nvoid read(T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n = 0, k, a[K], b[N];\nbool tag[K], valid[N];\n// validity check\n// last denotes the largest index i such that i <= pre and valid[i] = false.\n// len denotes the largest length of suffix such that b[pre], b[pre - 1], ..., b[pre - len + 1] are distinct.\nbool pre_valid[N];\nbool solve1(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] - 1 <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] - 1 <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1))) break;\n\t\tif (i <= last && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve2(int pre, int last, int len, int num) {\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (!tag[i] && !(a[i] <= num && num <= (a[i] << 1) - 1)) return false;\n\t}\n\tpre_valid[pre - len] = true;\n\tfor (int i = pre - len + 1; i <= pre; i++) {\n\t\tpre_valid[i] = pre_valid[i - 1];\n\t\tif (!(a[b[i]] <= num && num <= (a[b[i]] << 1) - 1)) pre_valid[i] = false;\n\t}\n\tint pos1 = 0, pos2 = n + 1;\n\tfor (int i = pre; i > pre - len; i--) {\n\t\tif (a[b[i]] <= num && num <= (a[b[i]] << 1 | 1)) {\n\t\t\tif (num == a[b[i]]) {\n\t\t\t\tif (!pos1) pos1 = i; \n\t\t\t}\n\t\t\tif (num == (a[b[i]] << 1 | 1)) pos2 = i;\n\t\t} else break;\n\t\tif (i <= last && pos1 <= pos2 && pre_valid[i - 1]) return true;\n\t}\n\treturn false;\n}\nbool solve(int pre, int last, int len, int num) {\n\treturn solve1(pre, last, len, num) || solve2(pre, last, len, num);\n}\n\nbool check(int pre) {\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tint len = min(pre, k);\n\tfor (int i = pre; i && i > pre - k; i--) {\n\t\tif (tag[b[i]]) len = pre - i;\n\t\ttag[b[i]] = true;\n\t}\n\tint last = pre + 1;\n\tif (len < k) {\n\t\tfor (int i = pre; i && i > pre - k; i--) {\n\t\t\tif (!valid[i]) last = i;\n\t\t}\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= k; i++) mx = max(mx, a[i] - 1);\n\tfor (int i = 1; i <= k; i++) tag[i] = false;\n\tfor (int i = pre; i > pre - len; i--) tag[b[i]] = true;\n\treturn solve(pre, last, len, mx) || solve(pre, last, len, mx + 1);\n}\n\nint main() {\n\tread(k);\n\tfor (int i = 1; i <= k; i++) read(a[i]), n += a[i];\n\tbool flag = true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool chk = false;\n\t\tvalid[i] = false;\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tb[i] = j, a[j]--, valid[i] = false;\n\t\t\tif (check(i)) {\n\t\t\t\tchk = true;\n\t\t\t\tbreak;\n\t\t\t} else a[j]++;\n\t\t}\n\t\tbool k_distinct = i >= k;\n\t\tfor (int j = 1; j <= k; j++) tag[j] = false;\n\t\tfor (int j = i; j > i - k; j--) {\n\t\t\tif (tag[b[j]]) k_distinct = false;\n\t\t\ttag[b[j]] = true;\n\t\t}\n\t\tif (k_distinct) {\n\t\t\tfor (int j = i; j > i - k; j--) valid[j] = true;\n\t\t}\n\t\tif (!chk) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) write(b[i]), putchar(' ');\n\t\tputchar('\\n');\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        //bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            //if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n        }\n    }\n\n    vector<int> best_js(0);\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_js.push_back(i);\n    int best_js_size = best_js.size();\n    if (best_js_size > 1) {\n        rep(k,best_js_size) {\n        }\n    }\n    else {\n        best_j = best_js[0];\n    }\n\n    bool flag2 = false;\n    int ans_size = ans.size();\n    if (ans_size >= K-1) {\n        set<int> s_next;\n        rep1(i,K) s_next.insert(i);\n        rep1(i,K-1) {\n            auto ite = s_next.find(ans[ans_size-i]);\n            if (ite != s_next.end()) {\n                s_next.erase(ans[ans_size-i]);\n            }\n        }\n        if (s_next.size() == 1) {\n            int best_next = *s_next.begin();\n            if (best_next < tempv[best_j][0]) {\n                bool flag3 = true;\n                rep(i,K) {\n                    if (a[i] > (a[best_next-1] - 1) * 2) {\n                        flag3 = false;\n                    }\n                }\n                if (flag3) {\n                    ans.push_back(best_next);\n                    a[best_next]--;\n                    flag2 = true;\n                }\n            }\n        }\n    }\n\n    if (!flag2) {\n        int best_j_size = tempv[best_j].size();\n        rep(i,best_j_size) {\n            ans.push_back(tempv[best_j][i]);\n        }\n\n        rep(i,K) a[i] -= now[best_j][i];\n    }\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,i,j,cnt,lst,nxt,fi,a[1111],k[1111],st[1111];\nbool cmp(int i, int j) { return a[i]>a[j]; }\nint main() {\n  scanf(\"%d\",&n);\n  for (i=1; i<=n; i++) {\n    scanf(\"%d\",&a[i]);\n    k[i-1]=i;\n  }\n  sort(k,k+n,cmp);\n  cnt=a[k[n-1]];\n  if (a[k[0]]-cnt>cnt) { puts(\"-1\"); return 0; }\n  for (i=1; i<=n; i++) a[i]-=cnt;\n  for (j=cnt; j>=1; j--) {\n    lst=0;\n    for (i=1; i<=n; i++) if (a[i]==j) lst=i;\n    if (lst==0) {\n      if (j==1) {\n        for (i=1; i<=n; i++) printf(\"%d \",i);\n      } else {\n        nxt=0;\n        for (i=1; i<=n; i++) if (a[i]==j-1) nxt=i;\n        if (nxt) {\n          for (i=1; i<=nxt; i++) if (a[i]>1) { fi=i; break; }\n        } else fi=1;\n        for (i=1; i<=fi; i++) if (a[i]>0) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]<=0) printf(\"%d \",i);\n        for (; i<=n; i++) printf(\"%d \",i);\n        for (i=1; i<=fi; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n      }\n    } else {\n      for (i=1; i<=lst; i++) if (a[i]>0) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]<=0) printf(\"%d \",i);\n      for (; i<=n; i++) printf(\"%d \",i);\n      for (i=1; i<=lst; i++) if (a[i]>0) { printf(\"%d \",i); --a[i]; }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[109];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint k;cin>>k;\n\trepA(i,1,k) cin>>a[i];\n\tint x = 1009,y=0;\n\trepA(i,1,k) x = min(x,a[i]),y=max(y,a[i]);\n\tif(y>2*x){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tvi ans;\n\trep(qq,x){\n\t\tvi cur;\n\t\tbool fg[109];\n\t\tfill(fg);\n\t\tint gg = 1;\n\t\tif(a[1]==(x-qq)+1){\n\t\t\trepA(i,1,k) if(a[i]>=2*(x-qq)-1) {\n\t\t\t\tgg=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(a[1]==(x-qq)){\n\t\t\trepA(i,1,k) if(a[i]>=2*(x-qq)) {\n\t\t\t\tgg=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t\trepA(i,1,k){\n\t\t\tif(i<=gg&&a[i]>x-qq){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i]=1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t\telse if(a[i]==2*(x-qq)){\n\t\t\t\tcur.pb(i);\n\t\t\t\tans.pb(i);\n\t\t\t\tfg[i] = 1;\n\t\t\t\ta[i]-=2;\n\t\t\t}\n\t\t}\n\t\trepA(i,1,k) if(!fg[i]) a[i]--,ans.pb(i);\n\t\ttrav(i,cur) ans.pb(i);\n\t}\n\ttrav(i,ans) cout<<i<<' ';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint a[maxn], id[maxn], k;\nvector<int> res;\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nbool stvalid() {\n\treturn *min_element(a, a+k) * 2 >= *max_element(a, a+k);\n}\nbool p1valid(vector<int> v) {\n\tstatic int cnt[maxn], T, cp[maxn];\n\tcopy(a, a+k, cp);\n\t++T;\n\t//\n\tfor (int i : v) cnt[i] = T;\n\tvector<int> h;\n\n\tfor (int i = 0;i < k;++i)\n\t\tif (cnt[i] != T)\n\t\t\t--a[i], h.pb(i);\n\n\tsort(h.begin(), h.end(), cmp);\n\treverse(h.begin(), h.end());\n\n\tint mino = *min_element(a, a+k);\n\n\tbool stp = false;\n\tfor (int i : v)\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\n\tif (!stp) for (int i : h) {\n\t\tif (a[i] == mino) {\n\t\t\tstp = true;\n\t\t\tbreak;\n\t\t}\n\t\telse --a[i];\n\t}\n\tbool res = stvalid();\n\tcopy(cp, cp+k, a);\n\treturn res;\n}\nint mh() {\n\tfor (int i = 0;i < k;++i) {\n\t\t--a[i];\n\t\tif (p1valid({i})) return ++a[i], i;\n\t\t++a[i];\n\t}\n\treturn inf;\n\tsort(id, id+k, cmp);\n\tif (a[ id[0] ] * 2 > a[ id[k-1] ])\n\t\treturn 0;\n\tif (a[ id[0] ] == 0) return inf;\n\tint res = inf;\n\tfor (int i = 0;i < k;++i)\n\t\tif (a[i] != a[id[0]])\n\t\t\treturn i;\n\tassert(false);\n}\n\t\nbool solve() {\n\tiota(id, id+k, 0);\n\tif (!stvalid()) return false;\n\tint sum = accumulate(a, a+k, 0);\n\tfor (int i = 0;i < sum; i = res.size()) {\n\t\tint h = i;\n\t\tvector<bool> pt(k);\n//\t\tfor (int i : res)\n//\t\t\tcerr << i+1 << ' ';\n//\t\tcerr << '\\n';\n//\t\tcerr << \"I \" << i << '\\n';\n\t\twhile (i < sum && i-h < k) {\n\t\t\tfor (int v = 0;v < k;++v)\n\t\t\t\tif (!pt[v]) {\n\t\t\t\t\tres.pb(v);\n\t\t\t\t\t--a[v];\n\t\t\t\t\tif (!p1valid(vector<int>(res.begin()+h, res.end())))\n\t\t\t\t\t\tres.pop_back(), ++a[v];\n\t\t\t\t\telse {\n\t\t\t\t\t\tpt[v] = true;\n\t\t\t\t\t\t//cerr << \"V \" << v << '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\t//cerr << \"out\\n\";\n\t\tfor (int j = 0;j < k && res.size() < sum;++j) {\n\t\t\t//cerr << \"phase 2\\n\";\n\t\t\tint v = res[h+j];\n\t\t\tif (!stvalid()) {\n\t\t\t\tres.pb(v);\n\t\t\t\t--a[v];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mh() < v) break;\n\t\t\t--a[v];\n\t\t\tif (!stvalid()) {\n\t\t\t\t++a[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mh() == v) {\n\t\t\t\t--a[res[h+j+1]];\n\t\t\t\tbool pn = stvalid();\n\t\t\t\t++a[res[h+j+1]];\n\n\t\t\t\tint nxt = min(mh(), j==k-1 || !pn ? inf : res[h+j]), nh = inf;\n\t\t\t\tvector<int> tst{v};\n\t\t\t\tfor (int nv = 0;nv < k;++nv) if (nv != v) {\n\t\t\t\t\t--a[nv];\n\t\t\t\t\ttst.pb(nv);\n\t\t\t\t\tbool ok = p1valid(tst);\n\t\t\t\t\ttst.pop_back();\n\t\t\t\t\t++a[nv];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tnh = nv;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nh < nxt)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres.pb(v);\n\t\t}\n\t}\n\tfor (int i = 0;i < k;++i)\n\t\tassert(a[i] == 0);\n\treturn true;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> k;\n\tfor (int i = 0;i < k;++i)\n\t\tcin >> a[i];\n\tif (!solve())\n\t\treturn puts(\"-1\"), 0;\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\ntypedef int64_t Int;\ntypedef pair<int,int> P;\n\nint main(){\n    int K;\n    cin >> K;\n    vector<int> a(K);\n    int all = 0;\n    rep(i,K) {\n        cin >> a[i];\n        all += a[i];\n    }\n\n    vector<int> ans(0);\n\n    rep(i,K) rep(j,K) {\n        if (a[i] > a[j] * 2) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    \n\n    while(true) {\n    vector<P> av(K);\n    rep(i,K) {\n        av[i] = make_pair(a[i],K-i);\n    }\n    sort(av.begin(),av.end());\n    reverse(av.begin(),av.end());\n    rep(i,K) {\n        av[i] = make_pair(av[i].first,K-av[i].second);\n    }\n    vector<vector<int>> tempv(K, vector<int>(0));\n    vector<bool> flag(K,true);\n    vector<vector<int>> now(K, vector<int>(K,0));\n    rep(j,K-1) {\n        rep(i,K) {\n            if (i <= j) now[j][av[i].second] = 2;\n            else now[j][av[i].second] = 1;\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 1) tempv[j].push_back(i+1);\n        }\n        rep(i,K) {\n            if (now[j][i] == 2) tempv[j].push_back(i+1);\n        }\n        rep(i,K) rep(k,K) {\n            if ((a[i] < now[j][i]) || (a[k] < now[j][k]) || (a[i] - now[j][i]) > (a[k] - now[j][k]) * 2) {\n                flag[j] = false;\n            }\n        }\n    }\n    rep(i,K) rep(j,K) {\n        if ((a[i] < 1) || (a[j] < 1) || (a[i] - 1) > (a[j] - 1) * 2) {\n            flag[K-1] = false;\n        }\n    }\n    rep(i,K) {\n        tempv[K-1].push_back(i+1);\n        now[K-1][i] = 1;\n    }\n\n    rep(i,K-1) for(int j = i+1; j<K; j++) {\n        if ((!flag[i]) || (!flag[j])) continue;\n        int li = tempv[i].size();\n        int lj = tempv[j].size();\n        bool flag1 = true;\n        rep(k,min(li,lj)) {\n            if (tempv[i][k] < tempv[j][k]) {\n                flag[j] = false;\n                break;\n            }\n            if (tempv[i][k] == tempv[j][k] && tempv[i][k] != k+1) flag1 = false;\n        }\n        if (flag[i] && flag[j]) {\n            if (j == K-1) {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n            else if (flag1) {\n                if (li < lj) flag[j] = false;\n                else flag[i] = false;\n            }\n            else {\n                if (li < lj) flag[i] = false;\n                else flag[j] = false;\n            }\n\n        }\n    }\n\n    int best_j = 0;\n    rep(i,K) if (flag[i]) best_j = i;\n    int best_j_size = tempv[best_j].size();\n    rep(i,best_j_size) {\n        ans.push_back(tempv[best_j][i]);\n    }\n\n    rep(i,K) a[i] -= now[best_j][i];\n\n    /*rep(i,K) {\n        cout << a[i] << endl;\n    }*/\n\n    bool out_from_roop = false;\n    rep(i,K) if (a[i] == 0) {\n        out_from_roop = true;\n        break;\n    }\n    if (out_from_roop) break;\n    }\n\n    rep(i,all-1) cout << ans[i] << \" \";\n    cout << ans[all-1] << endl;\n\n    /*vector<int> determined(K, 0);\n    rep(i,K) rep(j,K) {\n        if (a[i] == a[j] * 2) {\n            determined[i] = 2;\n            determined[j] = 1;\n        }\n    }*/\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint K;\n\tcin>>K;\n\tvector<int> V(K);\n\tfor(auto &a: V)\n\t\tcin>>a;\n\tint N = 0;\n\tfor(auto a: V)\n\t\tN+=a;\n\tvector<int> A;\n\twhile(A.size()<N)\n\t{\n\t\t\n\t\tint m1 = N;\n\t\tint m2 = 0;\n\t\tfor(auto a: V)\n\t\t{\n\t\t\tm1 = min(m1,a);\n\t\t\tm2 = max(m2,a);\n\t\t}\n\t\tif(m1*2<m2)\n\t\t{\n\t\t\tV.resize(1);\n\t\t\tV[0]=-2;\n\t\t\tbreak;\n\t\t}\n\t\t//cerr<<m1<<\" \"<<m2<<endl;\n\t\tvector<int> side, center, opt;\n\t\tif(m2 == m1*2)\n\t\t{\n\t\t\tfor(int i=0; i<K; ++i)\n\t\t\t{\n\t\t\t\tif(m2 == V[i])\n\t\t\t\t\tside.push_back(i);\n\t\t\t\telse if(m1 == V[i])\n\t\t\t\t\tcenter.push_back(i);\n\t\t\t\telse\n\t\t\t\t\topt.push_back(i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=0; i<K; ++i)\n\t\t\t\topt.push_back(i);\n\t\t}\n\t\tsort(center.begin(),center.end());\n\t\tsort(opt.begin(),opt.end());\n\t\tsort(side.begin(),side.end());\n\t\tint s1 = 0, o1 = 0, c1 = 0;\n\t\twhile(s1<side.size())\n\t\t{\n\t\t\tif(o1<opt.size() && opt[o1]<side[s1])\n\t\t\t{\n\t\t\t\tA.push_back(opt[o1]);\n\t\t\t\t--V[opt[o1++]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA.push_back(side[s1]);\n\t\t\t\t--V[side[s1++]];\n\t\t\t}\n\t\t}\n\t\twhile(c1<center.size())\n\t\t{\n\t\t\tif(o1<opt.size() && opt[o1]<center[c1])\n\t\t\t{\n\t\t\t\tA.push_back(opt[o1]);\n\t\t\t\t--V[opt[o1++]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA.push_back(center[c1]);\n\t\t\t\t--V[center[c1++]];\n\t\t\t}\n\t\t}\n\t\twhile(o1<opt.size())\n\t\t{\n\t\t\tA.push_back(opt[o1]);\n\t\t\t--V[opt[o1++]];\n\t\t}\n\t\to1 = 0;\n\t\ts1 = 0;\n\t\twhile(s1<side.size())\n\t\t{\n\t\t\tif(o1<opt.size() && (center.size()==0 || opt[o1]<center[0]) && opt[o1]<side[s1])\n\t\t\t{\n\t\t\t\tA.push_back(opt[o1]);\n\t\t\t\t--V[opt[o1++]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tA.push_back(side[s1]);\n\t\t\t\t--V[side[s1++]];\n\t\t\t}\n\t\t}\n\t\t\n\n\n\n\t}\n\tfor(auto a: A)\n\t\tcout<<a+1<<\" \";\n\tcout<<endl;\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << (x) << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f1, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f1 = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f1 = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f1;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 1e3 + 7;\nint n, m, s, a[N], p[N], q[N], ans[N];\n\nvoid work(int k) {\n\tbool ok1 = 1, ok2 = 0;\n\tfor (int i = 1; i <= k; i++) --a[p[i]];\n\tint mn = *min_element(a + 1, a + n + 1);\n\tint mx = *max_element(a + 1, a + n + 1);\n\tif (mn * 2 >= mx) {\n\t\tok2 = 1;\n\t\tcopy(p + 1, p + k + 1, q + 1);\n\t\tsort(q + 1, q + k + 1);\n\t} else if (mn * 2 + 1 == mx) {\n\t\tint k1 = 0, k2 = 0;\n\t\tstatic int f1[N], f2[N];\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\t((a[p[i]] == mn || a[p[i]] == mx) ? f1[++k1] : f2[++k2]) = p[i];\n\t\tsort(f1 + 1, f1 + k1 + 1, [&](int i, int j) {\n\t\t\tif ((a[i] == mn) == (a[j] == mn)) return i < j;\n\t\t\treturn (a[i] == mn) < (a[j] == mn);\n\t\t});\n\t\tsort(f2 + 1, f2 + k2 + 1);\n\t\tint x1 = 1, x2 = 1;\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tif (x1 <= k1 && x2 <= k2)\n\t\t\t\tq[i] = f1[x1] < f2[x2] ? f1[x1++] : f2[x2++];\n\t\t\telse q[i] = x1 <= k1 ? f1[x1++] : f2[x2++];\n\t\tok2 = 1;\n\t\tfor (int i = k + 1; i <= n; i++)\n\t\t\tif (a[p[i]] == mn) ok2 = 0;\n\t\tok2 |= !x1 || (a[f1[1]] == mx);\n\t}\n\tfor (int i = 1; i <= k; i++) ++a[p[i]];\n\tif (!ok1 || !ok2) q[1] = 0;\n}\n\ninline bool pd(int *a, int *b) {\n\tint p = 1;\n\twhile (a[p] == b[p]) ++p;\n\treturn a[p] < b[p];\n}\n\nint main() {\n\trd(n), rda(a, n);\n\tfor (int i = 1; i <= n; i++) s += a[i];\n\tint mn = *min_element(a + 1, a + n + 1);\n\tint mx = *max_element(a + 1, a + n + 1);\n\tif (mn * 2 < mx) return print(-1), 0;\n\tiota(p + 1, p + n + 1, 1), work(n);\n\tfor (int i = 1; i <= n; i++) --a[q[i]], ans[++m] = p[i] = q[i];\n\twhile (m != s) {\n\t\tstatic int t[N];\n\t\tmemset(t, 0, sizeof(t)), t[1] = n + 1;\n\t\tint k = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\twork(i);\n\t\t\tif (q[1] && pd(q, t))\n\t\t\t\tk = i, copy(q + 1, q + i + 1, t + 1);\n\t\t}\n\t\tfor (int i = 1; i + k <= n; i++) p[i] = p[i+k];\n\t\tfor (int i = 1; i <= k; i++)\n\t\t\tans[++m] = p[n-k+i] = t[i], --a[t[i]];\n\t}\n\tprinta(ans, m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt n;\nvector<Int> a;\nvector<Int> ans;\nInt mx, mn;\nset<int> maxs, mins;\nbool ok[1100];\n\nInt min_initial(Int from, Int to)\n{\n    auto aa = a;\n    vector<int> used(n, 0);\n    for (int i = from; i < to; i++) {\n        if (used[ans[i]])\n            return n;\n        used[ans[i]] = 1;\n        aa[ans[i]]++;\n    }\n\n    Int tmpmx = *max_element(aa.begin(), aa.end());\n    Int tmpmn = *min_element(aa.begin(), aa.end());\n    if (tmpmn * 2 < tmpmx)\n        return n;\n    if (tmpmn * 2 > tmpmx) {\n        for (int i = 0; i < n; i++)\n            if (!used[i])\n                return i;\n        return n;\n    }\n    Int max_cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == tmpmx)\n            max_cnt++;\n    }\n\n    for (int i = from; i < to; i++) {\n        if (aa[ans[i]] == tmpmx)\n            max_cnt--;\n        if (aa[ans[i]] == tmpmn) {\n            if (max_cnt != 0)\n                return n;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (aa[i] == 0)\n            continue;\n        if (used[i])\n            continue;\n        if (max_cnt == 0 && !used[i])\n            return i;\n        if (max_cnt > 0 && aa[i] != tmpmn && !used[i])\n            return i;\n    }\n    return ans[from];\n}\n\nint main()\n{\n    Int as = 0;\n    cin >> n;\n    a.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        as += a[i];\n    }\n\n    Int mx = *max_element(a.begin(), a.end());\n    Int mn = *max_element(a.begin(), a.end());\n\n    if (mn * 2 < mx) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < as; i++) {\n        Int nxt = n;\n        for (int j = max(0ll, i - n + 1); j <= i; j++) {\n            nxt = min(nxt, min_initial(j, i));\n            if (!ok[j])\n                break;\n        }\n\n        a[nxt]--;\n        ans.push_back(nxt);\n        if (ans.size() >= n) {\n            set<int> hoge;\n            for (int j = 0; j < n; j++) {\n                hoge.insert(ans[ans.size() - 1 - j]);\n            }\n            if (hoge.size() == n) {\n                for (int j = 0; j < n; j++)\n                    ok[ans.size() - 1 - j] = true;\n            }\n        }\n    }\n\n    for (auto elem : ans)\n        cout << elem + 1 << \" \";\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nUL K;\nUL P[100];\nUL loops, loopsm;\nUL P2[100];\nvector<UL> buf;\nvector<vector<UL>> ans;\n\nvoid concat(vector<UL> & tg, vector<UL> & src) {\n\tfor (UL t : src) tg.push_back(t);\n}\n\nint main() {\n\tcin >> K;\n\trep(i, K) cin >> P[i];\n\tloops = 0; rep(i, K) loops = max(loops, P[i]);\n\tloops = (loops + 1) / 2;\n\tloopsm = 1000; rep(i, K) loopsm = min(loopsm, P[i]);\n\n\tfor (UL L = loops; L <= loopsm; L++) {\n\t\trep(i, K) P2[i] = P[i] - L;\n\t\trep(i, K) if (P2[i] > L) { cout << -1 << endl; return 0; }\n\t\tvector<UL> ans;\n\t\trep(l, L) {\n\t\t\tvector<UL> S, T;\n\t\t\tUL p = 0;\n\t\t\trep(i, K) {\n\t\t\t\tif (P2[i] == L - l) {\n\t\t\t\t\tfor (; p <= i; p++) {\n\t\t\t\t\t\tif (P2[p]) { S.push_back(p); P2[p]--; }\n\t\t\t\t\t\telse T.push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.size() == 0) if (P2[0]) { S.push_back(0); P2[0]--; p = 1; }\n\t\t\tfor (; p < K; p++) {\n\t\t\t\tT.push_back(p);\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\tsort(T.begin(), T.end());\n\t\t\tconcat(ans, S);\n\t\t\tconcat(ans, T);\n\t\t\tconcat(ans, S);\n\t\t}\n\t\t::ans.push_back(ans);\n\t}\n\tsort(ans.begin(), ans.end());\n\trep(i, ans[0].size()) {\n\t\tif (i) cout << \" \";\n\t\tcout << ans[0][i] + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    int k;\n    cin >> k;\n    vector<int> a(k + 1);\n    int amin = 1000;\n    int amax = 0;\n    for (int i = 1; i <= k; ++i) {\n        cin >> a[i];\n        amin = min(a[i], amin);\n        amax = max(a[i], amax);\n    }\n    if (amax > 2 * amin) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    \n    vector<set<int>> vs(amin);\n    for (int i = 1; i <= k; ++i) {\n        a[i] -= amin;\n    }\n    int cl = 0, cr = a[1] - 1;\n    while(a[1] > 0) {\n        --a[1];\n        vs[a[1]].insert(1);\n    }\n    \n    int lmi = 2;\n    int imax = -1;\n    while (imax != -2) {\n        if (imax == -1) {\n            imax = -2;\n            amax = -1;\n            for (int i = lmi; i <= k; ++i) {\n                if (a[i] >= amax) {\n                    imax = i;\n                    amax = a[i];\n                }\n            }\n        } else {\n            cl = amin - a[imax];\n            for (int i = imax; i >= lmi; --i) {\n                for (int ind = cl; ind < amin && a[i] > 0; ++ind) {\n                    if (vs[ind].count(i) == 0) {\n                        --a[i];\n                        vs[ind].insert(i);\n                    }\n                }\n                while (a[i] > 0) {\n                    --cl;\n                    if (vs[cl].count(i) == 0) {\n                        vs[cl].insert(i);\n                    }\n                }\n            }\n            lmi = imax + 1;\n            imax = -1;\n        }\n    }\n    \n    for (int q = 0; q < amin; ++q) {\n        set<int> inv;\n        for (int i = 1; i <= k; ++i) {\n            inv.insert(i);\n        }\n        for (int i : vs[q]) {\n            inv.erase(i);\n            cout << i << \" \";\n        }\n        for (int i : inv) {\n            cout << i << \" \";\n        }\n        for (int i : vs[q]) {\n            cout << i << \" \";\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int K = 110, N = 1010;\n\nint a[K],n,k;\nint ret[N], curlen;\n\ninline bool check(){\n\tint mn=a[1], mx=a[1];\n\tfor(int i=1;i<=k;i++)mx=max(mx,a[i]), mn=min(mn,a[i]);\n//\tcerr << mn << \" \" << mx << \"???\" << endl;\n\treturn mn*2>=mx;\n}\nint vis[K];\n\ninline void merge(int *x,int *y,int *z,int len1,int len2){\n\tint i=1,j=1;\n\tint l=0;\n\twhile(i<=len1&&j<=len2){\n\t\tif(x[i]<y[j])z[++l]=x[i++];\n\t\telse z[++l]=y[j++];\n\t}\n\twhile(i<=len1)z[++l]=x[i++];\n\twhile(j<=len2)z[++l]=y[j++];\n}\n\nint b[K], x[K], y[K], z[K], l1, l2, l3;\n\nvector<int> solve_ext(int len){\n\tl1=l2=l3=0;\n\tfor(int i=1;i<=k;i++)vis[i]=0,b[i]=a[i];\n\tfor(int i=0;i<k-len;i++){\n\t\tvis[ret[curlen-i]]=curlen-i;\n\t}\n\tfor(int i=1;i<=k;i++){if(!vis[i])b[i]--;if(b[i]<0)return vector<int>(1,k+1);}\n\tint mn,mx;mn=mx=b[1];\n\tfor(int i=1;i<=k;i++){\n\t\tmn=min(mn, b[i]);\n\t\tmx=max(mx, b[i]);\n\t}\n\tif(mn*2>=mx){\n\t\tvector<int> ret;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i])ret.push_back(i);\n\t\treturn ret;\t\n\t}\n\telse if(mn*2+1==mx){\n\t\tvector<int> res;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mx)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]==mn)x[++l1]=i;\n\t\tfor(int i=1;i<=k;i++)if(!vis[i] && b[i]!=mx && b[i]!=mn)y[++l2]=i;\n\t\tmerge(x,y,z,l1,l2);l3=l1+l2;\n\t\tres=vector<int>(z+1,z+l3+1);\n\t\tint p1=0,p2=0;\n\t\tfor(int i=curlen-(k-len-1);i<=curlen;i++){\n//\t\t\tif(len==29)cerr << ret[curlen] << \":\" << k-len-1 << \" \" << i << \":\" << ret[i] << endl;\n\t\t\tif(b[ret[i]]==mx)p1=i;\n\t\t\tif(b[ret[i]]==mn&&!p2)p2=i;\n\t\t}\n\t\tfor(int i=1;i<=l3;i++){\n\t\t\tif(b[z[i]]==mx)p1=i+curlen;\n\t\t\tif(b[z[i]]==mn&&!p2)p2=i+curlen;\n\t\t}\n\t\tif(p1<p2)return res;\n\t\telse return vector<int>(1,k+1);\n\t}else\n\t\treturn vector<int>(1,k+1);\n}\n\nbool cmp(vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<a.size();i++){\n\t\tif(i>=b.size())return 1;\n\t\tif(a[i]>b[i])return 1;\n\t\tif(a[i]<b[i])return 0;\n\t}\n\treturn 0;\n}\n\ninline void extend(){\n\tvector<int> ext(1,k+1);\n//\tcerr << ret[curlen] << \"!!!\" ;\n\tfor(int extlen=1;extlen<=k&&curlen+extlen<=n;extlen++){\n\t\tint d=k-extlen;\n\t\tif(curlen-d+1>=1){\n//\t\t\tif(extlen==29)cerr << ret[curlen] << \"!\" << endl;\n\t\t\tvector<int> nw=solve_ext(extlen);\n//\t\t\tif(extlen==29){cerr << extlen << \"::\";for(size_t i=0;i<nw.size();i++)cerr << nw[i] << \" \";cerr << endl;}\n\t\t\tif(cmp(ext,nw))ext=nw;\n\t\t}\n\t}\n\tfor(size_t i=0;i<ext.size();i++){\n\t\tprintf(\"%d \",ext[i]);\n\t\tret[++curlen]=ext[i];\n\t\ta[ext[i]]--;\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tcin >> k;\n\tfor(int i=1;i<=k;++i)scanf(\"%d\",&a[i]),n+=a[i];\n\tif(!check()){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\twhile(curlen<n){\n\t\textend();\n\t}puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1010, inf = maxn;\nint cnt[maxn], n;\nvector<int> res;\nvector<int> operator + (vector<int> a, vector<int> b) {\n\ta.insert(a.end(), b.begin(), b.end());\n\treturn a;\n}\nbool stvalid() { return *min_element(cnt, cnt+n) * 2 >= *max_element(cnt, cnt+n); }\nvector<int> minimize(vector<int> a) {\n\tstatic int backup[maxn];\n\tcopy(cnt, cnt+n, backup);\n\tvector<bool> vis(n);\n\tfor (int i : a) if (vis[i])\n\t\treturn vector<int>{inf};\n\telse vis[i] = true;\n\tint m = a.size();\n\n\tvector<int> b;\n\tfor (int i = 0;i < n;++i)\n\t\tif (!vis[i]) b.pb(i), a.pb(i), --cnt[i];\n\n\tassert(a.size() == n);\n\tint mx = *max_element(cnt, cnt+n), mn = *min_element(cnt, cnt+n);\n\n\tif (mn * 2 >= mx) {\n\t\tcopy(backup, backup+n, cnt);\n\t\tsort(b.begin(), b.end());\n\t\treturn b;\n\t}\n\tif (mn < 0) {\n\t\tcopy(backup, backup+n, cnt);\n\t\treturn vector<int> {inf};\n\t}\n\n\tif (mn * 2 + 1 == mx) {\n\t\t//cerr << \"in \\n\";\n\t\tint fstmin = inf, lstmax = -inf;\n\t\tfor (int i = 0;i < n && fstmin == inf;++i)\n\t\t\tif (cnt[i] == mn) fstmin = i;\n\t\tfor (int i = n-1;i >= 0 && lstmax == inf;++i)\n\t\t\tif (cnt[i] == mx) lstmax = i;\n\t\tif (fstmin < m && lstmax > fstmin) {\n\t\t\tcopy(backup, backup+n, cnt);\n\t\t\treturn vector<int>{inf};\n\t\t}\n\t\t//cerr << \"AA\";\n\t\tvector<int> c, d, e, res;\n\t\tfor (int i : b) if (cnt[i] == mx)\n\t\t\tc.pb(i);\n\t\telse if (cnt[i] == mn)\n\t\t\td.pb(i);\n\t\telse\n\t\t\te.pb(i);\n\t\t\t\t\n\t\tcopy(backup, backup+n, cnt);\n\t\tsort(c.begin(), c.end(), greater<>());\n\t\tsort(d.begin(), d.end(), greater<>());\n\t\tsort(e.begin(), e.end(), greater<>());\n\n#define GB(v) (v.size()?v.back():inf)\n\t\twhile (c.size()+d.size()+e.size()) {\n\t\t\tif (c.size()) {\n\t\t\t\tint x = c.back(), y = GB(e);\n\t\t\t\tif (x < y) {\n\t\t\t\t\tres.pb(x);\n\t\t\t\t\tc.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres.pb(y);\n\t\t\t\t\te.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x = GB(d), y = GB(e);\n\t\t\t\tif (x < y) {\n\t\t\t\t\tres.pb(x);\n\t\t\t\t\td.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres.pb(y);\n\t\t\t\t\te.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tcopy(backup, backup+n, cnt);\n\tassert(mn * 2 < mx);\n\treturn vector<int>{ inf };\n}\nvoid solve() {\n\tint sum = accumulate(cnt, cnt+n, 0);\n\tif (!stvalid())\n\t\tputs(\"-1\"), exit(0);\n\tres = minimize(vector<int>());\n\tfor (int i : res)\n\t\t--cnt[i];\n\twhile (res.size() < sum) {\n//\tfor (int i : res)\n//\t\tcout << i+1 << ' ';\n//\tcout << '\\n';\n\t\tvector<int> ad = minimize(vector<int>());\n\t\tfor (int i = 1;i < n;++i)\n\t\t\tad = min(ad, minimize(vector<int>(res.end()-i, res.end())));\n\t\tassert(ad != vector<int>{inf});\n\t\tres.insert(res.end(), ad.begin(), ad.end());\n\t\tfor (int i : ad) --cnt[i];\n\t}\n}\n\n\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0;i < n;++i)\n\t\tcin >> cnt[i];\n\tsolve();\n\tfor (int i : res)\n\t\tcout << i+1 << ' ';\n\tcout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\nint main() {\n\tint K;\n\tscanf(\"%d\", &K);\n\tint a[K];\n\tfor (int i = 0; i < K; ++i) scanf(\"%d\", &a[i]);\n\tint mn = *min_element(a, a + K), mx = *max_element(a, a + K);\n\tif (mx <= 2 * mn) {\n      assert(false);\n\t\tvector<int> yay[mn];\n\t\tint ptr = 0, sfx[K];\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\ta[i] -= mn;\n\t\t\tsfx[i] = mn - a[i];\n\t\t}\n\t\tfor (int i = K - 2; i >= 0; --i) sfx[i] = min(sfx[i], sfx[i + 1]);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tif (ptr >= sfx[i]) {\n\t\t\t\tptr = sfx[i];\n\t\t\t\tfor (int j = i; j < K; ++j) {\n\t\t\t\t\tif (ptr < sfx[j]) ptr = sfx[j];\n\t\t\t\t\tfor (int k = ptr; k < ptr + a[j]; ++k) yay[k].push_back(j);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor (int j = ptr; j < ptr + a[i]; ++j) yay[j].push_back(i);\n\t\t\t\tptr = ptr + max(0, a[i] - 1);\n\t\t\t\tif (i > 0 && a[i] == 0 && a[i - 1] != 0) ++ptr;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < mn; ++i) {\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tvector<int>::iterator it = lower_bound(yay[i].begin(), yay[i].end(), j);\n\t\t\t\tif (it == yay[i].end() || *it != j) printf(\"%d \", j + 1);\n\t\t\t}\n\t\t\tfor (int j: yay[i]) printf(\"%d \", j + 1);\n\t\t}\n\t} else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100,M=1000;\n\nint n,a[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d\",&a[i]);\n}\nint mx,mn;\n\nvoid Get_mxn(){\n  mx=0;mn=M;\n  for (int i=1;i<=n;++i) mx=max(mx,a[i]),mn=min(mn,a[i]);\n}\n\nint last[N+9],tmp[N+9];\nint ta[N+9],tb[N+9],tc[N+9],cta,ctb,ctc;\n\nbool Get_tmp(int m){\n  int flag=1;\n  for (int i=1;i<=m;++i) --a[last[i]],tmp[i]=0;\n  Get_mxn();\n  if (mn<<1>=mx){\n\tfor (int i=1;i<=m;++i) tmp[i]=last[i];\n\tsort(tmp+1,tmp+m+1);\n  }else if (mn*2+1==mx){\n\tint flagmn=0,flagmx=0;\n\tcta=ctb=ctc=0;\n\tfor (int i=m+1;i<=n;++i)\n\t  if (a[last[i]]==mn) flagmn=1;\n      else if (a[last[i]]==mx&&flagmn) flagmx=1;\n\tfor (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mx) ta[++cta]=last[i],flagmx=1;\n    sort(ta+1,ta+cta+1);\n    if (flagmn&&flagmx) flag=0;\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]==mn) tc[++ctc]=last[i];\n    sort(tc+1,tc+ctc+1);\n\tfor (int i=1;i<=ctc;++i) ta[++cta]=tc[i];\n    for (int i=1;i<=m;++i)\n\t  if (a[last[i]]<mx&&a[last[i]]>mn) tb[++ctb]=last[i];\n    merge(ta+1,ta+cta+1,tb+1,tb+ctb+1,tmp+1);\n  }else flag=0;\n  for (int i=1;i<=m;++i) ++a[last[i]];\n  return flag;\n}\n\nint now[N+9],cn;\n\nbool Check_cmp(){\n  for (int i=1;2333;++i)\n\tif (tmp[i]^now[i]) return tmp[i]<now[i];\n}\n\nint ans[N*M+9],ca;\n\nvoid Get_ans(){\n  Get_mxn();\n  if (mn<<1<mx) return;\n  for (int i=1;i<=n;++i) ca+=a[i],last[i]=i;\n  Get_tmp(n);\n  for (int i=1;i<=n;++i) --a[ans[i]=last[i]=tmp[i]],tmp[i]=0;\n  for (int i=n+1;i<=ca;){\n\tfor (int j=1;j<=n;++j) now[j]=0;\n\tnow[1]=n+1;cn=0;\n\tfor (int j=1;j<=n;++j){\n\t  if (i+j-1>ca) continue;\n\t  if (!Get_tmp(j)) continue;\n\t  if (Check_cmp()){\n\t\tcn=j;\n\t\tfor (int k=1;k<=j;++k) now[k]=tmp[k];\n\t  }\n\t}\n\tfor (int j=1;j<=cn;++j) --a[ans[i++]=now[j]];\n    for (int j=1;j<=n;++j) last[j]=ans[i-n+j-1];\n  }\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  if (!ca) puts(\"-1\");\n  else{\n\tfor (int i=1;i<=ca;++i)\n\t  printf(\"%d \",ans[i]);\n    puts(\"\");\n  }\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: AnandRaj doubleux\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<pll> vpll; \n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define test() int t;cin>>t;while(t--)\n#define all(v) v.begin(),v.end()\n#define prin(V) for(auto v:V) cout<<v<<\" \";cout<<endl\n#define take(V,f,n) for(int in=f;in<f+n;in++) cin>>V[in]\n#define what(x) cerr<<#x<<\" = \"<<x<<endl\n#define KStest() int t,t1;cin>>t;t1=t;while(t--)\n#define KScout cout<<\"Case #\"<<t1-t<<\": \"\n\nconst int MOD = 998244353,MAX = 1e6+5;\n/////////////////FastExp///////////////////\nll powN(ll a,ll p)\n{\n\tif(p==0) return 1;\n\tll z=powN(a,p/2);\n\tz=(z*z)%MOD;\n\tif(p%2) z=(z*a)%MOD;\n\treturn z;\n}\n/////////////////FastExp///////////////////\n//////////////////Sieve////////////////////\nvector<bool> is_prime(MAX, true);\nvector<int> MinDiv(MAX);\nvoid Sieve()\n{\n\tis_prime[0] = is_prime[1] = false;\n\tint i,j;\n\tfor (i = 2; i*i <= MAX; i++) \n\t{\n    \tif (is_prime[i]) \n    \t{\n    \t\tMinDiv[i]=i;\n        \tfor (j = i * i; j <= MAX; j += i)\n            {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tMinDiv[j]=i;\n    \t\t}\n    \t}\n\t}\n\tfor(int i=2;i<=MAX;i++) if(is_prime[i]) MinDiv[i]=i;\n}\n//////////////////Sieve////////////////////\n\nint main()\n{\n\tint k;\n\tcin>>k;\n\tvi A(k+1);\n\ttake(A,1,k);\n\tint mn=MOD,mx=0;\n\tvi H(k+1);\n\tfor(int i=1;i<=k;i++)\n\t{\t\n\t\tH[i]=A[i];\n\t\tmn=min(mn,A[i]);\n\t\tmx=max(mx,A[i]);\n\t}\n\tif(mx>2*mn) cout<<-1<<endl;\n\telse\n\t{\n\t\tset<int> MIN;\n\t\tfor(int i=1;i<=k;i++) if(A[i]==mn) MIN.insert(i);\n\t\tvi Ans;\n\n\t\tint diff = 2*mn-mx;\n\t\tfor(int i=0;i<diff;i++)\n\t\t{\n\t\t\tfor(int num=1;num<=k;num++) Ans.push_back(num);\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tH[i]-=diff;\n\t\t}\n\t\tmn-=diff;\n\n\t\twhile(1)\n\t\t{ \n\t\t\tdeque<int> D;\n\t\t\tint smol = (*(MIN.begin()));\n\t\t\tif(H[smol]==0) break;\n\t\t\t\n\t\t\tfor(auto m:MIN) {D.push_back(m);H[m]--;}\n\t\t\tfor(int i=k;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(!MIN.count(i))\n\t\t\t\t{\n\t\t\t\t\tD.push_back(i);\n\t\t\t\t\tD.push_front(i);\n\t\t\t\t\tH[i]-=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmn--;\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tif(H[i]==mn) MIN.insert(i);\n\t\t\t}\n\n\t\t\t// prin(D);\n\t\t\tvi ND;\n\t\t\tfor(auto d:D) ND.push_back(d);\n\t\t\tint len1 = ND.size();\n\t\t\tint len2 = Ans.size();\n\t\t\tint upto = min(len1,len2);\n\t\t\tfor(int i=0;i<upto;i++)\n\t\t\t{\n\t\t\t\tif(Ans[i]<ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(Ans[i]>ND[i])\n\t\t\t\t{\n\t\t\t\t\tfor(auto a:Ans) ND.push_back(a);\n\t\t\t\t\tAns=ND;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Ans.size()==0)\n\t\t\t{\n\t\t\t\tfor(auto d:ND) Ans.push_back(d);\n\t\t\t}\n\t\t}\n\t\tprin(Ans);\n\t}\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint a[110],p[1010],pl[110],pr[110];\nbool bl[110];\nint main()\n{\n\tre int n=0,k,mx=0,mm=0,mk=0;\n\tscanf(\"%d\",&k);\n\tfor(re int i=1;i<=k;i++)scanf(\"%d\",&a[i]),n+=a[i],mx=std::max(mx,a[i]),pl[i]=k,pr[i]=i;\n\tfor(re int i=1;i<=k;i++)if(a[i]*2<mx){puts(\"-1\");return 0;}\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tre int j=1;\n\t\tfor(;j<=k;j++)\n\t\t{\n\t\t\tif(bl[j])continue;\n\t\t\tre bool bb=1;mx=0;\n\t\t\tfor(re int i=1;i<=k;i++)mx=std::max(mx,a[i]);\n\t\t\tfor(re int i1=1;i1<=pl[j];i1++)if(!bl[pr[i1]])a[pr[i1]]--;\n\t\t\tfor(re int i=1;i<=k;i++)if(a[i]*2+2<mx){bb=0;break;}\n\t\t\tif(a[j]*2+1<mx)bb=0;\n\t\t\tfor(re int i1=1;i1<=pl[j];i1++)if(!bl[pr[i1]])a[pr[i1]]++;\n\t\t\tif(bb)break;\n\t\t}\n\t\tassert(j<=k);\n\t\tbl[j]=1;p[i]=j;a[j]--;mm++;mk=std::max(mk,pl[j]);\n\t\tif(i>=k&&(i==k||mm==mk))\n\t\t{\n\t\t\tfor(re int j=1;j<=k;j++)bl[j]=0,pl[p[i-k+j]]=j,pr[j]=p[i-k+j];mm=mk=0;\n\t\t}\n\t}\n\tfor(re int i=1;i<=n;i++)printf(\"%d \",p[i]);\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // \n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // \n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO \n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\tfor (int i = 0;i < K;++ i) { // \n\t\t\ta[i] -= min;\n\t\t\tif (a[i] > min) {\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint max = Arrays.stream(a).max().getAsInt(); // \n\t\tfor (int i = 0;i < max;++ i) {\n\t\t\tfor (int j = 0;j < K;++ j) {\n\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\tblock.get(i).add(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ // 1\n\t\t\tfor (int i = 0;i < a[0];++ i) {\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO \n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\tfor (int i = 0;i < K;++ i) { // \n\t\t\ta[i] -= min;\n\t\t\tif (a[i] > min) {\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint max = Arrays.stream(a).max().getAsInt(); // \n\t\tfor (int i = 0;i < max;++ i) {\n\t\t\tfor (int j = 0;j < K;++ j) {\n\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\tblock.get(i).add(j);\n\t\t\t\t\t-- a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ // 1\n\t\t\tfor (int i = 0;i < a[0];++ i) {\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO \n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > min && !got || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void solve() throws Exception {\n\t\tint k = scanInt();\n\t\tint a[] = new int[k];\n\t\tint minA = Integer.MAX_VALUE, maxA = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\ta[i] = scanInt();\n\t\t\tminA = min(minA, a[i]);\n\t\t\tmaxA = max(maxA, a[i]);\n\t\t}\n\t\tif (maxA > minA * 2) {\n\t\t\tout.print(-1);\n\t\t\treturn;\n\t\t}\n\t\tboolean groupExtra[][] = new boolean[minA][k];\n\t\tint groupNext[] = new int[minA];\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint have = a[i] - minA;\n\t\t\tfor (int j = 0; j < minA; j++) {\n\t\t\t\tif (j + have == minA || (have > 0 && groupNext[j] == i)) {\n\t\t\t\t\tgroupExtra[j][i] = true;\n\t\t\t\t\t--have;\n\t\t\t\t\tif (groupNext[j] == i) {\n\t\t\t\t\t\tgroupNext[j] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < minA; i++) {\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (groupExtra[i][j]) {\n\t\t\t\t\tout.print((j + 1) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (!groupExtra[i][j]) {\n\t\t\t\t\tout.print((j + 1) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (groupExtra[i][j]) {\n\t\t\t\t\tout.print((j + 1) + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\tfor (int i = 0;i < K;++ i) { // \n\t\t\ta[i] -= min;\n\t\t\tif (a[i] > min) {\n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint max = 0; // \n\t\tfor (int i = 1;i < K;++ i) max = Math.max(max, a[i]);\n\t\t{ // 1\n\t\t\tint X = Math.min(a[0], min - max); // 123451\n\t\t\tfor (int i = 0;i < X;++ i) {\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\ta[0] -= X;\n\t\t}\n\t\tfor (int i = 1;i < max;++ i) {\n\t\t\tfor (int j = 0;j < K;++ j) {\n\t\t\t\tif (a[j] > 0) {\n\t\t\t\t\tblock.get(i).add(j);\n\t\t\t\t\t-- a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO \n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tint K = io.nextInt();\n\t\tint[] a = io.nextInt(K);\n\t\tint min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // \n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // \n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tSystem.exit(1);\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == l.size() + 1) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == r.size() + 1) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * (min - 1)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tif (max - 1 <= 2 * (vals[1] - 1)) {\n\t\t\t\t\tret[idx++] = 1;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tint firstDup = -1, lastDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min) lastDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (i < lastDup && vals[i] > min || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * Math.min(min - 1, vals[1] -2)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tret[idx++] = 1;\n\t\t\t\tvals[1]--;\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tint firstDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (firstDup != -1 && lastNoDup > firstDup && vals[i] > min && !got || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * Math.min(min - 1, vals[1] -2)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tret[idx++] = 1;\n\t\t\t\tvals[1]--;\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tint firstDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (firstDup != -1 && lastNoDup > firstDup && vals[i] > min || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tint K = io.nextInt();\n\t\tint[] a = io.nextInt(K);\n\t\tint min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // \n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - (min - X);++ i) block.get(i).add(0); // \n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == l.size() + 1) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == r.size() + 1) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // \n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // \n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i); // TODO \n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.size() == K + 1 && r.get(K) == 0) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.size() == K + 1 && l.get(K) == 0) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (ArrayList<Integer> i : block) for (int j : i) ans.add(j + 1);\n\t\tio.println(ans, \" \");\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i] = sc.nextInt();\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (max - 1 <= 2 * (min - 1)) {\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tif (max - 1 <= 2 * (vals[1] - 1)) {\n\t\t\t\t\tret[idx++] = 1;\n\t\t\t\t\tvals[1]--;\n\t\t\t\t}\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tint firstDup = -1, lastDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min) lastDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (i < lastNoDup && vals[i] > min || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tfinal int K = io.nextInt();\n\t\tfinal int[] a = io.nextInt(K);\n\t\tfinal int min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // \n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // \n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == K + 1) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == K + 1) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint K = sc.nextInt();\n\t\tint[] vals = new int[K + 1];\n\t\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, sum = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tvals[i] = sc.nextInt();\n\t\t\tmin = Math.min(min, vals[i]);\n\t\t\tmax = Math.max(max, vals[i]);\n\t\t\tsum += vals[i];\n\t\t}\n\t\tif (max <= 2 * min) {\n\t\t\tint idx = 0;\n\t\t\tint[] ret = new int[sum];\n\t\t\twhile (min > 0) {\n\t\t\t\tmax--;\n\t\t\t\tmin--;\n\t\t\t\tmax = Math.min(max, 2 * min);\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tvals[i]--;\n\t\t\t\t}\n\t\t\t\tboolean[] dup = new boolean[K + 1];\n\t\t\t\tboolean got = false;\n\t\t\t\tint firstDup = -1, lastNoDup = -1;;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (vals[i] == min) lastNoDup = i;\n\t\t\t\t\tif (vals[i] > 2 * min && firstDup == -1) firstDup = i;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tif (firstDup != -1 && lastNoDup > firstDup && vals[i] > min && !got || vals[i] > 2 * min) {\n\t\t\t\t\t\tdup[i] = true;\n\t\t\t\t\t\tvals[i]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgot = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dup[1] && vals[1] > min) {\n\t\t\t\t\tvals[1]--;\n\t\t\t\t\tdup[1] = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (!dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= K; i++)\n\t\t\t\t\tif (dup[i]) {\n\t\t\t\t\t\tret[idx++] = i;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int i = 1; i <= K; i++) {\n\t\t\t\t\tmin = Math.min(min, vals[i]);\n\t\t\t\t\tmax = Math.max(max, vals[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < sum; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(ret[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\t@SuppressWarnings(\"static-method\")\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AtCoder Grand Contest 046 E\n\t\t * \n\t\t * xnnxnnxn...2\n\t\t * 1231123112311231...2|P|/(K+1)\n\t\t * 123...\n\t\t * \n\t\t * 1123123\n\t\t * 221322132\n\t\t * 3213223123\n\t\t * \n\t\t * 2\n\t\t * 12341234 2\n\t\t * 123412341 1\n\t\t * 1234132413 \n\t\t * 1\n\t\t *\n\t\t * \n\t\t * 1234123412341/2341\n\t\t * 112341/12341\n\t\t * 23412~4\n\t\t * 312341/234112341/31243/\n\t\t * nxn\n\t\t * 1x1\n\t\t * 11231232132 213223\n\t\t * 2132231232132/23123 \n\t\t *\n\t\t * \n\t\t * 0123123...\n\t\t * 11231(-1)\n\t\t * 2\n\t\t * 12345213452\n\t\t * 1234511234512\n\t\t * +(13524678135)7\n\t\t * +7+++7\n\t\t * 13524678135135724681357 \n\t\t * \n\t\t * \n\t\t * 123451 < 12345 ... (123451)\n\t\t * < 213452 < 312453 < ... ()\n\t\t * \n\t\t * 12\n\t\t * 12\n\t\t * 12345112345\n\t\t * \n\t\t * X = max(a_2 - min(a), ..., a_n - min(a))\n\t\t * min(a_1, min(a) - X)123451\n\t\t * \n\t\t */\n\t\tint K = io.nextInt();\n\t\tint[] a = io.nextInt(K);\n\t\tint min = Arrays.stream(a).min().getAsInt(); //  = \n\t\tArrayList<ArrayList<Integer>> block = new ArrayList<>(min); // \n\t\tfor (int i = 0;i < min;++ i) block.add(new ArrayList<>());\n\t\t{ // 1\n\t\t\ta[0] -= min;\n\t\t\tif (a[0] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint X = 0; // \n\t\t\tfor (int i = 1;i < K;++ i) X = Math.max(X, a[i] -= min);\n\t\t\tfor (int i = 0;i < Math.min(a[0], min - X);++ i) { // 123451\n\t\t\t\tblock.get(min - i - 1).add(0);\n\t\t\t}\n\t\t\tfor (int i = 0;i < a[0] - Math.min(a[0], min - X);++ i) block.get(i).add(0); // \n\t\t}\n\t\tfor (int i = 1;i < K;++ i) {\n\t\t\tif (a[i] > block.size()) { // \n\t\t\t\tio.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int j = 0;j < a[i];++ j) block.get(j).add(i);\n\t\t}\n\t\t//for (ArrayList<Integer> i : block) io.debugln(i);\n\t\tfor (int i = 0;i < min;++ i) {\n\t\t\tboolean[] use = new boolean[K];\n\t\t\tArrays.fill(use, false);\n\t\t\tfor (int j : block.get(i)) use[j] = true; // \n\t\t\tfor (int j = 0;j < K;++ j) if (!use[j]) block.get(i).add(j); // ()\n\t\t\tfor (int j = 0;j < K;++ j) if (use[j]) block.get(i).add(j); // ()\n\t\t}\n\t\tblock.sort((l, r) -> {\n\t\t\tfinal int s = Math.min(l.size(), r.size());\n\t\t\tfor (int i = 0;i < s;++ i) {\n\t\t\t\tint comp = Integer.compare(l.get(i), r.get(i));\n\t\t\t\tif (comp != 0) return comp;\n\t\t\t}\n\t\t\tif (l.size() < r.size()) {\n\t\t\t\tif (r.get(l.size()) == '1' && r.size() == l.size() + 1) return 1; // r\n\t\t\t\treturn -1;\n\t\t\t} else if (r.size() < l.size()) {\n\t\t\t\tif (l.get(r.size()) == '1' && l.size() == r.size() + 1) return -1; // l\n\t\t\t\treturn 1;\n\t\t\t} else return 0;\n\t\t});\n\t\tio.print(block.get(0).get(0) + 1);\n\t\tfor (int i = 1;i < block.get(0).size();++ i) io.print(\" \" + (block.get(0).get(i) + 1));\n\t\tfor (int i = 1;i < block.size();++ i) {\n\t\t\tfor (int j : block.get(i)) io.print(\" \" + (j + 1));\n\t\t}\n\t\tio.println();\n\t}\n\n\t/**  */\n\tprivate static boolean DEBUG = false;\n\t/** (: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {e.printStackTrace(); System.exit(1);});\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve(io, args);\n\t\t} catch (Throwable e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tio.flush();\n\t\t}\n\t}\n\n\t// \n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO implements AutoCloseable{\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\t\tprivate boolean outFlush = false;\n\t\tprivate boolean autoOutFlush = true;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tpublic final void setAutoOutFlush(boolean flush) {\n\t\t\tautoOutFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate byte readByte() {\n\t\t\tif (hasNextByte()) return buffer[read++];\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\tprivate boolean readNewLine() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\tif (buffer[read] == '\\r') {\n\t\t\t\t\t++ read;\n\t\t\t\t\tif (hasNextByte() && buffer[read] == '\\n') ++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (buffer[read] == '\\n') {\n\t\t\t\t\t++ read;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(byte c) {\n\t\t\treturn 32 < c || c < 0;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tbyte b = readByte();\n\t\t\tif ((b & 0x80) == 0) return (char)b;\n\t\t\tif ((b & 0x20) == 0) return (char)((b & 0x1F) << 6 | (readByte() & 0x3F));\n\t\t\treturn (char)((b & 0xF) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F));\n\t\t}\n\n\t\tpublic final char[] nextChars() {\n\t\t\treturn next().toCharArray();\n\t\t}\n\n\t\tpublic final char[] nextChars(char around) {\n\t\t\treturn (around + next() + around).toCharArray();\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = nextChars();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final char[][] nextChars(int height, char around) {\n\t\t\tchar[][] ret = new char[height + 2][];\n\t\t\tfor (int i = 1;i <= height;++ i) ret[i] = nextChars(around);\n\t\t\tArrays.fill(ret[0] = new char[ret[1].length], around);\n\t\t\tArrays.fill(ret[ret.length - 1] = new char[ret[0].length], around);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tdo sb.append(nextChar()); while(hasNextByte() && isPrintableChar(buffer[read]));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(!readNewLine()) sb.append(nextChar());\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tif (outFlush) {\n\t\t\t\toutFlush = false;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\ttry {\n\t\t\t\tbyte b = readByte();\n\t\t\t\tif (b == '-') {\n\t\t\t\t\twhile(isNumber(b = readByte())) n = n * 10 + '0' - b;\n\t\t\t\t\treturn n;\n\t\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\t\tdo n = n * 10 + b - '0'; while(isNumber(b = readByte()));\n\t\t\t\treturn n;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj != null && obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t\telse outFlush = autoOutFlush;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array != null && array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\telse outFlush = autoOutFlush;\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t\toutFlush = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tout.close();\n\t\t\terr.close();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t *\n\t\t * @param other\n\t\t * @return true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param value \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param connectedRange \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param other \n\t\t * @return \n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static <C> List<Range<C>> scheduling(List<Range<C>> ranges) {\n\t\t\tPriorityQueue<Range<C>> pq = new PriorityQueue<Range<C>>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tList<Range<C>> ret = new ArrayList<>();\n\t\t\tRange<C> last = pq.poll();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tRange<C> tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * NO(NlogN)\n\t\t * @param ranges \n\t\t * @return \n\t\t */\n\t\tpublic static List<IntRange> intScheduling(List<IntRange> ranges) {\n\t\t\tPriorityQueue<IntRange> pq = new PriorityQueue<IntRange>((l, r) -> l.compareUpper(r.upper, r.upperType));\n\t\t\tpq.addAll(ranges);\n\t\t\tList<IntRange> ret = new ArrayList<>();\n\t\t\tif (pq.isEmpty()) return ret;\n\t\t\tIntRange last = pq.poll();\n\t\t\tret.add(last);\n\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\tIntRange tmp = pq.poll();\n\t\t\t\tif (tmp.compareLower(last.upper, last.upperType) > 0) {\n\t\t\t\t\tret.add(tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 1\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat \n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeatelement\n\t\t * @param element \n\t\t * @param repeat 0\n\t\t * @return +element + element + ... + elementrepeat-1\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * ()\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * GCD\n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t * @param <T> \n\t * @param <A> \n\t * @param <M> \n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param mod \n\t\t * @param calc \n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\n\t\t * @param calc \n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tif (calc > mod) calc = mod;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @return mod0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\n\t\t * @param n \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modn<br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkmod<br>\n\t\t * O(n-k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nPkmod\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkmod<br>\n\t\t * O(min(plogn, n-k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nCkmod\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (n < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n >= mod) {\n\t\t\t\tif (mod == 2) return (~n & k) == 0 ? 1 : 0;\n\t\t\t\twhile(n > 0) {\n\t\t\t\t\tret = ret * combination(n % mod, k % mod) % mod;\n\t\t\t\t\tn /= mod;\n\t\t\t\t\tk /= mod;\n\t\t\t\t}\n\t\t\t\treturn (int)ret;\n\t\t\t}\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tret = invfact.length > k ? invfact[k] : inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * mod<br>]\n\t\t * O(n)\n\t\t * @param n \n\t\t * @param k n\n\t\t * @return \n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nknHkmod<br>\n\t\t * O(min(n, k))\n\t\t * @param n \n\t\t * @param k \n\t\t * @return nHkmod\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * C(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int firstStirling(int n, int k) {\n\t\t\tint[] stirling = new int[(n + 1) * (k + 1)];\n\t\t\tstirling[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tfor (int j = 0;j < k;++ j) {\n\t\t\t\t\tint tmp = stirling[i * h + j] + (int)((long)i * stirling[i * h + j + 1] % mod);\n\t\t\t\t\tstirling[(i + 1) * h + j + 1] = tmp >= mod ? tmp - mod : tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stirling[stirling.length - 1];\n\t\t}\n\n\t\t/**\n\t\t * S(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return S(n, k)mod\n\t\t */\n\t\tpublic int secondStirling(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)combination(k, i) * (prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) % mod;\n\t\t\t\tans += (k - i & 1) != 0 ? -tmp : tmp;\n\t\t\t}\n\t\t\treturn (int)((long)mod(ans) * invfact[k] % mod);\n\t\t}\n\n\t\t/**\n\t\t * B(n, k)mod<br>\n\t\t * O(k)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return B(n, k)mod\n\t\t */\n\t\tpublic int bell(int n, int k) {\n\t\t\tif (k == 0) return n == 0 ? 1 : 0;\n\t\t\tint[] sieve = new int[k + 1], prime = new int[k + 1];\n\t\t\tint size = 0;\n\t\t\tsieve[1] = 1;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 2;i <= k;++ i) {\n\t\t\t\tif (sieve[i] == 0) prime[size++] = sieve[i] = i;\n\t\t\t\tfor (int j = 0, s;j < size && prime[j] <= sieve[i] && (s = i * prime[j]) <= k;++ j) sieve[s] = prime[j];\n\t\t\t\tsum += (i & 1) != 0 ? -invfact[i] : invfact[i];\n\t\t\t}\n\t\t\tsum = mod(sum);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0, s;i <= k;++ i) {\n\t\t\t\tlong tmp = (long)(prime[i] = (s = sieve[i]) == i ? pow(i, n) : (int)((long)prime[s] * prime[i / s] % mod)) * invfact[i] % mod;\n\t\t\t\tans += tmp * sum % mod;\n\t\t\t\tif ((sum -= (k - i & 1) != 0 ? -invfact[k - i] : invfact[k - i]) < 0) sum += mod;\n\t\t\t}\n\t\t\treturn mod(ans);\n\t\t}\n\n\t\t/**\n\t\t * B(n)mod<br>\n\t\t * O(n)\n\t\t * @param n \n\t\t * @return B(n)\n\t\t */\n\t\tpublic int bell(int n) {\n\t\t\treturn bell(n, n);\n\t\t}\n\n\t\t/**\n\t\t * P(n, k)mod<br>\n\t\t * O(nk) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @param k \n\t\t * @return P(n, k)mod\n\t\t */\n\t\tpublic int pertition(int n, int k) {\n\t\t\tint[] pertition = new int[(n + 1) * (k + 1)];\n\t\t\tpertition[0] = 1;\n\t\t\tint h = k + 1;\n\t\t\tfor (int i = 0;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, l = Math.min(i, k);j <= l;++ j) pertition[i * h + j] = pertition[i * h + j - 1] + pertition[(i - j) * h + j];\n\t\t\t\tfor (int j = i;j < k;++ j) pertition[i * h + j + 1] = pertition[i * h + j];\n\t\t\t}\n\t\t\treturn pertition[n * h + k];\n\t\t}\n\n\t\t/**\n\t\t * P(n)mod<br>\n\t\t * O(n sqrt(n)) // TODO NTTO(n log n)\n\t\t * @param n \n\t\t * @return P(n)\n\t\t */\n\t\tpublic int pertition(int n) {\n\t\t\tlong[] pertition = new long[n + 1];\n\t\t\tpertition[0] = 1;\n\t\t\tfor (int i = 1;i <= n;++ i) {\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j - 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tfor (int j = 1, t;(t = i - (j * (3 * j + 1) >> 1)) >= 0; ++ j) {\n\t\t\t\t\tpertition[i] += (j & 1) != 0 ? pertition[t] : -pertition[t];\n\t\t\t\t}\n\t\t\t\tpertition[i] %= mod;\n\t\t\t}\n\t\t\treturn (int)pertition[n];\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nmmod<br>\n\t\t * O(log m)\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n^mmod\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * mod<br>\n\t\t * mod-1\n\t\t * @return \n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n<br>\n\t\t * O(sqrt n)\n\t\t * @param n \n\t\t * @return n\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * nmod\n\t\t * @param n \n\t\t * @return nmod\n\t\t */\n\t\tpublic int mod(PrimeFactor n) {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) ret = multiply(ret, pow(i.getKey().prime, i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * n+mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n+mmod\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n-mmod\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n*mmod\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mmod\n\t\t * @param n \n\t\t * @param m \n\t\t * @return n/mmod\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * ff-1xmod<br>\n\t\t * O(f)\n\t\t * @param f \n\t\t * @param x \n\t\t * @return mod\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class SegmentPrime {\n\t\tprivate final Prime[] divisor;\n\t\tprivate final int offset;\n\n\t\tprivate SegmentPrime(Prime[] divisor, int offset) {\n\t\t\tthis.divisor = divisor;\n\t\t\tthis.offset = offset;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic IntRange getRange() {\n\t\t\treturn IntRange.closedOpen(offset, offset + divisor.length);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param n \n\t\t * @return true\n\t\t */\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn n <= 1 ? false : divisor[n - offset].prime == n;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * O(log n)\n\t\t * @param n \n\t\t * @return \n\t\t */\n\t\tpublic PrimeFactor getPrimeFactor(int n) {\n\t\t\tif (n < 1) throw new IllegalArgumentException(\"not positive number\");\n\t\t\tMap<Prime, Integer> map = new HashMap<>();\n\t\t\twhile(n > 1) {\n\t\t\t\tPrime d = divisor[n - offset];\n\t\t\t\tmap.compute(d, (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\tn /= d.prime;\n\t\t\t}\n\t\t\treturn new PrimeFactor(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"SegmentPrime: [\" + offset + \", \" + (offset + divisor.length) + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @author 31536000\n\t *\n\t */\n\tpublic static class PrimeFactor extends Number{\n\t\tprivate static final long serialVersionUID = 1363575672283884773L;\n\t\tpublic Map<Prime, Integer> primeFactor;\n\n\t\tprivate PrimeFactor(Map<Prime, Integer> n) {\n\t\t\tthis.primeFactor = n;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic List<Integer> getFactorizationList() {\n\t\t\tList<Integer> ret = new ArrayList<>();\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) {\n\t\t\t\tint p = i.getKey().prime, n = i.getValue();\n\t\t\t\tfor (int j = 0;j < n;++ j) ret.add(p);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * ngcd\n\t\t * @param n gcd\n\t\t */\n\t\tpublic void gcd(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t}\n\n\t\t/**\n\t\t * gcd(n, m)\n\t\t * @param n gcd\n\t\t * @param m gcd\n\t\t * @return gcd(n, m)\n\t\t */\n\t\tpublic static PrimeFactor gcd(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.computeIfPresent(i.getKey(), (k, v) -> Math.min(v, i.getValue()));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\t/**\n\t\t * nlcm\n\t\t * @param n lcm\n\t\t */\n\t\tpublic void lcm(PrimeFactor n) {\n\t\t\tfor (Entry<Prime, Integer> i : n.primeFactor.entrySet()) primeFactor.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t}\n\n\t\t/**\n\t\t * lcm(n, m)\n\t\t * @param n lcm\n\t\t * @param m lcm\n\t\t * @return lcm(n, m)\n\t\t */\n\t\tpublic static PrimeFactor lcm(PrimeFactor n, PrimeFactor m) {\n\t\t\tMap<Prime, Integer> ret = new HashMap<>(n.primeFactor);\n\t\t\tfor (Entry<Prime, Integer> i : m.primeFactor.entrySet()) ret.merge(i.getKey(), i.getValue(), (v1, v2) -> Math.max(v1, v2));\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int pow(int p, int n) {\n\t\t\tint ans = 1;\n\t\t\tfor (int mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tprivate static long pow(long p, long n) {\n\t\t\tlong ans = 1;\n\t\t\tfor (long mul = p;n > 0;n >>= 1, mul *= mul) if ((n & 1) != 0) ans *= mul;\n\t\t\treturn ans;\n\t\t}\n\n\t\tpublic BigInteger getValue() {\n\t\t\tBigInteger ret = BigInteger.ONE;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret = ret.multiply(new BigInteger(i.getKey().toString()).pow(i.getValue()));\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\tint ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= pow((long)i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\tfloat ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\tlong ret = 1;\n\t\t\tfor (Entry<Prime, Integer> i : primeFactor.entrySet()) ret *= Math.pow(i.getKey().prime, i.getValue());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof PrimeFactor ? ((PrimeFactor)o).primeFactor.equals(primeFactor) : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn primeFactor.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn primeFactor.toString();\n\t\t}\n\t}\n\n\t/**\n\t * <br>\n\t * \n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \n\t\t *\n\t\t * @param prime \n\t\t * @throws IllegalArgumentException \n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate Prime(int prime, boolean none) {\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\t\tprivate static final byte wheel[] = {10, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 8, 6, 4, 6, 2, 4, 6, 2, 6, 6, 4, 2, 4, 6, 2, 6, 4, 2, 4, 2, 10, 2};\n\n\t\tprivate static boolean isSPRP(int n, long a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\tdo {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = a * a % n;\n\t\t\t\tpw >>= 1;\n\t\t\t} while(pw != 0);\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0;r < s;++ r) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * http://ceur-ws.org/Vol-1326/020-Forisek.pdf\n\t\t * @param x \n\t\t * @return xtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\treturn checkPrime(x);\n\t\t}\n\n\t\tprivate static boolean checkPrime(int x) {\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t/**\n\t\t * <br>\n\t\t * \n\t\t * @param n \n\t\t * @return 1n\n\t\t */\n\t\tpublic static SegmentPrime getSegmentPrime(int n) {\n\t\t\tPrime[] divisor = new Prime[n - 1];\n\t\t\tint sqrt = (int)Math.sqrt(n) + 1;\n\t\t\tfor (int i = 0;i < sqrt;++ i) {\n\t\t\t\tif (divisor[i] != null) continue;\n\t\t\t\tint p = i + 2;\n\t\t\t\tdivisor[i] = new Prime(p, true);\n\t\t\t\tfor (int j = p * p - 2;j < divisor.length;j += p) divisor[j] = divisor[i];\n\t\t\t}\n\t\t\tfor (int i = sqrt;i < divisor.length;++ i) if (divisor[i] == null) divisor[i] = new Prime(i + 2, true);\n\t\t\treturn new SegmentPrime(divisor, 2);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param x \n\t\t * @return \n\t\t */\n\t\tpublic static PrimeFactor getPrimeFactor(int x) {\n\t\t\tif (x <= 0) throw new IllegalArgumentException(\"non positive number: \" + x);\n\t\t\tMap<Prime, Integer> ret = new TreeMap<>((l, r) -> Integer.compare(l.prime, r.prime));\n\t\t\tint c;\n\t\t\tif((x & 1) == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x >>= 1;(x & 1) == 0;x >>= 1) ++ c;\n\t\t\t\tret.put(new Prime(2, false), c);\n\t\t\t}\n\t\t\tif(x % 3 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 3;x % 3 == 0;x /= 3) ++ c;\n\t\t\t\tret.put(new Prime(3, false), c);\n\t\t\t}\n\t\t\tif(x % 5 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 5;x % 5 == 0;x /= 5) ++ c;\n\t\t\t\tret.put(new Prime(5, false), c);\n\t\t\t}\n\t\t\tif(x % 7 == 0) {\n\t\t\t\tc = 1;\n\t\t\t\tfor (x /= 7;x % 7 == 0;x /= 7) ++ c;\n\t\t\t\tret.put(new Prime(7, false), c);\n\t\t\t}\n\t\t\tif (x < 100000000) { // Wheel Factorization\n\t\t\t\tfor (int i = 11, j = 0;i * i <= x;i += wheel[++j % wheel.length]) {\n\t\t\t\t\twhile(x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t\tret.compute(new Prime(i, false), (k, v) -> v == null ? 1 : v + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x != 1) ret.put(new Prime(x, false), 1);\n\t\t\t} else {\n\t\t\t\tint p, count;\n\t\t\t\twhile(x != 1) { // \n\t\t\t\t\tfor (p = x;!checkPrime(p);p = pollardRho(p, 1));\n\t\t\t\t\tPrime prime = new Prime(p, false);\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tfor (x /= p;x % p == 0;x /= p)++ count;\n\t\t\t\t\tret.put(prime, count);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new PrimeFactor(ret);\n\t\t}\n\n\t\tprivate static int gcd(int n, int m) {\n\t\t\twhile (n != 0) if ((m %= n) != 0) n %= m; else return n;\n\t\t\treturn m;\n\t\t}\n\n\t\tprivate static int pollardRho(int x, int c) {\n\t\t\tint n = 2, m = 2, d = 1, next = 4, i = 1;\n\t\t\tdo {\n\t\t\t\tif (++ i == next) {\n\t\t\t\t\tm = n;\n\t\t\t\t\tnext <<= 1;\n\t\t\t\t}\n\t\t\t\tif ((n = (int)(((long)n * n + c) % x)) == m) return pollardRho(x, ++c); // \n\t\t\t} while((d = gcd(Math.abs(n - m), x)) == 1);// d\n\t\t\treturn d;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\treturn o instanceof Prime ? ((Prime)o).prime == prime : false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t * @param <E> \n\t */\n\tpublic static class Enumerate<E> {\n\t\tpublic final E value;\n\t\tpublic final int index;\n\n\t\t/**\n\t\t * index<br>\n\t\t * indexindex\n\t\t * @param value\n\t\t * @param index\n\t\t */\n\t\tpublic Enumerate(E value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return \n\t\t */\n\t\tpublic E getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t/**\n\t\t * index\n\t\t * @return index\n\t\t */\n\t\tpublic int getIndex() {\n\t\t\treturn index;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Enumerate) return ((Enumerate<?>)o).getValue().equals(value) && ((Enumerate<?>)o).getIndex() == index;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn value.hashCode() ^ index;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + value.toString() + \", \" + index + \"}\";\n\t\t}\n\t}\n\n\t/**\n\t * index\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Enumeration {\n\n\t\tprivate static class IteratorArray<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final E[] array;\n\t\t\tprivate final int start;\n\t\t\tprivate int index;\n\n\t\t\tpublic IteratorArray(E[] array, int index) {\n\t\t\t\tthis.array = array;\n\t\t\t\tthis.start = index;\n\t\t\t\tthis.index = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(array[index], index+++start);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tprivate static class IteratorCollection<E> implements Iterator<Enumerate<E>>{\n\t\t\tprivate final Iterator<E> iter;\n\t\t\tprivate int start;\n\n\t\t\tpublic IteratorCollection(Iterator<E> iter, int index) {\n\t\t\t\tthis.iter = iter;\n\t\t\t\tthis.start = index;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn iter.hasNext();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Enumerate<E> next() {\n\t\t\t\tEnumerate<E> ret = new Enumerate<>(iter.next(), start++);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array) {\n\t\t\treturn enumerate(array, 0);\n\t\t}\n\n\t\t/**\n\t\t * indexIterator\n\t\t * @param <E> \n\t\t * @param array \n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(E[] array, int start) {\n\t\t\tif (array == null) throw new NullPointerException(\"array is null\");\n\t\t\treturn new IteratorArray<E>(array, start);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter) {\n\t\t\treturn enumerate(iter, 0);\n\t\t}\n\n\t\t/**\n\t\t * IteratorindexIterator\n\t\t * @param <E> Iterator\n\t\t * @param iter Iterator\n\t\t * @param start index\n\t\t * @return Enumerate&lt;E&gt;Iterator\n\t\t */\n\t\tpublic static <E> Iterator<Enumerate<E>> enumerate(Iterator<E> iter, int start) {\n\t\t\tif (iter == null) throw new NullPointerException(\"iterator is null\");\n\t\t\treturn new IteratorCollection<E>(iter, start);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing System.Collections.Generic;\n\nclass Myon\n\n{\n    public Myon() { }\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Myon().calc();\n        return 0;\n    }\n    static Scanner cin;\n    int mod = 998244353;\n\n    void calc()\n    {\n        int K = cin.nextInt();\n        int[] A = cin.ArrayInt(K);\n        int min = 999999;\n        int max = 0;\n        for (int i = 0; i < A.Length; i++)\n        {\n            min = Math.Min(min, A[i]);\n            max = Math.Max(max, A[i]);\n        }\n        if(min * 2 < max)\n        {\n            Console.WriteLine(-1);\n            return;\n        }\n        List<int> ans = new List<int>();\n\n        for (int t = 0; t < min; t++)\n        {\n            int nokori = min - t;\n            List<int> over = new List<int>();\n            List<int> under = new List<int>();\n\n            int overMax = -1;\n            for (int i = 0; i < K; i++)\n            {\n                if(A[i] == nokori * 2)\n                {\n                    overMax = i;\n                }\n            }\n\n            bool first = true;\n            for (int i = 0; i < K; i++)\n            {\n                if((A[i] > nokori && (first || i <= overMax)))\n                {\n                    A[i] -= 2;\n                    over.Add(i + 1);\n                    if (A[i] > nokori - 1) first = false;\n                }\n                else\n                {\n                    A[i]--;\n                    under.Add(i + 1);\n                    first = false;\n                }\n            }\n            foreach (var item in over)\n            {\n                ans.Add(item);\n            }\n\n            foreach (var item in under)\n            {\n                ans.Add(item);\n            }\n\n            foreach (var item in over)\n            {\n                ans.Add(item);\n            }\n        }\n\n        Console.WriteLine(string.Join(\" \", ans));\n\n    }\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "k = gets.to_i\na = gets.split.map(&:to_i).zip(1..k).sort_by { |a| a[0] }\n\n# n\n# dd+1\n# k\n\nresult = []\n\nn = min = a[0][0]\n\nn.times do\n  b = []\n  temp = 1000000\n  (1..k).each do |i|\n    c = a[i-1][0] > min ? 2 : 1\n    b << [c, i]\n    a[i-1][0] -= c\n    temp = a[i-1][0] if temp > a[i-1][0]\n  end\n  min = temp\n  if min == 0\n    puts \"-1\"\n    exit\n  end\n  \n  b.sort_by! { |a| a[0] }\n  \n  i = b.index { |a| a[0] == 2 }\n  \n  b.each { |a| result << a[1] }\n  (i...k).reverse_each { |j| result << b[j][1] }\n  \nend\n\nputs result.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "k = gets.to_i\na = gets.split.map(&:to_i).zip(1..k).sort_by { |a| a[0] }\n\n# n\n# dd+1\n# k\n\nresult = []\n\nn = min = a[0][0]\n\nn.times do\n  b = []\n  temp = 1000000\n  (1..k).each do |i|\n    c = i > min ? 2 : 1\n    b << [c, i]\n    a[i-1][0] -= c\n    temp = a[i-1][0] if temp > a[i-1][0]\n  end\n  min = temp\n  if min == 0\n    puts \"-1\"\n    exit\n  end\n  \n  b.sort_by! { |a| a[0] }\n  \n  i = b.index { |a| a[0] == 2 }\n  \n  b.each { |a| result << a[1] }\n  (i...k).reverse_each { |j| result << b[j][1] }\n  \nend\n\nputs result.join(\" \")"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heapreplace\nfrom itertools import chain\n\n\ndef solve(k, aaa):\n    aaa_idx = [(-a, i) for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = -aaa_idx[-1][0]\n    max_a = -aaa_idx[0][0]\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = set()\n\n        while True:\n            while aaa[aaa_idx[0][1] - 1] != -aaa_idx[0][0]:\n                heapreplace(aaa_idx, (-aaa[aaa_idx[0][1] - 1], aaa_idx[0][1]))\n            if (min_a - 1) * 2 < (-aaa_idx[0][0] - 1):\n                a, i = aaa_idx[0]\n                double.add(i)\n                aaa[i - 1] -= 2\n                heapreplace(aaa_idx, (a + 2, i))\n            else:\n                break\n\n        if aaa[0] > min_a and 1 not in double:\n            double.add(1)\n            aaa[0] -= 2\n\n        double_sorted = sorted(double)\n\n        ans.extend(double_sorted)\n        for i in range(1, k + 1):\n            if i in double:\n                continue\n            ans.append(i)\n            aaa[i - 1] -= 1\n        ans.extend(double_sorted)\n\n        min_a -= 1\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    aaa_idx = [[a, i] for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = aaa_idx[0][0]\n    if min_a * 2 < aaa_idx[-1][1]:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = []\n        single = []\n        for j in range(k):\n            a, i = aaa_idx[j]\n            if a > min_a:\n                double.append(i)\n                aaa_idx[j][0] -= 2\n            else:\n                single.append(i)\n                aaa_idx[j][0] -= 1\n        double.sort()\n        single.sort()\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n        min_a -= 1\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=len_f:\n      index_i=len_f-k\nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    aaa_idx = [[a, i] for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = aaa_idx[0][0]\n    if min_a * 2 < aaa_idx[-1][1]:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = []\n        single = []\n        for j in range(k):\n            a, i = aaa_idx[j]\n            if a > min_a:\n                double.append(i)\n                aaa_idx[j][0] -= 2\n            else:\n                single.append(i)\n                aaa_idx[j][0] -= 1\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n        min_a -= 1\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "K = int(input())\nA = [int(a) for a in input().split()]\nm = min(A)\nif max(A) > m * 2:\n    print(-1)\n    exit()\nL = [i for i in range(K) if A[i] == m]\nX = [[[], L[:], []]  for _ in range(m)]\nL = [i for i in range(K)[::-1] if A[i] != m]\n\ndef ins(li, v):\n    for j, l in enumerate(li):\n        if l > v:\n            li.append(li[-1])\n            for k in range(j + 1, len(li) - 1)[::-1]:\n                li[k] = li[k-1]\n            li[j] = v\n            break\n    else:\n        li.append(v)\n\nfor l in L:\n    c = A[l]\n    for i in range(m):\n        if c == m - i:\n            ins(X[i][1], l)\n            c -= 1\n        elif c == (m - i) * 2:\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        elif len(X[i][0]) and l < X[i][0][-1]:\n            ins(X[i][1], l)\n            c -= 1\n        elif l > X[i][1][0]:\n            ins(X[i][1], l)\n            c -= 1\n        elif l < (X[i+1][0][0] if len(X[i+1][0]) else X[i+1][1][0]):\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        else:\n            ins(X[i][1], l)\n            c -= 1\n\nANS = []\nfor i in range(m):\n    for j in range(3):\n        for k in range(len(X[i][j])):\n            ANS.append(X[i][j][k] + 1)\nprint(*ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef find_permutation(aaa, use):\n    \"\"\"\n    iaaa[i-1]\n    use(1k)\n    \n    \n\n    \n     (k - |use|) use1\n     k \n\n    None\n\n    :param aaa:\n    :param use:\n    :return:\n    \"\"\"\n\n    max_a = -1\n    min_a = 1005\n    max_fixed = -1\n\n    for i in range(k):\n        a = aaa[i]\n        if i + 1 in use:\n            min_a = min(min_a, a)\n            max_a = max(max_a, a)\n        else:\n            max_fixed = max(max_fixed, a)\n\n    if max(max_a, max_fixed + 1) > 2 * min_a:\n        return None\n\n    if max_a < 2 * min_a:\n        return sorted(use)\n\n    front = []\n    rear = []\n    either = []\n    for i in use:\n        if aaa[i - 1] == max_a:\n            front.append(i)\n        elif aaa[i - 1] == min_a:\n            rear.append(i)\n        else:\n            either.append(i)\n\n    max_front = front[-1]\n    for i in either:\n        if i < max_front:\n            front.append(i)\n        else:\n            rear.append(i)\n    front.sort()\n    rear.sort()\n    front.extend(rear)\n\n    return front\n\n\ndef solve(k, aaa):\n    if k == 1:\n        return [1] * aaa[0]\n\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    ans.extend(find_permutation(aaa, set(range(1, k + 1))))\n    for i in range(k):\n        aaa[i] -= 1\n\n    remaining = sum(aaa)\n    while remaining:\n        use = set(range(1, k + 1))\n        candidates = []\n        for r in range(k):\n            result = find_permutation(aaa, use)\n            if result is not None:\n                candidates.append(result)\n\n            use.remove(ans[-r - 1])\n        adopted = min(candidates)\n        ans.extend(adopted)\n        for i in adopted:\n            aaa[i - 1] -= 1\n        remaining -= len(adopted)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a = max(aaa)\n\n        if min_a == 0:\n            assert max_a == 0\n            break\n\n        next_max = max_a - (1 if min_a * 2 > max_a else 2)\n\n        single = []\n        double = []\n        for i in range(k):\n            if len(double) == 0 and (aaa[i] - 2) * 2 >= next_max:\n                double.append(i + 1)\n                aaa[i] -= 2\n            elif min_a * 2 == aaa[i]:\n                double.append(i + 1)\n                aaa[i] -= 2\n            else:\n                single.append(i + 1)\n                aaa[i] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a1 = max(aaa[1:])\n        max_a = max(aaa[0], max_a1)\n\n        if min_a == 0:\n            assert max_a == 0\n            break\n\n        if min_a * 2 == max_a:\n            must_use = [i for i, a in enumerate(aaa) if a == max_a]\n            next_max = max_a - 2\n        elif (aaa[0] - 2) * 2 >= max_a1 - 1:\n            must_use = []\n            next_max = max(aaa[0] - 2, max_a1 - 1)\n        else:\n            ans.extend(range(1, k + 1))\n            for i in range(k):\n                aaa[i] -= 1\n            continue\n\n        can_use = []\n        cant_use = []\n\n        for i in range(k):\n            if min_a * 2 == aaa[i]:\n                pass\n            elif (aaa[i] - 2) * 2 >= next_max:\n                can_use.append(i)\n            else:\n                cant_use.append(i)\n\n        double = []\n        if len(must_use) == 0:\n            double.append(can_use[0] + 1)\n        else:\n            max_use = must_use[-1]\n            use = must_use + can_use\n            use.sort()\n            double = [i + 1 for i in use if i <= max_use]\n        single = [i for i in range(1, k + 1) if i not in double]\n\n        for i in double:\n            aaa[i - 1] -= 2\n        for i in single:\n            aaa[i - 1] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom itertools import chain\n\n\ndef solve(k, aaa):\n    aaa_idx = [[a, i] for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = aaa_idx[0][0]\n    if min_a * 2 < aaa_idx[-1][1]:\n        return [-1]\n\n    ans = []\n    for _ in range(min_a):\n        double = []\n        single = []\n        for j in range(k):\n            a, i = aaa_idx[j]\n            if a > min_a:\n                double.append(i)\n                aaa_idx[j][0] -= 2\n            else:\n                single.append(i)\n                aaa_idx[j][0] -= 1\n        double.sort()\n        single.sort()\n        single.extend(double)\n        double.extend(single)\n        ans.append(double)\n        min_a -= 1\n    ans.sort()\n\n    return chain.from_iterable(ans)\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": " "
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nK = input()\ncounts = np.array(list(map(int, input().split())))\n\nget_bin = lambda x, n: format(x, 'b').zfill(n)\n\ndef get_block_list(counts: np.ndarray):\n    if counts.max() - counts.min() == 0: return [np.ones_like(counts)]\n    blocks = [(counts == counts.max()).astype(int) + 1]\n    if counts.max() - counts.min() > 1: return blocks\n    indices = np.arange(len(counts))[counts == counts.max()]\n    blocks = []\n    for i in range(2 ** len(indices)):\n        block = np.ones_like(counts)\n        binary = get_bin(i, len(indices))\n        for k, j in enumerate(indices):\n            block[j] += int(binary[k])\n        blocks.append(block)\n    return blocks\n\n\ndef block_to_str(block):\n    arange = np.arange(1, len(block) + 1)\n    if block.max() == 1: return \" \".join(map(str, arange))\n    twice = list(arange[block == block.max()])\n    once = list(arange[block != block.max()])\n    return \" \".join(map(str, twice + once + twice))\n\n\ndef solution(block_list, counts):\n    if counts.min() < 0:\n        return -1\n    if counts.max() == 0:\n        sorted_strs = sorted([block_to_str(block) for block in block_list])\n        return \" \".join(sorted_strs)\n    blocks = get_block_list(counts)\n    sols = [solution(block_list + [block], counts - block) for block in blocks]\n    sols = list(filter(lambda x: x != -1, sols))\n    if sols: return sorted(sols)[0]\n    else: return -1\n\n\nprint(solution([], counts))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=len_f:\n      index_i=len_f-k\nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(len_f,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nK = input()\ncounts = np.array(list(map(int, input().split())))\n\n\ndef subtract_count(counts: np.ndarray):\n    if counts.max() == 1: block = np.ones_like(counts)\n    else: block = (counts == counts.max()).astype(int) + 1\n    return counts - block, block\n\n\ndef block_to_str(block):\n    arange = np.arange(1, len(block) + 1)\n    if block.max() == 1: return \" \".join(map(str, arange))\n    twice = list(arange[block == block.max()])\n    once = list(arange[block != block.max()])\n    return \" \".join(map(str, twice + once + twice))\n\n\ndef greedy_solution(counts):\n    blocks = []\n    while counts.max() > 0:\n        counts, block = subtract_count(counts)\n        blocks.append(block)\n    # print(blocks, counts)\n    if counts.min() < 0:\n        return -1\n    sorted_strs = sorted([block_to_str(block) for block in blocks])\n    return \" \".join(sorted_strs)\n\n\ndef solution(counts):\n    candidates = []\n    candidates.append(greedy_solution(counts))\n    alt = np.ones_like(counts)\n    alt[0] = 2\n    alts = [alt]\n    for alt in alts:\n        alt = np.array(alt)\n        sol = greedy_solution(counts - alt)\n        if sol == -1:\n            continue\n        candidates.append(block_to_str(alt) + \" \" + sol)\n    return sorted(candidates)[0]\n\n\nprint(solution(counts))"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    if k == 1:\n        return [1] * aaa[0]\n\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a1 = max(aaa[1:])\n        max_a = max(aaa[0], max_a1)\n\n        if min_a <= 0:\n            assert max_a == 0\n            break\n\n        if (min_a - 1) * 2 < max_a - 1:\n            must_use = [i for i, a in enumerate(aaa) if a - 1 > (min_a - 1) * 2]\n            next_max = max_a - 2\n        elif (aaa[0] - 2) * 2 >= max_a1 - 1:\n            must_use = []\n            next_max = max(aaa[0] - 2, max_a1 - 1)\n        else:\n            ans.extend(range(1, k + 1))\n            for i in range(k):\n                aaa[i] -= 1\n            continue\n\n        can_use = []\n        cant_use = []\n\n        for i in range(k):\n            if i in must_use:\n                pass\n            elif (aaa[i] - 2) * 2 >= next_max:\n                can_use.append(i)\n            else:\n                cant_use.append(i)\n\n        double = []\n        if len(must_use) == 0:\n            double.append(can_use[0] + 1)\n        else:\n            max_use = must_use[-1]\n            use = must_use + can_use\n            use.sort()\n            double = [i + 1 for i in use if i <= max_use]\n        single = [i for i in range(1, k + 1) if i not in double]\n\n        for i in double:\n            aaa[i - 1] -= 2\n        for i in single:\n            aaa[i - 1] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef solve(k, aaa):\n    min_a = min(aaa)\n    max_a = max(aaa)\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while True:\n        min_a = min(aaa)\n        max_a = max(aaa)\n\n        if min_a == 0:\n            assert max_a == 0\n            break\n\n        if aaa[0] == min_a and min_a * 2 - 1 == max_a:\n            ans.extend(range(1, k + 1))\n            for i in range(k):\n                aaa[i] -= 1\n            continue\n\n        next_max = max_a - (1 if min_a * 2 > max_a else 2)\n\n        must_use = []\n        can_use = []\n        cant_use = []\n        for i in range(k):\n            if min_a * 2 == aaa[i]:\n                must_use.append(i)\n            elif (aaa[i] - 2) * 2 >= next_max:\n                can_use.append(i)\n            else:\n                cant_use.append(i)\n\n        double = []\n        if len(must_use) == 0:\n            double.append(can_use[0] + 1)\n        else:\n            max_use = must_use[-1]\n            use = must_use + can_use\n            use.sort()\n            double = [i + 1 for i in use if i <= max_use]\n        single = [i for i in range(1, k + 1) if i not in double]\n\n        for i in double:\n            aaa[i - 1] -= 2\n        for i in single:\n            aaa[i - 1] -= 1\n\n        ans.extend(double)\n        ans.extend(single)\n        ans.extend(double)\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nK = input()\ncounts = np.array(list(map(int, input().split())))\n\nget_bin = lambda x, n: format(x, 'b').zfill(n)\n\n\ndef get_block_list(counts: np.ndarray):\n    if counts.max() - counts.min() == 0: return [np.ones_like(counts)]\n    blocks = [(counts == counts.max()).astype(int) + 1]\n    if counts.max() - counts.min() > 1: return blocks\n    # indices = np.arange(len(counts))[counts == counts.max()]\n    # blocks = []\n    # for i in range(2 ** len(indices)):\n    #     block = np.ones_like(counts)\n    #     binary = get_bin(i, len(indices))\n    #     for k, j in enumerate(indices):\n    #         block[j] += int(binary[k])\n    #     blocks.append(block)\n    return blocks\n\n\ndef block_to_str(block):\n    arange = np.arange(1, len(block) + 1)\n    if block.max() == 1: return \" \".join(map(str, arange))\n    twice = list(arange[block == block.max()])\n    once = list(arange[block != block.max()])\n    return \" \".join(map(str, twice + once + twice))\n\n\ndef solution(block_list, counts):\n    if counts.min() < 0:\n        return -1\n    if counts.max() == 0:\n        sorted_strs = sorted([block_to_str(block) for block in block_list])\n        return \" \".join(sorted_strs)\n    blocks = get_block_list(counts)\n    sols = [solution(block_list + [block], counts - block) for block in blocks]\n    sols = list(filter(lambda x: x != -1, sols))\n    if sols: return sorted(sols)[0]\n    else: return -1\n\n\nprint(solution([], counts))"
  },
  {
    "language": "Python",
    "code": "K = int(input())\nA = [int(a) for a in input().split()]\nm = min(A)\nif max(A) > m * 2:\n    print(-1)\n    exit()\nL = [i for i in range(K) if A[i] == m]\nX = [[[], L[:], []]  for _ in range(m)]\nL = [i for i in range(K)[::-1] if A[i] != m]\n\ndef ins(li, v):\n    for j, l in enumerate(li):\n        if l > v:\n            li.append(li[-1])\n            for k in range(j + 1, len(li) - 1)[::-1]:\n                li[k] = li[k-1]\n            li[j] = v\n            break\n    else:\n        li.append(v)\n\nfor l in L:\n    c = A[l]\n    for i in range(m):\n        if c == m - i:\n            ins(X[i][1], l)\n            c -= 1\n        elif c == (m - i) * 2:\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        elif len(X[i][0]) and l < X[i][0][-1]:\n            ins(X[i][1], l)\n            c -= 1\n        elif l < (X[i+1][0][0] if len(X[i+1][0]) else X[i+1][1][0]):\n            ins(X[i][0], l)\n            ins(X[i][2], l)\n            c -= 2\n        else:\n            ins(X[i][1], l)\n            c -= 1\n\nANS = []\nfor i in range(m):\n    for j in range(3):\n        for k in range(len(X[i][j])):\n            ANS.append(X[i][j][k] + 1)\nprint(*ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heapreplace\nfrom itertools import chain\n\n\ndef solve(k, aaa):\n    aaa_idx = [(-a, i) for i, a in enumerate(aaa, start=1)]\n    aaa_idx.sort()\n    min_a = -aaa_idx[-1][0]\n    max_a = -aaa_idx[0][0]\n    if min_a * 2 < max_a:\n        return [-1]\n\n    ans = []\n    while min_a:\n        double = set()\n\n        while True:\n            while aaa[aaa_idx[0][1] - 1] != -aaa_idx[0][0]:\n                heapreplace(aaa_idx, (-aaa[aaa_idx[0][1] - 1], aaa_idx[0][1]))\n            if (min_a - 1) * 2 < (-aaa_idx[0][0] - 1):\n                a, i = aaa_idx[0]\n                double.add(i)\n                aaa[i - 1] -= 2\n                heapreplace(aaa_idx, (a + 2, i))\n            else:\n                break\n\n        max_a = -aaa_idx[0][0]\n        if len(double) == 0:\n            max_a -= 1\n\n        if 1 not in double and (aaa[0] - 2) * 2 >= max_a:\n            double.add(1)\n            aaa[0] -= 2\n\n        double_sorted = sorted(double)\n\n        ans.extend(double_sorted)\n        for i in range(1, k + 1):\n            if i in double:\n                continue\n            ans.append(i)\n            aaa[i - 1] -= 1\n        ans.extend(double_sorted)\n\n        min_a = min(min_a - 1, aaa[0])\n\n    return ans\n\n\nk, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(*solve(k, aaa))\n"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  if temp1 + temp0 < temp3 + temp2:\n    for l in range(len_f,sum_a-len_e):\n      p[l]=fronts[index_i]\n      index_i+=1\n      if index_i >=len_f:\n        index_i=len_f-k\n  else:\n    index_i=len_e-k\n    for l in range(len_e,sum_a-len_e):\n      p[l]=ends[index_i]\n      index_i+=1\n      if index_i >=len_e:\n        index_i=len_e-k  \nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  if sum(temp1) < sum(temp3):\n    for l in range(len_f,sum_a-len_e):\n      p[l]=fronts[index_i]\n      index_i+=1\n      if index_i >=len_f:\n        index_i=len_f-k\n  else:\n    index_i=0\n    for l in range(len_e,sum_a-len_e):\n      p[l]=ends[index_i]\n      index_i+=1\n      if index_i >=len_e:\n        index_i=0  \nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Python",
    "code": "k=int(input())\na=list(map(int,input().split()))\nsum_a=sum(a)\nmax_a=max(a)\nmin_a=min(a)\nif max_a>min_a+2:\n  print(-1)\n  exit()\np=[None]*sum_a\ntemp0=[]\ntemp1=[]\nif max_a == min_a+2:\n  for i in range(k):\n    if a[i] ==max_a:\n      temp0.append(i+1)\n    else:\n      temp1.append(i+1)\n  fronts=(temp0+temp1+temp0)\n  #print(fronts)\n  len_f=len(fronts)\n  p[:len_f]=fronts\n  temp2=[]\n  temp3=[]\n  for j in range(k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=len_f-k\n  if sum(temp1) < sum(temp3):\n    for l in range(len_f,sum_a-len_e):\n      p[l]=fronts[index_i]\n      index_i+=1\n      if index_i >=len_f:\n        index_i=len_f-k\n  else:\n    index_i=len_e-k\n    for l in range(len_e,sum_a-len_e):\n      p[l]=ends[index_i]\n      index_i+=1\n      if index_i >=len_e:\n        index_i=len_e-k  \nelif max_a==min_a:\n  fronts=[i for i in range(1,k+1)]\n  index_i=0\n  p=fronts*min_a\nelse:\n  fronts=[i for i in range(1,k+1)]\n  #print(fronts)\n  p[:k]=fronts\n  temp2=[i for i in range(1,k//2+1)]\n  temp3=[]\n  for j in range(k//2,k):\n    if a[j] ==min_a:\n      temp2.append(j+1)\n    else:\n      temp3.append(j+1)\n  ends=(temp3+temp2+temp3)\n  #print(ends)\n  len_e=len(ends)\n  p[-len_e:]=ends\n  index_i=0\n  for l in range(k,sum_a-len_e):\n    p[l]=fronts[index_i]\n    index_i+=1\n    if index_i >=k:\n      index_i=0\nprint(\" \".join((str(x) for x in p)))"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input,fastout};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    }\n    else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i-1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i-1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i-1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j+1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    }\n    else {\n        true\n    }\n}\n\n\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n    /*let mut now: Vec<usize> = make_seq(&a);\n    let n: usize = now.len();\n    for i in 0..(n-1) {\n        print!(\"{} \", now[i]);\n    }\n    println!(\"{}\", now[n-1]);*/\n\n    loop{\n        if !ok(&a) {\n            let n: usize = ans.len();\n            let b: usize = ans[n-k];\n            ans.push(b);\n            a[b-1] -= 1;\n            num += 1;\n        }\n        else {\n            let mut now: Vec<usize> = make_seq(&a);\n            if ans.len() == 0 {\n                ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n                num += k;\n            }\n            else {\n                let n: usize = ans.len();\n                let b: usize = ans[n-k];\n                let mut c = a.clone();\n                c[b-1] -= 1;\n                if (ok(&a) && now[0] < b) || !ok(&c) {\n                    ans.append(&mut now);\n                    for i in 0..k {\n                        a[i] -= 1;\n                    }\n                    num += k;\n                }\n                else {\n                    ans.push(b);\n                    a[b-1] -= 1;\n                    num += 1;\n                }\n            }\n        }\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all-1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all-1]);\n    \n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\nfn vecmax(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n    }\n    mx\n}\n\nfn vecmin(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mn = cmp::min(mn, v[i]);\n    }\n    mn\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mx: usize = vecmax(&a);\n    let mn: usize = vecmin(&a);\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(all);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::with_capacity(k+1);\n            let mut flag: bool;\n            for i in 0..(k-1) {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if ok(&c) {\n                    v_tmp.sort();\n                    v.push(v_tmp);\n                }\n                else {//\n                    let cmx: usize = vecmax(&c);\n                    let cmn: usize = vecmin(&c);\n\n                    if cmx == cmn * 2 + 1 {\n                        let mut v_tmp2: Vec<usize> = Vec::with_capacity(k);\n                        for j in (i+1)..k {\n                            v_tmp2.push(ans[n - k + j]);\n                        }\n                        let mut j: usize = 0;\n                        for i in 1..=k {\n                            if c[i - 1] == cmx {\n                                j = i;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] != cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] == cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        if j < k {\n                            for i in (j + 1)..=k {\n                                if v_tmp.contains(&i) {\n                                    v_tmp2.push(i);\n                                }\n                            }\n                        }\n                        let mut lastcmx: usize = 0;\n                        let mut firstcmn: usize = 0;\n                        for i in 0..k {\n                            if c[v_tmp2[i]-1] == cmx {\n                                lastcmx = i;\n                            }\n                        }\n                        for i in 0..k {\n                            if c[v_tmp2[i]-1] == cmn {\n                                firstcmn = i;\n                                break;\n                            }\n                        }\n                        if lastcmx < firstcmn {\n                            for _ in (i+1)..k {\n                                v_tmp2.remove(0);\n                            }\n                            v.push(v_tmp2);\n                        }\n                    }\n                }\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        \n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::new();\n            let mut flag: bool;\n            for i in 0..k {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                /*if !ok(&c) {\n                    continue;\n                }*/\n                v_tmp.sort();\n                v.push(v_tmp);\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        \n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::new();\n            let mut flag: bool;\n            for i in 0..k {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if !ok(&c) {\n                    continue;\n                }\n                v_tmp.sort();\n                v.push(v_tmp);\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        \n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n            num += k;\n        }\n        else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::new();\n            let mut flag: bool;\n            for i in 0..k {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n-k+j]);\n                    if a[ans[n-k+j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n-k+j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if !ok(&c) {\n                    continue;\n                }\n                v_tmp.sort();\n                v.push(v_tmp);\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n\n        /*\n        if !ok(&a) {\n            let n: usize = ans.len();\n            let b: usize = ans[n - k];\n            ans.push(b);\n            a[b - 1] -= 1;\n            num += 1;\n        } else {\n            let mut now: Vec<usize> = make_seq(&a);\n            if ans.len() == 0 {\n                ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n                num += k;\n            } else {\n                let n: usize = ans.len();\n                let b: usize = ans[n - k];\n                let mut c = a.clone();\n                c[b - 1] -= 1;\n                if (ok(&a) && now[0] < b) || !ok(&c) {\n                    ans.append(&mut now);\n                    for i in 0..k {\n                        a[i] -= 1;\n                    }\n                    num += k;\n                } else {\n                    ans.push(b);\n                    a[b - 1] -= 1;\n                    num += 1;\n                }\n            }\n        }\n        */\n\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let mx: usize = vecmax(&v);\n    let mn: usize = vecmin(&v);\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\nfn vecmax(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n    }\n    mx\n}\n\nfn vecmin(v: &Vec<usize>) -> usize {\n    let n = v.len();\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mn = cmp::min(mn, v[i]);\n    }\n    mn\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mx: usize = vecmax(&a);\n    let mn: usize = vecmin(&a);\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(all);\n\n    let mut num: usize = 0;\n\n    loop {\n        if ans.len() == 0 {\n            let mut now: Vec<usize> = make_seq(&a);\n            ans.append(&mut now);\n            for i in 0..k {\n                a[i] -= 1;\n            }\n            num += k;\n        } else {\n            let n: usize = ans.len();\n            let mut v: Vec<Vec<usize>> = Vec::with_capacity(k + 1);\n            let mut flag: bool;\n            for i in 0..(k - 1) {\n                let mut v_tmp: Vec<usize> = Vec::with_capacity(k);\n                let mut c = a.clone();\n                flag = false;\n                for j in 0..=i {\n                    v_tmp.push(ans[n - k + j]);\n                    if a[ans[n - k + j] - 1] == 0 {\n                        flag = true;\n                        break;\n                    }\n                    c[ans[n - k + j] - 1] -= 1;\n                }\n                if flag {\n                    continue;\n                }\n                if ok(&c) {\n                    v_tmp.sort();\n                    v.push(v_tmp);\n                } else {\n                    //\n                    let cmx: usize = vecmax(&c);\n                    let cmn: usize = vecmin(&c);\n\n                    if cmx == cmn * 2 + 1 {\n                        let mut v_tmp2: Vec<usize> = Vec::with_capacity(k);\n                        for j in (i + 1)..k {\n                            v_tmp2.push(ans[n - k + j]);\n                        }\n                        let mut j: usize = 0;\n                        for i in 1..=k {\n                            if c[i - 1] == cmx {\n                                j = i;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] != cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        for i in 1..=k {\n                            if c[i - 1] == cmn && v_tmp.contains(&i) {\n                                v_tmp2.push(i);\n                            }\n                            if i == j {\n                                break;\n                            }\n                        }\n                        if j < k {\n                            for i in (j + 1)..=k {\n                                if v_tmp.contains(&i) {\n                                    v_tmp2.push(i);\n                                }\n                            }\n                        }\n                        let mut lastcmx: usize = 0;\n                        let mut firstcmn: usize = 0;\n                        for i in 0..k {\n                            if c[v_tmp2[i] - 1] == cmx {\n                                lastcmx = i;\n                            }\n                        }\n                        for i in 0..k {\n                            if c[v_tmp2[i] - 1] == cmn {\n                                firstcmn = i;\n                                break;\n                            }\n                        }\n                        if lastcmx < firstcmn {\n                            for _ in (i + 1)..k {\n                                v_tmp2.remove(0);\n                            }\n                            v.push(v_tmp2);\n                        }\n                    }\n                }\n            }\n            if ok(&a) {\n                let now: Vec<usize> = make_seq(&a);\n                v.push(now);\n            }\n            v.sort();\n            let mut w = v[0].clone();\n            ans.append(&mut w);\n            let m: usize = v[0].len();\n            for i in 0..m {\n                a[v[0][i] - 1] -= 1;\n            }\n            num += m;\n        }\n\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{fastout, input};\nuse std::cmp;\n\nfn make_seq(v: &Vec<usize>) -> Vec<usize> {\n    let n = v.len();\n    let mut u: Vec<usize> = Vec::new();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx < mn * 2 {\n        for i in 1..=n {\n            u.push(i);\n        }\n    } else {\n        let mut j: usize = 0;\n        for i in 1..=n {\n            if v[i - 1] == mx {\n                j = i;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] != mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        for i in 1..=n {\n            if v[i - 1] == mn {\n                u.push(i);\n            }\n            if i == j {\n                break;\n            }\n        }\n        if j < n {\n            for i in (j + 1)..=n {\n                u.push(i);\n            }\n        }\n    }\n    u\n}\n\nfn ok(v: &Vec<usize>) -> bool {\n    let n = v.len();\n    let mut mx: usize = v[0];\n    let mut mn: usize = v[0];\n    for i in 1..n {\n        mx = cmp::max(mx, v[i]);\n        mn = cmp::min(mn, v[i]);\n    }\n    if mx > 2 * mn {\n        false\n    } else {\n        true\n    }\n}\n\n#[fastout]\nfn main() {\n    input! {\n        k: usize,\n        mut a: [usize; k],\n    }\n\n    //\n    let mut mx: usize = a[0];\n    let mut mn: usize = a[0];\n\n    for i in 1..k {\n        mx = cmp::max(mx, a[i]);\n        mn = cmp::min(mn, a[i]);\n    }\n\n    //\n    if mx > 2 * mn {\n        println!(\"{}\", -1);\n        return;\n    }\n\n    let mut all: usize = 0;\n    for i in 0..k {\n        all += a[i];\n    }\n\n    let mut ans: Vec<usize> = Vec::with_capacity(1010);\n\n    let mut num: usize = 0;\n\n\n    loop {\n        if !ok(&a) {\n            let n: usize = ans.len();\n            let b: usize = ans[n - k];\n            ans.push(b);\n            a[b - 1] -= 1;\n            num += 1;\n        } else {\n            let mut now: Vec<usize> = make_seq(&a);\n            if ans.len() == 0 {\n                ans.append(&mut now);\n                for i in 0..k {\n                    a[i] -= 1;\n                }\n                num += k;\n            } else {\n                let n: usize = ans.len();\n                let b: usize = ans[n - k];\n                let mut c = a.clone();\n                c[b - 1] -= 1;\n                if (ok(&a) && now[0] < b) || !ok(&c) {\n                    ans.append(&mut now);\n                    for i in 0..k {\n                        a[i] -= 1;\n                    }\n                    num += k;\n                } else {\n                    ans.push(b);\n                    a[b - 1] -= 1;\n                    num += 1;\n                }\n            }\n        }\n        if all == num {\n            break;\n        }\n    }\n\n    for i in 0..(all - 1) {\n        print!(\"{} \", ans[i]);\n    }\n    println!(\"{}\", ans[all - 1]);\n}\n"
  }
]