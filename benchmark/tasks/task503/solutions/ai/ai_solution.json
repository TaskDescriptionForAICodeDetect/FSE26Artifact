[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nint H, W, N;\nint land[MAX_H][MAX_W];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculate_area(int r1, int c1, int r2, int c2) {\n    int area = 0;\n    for (int r = r1; r <= r2; r++) {\n        for (int c = c1; c <= c2; c++) {\n            area += land[r][c];\n        }\n    }\n    return area;\n}\n\nint solve() {\n    int max_min_area = 0;\n    \n    for (int r1 = 0; r1 < H; r1++) {\n        for (int c1 = 0; c1 < W; c1++) {\n            for (int r2 = r1; r2 < H; r2++) {\n                for (int c2 = c1; c2 < W; c2++) {\n                    int current_areas[MAX_H];\n                    int min_area = INT_MAX;\n                    \n                    current_areas[0] = calculate_area(r1, c1, r2, c2);\n                    \n                    for (int k = 1; k < N; k++) {\n                        int best_area = 0;\n                        for (int nr1 = 0; nr1 < H; nr1++) {\n                            for (int nc1 = 0; nc1 < W; nc1++) {\n                                for (int nr2 = nr1; nr2 < H; nr2++) {\n                                    for (int nc2 = nc1; nc2 < W; nc2++) {\n                                        int overlap = 0;\n                                        for (int pr = 0; pr < k; pr++) {\n                                            if ((nr1 <= r2 && nr2 >= r1 && nc1 <= c2 && nc2 >= c1)) {\n                                                overlap = 1;\n                                                break;\n                                            }\n                                        }\n                                        \n                                        if (!overlap) {\n                                            int area = calculate_area(nr1, nc1, nr2, nc2);\n                                            best_area = min(best_area, area);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        current_areas[k] = best_area;\n                        min_area = min(min_area, best_area);\n                    }\n                    \n                    max_min_area = min(max_min_area, min_area);\n                }\n            }\n        }\n    }\n    \n    return max_min_area;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &N);\n    \n    for (int r = 0; r < H; r++) {\n        for (int c = 0; c < W; c++) {\n            scanf(\"%d\", &land[r][c]);\n        }\n    }\n    \n    int result = solve();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, w, h;\n} Rectangle;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculateMinInheritance(int H, int W, int N, Rectangle* rects) {\n    int minArea = H * W;\n    for (int i = 0; i < N; ++i) {\n        int area = rects[i].w * rects[i].h;\n        if (area < minArea) {\n            minArea = area;\n        }\n    }\n    return minArea;\n}\n\nvoid divideLand(int H, int W, int N, Rectangle* rects) {\n    if (N == 1) {\n        rects[0].x = 0;\n        rects[0].y = 0;\n        rects[0].w = W;\n        rects[0].h = H;\n        return;\n    }\n\n    int bestMin = 0;\n    Rectangle* bestRects = malloc(N * sizeof(Rectangle));\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            if (i * j > N) continue;\n\n            int rows = i;\n            int cols = j;\n            int remaining = N - i * j;\n\n            if (remaining < 0) continue;\n\n            int hSplit = H / i;\n            int wSplit = W / j;\n\n            for (int k = 0; k < i * j; ++k) {\n                int row = k / j;\n                int col = k % j;\n                rects[k].x = col * wSplit;\n                rects[k].y = row * hSplit;\n                rects[k].w = (col == j - 1) ? W - col * wSplit : wSplit;\n                rects[k].h = (row == i - 1) ? H - row * hSplit : hSplit;\n            }\n\n            int currentMin = calculateMinInheritance(H, W, i * j, rects);\n            if (currentMin > bestMin) {\n                bestMin = currentMin;\n                for (int k = 0; k < i * j; ++k) {\n                    bestRects[k] = rects[k];\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        rects[i] = bestRects[i];\n    }\n    free(bestRects);\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    Rectangle* rects = malloc(N * sizeof(Rectangle));\n    divideLand(H, W, N, rects);\n\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d %d %d %d\\n\", rects[i].x, rects[i].y, rects[i].w, rects[i].h);\n    }\n\n    free(rects);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    int max_min_area = 0;\n    for (int h = 1; h <= H; ++h) {\n        int max_w = N / h;\n        if (max_w == 0) continue;\n        int w = min(W, max_w);\n        int area = h * w;\n        if (area > max_min_area) {\n            max_min_area = area;\n        }\n    }\n    \n    for (int w = 1; w <= W; ++w) {\n        int max_h = N / w;\n        if (max_h == 0) continue;\n        int h = min(H, max_h);\n        int area = h * w;\n        if (area > max_min_area) {\n            max_min_area = area;\n        }\n    }\n    \n    cout << max_min_area << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LandDivision {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        \n        int maxMinArea = (H * W) / N;\n        List<int[]> divisions = new ArrayList<>();\n        \n        int remaining = H * W;\n        int assigned = 0;\n        \n        for (int i = 0; i < N; i++) {\n            int area = Math.min(maxMinArea, remaining - (N - i - 1));\n            if (area <= 0) {\n                area = 1;\n            }\n            \n            int h = (int) Math.sqrt(area);\n            while (area % h != 0) {\n                h--;\n            }\n            int w = area / h;\n            \n            divisions.add(new int[]{h, w});\n            remaining -= area;\n            assigned += area;\n        }\n        \n        for (int[] rect : divisions) {\n            System.out.println(rect[0] + \" \" + rect[1]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:57:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LandInheritance {\n    public static double maximizeMinInheritance(int H, int W, int N) {\n        double left = 0, right = H * W;\n        \n        while (right - left > 1e-6) {\n            double mid = (left + right) / 2;\n            if (canDivide(H, W, N, mid)) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return left;\n    }\n    \n    private static boolean canDivide(int H, int W, int N, double minArea) {\n        int count = 0;\n        \n        for (int h1 = 0; h1 < H; h1++) {\n            for (int h2 = h1; h2 < H; h2++) {\n                for (int w1 = 0; w1 < W; w1++) {\n                    for (int w2 = w1; w2 < W; w2++) {\n                        double area = (h2 - h1 + 1) * (w2 - w1 + 1);\n                        if (area >= minArea) {\n                            count++;\n                        }\n                        \n                        if (count >= N) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int N = scanner.nextInt();\n        \n        double result = maximizeMinInheritance(H, W, N);\n        System.out.printf(\"%.6f\\n\", result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:57:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nbool canDivideLand(int H, int W, int N, int minArea) {\n    vector<vector<bool>> used(H, vector<bool>(W, false));\n    \n    for (int bro = 0; bro < N; bro++) {\n        bool found = false;\n        for (int r1 = 0; r1 < H && !found; r1++) {\n            for (int c1 = 0; c1 < W && !found; c1++) {\n                if (used[r1][c1]) continue;\n                \n                for (int r2 = r1; r2 < H; r2++) {\n                    for (int c2 = c1; c2 < W; c2++) {\n                        int area = (r2 - r1 + 1) * (c2 - c1 + 1);\n                        \n                        if (area < minArea) continue;\n                        \n                        bool valid = true;\n                        for (int r = r1; r <= r2; r++) {\n                            for (int c = c1; c <= c2; c++) {\n                                if (used[r][c]) {\n                                    valid = false;\n                                    break;\n                                }\n                            }\n                            if (!valid) break;\n                        }\n                        \n                        if (valid) {\n                            for (int r = r1; r <= r2; r++) {\n                                for (int c = c1; c <= c2; c++) {\n                                    used[r][c] = true;\n                                }\n                            }\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (found) break;\n                }\n            }\n        }\n        \n        if (!found) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    int left = 0, right = H * W / N;\n    int result = 0;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (canDivideLand(H, W, N, mid)) {\n            result = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_min_inheritance_value(N, H, W):\n    def can_divide(min_value):\n        from collections import defaultdict\n        \n        dp = defaultdict(lambda: False)\n        dp[0, 0] = True\n        \n        for _ in range(N):\n            new_dp = dp.copy()\n            for x1 in range(W):\n                for x2 in range(x1 + 1, W + 1):\n                    for y1 in range(H):\n                        for y2 in range(y1 + 1, H + 1):\n                            rect_value = (x2 - x1) * (y2 - y1)\n                            if rect_value >= min_value:\n                                for (claimed_x, claimed_y), valid in dp.items():\n                                    if valid and claimed_x <= x1 and claimed_y <= y1:\n                                        new_dp[x2, y2] = True\n            dp = new_dp\n        \n        return dp[W, H]\n    \n    lo, hi = 0, H * W // N\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if can_divide(mid):\n            lo = mid\n        else:\n            hi = mid - 1\n    \n    return lo\n\n# Example usage:\nN = 3\nH = 5\nW = 5\nprint(max_min_inheritance_value(N, H, W))",
    "timestamp": "2025-08-13 08:13:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class LandInheritance {\n\n    public static void main(String[] args) {\n        int H = 4, W = 5, N = 2; // Example values for H, W, and N\n        System.out.println(maximizeMinimumShare(H, W, N));\n    }\n\n    public static int maximizeMinimumShare(int H, int W, int N) {\n        int low = 0;\n        int high = H * W;\n        \n        while (low < high) {\n            int mid = low + (high - low + 1) / 2;\n            if (canDivide(H, W, N, mid)) {\n                low = mid;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return low;\n    }\n    \n    private static boolean canDivide(int H, int W, int N, int minSize) {\n        int[][] dp = new int[H + 1][W + 1];\n        \n        for (int h = 1; h <= H; h++) {\n            for (int w = 1; w <= W; w++) {\n                dp[h][w] = Math.max(dp[h - 1][w], dp[h][w - 1]);\n\n                for (int i = 1; i <= h; i++) {\n                    for (int j = 1; j <= w; j++) {\n                        int size = (h - i + 1) * (w - j + 1);\n                        if (size >= minSize) {\n                            dp[h][w] = Math.max(dp[h][w], dp[i - 1][w] + dp[h][j - 1] + 1);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[H][W] >= N;\n    }\n}",
    "timestamp": "2025-08-13 08:13:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N, H, W;\n    scanf(\"%d %d %d\", &N, &H, &W);\n\n    int maxMinValue = 0;\n\n    // Check all possible dimensions for each brother's plot,\n    // given the constraints of not overlapping and forming single rectangles\n    for (int h = 1; h <= H; ++h) {\n        for (int w = 1; w <= W; ++w) {\n            int numRows = H / h;\n            int numCols = W / w;\n            if (numRows * numCols < N) continue; // Check if this division can accommodate all brothers\n            \n            int totalPlots = numRows * numCols;\n            int remainderPlots = totalPlots - N;\n\n            // Calculate the minimum possible value a brother can get with this division\n            int currentMinValue = h * w;\n            if (remainderPlots >= numCols) { \n                // If we can make another full row, adjust the min value accordingly\n                currentMinValue = (h + (remainderPlots / numCols)) * w;\n            }\n            \n            maxMinValue = max(maxMinValue, currentMinValue);   \n        }\n    }\n\n    printf(\"%d\\n\", maxMinValue);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:13:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_divide_land(H, W, N):\n    def is_valid_division(area):\n        brothers_with_land = 0\n        current_area = 0\n        \n        for x in range(H):\n            for y in range(W):\n                if current_area >= area:\n                    brothers_with_land += 1\n                    current_area = 0\n                \n                current_area += 1\n        \n        if current_area >= area:\n            brothers_with_land += 1\n        \n        return brothers_with_land >= N\n\n    total_area = H * W\n    left, right = 0, total_area\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        \n        if is_valid_division(mid):\n            left = mid\n        else:\n            right = mid - 1\n    \n    return left\n\ndef main():\n    H, W, N = map(int, input().split())\n    result = can_divide_land(H, W, N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:13:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N, H, W = map(int, sys.stdin.readline().split())\n    \n    max_min_area = 0\n    \n    # The optimal solution is to divide the land into N equal or nearly equal rectangles\n    # The best way to maximize the minimum area is to split H and W into factors closest to sqrt(N)\n    \n    # Find the best split for rows (h_split) and columns (w_split)\n    best_h = 1\n    best_w = N\n    min_diff = abs(N - 1)\n    \n    for h_split in range(1, int(N**0.5) + 1):\n        if N % h_split == 0:\n            w_split = N // h_split\n            current_diff = abs(h_split - w_split)\n            if current_diff < min_diff:\n                min_diff = current_diff\n                best_h = h_split\n                best_w = w_split\n    \n    # Now split H into best_h parts and W into best_w parts\n    h_step = H // best_h\n    w_step = W // best_w\n    \n    max_min_area = h_step * w_step\n    print(max_min_area)\n\nsolve()",
    "timestamp": "2025-08-13 08:13:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n\n    vector<vector<int>> dp(H+1, vector<int>(W+1, 0));\n\n    for (int i = 1; i <= N; ++i) {\n        vector<vector<int>> new_dp = dp;\n\n        for (int x1 = 1; x1 <= H; ++x1) {\n            for (int y1 = 1; y1 <= W; ++y1) {\n                for (int x2 = x1; x2 <= H; ++x2) {\n                    for (int y2 = y1; y2 <= W; ++y2) {\n                        int area = (x2 - x1 + 1) * (y2 - y1 + 1);\n                        new_dp[x2][y2] = max(new_dp[x2][y2], dp[x1-1][y1-1] + area);\n                    }\n                }\n            }\n        }\n\n        dp.swap(new_dp);\n    }\n\n    cout << dp[H][W] / N << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:43:58"
  }
]