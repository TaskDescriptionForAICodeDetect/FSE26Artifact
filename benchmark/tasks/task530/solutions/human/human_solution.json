[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val Array(h, w, s, t) = readLine.trim.split(' ')\n  val state = Array.tabulate(h.toInt){_ ⇒ readLine.trim}\n  val nodes = Array.tabulate(26){id ⇒ new Node(id)}\n  val indices = Array.tabulate(26){i ⇒ i}.flatMap{i ⇒\n    (0 until h.toInt).flatMap{y ⇒ (0 until w.toInt).map{x ⇒ Coordinate(x, y)}}.find{coord ⇒ state(coord.y)(coord.x) == ('A' + i)}.map{(_, i)}\n  }\n  for {(posA, i) ← indices\n       (posB, j) ← indices if i != j}{\n    if (posA.x == posB.x){\n      if ((math.min(posA.y, posB.y) + 2 until math.max(posA.y, posB.y) - 1).forall{y ⇒ state(y)(posA.x) == '|'}) {\n        nodes(i).addEdge(nodes(j))\n        nodes(j).addEdge(nodes(i))\n      }\n    }else if (posA.y == posB.y){\n      if ((math.min(posA.x, posB.x) + 2 until math.max(posA.x, posB.x) - 1).forall{x ⇒ state(posA.y)(x) == '-'}){\n        nodes(i).addEdge(nodes(j))\n        nodes(j).addEdge(nodes(i))\n      }\n    }\n  }\n  val minCost = Array.tabulate(26){_ ⇒ Int.MaxValue}.also{arr ⇒ arr(s.head - 'A') = 0}\n  val queue = mutable.PriorityQueue()(Ordering.by[(Int, Int), Int](_._2).reverse).also{que ⇒ que.enqueue((s.head - 'A', 0))}\n  while (queue.nonEmpty){\n    val (top, distance) = queue.dequeue()\n    if (minCost(top) == distance){\n      for (next ← nodes(top).edges){\n        if (minCost(next.id) - distance > 1) {\n          minCost(next.id) = distance + 1\n          queue.enqueue((next.id, minCost(next.id)))\n        }\n      }\n    }\n  }\n  println(\n    minCost(t.head - 'A')\n  )\n\n  case class Coordinate(x: Int, y: Int)\n  class Node(val id: Int){\n    private var mEdges: List[Node] = Nil\n    def addEdge(to: Node): Unit = mEdges ::= to\n    def edges: List[Node] = mEdges\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int64_t\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nnamespace io {\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        io::print_to(os, \", \", \"\\n\", __VA_ARGS__);        \\\n        std::cerr << io::highlight(os.str());             \\\n    } while (0)\n#define dump_(cntnr)                                 \\\n    do {                                             \\\n        std::ostringstream os;                       \\\n        os << __LINE__ << \":\\t\" << #cntnr << \" = [\"; \\\n        io::print_to_(os, \", \", \"]\\n\", all(cntnr));  \\\n        std::cerr << io::highlight(os.str());        \\\n    } while (0)\n#define dumpf(fmt, ...)                             \\\n    do {                                            \\\n        const int N = 4096;                         \\\n        auto b = new char[N];                       \\\n        int l = snprintf(b, N, \"%d:\\t\", __LINE__);  \\\n        snprintf(b + l, N - l, fmt, ##__VA_ARGS__); \\\n        std::cerr << io::highlight(b) << std::endl; \\\n        delete[] b;                                 \\\n    } while (0)\n#else\n#define dump(...)\n#define dump_(...)\n#define dumpf(...)\n#endif\nstd::string highlight(std::string s) {\n#ifdef _MSC_VER\n    return s;\n#else\n    return \"\\033[33m\" + s + \"\\033[0m\";\n#endif\n}\ntemplate <typename T>\nvoid print_to(std::ostream &os, std::string, std::string tail, const T &first) {\n    os << first << tail;\n}\ntemplate <typename F, typename... R>\nvoid print_to(std::ostream &os, std::string del, std::string tail, const F &first,\n              const R &... rest) {\n    os << first << del;\n    print_to(os, del, tail, rest...);\n}\ntemplate <typename I>\nvoid print_to_(std::ostream &os, std::string del, std::string tail, I begin, I end) {\n    for (I it = begin; it != end;) {\n        os << *it;\n        os << (++it != end ? del : tail);\n    }\n}\ntemplate <typename F, typename... R>\nvoid println(const F &first, const R &... rest) {\n    print_to(std::cout, \"\\n\", \"\\n\", first, rest...);\n}\ntemplate <typename F, typename... R>\nvoid print(const F &first, const R &... rest) {\n    print_to(std::cout, \" \", \"\\n\", first, rest...);\n}\ntemplate <typename I>\nvoid println_(I begin, I end) {\n    print_to_(std::cout, \"\\n\", \"\\n\", begin, end);\n}\ntemplate <typename I>\nvoid print_(I begin, I end) {\n    print_to_(std::cout, \" \", \"\\n\", begin, end);\n}\ntemplate <typename C>\nvoid println_(const C &cntnr) {\n    println_(std::begin(cntnr), std::end(cntnr));\n}\ntemplate <typename C>\nvoid print_(const C &cntnr) {\n    print_(std::begin(cntnr), std::end(cntnr));\n}\nint _ = (\n#ifndef LOCAL\n    std::cin.tie(nullptr), std::ios::sync_with_stdio(false),\n#endif\n    std::cout.precision(10), std::cout.setf(std::ios::fixed));\n}\nusing io::print;\nusing io::println;\nusing io::println_;\nusing io::print_;\ntemplate <typename T>\nusing vec = std::vector<T>;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n// const int MOD = 1000000007;\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nstd::vector<Weight> dijkstra(const Graph &g, int s) {\n    const Weight INF = std::numeric_limits<Weight>::max() / 8;\n    using state = std::tuple<Weight, int>;\n    std::priority_queue<state> q;\n    std::vector<Weight> dist(g.size(), INF);\n    dist[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        Weight d;\n        int v;\n        std::tie(d, v) = q.top();\n        q.pop();\n        d *= -1;\n        /* if(v == t) return d; */\n        if (dist[v] < d) continue;\n        for (auto &e : g[v]) {\n            if (dist[e.dst] > dist[v] + e.weight) {\n                dist[e.dst] = dist[v] + e.weight;\n                q.emplace(-dist[e.dst], e.dst);\n            }\n        }\n    }\n    return dist;\n}\n\nint h, w;\nchar s, t;\nvec<string> g;\n\nbool inner(int i, int j) {\n    return !(i < 0 || i >= h || j < 0 || j >= w);\n}\n\nsigned main() {\n    while (cin >> h >> w) {\n        cin >> s >> t;\n        g.resize(h);\n        rep(i, h) {\n            cin >> g[i];\n        }\n\n        Graph graph(26);\n        rep(i, h) rep(j, w) {\n            static const pii dir[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n            if ('A' <= g[i][j] && g[i][j] <= 'Z') {\n                int di, dj;\n                rep(d, 4) {\n                    tie(di, dj) = dir[d];\n                    int ni = i + di;\n                    int nj = j + dj;\n                    while (inner(ni, nj) && !('A' <= g[ni][nj] && g[ni][nj] <= 'Z') && g[ni][nj] != '.') {\n                        ni += di;\n                        nj += dj;\n                    }\n                    if (inner(ni, nj) && 'A' <= g[ni][nj] && g[ni][nj] <= 'Z') {\n                        int a = g[i][j] - 'A';\n                        int b = g[ni][nj] - 'A';\n                        dump(char(a + 'A'), char(b + 'A'));\n                        add_arc(graph, a, b, 1);\n                    }\n                }\n            }\n        }\n\n        auto dist = dijkstra(graph, s - 'A');\n        int ans = dist[t - 'A'];\n        print(ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\t//if(x == 10 && y == 3)printf(\"%c\\n\", c);\n\trep(i,4){\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\ta[y+i][x+j] = a[y][x];\n\t\t\t\tused[y+i][x+j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill((int*)used, (int*)(used+100), 0);\n\trrep(i,h)rrep(j,w){\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\tint x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t\t//printf(\"%c\\n\", y+'A');\n\t}\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", used[i][j]+'A'-1);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nchar fld[55][55];\n\nvint G[26];\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n\nint dist[26];\nconst int INF=1001001001;\nsigned main(){\n    char a,b;\n    cin>>H>>W>>a>>b;\n\n\n    int s=a-'A';\n    int t=b-'A';\n\n    rep(i,H)cin>>fld[i];\n\n\n    rep(i,H)rep(j,W){\n        if(!isupper(fld[i][j]))continue;\n        rep(d,4){\n            int y=i,x=j;\n            while(true){\n                y+=dy[d];\n                x+=dx[d];\n                if(y<0||y>=H||x<0||x>=W)break;\n                if(fld[y][x]=='.')break;\n                if(isupper(fld[y][x])){\n                    G[fld[i][j]-'A'].pb(fld[y][x]-'A');\n                    break;\n                }\n            }\n        }\n    }\n\n\n    fill_n(dist,26,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(dist[u]!=INF)continue;\n            dist[u]=dist[v]+1;\n            que.push(u);\n        }\n    }\n    cout<<dist[t]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint h,w;\nvector<string> mp;\n\nint bfs(char sx,int sy,char goal){\n  vector<vector<int> > D(h,vector<int>(w,INF));\n  \n  queue<P> Q;\n  Q.push(P(sx,sy));\n  D[sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  auto in=[&](int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);};\n  auto go=[&](int x,int y,int i,char ch){\n    while(1){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!in(nx,ny)) return P(-1,-1);\n      \n      if((mp[ny][nx] != ch && !isupper(mp[ny][nx]))) return P(-1,-1);\n      if(isupper(mp[ny][nx])) return P(nx,ny);\n      x = nx;\n      y = ny;\n    }\n  };\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int x = t.first;\n    int y = t.second;\n\n    if(mp[y][x] == goal) return D[y][x];\n    \n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      auto to = go(nx,ny,i,mp[ny][nx]);\n      if(to == P(-1,-1)) continue;\n      tie(nx,ny) = to;\n      if(D[ny][nx] != INF) continue;\n\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(nx,ny));\n    }\n  }\n  assert(0);\n}\n\nsigned main(){\n\n  char s,t;\n  cin>>h>>w>>s>>t;\n  mp.resize(h);\n  cin>>mp;\n\n  int sx,sy;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!isupper(mp[i][j])) continue;\n      mp[i-1][j] = mp[i+1][j] = '|';\n      mp[i][j-1] = mp[i][j+1] = '-';\n      if(mp[i][j] == s) sx = j, sy = i;\n    }\n\n  int ans = bfs(sx,sy,t);\n\n  cout<<ans<<endl;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint H, W, s, t;\nstring A[101];\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nint d[26][26];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> H >> W;\n    char c; cin >> c; s = c - 'A'; cin >> c; t = c - 'A';\n    rep(y, 0, H) cin >> A[y];\n\n    rep(i, 0, 26) rep(j, 0, 26) d[i][j] = inf;\n    rep(i, 0, 26) d[i][i] = 0;\n\n    rep(y, 0, H) rep(x, 0, W) if ('A' <= A[y][x] and A[y][x] <= 'Z') {\n        rep(i, 0, 4) {\n            int xx = x + dx[i];\n            int yy = y + dy[i];\n            while (0 <= xx and xx < W and 0 <= yy and yy < H) {\n                if ('A' <= A[yy][xx] and A[yy][xx] <= 'Z') {\n                    int a = A[y][x] - 'A';\n                    int b = A[yy][xx] - 'A';\n                    d[a][b] = d[b][a] = 1;\n                    break;\n                } else if (A[yy][xx] == '.') break;\n\n                if (i % 2 == 0 and A[yy][xx] == '-') break;\n                if (i % 2 == 1 and A[yy][xx] == '|') break;\n\n                xx += dx[i];\n                yy += dy[i];\n            }\n        }\n    }\n\n    rep(k, 0, 26) rep(i, 0, 26) rep(j, 0, 26) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    cout << d[s][t] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[30];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 30) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            if(!contain(y, x)) continue;\n            if(c[y][x] == '|'){\n                if(j == 2 || j == 3) continue;\n            }\n            if(c[y][x] == '-'){\n                if(j == 1 || j == 0) continue;\n            }\n            while(1){\n                if(!contain(y, x)) break;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    break;\n                }\n                if(c[y][x] == '.') break;\n                y += dy[j];\n                x += dx[j];\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nint di[4] = {1, 0, -1, 0}, dj[4] = {0, 1, 0, -1};\n\nmain {\n  int H, W;\n  char s, t;\n  cin >> H >> W >> s >> t;\n  vector<vector<char>> m(H, vector<char>(W));\n  int S, G;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> m[i][j];\n      if (isupper(m[i][j])) {\n        if (m[i][j] == s) S = i * W + j;\n        if (m[i][j] == t) G = i * W + j;\n        m[i][j] = 'o';\n      }\n    }\n  }\n\n  Graph g(H * W);\n  rep(i, H) rep(j, W) {\n    rep(k, 4) {\n      int i2 = i + di[k], j2 = j + dj[k];\n      if (i2 < 0 || j2 < 0 || i2 >= H || j2 >= W) continue;\n      if (m[i][j] == '-') {\n        if ((k==1||k==3)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '-') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == '|') {\n        if ((k==0||k==2)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == 'o') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        } else if (((k==1||k==3)&&m[i2][j2] == '-') ||((k==0||k==2)&& m[i2][j2] == '|')) {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        }\n      }\n    }\n  }\n  cout << dijkstra(g, S).first[G] / 2 << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <cstdlib>\n#include <unordered_map>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007 \n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define seg_size 524288\nusing namespace std;\nvector<int> vertexs[2000];\nvector<string> mapping;\nint dp[2000] = {};\nint validation(int a, int b) {\n\tint x[8] = { 1,1,1,0,0,-1,-1,-1 };\n\tint y[8] = { 1,0,-1,1,-1,1,0,-1 };\n\tfor (int i = 0; i < 8; ++i) {\n\t\tif(x[i]+a >= 0&&x[i]+a < mapping.size()&&y[i]+b >= 0&&y[i]+b < mapping[0].size()&&mapping[x[i] + a][y[i] + b] >= 'A'&&mapping[x[i] + a][y[i] + b] <= 'Z') return 1;\n\t}\n\treturn 0;\n}\nint main() {\n\tREP(i, 2000) {\n\t\tdp[i] = 1000;\n\t}\n\tint h, w;\n\tcin >> h >> w;\n\tstring a, b;\n\tcin >> a >> b;\n\tfor (int i = 0; i < h; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tmapping.push_back(s);\n\t}\n\tfor (int i = 0; i < h; ++i) {\n\t\tint backing = -1;\n\t\tfor (int q = 0; q < w; ++q) {\n\t\t\tif (mapping[i][q] == '.'||mapping[i][q] == '|') {\n\t\t\t\tbacking = -1;\n\t\t\t}\n\t\t\telse if (mapping[i][q] >= 'A'&&mapping[i][q] <= 'Z') {\n\t\t\t\tint next = mapping[i][q] - 'A';\n\t\t\t\tif (backing != -1) {\n\t\t\t\t\tvertexs[backing].push_back(next);\n\t\t\t\t\tvertexs[next].push_back(backing);\n\t\t\t\t}\n\t\t\t\tbacking = next;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int q = 0; q < w; ++q) {\n\t\tint backing = -1;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tif (mapping[i][q] == '.' || mapping[i][q] == '-') {\n\t\t\t\tbacking = -1;\n\t\t\t}\n\t\t\telse if (mapping[i][q] >= 'A'&&mapping[i][q] <= 'Z') {\n\t\t\t\tint next = mapping[i][q] - 'A';\n\t\t\t\tif (backing != -1) {\n\t\t\t\t\tvertexs[backing].push_back(next);\n\t\t\t\t\tvertexs[next].push_back(backing);\n\t\t\t\t}\n\t\t\t\tbacking = next;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> nexting;\n\tnexting.push(a[0] - 'A');\n\tdp[nexting.front()] = 0;\n\twhile (nexting.empty() == false) {\n\t\tint hoge = nexting.front();\n\t\tnexting.pop();\n\t\tfor (int i = 0; i < vertexs[hoge].size(); ++i) {\n\t\t\tif (dp[vertexs[hoge][i]] > dp[hoge] + 1) {\n\t\t\t\tdp[vertexs[hoge][i]] = dp[hoge] + 1;\n\t\t\t\tnexting.push(vertexs[hoge][i]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[b[0] - 'A'] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  int a = -1;\n  rep(i, 30) {\n    if(pos[i].first != -1) {\n      a = i;\n      break;\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  vector<vint> graph(30);\n  {\n    queue<int>  que;\n    bool used[30] = {};\n    que.push(a);\n    used[a] = true;\n\n    while(!que.empty()) {\n      int u = que.front(); que.pop();\n      rep(i, 4) {\n\tint ny = pos[u].first+dy[i]+dy[i], nx = pos[u].second+dx[i]+dx[i];\n\twhile(in(ny, nx) && (mas[ny][nx] == '|' || mas[ny][nx] == '-')) {\n\t  ny += dy[i];\n\t  nx += dx[i];\n\t}\n\tny += dy[i];\n\tnx += dx[i];\n\tif(!in(ny, nx)) continue;\n\tif(!isalpha(mas[ny][nx])) continue;\n\tint v = mas[ny][nx]-'A';\n\tgraph[u].push_back(v);\n\tif(used[v]) continue;\n\tused[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n  int ss = s-'A', tt = t-'A';\n  queue<int> que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    if(u == tt) break;\n    for(int v : graph[u]) {\n      if(dist[v] == -1) {\n\tdist[v] = dist[u]+1;\n\tque.push(v);\n      }\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 3000;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  rep(i, 4) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (xx<0||yy<0||xx>=W||yy>=H)continue;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        cost[y * W + x][yy * W + xx] = 1;\n      } else if (graph[yy][xx] == '-') {\n        cost[y * W + x][yy * W + xx] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        cost[y * W + x][yy * W + xx] = 1;\n      } else if (graph[yy][xx] == '|') {\n        cost[y * W + x][yy * W + xx] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      cost[y * W + x][yy * W + xx] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        cost[y * W + x][yy * W + xx] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        cost[y * W + x][yy * W + xx] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  rep(i, H) rep(j, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(d[p.second] % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  // rep(i,H) {\n  //   rep(j,W) cout<<d[i*W+j]<<' ';\n  //   cout<<endl;\n  // }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint h,w;\nvector<string> mp;\n\nint bfs(char sx,int sy,char goal){\n  vector<vector<int> > D(h,vector<int>(w,INF));\n  \n  queue<P> Q;\n  Q.push(P(sx,sy));\n  D[sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  auto in=[&](int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);};\n  auto go=[&](int x,int y,int i,char ch){\n    while(1){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!in(nx,ny)) return P(-1,-1);\n      \n      if((mp[ny][nx] != ch && !isupper(mp[ny][nx]))) return P(-1,-1);\n      if(isupper(mp[ny][nx])) return P(nx,ny);\n      x = nx;\n      y = ny;\n    }\n  };\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int x = t.first;\n    int y = t.second;\n\n    if(mp[y][x] == goal) return D[y][x];\n    \n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      auto to = go(nx,ny,i,mp[ny][nx]);\n      if(to == P(-1,-1)) continue;\n      tie(nx,ny) = to;\n      if(D[ny][nx] != INF) continue;\n\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(nx,ny));\n    }\n  }\n  assert(0);\n}\n\nsigned main(){\n\n  char s,t;\n  cin>>h>>w>>s>>t;\n  mp.resize(h);\n  cin>>mp;\n\n  int sx,sy;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!isupper(mp[i][j])) continue;\n      mp[i-1][j] = mp[i+1][j] = '|';\n      mp[i][j-1] = mp[i][j+1] = '-';\n      if(mp[i][j] == s) sx = j, sy = i;\n    }\n\n  int ans = bfs(sx,sy,t);\n\n  cout<<ans<<endl;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_sum_cost,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t\tdir = arg_dir;\n\t}\n\tint row,col,sum_cost;\n\tDIR dir;\n};\n\nint H,W;\nint min_dist[26];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar table[50][51],start[2],goal[2];\nDIR dir_array[4] = {North,East,South,West};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %s %s\",&H,&W,start,goal);\n\n\tint start_row,start_col;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(table[row][col] == start[0]){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++)min_dist[i] = BIG_NUM;\n\n\tqueue<Info> Q;\n\tmin_dist[start[0]-'A'] = 0;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tQ.push(Info(start_row,start_col,0,dir_array[i]));\n\t}\n\n\tint adj_row,adj_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(table[Q.front().row][Q.front().col] == goal[0]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tif(Q.front().dir != dir_array[i])continue; //方向が同じでなければSKIP\n\n\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '.')continue;\n\t\t\t\tif(Q.front().dir == North || Q.front().dir == South){\n\t\t\t\t\tif(table[adj_row][adj_col] == '-')continue;\n\n\t\t\t\t}else{\n\t\t\t\t\tif(table[adj_row][adj_col] == '|')continue;\n\t\t\t\t}\n\n\t\t\t\tif(table[adj_row][adj_col] >= 'A' && table[adj_row][adj_col] <= 'Z'){ //ノードに到着\n\t\t\t\t\tif(min_dist[table[adj_row][adj_col]-'A'] <= Q.front().sum_cost+1)continue;\n\t\t\t\t\tmin_dist[table[adj_row][adj_col]-'A'] = Q.front().sum_cost+1;\n\n\t\t\t\t\tfor(int k = 0; k < 4; k++){ //方向転換\n\t\t\t\t\t\tQ.push(Info(adj_row,adj_col,min_dist[table[adj_row][adj_col]-'A'],dir_array[k]));\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,Q.front().sum_cost,Q.front().dir));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_dist[goal[0]-'A']);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_sum_cost,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t\tdir = arg_dir;\n\t}\n\tint row,col,sum_cost;\n\tDIR dir;\n};\n\nint H,W;\nint min_dist[26];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar table[50][51],start[2],goal[2];\nDIR dir_array[4] = {North,West,East,South};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %s %s\",&H,&W,start,goal);\n\n\tint start_row,start_col;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(table[row][col] == start[0]){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++)min_dist[i] = BIG_NUM;\n\n\tqueue<Info> Q;\n\tmin_dist[start[0]-'A'] = 0;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tQ.push(Info(start_row,start_col,0,dir_array[i]));\n\t}\n\n\tint adj_row,adj_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(table[Q.front().row][Q.front().col] == goal[0]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tif(Q.front().dir != dir_array[i])continue;\n\n\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '.')continue;\n\t\t\t\tif(Q.front().dir == North || Q.front().dir == South){\n\t\t\t\t\tif(table[adj_row][adj_col] == '-')continue;\n\n\t\t\t\t}else{\n\t\t\t\t\tif(table[adj_row][adj_col] == '|')continue;\n\t\t\t\t}\n\n\t\t\t\tif(table[adj_row][adj_col] >= 'A' && table[adj_row][adj_col] <= 'Z'){\n\t\t\t\t\tif(min_dist[table[adj_row][adj_col]-'A'] <= Q.front().sum_cost+1)continue;\n\t\t\t\t\tmin_dist[table[adj_row][adj_col]-'A'] = Q.front().sum_cost+1;\n\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tQ.push(Info(adj_row,adj_col,min_dist[table[adj_row][adj_col]-'A'],dir_array[k]));\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,Q.front().sum_cost,Q.front().dir));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_dist[goal[0]-'A']);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\nconst int M = 1000000007;\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint main() {\n    int h, w;\n    char s, g;\n    cin >> h >> w >> s >> g;\n    int si = -1, sj = -1, gi = -1, gj = -1;\n    vector<string> b(h);\n    for (int i = 0; i < h; ++i) {\n        cin >> b[i];\n        for (int j = 0; j < w; ++j) {\n            if (b[i][j] == s) {\n                si = i;\n                sj = j;\n            }\n            if (b[i][j] == g) {\n                gi = i;\n                gj = j;\n            }\n        }\n    }\n    vector<vector<int>> dist(h, vector<int>(w, M));\n    dist[si][sj] = 0;\n    deque<P> dq;\n    dq.push_back(P(si, sj));\n    while (!dq.empty()) {\n        P p = dq.front();\n        int i = p.first, j = p.second;\n        dq.pop_front();\n        for (int k = 0; k < 4; ++k) {\n            int ti = i + dd[k], tj = j + dd[k + 1];\n            if (ti >= 0 && ti < h && tj >= 0 && tj < w) {\n                if (b[i][j] == 'o' && (b[ti][tj] == '|' || b[ti][tj] == '-')) {\n                    if (dist[ti][tj] > dist[i][j] + 1) {\n                        dist[ti][tj] = dist[i][j] + 1;\n                        dq.push_back(P(ti, tj));\n                    }\n                }\n                else if (b[i][j] != '.' && b[ti][tj] != '.' && dist[ti][tj] > dist[i][j]) {\n                    dist[ti][tj] = dist[i][j];\n                    dq.push_front(P(ti, tj));\n                }\n            }\n        }\n    }\n    cout << dist[gi][gj] << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isupper(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  int ss = s-'A', tt = t-'A';\n  queue<int>  que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = pos[u].first+dy[i], nx = pos[u].second+dx[i];\n      ny += dy[i];\n      nx += dx[i];\n      int cnt = 0;\n      while(in(ny, nx) && (((i==0||i==2) && mas[ny][nx] == '|') || ((i==1||i==3) && mas[ny][nx] == '-'))) {\n\tny += dy[i];\n\tnx += dx[i];\n\t++cnt;\n      }\n      if(cnt == 0) continue;\n      ny += dy[i];\n      nx += dx[i];\n      if(!in(ny, nx) || !isupper(mas[ny][nx])) continue;\n      int v = mas[ny][nx]-'A';\n      if(dist[v] != -1) continue;\n      dist[v] = dist[u]+1;\n      que.push(v);\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint h,w;\nchar S,T;\n\nvector<int>v[1000];\n\nint sx,sy,gx,gy;\nstring s[100];\n\nvoid INPUT(){\n\n  cin>>h>>w>>S>>T; \n\n  r(i,h)cin>>s[i];\n\n  r(i,h)r(j,w){\n    if(s[i][j]==S)sx=j,sy=i;\n    if(s[i][j]==T)gx=j,gy=i;\n  }\n}\n\nvoid make_GRAPH(){\n  r(i,h)r(j,w)if(isalpha(s[i][j])){\n    r(k,4){\n      int x=j+dx[k]*2;\n      int y=i+dy[k]*2;\n      if(x<0||y<0||x>=w||y>=h)continue;\n      if(!(s[y][x]=='-'||s[y][x]=='|'))continue;\n      while(s[y][x]=='-'||s[y][x]=='|'){\n        y+=dy[k];\n        x+=dx[k];\n      }\n      y+=dy[k];\n      x+=dx[k];\n      v[s[i][j]-'A'].push_back(s[y][x]-'A');\n    }\n  }\n}\nbool used[100009];\nint d[100005];\n\nvoid BFS(){\n  queue<P>q;\n  q.push(P(s[sy][sx]-'A',0));\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int x=p.first;\n    int cost=p.second;\n    d[x]=cost;\n    r(i,v[x].size()){\n      int next=v[x][i];\n      if(!used[next]){\n        used[next]=1;\n        q.push(P(next,cost+1));\n      }\n    }\n  }\n  cout<<d[s[gy][gx]-'A']<<endl;\n}\n\nint main(){\n  INPUT();\n  make_GRAPH();\n  BFS();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nstruct Dijkstra {\n  Dijkstra(int V) : V(V), G(V) {}\n  struct edge {\n    edge(int to, long long cost) : to(to), cost(cost) {}\n    int to;\n    long long cost;\n  };\n\n  using P = pair<long long, int>;\n  const long long inf = 1001001001001001001ll;\n\n  int V;\n  vector<vector<edge>> G;\n  vector<long long> d;\n\n  void init(int n) {\n    V = n;\n    G.resize(n);\n  }\n\n  void debug() {\n    cerr << \"edges : \" << endl;\n    for (int i = 0; i < V; ++i)\n      for (auto e : G[i]) cerr << i << \" -> \" << e.to << \" : \" << e.cost << endl;\n    cerr << endl << \"dist : \" << endl;\n    for (int i = 0; i < V; ++i) cerr << i << \" : \" << d[i] << endl;\n  }\n\n  void add_edge(int u, int v, long long c) {\n    // cerr << char(u + 'A') << \" -> \" << char(v + 'A') << endl;\n    G[u].push_back(edge(v, c));\n  }\n\n  void build(int s) {\n    d.assign(V, inf);\n    priority_queue<P, vector<P>, greater<P>> q;\n\n    d[s] = 0;\n    q.push(P(0ll, s));\n\n    while (!q.empty()) {\n      P p = q.top();\n      q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto &e : G[v])\n        if (d[e.to] > p.first + e.cost) {\n          d[e.to] = p.first + e.cost;\n          q.push(P(d[e.to], e.to));\n        }\n    }\n  }\n\n  long long operator[](int v) {\n    return d[v];\n  }\n};\n\nDijkstra G(256);\nint h, w;\nchar a[60][60];\n\nvoid add_edge(int y, int x, int v) {\n  for (int i = y - 2; i > 1; --i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i - 1][x] - 'A', 1);\n    break;\n  }\n  for (int i = y + 2; i <= h; ++i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i + 1][x] - 'A', 1);\n    break;\n  }\n  for (int j = x - 2; j > 1; --j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j - 1] - 'A', 1);\n    break;\n  }\n  for (int j = x + 2; j <= w; ++j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j + 1] - 'A', 1);\n    break;\n  }\n}\n\nsigned main(int argc, char *argv[]) {\n  char s, t;\n\n  cin >> h >> w >> s >> t;\n\n  if (h > 50 || w > 50)\n    for (;;) {\n    }\n\n  for (int i = 0; i < 60; ++i) {\n    for (int j = 0; j < 60; ++j) {\n      a[i][j] = '.';\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      cin >> a[i][j];\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      if ('A' <= a[i][j] && a[i][j] <= 'Z') {\n        // cerr << a[i][j] << endl;\n        add_edge(i, j, a[i][j] - 'A');\n      }\n    }\n  }\n\n  G.build(s - 'A');\n  cout << G[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing u64 = uint64_t;\nconstexpr const u64 INF = UINT64_MAX / 2;\n\nbool inbound(int H, int W, int h, int w) {\n    return (0 <= h && h < H) && (0 <= w && w < W);\n}\n\nbool continuing(int dh, char ch) {\n    return ch == (dh == 0 ? '-' : '|');\n}\n\nvector<vector<u64>> parse(int H, int W, vector<vector<char>> const &aa) {\n    int h, w;\n    for (h = 0; h < H; h++) {\n        for (w = 0; w < W; w++) {\n            if (isupper(aa[h][w])) goto loopend;\n        }\n    }\nloopend:\n    vector<vector<u64>> graph(26, vector<u64>(26, INF));\n    queue<pair<int, int>> q; // <h, w>\n    q.push({h, w});\n    while (!q.empty()) {\n        auto c = q.front();\n        auto cv = aa[c.first][c.second] - 'A';\n        q.pop();\n        int adh[] = { -2, 0, 2, 0 };\n        int adw[] = { 0, -2, 0, 2 };\n        for (int i = 0; i < 4; i++) {\n            int dh = adh[i], dw = adw[i];\n            int h = c.first + dh, w = c.second + dw;\n            if (inbound(H, W, h, w) && continuing(dh, aa[h][w])) {\n                dh /= 2; dw /= 2;\n                char ch;\n                while (!isupper((ch = aa[h][w]))) {\n                    h += dh, w += dw;\n                }\n                auto tv = ch - 'A';\n                if (graph[cv][tv] == INF) {\n                    graph[cv][tv] = graph[tv][cv] = 1;\n                    q.push({h, w});\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nvoid warshall_floyd(vector<vector<u64>> &graph) {\n    int N = graph.size();\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    istringstream ss(line);\n    int H, W;\n    ss >> H >> W;\n    char S, T;\n    ss >> S >> T;\n    S -= 'A'; T -= 'A';\n\n    vector<vector<char>> aa(H, vector<char>(W));\n\n    for (int h = 0; h < H; h++) {\n        string line;\n        getline(cin, line);\n        for (int w = 0; w < W; w++) {\n            aa[h][w] = line[w];\n        }\n    }\n\n    auto graph = parse(H, W, aa);\n    warshall_floyd(graph);\n    cout << graph[S][T] << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>pipii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  string ss,st;\n  cin>>h>>w>>ss>>st;\n  char s=ss[0],t=st[0];\n  rep(i,h){\n    cin>>brd[i];\n  }\n  priority_queue<pipii,vector<pipii>,greater<pipii> > que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push(pipii(0,pii(sx,sy)));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  int dx[4]={1,0,-1,0};\n  int dy[4]={0,1,0,-1};\n  while(!que.empty()){\n    pipii dt=que.top();que.pop();\n    int d=dt.first;\n    pii t=dt.second;\n    if(dis[t.first][t.second]<=d)continue;\n    dis[t.first][t.second]=d;\n    rep(dir,4){\n      int nx=t.first+dx[dir],ny=t.second+dy[dir];\n      if(nx<0||nx>=h||ny<0||ny>=w)continue;\n      if(brd[nx][ny]=='.')continue;\n      int cos=(brd[nx][ny]=='o'?1:0);\n      int nd=dis[t.first][t.second]+cos;\n      que.push(pipii(nd,pii(nx,ny)));\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]/2<<endl;\n    }\n  }\n  if(0){\n    rep(i,h)rep(j,w){\n      if(brd[i][j]>='A'&&brd[i][j]<='Z'){\n\tcerr<<brd[i][j]<<\" \"<<dis[i][j]<<endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nint INF = 1 << 28;\n\nstruct state {\n    char ch;\n    int x, y, cost;\n    state() {}\n    state(char ch, int x, int y, int cost): ch(ch), x(x), y(y), cost(cost) {}\n};\n\nint H, W;\nchar S, T;\nstring G[50];\n\nint sx, sy, gx, gy;\n\nint main() {\n    cin >> H >> W >> S >> T;\n    for (int j = 0; j < H; ++j) {\n        cin >> G[j];\n    }\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            if (G[j][k] == S) {\n                sx = j; sy = k;\n            }\n            if (G[j][k] == T) {\n                gx = j; gy = k;\n            }\n        }\n    }\n\n    queue<state> que;\n    que.emplace(S, sx, sy, 0);\n\n    int ans[26]; fill(ans, ans+26, INF);\n    ans[S-'A'] = 0;\n\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = st.x + 2*dx[d], ny = st.y + 2*dy[d];\n            if (nx < 0 || H <= nx || ny < 0 || W <= ny) { continue; }\n            if ((d % 2 == 0 && G[nx][ny] == '|') || (d % 2 == 1 && G[nx][ny] == '-')) {\n                while (!('A' <= G[nx][ny] && G[nx][ny] <= 'Z')) {\n                    nx += dx[d];  ny += dy[d];\n                }\n\n                char nch = G[nx][ny];\n\n                if (st.cost + 1 < ans[nch - 'A']) {\n                    ans[nch - 'A'] = st.cost + 1;\n                    que.emplace(nch, nx, ny, ans[nch-'A']);\n                }\n            }\n        }\n    }\n\n    cout << ans[T-'A'] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nconst int INF = 1 << 29;\nconst int vy[] = {1, 0, -1, 0};\nconst int vx[] = {0, -1, 0, 1};\n\ntemplate< typename T = int >\nvoid warshall_floyd(Matrix< T > &g) {\n  for(int k = 0; k < g.size(); k++) {\n    for(int i = 0; i < g.size(); i++) {\n      for(int j = 0; j < g.size(); j++) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int H, W;\n  char S, T;\n  string A[50];\n  cin >> H >> W >> S >> T;\n  for(int i = 0; i < H; i++) {\n    cin >> A[i];\n  }\n\n  Matrix< int > mat(26, vector< int >(26, INF));\n  for(int i = 0; i < 26; i++) mat[i][i] = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(isupper(A[i][j])) {\n        for(int k = 0; k < 4; k++) {\n          int ny = i + vy[k], nx = j + vx[k];\n          bool isbeet = false;\n          while(0 <= ny && ny < H && 0 <= nx && nx < W) {\n            if(isupper(A[ny][nx]) && isbeet) {\n              mat[A[i][j] - 'A'][A[ny][nx] - 'A'] = 1;\n              break;\n            } else if(A[ny][nx] == '.') {\n              break;\n            } else if(A[ny][nx] == '|' || A[ny][nx] == '-') {\n              isbeet = true;\n            }\n            ny += vy[k];\n            nx += vx[k];\n          }\n\n        }\n      }\n    }\n  }\n  warshall_floyd(mat);\n  cout << mat[S - 'A'][T - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nstruct edge { int to, cost; };\nint H, W;\nvector<string> table;\nvector<edge> G[30];\nbool isOut(int y, int x)\n{\n    if(y < 0 || x < 0 || y >= H || x >= W) return true;\n    return false;\n}\nvoid makeGragh(int y, int x)\n{\n    bool used[H][W] = {};\n    used[y][x] = true;\n    queue<P> que;\n    que.push(P(y, x));\n    while(que.size())\n    {\n        P p = que.front(); que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = p.first;\n            int nx = p.second;\n            while(not isOut(ny + dy[i], nx + dx[i]))\n            {\n                ny += dy[i];\n                nx += dx[i];\n                if(table[ny][nx] == '.' || used[ny][nx]) break; \n                if(dy[i] == 0 && table[ny][nx] == '|') break;\n                if(dx[i] == 0 && table[ny][nx] == '-') break;\n                if(table[ny][nx] >= 'A' && table[ny][nx] <= 'Z')\n                {\n                    int a = table[p.first][p.second] - 'A';\n                    int b = table[ny][nx] - 'A';\n                    G[a].push_back({b, 1});\n                    G[b].push_back({a, 1});\n                    que.push(P(ny, nx));\n                    break;\n                }\n                used[ny][nx] = true;\n            }\n        }\n    }\n}\nint solve(int s, int t)\n{\n    // for(int i = 0; i < 26; i++)\n    // {\n    //     cout << char(i + 'A') << \" : \";\n    //     for(int j = 0; j < G[i].size(); j++) cout << char(G[i][j].to + 'A') << \" \"; cout << endl;\n    // }\n    vector<int> dist(30, INF);\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0, s));\n    dist[s] = 0;\n    while(que.size())\n    {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        for(int u = 0; u < G[v].size(); u++)\n        {\n            edge e = G[v][u];\n            if(dist[v] + e.cost < dist[e.to])\n            {\n                dist[e.to] = dist[v] + e.cost;\n                que.push(P(dist[e.to], e.to));\n            }\n        }\n    }\n    return dist[t];\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    char s, t;\n    cin >> H >> W >> s >> t;\n    table.resize(H);\n    vector<char> v;\n    int sy, sx;\n    for(int i = 0; i < H; i++)\n    {\n        string s; cin >> s;\n        for(int j = 0; j < s.size(); j++) if(s[j] >= 'A' && s[j] <= 'Z') sy = i, sx = j;\n        table[i] = s;\n    }\n    makeGragh(sy, sx);\n    cout << solve(s - 'A', t - 'A') << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nint di[4] = {1, 0, -1, 0}, dj[4] = {0, 1, 0, -1};\n\nmain {\n  int H, W;\n  char s, t;\n  cin >> H >> W >> s >> t;\n  vector<vector<char>> m(H, vector<char>(W));\n  int S, G;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> m[i][j];\n      if (isupper(m[i][j])) {\n        if (m[i][j] == s) S = i * W + j;\n        if (m[i][j] == t) G = i * W + j;\n        m[i][j] = 'o';\n      }\n    }\n  }\n\n  Graph g(H * W);\n  rep(i, H) rep(j, W) {\n    rep(k, 4) {\n      int i2 = i + di[k], j2 = j + dj[k];\n      if (i2 < 0 || j2 < 0 || i2 >= H || j2 >= W) continue;\n      if (m[i][j] == '-') {\n        if ((k==0||k==2)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '-') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == '|') {\n        if ((k==1||k==3)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == 'o') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        } else if (m[i2][j2] == '-' || m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        }\n      }\n    }\n  }\n  cout << dijkstra(g, S).first[G] / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n#define MAX 2000\nint h,w;\nchar a,b;\nstring s[MAX];\n\nii getP(char c) {\n  rep(i,h) {\n    rep(j,w) {\n      if( s[i][j] == c ) return ii(j,i);\n    }\n  }\n  assert(false);\n}\n\nint mini[MAX][MAX];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nstruct Data {\n  int x,y,c;\n  bool operator < ( const Data &data) const {\n    if( c != data.c ) return c > data.c;\n    if( y != data.y ) return y < data.y;\n    return x < data.x;\n  }\n};\n\nbool check(int x,int y) {\n  int cnt = 0;\n  rep(i,4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !( 0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n    if( s[ny][nx] == 'o' ) ++cnt;\n  }\n  return cnt <= 2;\n}\n\nvoid compute() {\n  rep(i,h) rep(j,w) if( s[i][j] == 'o' ) assert( check(j,i) );\n  ii sp = getP(a), ep = getP(b);\n  rep(i,h) rep(j,w) mini[i][j] = INT_MAX;\n  mini[sp.second][sp.first] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){sp.first,sp.second,0});\n  while( !Q.empty() ) {\n    Data d = Q.top(); Q.pop();\n    rep(i,4) {\n      int nx = d.x + dx[i];\n      int ny = d.y + dy[i];\n      if( !( 0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n      char c = s[ny][nx];\n      if( c == '.' ) continue;\n      int coef = 0;\n      if( s[d.y][d.x] == 'o'  && ( c == '-' || c == '|' ) ) {\n\tcoef = 1;\n      }\n      if( mini[ny][nx] > d.c + coef ) {\n\tmini[ny][nx] = d.c + coef;\n\tQ.push((Data){nx,ny,mini[ny][nx]});\n      }\n    }\n  }\n  cout <<mini[ep.second][ep.first] << endl;\n}\n\nint main() {\n  cin >> h  >> w >> a >> b;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1010101;\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nbool is_edge(int x, char c){\n    if(x<2) return c=='-';\n    return c=='|';\n}\n\nint main(){\n    int h,w;\n    char s,t;\n    cin >>h >>w >>s >>t;\n\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    pi start,goal;\n    rep(i,h)rep(j,w){\n        if(f[i][j] == s) start = {i,j};\n        if(f[i][j] == t) goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n    vector<vector<int>> d(h,vector<int>(w,INF));\n    queue<pi> que;\n    d[start.fi][start.se] = 0;\n    que.push(start);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        rep(i,4){\n            int xx = now.se+2*dx[i], yy = now.fi+2*dy[i];\n            if(IN(yy,xx) && is_edge(i,f[yy][xx])){\n                while( !('A'<=f[yy][xx] && f[yy][xx]<='Z') ){\n                    yy += dy[i];\n                    xx += dx[i];\n                }\n\n                if(('A'<=f[yy][xx] && f[yy][xx]<='Z')){\n                    if(d[yy][xx] > d[now.fi][now.se]+1){\n                        d[yy][xx] = d[now.fi][now.se]+1;\n                        que.push({yy,xx});\n                    }\n                }\n            }\n        }\n    }\n\n    cout << d[goal.fi][goal.se] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s, t;\n\tcin >> H >> W >> s >> t;\n\tvector<string>field(H);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> field[i];\n\t}\n\tvector<vector<bool>>edge(26, vector<bool>(26));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (field[i][j] == '-') {\n\t\t\t\tint a, b;\n\t\t\t\tfor (int k = 0;; k--) {\n\t\t\t\t\tif (field[i][j + k] >= 'A'&&field[i][j + k] <= 'Z') {\n\t\t\t\t\t\ta = field[i][j + k] - 'A';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0;; k++) {\n\t\t\t\t\tif (field[i][j + k] >= 'A'&&field[i][j + k] <= 'Z') {\n\t\t\t\t\t\tb = field[i][j + k] - 'A';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[a][b] = true;\n\t\t\t\tedge[b][a] = true;\n\t\t\t}\n\t\t\telse if (field[i][j] == '|') {\n\t\t\t\tint a, b;\n\t\t\t\tfor (int k = 0;; k--) {\n\t\t\t\t\tif (field[i + k][j] >= 'A'&&field[i + k][j] <= 'Z') {\n\t\t\t\t\t\ta = field[i + k][j] - 'A';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0;; k++) {\n\t\t\t\t\tif (field[i + k][j] >= 'A'&&field[i + k][j] <= 'Z') {\n\t\t\t\t\t\tb = field[i + k][j] - 'A';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedge[a][b] = true;\n\t\t\t\tedge[b][a] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint st = s[0] - 'A';\n\tint gl = t[0] - 'A';\n\tvector<int>dis(26, MOD);\n\tdis[st] = 0;\n\tqueue<int>Q;\n\tQ.push(st);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (edge[cn][i]) {\n\t\t\t\tif (dis[cn] + 1 < dis[i]) {\n\t\t\t\t\tdis[i] = dis[cn] + 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis[gl] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint H,W;\nchar si,ti;\nint sy,sx;\n\nchar t[100][100];\nbool inField(int y,int x){\n  return (0<=y&&y<H&&0<=x&&x<W);\n}\nbool isAl(char ch){\n  return ('A'<=ch&&ch<='Z');\n}\n\nint solve(){\n  typedef pair<int,int> P;\n  map< P , int > d;\n  \n  queue< P > Q;\n  Q.push( P(sy,sx) );\n  d[ P(sy,sx) ]=0;\n  while(!Q.empty()){\n    P p=Q.front();Q.pop();\n    int py=p.first;\n    int px=p.second;\n    if( t[py][px]==ti )return d[p];\n    \n    for(int dir=0;dir<4;dir++){\n      int ny=py+dy[dir];\n      int nx=px+dx[dir];\n      bool flag=true;\n\n      \n      while( inField(ny,nx) && !isAl(t[ny][nx]) ){\n        ny+=dy[dir];\n        nx+=dx[dir];\n        if(t[ny][nx]=='.')flag=false;\n      }\n      \n      if(!flag)continue;\n      if( !inField(ny,nx) )continue;\n      if( !isAl(t[ny][nx]) )continue;\n      if( d.count( P(ny,nx) ) )continue;\n      d[ P(ny,nx) ] = d[ P(py,px) ]+1;\n      Q.push( P(ny,nx) );\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  cin>>H>>W>>si>>ti;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]==si){\n        sy=i;\n        sx=j;\n      }\n    }\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int h,w;\n    char a,b;\n    cin>>h>>w>>a>>b;\n    string s[h];\n    int dp[26][26];\n    int INF = 1e9;\n    for(int i=0;i<26;i++){\n        for(int j=0;j<26;j++){\n            dp[i][j] = INF;\n            if(i==j) dp[i][j] = 0;\n        }\n    }\n    for(int i=0;i<h;i++){\n        cin>>s[i];\n    }\n    bool used[h][w] = {};\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(used[i][j]) continue;\n            if(s[i][j] == '|'){\n                char u='0',v='0';\n                for(int k=i;k>=0;k--){\n                    used[k][j] = 1;\n                    if(s[k][j] !='o' && s[k][j] !='.' && s[k][j]!='|'){\n                        u = s[k][j];\n                        break;\n                    }\n                }\n                for(int k=i;k<h;k++){\n                    used[k][j] = 1;\n                    if(s[k][j] !='o' && s[k][j] !='.' && s[k][j]!='|'){\n                        v = s[k][j];\n                        break;\n                    }\n                }\n                //cerr << i << \" \" << j << \" \" << u << \" \" << v << endl;\n                if(u!='0' && v!='0') {\n                    dp[u-'A'][v-'A'] = 1;\n                    dp[v-'A'][u-'A'] = 1;\n                }\n            }\n            if(s[i][j] == '-'){\n                char u='0',v='0';\n                for(int k=j;k>=0;k--){\n                    used[i][k] = 1;\n                    if(s[i][k]!='o' && s[i][k]!='.' && s[i][k] !='-'){\n                        u = s[i][k];\n                        break;\n                    }\n                }\n                for(int k=j;k<w;k++){\n                    used[i][k] = 1;\n                    if(s[i][k]!='o' && s[i][k]!='.' && s[i][k] !='-'){\n                        v = s[i][k];\n                        break;\n                    }\n                }\n                //cerr << i << \" \" << j << \" \" << u << \" \" << v << endl;\n                if(u!='0' && v!='0') {\n                    dp[u-'A'][v-'A'] = 1;\n                    dp[v-'A'][u-'A'] = 1;\n                }\n            }\n        }\n    }\n    for(int k=0;k<26;k++)for(int i=0;i<26;i++)for(int j=0;j<26;j++){\n        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n    }\n    cout << dp[a-'A'][b-'A'] << endl;\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<ll,ll> pint;\n\nvector<pint> vp[30];\nint d[30];\nint INF=1000100010;\nint dijkstra(int st){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    rep(i,26) d[i]=INF;\n    d[st]=0;\n    pq.push(make_pair(0,st));\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        if(d[t]<pi.first) continue;\n        for(auto it:vp[t]){\n            if(d[it.second]>d[t]+it.first){\n                d[it.second]=d[t]+it.first;\n                pq.push(make_pair(d[it.second],it.second));\n            }\n        }\n    }\n}\nstring s[51];\nconst int dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int h,w;\n    char sr,dt;\n    cin>>h>>w>>sr>>dt;\n    rep(i,h) cin>>s[i];\n    rep(i,h)rep(j,w){\n        if(isalpha(s[i][j])&&s[i][j]!='o'){\n            rep(k,4){\n                int tx=j+dx[k]*2,ty=i+dy[k]*2;\n                char c;\n                if(k%2==0) c='-';\n                else c='|';\n                while(tx>=0&&ty>=0&&tx<w&&ty<h){\n                    if(isalpha(s[ty][tx])&&s[ty][tx]!='o'){\n                        vp[s[i][j]-'A'].pb(1,s[ty][tx]-'A');\n                        break;\n                    }\n                    else if(s[ty][tx]==c||s[ty][tx]=='o'){\n                        tx+=dx[k],ty+=dy[k];\n                    }\n                    else break;\n                } \n            }\n        }\n    }\n    dijkstra(sr-'A');\n    cout<<d[dt-'A']<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tint to,cost;\n\t};\n\tvector<vector<edge> >G,rG;\n\tint n;\n\tvi d;//distance\n\tDIJ(int size){\n\t\tn=size;\n\t\trG=G=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s){\n\t\td=vi(n,inf);\n\t\td[s]=0;\n\t\tpriority_queue<pii>q;\n\t\tq.push(pii(0,s));\n\t\twhile(!q.empty()){\n\t\t\tpii p=q.top();\n\t\t\tq.pop();\n\t\t\tint pos=p.second,cost=-p.first;\n\t\t\tif(cost>d[pos])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tint nowcost=cost+e.cost;\n\t\t\t\tif(nowcost<d[to]){\n\t\t\t\t\td[to]=nowcost;\n\t\t\t\t\tq.push(pii(-d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,m;\n\tchar s,t;\n\tcin>>n>>m>>s>>t;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tDIJ dij(26);\n\trep(i,n){\n\t\tbool h=false;\n\t\tint w;\n\t\trep(j,m){\n\t\t\tif(in[i][j]=='-'&&h==false){\n\t\t\t\th=true;\n\t\t\t\tw=in[i][j-2]-'A';\n\t\t\t}else if(in[i][j]!='-'&&h){\n\t\t\t\th=false;\n\t\t\t\tdij.add_edge(w,in[i][j+1]-'A',1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,m){\n\t\tbool h=false;\n\t\tint w;\n\t\trep(j,n){\n\t\t\tif(in[j][i]=='|'&&h==false){\n\t\t\t\th=true;\n\t\t\t\tw=in[j-2][i]-'A';\n\t\t\t}else if(in[j][i]!='|'&&h){\n\t\t\t\th=false;\n\t\t\t\tdij.add_edge(w,in[j+1][i]-'A',1);\n\t\t\t}\n\t\t}\n\t}\n\tdij.dij(s-'A');\n\tcout<<dij.d[t-'A']<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[26];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 26) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            int y = idx[i].first + dy[j];\n            int x = idx[i].second + dx[j];\n            while(1){\n                if(!contain(y, x)) break;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    break;\n                }\n                if(c[y][x] == '.') break;\n                y += dy[j];\n                x += dx[j];\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_sum_cost,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t\tdir = arg_dir;\n\t}\n\tint row,col,sum_cost;\n\tDIR dir;\n};\n\nint H,W;\nint min_dist[26];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar table[50][51],start[2],goal[2];\nDIR dir_array[4] = {North,West,East,South};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %s %s\",&H,&W,start,goal);\n\n\tint start_row,start_col;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(table[row][col] == start[0]){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++)min_dist[i] = BIG_NUM;\n\n\tqueue<Info> Q;\n\tmin_dist[start[0]-'A'] = 0;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tQ.push(Info(start_row,start_col,0,dir_array[i]));\n\t}\n\n\tint adj_row,adj_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(table[Q.front().row][Q.front().col] == goal[0]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tif(Q.front().dir != dir_array[i])continue; //方向が同じでなければSKIP\n\n\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '.')continue;\n\t\t\t\tif(Q.front().dir == North || Q.front().dir == South){\n\t\t\t\t\t//printf(\"縦 adj_row:%d adj_col:%d\\n\",adj_row,adj_col);\n\t\t\t\t\tif(table[adj_row][adj_col] == '-')continue;\n\n\t\t\t\t}else{\n\t\t\t\t\t//printf(\"縦 adj_col:%d adj_row:%d\\n\",adj_row,adj_col);\n\t\t\t\t\tif(table[adj_row][adj_col] == '|')continue;\n\t\t\t\t}\n\n\t\t\t\tif(table[adj_row][adj_col] >= 'A' && table[adj_row][adj_col] <= 'Z'){ //ノードに到着\n\t\t\t\t\tif(min_dist[table[adj_row][adj_col]-'A'] <= Q.front().sum_cost+1)continue;\n\t\t\t\t\tmin_dist[table[adj_row][adj_col]-'A'] = Q.front().sum_cost+1;\n\n\t\t\t\t\tfor(int k = 0; k < 4; k++){ //方向転換\n\t\t\t\t\t\tQ.push(Info(adj_row,adj_col,min_dist[table[adj_row][adj_col]-'A'],dir_array[k]));\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,Q.front().sum_cost,Q.front().dir));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_dist[goal[0]-'A']);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    cout << \"debug\" << endl;\n    rep(i,H) cout << grid[i] << endl;\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                assert(inrange(now.first, now.second));\n            }\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint H,W;\nchar si,ti;\nint sy,sx;\n\nchar t[100][100];\nbool inField(int y,int x){\n  return (0<=y&&y<H&&0<=x&&x<W);\n}\nbool isAl(char ch){\n  return ('A'<=ch&&ch<='Z');\n}\n\nint solve(){\n  typedef pair<int,int> P;\n  map< P , int > d;\n  \n  queue< P > Q;\n  Q.push( P(sy,sx) );\n  d[ P(sy,sx) ]=0;\n  while(!Q.empty()){\n    P p=Q.front();Q.pop();\n    int py=p.first;\n    int px=p.second;\n    if( t[py][px]==ti )return d[p];\n    \n    for(int dir=0;dir<4;dir++){\n      int ny=py+dy[dir];\n      int nx=px+dx[dir];\n      bool flag=true;\n\n      \n      while( inField(ny,nx) && !isAl(t[ny][nx]) ){\n        ny+=dy[dir];\n        nx+=dx[dir];\n        if(t[ny][nx]=='.')flag=false;\n        if(dx[dir]==0 && t[ny][nx]=='-')flag=false;\n        if(dy[dir]==0 && t[ny][nx]=='|')flag=false;\n      }\n      \n      if(!flag)continue;\n      if( !inField(ny,nx) )continue;\n      if( !isAl(t[ny][nx]) )continue;\n      if( d.count( P(ny,nx) ) )continue;\n      d[ P(ny,nx) ] = d[ P(py,px) ]+1;\n      Q.push( P(ny,nx) );\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  cin>>H>>W>>si>>ti;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]==si){\n        sy=i;\n        sx=j;\n      }\n    }\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main()\n{\n\tint H, W;\n\tchar sc, tc;\n\tcin >> H >> W >> sc >> tc;\n\tint s = sc - 'A', t = tc - 'A';\n\tvector<string> S(H);\n\tvector<vector<int>> G(26);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> S[i];\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S[i][j] == '-') {\n\t\t\t\tint u = S[i][j - 2] - 'A';\n\t\t\t\tint p = j;\n\t\t\t\twhile (S[i][p] == '-') {\n\t\t\t\t\tS[i][p] = '.';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tint v = S[i][p + 1] - 'A';\n\t\t\t\tG[u].push_back(v);\n\t\t\t\tG[v].push_back(u);\n\t\t\t}\n\t\t\tif (S[i][j] == '|') {\n\t\t\t\tint u = S[i - 2][j] - 'A';\n\t\t\t\tint p = i;\n\t\t\t\twhile (S[p][j] == '|') {\n\t\t\t\t\tS[p][j] = '.';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tint v = S[p + 1][j] - 'A';\n\t\t\t\tG[u].push_back(v);\n\t\t\t\tG[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tvector<int> d(26, INF);\n\tq.push(s);\n\td[s] = 0;\n\twhile (!q.empty()) {\n\t\tauto v = q.front(); q.pop();\n\t\tfor (auto to : G[v]) if (d[to] == INF) {\n\t\t\tq.push(to);\n\t\t\td[to] = d[v] + 1;\n\t\t}\n\t}\n\tcout << d[t] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tchar a, b;\n\tcin >> a >> b;\n\tint s = a - 'A', t = b - 'A';\n\tvector<string> v(h);\n\tREP(i, h)cin >> v[i];\n\tvvi g(26);\n\tvector<pii> p(26, { -1,-1 });\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (isalpha(v[i][j]) && v[i][j] != 'o') {\n\t\t\t\tp[v[i][j] - 'A'] = { i,j };\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 26) {\n\t\tif (p[i].first == -1)continue;\n\t\tREP(k, 4) {\n\t\t\tint ni = p[i].first + dx[k * 2] * 2, nj = p[i].second + dy[k * 2] * 2;\n\t\t\tif (ni < 0 || nj < 0 || ni >= h || nj >= w)continue;\n\t\t\tif (dx[k * 2] == 0) {\n\t\t\t\tif (v[ni][nj] == '-') {\n\t\t\t\t\twhile (v[ni][nj] != 'o') {\n\t\t\t\t\t\tni += dx[k * 2];\n\t\t\t\t\t\tnj += dy[k * 2];\n\t\t\t\t\t}\n\t\t\t\t\tni += dx[k * 2];\n\t\t\t\t\tnj += dy[k * 2];\n\t\t\t\t\tint j = v[ni][nj] - 'A';\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (v[ni][nj] == '|') {\n\t\t\t\t\twhile (v[ni][nj] != 'o') {\n\t\t\t\t\t\tni += dx[k * 2];\n\t\t\t\t\t\tnj += dy[k * 2];\n\t\t\t\t\t}\n\t\t\t\t\tni += dx[k * 2];\n\t\t\t\t\tnj += dy[k * 2];\n\t\t\t\t\tint j = v[ni][nj] - 'A';\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi d(26, INF);\n\tqueue<int> q;\n\td[s] = 0;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tREP(i, g[x].size()) {\n\t\t\tif (d[g[x][i]] > d[x] + 1) {\n\t\t\t\tq.push(g[x][i]);\n\t\t\t}\n\t\t\td[g[x][i]] = min(d[g[x][i]], d[x] + 1);\n\t\t}\n\t}\n\tcout << d[t] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nP start;\nP goal;\n\nbool check(int x, int y, int H, int W){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint main(void){\n  int H, W;\n  char s, t;\n  cin >> H >> W;\n  cin >> s >> t;\n  vector< vector<char> > graph(H, vector<char>(W));\n  for(int i = 0; i < H; i++){\n    string str;\n    cin >> str;\n    for(int j = 0; j < W; j++){\n      graph[i][j] = str[j];\n      if(graph[i][j] == s){\n        start.first = j;\n        start.second = i;\n      }\n      if(graph[i][j] == t){\n        goal.first = j;\n        goal.second = i;\n      }\n    }\n  }\n\n  // bfs\n  int INF = 50*50*50;\n  vector< vector<int> > d(H, vector<int>(W, INF));\n  queue<P> que;\n  que.push(make_pair(start.first, start.second));\n  d[start.second][start.first] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    if(p == goal) break;\n\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for(int i = 0; i < 4; i++){\n      int nx = p.first + dx[i]*2, ny = p.second + dy[i]*2;\n      if( check(nx, ny, H, W) == false ) continue;\n      if(graph[ny][nx] == '|' || graph[ny][nx] == '-'){\n        while(!('A' <= graph[ny][nx] && graph[ny][nx] <= 'Z')){\n          nx += dx[i]; ny += dy[i];\n          assert(check(nx, ny, H, W));\n        }\n        if(d[ny][nx] == INF){\n          d[ny][nx] = d[p.second][p.first] + 1;\n          que.push(make_pair(nx, ny));\n        }\n      }\n    }\n  }\n  cout << d[goal.second][goal.first] << endl;;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define CHMIN(a,b) (a)=min((a),(b))\ntypedef long long ll;\ntypedef vector<int> vi;\n\nchar buf[25];\n\nint h,w;\nchar s,t;\nchar mp[52][52];\n\nint g[26][26];\n\nint ddd[5] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  scanf(\"%s\",buf); s=buf[0];\n  scanf(\"%s\",buf); t=buf[0];\n  REP(i,h)scanf(\"%s\",mp[i]);\n  REP(i,26)REP(j,26)g[i][j] = 10000000;\n  REP(i,h)REP(j,w)if(isalpha(mp[i][j]) && mp[i][j]!='o'){\n    int id = mp[i][j]-'A';\n    REP(d,4){\n      int ni = i+ddd[d];\n      int nj = j+ddd[d+1];\n      while(true){\n        if(ni>=h || nj>=w || ni<0 || nj<0)break;\n        if(mp[ni][nj]=='.')break;\n        if(d%2==0 && mp[ni][nj]=='-')break;\n        if(d%2==1 && mp[ni][nj]=='|')break;\n        if(isalpha(mp[ni][nj]) && mp[ni][nj]!='o'){\n          int nid = mp[ni][nj]-'A';\n          g[id][nid] = g[nid][id] = 1;\n          // printf(\"%d - %d\\n\",id,nid);\n          break;\n        }\n        ni += ddd[d];\n        nj += ddd[d+1];\n      }\n    }\n  }\n  // printf(\"s:%d, t:%d\\n\",s-'A',t-'A');\n  REP(k,26)REP(i,26)REP(j,26)CHMIN(g[i][j],g[i][k]+g[k][j]);\n  printf(\"%d\\n\",g[s-'A'][t-'A']);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tchar s, t;\n\tcin >> N >> M >> s >> t;\n\tvector<string> S(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> S[i];\n\t}\n\tvector<vector<int> > ed;\n\tmap<char, int> mp;\n\tvector<pair<char, char> > vp;\n\tint c = 0;\n\tchar e[2] = { '-', '|' };\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((int)(S[i][j] - 'A') >= 0 && (int)(S[i][j] - 'A') < 26) {\n\t\t\t\tmp[S[i][j]] = c;\n\t\t\t\tc++;\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tint dx = k;\n\t\t\t\t\tint dy = 1 - k;\n\t\t\t\t\tif (i + 2 * dx < N && j + 2 * dy < M) {\n\t\t\t\t\t\tif (S[i + 2 * dx][j + 2 * dy] == e[k]) {\n\t\t\t\t\t\t\tint nx = i + 2 * dx;\n\t\t\t\t\t\t\tint ny = j + 2 * dy;\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tif ((int)(S[nx][ny] - 'A') >= 0 && (int)(S[nx][ny] - 'A') < 26) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnx += dx;\n\t\t\t\t\t\t\t\tny += dy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvp.push_back(make_pair(S[i][j], S[nx][ny]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ted.resize(mp.size());\n\tfor (int i = 0; i < vp.size(); i++) {\n\t\t//cerr << vp[i].first << \" \" << vp[i].second << endl;\n\t\ted[mp[vp[i].first]].push_back(mp[vp[i].second]);\n\t\ted[mp[vp[i].second]].push_back(mp[vp[i].first]);\n\t}\n\tvector<int> dist(ed.size(), (int)1 << 60);\n\tdist[mp[s]] = 0;\n\tqueue<int> qu;\n\tqu.push(mp[s]);\n\tint a;\n\twhile ((int)qu.size() > 0) {\n\t\ta = qu.front(); qu.pop();\n\t\tfor (int i = 0; i < ed[a].size(); i++) {\n\t\t\tif (dist[ed[a][i]] > dist[a] + 1) {\n\t\t\t\tdist[ed[a][i]] = dist[a] + 1;\n\t\t\t\tqu.push(ed[a][i]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[mp[t]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int64_t\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nnamespace io {\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        io::print_to(os, \", \", \"\\n\", __VA_ARGS__);        \\\n        std::cerr << io::highlight(os.str());             \\\n    } while (0)\n#define dump_(cntnr)                                 \\\n    do {                                             \\\n        std::ostringstream os;                       \\\n        os << __LINE__ << \":\\t\" << #cntnr << \" = [\"; \\\n        io::print_to_(os, \", \", \"]\\n\", all(cntnr));  \\\n        std::cerr << io::highlight(os.str());        \\\n    } while (0)\n#define dumpf(fmt, ...)                             \\\n    do {                                            \\\n        const int N = 4096;                         \\\n        auto b = new char[N];                       \\\n        int l = snprintf(b, N, \"%d:\\t\", __LINE__);  \\\n        snprintf(b + l, N - l, fmt, ##__VA_ARGS__); \\\n        std::cerr << io::highlight(b) << std::endl; \\\n        delete[] b;                                 \\\n    } while (0)\n#else\n#define dump(...)\n#define dump_(...)\n#define dumpf(...)\n#endif\nstd::string highlight(std::string s) {\n#ifdef _MSC_VER\n    return s;\n#else\n    return \"\\033[33m\" + s + \"\\033[0m\";\n#endif\n}\ntemplate <typename T>\nvoid print_to(std::ostream &os, std::string, std::string tail, const T &first) {\n    os << first << tail;\n}\ntemplate <typename F, typename... R>\nvoid print_to(std::ostream &os, std::string del, std::string tail, const F &first,\n              const R &... rest) {\n    os << first << del;\n    print_to(os, del, tail, rest...);\n}\ntemplate <typename I>\nvoid print_to_(std::ostream &os, std::string del, std::string tail, I begin, I end) {\n    for (I it = begin; it != end;) {\n        os << *it;\n        os << (++it != end ? del : tail);\n    }\n}\ntemplate <typename F, typename... R>\nvoid println(const F &first, const R &... rest) {\n    print_to(std::cout, \"\\n\", \"\\n\", first, rest...);\n}\ntemplate <typename F, typename... R>\nvoid print(const F &first, const R &... rest) {\n    print_to(std::cout, \" \", \"\\n\", first, rest...);\n}\ntemplate <typename I>\nvoid println_(I begin, I end) {\n    print_to_(std::cout, \"\\n\", \"\\n\", begin, end);\n}\ntemplate <typename I>\nvoid print_(I begin, I end) {\n    print_to_(std::cout, \" \", \"\\n\", begin, end);\n}\ntemplate <typename C>\nvoid println_(const C &cntnr) {\n    println_(std::begin(cntnr), std::end(cntnr));\n}\ntemplate <typename C>\nvoid print_(const C &cntnr) {\n    print_(std::begin(cntnr), std::end(cntnr));\n}\nint _ = (\n#ifndef LOCAL\n    std::cin.tie(nullptr), std::ios::sync_with_stdio(false),\n#endif\n    std::cout.precision(10), std::cout.setf(std::ios::fixed));\n}\nusing io::print;\nusing io::println;\nusing io::println_;\nusing io::print_;\ntemplate <typename T>\nusing vec = std::vector<T>;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n// const int MOD = 1000000007;\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nstd::vector<Weight> dijkstra(const Graph &g, int s) {\n    const Weight INF = std::numeric_limits<Weight>::max() / 8;\n    using state = std::tuple<Weight, int>;\n    std::priority_queue<state> q;\n    std::vector<Weight> dist(g.size(), INF);\n    dist[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        Weight d;\n        int v;\n        std::tie(d, v) = q.top();\n        q.pop();\n        d *= -1;\n        /* if(v == t) return d; */\n        if (dist[v] < d) continue;\n        for (auto &e : g[v]) {\n            if (dist[e.dst] > dist[v] + e.weight) {\n                dist[e.dst] = dist[v] + e.weight;\n                q.emplace(-dist[e.dst], e.dst);\n            }\n        }\n    }\n    return dist;\n}\n\nint h, w;\n\nbool inner(int i, int j) {\n    return !(i < 0 || i >= h || j < 0 || j >= w);\n}\n\n\n\nsigned main() {\n    vec<string> g;\n    while (cin >> h >> w) {\n        char s, t;\n        cin >> s >> t;\n        g.resize(h);\n        rep(i, h) {\n            cin >> g[i];\n        }\n\n        Graph graph(26);\n        rep(i, h) rep(j, w) {\n            static const pii dir[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n            if ('A' <= g[i][j] && g[i][j] <= 'Z') {\n                int di, dj;\n                rep(d, 4) {\n                    tie(di, dj) = dir[d];\n                    int ni = i + di * 1;\n                    int nj = j + dj * 1;\n                    while (inner(ni, nj) && !('A' <= g[ni][nj] && g[ni][nj] <= 'Z')) {\n                        ni += di;\n                        nj += dj;\n                    }\n                    if (inner(ni, nj)) {\n                        char cell = g[ni][nj];\n                        assert('A' <= cell && cell <= 'Z');\n                        int a = g[i][j] - 'A';\n                        int b = g[ni][nj] - 'A';\n                        dump(a, b);\n                        add_arc(graph, a, b, 1);\n                    }\n                }\n            }\n        }\n\n        auto dist = dijkstra(graph, s - 'A');\n        int ans = dist[t - 'A'];\n        print(ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nconst int MAX_V = 50 * 50 + 1;\n\n\nint H,W;\nchar s,t;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nvoid Dijkstra(int s){\n  fill(d,d+MAX_V,INF);\n  fill(used,used+V,false);\n  d[s]=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<MAX_V;u++){\n      if(!used[u] && (v==-1||d[u]<d[v]))v=u;\n    }\n    if(v==-1)break;\n    used[v]=true;\n    for(int u=0;u<MAX_V;u++){\n      \n      d[u]=min(d[u],d[v]+cost[v][u]);\n    }\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\nvoid add_path(int x,int y){\n  int dx[2]={-1,0};\n  int dy[2]={0,-1};\n  rep(i,2){\n    int xx=dx[i]+x,yy=dy[i]+y;\n    if(graph[y][x]=='-'){\n      if(graph[yy][xx]=='o'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }else if(graph[yy][xx]=='-'){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }\n    }else if(graph[y][x]=='|'){\n      if(graph[yy][xx]=='o'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }else if(graph[yy][xx]=='|'){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }\n    }else if('A'<=graph[y][x]&&graph[y][x]<='Z'){\n      cost[y*W+x][yy*W+xx]=0;\n      cost[yy*W+xx][y*W+x]=0;\n    }else if(graph[y][x]=='o'){\n      if(graph[yy][xx]=='o'||('A'<=graph[yy][xx]&&graph[yy][xx]<='Z')){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }else if(graph[yy][xx]=='-'||graph[yy][xx]=='|'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }\n    }\n  }\n}\n\nint main(){\n  \n  cin>>H>>W>>s>>t;\n  int start,goal;\n  rep(i,H){\n    rep(j,W){\n      cin>>graph[i][j];\n      if(graph[i][j]==s)start=i*W+j;\n      if(graph[i][j]==t)goal=i*W+j;\n    }\n  }\n\n  rep(i,50*50+1){\n    rep(j,50*50+1)cost[i][j]=INF;\n  }\n  \n  REP(i,1,H){\n    REP(j,1,W){\n      add_path(j,i);\n    }\n  }\n\n  Dijkstra(start);\n  cout<<d[goal] / 2<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nint h,w;\nchar a,b;\nstring s[51];\n\nii getP(char c) {\n  rep(i,h) {\n    rep(j,w) {\n      if( s[i][j] == c ) return ii(j,i);\n    }\n  }\n  assert(false);\n}\n\nint mini[51][51];\n\nstruct Data {\n  int x,y,c;\n  bool operator < ( const Data &data) const {\n    if( c != data.c ) return c > data.c;\n    return x < data.x;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvoid compute() {\n  ii sp = getP(a), ep = getP(b);\n  rep(i,h) rep(j,w) mini[i][j] = INT_MAX;\n  mini[sp.second][sp.first] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){sp.first,sp.second,0});\n  while( !Q.empty() ) {\n    Data d = Q.top(); Q.pop();\n    rep(i,4) {\n      int nx = d.x + dx[i];\n      int ny = d.y + dy[i];\n      if( !( 0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n      char c = s[ny][nx];\n      if( c == '.' ) continue;\n      int coef = 0;\n      if( s[d.y][d.x] == 'o'  && ( c == '-' || c == '|' ) ) {\n\tcoef = 1;\n      }\n      if( mini[ny][nx] > d.c + coef ) {\n\tmini[ny][nx] = d.c + coef;\n\tQ.push((Data){nx,ny,mini[ny][nx]});\n      }\n    }\n  }\n  cout <<mini[ep.second][ep.first] << endl;\n}\n\nint main() {\n  cin >> h  >> w >> a >> b;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[26];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nbool f[51][51];\nvoid dfs(int y, int x, int now){\n    if(!contain(y, x)) return;\n    if(f[y][x]) return;\n    f[y][x] = true;\n    if(c[y][x] == '.') return;\n    if(c[y][x] == 'o'){\n        rep(i, 0, 4){\n            int ty = y + dy[i];\n            int tx = x + dx[i];\n            if(!contain(ty, tx)) continue;\n            if('A' <= c[ty][tx] && c[ty][tx] <= 'Z'){\n                G[now].push_back(c[ty][tx] - 'A');\n                // cout << (char)('A' + now) << \" \" << c[ty][tx] << endl;\n            }\n        }\n        return;\n    }\n    rep(i, 0, 4){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(!contain(ny, nx)) continue;\n        if(f[ny][nx]) continue;\n        if(c[y][x] == '-' && c[ny][nx] == '-'){\n            if(i == 1 || i == 0) continue;\n        }\n        if(c[y][x] == '|' && c[ny][nx] == '|'){\n            if(i == 2 || i == 3) continue;\n        }\n        dfs(ny, nx, now);\n    }\n    // if(c[y][x] == '-'){\n    //     dfs(y, x - 1, now);\n    //     dfs(y, x + 1, now);\n    // }\n    // if(c[y][x] == '|'){\n    //     dfs(y - 1, x, now);\n    //     dfs(y + 1, x, now);\n    // }\n    return;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 26) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            rep(k, 0, 51) rep(l, 0, 51) f[k][l] = false;\n            // cout << i << ' ' << j << endl;\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            // bool f[51][51] = {};\n            if(!contain(y, x)) continue;\n            f[idx[i].first][idx[i].second] = true;\n            f[idx[i].first + dy[j]][idx[i].second + dx[j]] = true;\n            // f[y][x] = true;\n            dfs(y, x, i);\n            // if(c[y][x] == '.') continue;\n            // while(1){\n            //     int ny = -1, nx = -1;\n            //     // cout << i << ' ' << j << ' ' << y << ' ' << x << ' ' << c[y][x] << endl;\n            //     rep(k, 0, 4){\n            //         if(c[y][x] == '|'){\n            //             if(k == 2 || k == 3) continue;\n            //         }\n            //         if(c[y][x] == '-'){\n            //             if(k == 0 || k == 1) continue;\n            //         }\n            //         ny = y + dy[k];\n            //         nx = x + dx[k];\n            //         if(!contain(ny, nx)) continue;\n            //         if(f[ny][nx]) continue;\n                    \n            //         if(c[ny][nx] == '-'){\n            //             break;\n            //         }\n            //         if(c[ny][nx] == '|'){\n            //             break;\n            //         }\n            //         if(c[ny][nx] == 'o'){\n            //             ny += dy[k];\n            //             nx += dx[k];\n            //             break;\n            //         }\n            //     }\n            //     y = ny;\n            //     x = nx;\n            //     f[y][x] = true;\n            //     if('A' <= c[y][x] && c[y][x] <= 'Z'){\n            //         G[i].push_back(c[y][x] - 'A');\n            //         // cout << (char)('A' + i) << ' ' << c[y][x] << endl;\n            //         break;\n            //     }\n            // }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n/*\n7 7 A D\nooo.ooo\noAo-oBo\nooo.ooo\n.|..|.\n.|..ooo\n.---oDo\n....ooo\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_sum_cost,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t\tdir = arg_dir;\n\t}\n\tint row,col,sum_cost;\n\tDIR dir;\n};\n\nint H,W;\nint min_dist[26];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar table[50][51],start[2],goal[2];\nDIR dir_array[4] = {North,East,South,West};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %s %s\",&H,&W,start,goal);\n\n\tint start_row,start_col;\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(table[row][col] == start[0]){\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++)min_dist[i] = BIG_NUM;\n\n\tqueue<Info> Q;\n\tmin_dist[start[0]-'A'] = 0;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tQ.push(Info(start_row,start_col,0,dir_array[i]));\n\t}\n\n\tint adj_row,adj_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(table[Q.front().row][Q.front().col] == goal[0]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tif(Q.front().dir != dir_array[i])continue; //方向が同じでなければSKIP\n\n\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '.')continue;\n\n\t\t\t\tif(table[adj_row][adj_col] >= 'A' && table[adj_row][adj_col] <= 'Z'){ //ノードに到着\n\t\t\t\t\tif(min_dist[table[adj_row][adj_col]-'A'] <= Q.front().sum_cost+1)continue;\n\t\t\t\t\tmin_dist[table[adj_row][adj_col]-'A'] = Q.front().sum_cost+1;\n\n\t\t\t\t\tfor(int k = 0; k < 4; k++){ //方向転換\n\t\t\t\t\t\tQ.push(Info(adj_row,adj_col,min_dist[table[adj_row][adj_col]-'A'],dir_array[k]));\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,Q.front().sum_cost,Q.front().dir));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_dist[goal[0]-'A']);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                if(!inrange(now.first, now.second)) break;\n            }\n            if(!inrange(now.first, now.second))continue;\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 52 * 52 + 1;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[2] = {-1, 0};\n  int dy[2] = {0, -1};\n  rep(i, 2) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '-') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      assert(cost[y * W + x][yy * W + xx] == INF);\n      assert(cost[yy * W + xx][y * W + x] == INF);\n      cost[y * W + x][yy * W + xx] = 0;\n      cost[yy * W + xx][y * W + x] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  REP(i, 1, H) REP(j, 1, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(p.second % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;char a,b;cin>>n>>m>>a>>b;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tvvi G(26,vi(26,inf));\n\trep(i,26)G[i][i]=0;\n\t\n\trep(i,n){\n\t\tchar s;\n\t\tbool h=false;\n\t\trep(j,m){\n\t\t\tif(in[i][j]=='-'&&!h){\n\t\t\t\ts=in[i][j-2]-'A';\n\t\t\t\th=true;\n\t\t\t}else if(in[i][j]!='-'&&h){\n\t\t\t\th=false;\n\t\t\t\tG[s][in[i][j+1]-'A']=\n\t\t\t\t\tG[in[i][j+1]-'A'][s]=1;\n//\t\t\t\tcout<<(char)(s+'A')<<\" \"<<in[i][j+1]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\trep(j,m){\n\t\tchar s;\n\t\tbool h=false;\n\t\trep(i,n){\n\t\t\tif(in[i][j]=='|'&&!h){\n\t\t\t\ts=in[i-2][j]-'A';\n\t\t\t\th=true;\n\t\t\t}else if(in[i][j]!='|'&&h){\n\t\t\t\th=false;\n\t\t\t\tG[s][in[i+1][j]-'A']=\n\t\t\t\t\tG[in[i+1][j]-'A'][s]=1;\n//\t\t\t\tcout<<(char)(s+'A')<<\" \"<<in[i+1][j]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\trep(k,26)rep(i,26)rep(j,26)\n\t\tG[i][j]=min(G[i][k]+G[k][j],G[i][j]);\n\t\t\n\tcout<<G[a-'A'][b-'A']<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dbg(x) cout<<#x<<\":\"<<x<<endl\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nint main(){\n  int h,w;\n  vector<int> g[30];\n  char s,t,a[50][50];\n  cin>>h>>w>>s>>t;  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>a[i][j];\n    }\n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if('A'>=a[i][j]||a[i][j]>='Z')continue;\n      \n      int dx[4]={0,1,0,-1};\n      int dy[4]={1,0,-1,0};\n      for(int k=0;k<4;k++){\n\tint tx=i+dx[k],ty=j+dy[k];\n\twhile(1){\n\t  if(tx<0||h<=tx||ty<0||w<=ty)break;\n\t  if(a[tx][ty]=='.')break;\n\t  if(k%2&&a[tx][ty]=='-')break;\n\t  if(k%2==0&&a[tx][ty]=='|')break;\n\t  if('A'<=a[tx][ty]&&a[tx][ty]<='Z'){\n\t    g[a[i][j]-'A'].pb(a[tx][ty]-'A');\n\t    g[a[tx][ty]-'A'].pb(a[i][j]-'A');\n\t    break;\n\t  }\n\t  tx+=dx[k],ty+=dy[k];\n\t}\n      }\n    }\n  }\n\n  queue<P>q;\n  q.push(P(s-'A',0));\n  int used[30]={};\n\n  while(q.size()){\n    int node=q.front().fi;\n    int l=q.front().se;\n    q.pop();\n    if(node==t-'A'){\n      cout<<l<<endl;\n      return 0;\n    }\n    if(used[node])continue;\n    used[node]=1;\n    for(int i=0;i<g[node].size();i++){\n      q.push(P(g[node][i],l+1));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define CHMIN(a,b) (a)=min((a),(b))\ntypedef long long ll;\ntypedef vector<int> vi;\n\nchar buf[25];\n\nint h,w;\nchar s,t;\nchar mp[52][52];\n\nint g[26][26];\n\nint ddd[5] = {1,0,-1,0,1};\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  scanf(\"%s\",buf); s=buf[0];\n  scanf(\"%s\",buf); t=buf[0];\n  REP(i,h)scanf(\"%s\",mp[i]);\n  REP(i,26)REP(j,26)g[i][j] = 10000000;\n  REP(i,h)REP(j,w)if(isalpha(mp[i][j]) && mp[i][j]!='o'){\n    int id = mp[i][j]-'A';\n    REP(d,4){\n      int ni = i+ddd[d];\n      int nj = j+ddd[d+1];\n      while(true){\n        if(ni>=h || nj>=w || ni<0 || nj<0)break;\n        if(mp[ni][nj]=='.')break;\n        if(isalpha(mp[ni][nj]) && mp[ni][nj]!='o'){\n          int nid = mp[ni][nj]-'A';\n          g[id][nid] = g[nid][id] = 1;\n          // printf(\"%d - %d\\n\",id,nid);\n          break;\n        }\n        ni += ddd[d];\n        nj += ddd[d+1];\n      }\n    }\n  }\n  // printf(\"s:%d, t:%d\\n\",s-'A',t-'A');\n  REP(k,26)REP(i,26)REP(j,26)CHMIN(g[i][j],g[i][k]+g[k][j]);\n  printf(\"%d\\n\",g[s-'A'][t-'A']);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nint di[4] = {1, 0, -1, 0}, dj[4] = {0, 1, 0, -1};\n\nmain {\n  int H, W;\n  char s, t;\n  cin >> H >> W >> s >> t;\n  vector<vector<char>> m(H, vector<char>(W));\n  int S, G;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> m[i][j];\n      if (isupper(m[i][j])) {\n        if (m[i][j] == s) S = i * W + j;\n        if (m[i][j] == t) G = i * W + j;\n        m[i][j] = 'o';\n      }\n    }\n  }\n\n  Graph g(H * W);\n  rep(i, H) rep(j, W) {\n    rep(k, 4) {\n      int i2 = i + di[k], j2 = j + dj[k];\n      if (i2 < 0 || j2 < 0 || i2 >= H || j2 >= W) continue;\n      if (m[i][j] == '-') {\n        if ((k==1||k==3)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '-') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == '|') {\n        if ((k==0||k==2)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == 'o') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        } else if (m[i2][j2] == '-' || m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        }\n      }\n    }\n  }\n  cout << dijkstra(g, S).first[G] / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\trep(i,4){\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\ta[y+i][x+j] = a[y][x];\n\t\t\t\tused[y+i][x+j] = 1;\n\t\t\t\tif((x*y)*(x*y) == 1)a[y][x] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill((int*)used, (int*)(used+100), 0);\n\trrep(i,h)rrep(j,w){\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\t/*int x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t}*/\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", used[i][j]+'A'-1);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nconst int INF = 1 << 29;\nconst int vy[] = {1, 0, -1, 0};\nconst int vx[] = {0, -1, 0, 1};\n\ntemplate< typename T = int >\nvoid warshall_floyd(Matrix< T > &g) {\n  for(int k = 0; k < g.size(); k++) {\n    for(int i = 0; i < g.size(); i++) {\n      for(int j = 0; j < g.size(); j++) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int H, W;\n  char S, T;\n  string A[50];\n  cin >> H >> W >> S >> T;\n  for(int i = 0; i < H; i++) {\n    cin >> A[i];\n  }\n\n  Matrix< int > mat(26, vector< int >(26, INF));\n  for(int i = 0; i < 26; i++) mat[i][i] = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(isupper(A[i][j])) {\n        for(int k = 0; k < 4; k++) {\n          int ny = i + vy[k], nx = j + vx[k];\n\n          while(0 <= ny && ny < H && 0 <= nx && nx < W) {\n            if(isupper(A[ny][nx])) {\n              mat[A[i][j] - 'A'][A[ny][nx] - 'A'] = 1;\n              break;\n            } else if(A[ny][nx] == '.' || A[ny][nx] == 'o') {\n              break;\n            }\n            ny += vy[k];\n            nx += vx[k];\n          }\n\n        }\n      }\n    }\n  }\n  warshall_floyd(mat);\n  cout << mat[S - 'A'][T - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\n\nint dy[4] = {0,2,0,-2};\nint dx[4] = {2,0,-2,0};\nint dir[12] = {0,1,2,3};\nint diry[4] = {0,1,0,-1};\nint dirx[4] = {1,0,-1,0};\n\nchar bar[4] = {'-','|','-','|'};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll H,W; cin >> H >> W;\n    char cs,ct; cin >> cs >> ct;\n    ll s,t; s = (cs - 'A'); t = (ct - 'A');\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'#'));\n    map<char,pii> mp;\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] >= 'A' && masu[i][j] <= 'Z'){\n                mp[masu[i][j]] = {i,j};\n            }\n        }\n    }\n    \n    for(auto m:mp){\n        auto p = m.second;\n        for(int i = -1;i <= 1; i++){\n            for(int j = -1; j <= 1;j++){\n                masu[p.first+i][p.second+j] = masu[p.first][p.second];\n            }\n        }\n    }\n    \n    //    cout << masu << endl;\n    \n    vector<vector<int>> G(30);\n    for(auto m:mp){\n        auto p = m.second;\n        int u = masu[p.first][p.second] - 'A';\n        for(int i = 0; i < 4;i++){\n            char masu_c = masu[p.first+dy[i]][p.second+dx[i]];\n            if(masu_c == bar[i]){\n                int ny = p.first+dy[i],nx = p.second+dx[i];\n                while(true){\n                    if(ny > H || ny < 1 || nx > W || nx < 1) break;\n                    if(masu[ny][nx] == '#') break;\n                    if(masu[ny][nx] == bar[i]){\n                        ny += diry[dir[i]]; nx += dirx[dir[i]];\n                        continue;\n                    }\n                    if(masu[ny][nx] >= 'A' && masu[ny][nx] <= 'Z'){\n                        int v = masu[ny][nx] - 'A';\n                        G[u].push_back(v);\n                        G[v].push_back(u);\n                        break;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    \n    \n    vector<ll> dist(30,INF);\n    dist[s] = 0;\n    queue<ll> q; q.push(s);\n    while(q.size()){\n        ll n = q.front(); q.pop();\n        for(auto next:G[n]){\n            if(dist[next] > dist[n] + 1){\n                dist[next] = dist[n] + 1;\n                q.push(next);\n            }\n        }\n    }\n//    cout << dist << endl;\n    cout << dist[t] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<ll>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    char s, t;\n    cin >> H >> W >> s >> t;\n    vector<vector<char> > ch(H + 2, vector<char>(W + 2, '.'));\n\n    rep(i, 1, H + 1) {\n        rep(j, 1, W + 1) {\n            cin >> ch[i][j];\n        }\n    }\n\n    Dijkstra dij(26);\n\n    for (int i = 1; i < H + 1; i++) {\n        for (int j = 1; j < W + 1; j++) {\n            char c = ch[i][j];\n            if (c >= 'A' && c <= 'Z') {\n                for (int di = 1; ch[i + di][j] != '.'; di++) {\n                    if (ch[i + di][j] >= 'A' && ch[i + di][j] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i + di][j] - 'A', 1);\n                        dij.addEdge(ch[i + di][j] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n                for (int dj = 1; ch[i][j + dj] != '.'; dj++) {\n                    if (ch[i][j + dj] >= 'A' && ch[i][j + dj] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i][j + dj] - 'A', 1);\n                        dij.addEdge(ch[i][j + dj] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    dij.dijkstra(s - 'A');\n    cout << dij.d[t - 'A'];\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  int ss = s-'A', tt = t-'A';\n  queue<int>  que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = pos[u].first+dy[i], nx = pos[u].second+dx[i];\n      ny += dy[i];\n      nx += dx[i];\n      int cnt = 0;\n      while(in(ny, nx) && (((i==0||i==2) && mas[ny][nx] == '|') || ((i==1||i==3) && mas[ny][nx] == '-'))) {\n\tny += dy[i];\n\tnx += dx[i];\n\t++cnt;\n      }\n      if(cnt == 0) continue;\n      ny += dy[i];\n      nx += dx[i];\n      if(!in(ny, nx) || !isalpha(mas[ny][nx])) continue;\n      int v = mas[ny][nx]-'A';\n      if(dist[v] != -1) continue;\n      dist[v] = dist[u]+1;\n      que.push(v);\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int64_t\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nnamespace io {\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        io::print_to(os, \", \", \"\\n\", __VA_ARGS__);        \\\n        std::cerr << io::highlight(os.str());             \\\n    } while (0)\n#define dump_(cntnr)                                 \\\n    do {                                             \\\n        std::ostringstream os;                       \\\n        os << __LINE__ << \":\\t\" << #cntnr << \" = [\"; \\\n        io::print_to_(os, \", \", \"]\\n\", all(cntnr));  \\\n        std::cerr << io::highlight(os.str());        \\\n    } while (0)\n#define dumpf(fmt, ...)                             \\\n    do {                                            \\\n        const int N = 4096;                         \\\n        auto b = new char[N];                       \\\n        int l = snprintf(b, N, \"%d:\\t\", __LINE__);  \\\n        snprintf(b + l, N - l, fmt, ##__VA_ARGS__); \\\n        std::cerr << io::highlight(b) << std::endl; \\\n        delete[] b;                                 \\\n    } while (0)\n#else\n#define dump(...)\n#define dump_(...)\n#define dumpf(...)\n#endif\nstd::string highlight(std::string s) {\n#ifdef _MSC_VER\n    return s;\n#else\n    return \"\\033[33m\" + s + \"\\033[0m\";\n#endif\n}\ntemplate <typename T>\nvoid print_to(std::ostream &os, std::string, std::string tail, const T &first) {\n    os << first << tail;\n}\ntemplate <typename F, typename... R>\nvoid print_to(std::ostream &os, std::string del, std::string tail, const F &first,\n              const R &... rest) {\n    os << first << del;\n    print_to(os, del, tail, rest...);\n}\ntemplate <typename I>\nvoid print_to_(std::ostream &os, std::string del, std::string tail, I begin, I end) {\n    for (I it = begin; it != end;) {\n        os << *it;\n        os << (++it != end ? del : tail);\n    }\n}\ntemplate <typename F, typename... R>\nvoid println(const F &first, const R &... rest) {\n    print_to(std::cout, \"\\n\", \"\\n\", first, rest...);\n}\ntemplate <typename F, typename... R>\nvoid print(const F &first, const R &... rest) {\n    print_to(std::cout, \" \", \"\\n\", first, rest...);\n}\ntemplate <typename I>\nvoid println_(I begin, I end) {\n    print_to_(std::cout, \"\\n\", \"\\n\", begin, end);\n}\ntemplate <typename I>\nvoid print_(I begin, I end) {\n    print_to_(std::cout, \" \", \"\\n\", begin, end);\n}\ntemplate <typename C>\nvoid println_(const C &cntnr) {\n    println_(std::begin(cntnr), std::end(cntnr));\n}\ntemplate <typename C>\nvoid print_(const C &cntnr) {\n    print_(std::begin(cntnr), std::end(cntnr));\n}\nint _ = (\n#ifndef LOCAL\n    std::cin.tie(nullptr), std::ios::sync_with_stdio(false),\n#endif\n    std::cout.precision(10), std::cout.setf(std::ios::fixed));\n}\nusing io::print;\nusing io::println;\nusing io::println_;\nusing io::print_;\ntemplate <typename T>\nusing vec = std::vector<T>;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n// const int MOD = 1000000007;\n\nint grid_bfs(const vector<string> &g, char S, char T) {\n    const int INF = 1e18;\n    using pii = pair<int, int>;\n\n    int h = g.size(), w = g[0].size();\n    static const auto is_valid = [&](int i, int j) {\n        if (i < 0 || i >= h || j < 0 || j >= w) return false;\n        if (g[i][j] == '.') return false;\n        return true;\n    };\n\n    static const pii dir[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    priority_queue<pair<int, pii>> q;\n    vector<vector<int>> d(h, vector<int>(w, INF));\n\n    rep(i, h) rep(j, w) {\n        if (g[i][j] == S) {\n            dump(S, g[i][j], i, j);\n            d[i][j] = 0;\n            q.emplace(0, pii(i, j));\n        }\n    }\n\n    while (q.size()) {\n        int ci, cj;\n        auto top = q.top();\n        int cd = -top.first;\n        tie(ci, cj) = top.second;\n        q.pop();\n\n        if (d[ci][cj] > cd) continue;\n\n        if (g[ci][cj] == T) {\n\n            for(auto &r : d) {\n                dump_(r);\n            }\n\n            return cd;\n        }\n\n        for (auto &v : dir) {\n            int ni = ci + v.first;\n            int nj = cj + v.second;\n            if (is_valid(ni, nj)) {\n                char cell = g[ni][nj];\n                int cost;\n                if ('A' <= cell && cell <= 'Z') {\n                    cost = 1;\n                } else {\n                    cost = 0;\n                }\n                int nd = d[ci][cj] + cost;\n                if (d[ni][nj] > nd) {\n                    d[ni][nj] = nd;\n                    q.emplace(-nd, pii(ni, nj));\n                }\n            }\n        }\n    }\n\n    // dump(\"ha?\");\n    abort();\n}\n\nsigned main() {\n    int h, w;\n    vec<string> g;\n    cin >> h >> w;\n    char s, t;\n    cin >> s >> t;\n    g.resize(h);\n    rep(i, h) {\n        cin >> g[i];\n    }\n\n    rep(i, h) rep(j, w) {\n        if ('A' <= g[i][j] && g[i][j] <= 'Z') {\n            FOR(di, -1, 2) {\n                FOR(dj, -1, 2) {\n                    int ni = i + di, nj = j + dj;\n                    if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n                    if (di == 0 || dj == 0) continue;\n                    g[ni][nj] = '.';\n                }\n            }\n        }\n    }\n\n    rep(i, h) {\n        dump(g[i]);\n    }\n\n    int ans = grid_bfs(g, s, t);\n    print(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<ll>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    char s, t;\n    cin >> H >> W >> s >> t;\n    vector<vector<char> > ch(H + 2, vector<char>(W + 2, '.'));\n\n    rep(i, 1, H + 1) {\n        rep(j, 1, W + 1) {\n            cin >> ch[i][j];\n        }\n    }\n\n    Dijkstra dij(26);\n\n    for (int i = 1; i < H + 1; i++) {\n        for (int j = 1; j < W + 1; j++) {\n            char c = ch[i][j];\n            if (c >= 'A' && c <= 'Z') {\n                for (int di = 1; ch[i + di][j] != '.'; di++) {\n                    if (ch[i + di][j] >= 'A' && ch[i + di][j] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i + di][j] - 'A', 1);\n                        dij.addEdge(ch[i + di][j] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n                for (int dj = 1; ch[i][j + dj] != '.'; dj++) {\n                    if (ch[i][j + dj] >= 'A' && ch[i][j + dj] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i][j + dj] - 'A', 1);\n                        dij.addEdge(ch[i][j + dj] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    dij.dijkstra(s - 'A');\n    cout << dij.d[t - 'A'];\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n#define MAX 2000\nint h,w;\nchar a,b;\nstring s[MAX];\n\nii getP(char c) {\n  rep(i,h) {\n    rep(j,w) {\n      if( s[i][j] == c ) return ii(j,i);\n    }\n  }\n  assert(false);\n}\n\nint mini[MAX][MAX];\n\nstruct Data {\n  int x,y,c;\n  bool operator < ( const Data &data) const {\n    if( c != data.c ) return c > data.c;\n    return x < data.x;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvoid compute() {\n  ii sp = getP(a), ep = getP(b);\n  rep(i,h) rep(j,w) mini[i][j] = INT_MAX;\n  mini[sp.second][sp.first] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){sp.first,sp.second,0});\n  while( !Q.empty() ) {\n    Data d = Q.top(); Q.pop();\n    rep(i,4) {\n      int nx = d.x + dx[i];\n      int ny = d.y + dy[i];\n      if( !( 0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n      char c = s[ny][nx];\n      if( c == '.' ) continue;\n      int coef = 0;\n      if( s[d.y][d.x] == 'o'  && ( c == '-' || c == '|' ) ) {\n\tcoef = 1;\n      }\n      if( mini[ny][nx] > d.c + coef ) {\n\tmini[ny][nx] = d.c + coef;\n\tQ.push((Data){nx,ny,mini[ny][nx]});\n      }\n    }\n  }\n  cout <<mini[ep.second][ep.first] << endl;\n}\n\nint main() {\n  cin >> h  >> w >> a >> b;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[30];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 30) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            if(!contain(y, x)) continue;\n            if(c[y][x] == '|'){\n                if(j == 2 || j == 3) continue;\n            }\n            if(c[y][x] == '-'){\n                if(j == 1 || j == 0) continue;\n            }\n            while(1){\n                if(!contain(y, x)) break;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    break;\n                }\n                if(c[y][x] == '.') break;\n                y += dy[j];\n                x += dx[j];\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n \nusing namespace std;\ntypedef pair<int,int>P;\n \nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint dx1[]={-1,-1,-1,0,0,1,1,1};\nint dy1[]={-1,0,1,-1,1,-1,0,1};\nint h,w;\nchar S,T;\n \nvector<int>v[1000];\n \nint sx,sy,gx,gy;\nstring s[100];\n \nvoid INPUT(){\n \n  cin>>h>>w>>S>>T; \n \n  r(i,h)cin>>s[i];\n \n  r(i,h)r(j,w){\n    if(s[i][j]==S)sx=j,sy=i;\n    if(s[i][j]==T)gx=j,gy=i;\n  }\n}\n \nvoid make_GRAPH(){\n  r(i,h)r(j,w)if('A'<=s[i][j]&&s[i][j]<='Z'){\n    r(k,4){\n      int x=j+dx[k]+dx[k];\n      int y=i+dy[k]+dy[k];\n      if(x<0||y<0||x>=w||y>=h)continue;\n      if(k%2==1&&s[y][x]=='|')continue;\n      if(k%2==0&&s[y][x]=='-')continue;\n \n      if(k%2==1&&s[y][x]=='-'){\n        while(s[y][x]=='-'){\n          y+=dy[k];\n          x+=dx[k];\n        }\n        y+=dy[k];\n        x+=dx[k];\n        v[s[i][j]-'A'].push_back(s[y][x]-'A');\n      }\n \n      else if(k%2==0&&s[y][x]=='|'){\n        while(s[y][x]=='|'){\n          y+=dy[k];\n          x+=dx[k];\n        }\n        y+=dy[k];\n        x+=dx[k];\n        v[s[i][j]-'A'].push_back(s[y][x]-'A');\n      }\n \n    }\n  }\n}\nbool used[100009];\nint d[100005];\n \nvoid BFS(){\n \n  queue<P>q;\n \n  q.push(P(s[sy][sx]-'A',0));\n  used[s[sy][sx]-'A']=1;\n \n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int x=p.first;\n    int cost=p.second;\n    d[x]=cost;\n    r(i,v[x].size()){\n      int next=v[x][i];\n      if(!used[next]){\n        used[next]=1;\n        q.push(P(next,cost+1));\n      }\n    }\n  }\n  cout<<d[s[gy][gx]-'A']<<endl;\n}\n \nint main(){\n  INPUT();\n  make_GRAPH();\n  BFS();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[26];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 26) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            // cout << i << ' ' << j << endl;\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            bool f[51][51] = {};\n            if(!contain(y, x)) continue;\n            f[idx[i].first][idx[i].second] = true;\n            f[idx[i].first + dy[j]][idx[i].second + dx[j]] = true;\n            f[y][x] = true;\n            if(c[y][x] == '.') continue;\n            while(1){\n                int ny = -1, nx = -1;\n                // cout << i << ' ' << j << ' ' << y << ' ' << x << ' ' << c[y][x] << endl;\n                rep(k, 0, 4){\n                    ny = y + dy[k];\n                    nx = x + dx[k];\n                    if(!contain(ny, nx)) continue;\n                    if(f[ny][nx]) continue;\n                    if(c[ny][nx] == '-' || c[ny][nx] == '|' || c[ny][nx] == 'o'){\n                        if(c[ny][nx] == 'o'){\n                            ny += dy[k];\n                            nx += dx[k];\n                        }\n                        break;\n                    }\n                }\n                y = ny;\n                x = nx;\n                f[y][x] = true;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    // cout << (char)('A' + i) << ' ' << c[y][x] << endl;\n                    break;\n                }\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nconst ll INF = 1145148931919810;\nint main(){\n    map<char, ll> m;\n    for(ll i = 0; i < 26; i++) m['A' + i] = i;\n    ll dist[26][26];\n    for(ll i = 0; i < 26; i++)for(ll j = 0; j < 26; j++) dist[i][j] = (i == j ? 0 : INF);\n    ll h, w;\n    char start, goal;\n    cin >> h >> w >> start >> goal;\n    string s[h];\n    for(ll i = 0; i < h; i++) cin >> s[i];\n    for(ll i = 0; i < h; i++){\n        char now;\n        bool st = 0;\n        for(ll j = 0; j < w; j++){\n            if('A' <= s[i][j] && s[i][j] <= 'Z'){\n                if(st){\n                    dist[m[now]][m[s[i][j]]] = dist[m[s[i][j]]][m[now]] = 1;\n                    st = 0;\n                }\n                now = s[i][j];\n            }else if(s[i][j] == '-'){\n                st = 1;\n            }\n        }\n    }\n    for(ll i = 0; i < w; i++){\n        char now;\n        bool st = 0;\n        for(ll j = 0; j < h; j++){\n            if('A' <= s[j][i] && s[j][i] <= 'Z'){\n                if(st){\n                    dist[m[now]][m[s[j][i]]] = dist[m[s[j][i]]][m[now]] = 1;\n                    st = 0;\n                }\n                now = s[j][i];\n            }else if(s[j][i] == '|'){\n                st = 1;\n            }\n        }\n    }\n    //for(ll i = 0; i < 26; i++)for(ll j = i + 1; j < 26; j++) cout << (char)('A' + i) << \", \" << (char)('A' + j) << \": \" << dist[i][j] << endl;\n    for(ll k = 0; k < 26; k++)for(ll i = 0; i < 26; i++)for(ll j = 0; j < 26; j++) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n    cout << dist[m[start]][m[goal]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\n\nint dy[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dir[12] = {0,0,0,1,1,1,2,2,2,3,3,3};\nint diry[4] = {0,1,0,-1};\nint dirx[4] = {1,0,-1,0};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll H,W; cin >> H >> W;\n    char cs,ct; cin >> cs >> ct;\n    ll s,t; s = (cs - 'A'); t = (ct - 'A');\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'#'));\n    map<char,pii> mp;\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] >= 'A' && masu[i][j] <= 'Z'){\n                mp[masu[i][j]] = {i,j};\n            }\n        }\n    }\n    \n    for(auto m:mp){\n        auto p = m.second;\n        for(int i = -1;i <= 1; i++){\n            for(int j = -1; j <= 1;j++){\n                masu[p.first+i][p.second+j] = masu[p.first][p.second];\n            }\n        }\n    }\n    \n    //    cout << masu << endl;\n    \n    vector<vector<int>> G(26);\n    for(auto m:mp){\n        auto p = m.second;\n        int u = masu[p.first][p.second] - 'A';\n        for(int i = 0; i < 12;i++){\n            char masu_c = masu[p.first+dy[i]][p.second+dx[i]];\n            if(masu_c == '|' || masu_c == '-'){\n                int ny = p.first+dy[i],nx = p.second+dx[i];\n                while(true){\n                    if(masu[ny][nx] == '#') break;\n                    if(masu[ny][nx] == '-' || masu[ny][nx] == '|'){\n                        ny += diry[dir[i]]; nx += dirx[dir[i]];\n                        continue;\n                    }\n                    \n                    int v = masu[ny][nx] - 'A';\n                    G[u].push_back(v);\n                    G[v].push_back(u);\n                    break;\n                }\n            }\n        }\n    }\n    \n    \n    vector<ll> dist(26,INF);\n    dist[s] = 0;\n    queue<ll> q; q.push(s);\n    while(q.size()){\n        ll n = q.front(); q.pop();\n        for(auto next:G[n]){\n            if(dist[next] > dist[n] + 1){\n                dist[next] = dist[n] + 1;\n                q.push(next);\n            }\n        }\n    }\n//    cout << dist << endl;\n    cout << dist[t] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n            }\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) sy = i, sx = j;\n\t\tif (a[i][j] == t) ty = i, tx = j;\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P {\n\t\tint y, x, d; \n\t\tbool operator>(const P& r) const {\n\t\t\treturn d > r.d;\n\t\t}\n\t};\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\tpq.push(P{sy,sx,4});\n\tdist[sy][sx] = 0;\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tif (p.d == 4) {\n\t\t\tREP(d, 4) {\n\t\t\t\tint dy = p.y + dy4[d];\n\t\t\t\tint dx = p.x + dx4[d];\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x]) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x];\n\t\t\t\t\tpq.push(P{dy,dx,d});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint dy = p.y + dy4[p.d];\n\t\t\tint dx = p.x + dx4[p.d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tif (IN('A', a[dy][dx], 'Z' + 1)) {\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x] + 1) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x] + 1;\n\t\t\t\t\tpq.push(P{dy,dx,4});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x]) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x];\n\t\t\t\t\tpq.push(P{dy,dx,p.d});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#endif\n\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(int i=0;i<N;++i)\ntypedef long long int LL;\nstruct edge { int to, cost; };\ntypedef std::pair<int, int> P;\n\nint H, W;\nchar s, t;\nstd::string a[51];\nstd::vector<edge>G[51];\nLL d[112345];\n\nvoid dijkstra(int s)\n{\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>>que;\n\tstd::fill(d, d + 51, 114514810);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tP p = que.top(); que.pop();\n\t\tLL v = p.second;\n\t\tif (d[v] < p.first) { continue; }\n\t\trep(i, G[v].size())\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tin >> H >> W >> s >> t;\n\trep(i, H) in >> a[i];\n\tfor (int i = 1; i < H - 1; ++i)\n\t{\n\t\tfor (int j = 1; j < W - 1; ++j)\n\t\t{\n\t\t\tif (a[i][j] != 'o'&&a[i][j] != '-'&&a[i][j] != '|'&&a[i][j] != '.')\n\t\t\t{\n\t\t\t\t// 右へ\n\t\t\t\tfor (int k = j + 2; k < W - 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][k] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[i][k + 1] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[i][k] != '-') break;\n\t\t\t\t}\n\t\t\t\t// 左へ\n\t\t\t\tfor (int k = j - 2; k > 1; --k)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][k] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[i][k - 1] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[i][k] != '-') break;\n\t\t\t\t}\n\t\t\t\t// 下へ\n\t\t\t\tfor (int k = i + 2; k < H - 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (a[k][j] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[k + 1][j] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[k][j] != '|') break;\n\t\t\t\t}\n\t\t\t\t// 上へ\n\t\t\t\tfor (int k = i - 2; k > 1; --k)\n\t\t\t\t{\n\t\t\t\t\tif (a[k][j] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[k - 1][j] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[k][j] != '|') break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(s - 'A');\n\tout << d[t - 'A'] << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nstruct Dijkstra {\n  Dijkstra(int V) : V(V), G(V) {}\n  struct edge {\n    edge(int to, long long cost) : to(to), cost(cost) {}\n    int to;\n    long long cost;\n  };\n\n  using P = pair<long long, int>;\n  const long long inf = 1001001001001001001ll;\n\n  int V;\n  vector<vector<edge>> G;\n  vector<long long> d;\n\n  void init(int n) {\n    V = n;\n    G.resize(n);\n  }\n\n  void debug() {\n    cerr << \"edges : \" << endl;\n    for (int i = 0; i < V; ++i)\n      for (auto e : G[i]) cerr << i << \" -> \" << e.to << \" : \" << e.cost << endl;\n    cerr << endl << \"dist : \" << endl;\n    for (int i = 0; i < V; ++i) cerr << i << \" : \" << d[i] << endl;\n  }\n\n  void add_edge(int u, int v, long long c) {\n    // cerr << u + 'A' << \" -> \" << v + 'A' << endl;\n    G[u].push_back(edge(v, c));\n  }\n\n  void build(int s) {\n    d.assign(V, inf);\n    priority_queue<P, vector<P>, greater<P>> q;\n\n    d[s] = 0;\n    q.push(P(0ll, s));\n\n    while (!q.empty()) {\n      P p = q.top();\n      q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto &e : G[v])\n        if (d[e.to] > p.first + e.cost) {\n          d[e.to] = p.first + e.cost;\n          q.push(P(d[e.to], e.to));\n        }\n    }\n  }\n\n  long long operator[](int v) {\n    return d[v];\n  }\n};\n\nDijkstra G(30);\nint h, w;\nchar a[60][60];\n\nvoid add_edge(int y, int x, int v) {\n  for (int i = y - 2; i > 0; --i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i - 1][x] - 'A', 1);\n    break;\n  }\n  for (int i = y + 2; i <= h; ++i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i + 1][x] - 'A', 1);\n    break;\n  }\n  for (int j = x - 2; j > 0; --j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j - 1] = 'A', 1);\n    break;\n  }\n  for (int j = x + 2; j <= w; ++j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j + 1] - 'A', 1);\n    break;\n  }\n}\n\nsigned main(int argc, char *argv[]) {\n  char s, t;\n\n  cin >> h >> w >> s >> t;\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      cin >> a[i][j];\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      if ('A' <= a[i][j] && a[i][j] <= 'Z') {\n        // cerr << a[i][j] << endl;\n        add_edge(i, j, a[i][j] - 'A');\n      }\n    }\n  }\n\n  G.build(s - 'A');\n  cout << G[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1010101;\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nbool is_edge(int x, char c){\n    if(x<2) return c=='-';\n    return c=='|';\n}\n\nint main(){\n    int h,w;\n    char s,t;\n    cin >>h >>w >>s >>t;\n\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    pi start,goal;\n    rep(i,h)rep(j,w){\n        if(f[i][j] == s) start = {i,j};\n        if(f[i][j] == t) goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n    vector<vector<int>> d(h,vector<int>(w,INF));\n    queue<pi> que;\n    d[start.fi][start.se] = 0;\n    que.push(start);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        rep(i,4){\n            int xx = now.se+2*dx[i], yy = now.fi+2*dy[i];\n            if(IN(yy,xx) && is_edge(i,f[yy][xx])){\n                while( !('A'<=f[yy][xx] && f[yy][xx]<='Z') ){\n                    yy += dy[i];\n                    xx += dx[i];\n                }\n\n                if(('A'<=f[yy][xx] && f[yy][xx]<='Z')){\n                    if(d[yy][xx] > d[now.fi][now.se]+1){\n                        d[yy][xx] = d[now.fi][now.se]+1;\n                        que.push({yy,xx});\n                    }\n                }\n            }\n        }\n    }\n\n    cout << d[goal.fi][goal.se] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[26];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 26) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            // cout << i << ' ' << j << endl;\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            bool f[51][51] = {};\n            if(!contain(y, x)) continue;\n            f[idx[i].first][idx[i].second] = true;\n            f[idx[i].first + dy[j]][idx[i].second + dx[j]] = true;\n            f[y][x] = true;\n            if(c[y][x] == '.') continue;\n            while(1){\n                int ny = -1, nx = -1;\n                // cout << i << ' ' << j << ' ' << y << ' ' << x << ' ' << c[y][x] << endl;\n                rep(k, 0, 4){\n                    if(c[y][x] == '|'){\n                        if(k == 2 || k == 3) continue;\n                    }\n                    if(c[y][x] == '-'){\n                        if(k == 0 || k == 1) continue;\n                    }\n                    ny = y + dy[k];\n                    nx = x + dx[k];\n                    if(!contain(ny, nx)) continue;\n                    if(f[ny][nx]) continue;\n                    \n                    if(c[ny][nx] == '-'){\n                        break;\n                    }\n                    if(c[ny][nx] == '|'){\n                        break;\n                    }\n                    if(c[ny][nx] == 'o'){\n                        ny += dy[k];\n                        nx += dx[k];\n                        break;\n                    }\n                }\n                y = ny;\n                x = nx;\n                f[y][x] = true;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    // cout << (char)('A' + i) << ' ' << c[y][x] << endl;\n                    break;\n                }\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n/*\n7 7 A D\nooo.ooo\noAo-oBo\nooo.ooo\n.|..|.\n.|..ooo\n.---oDo\n....ooo\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "テストケース23ってなーんだ？\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) { sy = i, sx = j; }\n\t\tif (a[i][j] == t) { ty = i, tx = j; }\n\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\ta[i - 1][j - 1] = '.';\n\t\t\ta[i - 1][j + 1] = '.';\n\t\t\ta[i + 1][j - 1] = '.';\n\t\t\ta[i + 1][j + 1] = '.';\n\t\t}\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P {\n\t\tint y, x, dist;\n\t\tbool operator<(const P& r) const {\n\t\t\treturn dist < r.dist;\n\t\t}\n\t};\n\tstd::priority_queue<P> pq;\n\tpq.push(P{sy,sx,0});\n\tdist[sy][sx] = 0;\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tif (dist[p.y][p.x] < p.dist) continue;\n\t\tREP(d, 4) {\n\t\t\tint dy = p.y + dy4[d];\n\t\t\tint dx = p.x + dx4[d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tint cost = IN('A', a[dy][dx], 'Z' + 1);\n\t\t\tif (dist[dy][dx] > dist[p.y][p.x] + cost) {\n\t\t\t\tdist[dy][dx] = dist[p.y][p.x] + cost;\n\t\t\t\tpq.push(P{dy, dx, dist[dy][dx]});\n\t\t\t}\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[30];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 30) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            if(!contain(y, x)) continue;\n            \n            while(1){\n                if(!contain(y, x)) break;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    break;\n                }\n                if(c[y][x] == '.') break;\n                y += dy[j];\n                x += dx[j];\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) sy = i, sx = j;\n\t\tif (a[i][j] == t) ty = i, tx = j;\n\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\ta[i - 1][j - 1] = '.';\n\t\t\ta[i - 1][j + 1] = '.';\n\t\t\ta[i + 1][j - 1] = '.';\n\t\t\ta[i + 1][j + 1] = '.';\n\t\t}\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P {\n\t\tint y, x, dist;\n\t\tbool operator<(const P& r) const {\n\t\t\treturn dist > r.dist;\n\t\t}\n\t};\n\tstd::priority_queue<P> pq;\n\tpq.push(P{sy,sx,0});\n\tdist[sy][sx] = 0;\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tREP(d, 4) {\n\t\t\tint dy = p.y + dy4[d];\n\t\t\tint dx = p.x + dx4[d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tif (dist[dy][dx] <= dist[p.y][p.x]) continue;\n\t\t\tdist[dy][dx] = dist[p.y][p.x] + IN('A', a[dy][dx], 'Z' + 1);\n\t\t\tpq.push(P{dy, dx, dist[dy][dx]});\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w; char s, t;\nstring art[50];\nvector<int> et[26];\n\nP toPos(char a) {\n\tint i, j;\n\trep(i, h) rep(j, w) if (art[i][j] == a) return P(i, j);\n\treturn P(-1, -1);\n}\n\nbool isConnect(char a, char b) {\n\tP posA = toPos(a); int yA = posA.first; int xA = posA.second;\n\tP posB = toPos(b); int yB = posB.first; int xB = posB.second;\n\tint i;\n\t\n\tif (yA == -1 || yB == -1) return false;\n\tif (yA == yB) {\n\t\tint y = yA;\n\t\tif (xA > xB) swap(xA, xB);\n\t\tif (art[y][xA + 1] != 'o') return false;\n\t\tif (art[y][xB - 1] != 'o') return false;\n\t\tfor (i = xA + 2; i <= xB - 2; i++) {\n\t\t\tif (art[y][i] != '-') return false;\n\t\t}\n\t\treturn true;\n\t}\n\tif (xA == xB) {\n\t\tint x = xA;\n\t\tif (yA > yB) swap(yA, yB);\n\t\tif (art[yA + 1][x] != 'o') return false;\n\t\tif (art[yB - 1][x] != 'o') return false;\n\t\tfor (i = yA + 2; i <= yB - 2; i++) {\n\t\t\tif (art[i][x] != '|') return false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> h >> w >> s >> t;\n\tfor (i = 0; i < h; i++) cin >> art[i];\n\t\n\tfor (i = 0; i < 26; i++) {\n\t\tfor (j = i + 1; j < 26; j++) {\n\t\t\tif (isConnect('A' + i, 'A' + j)) {\n\t\t\t\tet[i].push_back(j);\n\t\t\t\tet[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint dist[26][26], INF = 114514;\n\trep(i, 26) rep(j, 26) dist[i][j] = INF;\n\trep(i, 26) dist[i][i] = 0;\n\trep(i, 26) rep(j, et[i].size()) dist[i][et[i][j]] = 1;\n\trep(k, 26) rep(i, 26) rep(j, 26) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\tcout << dist[s - 'A'][t - 'A'] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint H, W, s, t;\nstring A[101];\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nint d[26][26];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> H >> W;\n    char c; cin >> c; s = c - 'A'; cin >> c; t = c - 'A';\n    rep(y, 0, H) cin >> A[y];\n\n    rep(i, 0, 26) rep(j, 0, 26) d[i][j] = inf;\n    rep(i, 0, 26) d[i][i] = 0;\n\n    rep(y, 0, H) rep(x, 0, W) if ('A' <= A[y][x] and A[y][x] <= 'Z') {\n        rep(i, 0, 4) {\n            int xx = x + dx[i];\n            int yy = y + dy[i];\n            while (0 <= xx and xx < W and 0 <= yy and yy < H) {\n                if ('A' <= A[yy][xx] and A[yy][xx] <= 'Z') {\n                    //int dist = abs(x - xx) + abs(y - yy) - 2;\n                    int dist = 1;\n                    int a = A[y][x] - 'A';\n                    int b = A[yy][xx] - 'A';\n                    d[a][b] = d[b][a] = dist;\n                    break;\n                } else if (A[yy][xx] == '.') break;\n\n                xx += dx[i];\n                yy += dy[i];\n            }\n        }\n    }\n\n    rep(k, 0, 26) rep(i, 0, 26) rep(j, 0, 26) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    cout << d[s][t] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                if(!inrange(now.first, now.second)) break;\n            }\n            if(!inrange(now.second, now.first))continue;\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint dx1[]={-1,-1,-1,0,0,1,1,1};\nint dy1[]={-1,0,1,-1,1,-1,0,1};\nint h,w;\nchar S,T;\n\nvector<int>v[1000];\n\nint sx,sy,gx,gy;\nstring s[100];\n\nvoid INPUT(){\n\n  cin>>h>>w>>S>>T; \n\n  r(i,h)cin>>s[i];\n\n  r(i,h)r(j,w){\n    if(s[i][j]==S)sx=j,sy=i;\n    if(s[i][j]==T)gx=j,gy=i;\n  }\n}\n\nvoid make_GRAPH(){\n  r(i,h)r(j,w)if('A'<=s[i][j]&&s[i][j]<='Z'){\n    r(k,4){\n      int x=j+dx[k]+dx[k];\n      int y=i+dy[k]+dy[k];\n      if(x<0||y<0||x>=w||y>=h)continue;\n      if(k%2==1&&s[y][x]=='|')continue;\n      if(k%2==0&&s[y][x]=='-')continue;\n\n      if(k%2==1&&s[y][x]=='-'){\n        while(s[y][x]=='-'){\n          y+=dy[k];\n          x+=dx[k];\n        }\n        y+=dy[k];\n        x+=dx[k];\n        v[s[i][j]-'A'].push_back(s[y][x]-'A');\n      }\n\n      else if(k%2==0&&s[y][x]=='|'){\n        while(s[y][x]=='|'){\n          y+=dy[k];\n          x+=dx[k];\n        }\n        y+=dy[k];\n        x+=dx[k];\n        v[s[i][j]-'A'].push_back(s[y][x]-'A');\n      }\n\n    }\n  }\n}\nbool used[100009];\nint d[100005];\n\nvoid BFS(){\n\n  queue<P>q;\n\n  q.push(P(s[sy][sx]-'A',0));\n  used[s[sy][sx]-'A']=1;\n\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int x=p.first;\n    int cost=p.second;\n    d[x]=cost;\n    r(i,v[x].size()){\n      int next=v[x][i];\n      if(!used[next]){\n        used[next]=1;\n        q.push(P(next,cost+1));\n      }\n    }\n  }\n  cout<<d[s[gy][gx]-'A']<<endl;\n}\n\nint main(){\n  INPUT();\n  make_GRAPH();\n  BFS();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(25, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  int a = -1;\n  rep(i, 25) {\n    if(pos[i].first != -1) {\n      a = i;\n      break;\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  vector<vint> graph(25);\n  {\n    queue<int>  que;\n    bool used[25] = {};\n    que.push(a);\n    used[a] = true;\n\n    while(!que.empty()) {\n      int u = que.front(); que.pop();\n      rep(i, 4) {\n\tint ny = pos[u].first+dy[i]+dy[i], nx = pos[u].second+dx[i]+dx[i];\n\twhile(in(ny, nx) && (mas[ny][nx] == '|' || mas[ny][nx] == '-')) {\n\t  ny += dy[i];\n\t  nx += dx[i];\n\t}\n\tny += dy[i];\n\tnx += dx[i];\n\tif(!in(ny, nx)) continue;\n\tif(!isalpha(mas[ny][nx])) continue;\n\tint v = mas[ny][nx]-'A';\n\tgraph[u].push_back(v);\n\tif(used[v]) continue;\n\tused[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n  int ss = s-'A', tt = t-'A';\n  queue<int> que;\n  vint dist(25, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    if(u == tt) break;\n    for(int v : graph[u]) {\n      if(dist[v] == -1) {\n\tdist[v] = dist[u]+1;\n\tque.push(v);\n      }\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) sy = i, sx = j;\n\t\tif (a[i][j] == t) ty = i, tx = j;\n\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\ta[i - 1][j - 1] = '.';\n\t\t\ta[i - 1][j + 1] = '.';\n\t\t\ta[i + 1][j - 1] = '.';\n\t\t\ta[i + 1][j + 1] = '.';\n\t\t}\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P {\n\t\tint y, x, dist;\n\t\tbool operator<(const P& r) const {\n\t\t\treturn dist > r.dist;\n\t\t}\n\t};\n\tstd::priority_queue<P> pq;\n\tpq.push(P{sy,sx,0});\n\tdist[sy][sx] = 0;\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tif (dist[p.y][p.x] < p.dist) continue;\n\t\tREP(d, 4) {\n\t\t\tint dy = p.y + dy4[d];\n\t\t\tint dx = p.x + dx4[d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tint cost = IN('A', a[dy][dx], 'Z' + 1);\n\t\t\tif (dist[dy][dx] > dist[p.y][p.x] + cost) {\n\t\t\t\tdist[dy][dx] = dist[p.y][p.x] + cost;\n\t\t\t\tpq.push(P{dy, dx, dist[dy][dx]});\n\t\t\t}\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) sy = i, sx = j;\n\t\tif (a[i][j] == t) ty = i, tx = j;\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P { int y, x, d; };\n\tstd::queue<P> que({P{sy,sx,4}});\n\tdist[sy][sx] = 0;\n\twhile (!que.empty()) {\n\t\tauto p = que.front(); que.pop();\n\t\tif (p.d == 4) {\n\t\t\tREP(d, 4) {\n\t\t\t\tint dy = p.y + dy4[d];\n\t\t\t\tint dx = p.x + dx4[d];\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x]) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x];\n\t\t\t\t\tque.push(P{dy,dx,d});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint dy = p.y + dy4[p.d];\n\t\t\tint dx = p.x + dx4[p.d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tif (IN('A', a[dy][dx], 'Z' + 1)) {\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x] + 1) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x] + 1;\n\t\t\t\t\tque.push(P{dy,dx,4});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x]) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x];\n\t\t\t\t\tque.push(P{dy,dx,p.d});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1010101;\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nbool is_edge(char c){\n    return c=='-' || c=='|';\n}\n\nint main(){\n    int h,w;\n    char s,t;\n    cin >>h >>w >>s >>t;\n\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    pi start,goal;\n    rep(i,h)rep(j,w){\n        if(f[i][j] == s) start = {i,j};\n        if(f[i][j] == t) goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n    vector<vector<int>> d(h,vector<int>(w,INF));\n    queue<pi> que;\n    d[start.fi][start.se] = 0;\n    que.push(start);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        rep(i,4){\n            int xx = now.se+2*dx[i], yy = now.fi+2*dy[i];\n            if(IN(yy,xx) && is_edge(f[yy][xx])){\n                while( !('A'<=f[yy][xx] && f[yy][xx]<='Z') ){\n                    yy += dy[i];\n                    xx += dx[i];\n                }\n\n                if(d[yy][xx] > d[now.fi][now.se]+1){\n                    d[yy][xx] = d[now.fi][now.se]+1;\n                    que.push({yy,xx});\n                }\n            }\n        }\n    }\n\n    cout << d[goal.fi][goal.se] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  char s,t;\n  cin>>h>>w>>s>>t;\n  rep(i,h){\n    cin>>brd[i];\n  }\n  queue<pii> que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push(pii(sx,sy));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  dis[sx][sy]=0;\n  while(!que.empty()){\n    pii t=que.front();que.pop();\n    for(int dx=-1;dx<=1;++dx){\n      for(int dy=-1;dy<=1;++dy){\n\tint nx=t.first+dx,ny=t.second+dy;\n\tif(nx<0||nx>=h||ny<0||ny>=w)continue;\n\tif(dis[nx][ny]<inf)continue;\n\tdis[nx][ny]=dis[t.first][t.second]+(brd[nx][ny]=='o'?1:0);\n\tque.push(pii(nx,ny));\n      }\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\nstruct edge { ll v, dist; };\nstruct state {\n  ll v, cost;\n  bool operator>(const state s) const { return cost > s.cost; }\n};\n\nvector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n  vector<ll> dp(E.size(), INF);\n  priority_queue<state, vector<state>, greater<state> > q;\n  q.push((state) { S, 0 });\n  while(!q.empty()) {\n    ll v = q.top().v, cost = q.top().cost;\n    q.pop();\n    if(dp[v] <= cost) continue;\n    dp[v] = cost;\n    REP(i, 0, E[v].size()) {\n      ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n      if(dp[nv] > ncost) q.push((state) { nv, ncost });\n    }\n  }\n  return dp;\n}\n\nint main(void) {\n  ll H, W;\n  char S, T;\n  cin >> H >> W >> S >> T;\n  char A[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> A[i][j];\n\n  vector< vector<edge> > E(256);\n  REP(i, 0, H) REP(j, 0, W) {\n    if('A' <= A[i][j] && A[i][j] <= 'Z') {\n      ll dd[5] = { 0, 1, 0, -1, 0 };\n      REP(k, 0, 4) {\n        ll pi = i + dd[k];\n        ll pj = j + dd[k + 1];\n        while(1) {\n          pi += dd[k];\n          pj += dd[k + 1];\n          if(!(0 <= pi && pi < H && 0 <= pj && pj < W)) break;\n          if(A[pi][pj] == 'o') {\n            E[A[i][j]].push_back((edge) { A[pi + dd[k]][pj + dd[k + 1]], 1 });\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  cout << dijkstra(E, S)[T] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint h, w;\nchar s, t;\nchar a[55][55];\n\nstruct edge{int to, cost;};\nvector<vector<edge>> g(100);\n\nvector<ll> dijkstra(int s, int n, vector<vector<edge>>& g){\n    priority_queue<plli, vector<plli>, greater<plli>> pque;\n    vector<ll> d(n, INFLL);\n    d[s] = 0;\n    pque.push(plli(0, s));\n\n    while (!pque.empty()){\n        plli p = pque.top(); pque.pop();\n        int fr = p.second;\n        if (d[fr] < p.first) continue;\n        for (edge e: g[fr]){\n            if (d[e.to] > d[fr] + e.cost){\n                d[e.to] = d[fr] + e.cost;\n                pque.push(plli(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nbool al(int i, int j) {\n  return (a[i][j] != 'o' && a[i][j] != '.' && a[i][j] != '|' && a[i][j] != '-');\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w >> s >> t;\n    rep(i, h)rep(j, w) cin >> a[i][j];\n    rep(i, h)rep(j, w) {\n      if (al(i, j)) {\n        rep2(k, i + 2, h) {\n          if (a[k][j] == '.') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        rep2(k, j + 2, w) {\n          if (a[i][k] == '.') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = i - 2; k >= 0; k--) {\n          if (a[k][j] == '.') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = j - 2; k >= 0; k--) {\n          if (a[i][k] == '.') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n      }\n    }\n    vector<ll> dist = dijkstra(s - 'A', 100, g);\n    cout << dist[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int64_t\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nnamespace io {\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        io::print_to(os, \", \", \"\\n\", __VA_ARGS__);        \\\n        std::cerr << io::highlight(os.str());             \\\n    } while (0)\n#define dump_(cntnr)                                 \\\n    do {                                             \\\n        std::ostringstream os;                       \\\n        os << __LINE__ << \":\\t\" << #cntnr << \" = [\"; \\\n        io::print_to_(os, \", \", \"]\\n\", all(cntnr));  \\\n        std::cerr << io::highlight(os.str());        \\\n    } while (0)\n#define dumpf(fmt, ...)                             \\\n    do {                                            \\\n        const int N = 4096;                         \\\n        auto b = new char[N];                       \\\n        int l = snprintf(b, N, \"%d:\\t\", __LINE__);  \\\n        snprintf(b + l, N - l, fmt, ##__VA_ARGS__); \\\n        std::cerr << io::highlight(b) << std::endl; \\\n        delete[] b;                                 \\\n    } while (0)\n#else\n#define dump(...)\n#define dump_(...)\n#define dumpf(...)\n#endif\nstd::string highlight(std::string s) {\n#ifdef _MSC_VER\n    return s;\n#else\n    return \"\\033[33m\" + s + \"\\033[0m\";\n#endif\n}\ntemplate <typename T>\nvoid print_to(std::ostream &os, std::string, std::string tail, const T &first) {\n    os << first << tail;\n}\ntemplate <typename F, typename... R>\nvoid print_to(std::ostream &os, std::string del, std::string tail, const F &first,\n              const R &... rest) {\n    os << first << del;\n    print_to(os, del, tail, rest...);\n}\ntemplate <typename I>\nvoid print_to_(std::ostream &os, std::string del, std::string tail, I begin, I end) {\n    for (I it = begin; it != end;) {\n        os << *it;\n        os << (++it != end ? del : tail);\n    }\n}\ntemplate <typename F, typename... R>\nvoid println(const F &first, const R &... rest) {\n    print_to(std::cout, \"\\n\", \"\\n\", first, rest...);\n}\ntemplate <typename F, typename... R>\nvoid print(const F &first, const R &... rest) {\n    print_to(std::cout, \" \", \"\\n\", first, rest...);\n}\ntemplate <typename I>\nvoid println_(I begin, I end) {\n    print_to_(std::cout, \"\\n\", \"\\n\", begin, end);\n}\ntemplate <typename I>\nvoid print_(I begin, I end) {\n    print_to_(std::cout, \" \", \"\\n\", begin, end);\n}\ntemplate <typename C>\nvoid println_(const C &cntnr) {\n    println_(std::begin(cntnr), std::end(cntnr));\n}\ntemplate <typename C>\nvoid print_(const C &cntnr) {\n    print_(std::begin(cntnr), std::end(cntnr));\n}\nint _ = (\n#ifndef LOCAL\n    std::cin.tie(nullptr), std::ios::sync_with_stdio(false),\n#endif\n    std::cout.precision(10), std::cout.setf(std::ios::fixed));\n}\nusing io::print;\nusing io::println;\nusing io::println_;\nusing io::print_;\ntemplate <typename T>\nusing vec = std::vector<T>;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n// const int MOD = 1000000007;\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nstd::vector<Weight> dijkstra(const Graph &g, int s) {\n    const Weight INF = std::numeric_limits<Weight>::max() / 8;\n    using state = std::tuple<Weight, int>;\n    std::priority_queue<state> q;\n    std::vector<Weight> dist(g.size(), INF);\n    dist[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        Weight d;\n        int v;\n        std::tie(d, v) = q.top();\n        q.pop();\n        d *= -1;\n        /* if(v == t) return d; */\n        if (dist[v] < d) continue;\n        for (auto &e : g[v]) {\n            if (dist[e.dst] > dist[v] + e.weight) {\n                dist[e.dst] = dist[v] + e.weight;\n                q.emplace(-dist[e.dst], e.dst);\n            }\n        }\n    }\n    return dist;\n}\n\nint h, w;\n\nbool inner(int i, int j) {\n    return !(i < 0 || i >= h || j < 0 || j >= w);\n}\n\n\n\nsigned main() {\n    vec<string> g;\n    while (cin >> h >> w) {\n        char s, t;\n        cin >> s >> t;\n        g.resize(h);\n        rep(i, h) {\n            cin >> g[i];\n        }\n\n        Graph graph(26);\n        rep(i, h) rep(j, w) {\n            static const pii dir[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n            if ('A' <= g[i][j] && g[i][j] <= 'Z') {\n                int di, dj;\n                rep(d, 4) {\n                    tie(di, dj) = dir[d];\n                    int ni = i + di * 1;\n                    int nj = j + dj * 1;\n                    while (inner(ni, nj) && !('A' <= g[ni][nj] && g[ni][nj] <= 'Z')) {\n                        ni += di;\n                        nj += dj;\n                    }\n                    if (inner(ni, nj)) {\n                        char cell = g[ni][nj];\n                        assert('A' <= cell && cell <= 'Z');\n                        int a = g[i][j] - 'A';\n                        int b = g[ni][nj] - 'A';\n                        dump(a, b);\n                        add_arc(graph, a, b, 1);\n                    }\n                }\n            }\n        }\n\n        auto dist = dijkstra(graph, s - 'A');\n        int ans = dist[t - 'A'];\n        print(ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int h,w;\n    char a,b;\n    cin>>h>>w>>a>>b;\n    string s[h];\n    int dp[26][26];\n    int INF = 1e9;\n    for(int i=0;i<26;i++){\n        for(int j=0;j<26;j++){\n            dp[i][j] = INF;\n            if(i==j) dp[i][j] = 0;\n        }\n    }\n    for(int i=0;i<h;i++){\n        cin>>s[i];\n    }\n    bool used[h][w] = {};\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(used[i][j]) continue;\n            if(s[i][j] == '|'){\n                char u='0',v='0';\n                for(int k=i;k>=0;k--){\n                    used[k][j] = 1;\n                    if(s[k][j] !='o' && s[k][j] !='.' && s[k][j]!='|'){\n                        u = s[k][j];\n                        break;\n                    }\n                }\n                for(int k=i;k<h;k++){\n                    used[k][j] = 1;\n                    if(s[k][j] !='o' && s[k][j] !='.' && s[k][j]!='|'){\n                        v = s[k][j];\n                        break;\n                    }\n                }\n                //cerr << i << \" \" << j << \" \" << u << \" \" << v << endl;\n                if(u!='0' && v!='0') {\n                    dp[u-'A'][v-'A'] = 1;\n                    dp[v-'A'][u-'A'] = 1;\n                }\n            }\n            if(s[i][j] == '-'){\n                char u='0',v='0';\n                for(int k=j;k>=0;k--){\n                    used[i][k] = 1;\n                    if(s[i][k]!='o' && s[i][k]!='.' && s[i][k] !='-'){\n                        u = s[i][k];\n                        break;\n                    }\n                }\n                for(int k=j;k<w;k++){\n                    used[i][k] = 1;\n                    if(s[i][k]!='o' && s[i][k]!='.' && s[i][k] !='-'){\n                        v = s[i][k];\n                        break;\n                    }\n                }\n                //cerr << i << \" \" << j << \" \" << u << \" \" << v << endl;\n                if(u!='0' && v!='0') {\n                    dp[u-'A'][v-'A'] = 1;\n                    dp[v-'A'][u-'A'] = 1;\n                }\n            }\n        }\n    }\n    for(int k=0;k<26;k++)for(int i=0;i<26;i++)for(int j=0;j<26;j++){\n        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n    }\n    cout << dp[a-'A'][b-'A'] << endl;\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint dx1[]={-1,-1,-1,0,0,1,1,1};\nint dy1[]={-1,0,1,-1,1,-1,0,1};\nint h,w;\nchar S,T;\n\nvector<int>v[1000];\n\nint sx,sy,gx,gy;\nstring s[100];\n\nvoid INPUT(){\n\n  cin>>h>>w>>S>>T; \n\n  r(i,h)cin>>s[i];\n\n  r(i,h)r(j,w){\n    if(s[i][j]==S)sx=j,sy=i;\n    if(s[i][j]==T)gx=j,gy=i;\n  }\n}\n\nvoid make_GRAPH(){\n  r(i,h)r(j,w)if('A'<=s[i][j]&&s[i][j]<='Z'){\n    r(k,4){\n      int x=j+dx[k]*2;\n      int y=i+dy[k]*2;\n      if(x<0||y<0||x>=w||y>=h)continue;\n      if(!(s[y][x]=='-'||s[y][x]=='|'))continue;\n      while(s[y][x]=='-'||s[y][x]=='|'){\n        y+=dy[k];\n        x+=dx[k];\n      }\n      y+=dy[k];\n      x+=dx[k];\n      v[s[i][j]-'A'].push_back(s[y][x]-'A');\n    }\n  }\n}\nbool used[100009];\nint d[100005];\n\nvoid BFS(){\n  queue<P>q;\n  q.push(P(s[sy][sx]-'A',0));\n  used[s[sy][sx]-'A']=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int x=p.first;\n    int cost=p.second;\n    d[x]=cost;\n    r(i,v[x].size()){\n      int next=v[x][i];\n      if(!used[next]){\n        used[next]=1;\n        q.push(P(next,cost+1));\n      }\n    }\n  }\n  cout<<d[s[gy][gx]-'A']<<endl;\n}\n\nint main(){\n  INPUT();\n  make_GRAPH();\n  BFS();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int64_t\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nnamespace io {\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        io::print_to(os, \", \", \"\\n\", __VA_ARGS__);        \\\n        std::cerr << io::highlight(os.str());             \\\n    } while (0)\n#define dump_(cntnr)                                 \\\n    do {                                             \\\n        std::ostringstream os;                       \\\n        os << __LINE__ << \":\\t\" << #cntnr << \" = [\"; \\\n        io::print_to_(os, \", \", \"]\\n\", all(cntnr));  \\\n        std::cerr << io::highlight(os.str());        \\\n    } while (0)\n#define dumpf(fmt, ...)                             \\\n    do {                                            \\\n        const int N = 4096;                         \\\n        auto b = new char[N];                       \\\n        int l = snprintf(b, N, \"%d:\\t\", __LINE__);  \\\n        snprintf(b + l, N - l, fmt, ##__VA_ARGS__); \\\n        std::cerr << io::highlight(b) << std::endl; \\\n        delete[] b;                                 \\\n    } while (0)\n#else\n#define dump(...)\n#define dump_(...)\n#define dumpf(...)\n#endif\nstd::string highlight(std::string s) {\n#ifdef _MSC_VER\n    return s;\n#else\n    return \"\\033[33m\" + s + \"\\033[0m\";\n#endif\n}\ntemplate <typename T>\nvoid print_to(std::ostream &os, std::string, std::string tail, const T &first) {\n    os << first << tail;\n}\ntemplate <typename F, typename... R>\nvoid print_to(std::ostream &os, std::string del, std::string tail, const F &first,\n              const R &... rest) {\n    os << first << del;\n    print_to(os, del, tail, rest...);\n}\ntemplate <typename I>\nvoid print_to_(std::ostream &os, std::string del, std::string tail, I begin, I end) {\n    for (I it = begin; it != end;) {\n        os << *it;\n        os << (++it != end ? del : tail);\n    }\n}\ntemplate <typename F, typename... R>\nvoid println(const F &first, const R &... rest) {\n    print_to(std::cout, \"\\n\", \"\\n\", first, rest...);\n}\ntemplate <typename F, typename... R>\nvoid print(const F &first, const R &... rest) {\n    print_to(std::cout, \" \", \"\\n\", first, rest...);\n}\ntemplate <typename I>\nvoid println_(I begin, I end) {\n    print_to_(std::cout, \"\\n\", \"\\n\", begin, end);\n}\ntemplate <typename I>\nvoid print_(I begin, I end) {\n    print_to_(std::cout, \" \", \"\\n\", begin, end);\n}\ntemplate <typename C>\nvoid println_(const C &cntnr) {\n    println_(std::begin(cntnr), std::end(cntnr));\n}\ntemplate <typename C>\nvoid print_(const C &cntnr) {\n    print_(std::begin(cntnr), std::end(cntnr));\n}\nint _ = (\n#ifndef LOCAL\n    std::cin.tie(nullptr), std::ios::sync_with_stdio(false),\n#endif\n    std::cout.precision(10), std::cout.setf(std::ios::fixed));\n}\nusing io::print;\nusing io::println;\nusing io::println_;\nusing io::print_;\ntemplate <typename T>\nusing vec = std::vector<T>;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n// const int MOD = 1000000007;\n\nint grid_bfs(const vector<string> &g, char S, char T) {\n    const int INF = 1e18;\n    using pii = pair<int, int>;\n\n    int h = g.size(), w = g[0].size();\n    static const auto is_valid = [&](int i, int j) {\n        if (i < 0 || i >= h || j < 0 || j >= w) return false;\n        if (g[i][j] == '.') return false;\n        return true;\n    };\n\n    static const pii dir[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    priority_queue<pair<int, pii>> q;\n    vector<vector<int>> d(h, vector<int>(w, INF));\n\n    rep(i, h) rep(j, w) {\n        if (g[i][j] == S) {\n            dump(S, g[i][j], i, j);\n            d[i][j] = 0;\n            q.emplace(0, pii(i, j));\n        }\n    }\n\n    while (q.size()) {\n        int ci, cj;\n        auto top = q.top();\n        int cd = -top.first;\n        tie(ci, cj) = top.second;\n        q.pop();\n\n        if (d[ci][cj] > cd) continue;\n        if (g[ci][cj] == T) {\n            \n            for(auto &r : d) {\n                dump_(r);\n            }\n\n            return cd;\n        }\n\n        for (auto &v : dir) {\n            int ni = ci + v.first;\n            int nj = cj + v.second;\n            if (is_valid(ni, nj)) {\n                char cell = g[ni][nj];\n                int cost;\n                if ('A' <= cell && cell <= 'Z') {\n                    cost = 1;\n                } else {\n                    cost = 0;\n                }\n                int nd = d[ci][cj] + cost;\n                if (d[ni][nj] > nd) {\n                    d[ni][nj] = nd;\n                    q.emplace(-nd, pii(ni, nj));\n                }\n            }\n        }\n    }\n\n    // dump(\"ha?\");\n    abort();\n}\n\nsigned main() {\n    int h, w;\n    vec<string> g;\n\n    while (cin >> h >> w) {\n        char s, t;\n        cin >> s >> t;\n        g.resize(h);\n        rep(i, h) {\n            cin >> g[i];\n        }\n\n        rep(i, h) rep(j, w) {\n            if ('A' <= g[i][j] && g[i][j] <= 'Z') {\n                FOR(di, -1, 2) {\n                    FOR(dj, -1, 2) {\n                        int ni = i + di, nj = j + dj;\n                        if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n                        if (di == 0 || dj == 0) continue;\n                        g[ni][nj] = '.';\n                    }\n                }\n            }\n        }\n\n        rep(i, h) {\n            dump(g[i]);\n        }\n\n        int ans = grid_bfs(g, s, t);\n        print(ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\trep(i,4){\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\tint yy = y+i, xx = x+j;\n\t\t\t\t//a[yy][xx] = a[y][x];\n\t\t\t\tused[yy][xx] = 1;\n\t\t\t\tif(i*j == -1 || i*j == 1)a[yy][xx] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill((int*)used, (int*)(used+100), 0);\n\trrep(i,h)rrep(j,w){\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\t/*int x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t}*/\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W;\n  cin >> H >> W;\n  char S, T;\n  cin >> S >> T;\n  S -= 'A';\n  T -= 'A';\n  VS vs(H);\n  cin >> vs;\n\n  VVI G(26);\n  REP(y,H) REP(x,W){\n\tif('A' <= vs[y][x] && vs[y][x] <= 'Z'){\n\t  int s = vs[y][x] - 'A';\n\t  REP(d,4){\n\t\tint tx = x + dx[d]*2;\n\t\tint ty = y + dy[d]*2;\n\t\twhile(0 <= tx && tx < W && 0 <= ty && ty < H){\n\t\t  if((d%2==0&&vs[ty][tx] == '-') || (d%2==1&&vs[ty][tx] == '|')){\n\t\t\ttx += dx[d];\n\t\t\tty += dy[d];\n\t\t  }\n\t\t  else if(vs[ty][tx] == 'o'){\n\t\t\ttx += dx[d];\n\t\t\tty += dy[d];\n\t\t\tint t = vs[ty][tx] - 'A';\n\t\t\tG[s].PB(t);\n\t\t\tbreak;\n\t\t  }\n\t\t  else\n\t\t\tbreak;\n\t\t}\n\t  }\n\t}\n  }\n\n  queue<int> q;\n  q.push(S);\n  VI dist(26, -1);\n  dist[S] = 0;\n  while(!q.empty()){\n\tint u = q.front();\n\tq.pop();\n\tfor(int to: G[u]){\n\t  if(dist[to] != -1) continue;\n\t  dist[to] = dist[u]+1;\n\t  q.push(to);\n\t}\n  }\n  cout << dist[T] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\nstruct edge { ll v, dist; };\nstruct state {\n  ll v, cost;\n  bool operator>(const state s) const { return cost > s.cost; }\n};\n\nvector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n  vector<ll> dp(E.size(), INF);\n  priority_queue<state, vector<state>, greater<state> > q;\n  q.push((state) { S, 0 });\n  while(!q.empty()) {\n    ll v = q.top().v, cost = q.top().cost;\n    q.pop();\n    if(dp[v] <= cost) continue;\n    dp[v] = cost;\n    REP(i, 0, E[v].size()) {\n      ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n      if(dp[nv] > ncost) q.push((state) { nv, ncost });\n    }\n  }\n  return dp;\n}\n\nint main(void) {\n  ll H, W;\n  char S, T;\n  cin >> H >> W >> S >> T;\n  char A[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> A[i][j];\n\n  vector< vector<edge> > E(256);\n  REP(i, 0, H) REP(j, 0, W) {\n    if('A' <= A[i][j] && A[i][j] <= 'Z') {\n      ll dd[5] = { 0, 1, 0, -1, 0 };\n      REP(k, 0, 4) {\n        ll pi = i + dd[k];\n        ll pj = j + dd[k + 1];\n        while(1) {\n          pi += dd[k];\n          pj += dd[k + 1];\n          if(!(0 <= pi && pi < H && 0 <= pj && pj < W)) break;\n          if(A[pi][pj] == '.') break;\n          if(A[pi][pj] == 'o') {\n            E[A[i][j]].push_back((edge) { A[pi + dd[k]][pj + dd[k + 1]], 1 });\n            // cout << A[i][j] << \" \" << A[pi + dd[k]][pj + dd[k + 1]] << endl;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  cout << dijkstra(E, S)[T] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1010101;\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nbool is_edge(int x, char c){\n    if(x<2) return c=='-';\n    return c=='|';\n}\n\nint main(){\n    int h,w;\n    char s,t;\n    cin >>h >>w >>s >>t;\n\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    pi start,goal;\n    rep(i,h)rep(j,w){\n        if(f[i][j] == s) start = {i,j};\n        if(f[i][j] == t) goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n    vector<vector<int>> d(h,vector<int>(w,INF));\n    queue<pi> que;\n    d[start.fi][start.se] = 0;\n    que.push(start);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        rep(i,4){\n            int xx = now.se+2*dx[i], yy = now.fi+2*dy[i];\n            if(IN(yy,xx) && is_edge(i,f[yy][xx])){\n                while( !('A'<=f[yy][xx] && f[yy][xx]<='Z') ){\n                    yy += dy[i];\n                    xx += dx[i];\n                }\n\n                if(('A'<=f[yy][xx] && f[yy][xx]<='Z')){\n                    if(d[yy][xx] > d[now.fi][now.se]+1){\n                        d[yy][xx] = d[now.fi][now.se]+1;\n                        que.push({yy,xx});\n                    }\n                }\n            }\n        }\n    }\n\n    cout << d[goal.fi][goal.se] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <deque>\n\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define mod 1000000007\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n\n#define yes cout << \"YES\" << endl\n#define no cout << \"NO\" << endl\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing pint = pair<int,int>;\n\nconst int INF = (1 << 30);\n\nint dx[4] = {1, 0, -1, 0},dy[4] = {0, 1, 0, -1};\nint nx[4] = {1, 1, -1, -1}, ny[4] = {1, -1, -1, 1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    char s, g;\n    cin >> H >> W >> s >> g;\n    char field[H][W];\n    bool already[H][W];\n    int cost[H][W];\n    \n    deque<pint> deq;\n    memset(already, false, sizeof(already));\n    rep(i, H){\n        rep(j, W) cost[i][j] = INF;\n    }\n    rep(i, H){\n        rep(j, W){\n            cin >> field[i][j];\n            if(field[i][j] == s){\n                deq.pb(mp(i, j));\n                cost[i][j] = 0;\n                already[i][j] = true;\n            }\n        }\n    }\n\n    rep(i, H){\n        rep(j, W){\n            if(isupper(field[i][j])){\n                rep(k, 4){\n                    field[i + nx[k]][j + ny[k]] = '.';\n                }\n            }\n        }\n    }\n\n    pint cur;\n\n    while(!deq.empty()){\n        cur = deq.front();\n        deq.pop_front();\n        //cerr << field[cur.fs][cur.sc] << endl;\n        //show(cost[cur.fs][cur.sc]);\n        if(g == field[cur.fs][cur.sc]) break;\n        rep(i, 4){\n            pint next = mp(cur.fs + dx[i], cur.sc + dy[i]);\n            if(next.fs < 0 || next.fs >= H || next.sc < 0 || next.sc >= W) continue;\n            if(!already[cur.fs + dx[i]][cur.sc + dy[i]] && field[cur.fs + dx[i]][cur.sc + dy[i]] != '.'){\n                already[cur.fs + dx[i]][cur.sc + dy[i]] = true;\n                if(isupper(field[cur.fs + dx[i]][cur.sc + dy[i]])){\n                    deq.push_back(mp(cur.fs + dx[i], cur.sc + dy[i]));\n                    cost[cur.fs + dx[i]][cur.sc + dy[i]] = cost[cur.fs][cur.sc] + 1;\n                }else{\n                    deq.push_front(mp(cur.fs + dx[i], cur.sc + dy[i]));\n                    cost[cur.fs + dx[i]][cur.sc + dy[i]] = cost[cur.fs][cur.sc];\n                }\n            }\n        }\n    }\n\n    cout << cost[cur.fs][cur.sc] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nint di[4] = {1, 0, -1, 0}, dj[4] = {0, 1, 0, -1};\n\nmain {\n  int H, W;\n  char s, t;\n  cin >> H >> W >> s >> t;\n  vector<vector<char>> m(H, vector<char>(W));\n  int S, G;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> m[i][j];\n      if (isupper(m[i][j])) {\n        if (m[i][j] == s) S = i * W + j;\n        if (m[i][j] == t) G = i * W + j;\n        m[i][j] = 'o';\n      }\n    }\n  }\n\n  Graph g(H * W);\n  rep(i, H) rep(j, W) {\n    rep(k, 4) {\n      int i2 = i + di[k], j2 = j + dj[k];\n      if (i2 < 0 || j2 < 0 || i2 >= H || j2 >= W) continue;\n      if (m[i][j] == '-') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '-') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == '|') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == 'o') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        } else if (m[i2][j2] == '-' || m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        }\n      }\n    }\n  }\n  cout << dijkstra(g, S).first[G] / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint h,w;\nvector<string> mp;\n\nint bfs(char sx,int sy,char goal){\n  vector<vector<int> > D(h,vector<int>(w,INF));\n  \n  queue<P> Q;\n  Q.push(P(sx,sy));\n  D[sy][sx] = 0;\n\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  auto in=[&](int x,int y){return !(x < 0 || y < 0 || x >= w || y >= h);};\n  auto go=[&](int x,int y,int i,char ch){\n    while(1){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!in(nx,ny)) return P(-1,-1);\n      \n      if((mp[ny][nx] != ch && !isupper(mp[ny][nx]))) return P(-1,-1);\n      if(isupper(mp[ny][nx])) return P(nx,ny);\n      x = nx;\n      y = ny;\n    }\n  };\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int x = t.first;\n    int y = t.second;\n\n    if(mp[y][x] == goal) return D[y][x];\n    \n    for(int i=0;i<4;i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      auto to = go(nx,ny,i,mp[ny][nx]);\n      if(to == P(-1,-1)) continue;\n      tie(nx,ny) = to;\n      if(D[ny][nx] != INF) continue;\n\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(nx,ny));\n    }\n  }\n  assert(0);\n}\n\nsigned main(){\n\n  char s,t;\n  cin>>h>>w>>s>>t;\n  mp.resize(h);\n  cin>>mp;\n\n  int sx,sy;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!isupper(mp[i][j])) continue;\n      mp[i-1][j] = mp[i+1][j] = '|';\n      mp[i][j-1] = mp[i][j+1] = '-';\n      if(mp[i][j] == s) sx = j, sy = i;\n    }\n\n  int ans = bfs(sx,sy,t);\n\n  cout<<ans<<endl;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) { sy = i, sx = j; }\n\t\tif (a[i][j] == t) { ty = i, tx = j; }\n\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\ta[i - 1][j - 1] = '.';\n\t\t\ta[i - 1][j + 1] = '.';\n\t\t\ta[i + 1][j - 1] = '.';\n\t\t\ta[i + 1][j + 1] = '.';\n\t\t}\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P {\n\t\tint y, x, dist;\n\t\tbool operator<(const P& r) const {\n\t\t\treturn dist > r.dist;\n\t\t}\n\t};\n\tstd::priority_queue<P> pq;\n\tpq.push(P{sy,sx,0});\n\tdist[sy][sx] = 0;\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tif (dist[p.y][p.x] < p.dist) continue;\n\t\tREP(d, 4) {\n\t\t\tint dy = p.y + dy4[d];\n\t\t\tint dx = p.x + dx4[d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tint cost = IN('A', a[dy][dx], 'Z' + 1);\n\t\t\tif (dist[dy][dx] > dist[p.y][p.x] + cost) {\n\t\t\t\tdist[dy][dx] = dist[p.y][p.x] + cost;\n\t\t\t\tpq.push(P{dy, dx, dist[dy][dx]});\n\t\t\t}\n\t\t}\n\t}\n\tassert(dist[ty][tx] < INFINT);\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <deque>\n\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define mod 1000000007\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n\n#define yes cout << \"YES\" << endl\n#define no cout << \"NO\" << endl\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing pint = pair<int,int>;\n\nconst int INF = (1 << 30);\n\nint dx[4] = {1, 0, -1, 0},dy[4] = {0, 1, 0, -1};\nint nx[4] = {1, 1, -1, -1}, ny[4] = {1, -1, -1, 1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    char s, g;\n    cin >> H >> W >> s >> g;\n    char field[H][W];\n    bool already[H][W];\n    int cost[H][W];\n\n    deque<pint> deq;\n    memset(already, false, sizeof(already));\n    rep(i, H){\n        rep(j, W) cost[i][j] = INF;\n    }\n    rep(i, H){\n        rep(j, W){\n            cin >> field[i][j];\n            if(field[i][j] == s){\n                deq.pb(mp(i, j));\n                cost[i][j] = 0;\n                already[i][j] = true;\n            }\n        }\n    }\n\n    rep(i, H){\n        rep(j, W){\n            if(isupper(field[i][j])){\n                rep(k, 4){\n                    field[i + nx[k]][j + ny[k]] = '.';\n                }\n            }\n        }\n    }\n\n    pint cur;\n\n    while(!deq.empty()){\n        cur = deq.front();\n        deq.pop_front();\n        //cerr << field[cur.fs][cur.sc] << endl;\n        //show(cost[cur.fs][cur.sc]);\n        rep(i, 4){\n            pint next = mp(cur.fs + dx[i], cur.sc + dy[i]);\n            if(next.fs < 0 || next.fs >= H || next.sc < 0 || next.sc >= W) continue;\n            if(field[cur.fs + dx[i]][cur.sc + dy[i]] != '.'){\n                if(isupper(field[cur.fs + dx[i]][cur.sc + dy[i]])){\n                    if(cost[next.fs][next.sc]>cost[cur.fs][cur.sc]+1){\n                    deq.push_back(mp(cur.fs + dx[i], cur.sc + dy[i]));\n                    cost[cur.fs + dx[i]][cur.sc + dy[i]] = cost[cur.fs][cur.sc] + 1;\n                    }\n                }else{\n                    if(cost[next.fs][next.sc]>cost[cur.fs][cur.sc]){\n                    deq.push_front(mp(cur.fs + dx[i], cur.sc + dy[i]));\n                    cost[cur.fs + dx[i]][cur.sc + dy[i]] = cost[cur.fs][cur.sc];\n                }\n                }\n            }\n        }\n    }\n\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]!=g)continue;\n            cout<<cost[i][j]<<endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstruct Edge {\n\t\tint to, cost;\n\t\tEdge() {}\n\t\tEdge(int to, int cost) : to(to), cost(cost) {}\n\t\tbool operator<(const Edge& r) const {\n\t\t\treturn cost < r.cost;\n\t\t}\n\t};\n\tstd::vector<std::vector<Edge>> g(h*w);\n\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) { sy = i; sx = j; }\n\t\tif (a[i][j] == t) { ty = i; tx = j; }\n\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\ta[i - 1][j - 1] = '.';\n\t\t\ta[i - 1][j + 1] = '.';\n\t\t\ta[i + 1][j - 1] = '.';\n\t\t\ta[i + 1][j + 1] = '.';\n\t\t}\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == '|') {\n\t\t\tif (i > 0) g[i*w + j].emplace_back((i - 1)*w + j, 0);\n\t\t\tif (i < h - 1) g[i*w + j].emplace_back((i + 1)*w + j, 0);\n\t\t}\n\t\tif (a[i][j] == '-') {\n\t\t\tif (j > 0) g[i*w + j].emplace_back(i*w + j - 1, 0);\n\t\t\tif (j < w - 1) g[i*w + j].emplace_back(i*w + j + 1, 0);\n\t\t}\n\t\tif (a[i][j] == 'o') {\n\t\t\tREP(d, 4) {\n\t\t\t\tint dy = i + dy4[d];\n\t\t\t\tint dx = j + dx4[d];\n\t\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\t\tg[i*w + j].emplace_back(dy*w + dx, 0);\n\t\t\t}\n\t\t}\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\tREP(d, 4) {\n\t\t\t\tint dy = i + dy4[d];\n\t\t\t\tint dx = j + dx4[d];\n\t\t\t\tg[i*w + j].emplace_back(dy*w + dx, 1);\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<int> dist(h*w);\n\tstd::function<void(int)> Dijkstra = [&](int s) {\n\t\tusing P = std::pair<int, int>;\n\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\t\tstd::fill(dist.begin(), dist.end(), INFINT);\n\t\tdist[s] = 0;\n\t\tpq.push(P(0, s));\n\t\twhile (!pq.empty()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\t\tEdge e = g[v][i];\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpq.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tDijkstra(sy*w + sx);\n\tOUT(dist[ty*w+tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<ll>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    char s, t;\n    cin >> H >> W >> s >> t;\n    vector<vector<char> > ch(H + 2, vector<char>(W + 2, '.'));\n\n    rep(i, 1, H + 1) {\n        rep(j, 1, W + 1) {\n            cin >> ch[i][j];\n        }\n    }\n\n    Dijkstra dij(26);\n\n    for (int i = 1; i < H + 1; i++) {\n        for (int j = 1; j < W + 1; j++) {\n            char c = ch[i][j];\n            if (c >= 'A' && c <= 'Z') {\n                for (int di = 1; ch[i + di][j] != '.'; di++) {\n                    if (ch[i + di][j] >= 'A' && ch[i + di][j] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i + di][j] - 'A', 1);\n                        dij.addEdge(ch[i + di][j] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n                for (int dj = 1; ch[i][j + dj] != '.'; dj++) {\n                    if (ch[i][j + dj] >= 'A' && ch[i][j + dj] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i][j + dj] - 'A', 1);\n                        dij.addEdge(ch[i][j + dj] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    dij.dijkstra(s - 'A');\n    cout << dij.d[t - 'A'] << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2869.cc: AA Graph\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 50;\nconst int MAX_W = 50;\nconst int N = 26;\nconst int dxs[] = { 1, 0, -1, 0 }, dys[] = { 0, -1, 0, 1 };\nconst char echs[] = \"-|-|\";\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\n/* global variables */\n\nchar flds[MAX_H][MAX_W + 4];\nint xs[N], ys[N], dists[N];\nvi nbrs[N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int h, w;\n  char sst[2], sgl[2];\n  scanf(\"%d%d%s%s\", &h, &w, sst, sgl);\n  int st = sst[0] - 'A', gl = sgl[0] - 'A';\n\n  memset(xs, -1, sizeof(xs));\n\n  for (int y = 0; y < h; y++) {\n    scanf(\"%s\", flds[y]);\n    for (int x = 0; x < w; x++)\n      if (isupper(flds[y][x])) {\n\tint u = flds[y][x] - 'A';\n\txs[u] = x, ys[u] = y;\n      }\n  }\n\n  for (int u = 0; u < N; u++)\n    if (xs[u] >= 0)\n      for (int di = 0; di < 4; di++) {\n\tconst int &dx = dxs[di], &dy = dys[di];\n\tconst char &ech = echs[di];\n\tfor (int x = xs[u] + dx * 2, y = ys[u] + dy * 2;\n\t     x >= 0 && x < w && y >= 0 && y < h &&\n\t       (flds[y][x] == 'o' || flds[y][x] == ech || isupper(flds[y][x]));\n\t     x += dx, y += dy)\n\t  if (isupper(flds[y][x])) {\n\t    int v = flds[y][x] - 'A';\n\t    nbrs[u].push_back(v);\n\t    break;\n\t  }\n      }\n\n  memset(dists, -1, sizeof(dists));\n  dists[st] = 0;\n  qi q;\n  q.push(st);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    if (u == gl) break;\n\n    int vd = dists[u] + 1;\n    vi &nbru = nbrs[u];\n\n    for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &v = *vit;\n      if (dists[v] < 0) {\n\tdists[v] = vd;\n\tq.push(v);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", dists[gl]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P;//firstは最短距離、secondは頂点の番号\n\n    int V;//超点数\n    vector<vector<edge> > G;//グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d; //最短距離\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge> >(N);\n        d = vector<ll>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    char s, t;\n    cin >> H >> W >> s >> t;\n    vector<vector<char> > ch(H + 2, vector<char>(W + 2, '.'));\n\n    rep(i, 1, H + 1) {\n        rep(j, 1, W + 1) {\n            cin >> ch[i][j];\n        }\n    }\n\n    Dijkstra dij(26);\n\n    for (int i = 1; i < H + 1; i++) {\n        for (int j = 1; j < W + 1; j++) {\n            char c = ch[i][j];\n            if (c >= 'A' && c <= 'Z') {\n                for (int di = 1; ch[i + di][j] != '.' && ch[i + di][j] != '-'; di++) {\n                    if (ch[i + di][j] >= 'A' && ch[i + di][j] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i + di][j] - 'A', 1);\n                        dij.addEdge(ch[i + di][j] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n                for (int dj = 1; ch[i][j + dj] != '.' && ch[i][j + dj] != '|'; dj++) {\n                    if (ch[i][j + dj] >= 'A' && ch[i][j + dj] <= 'Z') {\n                        dij.addEdge(c - 'A', ch[i][j + dj] - 'A', 1);\n                        dij.addEdge(ch[i][j + dj] - 'A', c - 'A', 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    dij.dijkstra(s - 'A');\n    cout << dij.d[t - 'A'] << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n//verified AOJ GRL_1\n#define MAX_V 100000\ntemplate <typename T>\nstruct edge{int to;T cost;};\n\ntemplate <typename T>\nvoid dijkstra(int s, vector<T> &d, vector<edge<T>> G[MAX_V]){\n    priority_queue< pii,vector<pii>,greater<pii> > que;\n    rep( i,d.size() )d[i]=INF;\n    d[s] = 0;\n    que.push( pii(0,s) );\n    \n    while( que.size() ){\n        pii p=que.top();\n        que.pop();\n        \n        int v=p.second;\n        if(d[v]<p.first)continue;\n        \n        rep(i,G[v].size()){\n            edge<T> e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint h,w;\nint f(int y,int x){\n    return y*w + x;\n}\n\nint main(){\n    char a,b;\n    cin>>h>>w>>a>>b;\n    \n    vector<string> v(h);\n    rep(i,h)cin>>v[i];\n    \n    pii s,t;\n    rep(i,h){\n        rep(j,w){\n            if(v[i][j]==a)s = pii(i,j);\n            if(v[i][j]==b)t = pii(i,j);\n        }\n    }\n    \n    vector<edge<int>> G[2500];\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    rep(i,h){\n        rep(j,w){\n            rep(k,4){\n                int ddy = i+dy[k];\n                int ddx = j+dx[k];\n                if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)continue;\n                if(v[i][j]==v[ddy][ddx]){\n                    G[f(i,j)].pb(edge<int>{f(ddy,ddx),0});\n                    G[f(ddy,ddx)].pb(edge<int>{f(i,j),0});\n                }else if(((v[i][j]=='o') xor (v[ddy][ddx]=='o')) and (isupper(v[i][j]) xor isupper(v[ddy][ddx]))){\n                    G[f(i,j)].pb(edge<int>{f(ddy,ddx),0});\n                    G[f(ddy,ddx)].pb(edge<int>{f(i,j),0});\n                }else if(k%2==1 and ((v[i][j]=='o') xor (v[ddy][ddx]=='o')) and ((v[i][j]=='-') xor (v[ddy][ddx]=='-'))){\n                    G[f(i,j)].pb(edge<int>{f(ddy,ddx),1});\n                    G[f(ddy,ddx)].pb(edge<int>{f(i,j),1});\n                }else if(k%2==0 and ((v[i][j]=='o') xor (v[ddy][ddx]=='o')) and ((v[i][j]=='|') xor (v[ddy][ddx]=='|'))){\n                    G[f(i,j)].pb(edge<int>{f(ddy,ddx),1});\n                    G[f(ddy,ddx)].pb(edge<int>{f(i,j),1});\n                }\n            }\n        }\n    }\n    vector<int> d(h*w);\n    dijkstra(f(s.first,s.second),d,G);\n    cout<<d[f(t.first,t.second)]/2<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                assert(inrange(now.first, now.second));\n            }\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) sy = i, sx = j;\n\t\tif (a[i][j] == t) ty = i, tx = j;\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstruct P {\n\t\tint y, x, d, dist;\n\t\tbool operator>(const P& r) const {\n\t\t\treturn dist > r.dist;\n\t\t}\n\t};\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\tpq.push(P{sy,sx,4,0});\n\tdist[sy][sx] = 0;\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tif (p.d == 4) {\n\t\t\tREP(d, 4) {\n\t\t\t\tint dy = p.y + dy4[d];\n\t\t\t\tint dx = p.x + dx4[d];\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x]) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x];\n\t\t\t\t\tpq.push(P{dy,dx,d,dist[dy][dx]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint dy = p.y + dy4[p.d];\n\t\t\tint dx = p.x + dx4[p.d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tif (IN('A', a[dy][dx], 'Z' + 1)) {\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x] + 1) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x] + 1;\n\t\t\t\t\tpq.push(P{dy,dx,4,dist[dy][dx]});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist[dy][dx] > dist[p.y][p.x]) {\n\t\t\t\t\tdist[dy][dx] = dist[p.y][p.x];\n\t\t\t\t\tpq.push(P{dy,dx,p.d,dist[dy][dx]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007;\n#define INF (1<<28)\n#define int long long\n#define double long double\n#define floot10 cout<<fixed<<setprecision(10)\n\nsigned main(){\n  int h,w;\n  cin>>h>>w;\n  char s,t;\n  cin>>s>>t;\n  char a[52][52];\n  lp(i,52) lp(j,52) a[i][j]='.';\n  int sx,sy;\n  lp(i,h){\n    lp(j,w){\n      cin>>a[j+1][i+1];\n      if(a[j+1][i+1]==s){\n\tsy=i+1;sx=j+1;\n      }\n    }\n  }\n  queue<pair<int,pair<int,int> > > q;\n  int dp[55][55];\n  lp(i,55) lp(j,55) dp[i][j]=INF;\n  q.push({0,{sx,sy}});\n  int ans=INF;\n  while(!q.empty()){\n    int cnt=q.front().first;\n    int x=q.front().second.first;\n    int y=q.front().second.second;\n    q.pop();\n    if(dp[x][y]<=cnt) continue;\n    dp[x][y]=cnt;\n    //cout<<x<<y<<endl;\n    if(a[x][y]=='.') continue;\n    if('A'<=a[x][y]&&a[x][y]<='Z'){\n      //cout<<a[x][y]<<\" \"<<cnt<<endl;\n      if(a[x][y]==t){\n\tans=min(ans,cnt);\n\tcontinue;\n      }\n      if(a[x-2][y]=='-') q.push({cnt+1,{x-2,y}});\n      if(a[x+2][y]=='-') q.push({cnt+1,{x+2,y}});\n      if(a[x][y-2]=='|') q.push({cnt+1,{x,y-2}});\n      if(a[x][y+2]=='|') q.push({cnt+1,{x,y+2}});\n    }\n    else if(a[x][y]=='o'){\n      for(int i=-1;i<2;i++){\n\tfor(int j=-1;j<2;j++){\n\t  if('A'<=a[x+i][y+j]&&a[x+i][y+j]<='Z'){\n\t    q.push({cnt,{x+i,y+j}});\n\t  }\n\t}\n      }\n    }\n    else{\n      if(a[x][y]=='-'){\n\tq.push({cnt,{x+1,y}});\n\tq.push({cnt,{x-1,y}});\n      }\n      else{\n\tq.push({cnt,{x,y+1}});\n\tq.push({cnt,{x,y-1}});\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n/*\n7 7 A D\nooo.ooo\noAo-oBo\nooo.ooo\n.|...|.\nooo.ooo\noCo-oDo\nooo.ooo\n\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            if(grid[temp.second][temp.first] == '|' && ( i > 1)) continue;\n            if(grid[temp.second][temp.first] == '-' && ( i <= 1))continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                assert(inrange(now.first, now.second));\n            }\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint H,W;\nchar S,T;\nint d[26][26];\nstring s[5000];\nint main(){\n\tcin>>H>>W>>S>>T;\n\trep(i,H) cin>>s[i];\n\n\trep(i,26) rep(j,26) if(i!=j) d[i][j] = 1e9;\n\n\trep(i,H) rep(j,W){\n\t\tif(s[i][j]=='-'){\n\t\t\tchar a = s[i][j-2];\n\t\t\tint k = j;\n\t\t\twhile(s[i][k]=='-') k++;\n\t\t\tchar b = s[i][k+1];\n\t\t\tassert(isupper(a) && isupper(b));\n\t\t\td[a-'A'][b-'A'] = d[b-'A'][a-'A'] = 1;\n\t\t\tfor(int l=j;l<k;l++) s[i][l] = '.';\n\t\t}\n\t\tif(s[i][j]=='|'){\n\t\t\tchar a = s[i-2][j];\n\t\t\tint k = i;\n\t\t\twhile(s[k][j]=='|') k++;\n\t\t\tchar b = s[k+1][j];\n\t\t\tassert(isupper(a) && isupper(b));\n\t\t\td[a-'A'][b-'A'] = d[b-'A'][a-'A'] = 1;\n\t\t\tfor(int l=i;l<k;l++) s[l][j] = '.';\n\t\t}\n\t}\n\trep(i,26) rep(j,26) rep(k,26) chmin(d[j][k],d[j][i]+d[i][k]);\n\tcout<<d[S-'A'][T-'A']<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nint di[4] = {1, 0, -1, 0}, dj[4] = {0, 1, 0, -1};\n\nmain {\n  int H, W;\n  char s, t;\n  cin >> H >> W >> s >> t;\n  vector<vector<char>> m(H, vector<char>(W));\n  int S, G;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> m[i][j];\n      if (isupper(m[i][j])) {\n        if (m[i][j] == s) S = i * W + j;\n        if (m[i][j] == t) G = i * W + j;\n        m[i][j] = 'o';\n      }\n    }\n  }\n\n  Graph g(H * W);\n  rep(i, H) rep(j, W) {\n    rep(k, 4) {\n      int i2 = i + di[k], j2 = j + dj[k];\n      if (i2 < 0 || j2 < 0 || i2 >= H || j2 >= W) continue;\n      if (m[i][j] == '-') {\n        if ((k==1||k==3)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '-') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == '|') {\n        if ((k==0||k==2)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == 'o') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        } else if (((k==1||k==3)&&m[i2][j2] == '-') ||((k==0||k==2)&& m[i2][j2] == '|')) {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        }\n      }\n    }\n  }\n  cout << dijkstra(g, S).first[G] / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing namespace std;\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> std::pair<std::vector<Weight>, std::vector<int>> dijkstra(const Graph &g, const int src) {\n  using state = std::pair<Weight, int>;\n  std::priority_queue<state, std::vector<state>, std::greater<state>> q;\n  std::vector<Weight> dist(g.size(), inf);\n  std::vector<int> via(g.size());\n  dist[src] = 0;\n  q.emplace(0, src);\n  while (q.size()) {\n    Weight d;\n    int v;\n    std::tie(d, v) = q.top();\n    q.pop();\n    if (dist[v] < d) continue;\n    for (auto &e : g[v]) {\n      if (cmin(dist[e.dst], dist[v] + e.weight)) {\n        via[e.dst] = v;\n        q.emplace(dist[e.dst], e.dst);\n      }\n    }\n  }\n  return {dist, via};\n}\n\nint di[4] = {1, 0, -1, 0}, dj[4] = {0, 1, 0, -1};\n\nmain {\n  int H, W;\n  char s, t;\n  cin >> H >> W >> s >> t;\n  vector<vector<char>> m(H, vector<char>(W));\n  int S, G;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> m[i][j];\n      if (isupper(m[i][j])) {\n        if (m[i][j] == s) S = i * W + j;\n        if (m[i][j] == t) G = i * W + j;\n        m[i][j] = 'o';\n      }\n    }\n  }\n\n  Graph g(H * W);\n  rep(i, H) rep(j, W) {\n    rep(k, 4) {\n      int i2 = i + di[k], j2 = j + dj[k];\n      if (i2 < 0 || j2 < 0 || i2 >= H || j2 >= W) continue;\n      if (m[i][j] == '-') {\n        if ((k==1||k==3)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '-') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == '|') {\n        if ((k==0||k==2)&&m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        } else if (m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        }\n      } else if (m[i][j] == 'o') {\n        if (m[i2][j2] == 'o') {\n          g.addArc(i * W + j, i2 * W + j2, 0);\n        } else if (m[i2][j2] == '-' || m[i2][j2] == '|') {\n          g.addArc(i * W + j, i2 * W + j2, 1);\n        }\n      }\n    }\n  }\n  cout << dijkstra(g, S).first[G] / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nint INF = 1 << 28;\n\nstruct state {\n    char ch;\n    int x, y, cost;\n    state() {}\n    state(char ch, int x, int y, int cost): ch(ch), x(x), y(y), cost(cost) {}\n};\n\nint H, W;\nchar S, T;\nstring G[50];\n\nint sx, sy, gx, gy;\n\nint main() {\n    cin >> H >> W >> S >> T;\n    for (int j = 0; j < H; ++j) {\n        cin >> G[j];\n    }\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            if (G[j][k] == S) {\n                sx = j; sy = k;\n            }\n            if (G[j][k] == T) {\n                gx = j; gy = k;\n            }\n        }\n    }\n\n    queue<state> que;\n    que.emplace(S, sx, sy, 0);\n\n    int ans[26];\n    fill(ans, ans+26, INF);\n    ans[S-'A'] = 0;\n\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = st.x + 2*dx[d], ny = st.y + 2*dy[d];\n            if (nx < 0 || H <= nx || ny < 0 || W <= ny) { continue; }\n            if (G[nx][ny] == '|' || G[nx][ny] == '-') {\n                while (!('A' <= G[nx][ny] && G[nx][ny] <= 'Z')) {\n                    nx += dx[d];  ny += dy[d];\n                }\n\n                char nch = G[nx][ny];\n\n                if (st.cost + 1 < ans[nch - 'A']) {\n                    ans[nch - 'A'] = st.cost + 1;\n                    que.emplace(nch, nx, ny, ans[nch-'A']);\n                }\n            }\n        }\n    }\n\n    cout << ans[T-'A'] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>pipii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  string ss,st;\n  cin>>h>>w>>ss>>st;\n  char s=ss[0],t=st[0];\n  rep(i,h){\n    cin>>brd[i];\n  }\n  priority_queue<pipii,vector<pipii>,greater<pipii> > que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push(pipii(0,pii(sx,sy)));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  int dx[4]={1,0,-1,0};\n  int dy[4]={0,1,0,-1};\n  while(!que.empty()){\n    pipii dt=que.top();que.pop();\n    int d=dt.first;\n    pii t=dt.second;\n    if(dis[t.first][t.second]<=d)continue;\n    dis[t.first][t.second]=d;\n    char cur=brd[t.first][t.second];\n    rep(dir,4){\n      if(cur=='|'&&dir%2==1)continue;\n      if(cur=='-'&&dir%2==0)continue;\n      int nx=t.first+dx[dir],ny=t.second+dy[dir];\n      if(nx<0||nx>=h||ny<0||ny>=w)continue;\n      if(brd[nx][ny]=='.')continue;\n      if(brd[nx][ny]=='|'&&dir%2==1)continue;\n      if(brd[nx][ny]=='-'&&dir%2==0)continue;\n      int cos=(brd[nx][ny]=='o'?1:0);\n      int nd=d+cos;\n      que.push(pipii(nd,pii(nx,ny)));\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]/2<<endl;\n    }\n  }\n  if(0){\n    rep(i,h)rep(j,w){\n      if(brd[i][j]>='A'&&brd[i][j]<='Z'){\n\tcerr<<brd[i][j]<<\" \"<<dis[i][j]<<endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n\tint h,w;\n\tchar s,t;\n\tcin >> h >> w >> s >> t;\n\tvector<int> x(26), y(26);\n\tvector<vector<char> > field(h, vector<char>(w));\n\tvector<int> vlist(26, false);\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tcin >> field[i][j];\n\t\t\tif('A' <= field[i][j] && field[i][j] <='Z'){\n\t\t\t\tvlist[field[i][j] -'A'] = true;\n\t\t\t\tx[field[i][j]-'A'] = j;\n\t\t\t\ty[field[i][j]-'A'] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int> > adj(26, vector<int>(26, inf));\n\tfor(int i=0; i<26; i++){\n\t\tfor(int j=i+1; j<26; j++){\n\t\t\tif(!vlist[i] || !vlist[j]) continue;\n\t\t\tif(x[i] == x[j]){\n\t\t\t\tbool connect = true;\n\t\t\t\tint yi=y[i], yj=y[j];\n\t\t\t\tif(yi>yj) swap(yi, yj);\n\t\t\t\tfor(int k=yi+1; k<yj-1; k++){\n\t\t\t\t\tif(field[k][x[i]]!='o' && field[k][x[i]]!='|'){\n\t\t\t\t\t\tconnect = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(connect) adj[i][j] = adj[j][i] = 1;\n\t\t\t}\n\t\t\tif(y[i] == y[j]){\n\t\t\t\tbool connect = true;\n\t\t\t\tint xi=x[i], xj=x[j];\n\t\t\t\tif(xi>xj) swap(xi, xj);\n\t\t\t\tfor(int k=xi+1; k<xj-1; k++){\n\t\t\t\t\tif(field[y[i]][k]!='o' && field[y[i]][k]!='-'){\n\t\t\t\t\t\tconnect = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(connect) adj[i][j] = adj[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor(int k=0; k<26; k++){\n\t\tfor(int i=0; i<26; i++){\n\t\t\tfor(int j=0; j<26; j++){\n\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << adj[s-'A'][t-'A'] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H, W, dist[55]; string x, y, s[55]; vector<int> g[55];\nbool isvalid(string t, bool yoko) {\n\tif (t.size() <= 4) return false;\n\tif (t[1] != 'o') return false;\n\tif (t[t.size() - 2] != 'o') return false;\n\tfor (int i = 2; i <= t.size() - 3; i++) {\n\t\tif (!((yoko && t[i] == '-') || (!yoko && t[i] == '|'))) return false;\n\t}\n\treturn true;\n}\nint main() {\n\tcin >> H >> W >> x >> y;\n\tfor (int i = 0; i < H; i++) cin >> s[i];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = j + 1; k <= W; k++) {\n\t\t\t\tif (isupper(s[i][j]) && isupper(s[i][k - 1]) && isvalid(s[i].substr(j, k - j), true)) {\n\t\t\t\t\tg[s[i][j] - 65].push_back(s[i][k - 1] - 65);\n\t\t\t\t\tg[s[i][k - 1] - 65].push_back(s[i][j] - 65);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < W; i++) {\n\t\tstring t;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tt += s[j][i];\n\t\t}\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tfor (int k = j + 1; k <= H; k++) {\n\t\t\t\tif (isupper(t[j]) && isupper(t[k - 1]) && isvalid(t.substr(j, k - j), false)) {\n\t\t\t\t\tg[t[j] - 65].push_back(t[k - 1] - 65);\n\t\t\t\t\tg[t[k - 1] - 65].push_back(t[j] - 65);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 26; i++) dist[i] = -1;\n\tqueue<int> que; que.push(x[0] - 65); dist[x[0] - 65] = 0;\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tfor (int i : g[u]) {\n\t\t\tif (dist[i] == -1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[y[0] - 65] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nconst int MAX_V = 50 * 50 + 1;\n\n\nint H,W;\nchar s,t;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nvoid Dijkstra(int s){\n  fill(d,d+MAX_V,INF);\n  fill(used,used+MAX_V,false);\n  d[s]=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<MAX_V;u++){\n      if(!used[u] && (v==-1||d[u]<d[v]))v=u;\n    }\n    if(v==-1)break;\n    used[v]=true;\n    for(int u=0;u<MAX_V;u++){\n      \n      d[u]=min(d[u],d[v]+cost[v][u]);\n    }\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\nvoid add_path(int x,int y){\n  int dx[2]={-1,0};\n  int dy[2]={0,-1};\n  rep(i,2){\n    int xx=dx[i]+x,yy=dy[i]+y;\n    if(graph[y][x]=='-'){\n      if(graph[yy][xx]=='o'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }else if(graph[yy][xx]=='-'){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }\n    }else if(graph[y][x]=='|'){\n      if(graph[yy][xx]=='o'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }else if(graph[yy][xx]=='|'){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }\n    }else if('A'<=graph[y][x]&&graph[y][x]<='Z'){\n      cost[y*W+x][yy*W+xx]=0;\n      cost[yy*W+xx][y*W+x]=0;\n    }else if(graph[y][x]=='o'){\n      if(graph[yy][xx]=='o'||('A'<=graph[yy][xx]&&graph[yy][xx]<='Z')){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }else if(graph[yy][xx]=='-'||graph[yy][xx]=='|'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }\n    }\n  }\n}\n\nint main(){\n  \n  cin>>H>>W>>s>>t;\n  int start,goal;\n  rep(i,H){\n    rep(j,W){\n      cin>>graph[i][j];\n      if(graph[i][j]==s)start=i*W+j;\n      if(graph[i][j]==t)goal=i*W+j;\n    }\n  }\n\n  rep(i,50*50+1){\n    rep(j,50*50+1)cost[i][j]=INF;\n  }\n  \n  REP(i,1,H){\n    REP(j,1,W){\n      add_path(j,i);\n    }\n  }\n\n  Dijkstra(start);\n  cout<<d[goal] / 2<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  int ss = s-'A', tt = t-'A';\n  queue<int>  que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = pos[u].first+dy[i], nx = pos[u].second+dx[i];\n      if(in(ny, nx)) assert(mas[ny][nx] == 'o');\n      ny += dy[i];\n      nx += dx[i];\n      while(in(ny, nx) && (mas[ny][nx] == '|' || mas[ny][nx] == '-')) {\n\tny += dy[i];\n\tnx += dx[i];\n      }\n      if(in(ny, nx)) assert(mas[ny][nx] == 'o');\n      ny += dy[i];\n      nx += dx[i];\n      if(!in(ny, nx)) continue;\n      assert(isalpha(mas[ny][nx]));\n      int v = mas[ny][nx]-'A';\n      if(dist[v] != -1) continue;\n      dist[v] = dist[u]+1;\n      que.push(v);\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint h, w;\nchar s, t;\nchar a[55][55];\n\nstruct edge{int to, cost;};\nvector<vector<edge>> g(100);\n\nvector<ll> dijkstra(int s, int n){\n    priority_queue<plli, vector<plli>, greater<plli>> pque;\n    vector<ll> d(n, INFLL);\n    d[s] = 0;\n    pque.push(plli(0, s));\n\n    while (!pque.empty()){\n        plli p = pque.top(); pque.pop();\n        int fr = p.second;\n        if (d[fr] < p.first) continue;\n        for (edge e: g[fr]){\n            if (d[e.to] > d[fr] + e.cost){\n                d[e.to] = d[fr] + e.cost;\n                pque.push(plli(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nbool al(int i, int j) {\n  return (a[i][j] != 'o' && a[i][j] != '.' && a[i][j] != '|' && a[i][j] != '-');\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w >> s >> t;\n    rep(i, h)rep(j, w) cin >> a[i][j];\n    rep(i, h)rep(j, w) {\n      if (al(i, j)) {\n        rep2(k, i + 2, h) {\n          if (a[k][j] == '.' || a[k][j] == '-') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        rep2(k, j + 2, w) {\n          if (a[i][k] == '.' || a[i][k] == '|') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = i - 2; k >= 0; k--) {\n          if (a[k][j] == '.' || a[k][j] == '-') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = j - 2; k >= 0; k--) {\n          if (a[i][k] == '.' || a[i][k] == '|') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n      }\n    }\n    vector<ll> dist = dijkstra(s - 'A', 100);\n    cout << dist[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring a[55];\nvector<PII> g[30];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int h, w;\n  char st, t;\n  cin >> h >> w >> st >> t;\n  REP(i, h) cin >> a[i];\n\n  vector<PII> pos(26, {-1, -1});\n  REP(i, h) REP(j, w) {\n    if('A' <= a[i][j] && a[i][j] <= 'Z') {\n      pos[a[i][j]-'A'] = {i, j};\n    }\n  }\n  // cout << pos << endl;\n\n  REP(i, 26) {\n    if(pos[i] == PII{-1, -1}) continue;\n    // cout << i << endl;\n    REP(j, 4) {\n      int x = pos[i].second + 2*dx[j], y = pos[i].first + 2*dy[j];\n      if(!IN(0LL, w, x) || !IN(0LL, h, y)) continue;\n      if(dx[j] != 0 && a[y][x] != '-') continue;\n      if(dy[j] != 0 && a[y][x] != '|') continue;\n      while(IN(0LL, w, x) && IN(0LL, h, y)) {\n        // cout << x << \" \" << y << endl;\n        if('A' <= a[y][x] && a[y][x] <= 'Z') {\n          g[i].PB({a[y][x]-'A', 1});\n          g[a[y][x]-'A'].PB({i, 1});\n          break;\n        } else if(a[y][x] != '.') {\n          x += dx[j], y += dy[j];\n        } else {\n          break;\n        }\n      }\n    }\n    // cout << g[i] << endl;\n  }\n\n  VI d(30);\n  auto dijkstra = [&](int s) {\n    d.assign(30, INF);\n    d[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> que;\n    que.push(PII{d[s], s});\n\n    while(que.size()) {\n      PII p = que.top(); que.pop();\n      // cout << p << endl;\n      int v = p.second;\n      if(d[v] < p.first) continue;\n      for(PII &e: g[v]) {\n        if(d[e.first] > d[v] + e.second) {\n          d[e.first] = d[v] + e.second;\n          que.push(PII{d[e.first], e.first});\n        }\n      }\n    }\n  };\n  dijkstra(st-'A');\n  cout << d[t-'A'] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstruct Edge {\n\t\tint to, cost;\n\t\tEdge() {}\n\t\tEdge(int to, int cost) : to(to), cost(cost) {}\n\t\tbool operator<(const Edge& r) const {\n\t\t\treturn cost < r.cost;\n\t\t}\n\t};\n\tstd::vector<std::vector<Edge>> g(h*w);\n\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) { sy = i; sx = j; }\n\t\tif (a[i][j] == t) { ty = i; tx = j; }\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == '|') {\n\t\t\tif (i > 0) g[i*w + j].emplace_back((i - 1)*w + j, 0);\n\t\t\tif (i < h - 1) g[i*w + j].emplace_back((i + 1)*w + j, 0);\n\t\t}\n\t\tif (a[i][j] == '-') {\n\t\t\tif (j > 0) g[i*w + j].emplace_back(i*w + j - 1, 0);\n\t\t\tif (j < w - 1) g[i*w + j].emplace_back(i*w + j + 1, 0);\n\t\t}\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\tREP(d, 4) {\n\t\t\t\tint dy = i + dy4[d] * 2;\n\t\t\t\tint dx = j + dx4[d] * 2;\n\t\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\t\tif (d % 2 == 0 && a[dy][dx] == '-') continue;\n\t\t\t\tif (d % 2 == 1 && a[dy][dx] == '|') continue;\n\t\t\t\tg[i*w + j].emplace_back(dy*w + dx, 1);\n\t\t\t\tg[dy*w + dx].emplace_back(i*w + j, 0);\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<int> dist(h*w);\n\tstd::function<void(int)> Dijkstra = [&](int s) {\n\t\tusing P = std::pair<int, int>;\n\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\t\tstd::fill(dist.begin(), dist.end(), INFINT);\n\t\tdist[s] = 0;\n\t\tpq.push(P(0, s));\n\t\twhile (!pq.empty()) {\n\t\t\tP p = pq.top(); pq.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\t\tEdge e = g[v][i];\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tpq.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tDijkstra(sy*w + sx);\n\tOUT(dist[ty*w + tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <string>\n#include <cstring>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing ll = long long;\n\nconst int vx[4] = { -1, 0, 1, 0 }, vy[4] = { 0, -1, 0, 1 };\n\nint main() {\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int H, W;\n  char s, t;\n  std::string aagraph[51];\n\n  cin >> H >> W >> s >> t;\n\n  for (int i = 0; i < H; ++i) {\n    cin >> aagraph[i];\n  }\n\n  int d[26][26];\n\n  std::memset(d, 0x3f, sizeof d);\n\n  for (int i = 0; i < 26; ++i) {\n    d[i][i] = 0;\n  }\n\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      if ('A' <= aagraph[i][j] && aagraph[i][j] <= 'Z') {\n\n        for (int k = 0; k < 4; ++k) {\n          int nx = i + vx[k] * 2, ny = j + vy[k] * 2;\n\n          if (0 <= nx && nx < H && 0 <= ny && ny < W) {\n            if (aagraph[nx][ny] == '-' || aagraph[nx][ny] == '|') {\n              while (aagraph[nx][ny] != 'o') {\n                nx += vx[k], ny += vy[k];\n              }\n              nx += vx[k], ny += vy[k];\n\n              int u = aagraph[i][j] - 'A', v = aagraph[nx][ny] - 'A';\n              d[u][v] = d[v][u] = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /*\n  for (int i = 0; i < 26; ++i) {\n    for (int j = 0; j < 26; ++j) {\n      cerr << d[i][j] << \" \"[j == 25];\n    }\n  }\n  */\n\n  for (int k = 0; k < 26; ++k) {\n    for (int i = 0; i < 26; ++i) {\n      for (int j = 0; j < 26; ++j) {\n        d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  int u = s - 'A', v = t - 'A';\n\n  cout << d[u][v] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\n#define ID(x, y) ((y) * w + x)\n\nstruct Edge {\n    ll to, cost;\n};\nvector<ll> dijkstra(const vector<vector<Edge>>& G, const ll s) {\n    const ll n = G.size();\n    vector<ll> dist(n, linf);\n    dist[s] = 0;\n    priority_queue<P, vector<P>, greater<P>> Q;\n    Q.push({0, s});\n    while ( !Q.empty() ) {\n        P p = Q.top(); Q.pop();\n        ll v = p.second;\n        ll cost = p.first;\n        if (cost > dist[v]) continue;\n        each(e, G[v]) {\n            if (dist[v] + e.cost < dist[e.to]) {\n                dist[e.to] = dist[v] + e.cost;\n                Q.push({dist[e.to], e.to});\n            }\n        }\n    }\n    return dist;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll h, w; cin >> h >> w;\n    char sc, tc; cin >> sc >> tc;\n    vector<string> m(h); cin >> m;\n    auto inRange = [&](ll x, ll y) {\n        return 0 <= x && x < w && 0 <= y && y < h;\n    };\n    ll s, t;\n    vector<vector<Edge>> G(w*h);\n    auto add_edge = [&](ll a, ll b, ll c) {\n        G[a].pb({b, c});\n        G[b].pb({a, c});\n    };\n    rep(y, h) rep(x, w) {\n        if (m[y][x] == sc) s = ID(x, y);\n        if (m[y][x] == tc) t = ID(x, y);\n        if (m[y][x] == '-') {\n            add_edge(ID(x-1, y), ID(x, y), 0);\n            add_edge(ID(x+1, y), ID(x, y), 0);\n        }\n        else if (m[y][x] == '|') {\n            add_edge(ID(x, y-1), ID(x, y), 0);\n            add_edge(ID(x, y+1), ID(x, y), 0);\n        }\n        else if ('A' <= m[y][x] && m[y][x] <= 'Z') {\n            rep(dx, -1, 2) rep(dy, -1, 2) {\n                if (dx != 0 || dy != 0) {\n                    add_edge(ID(x+dx, y+dy), ID(x, y), 1);\n                }\n            }\n        }\n    }\n    ll ans = dijkstra(G, s)[t];\n    assert(ans % 2 == 0);\n    cout << ans/2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint h, w;\nchar s, t;\nchar a[55][55];\n\nstruct edge{int to, cost;};\nvector<vector<edge>> g(100);\n\nvector<ll> dijkstra(int s, int n, vector<vector<edge>>& g){\n    priority_queue<plli, vector<plli>, greater<plli>> pque;\n    vector<ll> d(n, INFLL);\n    d[s] = 0;\n    pque.push(plli(0, s));\n\n    while (!pque.empty()){\n        plli p = pque.top(); pque.pop();\n        int fr = p.second;\n        if (d[fr] < p.first) continue;\n        for (edge e: g[fr]){\n            if (d[e.to] > d[fr] + e.cost){\n                d[e.to] = d[fr] + e.cost;\n                pque.push(plli(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nbool al(int i, int j) {\n  return (a[i][j] != 'o' && a[i][j] != '.' && a[i][j] != '|' && a[i][j] != '-');\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w >> s >> t;\n    rep(i, h)rep(j, w) cin >> a[i][j];\n    rep(i, h)rep(j, w) {\n      if (al(i, j)) {\n        rep2(k, i + 3, h) {\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        rep2(k, j + 3, w) {\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = i - 3; k >= 0; k--) {\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = j - 3; k >= 0; k--) {\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n      }\n    }\n    vector<ll> dist = dijkstra(s - 'A', 100, g);\n    cout << dist[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>pipii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  char s,t;\n  cin>>h>>w>>s>>t;\n  rep(i,h){\n    cin>>brd[i];\n  }\n  priority_queue<pipii,vector<pipii>,greater<pipii> > que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push(pipii(0,pii(sx,sy)));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  int dx[4]={1,0,-1,0};\n  int dy[4]={0,1,0,-1};\n  while(!que.empty()){\n    pipii dt=que.top();que.pop();\n    int d=dt.first;\n    pii t=dt.second;\n    if(dis[t.first][t.second]<=d)continue;\n    dis[t.first][t.second]=d;\n    rep(dir,4){\n      int nx=t.first+dx[dir],ny=t.second+dy[dir];\n      if(nx<0||nx>=h||ny<0||ny>=w)continue;\n      if(dis[nx][ny]<inf)continue;\n      if(brd[nx][ny]=='.')continue;\n      int cos=(brd[nx][ny]=='o'?1:0);\n      int nd=dis[t.first][t.second]+cos;\n      que.push(pipii(nd,pii(nx,ny)));\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]/2<<endl;\n    }\n  }\n  if(0){\n    rep(i,h)rep(j,w){\n      if(brd[i][j]>='A'&&brd[i][j]<='Z'){\n\tcerr<<brd[i][j]<<\" \"<<dis[i][j]<<endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>pipii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  char s,t;\n  cin>>h>>w>>s>>t;\n  rep(i,h){\n    cin>>brd[i];\n  }\n  deque<pipii> que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push_back(pipii(0,pii(sx,sy)));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  int dx[4]={1,0,-1,0};\n  int dy[4]={0,1,0,-1};\n  while(!que.empty()){\n    pipii dt=que.front();que.pop_front();\n    int d=dt.first;\n    pii t=dt.second;\n    if(dis[t.first][t.second]<=d)continue;\n    dis[t.first][t.second]=d;\n    rep(dir,4){\n      int nx=t.first+dx[dir],ny=t.second+dy[dir];\n      if(nx<0||nx>=h||ny<0||ny>=w)continue;\n      if(dis[nx][ny]<inf)continue;\n      if(brd[nx][ny]=='.')continue;\n      int cos=(brd[nx][ny]=='o'?1:0);\n      int nd=dis[t.first][t.second]+cos;\n      if(cos==1)\n\tque.push_back(pipii(nd,pii(nx,ny)));\n      else\n\tque.push_front(pipii(nd,pii(nx,ny)));\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]/2<<endl;\n    }\n  }\n  if(0){\n    rep(i,h)rep(j,w){\n      if(brd[i][j]>='A'&&brd[i][j]<='Z'){\n\tcerr<<brd[i][j]<<\" \"<<dis[i][j]<<endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 52 * 52 + 1;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[2] = {-1, 0};\n  int dy[2] = {0, -1};\n  rep(i, 2) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '-') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      assert(cost[y * W + x][yy * W + xx] == INF);\n      assert(cost[yy * W + xx][y * W + x] == INF);\n      cost[y * W + x][yy * W + xx] = 0;\n      cost[yy * W + xx][y * W + x] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n  rep(i, MAX_V) cost[i][i]=0;\n\n  REP(i, 1, H) REP(j, 1, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(d[p.second] % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 52 * 52 + 1;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  rep(i, 4) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (xx<0||yy<0||xx>=W||yy>=H)continue;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        // cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '-') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        // cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        // cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '|') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        // cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      // assert(cost[y * W + x][yy * W + xx] == INF);\n      // assert(cost[yy * W + xx][y * W + x] == INF);\n      cost[y * W + x][yy * W + xx] = 0;\n      // cost[yy * W + xx][y * W + x] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        // cost[yy * W + xx][y * W + x] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        // cost[yy * W + xx][y * W + x] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  rep(i, H) rep(j, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(d[p.second] % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  // rep(i,H) {\n  //   rep(j,W) cout<<d[i*W+j]<<' ';\n  //   cout<<endl;\n  // }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing ll = long long;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(in) in.begin(), in.end()\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            if(grid[temp.second][temp.first] == '|' && ( i > 1)) continue;\n            if(grid[temp.second][temp.first] == '-' && ( i <= 1))continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                assert(inrange(now.first, now.second));\n            }\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nstruct Dijkstra {\n  Dijkstra(int V) : V(V), G(V) {}\n  struct edge {\n    edge(int to, long long cost) : to(to), cost(cost) {}\n    int to;\n    long long cost;\n  };\n\n  using P = pair<long long, int>;\n  const long long inf = 1001001001001001001ll;\n\n  int V;\n  vector<vector<edge>> G;\n  vector<long long> d;\n\n  void init(int n) {\n    V = n;\n    G.resize(n);\n  }\n\n  void debug() {\n    cerr << \"edges : \" << endl;\n    for (int i = 0; i < V; ++i)\n      for (auto e : G[i]) cerr << i << \" -> \" << e.to << \" : \" << e.cost << endl;\n    cerr << endl << \"dist : \" << endl;\n    for (int i = 0; i < V; ++i) cerr << i << \" : \" << d[i] << endl;\n  }\n\n  void add_edge(int u, int v, long long c) {\n    // cerr << char(u + 'A') << \" -> \" << char(v + 'A') << endl;\n    G[u].push_back(edge(v, c));\n  }\n\n  void build(int s) {\n    d.assign(V, inf);\n    priority_queue<P, vector<P>, greater<P>> q;\n\n    d[s] = 0;\n    q.push(P(0ll, s));\n\n    while (!q.empty()) {\n      P p = q.top();\n      q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto &e : G[v])\n        if (d[e.to] > p.first + e.cost) {\n          d[e.to] = p.first + e.cost;\n          q.push(P(d[e.to], e.to));\n        }\n    }\n  }\n\n  long long operator[](int v) {\n    return d[v];\n  }\n};\n\nDijkstra G(30);\nint h, w;\nchar a[60][60];\n\nvoid add_edge(int y, int x, int v) {\n  for (int i = y - 2; i > 0; --i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i - 1][x] - 'A', 1);\n    break;\n  }\n  for (int i = y + 2; i <= h; ++i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i + 1][x] - 'A', 1);\n    break;\n  }\n  for (int j = x - 2; j > 0; --j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j - 1] - 'A', 1);\n    break;\n  }\n  for (int j = x + 2; j <= w; ++j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j + 1] - 'A', 1);\n    break;\n  }\n}\n\nsigned main(int argc, char *argv[]) {\n  char s, t;\n\n  cin >> h >> w >> s >> t;\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      cin >> a[i][j];\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      if ('A' <= a[i][j] && a[i][j] <= 'Z') {\n        // cerr << a[i][j] << endl;\n        add_edge(i, j, a[i][j] - 'A');\n      }\n    }\n  }\n\n  G.build(s - 'A');\n  cout << G[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nint main() {\n  int h, w;\n  char S, T;\n\n  cin >> h >> w >> S >> T;\n\n  int sx = -1, sy = -1;\n  int gx = -1, gy = -1;\n\n  char c[100][100];\n  // fill_n(c, 100 * 100, '.');\n  for (int i = 0; i < 100; ++i) {\n    for (int j = 0; j < 100; ++j) {\n      c[i][j] = '.';\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      cin >> c[i][j];\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      if ('A' <= c[i][j] && c[i][j] <= 'Z') {\n        if (S == c[i][j]) {\n          sy = i;\n          sx = j;\n        }\n        if (T == c[i][j]) {\n          gy = i;\n          gx = j;\n        }\n\n        for (int k = 0; k < 4; ++k) {\n          int y = i + dy[k], x = j + dx[k];\n          int ny = i + 2 * dy[k], nx = j + 2 * dx[k];\n          c[y][x] = c[ny][nx];\n        }\n        for (int k = 4; k < 8; ++k) {\n          int y = i + dy[k], x = j + dx[k];\n          c[y][x] = '.';\n        }\n      }\n    }\n  }\n\n  int d[100][100];\n  // fill_n(d, 100 * 100, inf);\n  for (int i = 0; i < 100; ++i) {\n    for (int j = 0; j < 100; ++j) {\n      d[i][j] = inf;\n    }\n  }\n\n  using P = pair<int, int>;\n  queue<P> q;\n\n  q.push(P(sy, sx));\n  d[sy][sx] = 0;\n  while (!q.empty()) {\n    P p = q.front();\n    q.pop();\n\n    for (int i = 0; i < 4; ++i) {\n      int y = p.fs + dy[i];\n      int x = p.sc + dx[i];\n\n      if (c[y][x] == '.') continue;\n\n      if (d[y][x] > d[p.fs][p.sc] + ('A' <= c[y][x] && c[y][x] <= 'Z')) {\n        d[y][x] = d[p.fs][p.sc] + ('A' <= c[y][x] && c[y][x] <= 'Z');\n        q.push(P(y, x));\n      }\n    }\n  }\n\n  cout << d[gy][gx] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 52 * 52 + 1;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[2] = {-1, 0};\n  int dy[2] = {0, -1};\n  rep(i, 2) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '-') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      assert(cost[y * W + x][yy * W + xx] == INF);\n      assert(cost[yy * W + xx][y * W + x] == INF);\n      cost[y * W + x][yy * W + xx] = 0;\n      cost[yy * W + xx][y * W + x] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  REP(i, 1, H) REP(j, 1, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(d[p.second] % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day3/problems/C>\n 問題文============================================================\n \n (略\n \n =================================================================\n \n 解説=============================================================\n \n グラフさえ作れば、やるだけ、、、、\n 実装を頑張る\n \n ================================================================\n */\n\nint dy[4] = {0,2,0,-2};\nint dx[4] = {2,0,-2,0};\nint dir[4] = {0,1,2,3};\nint diry[4] = {0,1,0,-1};\nint dirx[4] = {1,0,-1,0};\n\nchar bar[4] = {'-','|','-','|'};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll H,W; cin >> H >> W;\n    char cs,ct; cin >> cs >> ct;\n    ll s,t; s = (cs - 'A'); t = (ct - 'A');\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'#'));\n    map<char,pii> mp;\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] >= 'A' && masu[i][j] <= 'Z'){\n                mp[masu[i][j]] = {i,j};\n            }\n        }\n    }\n    \n    for(auto m:mp){\n        auto p = m.second;\n        for(int i = -1;i <= 1; i++){\n            for(int j = -1; j <= 1;j++){\n                masu[p.first+i][p.second+j] = masu[p.first][p.second];\n            }\n        }\n    }\n    \n    //    cout << masu << endl;\n    \n    vector<vector<int>> G(30);\n    for(auto m:mp){\n        auto p = m.second;\n        int u = masu[p.first][p.second] - 'A';\n        for(int i = 0; i < 4;i++){\n            char masu_c = masu[p.first+dy[i]][p.second+dx[i]];\n            if(masu_c == bar[i]){\n                int ny = p.first+dy[i],nx = p.second+dx[i];\n                while(true){\n                    if(ny > H || ny < 1 || nx > W || nx < 1) break;\n                    if(masu[ny][nx] == '#') break;\n                    if(masu[ny][nx] == bar[i]){\n                        ny += diry[dir[i]]; nx += dirx[dir[i]];\n                        continue;\n                    }\n                    if(masu[ny][nx] >= 'A' && masu[ny][nx] <= 'Z'){\n                        int v = masu[ny][nx] - 'A';\n                        G[u].push_back(v);\n                        G[v].push_back(u);\n                        break;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    \n    \n    vector<ll> dist(30,INF);\n    dist[s] = 0;\n    queue<ll> q; q.push(s);\n    while(q.size()){\n        ll n = q.front(); q.pop();\n        for(auto next:G[n]){\n            if(dist[next] > dist[n] + 1){\n                dist[next] = dist[n] + 1;\n                q.push(next);\n            }\n        }\n    }\n//    cout << dist << endl;\n    cout << dist[t] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\nconst int M = 1000000007;\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint main() {\n    int h, w;\n    char s, g;\n    cin >> h >> w >> s >> g;\n    int si, sj, gi, gj;\n    vector<string> b(h);\n    for (int i = 0; i < h; ++i) {\n        cin >> b[i];\n        for (int j = 0; j < w; ++j) {\n            if (b[i][j] == s) {\n                si = i;\n                sj = j;\n            }\n            if (b[i][j] == g) {\n                gi = i;\n                gj = j;\n            }\n        }\n    }\n    vector<vector<int>> dist(h, vector<int>(w, M));\n    dist[si][sj] = 0;\n    deque<P> dq;\n    dq.push_back(P(si, sj));\n    while (!dq.empty()) {\n        P p = dq.front();\n        int i = p.first, j = p.second;\n        dq.pop_front();\n        for (int k = 0; k < 4; ++k) {\n            int ti = i + dd[k], tj = j + dd[k + 1];\n            if (ti >= 0 && ti < h && tj >= 0 && tj < w) {\n                if (b[i][j] == 'o' && (b[ti][tj] == '|' || b[ti][tj] == '-')) {\n                    if (dist[ti][tj] > dist[i][j] + 1) {\n                        dist[ti][tj] = dist[i][j] + 1;\n                        dq.push_back(P(ti, tj));\n                    }\n                }\n                else if (b[ti][tj] != '.' && dist[ti][tj] > dist[i][j]) {\n                    dist[ti][tj] = dist[i][j];\n                    dq.push_front(P(ti, tj));\n                }\n            }\n        }\n    }\n    cout << dist[gi + 1][gj] << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nstruct Dijkstra {\n  Dijkstra(int V) : V(V), G(V) {}\n  struct edge {\n    edge(int to, long long cost) : to(to), cost(cost) {}\n    int to;\n    long long cost;\n  };\n\n  using P = pair<long long, int>;\n  const long long inf = 1001001001001001001ll;\n\n  int V;\n  vector<vector<edge>> G;\n  vector<long long> d;\n\n  void init(int n) {\n    V = n;\n    G.resize(n);\n  }\n\n  void debug() {\n    cerr << \"edges : \" << endl;\n    for (int i = 0; i < V; ++i)\n      for (auto e : G[i]) cerr << i << \" -> \" << e.to << \" : \" << e.cost << endl;\n    cerr << endl << \"dist : \" << endl;\n    for (int i = 0; i < V; ++i) cerr << i << \" : \" << d[i] << endl;\n  }\n\n  void add_edge(int u, int v, long long c) {\n    // cerr << char(u + 'A') << \" -> \" << char(v + 'A') << endl;\n    G[u].push_back(edge(v, c));\n  }\n\n  void build(int s) {\n    d.assign(V, inf);\n    priority_queue<P, vector<P>, greater<P>> q;\n\n    d[s] = 0;\n    q.push(P(0ll, s));\n\n    while (!q.empty()) {\n      P p = q.top();\n      q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto &e : G[v])\n        if (d[e.to] > p.first + e.cost) {\n          d[e.to] = p.first + e.cost;\n          q.push(P(d[e.to], e.to));\n        }\n    }\n  }\n\n  long long operator[](int v) {\n    return d[v];\n  }\n};\n\nDijkstra G(30);\nint h, w;\nchar a[60][60];\n\nvoid add_edge(int y, int x, int v) {\n  for (int i = y - 2; i > 1; --i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i - 1][x] - 'A', 1);\n    break;\n  }\n  for (int i = y + 2; i <= h; ++i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i + 1][x] - 'A', 1);\n    break;\n  }\n  for (int j = x - 2; j > 1; --j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j - 1] - 'A', 1);\n    break;\n  }\n  for (int j = x + 2; j <= w; ++j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j + 1] - 'A', 1);\n    break;\n  }\n}\n\nsigned main(int argc, char *argv[]) {\n  char s, t;\n\n  cin >> h >> w >> s >> t;\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      cin >> a[i][j];\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      if ('A' <= a[i][j] && a[i][j] <= 'Z') {\n        // cerr << a[i][j] << endl;\n        add_edge(i, j, a[i][j] - 'A');\n      }\n    }\n  }\n\n  G.build(s - 'A');\n  cout << G[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nusing P = pair<long long, long long>;\n\nstruct edge{\n    long long to, cost;\n};\n\nclass dijkstra\n{\nprivate:\n    long long vertex;   // 頂点数\n    vector<vector<edge>> list;  //隣接リスト\n    vector<long long> distance;    // 距離\npublic:\n    void init(long long n);  // nは頂点の数\n    void add_edge(long long v1, long long v2, long long cost);    // 頂点v1から頂点v2に辺を張る\n    void run(long long s);        // sは開始地点。\n    long long get_distance(long long v);    // 頂点vへの距離を返す\n};\n\nvoid dijkstra::init(long long n){\n    vertex = n;\n    list.resize(n);\n}\n\nvoid dijkstra::add_edge(long long v1, long long v2, long long cost){\n    list[v1].push_back({ v2, cost });\n}\n\nvoid dijkstra::run(long long s){\n    priority_queue<P, vector<P>, greater<P>> que;\n    distance = vector<long long>(vertex, INF);\n    distance[s] = 0;    // 開始点の距離は0\n    que.push(P(0, s));\n    \n    while(!que.empty()){\n        P p = que.top(); que.pop();\n        long long v = p.second;\n        if(distance[v] < p.first) continue;\n        for(auto e : list[v]){\n            if(distance[e.to] > distance[v] + e.cost){\n                distance[e.to] = distance[v] + e.cost;\n                que.push(P(distance[e.to], e.to));\n            }\n        }\n    }\n}\n\nlong long dijkstra::get_distance(long long v){\n    return distance[v];\n}\n\n \nint main() {\n    int h, w;\n    string s, t, a[55];\n    \n    cin >> h >> w >> s >> t;\n    REP(i, h){\n        cin >> a[i];\n    }\n    \n    int ss = s[0] - 'A', tt = t[0] - 'A';\n    // cout << ss << ' ' << tt << endl;\n    \n    dijkstra dik;\n    dik.init(2500);\n    \n    REP(i, h){\n        REP(j, w){\n            if(a[i][j] != '.' && a[i][j] != 'o' && a[i][j] != '-' && a[i][j] != '|'){\n                if(j > 1){\n                    if(a[i][j - 2] == '-'){\n                        for(int k = j - 2; k >= 0; k--){\n                            if(a[i][k] != '.' && a[i][k] != 'o' && a[i][k] != '-' && a[i][k] != '|'){\n                                dik.add_edge(a[i][j] - 'A', a[i][k] - 'A', 1);\n                                dik.add_edge(a[i][k] - 'A', a[i][j] - 'A', 1);\n                                // cout << a[i][j] - 'A' << ' ' << a[i][k] - 'A' << endl;\n                                goto aaa;\n                            }\n                        }\n                    }\n                }\n            aaa:\n                \n                if(j < w - 2){\n                    if(a[i][j + 2] == '-'){\n                        for(int k = j + 2; k < w; k++){\n                            if(a[i][k] != '.' && a[i][k] != 'o' && a[i][k] != '-' && a[i][k] != '|'){\n                                dik.add_edge(a[i][j] - 'A', a[i][k] - 'A', 1);\n                                dik.add_edge(a[i][k] - 'A', a[i][j] - 'A', 1);\n                                // cout << a[i][j] - 'A' << ' ' << a[i][k] - 'A' << endl;\n                                goto bbb;\n                            }\n                        }\n                    }\n                }\n            bbb:\n                \n                if(i > 1){\n                    if(a[i - 2][j] == '|'){\n                        for(int k = i - 2; k >= 0; k--){\n                            if(a[k][j] != '.' && a[k][j] != 'o' && a[k][j] != '-' && a[k][j] != '|'){\n                                dik.add_edge(a[i][j] - 'A', a[k][j] - 'A', 1);\n                                dik.add_edge(a[k][j] - 'A', a[i][j] - 'A', 1);\n                                // cout << a[i][j] - 'A' << ' ' << a[k][j] - 'A' << endl;\n                                goto ccc;\n                            }\n                        }\n                    }\n                }\n            ccc:\n                \n                if(i < h - 2){\n                    if(a[i + 2][j] == '|'){\n                        for(int k = i + 2; k < h; k++){\n                            if(a[k][j] != '.' && a[k][j] != 'o' && a[k][j] != '-' && a[k][j] != '|'){\n                                dik.add_edge(a[i][j] - 'A', a[k][j] - 'A', 1);\n                                dik.add_edge(a[k][j] - 'A', a[i][j] - 'A', 1);\n                                // cout << a[i][j] - 'A' << ' ' << a[k][j] - 'A' << endl;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    dik.run(ss);\n    \n    cout << dik.get_distance(tt) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\trep(i,4){\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\tint yy = y+i, xx = x+j;\n\t\t\t\ta[yy][xx] = a[y][x];\n\t\t\t\tused[yy][xx] = 1;\n\t\t\t\tif(i*j == -1 || i*j == 1)a[yy][xx] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill((int*)used, (int*)(used+100), 0);\n\trrep(i,h)rrep(j,w){\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\t/*int x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t}*/\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  int ss = s-'A', tt = t-'A';\n  queue<int>  que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = pos[u].first+dy[i]+dy[i], nx = pos[u].second+dx[i]+dx[i];\n      while(in(ny, nx) && (mas[ny][nx] == '|' || mas[ny][nx] == '-')) {\n\tny += dy[i];\n\tnx += dx[i];\n      }\n      ny += dy[i];\n      nx += dx[i];\n      if(!in(ny, nx)) continue;\n      if(!isalpha(mas[ny][nx])) continue;\n      int v = mas[ny][nx]-'A';\n      if(dist[v] != -1) continue;\n      dist[v] = dist[u]+1;\n      que.push(v);\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, h, w);\n\tVAR(char, s, t);\n\tMAT(char, a, h, w);\n\n\tstd::vector<std::vector<int>> dist(h, std::vector<int>(w, INFINT));\n\tint sx = -1, sy = -1, tx = -1, ty = -1;\n\tREP(i, h) REP(j, w) {\n\t\tif (a[i][j] == s) sy = i, sx = j;\n\t\tif (a[i][j] == t) ty = i, tx = j;\n\n\t\tif (IN('A', a[i][j], 'Z' + 1)) {\n\t\t\ta[i - 1][j - 1] = '.';\n\t\t\ta[i - 1][j + 1] = '.';\n\t\t\ta[i + 1][j - 1] = '.';\n\t\t\ta[i + 1][j + 1] = '.';\n\t\t}\n\t}\n\n\tint dy4[] = {-1, 0, 1, 0};\n\tint dx4[] = {0, 1, 0, -1};\n\tstd::queue<PAIR> que({PAIR(sy, sx)});\n\tdist[sy][sx] = 0;\n\twhile (!que.empty()) {\n\t\tauto p = que.front(); que.pop();\n\t\tREP(d, 4) {\n\t\t\tint dy = p.first + dy4[d];\n\t\t\tint dx = p.second + dx4[d];\n\t\t\tif (!IN(0, dy, h) || !IN(0, dx, w)) continue;\n\t\t\tif (a[dy][dx] == '.') continue;\n\t\t\tif (dist[dy][dx] <= dist[p.first][p.second]) continue;\n\t\t\tdist[dy][dx] = dist[p.first][p.second] + IN('A', a[dy][dx], 'Z' + 1);\n\t\t\tque.push(PAIR(dy, dx));\n\t\t}\n\t}\n\tOUT(dist[ty][tx])BR;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\nstruct edge { ll v, dist; };\nstruct state {\n  ll v, cost;\n  bool operator>(const state s) const { return cost > s.cost; }\n};\n\nvector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n  vector<ll> dp(E.size(), INF);\n  priority_queue<state, vector<state>, greater<state> > q;\n  q.push((state) { S, 0 });\n  while(!q.empty()) {\n    ll v = q.top().v, cost = q.top().cost;\n    q.pop();\n    if(dp[v] <= cost) continue;\n    dp[v] = cost;\n    REP(i, 0, E[v].size()) {\n      ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n      if(dp[nv] > ncost) q.push((state) { nv, ncost });\n    }\n  }\n  return dp;\n}\n\nint main(void) {\n  ll H, W;\n  char S, T;\n  cin >> H >> W >> S >> T;\n  char A[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> A[i][j];\n\n  vector< vector<edge> > E(256);\n  REP(i, 0, H) REP(j, 0, W) {\n    if('A' <= A[i][j] && A[i][j] <= 'Z') {\n      ll dd[5] = { 0, 1, 0, -1, 0 };\n      REP(k, 0, 4) {\n        ll pi = i + dd[k];\n        ll pj = j + dd[k + 1];\n        while(1) {\n          pi += dd[k];\n          pj += dd[k + 1];\n          if(!(0 <= pi && pi < H && 0 <= pj && pj < W)) break;\n          if(A[pi][pj] == 'o') {\n            E[A[i][j]].push_back((edge) { A[pi + dd[k]][pj + dd[k + 1]], 1 });\n            // cout << A[i][j] << \" \" << A[pi + dd[k]][pj + dd[k + 1]] << endl;\n            break;\n          }\n          if(dd[k] != 0 && A[pi][pj] != '|') break;\n          if(dd[k + 1] != 0 && A[pi][pj] != '-') break;\n          if(A[pi][pj] == '.') break;\n        }\n      }\n    }\n  }\n\n  cout << dijkstra(E, S)[T] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint alf_to_num(char c){\n\treturn (int)c - (int)'A';\n}\n\nint main(){\n\tint H, W, i, j, k, nowv;\n\tchar s, t;\n\tscanf(\"%d%d %c %c\", &H, &W, &s, &t);\n\tchar **a = (char **)malloc(sizeof(char *) * (H + 2));\n\tfor(i = 0; i <= H + 1; i++){\n\t\ta[i] = (char *)malloc(sizeof(char) * (W + 2));\n\t\tif(i == 0 || i == H + 1){\n\t\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\t\ta[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ta[i][0] = '.';\n\t\t\tscanf(\"%s\", &a[i][1]);\n\t\t\ta[i][W + 1] = '.';\n\t\t}\n\t}\n\tint **dis = (int **)malloc(sizeof(int *) * 26);\n\tfor(i = 0; i < 26; i++){\n\t\tdis[i] = (int *)malloc(sizeof(int) * 26);\n\t\tfor(j = 0; j < 26; j++){\n\t\t\tdis[i][j] = inf;\n\t\t}\n\t}\n\n\tfor(i = 0; i <= H + 1; i++){\n\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\tnowv = alf_to_num(a[i][j]);\n\t\t\tif(0 <= nowv && nowv < 26){\n\t\t\t\tif(a[i - 2][j] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i - k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i - k - 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i - k - 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i - k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i + 2][j] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i + k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i + k + 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i + k + 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i + k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j - 2] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j - k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j - k - 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j - k - 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j - k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j + 2] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j + k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j + k + 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j + k + 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j + k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(k = 0; k < 26; k++){\n\t\tfor(i = 0; i < 26; i++){\n\t\t\tfor(j = 0; j < 26; j++){\n\t\t\t\tif(dis[i][j] > dis[i][k] + dis[k][j]){\n\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dis[alf_to_num(s)][alf_to_num(t)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nint h,w;\nchar a,b;\nstring s[51];\n\nii getP(char c) {\n  rep(i,h) {\n    rep(j,w) {\n      if( s[i][j] == c ) return ii(j,i);\n    }\n  }\n  assert(false);\n}\n\nint mini[51][51];\n\nstruct Data {\n  int x,y,c;\n  bool operator < ( const Data &data) const {\n    if( c != data.c ) return c > data.c;\n    return x < data.x;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvoid compute() {\n  ii sp = getP(a), ep = getP(b);\n  rep(i,h) rep(j,w) mini[i][j] = INT_MAX;\n  mini[sp.second][sp.first] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){sp.first,sp.second,0});\n  while( !Q.empty() ) {\n    Data d = Q.top(); Q.pop();\n    rep(i,4) {\n      int nx = d.x + dx[i];\n      int ny = d.y + dy[i];\n      if( !( 0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n      char c = s[ny][nx];\n      if( c == '.' ) continue;\n      int coef = 0;\n      if( s[d.y][d.x] == 'o'  && ( c == '-' | c == '|' ) ) {\n\tcoef = 1;\n      }\n      if( mini[ny][nx] > d.c + coef ) {\n\tmini[ny][nx] = d.c + coef;\n\tQ.push((Data){nx,ny,mini[ny][nx]});\n      }\n    }\n  }\n  cout <<mini[ep.second][ep.first] << endl;\n}\n\nint main() {\n  cin >> h  >> w >> a >> b;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1010101;\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nbool is_edge(int x, char c){\n    if(x<2) return c=='-';\n    return c=='|';\n}\n\nint main(){\n    int h,w;\n    char s,t;\n    cin >>h >>w >>s >>t;\n\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    pi start,goal;\n    rep(i,h)rep(j,w){\n        if(f[i][j] == s) start = {i,j};\n        if(f[i][j] == t) goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n    vector<vector<int>> d(h,vector<int>(w,INF));\n    queue<pi> que;\n    d[start.fi][start.se] = 0;\n    que.push(start);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        rep(i,4){\n            int xx = now.se+2*dx[i], yy = now.fi+2*dy[i];\n            if(IN(yy,xx) && is_edge(i,f[yy][xx])){\n                while( !('A'<=f[yy][xx] && f[yy][xx]<='Z') ){\n                    yy += dy[i];\n                    xx += dx[i];\n                }\n\n                if(('A'<=f[yy][xx] && f[yy][xx]<='Z')){\n                    if(d[yy][xx] > d[now.fi][now.se]+1){\n                        d[yy][xx] = d[now.fi][now.se]+1;\n                        que.push({yy,xx});\n                    }\n                }\n            }\n        }\n    }\n\n    cout << d[goal.fi][goal.se] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\nconst int M = 1000000007;\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nint main() {\n    int h, w;\n    char s, g;\n    cin >> h >> w >> s >> g;\n    int si = -1, sj = -1, gi = -1, gj = -1;\n    vector<string> b(h);\n    for (int i = 0; i < h; ++i) {\n        cin >> b[i];\n        for (int j = 0; j < w; ++j) {\n            if (b[i][j] == s) {\n                si = i;\n                sj = j;\n            }\n            if (b[i][j] == g) {\n                gi = i;\n                gj = j;\n            }\n        }\n    }\n    vector<vector<int>> dist(h, vector<int>(w, M));\n    dist[si + 1][sj] = 0;\n    deque<P> dq;\n    dq.push_back(P(si + 1, sj));\n    while (!dq.empty()) {\n        P p = dq.front();\n        int i = p.first, j = p.second;\n        dq.pop_front();\n        if (i + 1 < h) {\n            if ((b[i][j] == 'o' && b[i + 1][j] == 'o' || b[i][j] == '|' && b[i + 1][j] == '|') && dist[i + 1][j] > dist[i][j]) {\n                dist[i + 1][j] = dist[i][j];\n                dq.push_front(P(i + 1, j));\n            }\n            if ((b[i][j] == 'o' && b[i + 1][j] == '|' || b[i][j] == '|' && b[i + 1][j] == 'o') && dist[i + 1][j] > dist[i][j] + 1) {\n                dist[i + 1][j] = dist[i][j] + 1;\n                dq.push_back(P(i + 1, j));\n            }\n        }\n        if (i > 0) {\n            if ((b[i][j] == 'o' && b[i - 1][j] == 'o' || b[i][j] == '|' && b[i - 1][j] == '|') && dist[i - 1][j] > dist[i][j]) {\n                dist[i - 1][j] = dist[i][j];\n                dq.push_front(P(i - 1, j));\n            }\n            if ((b[i][j] == 'o' && b[i - 1][j] == '|' || b[i][j] == '|' && b[i - 1][j] == 'o') && dist[i - 1][j] > dist[i][j] + 1) {\n                dist[i - 1][j] = dist[i][j] + 1;\n                dq.push_back(P(i - 1, j));\n            }\n        }\n        if (j + 1 < w) {\n            if ((b[i][j] == 'o' && b[i][j + 1] == 'o' || b[i][j] == '-' && b[i][j + 1] == '-') && dist[i][j + 1] > dist[i][j]) {\n                dist[i][j + 1] = dist[i][j];\n                dq.push_front(P(i, j + 1));\n            }\n            if ((b[i][j] == 'o' && b[i][j + 1] == '-' || b[i][j] == '-' && b[i][j + 1] == 'o') && dist[i][j + 1] > dist[i][j] + 1) {\n                dist[i][j + 1] = dist[i][j] + 1;\n                dq.push_back(P(i, j + 1));\n            }\n        }\n        if (j > 0) {\n            if ((b[i][j] == 'o' && b[i][j - 1] == 'o' || b[i][j] == '-' && b[i][j - 1] == '-') && dist[i][j - 1] > dist[i][j]) {\n                dist[i][j - 1] = dist[i][j];\n                dq.push_front(P(i, j - 1));\n            }\n            if ((b[i][j] == 'o' && b[i][j - 1] == '-' || b[i][j] == '-' && b[i][j - 1] == 'o') && dist[i][j - 1] > dist[i][j] + 1) {\n                dist[i][j - 1] = dist[i][j] + 1;\n                dq.push_back(P(i, j - 1));\n            }\n        }\n    }\n    cout << dist[gi + 1][gj] / 2 << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nstring s[100];\nvector<int> G[30];\nsigned main(){\nint h,w;\n\tcin>>h>>w;\n\tchar c1,c2;\n\tcin>>c1>>c2;\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\t\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(s[i][j]>='A' && s[i][j]<='Z'){\n\n\t\t\n\t\tfor(int r=0;r<4;r++){\n\t\t\t\tint x=i,y=j;\n\t\tx+=dx[r];\n\t\t\ty+=dy[r];\n\t\t\t\n\t\t\tif(x<0 || x>=h || y<0 ||y >=w)continue;\n\t\t\t\n\t\t\twhile(s[x][y]!='.' && s[x][y]!=(r%2==1?'-':'|')){\n\t\t\t\tif(s[x][y]>='A' && s[x][y]<='Z'){\n\t\t\t\t\tG[s[i][j]-'A'].pb(s[x][y]-'A');\n\t\t\t//\t\tcout<<s[i][j]<<\" \"<<s[x][y]<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx+=dx[r],y+=dy[r];\n\t\t\t\tif(x<0 || x>=h || y<0 ||y >=w)goto lll;\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tlll:;\n\t\t}\n\t\n\t\n\t}\n\t\n\t\n\tint s=c1-'A';\n\tint t=c2-'A';\n\t\n\tqueue<pa> qu;\n\tint sumi[30]={0};\n\tqu.push(mp(s,0));\n\t\n\twhile(1){\n\t\tpa z=qu.front();\n\t\tqu.pop();\n\t\tif(sumi[z.first]) continue;\n\t\tsumi[z.first]=1;\n\t\tif(z.first==t) {\n\t\t\tcout<<z.second<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(auto v:G[z.first]){\n\t\t\tqu.push(mp(v,z.second+1));\n\t\t}\n\t\n\t}\n\t\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nconst int INF = 1 << 29;\nconst int vy[] = {1, 0, -1, 0};\nconst int vx[] = {0, -1, 0, 1};\n\ntemplate< typename T = int >\nvoid warshall_floyd(Matrix< T > &g) {\n  for(int k = 0; k < g.size(); k++) {\n    for(int i = 0; i < g.size(); i++) {\n      for(int j = 0; j < g.size(); j++) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int H, W;\n  char S, T;\n  string A[50];\n  cin >> H >> W >> S >> T;\n  for(int i = 0; i < H; i++) {\n    cin >> A[i];\n  }\n\n  Matrix< int > mat(26, vector< int >(26, INF));\n  for(int i = 0; i < 26; i++) mat[i][i] = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(isupper(A[i][j])) {\n        for(int k = 0; k < 4; k++) {\n          int ny = i + vy[k], nx = j + vx[k];\n\n          while(0 <= ny && ny < H && 0 <= nx && nx < W) {\n            if(isupper(A[ny][nx])) {\n              mat[A[i][j] - 'A'][A[ny][nx] - 'A'] = 1;\n              break;\n            } else if(A[ny][nx] == '.') {\n              break;\n            }\n            ny += vy[k];\n            nx += vx[k];\n          }\n\n        }\n      }\n    }\n  }\n  warshall_floyd(mat);\n  cout << mat[S - 'A'][T - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\trep(i,4){\n\t\tint yy = y+dy[i],xx = x+dx[i];\n\t\tif(a[y][x] == 'o' && !dy[i] && a[yy][xx] == '|')continue;\n\t\tif(a[y][x] == 'o' && !dx[i] && a[yy][xx] == '-')continue;\n\t\tif(a[y][x] == '|' && !dy[i])continue;\n\t\tif(a[y][x] == '-' && !dx[i])continue;\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\tint yy = y+i, xx = x+j;\n\t\t\t\t//a[yy][xx] = a[y][x];\n\t\t\t\tused[yy][xx] = 1;\n\t\t\t\tif(i*j == -1 || i*j == 1)a[yy][xx] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\trrep(i,h)rrep(j,w){\n\t\tfill((int*)used, (int*)(used+100), 0);\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\t/*int x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t}*/\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x <= b)\n\nint main(){\n    char a, b;\n    int h, w, s, t;\n    cin >> h >> w >> a >> b;\n    s = a - 'A', t = b - 'A';\n\n    char mat[h][w];\n    for(int i = 0; i < h*w; i++)    cin >> mat[i/w][i%w];\n\n    vector<int> v[26];\n    for(int i = 1; i < h-1; i++){\n        for(int j = 1; j < w-1; j++){\n            if(!inRange(mat[i][j], 'A', 'Z'))   continue;\n            int from = mat[i][j]-'A';\n            if(i+2 < h && mat[i+2][j] == '|'){\n                int ni = i+2;\n                while(mat[ni][j]=='|')  ni++;\n                ni++;\n                int to = mat[ni][j]-'A';\n                v[from].push_back(to);\n                v[to].push_back(from);\n            }\n            if(j+2 < w && mat[i][j+2] == '-'){\n                int nj = j+2;\n                while(mat[i][nj]=='-')  nj++;\n                nj++;\n                int to = mat[i][nj]-'A';\n                v[from].push_back(to);\n                v[to].push_back(from);\n            }\n        }\n    }\n    const int INF = 1<<29;\n    vector<int> dp(26, INF);\n    queue<int> q;\n    q.push(s);\n    dp[s] = 0;\n    while(!q.empty()){\n        int x = q.front();  q.pop();\n        for(int next : v[x]){\n            if(dp[next] == INF){\n                dp[next] = dp[x]+1;\n                q.push(next);\n            }\n        }\n    }\n    cout << dp[t] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[30];\nchar s,t,a[50][50];\n\nint main(){\n  int h,w;\n  cin>>h>>w>>s>>t;  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>a[i][j];\n    }\n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if('A'>=a[i][j]||a[i][j]>='Z')continue;\n      \n      int dx[4]={0,1,0,-1};\n      int dy[4]={1,0,-1,0};\n      for(int k=0;k<4;k++){\n\tint tx=i+dx[k],ty=j+dy[k];\n\twhile(1){\n\t  if(tx<0||h<=tx||ty<0||w<=ty)break;\n\t  if(a[tx][ty]=='.')break;\n\t  if(k%2&&a[tx][ty]=='-')break;\n\t  if(k%2==0&&a[tx][ty]=='|')break;\n\t  if('A'<=a[tx][ty]&&a[tx][ty]<='Z'){\n\t    g[a[i][j]-'A'].push_back(a[tx][ty]-'A');\n\t    g[a[tx][ty]-'A'].push_back(a[i][j]-'A');\n\t    break;\n\t  }\n\t  tx+=dx[k],ty+=dy[k];\n\t}\n      }\n    }\n  }\n\n  queue<pair<int,int> >q;\n  q.push(make_pair(s-'A',0));\n  int used[30]={};\n\n  while(q.size()){\n    int node=q.front().first;\n    int l=q.front().second;\n    q.pop();\n    //  cout<<node<<endl;\n    if(node==t-'A'){\n      cout<<l<<endl;\n      return 0;\n    }\n    if(used[node])continue;\n    used[node]=1;\n    for(int i=0;i<g[node].size();i++){\n      \n      q.push(make_pair(g[node][i],l+1));\n    }\n  }\n  /*\n  for(int i=0;i<30;i++){\n    cout<<(char)('A'+i)<<\" \";\n    for(int j=0;j<g[i].size();j++){\n      cout<<g[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  int ss = s-'A', tt = t-'A';\n  queue<int>  que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = pos[u].first+dy[i], nx = pos[u].second+dx[i];\n      ny += dy[i];\n      nx += dx[i];\n      int cnt = 0;\n      while(in(ny, nx) && (mas[ny][nx] == '|' || mas[ny][nx] == '-')) {\n\tny += dy[i];\n\tnx += dx[i];\n\t++cnt;\n      }\n      if(cnt == 0) continue;\n      ny += dy[i];\n      nx += dx[i];\n      if(!in(ny, nx) || !isalpha(mas[ny][nx])) continue;\n      int v = mas[ny][nx]-'A';\n      if(dist[v] != -1) continue;\n      dist[v] = dist[u]+1;\n      que.push(v);\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint h, w;\nchar s, t;\nchar a[55][55];\n\nstruct edge{int to, cost;};\nvector<vector<edge>> g(100);\n\nvector<ll> dijkstra(int s, int n, vector<vector<edge>>& g){\n    priority_queue<plli, vector<plli>, greater<plli>> pque;\n    vector<ll> d(n, INFLL);\n    d[s] = 0;\n    pque.push(plli(0, s));\n\n    while (!pque.empty()){\n        plli p = pque.top(); pque.pop();\n        int fr = p.second;\n        if (d[fr] < p.first) continue;\n        for (edge e: g[fr]){\n            if (d[e.to] > d[fr] + e.cost){\n                d[e.to] = d[fr] + e.cost;\n                pque.push(plli(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nbool al(int i, int j) {\n  return (a[i][j] != 'o' && a[i][j] != '.' && a[i][j] != '|' && a[i][j] != '-');\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w >> s >> t;\n    rep(i, h)rep(j, w) cin >> a[i][j];\n    rep(i, h)rep(j, w) {\n      if (al(i, j)) {\n        rep2(k, i + 3, h) {\n          if (a[k][j] == '.') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        rep2(k, j + 3, w) {\n          if (a[i][k] == '.') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = i - 3; k >= 0; k--) {\n          if (a[k][j] == '.') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = j - 3; k >= 0; k--) {\n          if (a[i][k] == '.') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n      }\n    }\n    vector<ll> dist = dijkstra(s - 'A', 100, g);\n    cout << dist[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  char s,t;\n  cin>>h>>w>>s>>t;\n  rep(i,h){\n    cin>>brd[i];\n  }\n  deque<pii> que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push_back(pii(sx,sy));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  dis[sx][sy]=0;\n  int dx[4]={1,0,-1,0};\n  int dy[4]={0,1,0,-1};\n  while(!que.empty()){\n    pii t=que.front();que.pop_front();\n    rep(dir,4){\n      int nx=t.first+dx[dir],ny=t.second+dy[dir];\n      if(nx<0||nx>=h||ny<0||ny>=w)continue;\n      if(dis[nx][ny]<inf)continue;\n      if(brd[nx][ny]=='.')continue;\n      int cos=(brd[nx][ny]=='o'?1:0);\n      dis[nx][ny]=dis[t.first][t.second]+cos;\n      if(cos==1)\n\tque.push_back(pii(nx,ny));\n      else\n\tque.push_front(pii(nx,ny));\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]/2<<endl;\n    }\n  }\n  if(0){\n    rep(i,h)rep(j,w){\n      if(brd[i][j]>='A'&&brd[i][j]<='Z'){\n\tcerr<<brd[i][j]<<\" \"<<dis[i][j]<<endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n\nconst int32_t inf = 1001001001;\nconst int64_t infll = 1001001001001001001ll;\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\ntemplate <typename T> using vector2d = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T> void sort(vector<T> &v) { sort(all(v)); }\n// ostream &operator<<(ostream &os, __int128_t value) { if (ostream::sentry(os)) { __uint128_t tmp = value < 0 ? -value : value; char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[tmp % 10]; tmp /= 10; } while (tmp != 0); if (value < 0) { --d; *d = '-'; } int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __int128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } if (in[0] == '-') value *= -1; return is; }\n// ostream &operator<<(ostream &os, __uint128_t value) { if (ostream::sentry(os)) { char buffer[64]; char *d = end(buffer); do { --d; *d = \"0123456789\"[value % 10]; value /= 10; } while (value != 0); int len = end(buffer) - d; if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }} return os; }\n// istream &operator>>(istream &is, __uint128_t &value) { string in; is >> in; value = 0; for (const char &c : in) { if ('0' <= c && c <= '9') value = 10 * value + (c - '0'); } return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ninline int64_t in() { int64_t x = 0; cin >> x; return x; }\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nstruct Dijkstra {\n  Dijkstra(int V) : V(V), G(V) {}\n  struct edge {\n    edge(int to, long long cost) : to(to), cost(cost) {}\n    int to;\n    long long cost;\n  };\n\n  using P = pair<long long, int>;\n  const long long inf = 1001001001001001001ll;\n\n  int V;\n  vector<vector<edge>> G;\n  vector<long long> d;\n\n  void init(int n) {\n    V = n;\n    G.resize(n);\n  }\n\n  void debug() {\n    cerr << \"edges : \" << endl;\n    for (int i = 0; i < V; ++i)\n      for (auto e : G[i]) cerr << i << \" -> \" << e.to << \" : \" << e.cost << endl;\n    cerr << endl << \"dist : \" << endl;\n    for (int i = 0; i < V; ++i) cerr << i << \" : \" << d[i] << endl;\n  }\n\n  void add_edge(int u, int v, long long c) {\n    // cerr << char(u + 'A') << \" -> \" << char(v + 'A') << endl;\n    G[u].push_back(edge(v, c));\n  }\n\n  void build(int s) {\n    d.assign(V, inf);\n    priority_queue<P, vector<P>, greater<P>> q;\n\n    d[s] = 0;\n    q.push(P(0ll, s));\n\n    while (!q.empty()) {\n      P p = q.top();\n      q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto &e : G[v])\n        if (d[e.to] > p.first + e.cost) {\n          d[e.to] = p.first + e.cost;\n          q.push(P(d[e.to], e.to));\n        }\n    }\n  }\n\n  long long operator[](int v) {\n    return d[v];\n  }\n};\n\nDijkstra G(256);\nint h, w;\nchar a[256][256];\n\nvoid add_edge(int y, int x, int v) {\n  for (int i = y - 2; i > 1; --i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i - 1][x] - 'A', 1);\n    break;\n  }\n  for (int i = y + 2; i <= h; ++i) {\n    if (a[i][x] == '.') break;\n    if (a[i][x] == '|') continue;\n\n    G.add_edge(v, a[i + 1][x] - 'A', 1);\n    break;\n  }\n  for (int j = x - 2; j > 1; --j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j - 1] - 'A', 1);\n    break;\n  }\n  for (int j = x + 2; j <= w; ++j) {\n    if (a[y][j] == '.') break;\n    if (a[y][j] == '-') continue;\n\n    G.add_edge(v, a[y][j + 1] - 'A', 1);\n    break;\n  }\n}\n\nsigned main(int argc, char *argv[]) {\n  char s, t;\n\n  cin >> h >> w >> s >> t;\n\n  if (h > 50 || w > 50)\n    for (;;) {\n    }\n\n  for (int i = 0; i < 60; ++i) {\n    for (int j = 0; j < 60; ++j) {\n      a[i][j] = '.';\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      cin >> a[i][j];\n    }\n  }\n\n  for (int i = 1; i <= h; ++i) {\n    for (int j = 1; j <= w; ++j) {\n      if ('A' <= a[i][j] && a[i][j] <= 'Z') {\n        // cerr << a[i][j] << endl;\n        add_edge(i, j, a[i][j] - 'A');\n      }\n    }\n  }\n\n  G.build(s - 'A');\n  cout << G[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\trep(i,4){\n\t\tint yy = y+dy[i],xx = x+dx[i];\n\t\tif(a[y][x] == 'o' && !dy[i] && a[yy][xx] == '|')continue;\n\t\tif(a[y][x] == 'o' && !dx[i] && a[yy][xx] == '-')continue;\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\tint yy = y+i, xx = x+j;\n\t\t\t\t//a[yy][xx] = a[y][x];\n\t\t\t\tused[yy][xx] = 1;\n\t\t\t\tif(i*j == -1 || i*j == 1)a[yy][xx] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill((int*)used, (int*)(used+100), 0);\n\trrep(i,h)rrep(j,w){\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\t/*int x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t}*/\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\nstring s[100];\nvector<int> G[30];\nsigned main(){\nint h,w;\n\tcin>>h>>w;\n\tchar c1,c2;\n\tcin>>c1>>c2;\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\t\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(s[i][j]>='A' && s[i][j]<='Z'){\n\n\t\t\n\t\tfor(int r=0;r<4;r++){\n\t\t\t\tint x=i,y=j;\n\t\tx+=dx[r];\n\t\t\ty+=dy[r];\n\t\t\t\n\t\t\tif(x<0 || x>=h || y<0 ||y >=w)continue;\n\t\t\t\n\t\t\twhile(s[x][y]!='.'){\n\t\t\t\tif(s[x][y]>='A' && s[x][y]<='Z'){\n\t\t\t\t\tG[s[i][j]-'A'].pb(s[x][y]-'A');\n\t\t\t//\t\tcout<<s[i][j]<<\" \"<<s[x][y]<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx+=dx[r],y+=dy[r];\n\t\t\t\tif(x<0 || x>=h || y<0 ||y >=w)goto lll;\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tlll:;\n\t\t}\n\t\n\t\n\t}\n\t\n\t\n\tint s=c1-'A';\n\tint t=c2-'A';\n\t\n\tqueue<pa> qu;\n\tint sumi[30]={0};\n\tqu.push(mp(s,0));\n\t\n\twhile(1){\n\t\tpa z=qu.front();\n\t\tqu.pop();\n\t\tif(sumi[z.first]) continue;\n\t\tsumi[z.first]=1;\n\t\tif(z.first==t) {\n\t\t\tcout<<z.second<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(auto v:G[z.first]){\n\t\t\tqu.push(mp(v,z.second+1));\n\t\t}\n\t\n\t}\n\t\n return 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(iinclude<snt i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\ntypedef pair<int, P> speP;\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint h, w;\nchar mp[50][50];\nint d[50][50];\nvoid solve() {\n\tcin >> h >> w;\n\tchar a, b; cin >> a >> b;\n\trep(i, h)rep(j, w) {\n\t\tcin >> mp[i][j];\n\t\td[i][j] = mod;\n\t}\n\tpriority_queue<speP, vector<speP>, greater<speP>> q;\n\trep(i, h)rep(j, w)if (mp[i][j] == a) {\n\t\tq.push({ 0,{i,j} });\n\t\td[i][j] = 0;\n\t}\n\twhile (!q.empty()) {\n\t\tspeP p = q.top(); q.pop();\n\t\tint x = p.second.first, y = p.second.second;\n\t\trep(j, 4) {\n\t\t\tint nx = x + dx[j];\n\t\t\tint ny = y + dy[j];\n\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\tif (mp[nx][ny] == '.')continue;\n\t\t\tint cost = 0;\n\t\t\tif (mp[x][y] == '|'&&mp[nx][ny]=='o') {\n\t\t\t\tif (j % 2 == 0)cost = 1;\n\t\t\t\telse cost = mod;\n\t\t\t}\n\t\t\telse if (mp[x][y] == '-'&&mp[nx][ny] == 'o') {\n\t\t\t\tif (j % 2)cost = 1;\n\t\t\t\telse cost = mod;\n\t\t\t}\n\t\t\telse if (mp[x][y] == 'o'&&mp[nx][ny] == '|'&&j%2) {\n\t\t\t\tcost = mod;\n\t\t\t}\n\t\t\telse if (mp[x][y] == 'o'&&mp[nx][ny] == '-'&&j%2==0) {\n\t\t\t\tcost = mod;\n\t\t\t}\n\t\t\tif (d[nx][ny] > cost + d[x][y]) {\n\t\t\t\td[nx][ny] = cost + d[x][y];\n\t\t\t\tq.push({ d[nx][ny],{nx,ny} });\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h)rep(j, w)if (mp[i][j] == b)cout << d[i][j] << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing u64 = uint64_t;\nconstexpr const u64 INF = UINT64_MAX / 2;\n\nbool inbound(int H, int W, int h, int w) {\n    return (0 <= h && h < H) && (0 <= w && w < W);\n}\n\nvector<vector<u64>> parse(int H, int W, vector<vector<char>> &aa) {\n    int h, w;\n    for (h = 0; h < H; h++) {\n        for (w = 0; w < W; w++) {\n            if (isupper(aa[h][w])) goto loopend;\n        }\n    }\nloopend:\n    vector<vector<u64>> graph(26, vector<u64>(26, INF));\n    queue<pair<int, int>> q; // <h, w>\n    q.push({h, w});\n    while (!q.empty()) {\n        auto c = q.front();\n        if (aa[c.first][c.second] == 0) continue;\n        auto cv = aa[c.first][c.second] - 'A';\n        q.pop();\n        int adh[] = { -2, 0, 2, 0 };\n        int adw[] = { 0, -2, 0, 2 };\n        for (int i = 0; i < 4; i++) {\n            int dh = adh[i], dw = adw[i];\n            int h = c.first + dh, w = c.second + dw;\n            if (inbound(H, W, h, w) && (aa[h][w] == '|' || aa[h][w] == '-')) {\n                dh /= 2; dw /= 2;\n                char ch;\n                while (!isupper((ch = aa[h][w]))) {\n                    h += dh, w += dw;\n                }\n                int tv = ch - 'A';\n                if (graph[cv][tv] == INF) {\n                    graph[cv][tv] = graph[tv][cv] = 1;\n                    q.push({h, w});\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nvoid warshall_floyd(vector<vector<u64>> &graph) {\n    int N = graph.size();\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    char S, T;\n    cin >> S >> T;\n    S -= 'A'; T -= 'A';\n\n    vector<vector<char>> aa(H, vector<char>(W));\n\n    for (int h = 0; h < H; h++) {\n        string line;\n        getline(cin, line);\n        for (int w = 0; w < W; w++) {\n            aa[h][w] = line[w];\n        }\n    }\n\n    auto graph = parse(H, W, aa);\n    warshall_floyd(graph);\n    cout << graph[S][T] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nconst int INF = 1 << 29;\nconst int vy[] = {1, 0, -1, 0};\nconst int vx[] = {0, -1, 0, 1};\nconst string vt = \"|-|-\";\n\ntemplate< typename T = int >\nvoid warshall_floyd(Matrix< T > &g) {\n  for(int k = 0; k < g.size(); k++) {\n    for(int i = 0; i < g.size(); i++) {\n      for(int j = 0; j < g.size(); j++) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int H, W;\n  char S, T;\n  string A[50];\n  cin >> H >> W >> S >> T;\n  for(int i = 0; i < H; i++) {\n    cin >> A[i];\n  }\n\n  Matrix< int > mat(26, vector< int >(26, INF));\n  for(int i = 0; i < 26; i++) mat[i][i] = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(isupper(A[i][j])) {\n        for(int k = 0; k < 4; k++) {\n          int ny = i + vy[k], nx = j + vx[k];\n          while(0 <= ny && ny < H && 0 <= nx && nx < W) {\n            if(isupper(A[ny][nx])) {\n              mat[A[i][j] - 'A'][A[ny][nx] - 'A'] = 1;\n              break;\n            } else if(A[ny][nx] == '.') {\n              break;\n            } else if(vt.find(A[ny][nx]) != string::npos && A[ny][nx] != vt[k]) {\n              break;\n            }\n            ny += vy[k];\n            nx += vx[k];\n          }\n\n        }\n      }\n    }\n  }\n  warshall_floyd(mat);\n  cout << mat[S - 'A'][T - 'A'] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 100\n#define NUM 30\n\nint H, W;\nchar S, T;\nstring filed[MAX];\nvector<int> G[NUM];\n\n\nvoid check(int y, int x){\n\tint num = filed[y][x] - 'A';\n\t\n\tif(y-2 >= 0 && filed[y-2][x] == '|'){\n\t\tfor(int i = y-2; i >= 0; i--){\n\t\t\tif('A' <= filed[i][x] && filed[i][x] <= 'Z'){\n\t\t\t\tG[num].push_back(filed[i][x]-'A');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(y+2 < H && filed[y+2][x] == '|'){\n\t\tfor(int i = y+2; i < H; i++){\n\t\t\tif('A' <= filed[i][x] && filed[i][x] <= 'Z'){\n\t\t\t\tG[num].push_back(filed[i][x]-'A');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(x-2 >= 0 && filed[y][x-2] == '-'){\n\t\tfor(int i = x-2; i >= 0; i--){\n\t\t\tif('A' <= filed[y][i] && filed[y][i] <= 'Z'){\n\t\t\t\tG[num].push_back(filed[y][i]-'A');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(x+2 < W && filed[y][x+2] == '-'){\n\t\tfor(int i = x+2; i < W; i++){\n\t\t\tif('A' <= filed[y][i] && filed[y][i] <= 'Z'){\n\t\t\t\tG[num].push_back(filed[y][i]-'A');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs(){\n\tqueue<pair<int,int>> Q;\n\tint used[NUM] = {};\n\t\n\tQ.push(make_pair(S-'A',0));\n\t\n\t// for(int i = 0; i < 26; i++){\n\t\t// if(G[i].size()){\n\t\t\t// cout<<(char)(i+'A')<<\" : \";\n\t\t\t// for(int j = 0; j < G[i].size(); j++){\n\t\t\t\t// cout<<\"  \"<<(char)(G[i][j]+'A');\n\t\t\t// }cout<<endl;\n\t\t// }\n\t// }\n\twhile(!Q.empty()){\n\t\tpair<int,int> num = Q.front();Q.pop();\n\t\t\n\t\tif(num.first == T-'A') return num.second;\n\t\t\n\t\tfor(int i = 0; i < G[num.first].size(); i++){\n\t\t\tif(used[G[num.first][i]]) continue;\n\t\t\tused[G[num.first][i]] = true;\n\t\t\tQ.push(make_pair(G[num.first][i],num.second+1));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\t\n\tcin>>H>>W>>S>>T;\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin>>filed[i];\n\t}\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif('A' <= filed[i][j] && filed[i][j] <= 'Z'){\n\t\t\t\tcheck(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<bfs()<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G){  \n  const T INF = numeric_limits<T>::max();    \n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n        d[u]=d[v]+c;\n        b[u]=v;\n        q.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  char s,t;\n  cin>>h>>w>>s>>t;\n  vector<string> st(h);\n  for(Int i=0;i<h;i++){\n    cin>>st[i];\n    st[i]='.'+st[i]+'.';\n  }\n  \n  st.emplace(st.begin(),string(w+2,'.'));\n  st.emplace_back(string(w+2,'.'));\n\n  h=st.size();w=st[0].size();\n    \n  using P = pair<Int, Int>;\n  \n  vector<vector<P> > G(26);\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  char dc[]={'-','-','|','|'};\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(!isupper(st[i][j])) continue;\n      //cout<<st[i][j]<<endl;\n      for(Int k=0;k<4;k++){\n        Int ni=i+dy[k]*2,nj=j+dx[k]*2;\n        if(st[ni][nj]=='.') continue;\n        if(st[ni][nj]=='o') continue;\n        if(st[ni][nj]!=dc[k]) continue;\n        while(!isupper(st[ni][nj])) ni+=dy[k],nj+=dx[k];\n        G[st[i][j]-'A'].emplace_back(st[ni][nj]-'A',1);\n\n        //cout<<st[i][j]<<\" \"<<st[ni][nj]<<endl;\n      }            \n    }        \n  }\n  \n  cout<<dijkstra(s-'A',G)[t-'A']<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <string>\n#include <cassert>\n#include <cstring>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing ll = long long;\n\nconst int vx[4] = { -1, 0, 1, 0 }, vy[4] = { 0, -1, 0, 1 };\n\nint main() {\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int H, W;\n  char s, t;\n  std::string aagraph[51];\n\n  cin >> H >> W >> s >> t;\n\n  for (int i = 0; i < H; ++i) {\n    cin >> aagraph[i];\n  }\n\n  int d[26][26];\n\n  std::memset(d, 0x3f, sizeof d);\n\n  for (int i = 0; i < 26; ++i) {\n    d[i][i] = 0;\n  }\n\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      if ('A' <= aagraph[i][j] && aagraph[i][j] <= 'Z') {\n\n        for (int k = 0; k < 4; ++k) {\n          int nx = i + vx[k] * 2, ny = j + vy[k] * 2;\n\n          if (0 <= nx && nx < H && 0 <= ny && ny < W) {\n            if (((k == 1 || k == 3) && aagraph[nx][ny] == '-') || ((k == 0 || k == 2) && aagraph[nx][ny] == '|')) {\n              //if (aagraph[nx][ny] == '-' || aagraph[nx][ny] == '|') {\n\n              while (aagraph[nx][ny] != 'o') {\n                nx += vx[k], ny += vy[k];\n              }\n              nx += vx[k], ny += vy[k];\n\n              assert('A' <= aagraph[nx][ny] && aagraph[nx][ny] <= 'Z');\n\n              int u = aagraph[i][j] - 'A', v = aagraph[nx][ny] - 'A';\n              d[u][v] = d[v][u] = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /*\n  for (int i = 0; i < 26; ++i) {\n    for (int j = 0; j < 26; ++j) {\n      cerr << d[i][j] << \" \"[j == 25];\n    }\n  }\n  //*/\n\n  for (int k = 0; k < 26; ++k) {\n    for (int i = 0; i < 26; ++i) {\n      for (int j = 0; j < 26; ++j) {\n        d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  int u = s - 'A', v = t - 'A';\n\n  cout << d[u][v] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing u64 = uint64_t;\nconstexpr const u64 INF = UINT64_MAX / 2;\n\nbool inbound(int H, int W, int h, int w) {\n    return (0 <= h && h < H) && (0 <= w && w < W);\n}\n\nvector<vector<u64>> parse(int H, int W, vector<vector<char>> &aa) {\n    int h, w;\n    for (h = 0; h < H; h++) {\n        for (w = 0; w < W; w++) {\n            if (isupper(aa[h][w])) goto loopend;\n        }\n    }\nloopend:\n    vector<vector<u64>> graph(26, vector<u64>(26, INF));\n    queue<pair<int, int>> q; // <h, w>\n    q.push({h, w});\n    while (!q.empty()) {\n        auto c = q.front();\n        if (aa[c.first][c.second] == 0) continue;\n        auto cv = aa[c.first][c.second] - 'A';\n        q.pop();\n        int adh[] = { -2, 0, 2, 0 };\n        int adw[] = { 0, -2, 0, 2 };\n        for (int i = 0; i < 4; i++) {\n            int dh = adh[i], dw = adw[i];\n            int h = c.first + dh, w = c.second + dw;\n            if (inbound(H, W, h, w) && (aa[h][w] == '|' || aa[h][w] == '-')) {\n                dh /= 2; dw /= 2;\n                char ch;\n                while (!isupper((ch = aa[h][w]))) {\n                    h += dh, w += dw;\n                }\n                int tv = ch - 'A';\n                if (graph[cv][tv] == INF) {\n                    graph[cv][tv] = graph[tv][cv] = 1;\n                    q.push({h, w});\n                }\n            }\n        }\n    }\n    return graph;\n}\n\nvoid warshall_floyd(vector<vector<u64>> &graph) {\n    int N = graph.size();\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    istringstream ss(line);\n    int H, W;\n    ss >> H >> W;\n    char S, T;\n    ss >> S >> T;\n    S -= 'A'; T -= 'A';\n\n    vector<vector<char>> aa(H, vector<char>(W));\n\n    for (int h = 0; h < H; h++) {\n        string line;\n        getline(cin, line);\n        for (int w = 0; w < W; w++) {\n            aa[h][w] = line[w];\n        }\n    }\n\n    auto graph = parse(H, W, aa);\n    warshall_floyd(graph);\n    cout << graph[S][T] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 52 * 52 + 1;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  rep(i, 4) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (xx<0||yy<0||xx>=W||yy>=H)continue;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        // cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '-') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        // cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        // cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '|') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        // cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      // assert(cost[y * W + x][yy * W + xx] == INF);\n      // assert(cost[yy * W + xx][y * W + x] == INF);\n      cost[y * W + x][yy * W + xx] = 0;\n      // cost[yy * W + xx][y * W + x] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        // cost[yy * W + xx][y * W + x] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        // assert(cost[y * W + x][yy * W + xx] == INF);\n        // assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        // cost[yy * W + xx][y * W + x] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  rep(i, H) rep(j, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(d[p.second] % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  rep(i,H) {\n    rep(j,W) cout<<d[i*W+j]<<' ';\n    cout<<endl;\n  }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nchar fld[55][55];\n\nvint G[26];\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n\nint dist[26];\nconst int INF=1001001001;\nsigned main(){\n    char a,b;\n    cin>>H>>W>>a>>b;\n\n\n    int s=a-'A';\n    int t=b-'A';\n\n    rep(i,H)cin>>fld[i];\n\n\n    rep(i,H)rep(j,W){\n        if(!isupper(fld[i][j]))continue;\n        rep(d,4){\n            int y=i,x=j;\n            while(true){\n                y+=dy[d];\n                x+=dx[d];\n                if(y<0||y>=H||x<0||x>=W)break;\n                if(fld[y][x]=='.')break;\n                if(isupper(fld[y][x])){\n                    G[fld[i][j]-'A'].pb(fld[y][x]-'A');\n                    break;\n                }\n            }\n        }\n    }\n\n\n    fill_n(dist,26,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(dist[u]!=INF)continue;\n            dist[u]=dist[v]+1;\n            que.push(u);\n        }\n    }\n    cout<<dist[t]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                assert(inrange(now.first, now.second));\n            }\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint h, w;\nchar s, t;\nchar a[55][55];\n\nstruct edge{int to, cost;};\nvector<vector<edge>> g(100);\n\nvector<ll> dijkstra(int s, int n){\n    priority_queue<plli, vector<plli>, greater<plli>> pque;\n    vector<ll> d(n, INFLL);\n    d[s] = 0;\n    pque.push(plli(0, s));\n\n    while (!pque.empty()){\n        plli p = pque.top(); pque.pop();\n        int fr = p.second;\n        if (d[fr] < p.first) continue;\n        for (edge e: g[fr]){\n            if (d[e.to] > d[fr] + e.cost){\n                d[e.to] = d[fr] + e.cost;\n                pque.push(plli(d[e.to], e.to));\n            }\n        }\n    }\n    return d;\n}\n\nbool al(int i, int j) {\n  return (a[i][j] != 'o' && a[i][j] != '.' && a[i][j] != '|' && a[i][j] != '-');\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w >> s >> t;\n    rep(i, h)rep(j, w) cin >> a[i][j];\n    rep(i, h)rep(j, w) {\n      if (al(i, j)) {\n        rep2(k, i + 2, h) {\n          if (a[k][j] == '.' || a[k][j] == '-') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        rep2(k, j + 2, w) {\n          if (a[i][k] == '.' || a[i][k] == '|') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = i - 2; k >= 0; k--) {\n          if (a[k][j] == '.' || a[k][j] == '-') break;\n          if (al(k, j)) {\n            g[a[i][j] - 'A'].push_back({a[k][j] - 'A', 1});\n            break;\n          }\n        }\n        for (int k = j - 2; k >= 0; k--) {\n          if (a[i][k] == '.' || a[i][k] == '|') break;\n          if (al(i, k)) {\n            g[a[i][j] - 'A'].push_back({a[i][k] - 'A', 1});\n            break;\n          }\n        }\n      }\n    }\n    vector<ll> dist = dijkstra(s - 'A', 100);\n    cout << dist[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W;\n  cin >> H >> W;\n  char S, T;\n  cin >> S >> T;\n  S -= 'A';\n  T -= 'A';\n  VS vs(H);\n  cin >> vs;\n\n  VVI G(26);\n  REP(y,H) REP(x,W){\n\tif('A' <= vs[y][x] && vs[y][x] <= 'Z'){\n\t  int s = vs[y][x] - 'A';\n\t  REP(d,4){\n\t\tint tx = x + dx[d]*2;\n\t\tint ty = y + dy[d]*2;\n\t\twhile(0 <= tx && tx < W && 0 <= ty && ty < H){\n\t\t  if(vs[ty][tx] == '-' || vs[ty][tx] == '|'){\n\t\t\ttx += dx[d];\n\t\t\tty += dy[d];\n\t\t  }\n\t\t  else if(vs[ty][tx] == 'o'){\n\t\t\ttx += dx[d];\n\t\t\tty += dy[d];\n\t\t\tint t = vs[ty][tx] - 'A';\n\t\t\tG[s].PB(t);\n\t\t\tbreak;\n\t\t  }\n\t\t  else\n\t\t\tbreak;\n\t\t}\n\t  }\n\t}\n  }\n\n  queue<int> q;\n  q.push(S);\n  VI dist(26, -1);\n  dist[S] = 0;\n  while(!q.empty()){\n\tint u = q.front();\n\tq.pop();\n\tfor(int to: G[u]){\n\t  if(dist[to] != -1) continue;\n\t  dist[to] = dist[u]+1;\n\t  q.push(to);\n\t}\n  }\n  cout << dist[T] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= int(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\n\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nconst char *type = \"||--\";\nvector<vector<int> > parse(int h, int w, vector<string> const & f) {\n    auto is_on_field = [&](int y, int x) { return 0 <= y and y < h and 0 <= x and x < w; };\n    vector<vector<int> > g(26);\n    REP (y, h) REP (x, w) if (isupper(f[y][x])) {\n        REP (i, 4) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            while (is_on_field(ny, nx) and (f[ny][nx] == 'o' or f[ny][nx] == type[i])) {\n                ny += dy[i];\n                nx += dx[i];\n            }\n            if (is_on_field(ny, nx) and isupper(f[ny][nx])) {\n                g[f[y][x] - 'A'].push_back(f[ny][nx] - 'A');\n            }\n        }\n    }\n    return g;\n}\n\nvector<int> breadth_first_search(int root, vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> dist(n, INT_MAX);\n    queue<int> que;\n    dist[root] = 0;\n    que.push(root);\n    while (not que.empty()) {\n        int i = que.front(); que.pop();\n        for (int j : g[i]) if (dist[j] == INT_MAX) {\n            dist[j] = dist[i] + 1;\n            que.push(j);\n        }\n    }\n    return dist;\n}\n\nint main() {\n    // input\n    int h, w; cin >> h >> w;\n    char start, goal; cin >> start >> goal;\n    vector<string> f(h);\n    REP (y, h) cin >> f[y];\n\n    // solve\n    vector<vector<int> > g = parse(h, w, f);\n    vector<int> dist = breadth_first_search(start - 'A', g);\n    int result = dist[goal - 'A'];\n\n    // output\n    cout << result << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int64_t\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\nnamespace io {\n#ifdef LOCAL\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        io::print_to(os, \", \", \"\\n\", __VA_ARGS__);        \\\n        std::cerr << io::highlight(os.str());             \\\n    } while (0)\n#define dump_(cntnr)                                 \\\n    do {                                             \\\n        std::ostringstream os;                       \\\n        os << __LINE__ << \":\\t\" << #cntnr << \" = [\"; \\\n        io::print_to_(os, \", \", \"]\\n\", all(cntnr));  \\\n        std::cerr << io::highlight(os.str());        \\\n    } while (0)\n#define dumpf(fmt, ...)                             \\\n    do {                                            \\\n        const int N = 4096;                         \\\n        auto b = new char[N];                       \\\n        int l = snprintf(b, N, \"%d:\\t\", __LINE__);  \\\n        snprintf(b + l, N - l, fmt, ##__VA_ARGS__); \\\n        std::cerr << io::highlight(b) << std::endl; \\\n        delete[] b;                                 \\\n    } while (0)\n#else\n#define dump(...)\n#define dump_(...)\n#define dumpf(...)\n#endif\nstd::string highlight(std::string s) {\n#ifdef _MSC_VER\n    return s;\n#else\n    return \"\\033[33m\" + s + \"\\033[0m\";\n#endif\n}\ntemplate <typename T>\nvoid print_to(std::ostream &os, std::string, std::string tail, const T &first) {\n    os << first << tail;\n}\ntemplate <typename F, typename... R>\nvoid print_to(std::ostream &os, std::string del, std::string tail, const F &first,\n              const R &... rest) {\n    os << first << del;\n    print_to(os, del, tail, rest...);\n}\ntemplate <typename I>\nvoid print_to_(std::ostream &os, std::string del, std::string tail, I begin, I end) {\n    for (I it = begin; it != end;) {\n        os << *it;\n        os << (++it != end ? del : tail);\n    }\n}\ntemplate <typename F, typename... R>\nvoid println(const F &first, const R &... rest) {\n    print_to(std::cout, \"\\n\", \"\\n\", first, rest...);\n}\ntemplate <typename F, typename... R>\nvoid print(const F &first, const R &... rest) {\n    print_to(std::cout, \" \", \"\\n\", first, rest...);\n}\ntemplate <typename I>\nvoid println_(I begin, I end) {\n    print_to_(std::cout, \"\\n\", \"\\n\", begin, end);\n}\ntemplate <typename I>\nvoid print_(I begin, I end) {\n    print_to_(std::cout, \" \", \"\\n\", begin, end);\n}\ntemplate <typename C>\nvoid println_(const C &cntnr) {\n    println_(std::begin(cntnr), std::end(cntnr));\n}\ntemplate <typename C>\nvoid print_(const C &cntnr) {\n    print_(std::begin(cntnr), std::end(cntnr));\n}\nint _ = (\n#ifndef LOCAL\n    std::cin.tie(nullptr), std::ios::sync_with_stdio(false),\n#endif\n    std::cout.precision(10), std::cout.setf(std::ios::fixed));\n}\nusing io::print;\nusing io::println;\nusing io::println_;\nusing io::print_;\ntemplate <typename T>\nusing vec = std::vector<T>;\nusing vi = vec<int>;\nusing vvi = vec<vi>;\nusing pii = std::pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n// const int MOD = 1000000007;\n\nconst int WW = 100000;\n\nint grid_bfs(const vector<string> &g, char S, char T) {\n    const int INF = 1e18;\n    using pii = pair<int, int>;\n\n    int h = g.size(), w = g[0].size();\n    static const auto is_valid = [&](int i, int j) {\n        if (i < 0 || i >= h || j < 0 || j >= w) return false;\n        if (g[i][j] == '.') return false;\n        return true;\n    };\n\n    static const pii dir[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    priority_queue<pair<int, pii>> q;\n    vector<vector<int>> d(h, vector<int>(w, INF));\n\n    rep(i, h) rep(j, w) {\n        if (g[i][j] == S) {\n            dump(S, g[i][j], i, j);\n            d[i][j] = 0;\n            q.emplace(0, pii(i, j));\n        }\n    }\n\n    while (q.size()) {\n        int ci, cj;\n        auto top = q.top();\n        int cd = -top.first;\n        tie(ci, cj) = top.second;\n        q.pop();\n\n        if (d[ci][cj] > cd) continue;\n        if (g[ci][cj] == T) {\n            return cd;\n        }\n\n        for (auto &v : dir) {\n            int ni = ci + v.first;\n            int nj = cj + v.second;\n            if (is_valid(ni, nj)) {\n                char cell = g[ni][nj];\n                int cost;\n                if (cell == 'o') {\n                    cost = WW;\n                } else if ('A' <= cell && cell <= 'Z') {\n                    cost = 1;\n                } else {\n                    cost = 0;\n                }\n                int nd = d[ci][cj] + cost;\n                if (d[ni][nj] > nd) {\n                    d[ni][nj] = nd;\n                    q.emplace(-nd, pii(ni, nj));\n                }\n            }\n        }\n    }\n\n    // dump(\"ha?\");\n    abort();\n}\n\nsigned main() {\n    int h, w;\n    vec<string> g;\n\n    while (cin >> h >> w) {\n        char s, t;\n        cin >> s >> t;\n        g.resize(h);\n        rep(i, h) {\n            cin >> g[i];\n        }\n        int ans = grid_bfs(g, s, t);\n        print(ans % WW);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nchar fld[55][55];\n\nvint G[26];\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n\nint dist[26];\nconst int INF=1001001001;\nsigned main(){\n    char a,b;\n    cin>>H>>W>>a>>b;\n\n\n    int s=a-'A';\n    int t=b-'A';\n\n    rep(i,H)cin>>fld[i];\n\n\n    rep(i,H)rep(j,W){\n        if(!isupper(fld[i][j]))continue;\n        rep(d,4){\n            int y=i,x=j;\n            while(true){\n                y+=dy[d];\n                x+=dx[d];\n                if(y<0||y>=H||x<0||x>=W)break;\n                if(fld[y][x]=='.')break;\n                if(isupper(fld[y][x])){\n                    G[fld[i][j]-'A'].pb(fld[y][x]-'A');\n                    break;\n                }\n                if(d%2&&fld[y][x]=='|')break;\n                if(d%2==0&&fld[y][x]=='-')break;\n            }\n        }\n    }\n\n\n    fill_n(dist,26,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(dist[u]!=INF)continue;\n            dist[u]=dist[v]+1;\n            que.push(u);\n        }\n    }\n    cout<<dist[t]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\n\nint dy[12] = {-1,0,1,2,2,2,1,0,-1,-2,-2,-2};\nint dx[12] = {2,2,2,1,0,-1,-2,-2,-2,-1,0,1};\nint dir[12] = {0,0,0,1,1,1,2,2,2,3,3,3};\nint diry[4] = {0,1,0,-1};\nint dirx[4] = {1,0,-1,0};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll H,W; cin >> H >> W;\n    char cs,ct; cin >> cs >> ct;\n    ll s,t; s = (cs - 'A'); t = (ct - 'A');\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'#'));\n    map<char,pii> mp;\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] >= 'A' && masu[i][j] <= 'Z'){\n                mp[masu[i][j]] = {i,j};\n            }\n        }\n    }\n    \n    for(auto m:mp){\n        auto p = m.second;\n        for(int i = -1;i <= 1; i++){\n            for(int j = -1; j <= 1;j++){\n                masu[p.first+i][p.second+j] = masu[p.first][p.second];\n            }\n        }\n    }\n    \n    //    cout << masu << endl;\n    \n    vector<vector<int>> G(26);\n    for(auto m:mp){\n        auto p = m.second;\n        int u = masu[p.first][p.second] - 'A';\n        for(int i = 0; i < 12;i++){\n            char masu_c = masu[p.first+dy[i]][p.second+dx[i]];\n            if(masu_c == '|' || masu_c == '-'){\n                int ny = p.first+dy[i],nx = p.second+dx[i];\n                while(true){\n                    if(ny > H || ny < 1 || nx > W || nx < 1) break;\n                    if(masu[ny][nx] == '#') break;\n                    if(masu[ny][nx] == '-' || masu[ny][nx] == '|'){\n                        ny += diry[dir[i]]; nx += dirx[dir[i]];\n                        continue;\n                    }\n                    if(masu[ny][nx] >= 'A' && masu[ny][nx] <= 'Z'){\n                        int v = masu[ny][nx] - 'A';\n                        G[u].push_back(v);\n                        G[v].push_back(u);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    vector<ll> dist(30,INF);\n    dist[s] = 0;\n    queue<ll> q; q.push(s);\n    while(q.size()){\n        ll n = q.front(); q.pop();\n        for(auto next:G[n]){\n            if(dist[next] > dist[n] + 1){\n                dist[next] = dist[n] + 1;\n                q.push(next);\n            }\n        }\n    }\n//    cout << dist << endl;\n    cout << dist[t] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define REP(i, a, b) for (int i = (a); i < int(b); i++)\n#define all(x) (x).begin(), x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\n/*---------------------------------------------------*/\n\n/*\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n*/\n\nconst int MAX_V = 52 * 52 + 1;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[2] = {-1, 0};\n  int dy[2] = {0, -1};\n  rep(i, 2) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '-') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      } else if (graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      }\n    } else if ('A' <= graph[y][x] && graph[y][x] <= 'Z') {\n      assert(cost[y * W + x][yy * W + xx] == INF);\n      assert(cost[yy * W + xx][y * W + x] == INF);\n      cost[y * W + x][yy * W + xx] = 0;\n      cost[yy * W + xx][y * W + x] = 0;\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o' || ('A' <= graph[yy][xx] && graph[yy][xx] <= 'Z')) {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 0;\n        cost[yy * W + xx][y * W + x] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        assert(cost[y * W + x][yy * W + xx] == INF);\n        assert(cost[yy * W + xx][y * W + x] == INF);\n        cost[y * W + x][yy * W + xx] = 1;\n        cost[yy * W + xx][y * W + x] = 1;\n      }\n    }\n  }\n}\n\nint main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  // map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      // if (isupper(graph[i][j])) m[graph[i][j]] = i * W + j;\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  REP(i, 1, H) REP(j, 1, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  // for (auto &p : m) cout << p.first << ' ' << d[p.second] / 2 << endl;\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[26];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nbool f[51][51];\nvoid dfs(int y, int x, int now){\n    if(!contain(y, x)) return;\n    if(f[y][x]) return;\n    f[y][x] = true;\n    if(c[y][x] == 'o'){\n        rep(i, 0, 4){\n            int ty = y + dy[i];\n            int tx = x + dx[i];\n            if(!contain(ty, tx)) continue;\n            if('A' <= c[ty][tx] && c[ty][tx] <= 'Z'){\n                G[now].push_back(c[ty][tx] - 'A');\n                // cout << (char)('A' + now) << \" \" << c[ty][tx] << endl;\n            }\n        }\n        return;\n    }\n    if(c[y][x] == '-'){\n        dfs(y, x - 1, now);\n        dfs(y, x + 1, now);\n    }\n    if(c[y][x] == '|'){\n        dfs(y - 1, x, now);\n        dfs(y + 1, x, now);\n    }\n    return;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 26) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            rep(k, 0, 51) rep(l, 0, 51) f[k][l] = false;\n            // cout << i << ' ' << j << endl;\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            // bool f[51][51] = {};\n            if(!contain(y, x)) continue;\n            f[idx[i].first][idx[i].second] = true;\n            f[idx[i].first + dy[j]][idx[i].second + dx[j]] = true;\n            // f[y][x] = true;\n            dfs(y, x, i);\n            // if(c[y][x] == '.') continue;\n            // while(1){\n            //     int ny = -1, nx = -1;\n            //     // cout << i << ' ' << j << ' ' << y << ' ' << x << ' ' << c[y][x] << endl;\n            //     rep(k, 0, 4){\n            //         if(c[y][x] == '|'){\n            //             if(k == 2 || k == 3) continue;\n            //         }\n            //         if(c[y][x] == '-'){\n            //             if(k == 0 || k == 1) continue;\n            //         }\n            //         ny = y + dy[k];\n            //         nx = x + dx[k];\n            //         if(!contain(ny, nx)) continue;\n            //         if(f[ny][nx]) continue;\n                    \n            //         if(c[ny][nx] == '-'){\n            //             break;\n            //         }\n            //         if(c[ny][nx] == '|'){\n            //             break;\n            //         }\n            //         if(c[ny][nx] == 'o'){\n            //             ny += dy[k];\n            //             nx += dx[k];\n            //             break;\n            //         }\n            //     }\n            //     y = ny;\n            //     x = nx;\n            //     f[y][x] = true;\n            //     if('A' <= c[y][x] && c[y][x] <= 'Z'){\n            //         G[i].push_back(c[y][x] - 'A');\n            //         // cout << (char)('A' + i) << ' ' << c[y][x] << endl;\n            //         break;\n            //     }\n            // }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n/*\n7 7 A D\nooo.ooo\noAo-oBo\nooo.ooo\n.|..|.\n.|..ooo\n.---oDo\n....ooo\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n)repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define fi first\n#define se second\nconst int inf = 1e9;\nint mod = 1e9+7;\n\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nchar str[100][100], a[100][100], used[100][100];\n\nclass Dijkstra{\npublic:\n\tvector<vector<P> > G;\n\tvector<int> d;\n\t\n\tvoid init(int n){\n\t\td.resize(n);\n\t\tG.resize(n);\n\t}\n\tvoid add_edge(int s, int t, int cost){\n\t\tG[s].push_back(P(t, cost));\n\t}\n\t\n\tvoid dijkstra(int s){\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(d.begin(), d.end(), inf);\n\t\td[s] = 0;\n\t\tq.push(P(0, s));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tP p = q.top();q.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[p.second] < p.first)continue;\n\t\t\t\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tint to = G[v][i].first;\n\t\t\t\tint cost = G[v][i].second;\n\t\t\t\t\n\t\t\t\tif(d[to] > d[v]+cost){\n\t\t\t\t\td[to] = d[v]+cost;\n\t\t\t\t\tq.push(P(d[to], to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nDijkstra d;\nvoid dfs(int y, int x, char c){\n\tif(a[y][x] == '#' || a[y][x] == '.')return ;\n\tif(c != a[y][x] && 'A' <= a[y][x] && a[y][x] <= 'Z'){\n\t\td.add_edge(c-'A', a[y][x]-'A', 1);\n\t\td.add_edge(a[y][x]-'A', c-'A', 1);\n\t\tc = a[y][x];\n\t}\n\tif(used[y][x])return ;\n\tused[y][x] = 1;\n\trep(i,4){\n\t\tint yy = y+dy[i],xx = x+dx[i];\n\t\tif(a[y][x] == 'o' && !dy[i] && a[yy][xx] == '|')continue;\n\t\tif(a[y][x] == 'o' && !dx[i] && a[yy][xx] == '-')continue;\n\t\tdfs(y+dy[i],x+dx[i], c);\n\t}\n}\n\nsigned main(){\n\td.init(100);\n\tint h, w;\n\tchar s, t;\n\tfill((char*)a, (char*)(a+100), '#');\n\tscanf(\"%lld%lld\",&h, &w);\n\tscanf(\" %c %c\", &s, &t);\n\trep(i,h)scanf(\"%s\", str[i]);\n\trrep(i,h)rrep(j,w)a[i][j] = str[i-1][j-1];\n\t\n\trrep(y,h)rrep(x,w){\n\t\tif('A' <= a[y][x] && a[y][x] <= 'Z' && used[y][x] == 0){\n\t\t\trepi(i,-1,2)repi(j,-1,2){\n\t\t\t\tint yy = y+i, xx = x+j;\n\t\t\t\t//a[yy][xx] = a[y][x];\n\t\t\t\tused[yy][xx] = 1;\n\t\t\t\tif(i*j == -1 || i*j == 1)a[yy][xx] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\n\trrep(i,h)rrep(j,w){\n\t\tfill((int*)used, (int*)(used+100), 0);\n\t\tif('A' <= a[i][j] && a[i][j] <= 'Z' && used[i][j] == 0){\n\t\t\tdfs(i, j, a[i][j]);\n\t\t\t//printf(\"*%c\\n\", a[i][j]);\n\t\t}\n\t}\n\td.dijkstra(s-'A');\n\tprintf(\"%lld\\n\", d.d[t-'A']);\n\t/*int x = 'B'-'A';\n\trep(i,d.G[x].size()){\n\t\tint y = d.G[x][i].fi;\n\t}*/\n\t/*rrep(i,h){\n\t\trrep(j,w)printf(\"%c\", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nP start;\nP goal;\n\nbool check(int x, int y, int H, int W){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nint main(void){\n  int H, W;\n  char s, t;\n  cin >> H >> W;\n  cin >> s >> t;\n  vector< vector<char> > graph(H, vector<char>(W));\n  for(int i = 0; i < H; i++){\n    string str;\n    cin >> str;\n    for(int j = 0; j < W; j++){\n      graph[i][j] = str[j];\n      if(graph[i][j] == s){\n        start.first = j;\n        start.second = i;\n      }\n      if(graph[i][j] == t){\n        goal.first = j;\n        goal.second = i;\n      }\n    }\n  }\n\n  // bfs\n  int INF = 1000000;\n  vector< vector<int> > d(H, vector<int>(W, INF));\n  queue<P> que;\n  que.push(make_pair(start.first, start.second));\n  d[start.second][start.first] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    if(p == goal) break;\n\n    int dx[] = {1, -1, 0, 0};\n    int dy[] = {0, 0,  1, -1};\n    for(int i = 0; i < 4; i++){\n      int nx = p.first + dx[i]*2, ny = p.second + dy[i]*2;\n      if( check(nx, ny, H, W) == false ) continue;\n      if((graph[ny][nx] == '|' && abs(dy[i]) != 0) || (graph[ny][nx] == '-' && abs(dx[i]) != 0)){\n        while(!('A' <= graph[ny][nx] && graph[ny][nx] <= 'Z')){\n          nx += dx[i]; ny += dy[i];\n          assert(check(nx, ny, H, W));\n        }\n        if(d[ny][nx] == INF){\n          d[ny][nx] = d[p.second][p.first] + 1;\n          que.push(make_pair(nx, ny));\n        }\n      }\n    }\n  }\n  cout << d[goal.second][goal.first] << endl;;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint h, w;\nchar s, t;\nstring mas[55];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> h >> w >> s >> t;\n  rep(i, h) cin >> mas[i];\n\n  vector<Pi> pos(30, Pi(-1, -1));\n  rep(i, h) {\n    rep(j, w) {\n      if(isalpha(mas[i][j])) {\n\tpos[mas[i][j]-'A'] = Pi(i, j);\n      }\n    }\n  }\n\n  const int dy[] = {1, 0, -1, 0};\n  const int dx[] = {0, 1, 0, -1};\n\n  auto in = [&](int i, int j) {\n    return 0<=i&&i<h&&0<=j&&j<w;\n  };\n\n  int ss = s-'A', tt = t-'A';\n  queue<int>  que;\n  vint dist(30, -1);\n  que.push(ss);\n  dist[ss] = 0;\n  while(!que.empty()) {\n    int u = que.front(); que.pop();\n    rep(i, 4) {\n      int ny = pos[u].first+dy[i], nx = pos[u].second+dx[i];\n      assert(mas[ny][nx] == 'o');\n      ny += dy[i];\n      nx += dx[i];\n      while(in(ny, nx) && (mas[ny][nx] == '|' || mas[ny][nx] == '-')) {\n\tny += dy[i];\n\tnx += dx[i];\n      }\n      ny += dy[i];\n      nx += dx[i];\n      if(!in(ny, nx)) continue;\n      assert(isalpha(mas[ny][nx]));\n      int v = mas[ny][nx]-'A';\n      if(dist[v] != -1) continue;\n      dist[v] = dist[u]+1;\n      que.push(v);\n    }\n  }\n\n  cout << dist[tt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,2,-2};\nint dy[]={2,-2,0,0};\nint _dx[]={0,0,1,-1};\nint _dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    char s,t;\n    cin >> H >> W >> s >> t;\n    vector<string>grid(H);\n    vector<vector<pii>>edge(100);\n    map<int,pii>memo;\n    rep(i,H) cin >> grid[i];\n    rep(i,H)rep(j,grid[i].size()){\n        if('A' <= grid[i][j] && grid[i][j] <= 'Z'  ){\n            memo[grid[i][j] - 'A'] = MP(j,i);\n        }\n    }\n    for(auto itr : memo){\n        int vertex = itr.first;\n        pii pos = itr.second;\n        rep(i,4){\n            pii temp = MP(pos.first+dx[i],pos.second+dy[i]);\n            if(!inrange(temp.first,temp.second))continue;\n            if(grid[temp.second][temp.first] != '-' && grid[temp.second][temp.first] != '|') continue;\n            pii now = temp;\n            while(true){\n                if('A' <= grid[now.second][now.first] && grid[now.second][now.first] <= 'Z'  )\n                    break;\n                now.first += _dx[i];\n                now.second += _dy[i];\n                if(!inrange(now.first, now.second)) break;\n            }\n            if(!inrange(now.second, now.first))continue;\n            int next =  grid[now.second][now.first] - 'A';\n            edge[vertex].push_back(pii(next,1));\n        }\n    }\n    // dijkstra\n    vector<int>d(t,INF);\n    d[s-'A'] = 0;\n    priority_queue<pii,vector<pii>,greater<pii>>que;\n    que.push(pii(0,s-'A'));\n    while(!que.empty()){\n        pii now = que.top();\n        que.pop();\n        if(now.first > d[now.second])continue;\n        rep(i,edge[now.second].size()){\n            int next  = edge[now.second][i].first;\n            if(d[next] < 1 + now.first) continue;\n            d[next] = 1 + now.first;\n            que.push(pii(d[next],next));\n        }\n    }\n    cout << d[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s, t;\nstring c[51];\nP idx[26];\n\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvector<int> G[100];\nint d[110];\n\nvoid dijkstra(int s){\n    fill(d, d + 100, INF);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(d[s], s));\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int from = p.second;\n        int cost = p.first;\n        if(d[from] < cost) continue;\n        rep(i, 0, G[from].size()){\n            int next = G[from][i];\n            // int next = e.to;\n            int newCost = cost + 1;\n            if(d[next] > newCost){\n                d[next] = newCost;\n                q.push(P(newCost, next));\n            }\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w >> s >> t;\n    rep(i, 0, h) cin >> c[i];\n    rep(i, 0, 26) idx[i] = {-1, -1};\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if('A' <= c[i][j] && c[i][j] <= 'Z'){\n                idx[c[i][j] - 'A'] = {i, j};\n            }\n        }\n    }\n    rep(i, 0, 26){\n        if(idx[i].first == -1) continue;\n        rep(j, 0, 4){\n            // cout << i << ' ' << j << endl;\n            int y = idx[i].first + 2 * dy[j];\n            int x = idx[i].second + 2 * dx[j];\n            bool f[51][51] = {};\n            if(!contain(y, x)) continue;\n            f[idx[i].first][idx[i].second] = true;\n            f[idx[i].first + dy[j]][idx[i].second + dx[j]] = true;\n            f[y][x] = true;\n            if(c[y][x] == '.') continue;\n            while(1){\n                int ny = -1, nx = -1;\n                // cout << i << ' ' << j << ' ' << y << ' ' << x << ' ' << c[y][x] << endl;\n                rep(k, 0, 4){\n                    ny = y + dy[k];\n                    nx = x + dx[k];\n                    if(!contain(ny, nx)) continue;\n                    if(f[ny][nx]) continue;\n                    \n                    if(c[ny][nx] == '-' && (k == 2 || k == 3)){\n                        break;\n                    }\n                    if(c[ny][nx] == '|' && (k == 0 || k == 1)){\n                        break;\n                    }\n                    if(c[ny][nx] == 'o'){\n                        ny += dy[k];\n                        nx += dx[k];\n                        break;\n                    }\n                }\n                y = ny;\n                x = nx;\n                f[y][x] = true;\n                if('A' <= c[y][x] && c[y][x] <= 'Z'){\n                    G[i].push_back(c[y][x] - 'A');\n                    // cout << (char)('A' + i) << ' ' << c[y][x] << endl;\n                    break;\n                }\n            }\n        }\n    }\n    dijkstra(s - 'A');\n    cout << d[t - 'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n\nint main() {\n    int h, w;\n    char p, q;\n    cin >> h >> w >> p >> q;\n\n    vector<string> s(h);\n    REP(i,h) cin >> s[i];\n\n    VVI e(26);\n    REP(c,26){\n        int x = -1, y = -1;\n        REP(i,h) REP(j,w){\n            if (s[i][j] == c + 'A'){\n                x = i;\n                y = j;\n            }\n        }\n        if (x == -1) continue;\n        // cout << c << endl;\n        REP(d,4){\n            int xx = x + 2 * dx[d], yy = y + 2 * dy[d];\n            // cout << xx << \" \" << yy << endl;\n            if (xx >= 0 && yy >= 0 && xx < h && yy < w && s[xx][yy] != '.'){\n                // cout << d << \" \" << xx << \" \" << yy << endl;\n                while (s[xx][yy] < 'A' || s[xx][yy] > 'Z'){\n                    xx += dx[d];\n                    yy += dy[d];\n                }\n                // cout << d << \" \" << xx << \" \" << yy << endl;\n                e[c].push_back(s[xx][yy] - 'A');\n            }\n        }\n    }\n\n    // REP(i,26){\n    //     cout << i << \"   \";\n    //     for (int x : e[i]) cout << (char)(x + 'A') << \" \";\n    //         cout << endl;\n    // }\n\n    VI d(26, 1e9);\n    d[p - 'A'] = 0;\n    queue<int> que;\n    que.push(p - 'A');\n    while (!que.empty()){\n        int x = que.front();\n        que.pop();\n        for (int y : e[x]){\n            if (d[y] > 1e5){\n                d[y] = d[x] + 1;\n                que.push(y);\n            }\n        }\n    }\n    cout << d[q - 'A'] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int,int>P;\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint dx1[]={-1,-1,-1,0,0,1,1,1};\nint dy1[]={-1,0,1,-1,1,-1,0,1};\nint h,w;\nchar S,T;\n\nvector<int>v[1000];\n\nint sx,sy,gx,gy;\nstring s[100];\n\nvoid INPUT(){\n\n  cin>>h>>w>>S>>T; \n\n  r(i,h)cin>>s[i];\n\n  r(i,h)r(j,w){\n    if(s[i][j]==S)sx=j,sy=i;\n    if(s[i][j]==T)gx=j,gy=i;\n  }\n}\n\nvoid make_GRAPH(){\n  r(i,h)r(j,w)if('A'<=s[i][j]&&s[i][j]<='Z'){\n    r(k,4){\n      int x=j+dx[k]+dx[k];\n      int y=i+dy[k]+dy[k];\n      if(x<0||y<0||x>=w||y>=h)continue;\n      if(!(s[y][x]=='-'||s[y][x]=='|'))continue;\n      while(s[y][x]=='-'||s[y][x]=='|'){\n        y+=dy[k];\n        x+=dx[k];\n      }\n      y+=dy[k];\n      x+=dx[k];\n      v[s[i][j]-'A'].push_back(s[y][x]-'A');\n    }\n  }\n}\nbool used[100009];\nint d[100005];\n\nvoid BFS(){\n  queue<P>q;\n  q.push(P(s[sy][sx]-'A',0));\n  used[s[sy][sx]-'A']=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int x=p.first;\n    int cost=p.second;\n    d[x]=cost;\n    r(i,v[x].size()){\n      int next=v[x][i];\n      if(!used[next]){\n        used[next]=1;\n        q.push(P(next,cost+1));\n      }\n    }\n  }\n  cout<<d[s[gy][gx]-'A']<<endl;\n}\n\nint main(){\n  INPUT();\n  make_GRAPH();\n  BFS();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1010101;\nconst int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nbool is_edge(char c){\n    return c=='-' || c=='|';\n}\n\nint main(){\n    int h,w;\n    char s,t;\n    cin >>h >>w >>s >>t;\n\n    vector<string> f(h);\n    rep(i,h) cin >>f[i];\n\n    pi start,goal;\n    rep(i,h)rep(j,w){\n        if(f[i][j] == s) start = {i,j};\n        if(f[i][j] == t) goal = {i,j};\n    }\n\n    auto IN = [&](int y, int x){ return 0<=y && y<h && 0<=x && x<w; };\n\n    vector<vector<int>> d(h,vector<int>(w,INF));\n    queue<pi> que;\n    d[start.fi][start.se] = 0;\n    que.push(start);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        rep(i,4){\n            int xx = now.se+2*dx[i], yy = now.fi+2*dy[i];\n            if(IN(yy,xx) && is_edge(f[yy][xx])){\n                while( !('A'<=f[yy][xx] && f[yy][xx]<='Z') ){\n                    yy += dy[i];\n                    xx += dx[i];\n                }\n\n                if(('A'<=f[yy][xx] && f[yy][xx]<='Z')){\n                    if(d[yy][xx] > d[now.fi][now.se]+1){\n                        d[yy][xx] = d[now.fi][now.se]+1;\n                        que.push({yy,xx});\n                    }\n                }\n            }\n        }\n    }\n\n    cout << d[goal.fi][goal.se] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\n\nint dy[4] = {0,2,0,-2};\nint dx[4] = {2,0,-2,0};\nint dir[12] = {0,1,2,3};\nint diry[4] = {0,1,0,-1};\nint dirx[4] = {1,0,-1,0};\n\nchar bar[4] = {'-','|','-','|'};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll H,W; cin >> H >> W;\n    char cs,ct; cin >> cs >> ct;\n    ll s,t; s = (cs - 'A'); t = (ct - 'A');\n    vector<vector<char>> masu(H+2,vector<char>(W+2,'#'));\n    map<char,pii> mp;\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            cin >> masu[i][j];\n            if(masu[i][j] >= 'A' && masu[i][j] <= 'Z'){\n                mp[masu[i][j]] = {i,j};\n            }\n        }\n    }\n    \n    for(auto m:mp){\n        auto p = m.second;\n        for(int i = -1;i <= 1; i++){\n            for(int j = -1; j <= 1;j++){\n                masu[p.first+i][p.second+j] = masu[p.first][p.second];\n            }\n        }\n    }\n    \n    //    cout << masu << endl;\n    \n    vector<vector<int>> G(30);\n    for(auto m:mp){\n        auto p = m.second;\n        int u = masu[p.first][p.second] - 'A';\n        for(int i = 0; i < 4;i++){\n            char masu_c = masu[p.first+dy[i]][p.second+dx[i]];\n            if(masu_c == bar[i]){\n                int ny = p.first+dy[i],nx = p.second+dx[i];\n                while(true){\n                    if(ny > H || ny < 1 || nx > W || nx < 1) break;\n                    if(masu[ny][nx] == '#') break;\n                    if(masu[ny][nx] == bar[i]){\n                        ny += diry[dir[i]]; nx += dirx[dir[i]];\n                        continue;\n                    }\n                    if(masu[ny][nx] >= 'A' && masu[ny][nx] <= 'Z'){\n                        int v = masu[ny][nx] - 'A';\n                        G[u].push_back(v);\n                        G[v].push_back(u);\n                        break;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int i = 0; i < 2;i++){\n        cout << G[i] << endl;\n    }\n    \n    \n    vector<ll> dist(30,INF);\n    dist[s] = 0;\n    queue<ll> q; q.push(s);\n    while(q.size()){\n        ll n = q.front(); q.pop();\n        for(auto next:G[n]){\n            if(dist[next] > dist[n] + 1){\n                dist[next] = dist[n] + 1;\n                q.push(next);\n            }\n        }\n    }\n//    cout << dist << endl;\n    cout << dist[t] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(int i=0;i<N;++i)\ntypedef long long int LL;\nstruct edge { int to, cost; };\ntypedef std::pair<int, int> P;\n\nint H, W;\nchar s, t;\nstd::string a[51];\nstd::vector<edge>G[51];\nLL d[112345];\n\nvoid dijkstra(int s)\n{\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>>que;\n\tstd::fill(d, d + 51, 114514810);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tP p = que.top(); que.pop();\n\t\tLL v = p.second;\n\t\tif (d[v] < p.first) { continue; }\n\t\trep(i, G[v].size())\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tin >> H >> W >> s >> t;\n\trep(i, H) in >> a[i];\n\tfor (int i = 1; i < H - 1; ++i)\n\t{\n\t\tfor (int j = 1; j < W - 1; ++j)\n\t\t{\n\t\t\tif (a[i][j] != 'o'&&a[i][j] != '-'&&a[i][j] != '|'&&a[i][j] != '.')\n\t\t\t{\n\t\t\t\t// 右へ\n\t\t\t\tfor (int k = j + 2; k < W - 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][k] == '.') break;\n\t\t\t\t\tif (a[i][k] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[i][k + 1] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 左へ\n\t\t\t\tfor (int k = j - 2; k > 1; --k)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][k] == '.') break;\n\t\t\t\t\tif (a[i][k] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[i][k - 1] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 下へ\n\t\t\t\tfor (int k = i + 2; k < H - 1; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (a[k][j] == '.') break;\n\t\t\t\t\tif (a[k][j] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[k + 1][j] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 上へ\n\t\t\t\tfor (int k = i - 2; k > 1; --k)\n\t\t\t\t{\n\t\t\t\t\tif (a[k][j] == '.') break;\n\t\t\t\t\tif (a[k][j] == 'o')\n\t\t\t\t\t{\n\t\t\t\t\t\tG[a[i][j] - 'A'].push_back({ a[k - 1][j] - 'A',1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(s - 'A');\n\tout << d[t - 'A'] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nconst int SZ = 'Z' + 1;\nint d[SZ][SZ];\nconst int dr[4] = { 1,0,-1,0 };\nconst int dc[4] = { 0,1,0,-1 };\nstring ike = \"|-|-\";\nvector<string> wrap(vector<string> x, char c) {\n\tint R = x.size();\n\tint C = x[0].size();\n\tvector<string> ret(R + 2, string(C + 2, c));\n\tfor (int i : range(R)) {\n\t\tfor (int j : range(C)) {\n\t\t\tret[i + 1][j + 1] = x[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tint R, C;\n\twhile (cin >> R >> C) {\n\t\tchar S, T;\n\t\tcin >> S >> T;\n\t\tvector<string> s(R);\n\t\tfor (int i : range(R))cin >> s[i];\n\t\tfor (int i : range(SZ))for (int j : range(SZ))d[i][j] = 1000;\n\t\tfor (int i : range(SZ))for (int j : range(i,i+1))d[i][j] = 0;\n\t\ts = wrap(s, '.');\n\t\tR += 2;\n\t\tC += 2;\n\t\tfor (int i : range(R)) {\n\t\t\tfor (int j : range(C)) {\n\t\t\t\tif (isupper(s[i][j])) {\n\t\t\t\t\tfor (int k : range(4)) {\n\t\t\t\t\t\tint r = i + dr[k];\n\t\t\t\t\t\tint c = j + dc[k];\n\t\t\t\t\t\twhile (s[r][c] == 'o'||s[r][c] == ike[k]) {\n\t\t\t\t\t\t\tr += dr[k];\n\t\t\t\t\t\t\tc += dc[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isupper(s[r][c])) {\n\t\t\t\t\t\t\td[s[i][j]][s[r][c]] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k : range(SZ))for (int i : range(SZ))for (int j : range(SZ))\n\t\t\tchmin(d[i][j], d[i][k] + d[k][j]);\n\t\tcout << d[S][T] << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//----------------------------\n#define FOR(i,j,n) for (int i=(j);i<(n);i++)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REPN(i,n) for (int i=(n);i>=0;i--)\n#define I(n) scanf(\"%d\", &(n))\n#define LL(n) scanf(\"%lld\", &(n))\n#define pb(n) push_back((n))\n#define mp(i,j) make_pair((i),(j))\n#include <bits/stdc++.h>\nusing namespace std;\n\n//------------------------------typedef集\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vpi> vvpi;\ntypedef vector<vvi> vvvi;\ntypedef long long ll;\n\nint H,W,x,y,mv;\nchar s,t;\nvpi vertex(28);\nint adj[26][26],depth[26],exist[26];\nstring table[51];\n\nint main(){\n    cin >> H >> W >> s >> t ;\n    REP(i,H){\n        cin >> table[i];\n        REP(j,W){\n            if ('A' <= table[i][j] && table[i][j] <= 'Z'){\n                vertex[table[i][j] - 'A'] = {i,j};\n                exist[table[i][j] - 'A'] = 1;\n            }\n        }\n    }\n    REP(i,26){\n        if (! exist[i]) continue;\n        y = vertex[i].first;\n        x = vertex[i].second;\n        if (y >= 2 && table[y-2][x] == '|'){\n            mv = y-2;\n            while (table[mv][x] == '|') mv--;\n            char conn = table[mv-1][x];\n            adj[i][conn-'A'] = adj[conn-'A'][i] = 1;\n        }\n        if (y < H-2 && table[y+2][x] == '|'){\n            mv = y+2;\n            while (table[mv][x] == '|') mv++;\n            char conn = table[mv+1][x];\n            adj[i][conn-'A'] = adj[conn-'A'][i] = 1;\n        }\n        if (x >= 2 && table[y][x-2] == '-'){\n            mv = x-2;\n            while (table[y][mv] == '-') mv--;\n            char conn = table[y][mv-1];\n            adj[i][conn-'A'] = adj[conn-'A'][i] = 1;\n        }\n        if (x < W-2 && table[y][x+2] == '-'){\n            mv = x+2;\n            while (table[y][mv] == '-') mv++;\n            char conn = table[y][mv+1];\n            adj[i][conn-'A'] = adj[conn-'A'][i] = 1;\n        }\n    }\n\n    deque<pi> q;\n    q.push_back(mp(0,(s-'A')));\n\n    while (!q.empty()){\n        pi tp = q.front();\n        q.pop_front();\n        depth[tp.second] = tp.first;\n        REP(i,26) if (adj[i][tp.second] && !depth[i] && i != s-'A') q.pb(mp(tp.first+1,i));\n    }\n    cout << depth[t-'A'] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define int long long\n#define INF 10000\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define REP(i, a, b) for (int i = (a); i < (int) (b); i++)\n\nconst int MAX_V = 3000;\n\nint H, W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nvoid Dijkstra(int s) {\n  fill(d, d + MAX_V, INF);\n  fill(used, used + MAX_V, false);\n\n  d[s] = 0;\n\n  while (true) {\n    int v = -1;\n    for (int u = 0; u < MAX_V; u++) {\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    }\n    if (v == -1) break;\n    used[v] = true;\n    for (int u = 0; u < MAX_V; u++) d[u] = min(d[u], d[v] + cost[v][u]);\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\n#include <cassert>\nvoid add_path(int x, int y) {\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  rep(i, 4) {\n    int xx = dx[i] + x, yy = dy[i] + y;\n    if (xx<0||yy<0||xx>=W||yy>=H)continue;\n    if (graph[y][x] == '-') {\n      if (graph[yy][xx] == 'o') {\n        cost[y * W + x][yy * W + xx] = 1;\n      } else if (graph[yy][xx] == '-') {\n        cost[y * W + x][yy * W + xx] = 0;\n      }\n    } else if (graph[y][x] == '|') {\n      if (graph[yy][xx] == 'o') {\n        cost[y * W + x][yy * W + xx] = 1;\n      } else if (graph[yy][xx] == '|') {\n        cost[y * W + x][yy * W + xx] = 0;\n      }\n    } else if (graph[y][x] == 'o') {\n      if (graph[yy][xx] == 'o') {\n        cost[y * W + x][yy * W + xx] = 0;\n      } else if (graph[yy][xx] == '-' || graph[yy][xx] == '|') {\n        cost[y * W + x][yy * W + xx] = 1;\n      }\n    }\n  }\n}\n\nsigned main() {\n  char s, t;\n  cin >> H >> W >> s >> t;\n  int start, goal;\n  map<char, int> m;\n  rep(i, H) {\n    rep(j, W) {\n      cin >> graph[i][j];\n      if (graph[i][j] == s) start = i * W + j;\n      if (graph[i][j] == t) goal = i * W + j;\n      if (isupper(graph[i][j])) {\n        m[graph[i][j]] = i * W + j;\n        graph[i][j]='o';\n      }\n    }\n  }\n\n  rep(i, MAX_V) rep(j, MAX_V) cost[i][j] = INF;\n\n  rep(i, H) rep(j, W) add_path(j, i);\n\n  Dijkstra(start);\n\n  for (auto &p : m) {\n    assert(d[p.second] % 2 == 0);\n    // cout << p.first << ' ' << d[p.second] / 2 << endl;\n  }\n\n  // rep(i,H) {\n  //   rep(j,W) cout<<d[i*W+j]<<' ';\n  //   cout<<endl;\n  // }\n\n  cout << d[goal] / 2 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>pipii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nstring brd[51];\n\nint dis[51][51];\nconst int inf=1e7;\n\nint main(){\n  int h,w;\n  char s,t;\n  cin>>h>>w>>s>>t;\n  rep(i,h){\n    cin>>brd[i];\n  }\n  priority_queue<pipii,vector<pipii>,greater<pipii> > que;\n  int sx=-1,sy=-1;\n  rep(i,h){\n    rep(j,w){\n      if(brd[i][j]==s){\n\tsx=i;\n\tsy=j;\n\tbreak;\n      }\n    }\n  }\n  que.push(pipii(0,pii(sx,sy)));\n  rep(i,51)rep(j,51)dis[i][j]=inf;\n  int dx[4]={1,0,-1,0};\n  int dy[4]={0,1,0,-1};\n  while(!que.empty()){\n    pipii dt=que.top();que.pop();\n    int d=dt.first;\n    pii t=dt.second;\n    if(dis[t.first][t.second]<=d)continue;\n    dis[t.first][t.second]=d;\n    rep(dir,4){\n      int nx=t.first+dx[dir],ny=t.second+dy[dir];\n      if(nx<0||nx>=h||ny<0||ny>=w)continue;\n      if(brd[nx][ny]=='.')continue;\n      int cos=(brd[nx][ny]=='o'?1:0);\n      int nd=dis[t.first][t.second]+cos;\n      que.push(pipii(nd,pii(nx,ny)));\n    }\n  }\n  rep(i,h)rep(j,w){\n    if(brd[i][j]==t){\n      cout<<dis[i][j]/2<<endl;\n    }\n  }\n  if(0){\n    rep(i,h)rep(j,w){\n      if(brd[i][j]>='A'&&brd[i][j]<='Z'){\n\tcerr<<brd[i][j]<<\" \"<<dis[i][j]<<endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<utility>\nusing namespace std;\nstring s[99];\nint h,w;\nchar S,T;\nint d[999][999];\npair<int,int>x[999];\nint main()\n{\n\tcin>>h>>w>>S>>T;\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(s[i][j]>='A'&&s[i][j]<='Z')\n\t\t\t{\n\t\t\t\tx[s[i][j]]=make_pair(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i='A';i<='Z';i++)\n\t{\n\t\tfor(int j='A';j<='Z';j++)\n\t\t{\n\t\t\tif(i!=j)d[i][j]=1e8;\n\t\t}\n\t}\n\tfor(int i='A';i<='Z';i++)\n\t{\n\t\tfor(int j=i+1;j<='Z';j++)\n\t\t{\n\t\t\tif(x[i].first==0||x[j].second==0)continue;\n\t\t\tif(x[i].first==x[j].first)\n\t\t\t{\n\t\t\t\tbool f=1;\n\t\t\t\tint left=min(x[i].second,x[j].second),right=max(x[i].second,x[j].second);\n\t\t\t\tfor(int k=left+2;k<=right-2;k++)f&=s[x[i].first][k]=='-';\n\t\t\t\tif(f)d[i][j]=d[j][i]=1;\n\t\t\t}\n\t\t\telse if(x[i].second==x[j].second)\n\t\t\t{\n\t\t\t\tbool f=1;\n\t\t\t\tint left=min(x[i].first,x[j].first),right=max(x[i].first,x[j].first);\n\t\t\t\tfor(int k=left+2;k<=right-2;k++)f&=s[k][x[i].second]=='|';\n\t\t\t\tif(f)d[i][j]=d[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k='A';k<='Z';k++)\n\t{\n\t\tfor(int i='A';i<='Z';i++)\n\t\t{\n\t\t\tfor(int j='A';j<='Z';j++)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t}\n\t}\n\tcout<<d[S][T]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n\n#define INF 10000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n/*\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n*/\n\nconst int MAX_V = 52* 52 + 1;\n\nint H,W;\nchar graph[55][55];\n\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint V;\n\nvoid Dijkstra(int s){\n  fill(d,d+MAX_V,INF);\n  fill(used,used+MAX_V,false);\n  \n  d[s]=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<MAX_V;u++){\n      if(!used[u] && (v==-1||d[u]<d[v]))v=u;\n    }\n    if(v==-1)break;\n    used[v]=true;\n    for(int u=0;u<MAX_V;u++){\n      d[u]=min(d[u],d[v]+cost[v][u]);\n    }\n  }\n  // rep(i,10)cout<<\"debug: \"<<d[i]<<endl;\n}\n\nvoid add_path(int x,int y){\n  int dx[2]={-1,0};\n  int dy[2]={0,-1};\n  rep(i,2){\n    int xx=dx[i]+x,yy=dy[i]+y;\n    if(graph[y][x]=='-'){\n      if(graph[yy][xx]=='o'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }else if(graph[yy][xx]=='-'){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }\n    }else if(graph[y][x]=='|'){\n      if(graph[yy][xx]=='o'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }else if(graph[yy][xx]=='|'){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }\n    }else if('A'<=graph[y][x]&&graph[y][x]<='Z'){\n      cost[y*W+x][yy*W+xx]=0;\n      cost[yy*W+xx][y*W+x]=0;\n    }else if(graph[y][x]=='o'){\n      if(graph[yy][xx]=='o'||('A'<=graph[yy][xx]&&graph[yy][xx]<='Z')){\n\tcost[y*W+x][yy*W+xx]=0;\n\tcost[yy*W+xx][y*W+x]=0;\n      }else if(graph[yy][xx]=='-'||graph[yy][xx]=='|'){\n\tcost[y*W+x][yy*W+xx]=1;\n\tcost[yy*W+xx][y*W+x]=1;\n      }\n    }\n  }\n}\n\nint main(){\n  char s,t;\n  cin>>H>>W>>s>>t;\n  int start,goal;\n  rep(i,H){\n    rep(j,W){\n      cin>>graph[i][j];\n      if(graph[i][j]==s)start=i*W+j;\n      if(graph[i][j]==t)goal=i*W+j;\n    }\n  }\n\n  rep(i,MAX_V){\n    rep(j,MAX_V)cost[i][j]=INF;\n  }\n  \n  REP(i,1,H){\n    REP(j,1,W){\n      add_path(j,i);\n    }\n  }\n\n  Dijkstra(start);\n  cout<<d[goal] / 2<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint alf_to_num(char c){\n\treturn (int)c - (int)'A';\n}\n\nint main(){\n\tint H, W, i, j, k, nowv;\n\tchar s, t;\n\tscanf(\"%d%d %c %c\", &H, &W, &s, &t);\n\tchar **a = (char **)malloc(sizeof(char *) * (H + 2));\n\tfor(i = 0; i <= H + 1; i++){\n\t\ta[i] = (char *)malloc(sizeof(char) * (W + 2));\n\t\tif(i == 0 || i == H + 1){\n\t\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\t\ta[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ta[i][0] = '.';\n\t\t\tscanf(\"%s\", &a[i][1]);\n\t\t\ta[i][W + 1] = '.';\n\t\t}\n\t}\n\tint **dis = (int **)malloc(sizeof(int *) * 26);\n\tfor(i = 0; i < 26; i++){\n\t\tdis[i] = (int *)malloc(sizeof(int) * 26);\n\t\tfor(j = 0; j < 26; j++){\n\t\t\tdis[i][j] = inf;\n\t\t}\n\t}\n\n\tfor(i = 0; i <= H + 1; i++){\n\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\tnowv = alf_to_num(a[i][j]);\n\t\t\tif(0 <= nowv && nowv < 26){\n\t\t\t\tif(a[i - 2][j] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i - k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i - k - 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i - k - 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i - k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i + 2][j] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i + k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i + k + 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i + k + 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i + k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j - 2] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j - k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j - k - 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j - k - 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j - k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j + 2] != '.'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j + k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j + k + 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j + k + 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j + k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(k = 0; k < 26; k++){\n\t\tfor(i = 0; i < 26; i++){\n\t\t\tfor(j = 0; j < 26; j++){\n\t\t\t\tif(dis[i][j] > dis[i][k] + dis[k][j]){\n\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dis[alf_to_num(s)][alf_to_num(t)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2869 AA Graph\n// 2018.3.29 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n\ntypedef struct { int a; int t; } Q;\nQ q[500]; int top, end;\nchar map[53][53];\nchar mk[30];\nint  hi[26], to[26][26];\n\nint main()\n{\n\tint H, W, s, t, r, c, rr, cc, a, b, d, i;\n\tchar ss[5], tt[5];\n\n\tscanf(\"%d%d%s%s\", &H, &W, ss, tt);\n\ts = ss[0] - 'A', t = tt[0] - 'A';\n\n\tfor (r = 0; r < H; r++) scanf(\"%s\", map[r]);\n\tfor (r = 0; r < H; r++) for (c = 0; c < W; c++) {\n\t\tif (!isupper(map[r][c])) continue;\n\t\ta = map[r][c] - 'A';\n\t\tfor (cc = c+1; cc < W; cc++) {\n\t\t\tif (isupper(map[r][cc])) {\n\t\t\t\tb = map[r][cc] - 'A';\n\t\t\t\tto[a][hi[a]++] = b;\n\t\t\t\tto[b][hi[b]++] = a;\n\t\t\t\tbreak;\n\t\t\t} else if (map[r][cc] != 'o' && map[r][cc] != '-') break;\n\t\t}\n\t\tfor (rr = r+1; rr < H; rr++) {\n\t\t\tif (isupper(map[rr][c])) {\n\t\t\t\tb = map[rr][c] - 'A';\n\t\t\t\tto[a][hi[a]++] = b;\n\t\t\t\tto[b][hi[b]++] = a;\n\t\t\t\tbreak;\n\t\t\t} else if (map[rr][c] != 'o' && map[rr][c] != '|') break;\n\t\t}\n\t}\n\n\tq[0].a = s, q[0].t = 0, top = 0, end = 1;\n\twhile (top < end) {\n\t\ta = q[top].a, d = q[top++].t;\n\t\tif (a == t) break;\n\t\tif (mk[a]) continue;\n\t\tmk[a] = 1;\n\t\tfor (i = 0; i < hi[a]; i++) {\n\t\t\tb = to[a][i];\n\t\t\tif (mk[b]) continue;\n\t\t\tq[end].a = b, q[end++].t = d+1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={1,0,-1,0};\nint X[]={0,1,0,-1};\nint main(){\n  int h,w,i,j,r=1,t,ny,nx,gx,gy,x[100010],y[100010],d[100][100]={};\n  char s,g,m[100][100]={};\n  scanf(\"%d %d %c %c\",&h,&w,&s,&g);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&m[i][j]);\n      if(m[i][j]==g){\n\tgy=i;\n\tgx=j;\n      }\n      if(m[i][j]==s)m[y[t=0]=i][x[0]=j]='.';\n    }\n  }\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      ny=y[t]+Y[i]*2;\n      nx=x[t]+X[i]*2;\n      if(m[ny][nx]!='-'&&i%2   )continue;\n      if(m[ny][nx]!='|'&&i%2==0)continue;\n      for(j=1;1;j++){\n\tif(m[ny+Y[i]*j][nx+X[i]*j]=='o')break;\n      }\n      ny=ny+Y[i]*(j+1);\n      nx=nx+X[i]*(j+1);\n      if(m[ny][nx]=='.')continue;\n      m[y[r]=ny][x[r]=nx]='.';\n      d[y[r]][x[r]]=d[y[t]][x[t]]+1;\n      r++;\n    }\n  }/*printf(\"\\n\");\n  for(i=0;i<h;i++)printf(\"%s\\n\",m[i+1]+1);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++)printf(\"%d\",d[i][j]);\n    printf(\"\\n\");\n    }printf(\"%d %d\\n\",gy,gx);//*/\n  printf(\"%d\\n\",d[gy][gx]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint Y[]={1,0,-1,0};\nint X[]={0,1,0,-1};\nint main(){\n  int h,w,i,j,r=1,t,ny,nx,gx,gy,x[100010],y[100010],d[100][100]={};\n  char m[100][100],s,g;\n  scanf(\"%d %d %c %c\",&h,&w,&s,&g);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      scanf(\" %c\",&m[i][j]);\n      if(m[i][j]==s)m[y[t=0]=i][x[0]=j]='.';\n      if(m[i][j]==g){\n\tgy=i;\n\tgx=j;\n      }\n    }\n  }\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      ny=y[t]+Y[i]*2;\n      nx=x[t]+X[i]*2;\n      if(m[ny][nx]-'-'&&m[ny][nx]-'|')continue;\n      for(j=1;1;j++){\n\tif(m[ny+Y[i]*j][nx+X[i]*j]=='o')break;\n      }\n      ny=ny+Y[i]*(j+1);\n      nx=nx+X[i]*(j+1);\n      if(m[ny][nx]=='.')continue;\n      m[y[r]=ny][x[r]=nx]='.';\n      d[y[r]][x[r]]=d[y[t]][x[t]]+1;\n      r++;\n    }\n  }/*printf(\"\\n\");\n  for(i=0;i<h;i++)printf(\"%s\\n\",m[i+1]+1);\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++)printf(\"%d\",d[i][j]);\n    printf(\"\\n\");\n    }printf(\"%d %d\\n\",gy,gx);//*/\n  printf(\"%d\\n\",d[gy][gx]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e8)\n\nint alf_to_num(char c){\n\treturn (int)c - (int)'A';\n}\n\nint main(){\n\tint H, W, i, j, k, nowv;\n\tchar s, t;\n\tscanf(\"%d %d %c %c\", &H, &W, &s, &t);\n\tchar **a = (char **)malloc(sizeof(char *) * (H + 2));\n\tfor(i = 0; i <= H + 1; i++){\n\t\ta[i] = (char *)malloc(sizeof(char) * (W + 2));\n\t\tif(i == 0 || i == H + 1){\n\t\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\t\ta[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ta[i][0] = '.';\n\t\t\tscanf(\"%s\", &a[i][1]);\n\t\t\ta[i][W + 1] = '.';\n\t\t}\n\t}\n\tint **dis = (int **)malloc(sizeof(int *) * 26);\n\tfor(i = 0; i < 26; i++){\n\t\tdis[i] = (int *)malloc(sizeof(int) * 26);\n\t\tfor(j = 0; j < 26; j++){\n\t\t\tdis[i][j] = inf;\n\t\t}\n\t}\n\n//\tint dx = {0, 1, 0, -1};\n//\tint dy = {1, 0, -1, 0};\n\tfor(i = 0; i <= H + 1; i++){\n\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\tnowv = alf_to_num(a[i][j]);\n\t\t\tif(0 <= nowv && nowv < 26){\n/*\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\tif(a[i + 2 * dx[b]][j + 2 * dy[b]])\n\t\t\t\t}\n*/\t\t\t\tif(a[i - 2][j] == '|'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i - k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i - k - 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i - k - 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i - k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i + 2][j] == '|'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i + k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i + k + 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i + k + 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i + k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j - 2] == '-'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j - k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j - k - 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j - k - 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j - k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j + 2] == '-'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j + k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j + k + 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j + k + 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j + k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(k = 0; k < 26; k++){\n\t\tfor(i = 0; i < 26; i++){\n\t\t\tfor(j = 0; j < 26; j++){\n\t\t\t\tif(dis[i][j] > dis[i][k] + dis[k][j]){\n\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dis[alf_to_num(s)][alf_to_num(t)]);\n/*\tfor(i = 0; i <= H + 1; i++){\n\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\tprintf(\"%c\", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<62)-(1LL<<31))\n\n//遅い方のダイクストラ（早い方の完全下位互換だが一応）\n//頂点数、スタート（と隣接行列）を引いて最短距離と経路を返す\n//O(V^2)\nll daikusutorap[1<<11];\nll cost[1<<10][1<<10];//辺が無いところはINFにする前処理が必要\nvoid daikusutora(ll n,ll s){\n\tll*f=(ll*)malloc(n*sizeof(ll));\n\trep(i,0,n){\n\t\tdaikusutorap[i]=i==s?0:INF;\n\t\tf[i]=0;\n\t}\n\trep(nnnnnn,1,n){\n\t\tll m=INF,mv=-1;\n\t\trep(i,0,n){\n\t\t\tif(!f[i]&&m>daikusutorap[i]){\n\t\t\t\tm=daikusutorap[i];\n\t\t\t\tmv=i;\n\t\t\t}\n\t\t}\n\t\tif(mv==-1)break;\n\t\tf[mv]=1;\n\t\trep(i,0,n)if(cost[mv][i]&&daikusutorap[i]>daikusutorap[mv]+cost[mv][i]){\n\t\t\tdaikusutorap[i]=daikusutorap[mv]+cost[mv][i];\n\t\t\tdaikusutorap[n+i]=mv;\n\t\t}\n\t}\n\tfree(f);\n}\n\nchar s[60][60];\nint d4[]={0,1,0,-1,0};\nint main(){\n\trep(i,0,26)rep(j,0,26)cost[i][j]=INF;\n\tint h,w;\n\tchar x,y;\n\tscanf(\"%d%d %c %c\",&h,&w,&x,&y);\n\trep(i,0,h)scanf(\" %s\",s[i]);\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if('A'<=s[i][j]&&s[i][j]<='Z'){\n\t\tint start=s[i][j]-'A';\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ci=i+d4[k]*2,cj=j+d4[k+1]*2;\n\t\t\tchar edge=d4[k]?'|':'-';\n\t\t\tif(0<=ci&&ci<h&&0<=cj&&cj<w&&s[ci][cj]==edge){\n\t\t\t\twhile(s[ci][cj]==edge){\n\t\t\t\t\tci+=d4[k];\n\t\t\t\t\tcj+=d4[k+1];\n\t\t\t\t}\n\t\t\t\tci+=d4[k];\n\t\t\t\tcj+=d4[k+1];\n\t\t\t\tint goal=s[ci][cj]-'A';\n\t\t\t\tcost[start][goal]=1;\n\t\t\t}\n\t\t}\n\t}\n\tdaikusutora(26,x-'A');\n\tprintf(\"%lld\\n\",daikusutorap[y-'A']);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int h = sc.nextInt();\n        int w = sc.nextInt();\n        int start = sc.next().charAt(0) - 'A';\n        int end = sc.next().charAt(0) - 'A';\n        char[][] field = new char[h][];\n        for (int i = 0; i < h; i++) {\n            field[i] = sc.next().toCharArray();\n        }\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < 26; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] >= 'A' && field[i][j] <= 'Z') {\n                    char a = field[i][j];\n                    if (j + 2 < w && field[i][j + 2] == '-') {\n                        int right = j + 2;\n                        while (field[i][right] < 'A' || field[i][right] > 'Z') {\n                            right++;\n                        }\n                        char b = field[i][right];\n                        graph.get(a - 'A').add(b - 'A');\n                        graph.get(b - 'A').add(a - 'A');\n                    }\n                    if (i + 2 < h && field[i + 2][j] == '|') {\n                        int down = i + 2;\n                        while (field[down][j] < 'A' || field[down][j] > 'Z') {\n                            down++;\n                        }\n                        char b = field[down][j];\n                        graph.get(a - 'A').add(b - 'A');\n                        graph.get(b - 'A').add(a - 'A');\n                    }\n                }\n            }\n        }\n        int[] costs = new int[26];\n        Arrays.fill(costs, Integer.MAX_VALUE);\n        PriorityQueue<Path> queue = new PriorityQueue<>();\n        queue.add(new Path(start, 0));\n        while (queue.size() > 0) {\n            Path p = queue.poll();\n            if (p.value >= costs[p.idx]) {\n                continue;\n            }\n            costs[p.idx] = p.value;\n            for (int x : graph.get(p.idx)) {\n                queue.add(new Path(x, p.value + 1));\n            }\n        }\n        System.out.println(costs[end]);\n    }\n    \n    static class Path implements Comparable<Path> {\n        int idx;\n        int value;\n        \n        public Path (int idx, int value) {\n            this.idx = idx;\n            this.value = value;\n        }\n        \n        public int compareTo(Path another) {\n            return value - another.value;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n\n    int H, W;\n    void Solve()\n    {\n        var dd = new[] { 0, 1, 0, -1, 0 };\n        H = cin.Nextint;\n        W = cin.Nextint;\n        int S = cin.Next[0] - 'A';\n        int T = cin.Next[0] - 'A';\n        input(26, 26);\n\n        var C = new string[H];\n        for (int i = 0; i < H; i++)\n        {\n            C[i] = cin.Next;\n        }\n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                if ('A' <= C[i][j] && C[i][j] <= 'Z')\n                {\n                    for (int r = 0; r < 4; r++)\n                    {\n                        int y = i + dd[r] * 2;\n                        int x = j + dd[r + 1] * 2;\n                        while (0 <= y && y < H && 0 <= x && x < W)\n                        {\n                            if (r % 2 == 0)\n                            {\n                                if (C[y][x] == '-')\n                                {\n                                    y += dd[r];\n                                    x += dd[r + 1];\n                                }\n                                else if (C[y][x] == 'o')\n                                {\n                                    y += dd[r];\n                                    x += dd[r + 1];\n                                    D[C[i][j] - 'A', C[y][x] - 'A'] = 1;\n                                    D[C[y][x] - 'A', C[i][j] - 'A'] = 1;\n                                    break;\n                                }\n                                else break;\n                            }\n                            else\n                            {\n                                if (C[y][x] == '|')\n                                {\n                                    y += dd[r];\n                                    x += dd[r + 1];\n                                }\n                                else if (C[y][x] == 'o')\n                                {\n                                    y += dd[r];\n                                    x += dd[r + 1];\n                                    D[C[i][j] - 'A', C[y][x] - 'A'] = 1;\n                                    D[C[y][x] - 'A', C[i][j] - 'A'] = 1;\n                                    break;\n                                }\n                                else break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        warshall_floyd(26);\n        Console.WriteLine(D[S, T]);\n\n    }\n\n    long[,] D;\n    const long inf = long.MaxValue / 3;\n    void input(int n, int m)\n    {\n        D = new long[n, n];\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                D[i, j] = inf;\n                if (i == j) D[i, j] = 0;\n            }\n        }\n        //for (int i = 0; i < m; i++)\n        //{\n        //    int a = cin.nextint - 1;\n        //    int b = cin.nextint - 1;\n        //    long c = cin.nextlong;\n        //    D[a, b] = Math.Min(D[a, b], c);\n        //    D[b, a] = c;\n        //}\n    }\n    void warshall_floyd(int n)\n    {\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    D[i, j] = Math.Min(D[i, j], D[i, k] + D[k, j]);\n                }\n            }\n        }\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int h, w; char s, t; rd(h, w, s, t);\n  auto c=new char[][](h, w);\n  foreach(i; 0..h) c[i]=readln.chomp.to!(char[]);\n\n  const int n=26;\n  auto d=new int[][](n, n);\n  foreach(i; 0..n) fill(d[i], 1_000_000);\n\n  auto dir=[[1, 0], [-1, 0], [0, 1], [0, -1]];\n  bool A(char ch){return ('A'<=ch && ch<='Z');}\n  foreach(int i; 0..h)foreach(int j; 0..w){\n    if(A(c[i][j])==false) continue;\n    d[c[i][j]-'A'][c[i][j]-'A']=0;\n    foreach(dd; dir){\n      int ni=i+dd[0]*2, nj=j+dd[1]*2;\n      if(ni<0 || ni>=h || nj<0 || nj>=w) continue;\n      if(c[ni][nj]!='|' && c[ni][nj]!='-') continue;\n      while((ni>=0 && ni<h && nj>=0 && nj<w) && A(c[ni][nj])==false){\n        ni+=dd[0]; nj+=dd[1];\n      }\n      if((ni>=0 && ni<h && nj>=0 && nj<w)){\n        int x=c[i][j]-'A', y=c[ni][nj]-'A';\n        // writeln(c[i][j], \" \", c[ni][nj]);\n        d[x][y]=d[y][x]=1;\n      }\n    }\n  }\n\n  foreach(_; 0..n)foreach(i; 0..n)foreach(j; 0..n){\n    d[i][j]=min(d[i][j], d[i][_]+d[_][j]);\n  }\n\n  writeln(d[s-'A'][t-'A']);\n}\n\nvoid rd(Type...)(ref Type x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int h, w; char s, t; rd(h, w, s, t);\n  auto c=new char[][](h, w);\n  foreach(i; 0..h) c[i]=readln.chomp.to!(char[]);\n\n  int si, sj, gi, gj;\n  foreach(int i; 0..h)foreach(int j; 0..w){\n    if(c[i][j]==s) si=i, sj=j;\n    if(c[i][j]==t) gi=i, gj=j;\n  }\n\n  auto dir=[[1, 0], [-1, 0], [0, 1], [0, -1]];\n\n  auto d=new int[][](h, w);\n  foreach(i; 0..h) fill(d[i], 1_000_000);\n  d[si][sj]=0;\n  import std.typecons;\n  alias P=Tuple!(int, \"i\", int, \"j\");\n  auto q=new Queue!(P)(h*w);\n  q.insertBack(P(si, sj));\n  while(q.empty==false){\n    auto cur=q.front; q.removeFront;\n    foreach(dd; dir){\n      auto ni=cur.i+dd[0]*2, nj=cur.j+dd[1]*2;\n      if(ni<0 || ni>=h || nj<0 || nj>=w) continue;\n      if(c[ni][nj]=='.') continue;\n      while(('A'<=c[ni][nj] && c[ni][nj]<='Z')==false){\n        ni+=dd[0]; nj+=dd[1];\n      }\n      if(d[cur.i][cur.j]+1<d[ni][nj]){\n        d[ni][nj]=d[cur.i][cur.j]+1;\n        q.insertBack(P(ni, nj));\n      }\n    }\n  }\n\n  writeln(d[gi][gj]);\n}\n\nclass Queue(T){\nprivate:\n  int n, l=0, r=0;\n  T[] arr;\n\npublic:\n  this(int size){\n    n=size+1;\n    arr.length=n;\n  }\n  bool empty(){\n    return l==r;\n  }\n  bool full(){\n    return l==(r+1)%n;\n  }\n  T front(){\n    return arr[l];\n  }\n  void insertBack(T x){\n    assert(full==false);\n    arr[r]=x;\n    (r+=1)%=n;\n  }\n  void removeFront(){\n    assert(empty==false);\n    (l+=1)%=n;\n  }\n}\n\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int h, w; char s, t; rd(h, w, s, t);\n  auto c=new char[][](h, w);\n  foreach(i; 0..h) c[i]=readln.chomp.to!(char[]);\n\n  int si, sj, gi, gj;\n  foreach(int i; 0..h)foreach(int j; 0..w){\n    if(c[i][j]==s) si=i, sj=j;\n    if(c[i][j]==t) gi=i, gj=j;\n  }\n\n  auto dir=[[1, 0], [-1, 0], [0, 1], [0, -1]];\n\n  auto d=new int[][](h, w);\n  foreach(i; 0..h) fill(d[i], 1_000_000);\n  d[si][sj]=0;\n  import std.typecons;\n  alias P=Tuple!(int, \"i\", int, \"j\");\n  auto q=new Queue!(P)(h*w*1000);\n  q.insertBack(P(si, sj));\n  while(q.empty==false){\n    auto cur=q.front; q.removeFront;\n    foreach(dd; dir){\n      auto ni=cur.i+dd[0]*2, nj=cur.j+dd[1]*2;\n      if(ni<0 || ni>=h || nj<0 || nj>=w) continue;\n      if(c[ni][nj]=='.') continue;\n      while(('A'<=c[ni][nj] && c[ni][nj]<='Z')==false){\n        ni+=dd[0]; nj+=dd[1];\n      }\n      if(d[cur.i][cur.j]+1<d[ni][nj]){\n        d[ni][nj]=d[cur.i][cur.j]+1;\n        q.insertBack(P(ni, nj));\n      }\n    }\n  }\n\n  writeln(d[gi][gj]);\n}\n\nclass Queue(T){\nprivate:\n  int n, l=0, r=0;\n  T[] arr;\n\npublic:\n  this(int size){\n    n=size+1;\n    arr.length=n;\n  }\n  bool empty(){\n    return l==r;\n  }\n  bool full(){\n    return l==(r+1)%n;\n  }\n  T front(){\n    return arr[l];\n  }\n  void insertBack(T x){\n    assert(full==false);\n    arr[r]=x;\n    (r+=1)%=n;\n  }\n  void removeFront(){\n    assert(empty==false);\n    (l+=1)%=n;\n  }\n}\n\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int h, w; char s, t; rd(h, w, s, t);\n  auto c=new char[][](h, w);\n  foreach(i; 0..h) c[i]=readln.chomp.to!(char[]);\n\n  const int n=26;\n  auto d=new int[][](n, n);\n  foreach(i; 0..n) fill(d[i], 1_000_000);\n\n  auto dir=[[1, 0], [-1, 0], [0, 1], [0, -1]];\n  bool A(char ch){return ('A'<=ch && ch<='Z');}\n  foreach(int i; 0..h)foreach(int j; 0..w){\n    if(A(c[i][j])==false) continue;\n    d[c[i][j]-'A'][c[i][j]-'A']=0;\n    foreach(dd; dir){\n      int ni=i+dd[0], nj=j+dd[1];\n      while((ni>=0 && ni<h && nj>=0 && nj<w) && A(c[ni][nj])==false){\n        ni+=dd[0]; nj+=dd[1];\n      }\n      if((ni>=0 && ni<h && nj>=0 && nj<w)){\n        int x=c[i][j]-'A', y=c[ni][nj]-'A';\n        d[x][y]=d[y][x]=1;\n      }\n    }\n  }\n\n  foreach(_; 0..n)foreach(i; 0..n)foreach(j; 0..n){\n    d[i][j]=min(d[i][j], d[i][_]+d[_][j]);\n  }\n\n  writeln(d[s-'A'][t-'A']);\n}\n\nvoid rd(Type...)(ref Type x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int h, w; char s, t; rd(h, w, s, t);\n  auto c=new char[][](h, w);\n  foreach(i; 0..h) c[i]=readln.chomp.to!(char[]);\n\n  const int n=26;\n  auto d=new int[][](n, n);\n  foreach(i; 0..n) fill(d[i], 1_000_000);\n\n  auto dir=[[1, 0], [-1, 0], [0, 1], [0, -1]];\n  bool A(char ch){return ('A'<=ch && ch<='Z');}\n  foreach(int i; 0..h)foreach(int j; 0..w){\n    if(A(c[i][j])==false) continue;\n    d[c[i][j]-'A'][c[i][j]-'A']=0;\n    foreach(dd; dir){\n      int ni=i+dd[0]*2, nj=j+dd[1]*2;\n      if(ni<0 || ni>=h || nj<0 || nj>=w) continue;\n      if(((dd[0]!=0 && c[ni][nj]=='|')||(dd[1]!=0 && c[ni][nj]=='-'))==false) continue;\n      while((ni>=0 && ni<h && nj>=0 && nj<w) && A(c[ni][nj])==false){\n        ni+=dd[0]; nj+=dd[1];\n      }\n      if((ni>=0 && ni<h && nj>=0 && nj<w)){\n        int x=c[i][j]-'A', y=c[ni][nj]-'A';\n        // writeln(c[i][j], \" \", c[ni][nj]);\n        d[x][y]=d[y][x]=1;\n      }\n    }\n  }\n\n  foreach(_; 0..n)foreach(i; 0..n)foreach(j; 0..n){\n    d[i][j]=min(d[i][j], d[i][_]+d[_][j]);\n  }\n\n  writeln(d[s-'A'][t-'A']);\n}\n\nvoid rd(Type...)(ref Type x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  int h, w; char s, t; rd(h, w, s, t);\n  auto c=new char[][](h, w);\n  foreach(i; 0..h) c[i]=readln.chomp.to!(char[]);\n\n  const int n=26;\n  auto d=new int[][](n, n);\n  foreach(i; 0..n) fill(d[i], 1_000_000);\n\n  auto dir=[[1, 0], [-1, 0], [0, 1], [0, -1]];\n  bool A(char ch){return ('A'<=ch && ch<='Z');}\n  foreach(int i; 0..h)foreach(int j; 0..w){\n    if(A(c[i][j])==false) continue;\n    d[c[i][j]-'A'][c[i][j]-'A']=0;\n    foreach(dd; dir){\n      int ni=i+dd[0]*2, nj=j+dd[1]*2;\n      if(ni<0 || ni>=h || nj<0 || nj>=w) continue;\n      if(c[ni][nj]!='|' && c[ni][nj]!='-') continue;\n      while(A(c[ni][nj])==false){\n        ni+=dd[0]; nj+=dd[1];\n      }\n      if((ni>=0 && ni<h && nj>=0 && nj<w)){\n        int x=c[i][j]-'A', y=c[ni][nj]-'A';\n        // writeln(c[i][j], \" \", c[ni][nj]);\n        d[x][y]=d[y][x]=1;\n      }\n    }\n  }\n\n  foreach(_; 0..n)foreach(i; 0..n)foreach(j; 0..n){\n    d[i][j]=min(d[i][j], d[i][_]+d[_][j]);\n  }\n\n  writeln(d[s-'A'][t-'A']);\n}\n\nvoid rd(Type...)(ref Type x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  assert(l.length==x.length);\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e8)\n\nint alf_to_num(char c){\n\treturn (int)c - (int)'A';\n}\n\nint main(){\n\tint H, W, i, j, k, nowv;\n\tchar s, t;\n\tscanf(\"%d %d %c %c\", &H, &W, &s, &t);\n\tchar **a = (char **)malloc(sizeof(char *) * (H + 2));\n\tfor(i = 0; i <= H + 1; i++){\n\t\ta[i] = (char *)malloc(sizeof(char) * (W + 2));\n\t\tif(i == 0 || i == H + 1){\n\t\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\t\ta[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\ta[i][0] = '.';\n\t\t\tscanf(\"%s\", &a[i][1]);\n\t\t\ta[i][W + 1] = '.';\n\t\t}\n\t}\n\tint **dis = (int **)malloc(sizeof(int *) * 26);\n\tfor(i = 0; i < 26; i++){\n\t\tdis[i] = (int *)malloc(sizeof(int) * 26);\n\t\tfor(j = 0; j < 26; j++){\n\t\t\tdis[i][j] = inf;\n\t\t}\n\t}\n\n//\tint dx = {0, 1, 0, -1};\n//\tint dy = {1, 0, -1, 0};\n\tfor(i = 0; i <= H + 1; i++){\n\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\tnowv = alf_to_num(a[i][j]);\n\t\t\tif(0 <= nowv && nowv < 26){\n/*\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\tif(a[i + 2 * dx[b]][j + 2 * dy[b]])\n\t\t\t\t}\n*/\t\t\t\tif(a[i - 2][j] == '|'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i - k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i - k - 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i - k - 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i - k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i + 2][j] == '|'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i + k][j] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i + k + 1][j])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i + k + 1][j])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i + k][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j - 2] == '-'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j - k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j - k - 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j - k - 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j - k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j + 2] == '-'){\n\t\t\t\t\tfor(k = 2; ; k++){\n\t\t\t\t\t\tif(a[i][j + k] == 'o'){\n\t\t\t\t\t\t\tdis[nowv][alf_to_num(a[i][j + k + 1])] = 1;\n\t\t\t\t\t\t\tdis[alf_to_num(a[i][j + k + 1])][nowv] = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ta[i][j + k] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(k = 0; k < 26; k++){\n\t\tfor(i = 0; i < 26; i++){\n\t\t\tfor(j = 0; j < 26; j++){\n\t\t\t\tif(dis[i][j] > dis[i][k] + dis[k][j]){\n\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dis[alf_to_num(s)][alf_to_num(t)]);\n/*\tfor(i = 0; i <= H + 1; i++){\n\t\tfor(j = 0; j <= W + 1; j++){\n\t\t\tprintf(\"%c\", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nH,W,s,t = input().split()\nH = int(H)\nW = int(W)\nM = [(\".\") * (W + 2)]\nE = {}\n\nfor i in range(0,H):\n    a = input()\n    M.append(\".\" + a + \".\")\n\nM.append((\".\") * (W + 2))\nH = H + 2\nW = W + 2\n\nfor h in range(0,H):\n    for w in range(0,W):\n        if M[h][w] not in [\".\",\"-\",\"|\",\"o\"]:\n            E[M[h][w]] = [h,w]\n\nG = {k:[] for k in E.keys()}\nfor e,(h,w) in E.items():\n    if M[h][w+2] == \"-\":\n        i = 2\n        while M[h][w+i] == \"-\":\n            i += 1\n\n        G[e].append(M[h][w+i+1])\n\n    if M[h][w - 2] == \"-\":\n        i = 2\n        while M[h][w - i] == \"-\":\n            i += 1\n\n        G[e].append(M[h][w - i - 1])\n\n    if M[h + 2][w] == \"|\":\n        i = 2\n        while M[h + i][w] == \"|\":\n            i += 1\n\n        G[e].append(M[h + i + 1][w])\n\n    if M[h - 2][w] == \"|\":\n        i = 2\n        while M[h - i][w] == \"|\":\n            i += 1\n\n        G[e].append(M[h - i - 1][w])\n\nvisited = {k:False for k in E.keys()}\nQ = deque([[s,0]])\nwhile Q:\n    e,c = Q.popleft()\n    visited[e] = True\n    for ne in G[e]:\n        if ne == t:\n            print(c+1)\n            Q = []\n            break\n\n        if visited[ne] == True:\n            continue\n        else:\n            Q.append([ne,c +1])\n\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef main():\n    H, W, s, t = input().split()\n\n    H, W = map(int, (H, W))\n    s, t = map(lambda ch: ord(ch)-ord('A'), (s, t))\n\n    a = [input() for i in range(H)]\n    # b is transpose of a\n    b = [''.join([a[i][j] for i in range(H)]) for j in range(W)]\n\n    # Parse paths\n    paths = []\n    path_h_re = re.compile(r'o[A-Z]o(?:-+o[A-Z]o)+')\n    path_v_re = re.compile(r'o[A-Z]o(?:\\|+o[A-Z]o)+')\n    for a_i in a: paths.extend(path_h_re.findall(a_i))\n    for b_i in b: paths.extend(path_v_re.findall(b_i))\n    paths = [re.sub(r'[^A-Z]+', '', e) for e in paths]\n\n    # Make a graph\n    INF = 50\n    g = [[INF for j in range(26)] for i in range(26)]\n    for path in paths:\n        for u, v in zip(path[:-1], path[1:]):\n            u = ord(u)-ord('A')\n            v = ord(v)-ord('A')\n            g[u][v] = g[v][u] = 1\n\n    # Solve a shortest-path problem\n    for k in range(26):\n        g = [\n            [min(g[i][j], g[i][k]+g[k][j]) for j in range(26)]\n            for i in range(26)\n        ]\n\n    print(g[s][t])\n    return 0\n\nif __name__ == '__main__':\n    exit(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nh, w, s, t = input().split()\nh, w = int(h), int(w)\nmp = [\"#\" * (w + 2)] + [\"#\" + input() + \"#\" for _ in range(h)] + [\"#\" * (w + 2)]\nchecked = [[False] * (w + 2) for _ in range(h + 2)]\nedges = {chr(c):[] for c in range(ord(\"A\"), ord(\"Z\") + 1)}\nfor y in range(1, h + 1):\n  for x in range(1, w + 1):\n    if mp[y][x] == \"|\" and not checked[y][x]:\n      nx, ny = x, y\n      start = mp[ny - 2][nx]\n      while mp[ny][nx] == \"|\":\n        checked[ny][nx] = True\n        ny += 1\n      goal = mp[ny + 1][nx]\n      edges[start].append(goal)\n      edges[goal].append(start)\n    \n    if mp[y][x] == \"-\" and not checked[y][x]:\n      nx, ny = x, y\n      start = mp[ny][nx - 2]\n      while mp[ny][nx] == \"-\":\n        checked[ny][nx] = True\n        nx += 1\n      goal = mp[ny][nx + 1]\n      edges[start].append(goal)\n      edges[goal].append(start)\n\nque = deque()\nque.append((0, s))\nused = {}\nused[s] = True\nwhile que:\n  cost, node = que.popleft()\n  if node == t:\n    print(cost)\n    break\n  for to in edges[node]:\n    if not to in used:\n      used[to] = True\n      que.append((cost + 1, to))\n \n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::io::{self, Read};\nuse std::collections::HashMap;\n\n#[macro_use]\nmod parser {\n    macro_rules! input {\n    ($s:expr=>$($t:tt)*) => {\n        let mut lines=$s.split(\"\\n\");\n        $(\n            line_parse!(lines,$t);\n        )*\n    };\n    }\n\n    macro_rules! line_parse {\n    ($lines:expr,($($name:ident:$t:tt)*)) => {\n        let mut line=$lines.next().unwrap().split_whitespace();\n        $(value_def!(line,$name,$t);)*\n    };\n\n    //複数行\n    ($lines:expr,{$n:expr;$name:ident:$t:tt}) => {\n        values_def!($lines,$n,$name,$t);\n    };\n    }\n\n    macro_rules! value_def {\n    ($line:expr,$name:ident,$t:tt) => {\n        let $name=value!($line,$t);\n    };\n    }\n\n    macro_rules! values_def {\n    ($lines:expr,$n:expr,$name:ident,$t:tt) => {\n        let $name={\n        let mut vec=Vec::new();\n        for i in 0..$n{\n            let mut next=$lines.next().unwrap().split_whitespace();\n            vec.push(value!(next,$t));\n        }\n        vec\n        };\n    };\n    }\n\n    macro_rules! value {\n    //配列\n    ($line:expr,[$t:tt]) => {\n        $line.map(|x|{\n        let mut iter=::std::iter::once(x);\n        value!(iter,$t)\n        }).collect::<Vec<_>>()\n    };\n    //タプル\n    ($line:expr,($($t:tt),*)) => {\n        ($(value!($line,$t),)*)\n    };\n    //文字列\n    ($line:expr,#) => {\n        $line.next().unwrap()\n    };\n    //単一値\n    ($line:expr,$t:ty) => {\n        $line.next().unwrap().parse::<$t>().unwrap()\n    };\n    }\n}\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    let output = run(input.trim().to_string());\n    println!(\"{}\", output);\n}\n\nfn run(input: String) -> String {\n    input!(input=>(h:usize w:usize s:# t:#){h;list:#});\n    let s=s.chars().next().unwrap();\n    let t=t.chars().next().unwrap();\n    let list = list.into_iter()\n        .map(|x| x.chars().collect::<Vec<_>>())\n        .collect::<Vec<_>>();\n    let nodes=list.clone()\n        .into_iter()\n        .enumerate()\n        .flat_map(|(y, s)| {\n            s.into_iter()\n                .enumerate()\n                .filter(|&(x, c)| is_az(c))\n                .zip(std::iter::repeat(y))\n                .map(|((x, c),y)| {\n                    let top = y>=2&&list.get(y - 2).and_then(|i| i.get(x)) == Some(&'|');\n                    let bottom = list.get(y + 2).and_then(|i| i.get(x)) == Some(&'|');\n                    let left = x>=2&&list.get(y).and_then(|i| i.get(x - 2)) == Some(&'-');\n                    let right = list.get(y).and_then(|i| i.get(x + 2)) == Some(&'-');\n                    (c, y, x, top, bottom, left, right)\n                })\n        })\n        .enumerate()\n        .collect::<Vec<_>>();\n\n    //ID to Name\n    let id2name=nodes.clone().into_iter().map(|(_,(c,_,_,_,_,_,_))|c).collect::<Vec<_>>();\n    let name2id={\n        let mut map=HashMap::new();\n        for (i,x) in id2name.clone().into_iter().enumerate(){\n            map.insert(x,i);\n        }\n        map\n    };\n\n    \n    let arena=graph::NodeArena{\n        arena:nodes.into_iter().map(|(id, (c, y, x, top, bottom, left, right))| {\n            let mut paths=Vec::new();\n            if top {\n                paths.push(*name2id.get(&(0..y).rev().map(|i|list[i][x]).find(|&c|is_az(c)).unwrap()).unwrap());\n            }\n\n            if bottom {\n                paths.push(*name2id.get(&((y+1)..h).map(|i|list[i][x]).find(|&c|is_az(c)).unwrap()).unwrap());\n            }\n\n            if left {\n                paths.push(*name2id.get(&(0..x).rev().map(|i|list[y][i]).find(|&c|is_az(c)).unwrap()).unwrap());\n            }\n\n            if right {\n                paths.push(*name2id.get(&((x+1)..w).map(|i|list[y][i]).find(|&c|is_az(c)).unwrap()).unwrap());\n            }\n\n            graph::Node{\n                id:id,\n                edges:paths.into_iter().map(|to|graph::Edge{to:to,cost:1}).collect()\n            }\n        })\n        .collect()\n    };\n\n    let mut dij = dijsktra::Dijsktra::new(arena);\n    dij.dijsktra(*name2id.get(&s).unwrap());\n    dij.cost(*name2id.get(&t).unwrap()).unwrap().to_string()\n}\n\nfn is_az(c: char) -> bool {\n    'A' <= c && c <= 'Z'\n}\n\nmod graph {\n    //http://agtn.hatenablog.com/entry/2017/01/16/151745\n\n    pub type NodeId = usize;\n\n    pub struct NodeArena {\n        pub arena: Vec<Node>,\n    }\n\n    impl NodeArena {\n        pub fn new() -> NodeArena {\n            NodeArena { arena: Vec::new() }\n        }\n\n        pub fn alloc(&mut self) -> NodeId {\n            let id = self.arena.len();\n            let node = Node {\n                id: id,\n                edges: Vec::new(),\n            };\n            self.arena.push(node);\n            id\n        }\n\n        pub fn add_edge(&mut self, node: NodeId, to: NodeId, cost: i32) {\n            self.arena[node].edges.push(Edge { to: to, cost: cost });\n        }\n\n        pub fn get(&self, id: NodeId) -> &Node {\n            &self.arena[id]\n        }\n        pub fn get_mut(&mut self, id: NodeId) -> &mut Node {\n            &mut self.arena[id]\n        }\n    }\n\n    #[derive(PartialEq, Debug, Clone)]\n    pub struct Node {\n        pub id: NodeId,\n        pub edges: Vec<Edge>,\n    }\n\n    #[derive(PartialEq, Debug, Clone)]\n    pub struct Edge {\n        pub to: NodeId,\n        pub cost: i32,\n    }\n}\n\nmod dijsktra {\n    use std::cmp::Ordering;\n    use std::collections::BinaryHeap;\n    use graph;\n\n    #[derive(PartialEq, Debug, Clone)]\n    pub struct Node {\n        pub edges: Vec<graph::Edge>,\n        pub done: bool,\n        pub cost: Option<i32>,\n        pub before: Option<usize>,\n    }\n\n    impl Node {\n        pub fn new(node: graph::Node) -> Node {\n            Node {\n                edges: node.edges,\n                done: false,\n                cost: None,\n                before: None,\n            }\n        }\n\n        pub fn set_start(&mut self) {\n            self.cost = Some(0);\n        }\n    }\n\n    #[derive(PartialEq, Debug, Clone)]\n    pub struct Dijsktra {\n        pub nodes: Vec<Node>,\n    }\n\n    impl Dijsktra {\n        pub fn new(nodes: graph::NodeArena) -> Dijsktra {\n            Dijsktra {\n                nodes: nodes\n                    .arena\n                    .into_iter()\n                    .map(|node| Node::new(node))\n                    .collect::<Vec<_>>(),\n            }\n        }\n\n        pub fn cost(&self, node: graph::NodeId) -> Option<i32> {\n            self.nodes[node].cost\n        }\n\n        pub fn dijsktra(&mut self, start: graph::NodeId) {\n            let mut heap = BinaryHeap::new();\n            heap.push(State {\n                cost: 0,\n                node: start,\n            });\n            self.nodes[start].set_start();\n\n            self.dijsktra_r(&mut heap);\n        }\n        //スタートのコストを0とすること\n        fn dijsktra_r(&mut self, heap: &mut BinaryHeap<State>) {\n            let done_node = heap.pop().map(|State { node, cost: _ }| node);\n\n            if let Some(done_node) = done_node {\n                self.nodes[done_node].done = true;\n                for edge in self.nodes[done_node].edges.clone() {\n                    let cost = self.nodes[done_node].cost.unwrap() + edge.cost;\n                    if self.nodes[edge.to]\n                        .cost\n                        .map(|to_cost| cost < to_cost)\n                        .unwrap_or(true)\n                    {\n                        self.nodes[edge.to].cost = Some(cost);\n                        self.nodes[edge.to].before = Some(done_node);\n                        heap.push(State {\n                            node: edge.to,\n                            cost: cost,\n                        });\n                    }\n                }\n\n                self.dijsktra_r(heap);\n            }\n        }\n\n        pub fn path(&self, goal: usize) -> Vec<usize> {\n            let mut path = Vec::new();\n            path.push(goal);\n            let mut current = goal;\n            while let Some(node) = self.nodes[current].before {\n                path.push(node);\n                current = node;\n            }\n            path.reverse();\n            path\n        }\n    }\n\n    #[derive(Copy, Clone, Eq, PartialEq)]\n    struct State {\n        cost: i32,\n        node: usize,\n    }\n\n    impl Ord for State {\n        fn cmp(&self, other: &State) -> Ordering {\n            other.cost.cmp(&self.cost)\n        }\n    }\n\n    impl PartialOrd for State {\n        fn partial_cmp(&self, other: &State) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n}\n\nmacro_rules! tests {\n    ($($name:ident: $input:expr=>$output:expr,)*) => {\n        mod tests {\n            $(\n                #[test]\n                fn $name() {\n                    assert_eq!(super::run($input.to_string()), $output.to_string());\n                }\n            )*\n        }\n    }\n}\n\ntests! {\n    test1: \"14 16 A L \nooo.....ooo.....\noAo-----oHo.....\nooo.....ooo..ooo\n.|.......|...oLo\nooo..ooo.|...ooo\noKo--oYo.|....|.\nooo..ooo.|....|.\n.|....|.ooo...|.\n.|....|.oGo...|.\n.|....|.ooo...|.\n.|....|.......|.\nooo..ooo.....ooo\noFo--oXo-----oEo\nooo..ooo.....ooo\" => \"5\",\n    test2: \"21 17 F L\n.................\n.....ooo.....ooo.\n.....oAo-----oBo.\n.....ooo.....ooo.\n......|.......|..\n.ooo..|..ooo..|..\n.oCo..|..oDo.ooo.\n.ooo.ooo.ooo.oEo.\n..|..oFo..|..ooo.\n..|..ooo..|...|..\n..|...|...|...|..\n..|...|...|...|..\n..|...|...|...|..\n.ooo.ooo.ooo..|..\n.oGo-oHo-oIo..|..\n.ooo.ooo.ooo..|..\n..|...........|..\n.ooo...ooo...ooo.\n.oJo---oKo---oLo.\n.ooo...ooo...ooo.\n.................\" => \"4\",\n}\n\n"
  }
]