[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n#define MAX_H 100\n#define MAX_W 100\n\nchar graph[MAX_H][MAX_W];\nint dist[MAX_H][MAX_W];\nint H, W;\n\nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\n\npair<int, int> find_vertex(char vertex) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (graph[i][j] == vertex) {\n                return {i, j};\n            }\n        }\n    }\n    return {-1, -1};\n}\n\nint bfs(char s, char t) {\n    pair<int, int> start = find_vertex(s);\n    pair<int, int> end = find_vertex(t);\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n\n    queue<pair<int, int>> q;\n    q.push(start);\n    dist[start.first][start.second] = 0;\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        if (x == end.first && y == end.second) {\n            return dist[x][y];\n        }\n\n        for (int k = 0; k < 8; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                if (graph[nx][ny] == 'o' || graph[nx][ny] == t) {\n                    if (dist[nx][ny] > dist[x][y] + 1) {\n                        dist[nx][ny] = dist[x][y] + 1;\n                        q.push({nx, ny});\n                    }\n                }\n                if ((graph[nx][ny] == '-' || graph[nx][ny] == '|') && \n                    dist[nx][ny] > dist[x][y] + 1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    char s, t;\n    scanf(\" %c %c\", &s, &t);\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", graph[i]);\n    }\n\n    int shortest_path = bfs(s, t);\n    printf(\"%d\\n\", shortest_path);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point point;\n    int dist;\n} Node;\n\nchar grid[MAX_H][MAX_W];\nint dist[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nPoint vertices[26];\nint H, W;\nchar s, t;\nPoint start, end;\n\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool is_vertex(char c) {\n    return c >= 'A' && c <= 'Z';\n}\n\nvoid find_vertices() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (is_vertex(grid[i][j])) {\n                vertices[grid[i][j] - 'A'] = (Point){j, i};\n            }\n        }\n    }\n}\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < W && y >= 0 && y < H;\n}\n\nint bfs() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dist[i][j] = INT_MAX;\n            visited[i][j] = false;\n        }\n    }\n    \n    Point queue[MAX_H * MAX_W];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n    dist[start.y][start.x] = 0;\n    visited[start.y][start.x] = true;\n    \n    while (front < rear) {\n        Point current = queue[front++];\n        \n        if (current.x == end.x && current.y == end.y) {\n            return dist[current.y][current.x];\n        }\n        \n        for (int i = 0; i < 8; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            \n            if (is_valid(nx, ny) && !visited[ny][nx] && grid[ny][nx] == 'o') {\n                for (int j = 0; j < 8; j++) {\n                    int vx = nx + dx[j];\n                    int vy = ny + dy[j];\n                    if (is_valid(vx, vy) && is_vertex(grid[vy][vx])) {\n                        visited[ny][nx] = true;\n                        dist[ny][nx] = dist[current.y][current.x] + 1;\n                        queue[rear++] = (Point){nx, ny};\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    scanf(\" %c %c\", &s, &t);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\" %[^\\n]\", grid[i]);\n    }\n    \n    find_vertices();\n    start = vertices[s - 'A'];\n    end = vertices[t - 'A'];\n    \n    int result = bfs();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\nint main() {\n    int H, W;\n    char s, t;\n    cin >> H >> W >> s >> t;\n    cin.ignore();\n\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        getline(cin, grid[i]);\n    }\n\n    map<char, vector<Point>> vertices;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (isalpha(grid[i][j]) && isupper(grid[i][j])) {\n                vertices[grid[i][j]].emplace_back(i, j);\n            }\n        }\n    }\n\n    if (vertices.find(s) == vertices.end() || vertices.find(t) == vertices.end()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    map<Point, int> dist;\n    queue<Point> q;\n\n    for (auto &p : vertices[s]) {\n        dist[p] = 0;\n        q.push(p);\n    }\n\n    int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};\n    int dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    while (!q.empty()) {\n        Point current = q.front();\n        q.pop();\n\n        if (grid[current.x][current.y] == t) {\n            cout << dist[current] << endl;\n            return 0;\n        }\n\n        for (int i = 0; i < 8; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == 'o') {\n                Point neighbor(nx, ny);\n                if (dist.find(neighbor) == dist.end()) {\n                    dist[neighbor] = dist[current] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                char c = grid[nx][ny];\n                if (isalpha(c) && isupper(c) && c != grid[current.x][current.y]) {\n                    for (auto &p : vertices[c]) {\n                        if (dist.find(p) == dist.end()) {\n                            dist[p] = dist[current] + 1;\n                            q.push(p);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShortestPathInAA {\n    static class Node {\n        char c;\n        int x, y;\n        int dist;\n\n        Node(char c, int x, int y, int dist) {\n            this.c = c;\n            this.x = x;\n            this.y = y;\n            this.dist = dist;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        sc.nextLine();\n        char s = sc.next().charAt(0);\n        char t = sc.next().charAt(0);\n        sc.nextLine();\n\n        char[][] grid = new char[H][W];\n        Map<Character, List<int[]>> vertices = new HashMap<>();\n\n        for (int i = 0; i < H; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                if (Character.isUpperCase(grid[i][j])) {\n                    vertices.computeIfAbsent(grid[i][j], k -> new ArrayList<>()).add(new int[]{i, j});\n                }\n            }\n        }\n\n        Map<Character, Map<Character, Integer>> adj = new HashMap<>();\n        for (char u : vertices.keySet()) {\n            adj.put(u, new HashMap<>());\n        }\n\n        int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};\n        int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n        for (char u : vertices.keySet()) {\n            List<int[]> positions = vertices.get(u);\n            for (int[] pos : positions) {\n                int x = pos[0];\n                int y = pos[1];\n                for (int d = 0; d < 8; d++) {\n                    int nx = x + dx[d];\n                    int ny = y + dy[d];\n                    if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == 'o') {\n                        exploreEdge(u, nx, ny, grid, adj, H, W);\n                    }\n                }\n            }\n        }\n\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(node -> node.dist));\n        Map<Character, Integer> dist = new HashMap<>();\n        for (char u : vertices.keySet()) {\n            dist.put(u, Integer.MAX_VALUE);\n        }\n        dist.put(s, 0);\n        pq.add(new Node(s, 0, 0, 0));\n\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            char u = node.c;\n            if (u == t) {\n                System.out.println(node.dist);\n                return;\n            }\n            if (node.dist > dist.get(u)) continue;\n\n            for (Map.Entry<Character, Integer> entry : adj.get(u).entrySet()) {\n                char v = entry.getKey();\n                int weight = entry.getValue();\n                if (dist.get(u) + weight < dist.get(v)) {\n                    dist.put(v, dist.get(u) + weight);\n                    pq.add(new Node(v, 0, 0, dist.get(v)));\n                }\n            }\n        }\n\n        System.out.println(-1);\n    }\n\n    static void exploreEdge(char u, int x, int y, char[][] grid, Map<Character, Map<Character, Integer>> adj, int H, int W) {\n        Queue<int[]> q = new LinkedList<>();\n        boolean[][] visited = new boolean[H][W];\n        q.add(new int[]{x, y, 0});\n        visited[x][y] = true;\n\n        while (!q.isEmpty()) {\n            int[] curr = q.poll();\n            int cx = curr[0], cy = curr[1], cd = curr[2];\n\n            for (int[] dir : new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n                int nx = cx + dir[0];\n                int ny = cy + dir[1];\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                    if (grid[nx][ny] == '-' || grid[nx][ny] == '|') {\n                        visited[nx][ny] = true;\n                        q.add(new int[]{nx, ny, cd + 1});\n                    } else if (Character.isUpperCase(grid[nx][ny])) {\n                        char v = grid[nx][ny];\n                        if (!adj.get(u).containsKey(v) || adj.get(u).get(v) > cd + 1) {\n                            adj.get(u).put(v, cd + 1);\n                            adj.get(v).put(u, cd + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:04:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphShortestPath {\n    static class Point {\n        int x, y, dist;\n        Point(int x, int y, int dist) {\n            this.x = x;\n            this.y = y;\n            this.dist = dist;\n        }\n    }\n\n    public static int findShortestPath(char[][] graph, char start, char end) {\n        int H = graph.length;\n        int W = graph[0].length;\n        boolean[][] visited = new boolean[H][W];\n        Queue<Point> queue = new LinkedList<>();\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (graph[i][j] == start) {\n                    queue.offer(new Point(i, j, 0));\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        int[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}, {-1,-1}, {-1,1}, {1,-1}, {1,1}};\n\n        while (!queue.isEmpty()) {\n            Point curr = queue.poll();\n\n            if (graph[curr.x][curr.y] == end) {\n                return curr.dist;\n            }\n\n            for (int[] dir : dirs) {\n                int nx = curr.x + dir[0];\n                int ny = curr.y + dir[1];\n\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                    if (graph[nx][ny] == 'o' || graph[nx][ny] == '-' || graph[nx][ny] == '|' || graph[nx][ny] == end) {\n                        queue.offer(new Point(nx, ny, curr.dist + 1));\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        char start = scanner.next().charAt(0);\n        char end = scanner.next().charAt(0);\n        scanner.nextLine();\n\n        char[][] graph = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = scanner.nextLine();\n            graph[i] = line.toCharArray();\n        }\n\n        int result = findShortestPath(graph, start, end);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:04:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_H = 105, MAX_W = 105;\nchar grid[MAX_H][MAX_W];\nint H, W;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nstruct Node {\n    int x, y, dist;\n};\n\nint bfs(char start, char end) {\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<Node> q;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == start) {\n                q.push({i, j, 0});\n                visited[i][j] = true;\n            }\n        }\n    }\n    \n    while (!q.empty()) {\n        Node curr = q.front();\n        q.pop();\n        \n        if (grid[curr.x][curr.y] == end) {\n            return curr.dist;\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = curr.x + dx[k];\n            int ny = curr.y + dy[k];\n            \n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                if (k == 0 && grid[nx][ny] == '|') {\n                    q.push({nx, ny, curr.dist + 1});\n                    visited[nx][ny] = true;\n                }\n                if (k == 1 && grid[nx][ny] == '|') {\n                    q.push({nx, ny, curr.dist + 1});\n                    visited[nx][ny] = true;\n                }\n                if (k == 2 && grid[nx][ny] == '-') {\n                    q.push({nx, ny, curr.dist + 1});\n                    visited[nx][ny] = true;\n                }\n                if (k == 3 && grid[nx][ny] == '-') {\n                    q.push({nx, ny, curr.dist + 1});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    cin >> H >> W;\n    char s, t;\n    cin >> s >> t;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int result = bfs(s, t);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef parse_graph(H, W, graph_lines):\n    vertices = {}\n    edges = []\n\n    for i in range(H):\n        for j in range(W):\n            char = graph_lines[i][j]\n            if char.isupper():\n                vertices[char] = (i, j)\n            elif char == '-':\n                edges.append(((i, j), (i, j+1)))\n            elif char == '|':\n                edges.append(((i, j), (i+1, j)))\n\n    return vertices, edges\n\ndef build_adjacency_list(vertices, edges):\n    adj_list = {v: [] for v in vertices}\n\n    for (x1, y1), (x2, y2) in edges:\n        v1 = next((v for v in vertices if vertices[v] == (x1, y1 - 1) or vertices[v] == (x1, y2)), None)\n        v2 = next((v for v in vertices if vertices[v] == (x2, y1 - 1) or vertices[v] == (x2, y2)), None)\n        if v1 and v2:\n            adj_list[v1].append(v2)\n            adj_list[v2].append(v1)\n\n    return adj_list\n\ndef bfs_shortest_path(adj_list, start, end):\n    queue = deque([(start, 0)])\n    visited = set()\n\n    while queue:\n        current, dist = queue.popleft()\n        if current in visited:\n            continue\n        visited.add(current)\n        \n        if current == end:\n            return dist\n\n        for neighbor in adj_list[current]:\n            if neighbor not in visited:\n                queue.append((neighbor, dist + 1))\n\n    return -1\n\ndef shortest_path_length(H, W, s, t, graph_lines):\n    vertices, edges = parse_graph(H, W, graph_lines)\n    adj_list = build_adjacency_list(vertices, edges)\n    return bfs_shortest_path(adj_list, s, t)\n\n# Sample usage\nH, W = 7, 7\ns, t = 'A', 'C'\ngraph_lines = [\n    'ooooAoooo',\n    '    |    ',\n    'oooo|oooo',\n    '    |    ',\n    'ooooBoooo',\n    '    |    ',\n    'ooooCoooo',\n]\n\nprint(shortest_path_length(H, W, s, t, graph_lines))",
    "timestamp": "2025-08-13 08:40:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ShortestPathAsciiGraph {\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        char startVertex = scanner.next().charAt(0);\n        char endVertex = scanner.next().charAt(0);\n        scanner.nextLine();  // Consume the rest of the line\n\n        char[][] graph = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            graph[i] = scanner.nextLine().toCharArray();\n        }\n\n        int result = findShortestPath(H, W, graph, startVertex, endVertex);\n        System.out.println(result);\n    }\n\n    private static int findShortestPath(int H, int W, char[][] graph, char startVertex, char endVertex) {\n        Map<Character, int[]> vertices = new HashMap<>();\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (Character.isUpperCase(graph[i][j])) {\n                    vertices.put(graph[i][j], new int[]{i, j});\n                }\n            }\n        }\n\n        int[] startPos = vertices.get(startVertex);\n        int[] endPos = vertices.get(endVertex);\n\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(startPos);\n        boolean[][] visited = new boolean[H][W];\n        visited[startPos[0]][startPos[1]] = true;\n        int steps = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = queue.poll();\n                if (pos[0] == endPos[0] && pos[1] == endPos[1]) {\n                    return steps;\n                }\n                for (int dir = 0; dir < 4; dir++) {\n                    int newX = pos[0] + dx[dir];\n                    int newY = pos[1] + dy[dir];\n                    if (newX >= 0 && newX < H && newY >= 0 && newY < W && !visited[newX][newY]) {\n                        if (graph[newX][newY] == '-' || graph[newX][newY] == '|') {\n                            queue.add(new int[]{newX + dx[dir], newY + dy[dir]});\n                            visited[newX + dx[dir]][newY + dy[dir]] = true;\n                        } else if (Character.isUpperCase(graph[newX][newY])) {\n                            queue.add(new int[]{newX, newY});\n                            visited[newX][newY] = true;\n                        }\n                    }\n                }\n            }\n            steps++;\n        }\n        return -1;  // In case there is no path\n    }\n}",
    "timestamp": "2025-08-13 08:41:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\nint get_position(char grid[MAX_SIZE][MAX_SIZE], int H, int W, char vertex, int *x, int *y) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == vertex) {\n                *x = i;\n                *y = j;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint bfs(char grid[MAX_SIZE][MAX_SIZE], int H, int W, int startX, int startY, char target) {\n    int visited[MAX_SIZE][MAX_SIZE] = {0};\n    int queue[MAX_SIZE * MAX_SIZE][3];\n    int front = 0, rear = 0;\n\n    queue[rear][0] = startX;\n    queue[rear][1] = startY;\n    queue[rear][2] = 0;\n    rear++;\n    visited[startX][startY] = 1;\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    while (front < rear) {\n        int x = queue[front][0];\n        int y = queue[front][1];\n        int dist = queue[front][2];\n        front++;\n\n        if (grid[x][y] == target) {\n            return dist;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                if ((grid[nx][ny] >= 'A' && grid[nx][ny] <= 'Z') || grid[nx][ny] == '-' || grid[nx][ny] == '|') {\n                    visited[nx][ny] = 1;\n                    queue[rear][0] = nx;\n                    queue[rear][1] = ny;\n                    queue[rear][2] = dist + 1;\n                    rear++;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int H, W;\n    char s, t;\n    scanf(\"%d %d\", &H, &W);\n    scanf(\" %c %c\", &s, &t);\n    \n    char grid[MAX_SIZE][MAX_SIZE];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int startX, startY;\n    if (!get_position(grid, H, W, s, &startX, &startY)) {\n        printf(\"Start vertex not found\\n\");\n        return -1;\n    }\n\n    int length = bfs(grid, H, W, startX, startY, t);\n    printf(\"%d\\n\", length);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:41:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_ascii_graph(H, W, s, t, graph):\n    # Find coordinates of all vertices\n    vertices = {}\n    for i in range(H):\n        for j in range(W):\n            if graph[i][j].isupper():\n                vertices[graph[i][j]] = (i, j)\n    \n    # BFS to find shortest path\n    def bfs(start, end):\n        queue = deque([(start, 0)])\n        visited = set([start])\n        \n        while queue:\n            curr, dist = queue.popleft()\n            \n            if curr == end:\n                return dist\n            \n            # Check 4 directions\n            directions = [(0,1), (0,-1), (1,0), (-1,0)]\n            x, y = vertices[curr]\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                # Check if within bounds and is an edge or vertex\n                if 0 <= nx < H and 0 <= ny < W:\n                    # If vertex found\n                    if graph[nx][ny].isupper() and graph[nx][ny] not in visited:\n                        queue.append((graph[nx][ny], dist + 1))\n                        visited.add(graph[nx][ny])\n                    \n                    # If horizontal/vertical edge found\n                    elif graph[nx][ny] in '-|':\n                        # Try to find next vertex\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < H and 0 <= nny < W and graph[nnx][nny].isupper():\n                                if graph[nnx][nny] not in visited:\n                                    queue.append((graph[nnx][nny], dist + 1))\n                                    visited.add(graph[nnx][nny])\n                                break\n        \n        return -1  # No path found\n    \n    return bfs(s, t)\n\n# Read input\nH, W = map(int, input().split())\ns, t = input().split()\n\n# Read graph\ngraph = [input() for _ in range(H)]\n\n# Print result\nprint(solve_ascii_graph(H, W, s, t, graph))",
    "timestamp": "2025-08-13 08:41:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    s, t = sys.stdin.readline().split()\n    grid = [sys.stdin.readline().rstrip() for _ in range(H)]\n    \n    # Find positions of all vertices\n    vertices = {}\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j].isupper():\n                vertices[grid[i][j]] = (i, j)\n    \n    if s not in vertices or t not in vertices:\n        print(-1)\n        return\n    \n    start_pos = vertices[s]\n    end_pos = vertices[t]\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    visited = [[-1 for _ in range(W)] for _ in range(H)]\n    q = deque()\n    q.append(start_pos)\n    visited[start_pos[0]][start_pos[1]] = 0\n    \n    found = False\n    while q:\n        i, j = q.popleft()\n        if (i, j) == end_pos:\n            found = True\n            break\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            # Check if within bounds\n            if 0 <= ni < H and 0 <= nj < W:\n                # Check if it's a valid move (edge or vertex)\n                if grid[ni][nj] == '-' or grid[ni][nj] == '|' or grid[ni][nj].isupper():\n                    if visited[ni][nj] == -1:\n                        visited[ni][nj] = visited[i][j] + 1\n                        q.append((ni, nj))\n    \n    if found:\n        print(visited[end_pos[0]][end_pos[1]])\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 08:41:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <limits>\n\nusing namespace std;\n\nstruct Position {\n    int x, y;\n};\n\nbool isValid(int x, int y, int H, int W, const vector<string>& graph) {\n    return x >= 0 && x < H && y >= 0 && y < W && graph[x][y] != ' ';\n}\n\nint bfs(const vector<string>& graph, Position start, Position end) {\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int H = graph.size();\n    int W = graph[0].size();\n    vector<vector<int>> distance(H, vector<int>(W, numeric_limits<int>::max()));\n    queue<Position> q;\n    q.push(start);\n    distance[start.x][start.y] = 0;\n\n    while (!q.empty()) {\n        Position current = q.front();\n        q.pop();\n\n        for (const auto& dir : directions) {\n            int nx = current.x + dir[0];\n            int ny = current.y + dir[1];\n\n            if (isValid(nx, ny, H, W, graph) && distance[nx][ny] == numeric_limits<int>::max()) {\n                distance[nx][ny] = distance[current.x][current.y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    return distance[end.x][end.y];\n}\n\nint main() {\n    int H, W;\n    char startVertex, endVertex;\n    cin >> H >> W >> startVertex >> endVertex;\n\n    vector<string> graph(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> graph[i];\n    }\n\n    unordered_map<char, Position> vertexPositions;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            char ch = graph[i][j];\n            if (ch >= 'A' && ch <= 'Z') {\n                vertexPositions[ch] = {i, j};\n            }\n        }\n    }\n\n    Position start = vertexPositions[startVertex];\n    Position end = vertexPositions[endVertex];\n    \n    int shortestPathLength = bfs(graph, start, end);\n    cout << shortestPathLength << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:32"
  }
]