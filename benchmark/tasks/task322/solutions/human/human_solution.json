[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n    int n,m;\n    while(cin >> n >> m,n){\n        vector<int> a(n+1,0),b(n+1,0);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i+1];\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> b[i+1];\n        }\n        vector<vector<int>> dp(n+1,vector<int> (n+3,INF));\n        dp[0][0]=0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if(b[i+1]+m*(j+1)-a[i+1]>b[i]+m*j-a[i]) dp[i+1][j+1] = min(dp[i+1][j+1],dp[i][j]+b[i+1]+(j+1)*m-a[i+1]-(b[i]+m*j-a[i]));\n                else dp[i+1][j+1] = min(dp[i+1][j+1],dp[i][j]);\n\n                if(b[i+1]+m*(j+2)-a[i+1]>b[i]+m*j-a[i]) dp[i+1][j+2] = min(dp[i+1][j+2],dp[i][j]+b[i+1]+(j+2)*m-a[i+1]-(b[i]+m*j-a[i]));\n                else dp[i+1][j+2] = min(dp[i+1][j+2],dp[i][j]);\n\n                if(j&&a[i+1]<=b[i+1]+m*(j-1)){\n                    if(b[i+1]+m*(j-1)-a[i+1]>b[i]+m*j-a[i]) dp[i+1][j-1] = min(dp[i+1][j-1],dp[i][j]+b[i+1]+(j-1)*m-a[i+1]-(b[i]+m*j-a[i]));\n                    else dp[i+1][j-1] = min(dp[i+1][j-1],dp[i][j]);\n                }\n\n                if(j-1&&a[i+1]<=b[i+1]+m*(j-2)){\n                    if(b[i+1]+m*(j-2)-a[i+1]>b[i]+m*j-a[i]) dp[i+1][j-2] = min(dp[i+1][j-2],dp[i][j]+b[i+1]+(j-2)*m-a[i+1]-(b[i]+m*j-a[i]));\n                    else dp[i+1][j-2] = min(dp[i+1][j-2],dp[i][j]);\n                }\n                if(a[i+1]<=b[i+1]+m*j){\n                    if(b[i+1]+m*j-a[i+1]>b[i]+m*j-a[i]) dp[i+1][j] = min(dp[i+1][j],dp[i][j]+b[i+1]+m*j-a[i+1]-(b[i]+m*j-a[i]));\n                    else dp[i+1][j] = min(dp[i+1][j],dp[i][j]);\n                }\n            }\n        }\n        int ans=INF;\n        for (int i = 0; i < n+2; i++) {\n            ans = min(ans,dp[n][i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N,M;\nint A[1000],B[1000],D[1000];\nint dp[1000][1001];\nmain()\n{\n\twhile(cin>>N>>M,N)\n\t{\n\t\tfor(int i=0;i<N;i++)cin>>A[i];\n\t\tfor(int i=0;i<N;i++)cin>>B[i];\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tD[i]=(B[i]-A[i]+M)%M;\n\t\t}\n\t\tdp[0][0]=D[0];\n\t\tfor(int i=1;i<=N;i++)dp[0][i]=1e9;\n\t\tdp[0][1]=1e9;\n\t\tfor(int i=1;i<N;i++)\n\t\t{\n\t\t    for(int j=0;j<=N;j++)dp[i][j]=1e9;\n\t\t\tfor(int j=i;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(D[i-1]>=D[i])\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t\tif(j>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j-1]+M+D[i]-D[i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i-1][j+1],dp[i-1][j]+D[i]-D[i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=0;i<N;i++)ans=min(ans,dp[N-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nint a[1005],b[1005];\nvector<int> vec[1005];\nll dp[1005][2020];\n\nvoid solve(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n*2;j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<=n;i++){\n\t\tvec[i].clear();\n\t}\n\tvec[0].push_back(0);\n\tfor(int i=0;i<n;i++){\n\t\tint dif=b[i]-a[i];\n\t\tif(dif<0){\n\t\t\tdif+=m;\n\t\t}\n\t\tfor(int j=0;j<n*2;j++){\n\t\t\tvec[i+1].push_back(dif);\n\t\t\tdif+=m;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<vec[i].size();j++){\n\t\t\tif(dp[i][j]==INF)continue;\n\t\t\tint pos=lower_bound(vec[i+1].begin(),vec[i+1].end(),vec[i][j])-vec[i+1].begin();\n\t\t\tif(pos>0){\n\t\t\t\tll dif=vec[i+1][pos-1]-vec[i][j];\n\t\t\t\tif(dif<0)dif=0;\n\t\t\t\tdp[i+1][pos-1]=min(dp[i+1][pos-1],dp[i][j]+dif);\n\t\t\t}\n\t\t\tif(pos<vec[i+1].size()){\n\t\t\t\tll dif=vec[i+1][pos]-vec[i][j];\n\t\t\t\tif(dif<0)dif=0;\n\t\t\t\tdp[i+1][pos]=min(dp[i+1][pos],dp[i][j]+dif);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=0;i<vec[n].size();i++){\n\t\tans=min(ans,dp[n][i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&b[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll ans = 0;\nll n, m;\nll a[1005];\nll target[1005];\nll dp[1005][1005];\nll delta[1005];\n\nll chmin(ll &a, ll b) {\n    a = min(a, b);\n}\nint main() {\n    int times = 0;\n    while(true) {\n        cin >> n >> m;\n        if(n == 0) break;\n        times++;\n        //cerr << times << endl;\n        for(int i = 1; i <= n; i++) {\n            cin >> a[i];\n            a[i] %= m;\n        }\n        for(int i = 1; i <= n; i++) {\n            cin >> target[i];\n            target[i] %= m;\n            if(target[i] < a[i]) target[i] += m;\n            delta[i] = target[i] - a[i];\n        }\n        for(int timer = 0; timer <= n; timer++) {\n            dp[1][timer] = delta[1] + timer * m;\n        }\n        for(int index = 2; index <= n; index++) {\n            for(int after = 0; after <= n; after++) {\n                dp[index][after] = 1e18;\n                for(int before = max(0, after - 2); before <= min((int)n, after + 2); before++) {\n                    ll beforedelta = delta[index-1] + m * before;\n                    ll afterdelta = delta[index] + m * after;\n                   // cerr << index << \" \" << before << \" \" << after << \" \" << dp[index-1][before] << endl;\n                    chmin(dp[index][after], dp[index-1][before] + max((ll)0, afterdelta - beforedelta));\n                }\n            }\n        }\n        ll ans = 1e18;\n        for(int timer = 0; timer <= n; timer++) {\n            chmin(ans, dp[n][timer]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n\nint main() {\n    int n, i, j, k;\n    ll m;\n    while(1){\n        cin >> n >> m;\n        if(n==0)break;\n        vector<ll> a(n),b(n),del(n);\n        for(i=0;i<n;i++){\n            cin >> a[i];\n        }\n        for(i=0;i<n;i++){\n            cin >> b[i];\n            del[i]=(b[i]-a[i]+m)%m;\n        }\n        ll dp[n][n+1]; // dp[index][timer] := index番目のタイマーをtimer周多く押したときの最小回数\n        for(i=0;i<=n;i++){\n            dp[0][i] = del[0] + i*m;\n        }\n        \n        for(int index=1;index<n;index++){\n            for(int loop_cnt=0;loop_cnt<=n;loop_cnt++){\n                dp[index][loop_cnt] = INF;\n                for(int bef=max(loop_cnt-1,0);bef<=min(n,loop_cnt+1);bef++){\n                    ll bef_loop = del[index-1] + m * (ll)bef; // ひとつ前のタイマーをbef周させたときの押す回数\n                    ll now_loop = del[index] + m * (ll)loop_cnt; // 今のタイマーをloop_cnt周させたときの押す回数\n                    dp[index][loop_cnt] = min(dp[index][loop_cnt],dp[index-1][bef]+max(0ll,now_loop-bef_loop));\n                }\n            }\n        }\n\n        ll ans = INF;\n        for(i=0;i<=n;i++){\n            ans = min(dp[n-1][i],ans);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e16\nusing namespace std;\n\nlong long n, m;\nvector<long long> a, b, h;\nvector<vector<long long>> dp;\n\nlong long solve();\n\nint main() {\n  while(1) {\n    cin >> n >> m;\n    if(n + m == 0) break;\n    a.resize(n);\n    b.resize(n);\n    for(int i = 0; i < n; ++i) cin >> a[i];\n    for(int i = 0; i < n; ++i) cin >> b[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long ans = inf;\n  h.assign(n + 1, 0);\n  for(int i = 0; i < n; ++i) {\n    h[i + 1] = b[i] - a[i];\n    if(h[i + 1] < 0) h[i + 1] += m;\n  }\n  dp.assign(n + 1, vector<long long>(2 * n, inf));\n  for(int i = 0; i < 2 * n; ++i) dp[0][i] = i * m;\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < 2 * n; ++j)\n      for(int k = -1; k <= 1; ++k)\n        if(j + k >= 0 && j + k < 2 * n) {\n          dp[i + 1][j] =\n              min(dp[i + 1][j],\n                  dp[i][j + k] +\n                      max(0LL, h[i + 1] - h[i] - k * m));\n          if(i == n - 1) ans = min(ans, dp[i + 1][j]);\n        }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf 1000000000000000\n\nusing namespace std;\n\nllint n, m;\nllint a[1005], b[1005];\nllint dp[1005][1005];\n\nint main(void)\n{\n  while(1){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    for(int i = 1; i <= n; i++) cin >> a[i], a[i]--;\n    for(int i = 1; i <= n; i++) cin >> b[i], b[i]--;\n    for(int i = 1; i <= n; i++) a[i] = (b[i]-a[i]+m) % m;\n\n    for(int i = 1; i <= n; i++){\n      for(int j = 0; j <= n; j++){\n        dp[i][j] = inf;\n      }\n    }\n    dp[1][0] = a[1];\n\n    for(int i = 1; i < n; i++){\n      for(int j = 0; j <= n; j++){\n        if(a[i]+j*m >= a[i+1]+j*m){\n          dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n          if(j+1 <= n) dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + (a[i+1]+(j+1)*m) - (a[i]+j*m));\n        }\n        else{\n          if(j > 0) dp[i+1][j-1] = min(dp[i+1][j-1], dp[i][j]);\n          dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (a[i+1]+j*m) - (a[i]+j*m));\n        }\n      }\n    }\n\n    llint ans = inf;\n    for(int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\nint solve(const int max, const std::vector<int>& counter, const std::vector<int>& target, const int counter_pos, const int overflow, std::vector<std::vector<int>>& memo) {\n\tif (counter_pos == 0) {\n\t\treturn solve(max, counter, target, counter_pos + 1, 0, memo) + (target[0] - counter[0] + max) % max;\n\t}\n\telse if (counter_pos == counter.size()) {\n\t\treturn 0;\n\t}\n\telse if (memo[counter_pos][overflow] >= 0) {\n\t\treturn memo[counter_pos][overflow];\n\t}\n\telse {\n\t\tauto prev = (target[counter_pos - 1] - counter[counter_pos - 1] + max) % max;\n\t\tauto temp = (counter[counter_pos] + prev) % max;\n\t\tmemo[counter_pos][overflow] = solve(max, counter, target, counter_pos + 1, (prev + (target[counter_pos] - temp + max) % max >= max) ? overflow + 1 : overflow, memo) + (target[counter_pos] - temp + max) % max;\n\t\tif ((target[counter_pos] - counter[counter_pos] + max) % max <= prev) {\n\t\t\tmemo[counter_pos][overflow] = std::min(memo[counter_pos][overflow], solve(max, counter, target, counter_pos + 1, overflow, memo));\n\t\t}\n\t\tif (overflow > 0) {\n\t\t\tmemo[counter_pos][overflow] = std::min(memo[counter_pos][overflow], solve(max, counter, target, counter_pos + 1, overflow - 1, memo));\n\t\t}\n\t\treturn memo[counter_pos][overflow];\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tint n, m; std::cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tstd::vector<int>counter(n); for (auto& a : counter) std::cin >> a;\n\t\tstd::vector<int>target(n); for (auto& b : target) std::cin >> b;\n\t\tstd::vector<std::vector<int>> memo(n, std::vector<int>(n, -1));\n\t\tstd::cout << solve(m, counter, target, 0, 0, memo) << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os, const map<T,U>& mp){ os << \"{\"; for(auto& p : mp){ os << p << \",\"; } os << \"}\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = std::pair<int,int>;\nusing vi = std::vector<int>;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nvoid solve(ll n,ll m){\n    vector<ll> a(n),b(n);\n    rep(i,n){cin >> a[i];a[i]--;}\n    rep(i,n){cin >> b[i],b[i]--;}\n    vector<ll> c(n);\n    rep(i,n) c[i] = (b[i]-a[i]+m)%m;\n\n    //cout << c << endl;\n\n    // dp[i][j] := i番目までを見たときにi番目がc[i]+jm回操作しているときの最小回数\n    vector<vector<ll>> dp(n+5,vector<ll>(n+5,n*m+10));\n    for(int i=0;i<=n;i++){\n        dp[0][i] = c[0] + i * m;\n    }\n\n    for(int i=1;i<n;i++){\n        for(int j=0;j<=n;j++){\n            for(int k=max<ll>(0,j-3);k<=min<ll>(n,j+3);k++){\n                dp[i][j] = min(dp[i][j], dp[i-1][k] + max(0ll,(c[i]+j*m) - (c[i-1]+k*m)));\n            }\n        }\n    }\n\n    ll ans = LINF;\n    for(int i=0;i<=n;i++){\n        ans = min(ans, dp[n-1][i]);\n    }\n    cout << ans << endl;\n\n    /* for(int i=0;i<=n;i++){ */\n    /*     for(int j=0;j<=m;j++){ */\n    /*         cout << dp[i][j] << \"\\t\"; */\n    /*     } */\n    /*     cout << endl; */\n    /* } */\n}\n\nint main(){\n    while(true){\n        int n,m; cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nInt dp[1010][1010];\ntemplate <class T> void chmin(T& x, T y) { if (x > y) x = y; }\nint main() {\n    for (;;) {\n        Int N, M; cin >> N >> M;\n        if (N == 0) break;\n        vector<Int> A(N); for (auto &a : A) cin >> a;\n        vector<Int> B(N); for (auto &b : B) cin >> b;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N + 1; j++) {\n                dp[i][j] = 1e18;\n            }\n        }\n        for (int j = 0; j < N + 1; j++) {\n            if (B[0] + M * j >= A[0]) {\n                dp[0][j] = B[0] + M * j - A[0];\n            }\n        }\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j <= N; j++) {\n                for (int k = max(0, j - 2); k <= min((int)N, j + 2); k++) {\n                    if (B[i] + M * j >= A[i]) {\n                        Int cost = max(0LL, (B[i] + M * j - A[i]) - (B[i - 1] + M * k - A[i - 1]));\n                        chmin(dp[i][j], dp[i - 1][k] + cost);\n                    }\n                }\n            }\n        }\n        Int ans = 1e18;\n        for (int j = 0; j <= N; j++) {\n            ans = min(ans, dp[N - 1][j]);\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nint dp[1010][1010];\n\nint main(){\n\twhile(1){\n\t\tint n,m; cin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tvector<int> a(n),b(n),c(n+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tc[0]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a[i]==b[i])c[i+1]=0;\n\t\t\telse if(a[i]<b[i])c[i+1]=b[i]-a[i];\n\t\t\telse c[i+1]=b[i]+m-a[i];\n\t\t}\n\t\tfor(int i=0;i<1010;i++){\n\t\t\tfor(int j=0;j<1010;j++){\n\t\t\t\tdp[i][j]=1e9;\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(dp[i][j]==1e9)continue;\n\t\t\t\tif(j>0){\n\t\t\t\t\tdp[i+1][j-1]=min(dp[i+1][j-1],dp[i][j]+(c[i]+j*m<c[i+1]+(j-1)*m?c[i+1]+(j-1)*m-c[i]-j*m:0));\n\t\t\t\t}\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+(c[i]+j*m<c[i+1]+j*m?c[i+1]+j*m-c[i]-j*m:0));\n\t\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+(c[i]+j*m<c[i+1]+(j+1)*m?c[i+1]+(j+1)*m-c[i]-j*m:0));\n\t\t\t}\n\t\t}\n\t\tint ans=1e9;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tans=min(ans,dp[n][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    int N,M;\n    while(cin >> N >> M && N){\n        vector<int> A(N+1,(int)1e9),B(N+1,(int)1e9);\n        for(int i=1;i<=N;i++){\n            cin >> A[i];\n        }\n        for(int i=1;i<=N;i++){\n            cin >> B[i];\n        }\n        vector<vector<int>> dp(N+1,vector<int>(1010,(int) 1e9));\n        vector<vector<int>> mi(N+1,vector<int>(1010,(int) 1e9));\n        dp[0][0] = 0;\n        for(int i=1;i<=N;i++){\n            for(int j=0;j<=N;j++){\n                int now = B[i]-A[i]+j*M;\n                if(now<0) continue;\n                int pre = B[i-1]-A[i-1]+j*M;\n                if(pre>=0) dp[i][j] = min(dp[i][j],dp[i-1][j]+max(now-pre,0));\n                if(j>=1){\n                    for(int k=1;k<=2;k++){\n                        pre = B[i-1]-A[i-1]+(j-k)*M;\n                        if(pre>=0) dp[i][j] = min(dp[i][j],dp[i-1][j-k]+max(now-pre,0));\n                    }\n                }\n                dp[i][j] = min(dp[i][j],mi[i-1][j+2]);\n                pre = B[i-1]-A[i-1]+(j+1)*M;\n                if(pre>=0) dp[i][j] = min(dp[i][j],dp[i-1][j+1]+max(now-pre,0));\n            }\n            for(int j=1000;j>=0;j--) mi[i][j] = min(mi[i][j+1],dp[i][j]);\n        }\n        cout << mi[N][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,m,s[1000],a[1000],b[1000],ans,dp[1000][1001];\nint main(void){\n    while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)return 0;\n    ans=1e9;\n    for(int i=0;i<n;i++)for(int j=0;j<=n;j++)dp[i][j]=1e9;\n    for(int i=0;i<n;i++)cin>>a[i];\n    for(int i=0;i<n;i++)cin>>b[i];\n    for(int i=0;i<n;i++){\n        if(a[i]<b[i])s[i]=b[i]-a[i];\n        else if(a[i]>b[i])s[i]=m+b[i]-a[i];\n        else s[i]=0;\n    }\n    dp[0][0]=s[0];\n    for(int i=1;i<n;i++){\n        for(int j=i;j>=0;j--){\n            if(s[i]<=s[i-1]){\n                dp[i][j]=min(dp[i][j],dp[i-1][j]);\n                if(j>0)dp[i][j]=min(dp[i][j],dp[i-1][j-1]+m-s[i-1]+s[i]);\n            }\n            else{\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+s[i]-s[i-1]);\n                dp[i][j]=min(dp[i][j],dp[i-1][j+1]);\n            }\n            //cout<<dp[i][j]<<endl;\n        }\n    }\n    for(int i=0;i<=n;i++){\n        ans=min(ans,dp[n-1][i]);\n    }\n    cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#ifdef DEBUG\n    #define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n#include <chrono>\n\n#define stdin_filepath \"stdin.txt\"\n#define stdout_filepath \"stdout.txt\"\n#define stderr_filepath \"stderr.txt\"\n#define iostream_untie true\n#define stdout_precision 10\n#define stderr_precision 10\n#define rep(i,n) for(int_fast64_t i = 0; i < (int_fast64_t)(n); ++i)\n#define rrep(i,n) for(int_fast64_t i = (int_fast64_t)(n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcountll\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)2 - (T)1234567;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n\nnamespace execution {\n    std::chrono::system_clock::time_point start, end;\n    void print_elapsed_time() {\n        end = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n        std::cerr << \" ms -----\\n\";\n    }\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                // std::cout.tie(nullptr);\n                // std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(stdout_precision);\n            std::cerr << std::fixed << std::setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(stderr_filepath, \"wt\", stderr)) {\n                freopen(\"CON\", \"wt\", stderr);\n                std::cerr << \"Failed to open the stderr file\\n\";\n            }\n            if(!freopen(stdout_filepath, \"wt\", stdout)) {\n                freopen(\"CON\", \"wt\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\";\n            }\n            if(!freopen(stdin_filepath, \"rt\", stdin)) {\n                freopen(\"CON\", \"rt\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\";\n            }\n            atexit(print_elapsed_time);\n            start = std::chrono::system_clock::now();\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct hashval_calc {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hashval_calc<tuple_t, index - 1>::apply(seed, t);\n            hash_combine(seed,get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct hashval_calc<tuple_t, 0> {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hash_combine(seed,get<0>(t));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& t) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,t);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; }   return s; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; }   return s;\n}\ntemplate <class tuple_t, size_t index>\nstruct tupleos {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        tupleos<tuple_t,index - 1>::apply(s,t);\n        return s << \" \" << get<index>(t);\n    }\n};\ntemplate <class tuple_t>\nstruct tupleos<tuple_t, 0> {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        return s << get<0>(t);\n    }\n};\ntemplate <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t) {\n    return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n}\ntemplate <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n#ifdef DEBUG\n    #define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \", dump_func(__VA_ARGS__)\n#else\n    #define dump(...)\n#endif\ntemplate <class T> void dump_func(const T &x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(const T &x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(const T &x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(const T &x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(const T &x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\ntemplate <class P> void read(P __first, P __second) { for(P i = __first; i != __second; ++i) cin >> *i; }\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n};\nusing updater::add;\nusing updater::mul;\nusing updater::chmax;\nusing updater::chmin;\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool odd(int_fast64_t n) { return n & 1; }\nconstexpr bool even(int_fast64_t n) { return (int)odd(n) ^ 1; }\nconstexpr bool bit(int_fast64_t n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int_fast64_t ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\nconstexpr int_fast64_t gcd(int_fast64_t x, int_fast64_t y) { return x = max(x, -x), y = max(y, -y) ? gcd(y, x % y) : x; }\nconstexpr int_fast64_t lcm(int_fast64_t x, int_fast64_t y) { return x ? x / gcd(x, y) * y : 0; }\nint_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const function<bool(int_fast64_t)> &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array, (T*)(array + N), val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(const T &i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\nvoid for_subset(int_fast64_t s, const function<void(int_fast64_t)> &fn) {\n    int_fast64_t t = s;\n    do { fn(t); } while((--t &= s) != s);\n}\n\n\n/* The main code follows. */\n\n\nsigned main() {\n    void solve();\n    void input();\n    void init();\n\n    int t = 100;\n\n    #ifdef LOCAL\n        // t = 1;\n        // cin >> t;\n    #endif\n\n    // cin >> t;\n\n    while(t--) {\n        init();\n        input();\n        solve();\n    }\n}\n\nint n,m;\nint a[1<<10];\ni64 dp[1<<10][1<<10];\n\n\nvoid init() {\n    \n}\n\nvoid input() {\n    cin>>n>>m;\n    if(!n and !m) exit(0);\n    for(int i=1; i<=n; ++i)\n    {\n        cin>>a[i]; a[i]--;\n    }\n    for(int i=1; i<=n; ++i)\n    {\n        int b; cin>>b; b--;\n        a[i]=(b-a[i]+m)%m;\n    }\n    a[0]=a[n+1]=0;\n}\n\nvoid solve() {\n    init(dp[0],inf<i64>);\n    dp[0][0]=0;\n    for(int i=0; i<=n; ++i)\n    {\n        i64 lft[1010],rgt[1010];\n        lft[0]=rgt[n]=inf<i64>;\n        for(int j=0; j<n; ++j)\n        {\n            lft[1+j]=min(lft[j],dp[i][j]-a[i]-m*j);\n        }\n        for(int j=n-1; j>=0; --j)\n        {\n            rgt[j]=min(rgt[j+1],dp[i][j]+a[i]+m*j);\n        }\n        for(int k=0,h=0; k<n; ++k) {\n            while(h<n and a[i+1]+k*m>a[i]+h*m)\n            {\n                ++h;\n            }\n            dp[i+1][k]=min(lft[h]+a[i+1]+m*k,rgt[h]-a[i+1]-m*k);\n        }\n    }\n    write(dp[n+1][0]/2);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nusing ll = long long;\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n,m;\n  while(cin>>n>>m,n||m){\n    vector<Int> as(n),bs(n);\n    for(Int i=0;i<n;i++) cin>>as[i];\n    for(Int i=0;i<n;i++) cin>>bs[i];\n\n    const Int MAX = 1020;\n    const Int INF = 1e15;\n    vector<Int> dp(MAX,INF);\n    dp[0]=0;\n    Int pre=0;\n    for(Int i=0;i<n;i++){\n      vector<Int> nx(MAX,INF);\n      Int dif=bs[i]-as[i];\n      if(dif<0) dif+=m;\n\n      for(Int j=0;j<MAX;j++){\n        for(Int k=j-10;k<j+10;k++){\n          if(k<0||k>=MAX) continue;\n          if(dif+k*m<=pre+j*m)\n            chmin(nx[k],dp[j]);\n          else\n            chmin(nx[k],dp[j]+(dif+k*m)-(pre+j*m));\n        }\n      }\n\n      pre=dif;\n      swap(dp,nx);\n    }\n    cout<<*min_element(dp.begin(),dp.end())<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst int MAX_N = 1005;\nconst int MAX_K = MAX_N;\nint dp[MAX_N][MAX_K];\n\nint main() {\n\n  for (;;) {\n    int N = nextInt();\n    ll MOD = nextInt();\n    if (N == 0) break;\n    vector<int> a(N), b(N), c(N);\n    REP(i, N) a[i] = nextInt();\n    REP(i, N) b[i] = nextInt();\n    REP(i, N) c[i] = (b[i] - a[i] + MOD) % MOD;\n\n    const int INF = 1001001001;\n    REP(i, MAX_N) REP(j, MAX_K) dp[i][j] = INF;\n\n    dp[0][0] = c[0];\n    for (int i = 1; i < N; i++) {\n      for (int j1 = 0; j1 < MAX_K; j1++) {\n        if (dp[i-1][j1] >= INF) continue;\n        int ac1 = c[i-1] + j1 * MOD;\n        for (int j2 : {j1-1, j1, j1+1}) if (0 <= j2 && j2 < MAX_K) {\n          int ac2 = c[i] + j2 * MOD;\n          int cost = max(0, ac2 - ac1);\n          chmin(dp[i][j2], dp[i-1][j1] + cost);\n        }\n      }\n    }\n    int ans = dp[N-1][0];\n    REP(j, MAX_K) chmin(ans, dp[N-1][j]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool solve() {\n  // Inputs\n  int n, m;\n  cin >> n >> m;\n  if (n == 0 && m == 0) {\n    return false;\n  }\n  vector<int> a(n), b(n);\n  for (int &i : a) {\n    cin >> i;\n  }\n  for (int &i : b) {\n    cin >> i;\n  }\n\n  // Calculate the minimum number of button presses for each counter\n  vector<int> c(n);\n  for (int i = 0; i < n; ++i) {\n    c[i] = b[i] - a[i];\n    if (c[i] < 0) {\n      c[i] += m;\n    }\n  }\n\n  // dp[i][j] := the minimum number of button presses to display target values\n  //             for 0-th to i-th counters when the i-th button is pressed\n  //             c[i]+j*m times.\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; ++i) {\n    dp[0][i] = c[0] + i * m;\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (c[i - 1] <= c[i]) {\n        dp[i][j] = dp[i - 1][j] + (c[i] - c[i - 1]);\n        if (j < n - 1) {\n          dp[i][j] = min(dp[i][j], dp[i - 1][j + 1]);\n        }\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        if (j > 0) {\n          dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + (c[i] - c[i - 1] + m));\n        }\n      }\n    }\n  }\n\n  // Output the minimum number of button presses to display target values for\n  // all counters.\n  cout << *min_element(dp.back().begin(), dp.back().end()) << endl;\n\n  return true;\n}\n\nint main() {\n  while (solve()) {\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = long long;\nconst i64 INF = i64(1e18) + 7;\n\nbool chmax(i64& x, i64 y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\nbool chmin(i64& x, i64 y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nbool solve(){\n    int n, m;\n    cin >> n >> m;\n    if(!n)\n        return false;\n    vector<i64> a(n), b(n), v(n);\n    for(auto& x : a)\n        cin >> x;\n    for(auto& x : b)\n        cin >> x;\n    for(int i = 0; i < n; ++i){\n        v[i] = (b[i] - a[i] + m) % m;\n        assert(0 <= v[i] && v[i] < m);\n    }\n    vector<vector<i64>> dp(n, vector<i64>(n + 2, INF));\n    for(int i = 0; i < n; ++i)\n        dp[0][i] = v[0] + m * i;\n    for(int i = 0; i < n - 1; ++i){\n        for(int j = 0; j <= n; ++j){\n\n            chmin(dp[i + 1][j], dp[i][j] + max(0LL, v[i + 1] - v[i]));\n            chmin(dp[i + 1][j], dp[i][j + 1]);\n            chmin(dp[i + 1][j + 1], dp[i][j] + max(0LL, v[i + 1] + m - v[i]));\n            /*\n            chmin(dp[i + 1][0], dp[i][0] + max(0LL, v[i + 1] - v[i]));\n            chmin(dp[i + 1][0], dp[i][1] + max(0LL, v[i + 1] + - (v[i] + m)));\n            chmin(dp[i + 1][1], dp[i][0] + max(0LL, v[i + 1] + m - v[i]));\n            chmin(dp[i + 1][1], dp[i][1] + max(0LL, v[i + 1] + m - (v[i] + m)));\n            */\n        }\n    }\n    i64 ans = INF;\n    for(auto& x : dp.back())\n        chmin(ans, x);\n    cout << ans << endl;\n    return true;\n}\n\nsigned main()\n{\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 2010\n\nint N;\nll M;\nll dp[2][SIZE];\nll from[1005],to[1005];\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld\",&from[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld\",&to[i]);\n\t\tto[i] -= from[i];\n\t\tif(to[i] < 0){\n\t\t\tto[i] += M;\n\t\t}\n\t}\n\n\tint PRE = 0,CURRENT = 1;\n\n\tfor(int i = 0; i < SIZE; i++){\n\n\t\tdp[PRE][i] = HUGE_NUM;\n\t\tdp[CURRENT][i] = HUGE_NUM;\n\t}\n\n\tfor(ll k = 0; k <= 1000; k++){\n\n\t\tif(to[0]+M*k >= 0){\n\n\t\t\tdp[PRE][k] = to[0]+M*k;\n\t\t}\n\t}\n\n\tfor(int i = 1; i < N; i++){\n\t\tfor(ll k = 0; k < SIZE; k++){\n\t\t\tif(dp[PRE][k] == HUGE_NUM)continue;\n\n\t\t\t//下り:1つ左の加算値以下の、最も大きいiの加算値\n\t\t\tif(to[i-1] >= to[i]){\n\n\t\t\t\tdp[CURRENT][k] = min(dp[CURRENT][k],dp[PRE][k]); //下りなので押す回数は増えない\n\n\t\t\t}else{ //to[i-1] < to[i]\n\n\t\t\t\tif(k > 0){\n\t\t\t\t\tdp[CURRENT][k-1] = min(dp[CURRENT][k-1],dp[PRE][k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//上り:1つ左の加算値より大きい、最も小さいiの加算値\n\t\t\tif(to[i-1] >= to[i]){\n\n\t\t\t\tdp[CURRENT][k+1] = min(dp[CURRENT][k+1],dp[PRE][k]+to[i]+M-to[i-1]); //増加分を足す\n\n\t\t\t}else{ //to[i-1] < to[i]\n\n\t\t\t\tdp[CURRENT][k] = min(dp[CURRENT][k],dp[PRE][k]+(to[i]-to[i-1]));\n\t\t\t}\n\t\t}\n\t\tswap(PRE,CURRENT);\n\t\tfor(int k = 0; k < SIZE; k++){\n\n\t\t\tdp[CURRENT][k] = HUGE_NUM;\n\t\t}\n\t}\n\n\tll ans = HUGE_NUM;\n\n\tfor(int i = 0; i < SIZE; i++){\n\n\t\tans = min(ans,dp[PRE][i]);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %lld\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint min(int i, int j){return (i<=j)?i:j;}\nint main(void){\n  for(;;){\n    int n,m;\n    cin >> n >> m;\n    if(n==0 && m==0){return 0;}\n    int a[n]; int b[n];\n    for(int i=0;i<n;i++){cin >> a[i];}\n    for(int i=0;i<n;i++){cin >> b[i];}\n    \n    int c[n];\n    for(int i=0;i<n;i++){\n      c[i]=(b[i]-a[i]>=0)?(b[i]-a[i]):(b[i]-a[i]+m);\n    }\n    \n    int dp[2][n];\n    for(int j=0;j<n;j++){\n      dp[0][j]=c[0]+j*m;\n    }\n    \n    for(int i=0;i<n-1;i++){\n      for(int j=0;j<n;j++){\n\tif(c[i+1]>c[i]){\n\t  dp[1][j]=(j+1<n)?(min(dp[0][j]+c[i+1]-c[i],dp[0][j+1])):(dp[0][j]+c[i+1]-c[i]);\n\t}else{\n\t  dp[1][j]=(j-1>=0)?(min(dp[0][j-1]+m+c[i+1]-c[i],dp[0][j])):(dp[0][j]);\n\t}\n      }\n\n      for(int j=0;j<n;j++){\n\tdp[0][j]=dp[1][j];\n      }\n    }\n\n    int ans=n*m;\n    for(int j=0;j<n;j++){\n      if(ans>dp[0][j]){\n\tans=dp[0][j];\n      }\n    }\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll=long long;\nll dp[1001][1001];\nint a[1000];\nint b[1000];\nll c[1001];\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>a[i];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>b[i];\n\t\tc[0]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(b[i]<a[i])\n\t\t\t\tc[i+1]=b[i]-a[i]+m;\n\t\t\telse\n\t\t\t\tc[i+1]=b[i]-a[i];\n\t\t}\n\t\tfill(dp[0],dp[1001],1e14-1);\n\t\tdp[0][0]=0;\n\t\tfor(int i=1;i<n+1;i++)\n\t\t{\n\t\t\t//cerr<<c[i]<<endl;\n\t\t\tfor(int j=0;j<1001;j++)\n\t\t\t{\n\t\t\t\tif(i==1)\n\t\t\t\t\tdp[i][j]=c[i]+j*m;\n\t\t\t\telse{\n\t\t\t\t\tint k=(c[i]+j*m-c[i-1])/m;\n\t\t\t\t\tdp[i][j]=min(dp[i-1][k]+max(0LL,c[i]+j*m-c[i-1]-k*m),dp[i-1][k+1]+max(0LL,c[i]+j*m-c[i-1]-(k+1)*m));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=1e14-1;\n\t\tfor(int i=0;i<100;i++)\n\t\t\tans=min(ans,dp[n][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e8;\nconst size_t SIZE = 1010;\nint dp[SIZE], dp_buf[SIZE];\nint A[SIZE], B[SIZE];\n\nvoid chmin(int &a, int b) { a = min(a, b); }\nvoid chmax(int &a, int b) { a = max(a, b); }\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if(N + M == 0) return false;\n    for(int i = 0; i < N; i++) cin >> A[i];\n    for(int i = 0; i < N; i++) cin >> B[i];\n    \n    auto to_push = [&](int i) { return ((M - A[i]) + B[i]) % M; };\n\n    dp[0] = to_push(0);\n    for(int i = 1; i <= N; i++) dp[i] = dp[0] + i * M;\n    for(int i = 1; i < N; i++) {\n        fill(dp_buf, dp_buf + SIZE, inf);\n        for(int j = 0; j <= N; j++) {\n            int pushed = to_push(i - 1) + j * M;\n            for(int diff = -1; diff <= 1; diff++) {\n                int want = (j + diff) * M + to_push(i);\n                if(want < 0) continue;\n                chmin(dp_buf[j + diff], dp[j] + max(want - pushed, 0));\n            }\n        }\n        copy(dp_buf, dp_buf + SIZE, dp);\n    }\n\n    int ans = inf;\n    for(int i = 0; i <= N; i++) chmin(ans, dp[i]);\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint n, m;\n\nunsigned dp[1010][1010];\nint main() {\n    while(1) {\n        std::cin >> n >> m;\n\n        if(n * m == 0) {\n            return 0;\n        }\n\n        std::vector<int> A(n), B(n);\n\n        for(int i = 0; i < n; ++i) {\n            std::cin >> A[i];\n        }\n        for(int i = 0; i < n; ++i) {\n            std::cin >> B[i];\n\n            A[i] = (B[i] - A[i] + m) % m;\n        }\n        memset(dp, -1, sizeof(dp));\n\n        for(int i = 0; i < n; ++i) {\n            dp[0][i] = A[0] + i * m;\n        }\n        for(int i = 1; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                dp[i][j] = std::min(std::max(0, A[i] - A[i - 1]) + dp[i - 1][j], dp[i][j]);\n\n                if(j != 0) {\n                    dp[i][j] = std::min(A[i] + m - A[i - 1] + dp[i - 1][j - 1], dp[i][j]);\n                }\n                dp[i][j] = std::min(dp[i - 1][j + 1], dp[i][j]);\n            }\n        }\n\n        int min = 1e9;\n        for(int i = 0; i < n; ++i) {\n            min = std::min(static_cast<int>(dp[n - 1][i]), min);\n        }\n        assert(min >= 0);\n\n        std::cout << min << std::endl;\n    }\n\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve(C, N, M, range = range, min = min):\n    K = N // 4 + 1\n    S = [0]*K\n    T = [0]*K\n    U = [0]*(K+1)\n    for i in range(N-1):\n        U[0] = 10**18\n        for j in range(K):\n            U[j+1] = min(U[j], S[j])\n        k = K-1\n        ci = C[i]; cj = C[i+1]\n        r = 10**18\n        for j in range(K-1, -1, -1):\n            while ci + k*M > cj + j*M:\n                r = min(r, ci + k*M + S[k])\n                k -= 1\n            T[j] = min(r - j*M - cj, U[k+1])\n        S, T = T, S\n    ci = C[-1]\n    for i in range(K):\n        S[i] += ci + i*M\n    write(\"%d\\n\" % min(S))\nwhile 1:\n    N, M = map(int, readline().split())\n    if N == 0:\n        break\n    *A, = map(int, readline().split())\n    *B, = map(int, readline().split())\n    C = [(b - a) % M for a, b in zip(A, B)]\n    solve(C, N, M)\n"
  }
]