[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int dist[MAX_N - 1];\n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%d\", &dist[i]);\n    }\n\n    int deliciousness[MAX_N][MAX_M];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &deliciousness[i][j]);\n        }\n    }\n\n    int dp[MAX_N][1 << MAX_M];\n    memset(dp, -0x3f, sizeof(dp));\n\n    for (int start = 0; start < N; start++) {\n        for (int j = 0; j < M; j++) {\n            dp[start][1 << j] = deliciousness[start][j];\n        }\n    }\n\n    for (int mask = 1; mask < (1 << M); mask++) {\n        for (int start = 0; start < N; start++) {\n            for (int j = 0; j < M; j++) {\n                if (!(mask & (1 << j))) {\n                    for (int prev = 0; prev < N; prev++) {\n                        int total_dist = 0;\n                        if (prev < start) {\n                            for (int k = prev; k < start; k++) {\n                                total_dist += dist[k];\n                            }\n                        } else {\n                            for (int k = start; k < prev; k++) {\n                                total_dist += dist[k];\n                            }\n                        }\n\n                        if (dp[prev][mask] != -0x3f) {\n                            dp[start][mask | (1 << j)] = \n                                fmax(dp[start][mask | (1 << j)], \n                                     dp[prev][mask] + deliciousness[start][j] - total_dist);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int max_happiness = INT_MIN;\n    for (int start = 0; start < N; start++) {\n        for (int mask = 0; mask < (1 << M); mask++) {\n            max_happiness = fmax(max_happiness, dp[start][mask]);\n        }\n    }\n\n    printf(\"%d\\n\", max_happiness);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nlong long max(long long a, long long b) {\n    return (a > b) ? a : b;\n}\n\nlong long solve(int N, int M, long long A[], long long** B) {\n    long long* prefix = (long long*)malloc((N + 1) * sizeof(long long));\n    prefix[0] = 0;\n    for (int i = 1; i < N; i++) {\n        prefix[i] = prefix[i - 1] + A[i - 1];\n    }\n\n    long long* sumB = (long long*)malloc(N * sizeof(long long));\n    for (int i = 0; i < N; i++) {\n        sumB[i] = 0;\n        for (int j = 0; j < M; j++) {\n            if (B[i][j] > 0) {\n                sumB[i] += B[i][j];\n            }\n        }\n    }\n\n    long long max_happiness = LLONG_MIN;\n    long long current_max = 0;\n    long long min_prefix = 0;\n\n    for (int i = 0; i < N; i++) {\n        current_max = sumB[i] - prefix[i];\n        max_happiness = max(max_happiness, current_max - min_prefix);\n        min_prefix = min_prefix < (prefix[i] - sumB[i]) ? min_prefix : (prefix[i] - sumB[i]);\n    }\n\n    free(prefix);\n    free(sumB);\n\n    return max_happiness;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    long long* A = (long long*)malloc((N - 1) * sizeof(long long));\n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n\n    long long** B = (long long**)malloc(N * sizeof(long long*));\n    for (int i = 0; i < N; i++) {\n        B[i] = (long long*)malloc(M * sizeof(long long));\n        for (int j = 0; j < M; j++) {\n            scanf(\"%lld\", &B[i][j]);\n        }\n    }\n\n    long long result = solve(N, M, A, B);\n    printf(\"%lld\\n\", result);\n\n    for (int i = 0; i < N; i++) {\n        free(B[i]);\n    }\n    free(B);\n    free(A);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N - 1);\n    for (int i = 0; i < N - 1; ++i) {\n        cin >> A[i];\n    }\n\n    vector<vector<int>> tickets(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int B, C;\n        cin >> B >> C;\n        tickets[B].push_back(C);\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        sort(tickets[i].begin(), tickets[i].end(), greater<int>());\n    }\n\n    long long max_happiness = 0;\n    long long current_happiness = 0;\n    long long current_distance = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        long long sum = 0;\n        for (int j = 0; j < tickets[i].size(); ++j) {\n            sum += tickets[i][j];\n            long long happiness = sum - current_distance;\n            if (happiness > max_happiness) {\n                max_happiness = happiness;\n            }\n        }\n        if (i < N) {\n            current_distance += A[i - 1];\n        }\n    }\n\n    cout << max_happiness << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[] A = new int[N - 1];\n        for (int i = 0; i < N - 1; i++) {\n            A[i] = scanner.nextInt();\n        }\n        int[][] B = new int[N][M];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                B[i][j] = scanner.nextInt();\n            }\n        }\n\n        // Precompute prefix sums for distances\n        int[] prefixSum = new int[N];\n        for (int i = 1; i < N; i++) {\n            prefixSum[i] = prefixSum[i - 1] + A[i - 1];\n        }\n\n        // Precompute the prefix and suffix maximums for B\n        int[][] prefixMax = new int[N][M + 1];\n        int[][] suffixMax = new int[N][M + 1];\n        for (int i = 0; i < N; i++) {\n            prefixMax[i][0] = 0;\n            for (int j = 1; j <= M; j++) {\n                prefixMax[i][j] = prefixMax[i][j - 1] + B[i][j - 1];\n            }\n            suffixMax[i][M] = prefixMax[i][M];\n            for (int j = M - 1; j >= 0; j--) {\n                suffixMax[i][j] = Math.max(suffixMax[i][j + 1], prefixMax[i][j]);\n            }\n        }\n\n        int maxHappiness = Integer.MIN_VALUE;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int distanceCost = Math.abs(prefixSum[j] - prefixSum[i]);\n                int maxB = 0;\n                if (i <= j) {\n                    // Moving east, use suffixMax[i] and prefixMax[j]\n                    maxB = suffixMax[i][0] + prefixMax[j][M];\n                } else {\n                    // Moving west, use suffixMax[j] and prefixMax[i]\n                    maxB = suffixMax[j][0] + prefixMax[i][M];\n                }\n                int happiness = maxB - distanceCost;\n                if (happiness > maxHappiness) {\n                    maxHappiness = happiness;\n                }\n            }\n        }\n        System.out.println(maxHappiness);\n    }\n}",
    "timestamp": "2025-08-05 23:29:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BarbecueHappiness {\n    public static int maxHappiness(int N, int M, int[] A, int[][] deliciousness) {\n        int[][] dp = new int[N + 1][M + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                dp[i][j] = Integer.MIN_VALUE;\n                for (int k = 1; k <= N; k++) {\n                    int distance = Math.abs(i - k);\n                    int totalDistance = 0;\n                    for (int l = Math.min(k, i); l < Math.max(k, i); l++) {\n                        totalDistance += A[l];\n                    }\n                    \n                    for (int ticket = 1; ticket <= j; ticket++) {\n                        if (dp[k][j - ticket] != Integer.MIN_VALUE) {\n                            dp[i][j] = Math.max(dp[i][j], \n                                dp[k][j - ticket] + deliciousness[k - 1][ticket - 1] - totalDistance);\n                        }\n                    }\n                }\n            }\n        }\n        \n        int maxHappiness = Integer.MIN_VALUE;\n        for (int i = 1; i <= N; i++) {\n            maxHappiness = Math.max(maxHappiness, dp[i][M]);\n        }\n        \n        return maxHappiness;\n    }\n    \n    public static void main(String[] args) {\n        int N = 5;  // Number of restaurants\n        int M = 3;  // Number of tickets\n        int[] A = {1, 2, 3, 4};  // Distances between restaurants\n        int[][] deliciousness = {\n            {10, 20, 30},\n            {15, 25, 35},\n            {5, 15, 25},\n            {20, 30, 40},\n            {25, 35, 45}\n        };\n        \n        int result = maxHappiness(N, M, A, deliciousness);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:29:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint maxHappiness(int N, int M, vector<int>& distances, vector<vector<int>>& deliciousness) {\n    vector<vector<int>> dp(N, vector<int>(M + 1, INT_MIN));\n    \n    // Initialize base cases\n    for (int j = 0; j <= M; j++) {\n        for (int start = 0; start < N; start++) {\n            if (j == 0) {\n                dp[start][j] = 0;\n            } else {\n                for (int k = 0; k < N; k++) {\n                    int dist = abs(start - k);\n                    int totalDist = 0;\n                    for (int l = min(start, k); l < max(start, k); l++) {\n                        totalDist += distances[l];\n                    }\n                    \n                    for (int ticket = 1; ticket <= j; ticket++) {\n                        if (dp[k][j - ticket] != INT_MIN) {\n                            dp[start][j] = max(dp[start][j], \n                                               dp[k][j - ticket] + deliciousness[k][ticket - 1] - totalDist);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    int maxHappy = INT_MIN;\n    for (int start = 0; start < N; start++) {\n        maxHappy = max(maxHappy, dp[start][M]);\n    }\n    \n    return maxHappy;\n}",
    "timestamp": "2025-08-05 23:29:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_happiness(N, M, A, deliciousness):\n    # Prefix sum for distances\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i - 1]\n\n    # Initialize dp table\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n\n    # Iterate over each starting restaurant\n    for start in range(1, N + 1):\n        # Iterate over each number of tickets\n        for tickets in range(1, M + 1):\n            # Try distributing tickets from the current starting point to each restaurant\n            for current in range(start, N + 1):\n                travel_distance = prefix_sum[current] - prefix_sum[start - 1]\n                # Calculate max deliciousness for current point\n                # Depending on number of tickets used\n                for used_tickets in range(1, tickets + 1):\n                    # If using `used_tickets` tickets at restaurant `current`\n                    if used_tickets <= deliciousness[current - 1]:\n                        used_deliciousness = used_tickets * deliciousness[current - 1]\n                        dp[current][tickets] = max(dp[current][tickets],\n                                                   dp[start - 1][tickets - used_tickets] + used_deliciousness - travel_distance)\n\n    # Find the maximum happiness\n    max_val = 0\n    for j in range(1, N + 1):\n        max_val = max(max_val, max(dp[j]))\n\n    return max_val\n\n# Example usage:\n# N = Number of restaurants\n# M = Number of tickets\n# A = List with distances between restaurants\n# deliciousness = List with deliciousness of each restaurant\nN = 5\nM = 3\nA = [2, 3, 1, 4]\ndeliciousness = [3, 2, 4, 1, 5]\nprint(max_happiness(N, M, A, deliciousness))",
    "timestamp": "2025-08-13 15:24:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class BarbecueHappiness {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read number of restaurants (N) and tickets (M)\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        // Read deliciousness values\n        int[] deliciousness = new int[N];\n        for (int i = 0; i < N; i++) {\n            deliciousness[i] = scanner.nextInt();\n        }\n        \n        // Read distance values between restaurants\n        int[] distance = new int[N - 1];\n        for (int i = 0; i < N - 1; i++) {\n            distance[i] = scanner.nextInt();\n        }\n        \n        scanner.close();\n        \n        // Maximize happiness\n        int maxHappiness = Integer.MIN_VALUE;\n        \n        // Try starting from each restaurant\n        for (int start = 0; start < N; start++) {\n            int happiness = 0;\n            int ticketsUsed = 0;\n            \n            // Use tickets at starting restaurant\n            ticketsUsed = M;\n            happiness = deliciousness[start] * ticketsUsed;\n            \n            // Calculate positive distance impact if moving right\n            int rightDistance = 0;\n            for (int i = start; i < N - 1; i++) {\n                rightDistance += distance[i];\n                if (ticketsUsed >= 1) {\n                    ticketsUsed--;\n                    happiness += (deliciousness[i + 1] * ticketsUsed) - rightDistance;\n                }\n                maxHappiness = Math.max(maxHappiness, happiness);\n            }\n            \n            // Reset for left side calculation\n            ticketsUsed = M;\n            happiness = deliciousness[start] * ticketsUsed;\n            \n            // Calculate positive distance impact if moving left\n            int leftDistance = 0;\n            for (int i = start; i > 0; i--) {\n                leftDistance += distance[i - 1];\n                if (ticketsUsed >= 1) {\n                    ticketsUsed--;\n                    happiness += (deliciousness[i - 1] * ticketsUsed) - leftDistance;\n                }\n                maxHappiness = Math.max(maxHappiness, happiness);\n            }\n        }\n        \n        // Print the maximum happiness\n        System.out.println(maxHappiness);\n    }\n}",
    "timestamp": "2025-08-13 15:24:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint maxHappiness(int N, int M, int distances[], int deliciousness[][M]) {\n    int maxHappiness = 0;\n\n    for (int start = 0; start < N; ++start) {\n        for (int end = start; end < N; ++end) {\n            int ticketsUsed[M];\n            for (int i = 0; i < M; ++i) ticketsUsed[i] = 0;\n            \n            int currentHappiness = 0, totalDistance = 0;\n            \n            for (int i = start; i <= end; ++i) {\n                for (int j = 0; j < M; ++j) {\n                    if (ticketsUsed[j] == 0 && deliciousness[i][j] > 0) {\n                        currentHappiness += deliciousness[i][j];\n                        ticketsUsed[j] = 1;\n                    }\n                }\n                if (i < end) {\n                    totalDistance += distances[i];\n                }\n            }\n            \n            int potentialHappiness = currentHappiness - totalDistance;\n            if (potentialHappiness > maxHappiness) {\n                maxHappiness = potentialHappiness;\n            }\n        }\n    }\n    \n    return maxHappiness;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int *distances = malloc((N-1) * sizeof(int));\n    for (int i = 0; i < N-1; ++i) {\n        scanf(\"%d\", &distances[i]);\n    }\n    \n    int **deliciousness = malloc(N * sizeof(int*));\n    for (int i = 0; i < N; ++i) {\n        deliciousness[i] = malloc(M * sizeof(int));\n        for (int j = 0; j < M; ++j) {\n            scanf(\"%d\", &deliciousness[i][j]);\n        }\n    }\n    \n    int result = maxHappiness(N, M, distances, deliciousness);\n    printf(\"%d\\n\", result);\n    \n    for (int i = 0; i < N; ++i) {\n        free(deliciousness[i]);\n    }\n    free(deliciousness);\n    free(distances);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:25:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint maxHappiness(int N, int M, vector<int>& A, vector<vector<int>>& deliciousness) {\n    vector<int> distance(N, 0);\n    for (int i = 1; i < N; ++i) {\n        distance[i] = distance[i - 1] + A[i - 1];\n    }\n    \n    vector<vector<int>> dp(N, vector<int>(M + 1, INT_MIN));\n    \n    for (int i = 0; i < N; ++i) {\n        dp[i][0] = 0; \n        for (int k = 1; k <= M; ++k) {\n            for (int j = 0; j <= i; ++j) {\n                if (j == i) {\n                    if (k >= deliciousness[i].size()) {\n                        dp[i][k] = max(dp[i][k], dp[i][k - (int)deliciousness[i].size()] + deliciousness[i][deliciousness[i].size() - 1]);\n                    }\n                } else {\n                    dp[i][k] = max(dp[i][k], dp[j][k] - (distance[i] - distance[j]));\n                }\n            }\n        }\n    }\n\n    int maxHappiness = INT_MIN;\n    for (int i = 0; i < N; ++i) {\n        maxHappiness = max(maxHappiness, dp[i][M] - distance[i]);\n    }\n\n    return maxHappiness;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N - 1);\n    for (int i = 0; i < N - 1; ++i) {\n        cin >> A[i];\n    }\n\n    vector<vector<int>> deliciousness(N);\n    for (int i = 0; i < N; ++i) {\n        int K;\n        cin >> K;\n        deliciousness[i].resize(K);\n        for (int j = 0; j < K; ++j) {\n            cin >> deliciousness[i][j];\n        }\n    }\n\n    cout << maxHappiness(N, M, A, deliciousness) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:25:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_happiness(N, M, A, deliciousness):\n    # Initialize dynamic programming table\n    dp = [[-float('inf')] * (M + 1) for _ in range(N)]\n    \n    # Initialize base case: starting at each restaurant with 0 tickets\n    for i in range(N):\n        dp[i][0] = 0\n    \n    # Fill the DP table\n    for tickets in range(1, M + 1):\n        for current in range(N):\n            for prev in range(N):\n                # Calculate distance between restaurants\n                distance = abs(A[current] - A[prev]) if current != prev else 0\n                \n                # Try using a ticket at the current restaurant\n                for d in range(1, deliciousness[current] + 1):\n                    if tickets >= d:\n                        prev_happiness = dp[prev][tickets - d]\n                        if prev_happiness != -float('inf'):\n                            dp[current][tickets] = max(\n                                dp[current][tickets], \n                                prev_happiness + d - distance\n                            )\n    \n    # Return maximum happiness\n    return max(dp[i][M] for i in range(N))",
    "timestamp": "2025-08-13 15:25:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, M = map(int, data[idx:idx+2])\n    idx +=2\n    A = list(map(int, data[idx:idx+N-1]))\n    idx +=N-1\n    \n    restaurants = []\n    for _ in range(N):\n        B, C = map(int, data[idx:idx+2])\n        idx +=2\n        restaurants.append((C, B))\n    \n    # Sort restaurants by C in descending order\n    restaurants.sort(reverse=True, key=lambda x: x[0])\n    \n    total_happiness = 0\n    total_tickets = 0\n    pos = 0  # current position (irrelevant for happiness calculation)\n    \n    for C, B in restaurants:\n        if total_tickets + B <= M:\n            total_happiness += C * B\n            total_tickets += B\n        else:\n            remaining = M - total_tickets\n            total_happiness += C * remaining\n            total_tickets += remaining\n            break\n    \n    # The distance is not considered in the happiness calculation as per problem statement\n    print(total_happiness)\n\nsolve()",
    "timestamp": "2025-08-13 15:25:54"
  }
]