[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n    int dx, dy;\n} State;\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint rows = 0, cols = 0;\nint visited[MAX_SIZE][MAX_SIZE][4][2]; // x, y, direction (dx, dy mapped)\n\nint simulate() {\n    State stack[10000];\n    int stack_size = 0;\n    State initial = {0, 0, 1, 0};\n    stack[stack_size++] = initial;\n\n    while (stack_size > 0) {\n        State current = stack[--stack_size];\n        int x = current.x, y = current.y;\n        int dx = current.dx, dy = current.dy;\n\n        if (x < 0 || x >= cols || y < 0 || y >= rows) continue;\n        \n        int dir_index;\n        if (dx == 1 && dy == 0) dir_index = 0;\n        else if (dx == -1 && dy == 0) dir_index = 1;\n        else if (dx == 0 && dy == 1) dir_index = 2;\n        else dir_index = 3;\n\n        if (visited[y][x][dir_index][0]) continue;\n        visited[y][x][dir_index][0] = 1;\n\n        char cmd = grid[y][x];\n        if (cmd == '@') return 1;\n        if (cmd == '>') { dx = 1; dy = 0; }\n        else if (cmd == '<') { dx = -1; dy = 0; }\n        else if (cmd == '^') { dx = 0; dy = -1; }\n        else if (cmd == 'v') { dx = 0; dy = 1; }\n        else if (cmd == '_') { dx = (current.dx == 0) ? 0 : (rand() % 2 ? 1 : -1); dy = 0; }\n        else if (cmd == '|') { dy = (current.dy == 0) ? 0 : (rand() % 2 ? 1 : -1); dx = 0; }\n        else if (cmd == '?') {\n            int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            int r = rand() % 4;\n            dx = dirs[r][0];\n            dy = dirs[r][1];\n        }\n\n        State next = {x + dx, y + dy, dx, dy};\n        stack[stack_size++] = next;\n    }\n    return 0;\n}\n\nint main() {\n    char line[MAX_SIZE];\n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') break;\n        line[strcspn(line, \"\\n\")] = '\\0';\n        strcpy(grid[rows], line);\n        cols = strlen(line);\n        rows++;\n    }\n\n    memset(visited, 0, sizeof(visited));\n    printf(simulate() ? \"YES\\n\" : \"NO\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nstruct State {\n    int x, y;\n    int dx, dy;\n    bool operator<(const State& other) const {\n        if (x != other.x) return x < other.x;\n        if (y != other.y) return y < other.y;\n        if (dx != other.dx) return dx < other.dx;\n        return dy < other.dy;\n    }\n};\n\nbool willHalt(const vector<string>& grid) {\n    int rows = grid.size();\n    if (rows == 0) return false;\n    int cols = grid[0].size();\n    if (cols == 0) return false;\n\n    set<State> visited;\n    State current{0, 0, 1, 0};\n\n    while (true) {\n        if (current.x < 0 || current.x >= rows || current.y < 0 || current.y >= cols) {\n            return false;\n        }\n\n        char cmd = grid[current.x][current.y];\n        if (cmd == '@') return true;\n\n        if (visited.count(current)) {\n            return false;\n        }\n        visited.insert(current);\n\n        int new_dx = current.dx;\n        int new_dy = current.dy;\n\n        switch (cmd) {\n            case '>': new_dx = 0; new_dy = 1; break;\n            case '<': new_dx = 0; new_dy = -1; break;\n            case '^': new_dx = -1; new_dy = 0; break;\n            case 'v': new_dx = 1; new_dy = 0; break;\n            case '?':\n                for (auto [dx, dy] : vector<pair<int, int>>{{0,1}, {0,-1}, {1,0}, {-1,0}}) {\n                    State next = current;\n                    next.x += dx;\n                    next.y += dy;\n                    next.dx = dx;\n                    next.dy = dy;\n                    if (willHalt(grid)) return true;\n                }\n                return false;\n        }\n\n        current.x += new_dx;\n        current.y += new_dy;\n        current.dx = new_dx;\n        current.dy = new_dy;\n    }\n}\n\nint main() {\n    vector<string> grid;\n    string line;\n    while (getline(cin, line)) {\n        grid.push_back(line);\n    }\n    cout << (willHalt(grid) ? \"YES\" : \"NO\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DefungeHalting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> grid = new ArrayList<>();\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.isEmpty()) break;\n            grid.add(line);\n        }\n        int rows = grid.size();\n        int cols = rows > 0 ? grid.get(0).length() : 0;\n\n        boolean[][][] visited = new boolean[rows][cols][4];\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // right, down, left, up\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{0, 0, 0}); // x, y, dir (right)\n\n        boolean halts = false;\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            int dir = current[2];\n\n            if (x < 0 || x >= rows || y < 0 || y >= cols) continue;\n            if (visited[x][y][dir]) continue;\n            visited[x][y][dir] = true;\n\n            char c = grid.get(x).charAt(y);\n            if (c == '@') {\n                halts = true;\n                break;\n            }\n\n            int newDir = dir;\n            if (c == '>') newDir = 0;\n            else if (c == 'v') newDir = 1;\n            else if (c == '<') newDir = 2;\n            else if (c == '^') newDir = 3;\n            else if (c == '_') newDir = (dir == 0 || dir == 2) ? dir : 0;\n            else if (c == '|') newDir = (dir == 1 || dir == 3) ? dir : 1;\n\n            int newX = x + directions[newDir][0];\n            int newY = y + directions[newDir][1];\n            queue.add(new int[]{newX, newY, newDir});\n        }\n        System.out.println(halts ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 21:21:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DefungeHaltChecker {\n    public static String willHalt(String[] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length();\n        boolean[][][] visited = new boolean[rows][cols][4];\n        \n        return simulateExecution(grid, 0, 0, 0, visited) ? \"YES\" : \"NO\";\n    }\n    \n    private static boolean simulateExecution(String[] grid, int row, int col, int dir, boolean[][][] visited) {\n        int rows = grid.length;\n        int cols = grid[0].length();\n        \n        if (row < 0 || row >= rows || col < 0 || col >= cols) {\n            return false;\n        }\n        \n        if (visited[row][col][dir]) {\n            return false;\n        }\n        \n        visited[row][col][dir] = true;\n        \n        char command = grid[row].charAt(col);\n        \n        if (command == '@') {\n            return true;\n        }\n        \n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        \n        switch (command) {\n            case '>':\n                return simulateExecution(grid, row, (col + 1 + cols) % cols, 0, visited);\n            case '<':\n                return simulateExecution(grid, row, (col - 1 + cols) % cols, 2, visited);\n            case '^':\n                return simulateExecution(grid, (row - 1 + rows) % rows, col, 3, visited);\n            case 'v':\n                return simulateExecution(grid, (row + 1 + rows) % rows, col, 1, visited);\n            case '|':\n                return simulateExecution(grid, (row - 1 + rows) % rows, col, 3, visited) ||\n                       simulateExecution(grid, (row + 1 + rows) % rows, col, 1, visited);\n            case '_':\n                return simulateExecution(grid, row, (col - 1 + cols) % cols, 2, visited) ||\n                       simulateExecution(grid, row, (col + 1 + cols) % cols, 0, visited);\n            default:\n                return simulateExecution(grid, row + dx[dir], col + dy[dir], dir, visited);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine();\n        \n        String[] grid = new String[rows];\n        for (int i = 0; i < rows; i++) {\n            grid[i] = scanner.nextLine();\n        }\n        \n        System.out.println(willHalt(grid));\n    }\n}",
    "timestamp": "2025-08-05 21:21:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SIZE 25\n#define MAX_STEPS 1000\n\ntypedef enum {\n    RIGHT,\n    DOWN,\n    LEFT,\n    UP\n} Direction;\n\nbool visited[MAX_SIZE][MAX_SIZE][4][MAX_STEPS];\n\nbool is_halting(char grid[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            for (int d = 0; d < 4; d++) {\n                memset(visited, 0, sizeof(visited));\n                int x = r, y = c, dir = d, steps = 0;\n                bool terminate = false;\n\n                while (!terminate && steps < MAX_STEPS) {\n                    if (x < 0 || x >= rows || y < 0 || y >= cols) break;\n                    \n                    if (visited[x][y][dir][steps]) return false;\n                    visited[x][y][dir][steps] = true;\n\n                    char cmd = grid[x][y];\n                    switch (cmd) {\n                        case '>': dir = RIGHT; break;\n                        case 'v': dir = DOWN; break;\n                        case '<': dir = LEFT; break;\n                        case '^': dir = UP; break;\n                        case '?': dir = rand() % 4; break;\n                        case '@': terminate = true; break;\n                        case '#': \n                            switch (dir) {\n                                case RIGHT: y++; break;\n                                case DOWN: x++; break;\n                                case LEFT: y--; break;\n                                case UP: x--; break;\n                            }\n                            break;\n                        default:\n                            switch (dir) {\n                                case RIGHT: y++; break;\n                                case DOWN: x++; break;\n                                case LEFT: y--; break;\n                                case UP: x--; break;\n                            }\n                    }\n                    steps++;\n                }\n\n                if (terminate) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int rows, cols;\n    char grid[MAX_SIZE][MAX_SIZE];\n\n    scanf(\"%d %d\", &rows, &cols);\n    \n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    printf(\"%s\\n\", is_halting(grid, rows, cols) ? \"YES\" : \"NO\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nbool willHalt(vector<string>& grid) {\n    int rows = grid.size();\n    int cols = grid[0].length();\n    set<pair<int, pair<int, int>>> visited;\n    \n    int x = 0, y = 0;\n    int dx = 1, dy = 0;\n    \n    while (true) {\n        pair<int, pair<int, int>> state = {dx, {x, y}};\n        \n        if (visited.count(state)) {\n            return false;\n        }\n        visited.insert(state);\n        \n        if (x < 0 || x >= rows || y < 0 || y >= cols) {\n            return false;\n        }\n        \n        char cmd = grid[x][y];\n        \n        if (cmd == '@') {\n            return true;\n        }\n        \n        switch(cmd) {\n            case '>': dx = 0, dy = 1; break;\n            case '<': dx = 0, dy = -1; break;\n            case '^': dx = -1, dy = 0; break;\n            case 'v': dx = 1, dy = 0; break;\n        }\n        \n        x += dx;\n        y += dy;\n    }\n}\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    \n    vector<string> grid(m);\n    for (int i = 0; i < m; i++) {\n        cin >> grid[i];\n    }\n    \n    cout << (willHalt(grid) ? \"YES\" : \"NO\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def will_halt(defunge_program):\n    rows = len(defunge_program)\n    cols = len(defunge_program[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    dir_map = {'>': 0, 'v': 1, '<': 2, '^': 3}\n    visited = set()\n    \n    x, y, d = 0, 0, 0\n    \n    while True:\n        if (x, y, d) in visited:\n            return \"NO\"\n        visited.add((x, y, d))\n        \n        command = defunge_program[x][y]\n        \n        if command in dir_map:\n            d = dir_map[command]\n        \n        if command == '@':\n            return \"YES\"\n        \n        x = (x + directions[d][0]) % rows\n        y = (y + directions[d][1]) % cols",
    "timestamp": "2025-08-13 05:59:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class DefungeHaltingProblem {\n\n    private static final char END = '@';\n    private static final char[] DIRECTIONS = {'>', 'v', '<', '^'};\n\n    private static int[] move(char direction, int[] currentPosition) {\n        switch (direction) {\n            case '>': return new int[]{currentPosition[0], currentPosition[1] + 1};\n            case '<': return new int[]{currentPosition[0], currentPosition[1] - 1};\n            case 'v': return new int[]{currentPosition[0] + 1, currentPosition[1]};\n            case '^': return new int[]{currentPosition[0] - 1, currentPosition[1]};\n            default: return currentPosition;\n        }\n    }\n    \n    private static boolean isBounded(int x, int y, char[][] grid) {\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length;\n    }\n\n    public static String willHalt(char[][] grid) {\n        int[] position = {0, 0};\n        char direction = '>';\n        \n        Set<String> visited = new HashSet<>();\n        \n        while (isBounded(position[0], position[1], grid) && grid[position[0]][position[1]] != END) {\n            String state = position[0] + \",\" + position[1] + \",\" + direction;\n            if (visited.contains(state)) return \"NO\";\n            visited.add(state);\n\n            char command = grid[position[0]][position[1]];\n            for (char dir : DIRECTIONS) {\n                if (command == dir) {\n                    direction = dir;\n                    break;\n                }\n            }\n            \n            position = move(direction, position);\n        }\n\n        return isBounded(position[0], position[1], grid) && grid[position[0]][position[1]] == END ? \"YES\" : \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numRows = scanner.nextInt();\n        int numCols = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] grid = new char[numRows][numCols];\n        \n        for (int i = 0; i < numRows; i++) {\n            String line = scanner.nextLine();\n            grid[i] = line.toCharArray();\n        }\n        \n        System.out.println(willHalt(grid));\n    }\n}",
    "timestamp": "2025-08-13 06:00:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 100\n\nint visited[MAX][MAX];\nchar grid[MAX][MAX];\nint numRows, numCols;\n\n// Direction vectors for right, down, left, up\nint dRow[] = {0, 1, 0, -1};\nint dCol[] = {1, 0, -1, 0};\n\n// Function to check if a cell is within grid bounds\nint isValid(int row, int col) {\n    return row >= 0 && row < numRows && col >= 0 && col < numCols;\n}\n\n// Depth-First Search to check if we can reach '@'\nint dfs(int row, int col, int dir) {\n    if (!isValid(row, col) || visited[row][col]) return 0;\n    visited[row][col] = 1;\n    \n    if (grid[row][col] == '@') return 1;  // Program halts\n\n    // Stay in current direction by default\n    int newDir = dir;\n    \n    // Change direction if needed\n    if (grid[row][col] == '>') newDir = 0;\n    else if (grid[row][col] == 'v') newDir = 1;\n    else if (grid[row][col] == '<') newDir = 2;\n    else if (grid[row][col] == '^') newDir = 3;\n    \n    // Move in the chosen direction\n    return dfs(row + dRow[newDir], col + dCol[newDir], newDir);\n}\n\nint main() {\n    scanf(\"%d %d\", &numRows, &numCols);\n    \n    for (int i = 0; i < numRows; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    // Initialize visited array\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            visited[i][j] = 0;\n        }\n    }\n    \n    if (dfs(0, 0, 0)) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:00:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def will_halt(grid):\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    \n    def dfs(r, c, dr, dc, steps):\n        if steps > rows * cols * 2:\n            return False\n        \n        if (r, c, dr, dc) in visited:\n            return False\n        \n        visited.add((r, c, dr, dc))\n        \n        if grid[r][c] == '@':\n            return True\n        \n        next_r, next_c = (r + dr) % rows, (c + dc) % cols\n        \n        if grid[r][c] == '>':\n            return dfs(next_r, next_c, 0, 1, steps + 1)\n        elif grid[r][c] == '<':\n            return dfs(next_r, next_c, 0, -1, steps + 1)\n        elif grid[r][c] == '^':\n            return dfs(next_r, next_c, -1, 0, steps + 1)\n        elif grid[r][c] == 'v':\n            return dfs(next_r, next_c, 1, 0, steps + 1)\n        elif grid[r][c] == '#':\n            return dfs(next_r, next_c, dr, dc, steps + 1)\n        elif grid[r][c] == '_':\n            return dfs(next_r, next_c, 0, 1, steps + 1) or dfs(next_r, next_c, 0, -1, steps + 1)\n        elif grid[r][c] == '|':\n            return dfs(next_r, next_c, 1, 0, steps + 1) or dfs(next_r, next_c, -1, 0, steps + 1)\n        \n        return dfs(next_r, next_c, dr, dc, steps + 1)\n    \n    return 'YES' if dfs(0, 0, 0, 1, 0) else 'NO'\n\ndef main():\n    rows, cols = map(int, input().split())\n    grid = [input().strip() for _ in range(rows)]\n    print(will_halt(grid))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 06:00:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def will_halt(defunge_code):\n    rows = defunge_code.split('\\n')\n    grid = [list(row) for row in rows]\n    rows_count = len(grid)\n    if rows_count == 0:\n        return \"NO\"\n    cols_count = len(grid[0]) if rows_count > 0 else 0\n    \n    # Directions: right, left, down, up\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    current_dir = 0  # starts moving right\n    x, y = 0, 0\n    visited = set()\n    stack = []\n    string_mode = False\n    \n    steps = 0\n    max_steps = 100000  # Prevent infinite loops\n    \n    while steps < max_steps:\n        if x < 0 or x >= rows_count or y < 0 or y >= cols_count:\n            return \"NO\"\n        \n        char = grid[x][y]\n        \n        if string_mode and char != '\"':\n            stack.append(ord(char))\n        else:\n            if char == '@':\n                return \"YES\"\n            elif char == '>':\n                current_dir = 0\n            elif char == '<':\n                current_dir = 1\n            elif char == 'v':\n                current_dir = 2\n            elif char == '^':\n                current_dir = 3\n            elif char == '?':\n                current_dir = steps % 4\n            elif char == '\"':\n                string_mode = not string_mode\n            elif char == '#':\n                dx, dy = directions[current_dir]\n                x += dx\n                y += dy\n            elif char == ' ':\n                pass\n            elif char.isdigit():\n                stack.append(int(char))\n            elif char == '+':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(a + b)\n            elif char == '-':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(b - a)\n            elif char == '*':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(a * b)\n            elif char == '/':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(b // a if a != 0 else 0)\n            elif char == '%':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(b % a if a != 0 else 0)\n            elif char == '!':\n                if stack:\n                    val = stack.pop()\n                    stack.append(1 if val == 0 else 0)\n            elif char == '`':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(1 if b > a else 0)\n            elif char == '_':\n                if stack:\n                    val = stack.pop()\n                    current_dir = 1 if val != 0 else 0\n            elif char == '|':\n                if stack:\n                    val = stack.pop()\n                    current_dir = 3 if val != 0 else 2\n            elif char == ':':\n                if stack:\n                    val = stack.pop()\n                    stack.append(val)\n                    stack.append(val)\n            elif char == '\\\\':\n                if len(stack) >= 2:\n                    a = stack.pop()\n                    b = stack.pop()\n                    stack.append(a)\n                    stack.append(b)\n            elif char == '$':\n                if stack:\n                    stack.pop()\n            elif char == '.':\n                if stack:\n                    stack.pop()\n            elif char == ',':\n                if stack:\n                    stack.pop()\n        \n        dx, dy = directions[current_dir]\n        x += dx\n        y += dy\n        steps += 1\n        \n        # Check for loops\n        state = (x, y, current_dir, tuple(stack), string_mode)\n        if state in visited:\n            return \"NO\"\n        visited.add(state)\n    \n    return \"NO\"",
    "timestamp": "2025-08-13 06:00:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nenum Direction { RIGHT, DOWN, LEFT, UP };\n\nstruct State {\n    int x, y, direction;\n    bool operator==(const State &other) const { return x == other.x && y == other.y && direction == other.direction; }\n};\n\nstruct StateHash {\n    size_t operator()(const State &s) const { return s.x ^ (s.y << 10) ^ (s.direction << 20); }\n};\n\nbool willHalt(const vector<vector<char>> &grid) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    unordered_set<State, StateHash> visited;\n    int x = 0, y = 0;\n    Direction dir = RIGHT;\n    \n    while (true) {\n        if (grid[y][x] == '@') return true;\n        State current = {x, y, dir};\n        \n        if (visited.find(current) != visited.end()) return false;\n        visited.insert(current);\n        \n        switch (grid[y][x]) {\n            case '>': dir = RIGHT; break;\n            case 'v': dir = DOWN; break;\n            case '<': dir = LEFT; break;\n            case '^': dir = UP; break;\n        }\n\n        switch (dir) {\n            case RIGHT: x = (x + 1) % cols; break;\n            case DOWN: y = (y + 1) % rows; break;\n            case LEFT: x = (x - 1 + cols) % cols; break;\n            case UP: y = (y - 1 + rows) % rows; break;\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<char>> grid(n, vector<char>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    cout << (willHalt(grid) ? \"YES\" : \"NO\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:31"
  }
]