[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val Array(r, c) = readLine.trim.split(' ').map(_.toInt)\n  val arg = Array.tabulate(r){_ ⇒ readLine.trim}\n  val program = new Program(arg)\n  val isReach = Array.tabulate(r){_ ⇒ Array.tabulate(c){_ ⇒ Array.tabulate(16){_ ⇒ Array.tabulate(4){_ ⇒ false}}}}\n  var state = List(State(Position(0, 0), Right, 0))\n  var reachToGoal = false\n  while (!reachToGoal && state.nonEmpty){\n    state = state.flatMap{s ⇒\n      program.doStep(s)\n    }.filterNot{\n      case State(Position(x, y), direction, memory) ⇒ isReach(y)(x)(memory)(direction.asInt)\n    }.also{states ⇒\n      states.foreach{\n        case State(p@Position(x, y), direction, memory) ⇒\n          isReach(y)(x)(memory)(direction.asInt) = true\n          if (program(p) == End)\n            reachToGoal = true\n      }\n    }\n  }\n  println(\n    if (reachToGoal) \"YES\" else \"NO\"\n  )\n\n  class Program(state: Array[String]) {\n    private val mState = state.map{line ⇒ line.map{\n      case '<' ⇒ SetToLeft\n      case '>' ⇒ SetToRight\n      case '^' ⇒ SetToUp\n      case 'v' ⇒ SetToDown\n      case '_' ⇒ Horizontal\n      case '|' ⇒ Vertical\n      case '?' ⇒ Random\n      case '.' ⇒ DoNothing\n      case '@' ⇒ End\n      case h if h.isDigit ⇒ Write(h.asDigit)\n      case '+' ⇒ Increment\n      case '-' ⇒ Decrement\n      case _ ⇒ ???\n    }.toArray}\n    private val mHeight = mState.length\n    private val mWidth = mState.head.length\n    def apply(position: Position): Token = mState(position.y)(position.x)\n    def doStep(state: State): List[State] = {\n      this(state.position).changeState(state).map{st ⇒ st.copy(position = st.position.move(st.direction)).let{s ⇒ s.copy(position = Position((s.position.x + mWidth) % mWidth, (s.position.y + mHeight) % mHeight))}}\n    }\n  }\n  case class State(position: Position, direction: Direction, memory: Int)\n\n  case class Position(x: Int, y: Int) {\n    def move(direction: Direction): Position = {\n      direction match {\n        case Right ⇒ Position(x + 1, y)\n        case Left ⇒ Position(x - 1, y)\n        case Up ⇒ Position(x, y - 1)\n        case Down ⇒ Position(x, y + 1)\n      }\n    }\n  }\n\n  sealed trait Direction {\n    def asInt: Int = this match {\n      case Right ⇒ 0\n      case Left ⇒ 1\n      case Up ⇒ 2\n      case Down ⇒ 3\n    }\n  }\n  case object Right extends Direction\n  case object Left extends Direction\n  case object Down extends Direction\n  case object Up extends Direction\n\n  sealed trait Token {\n    def changeState(state: State): List[State]\n  }\n  sealed trait SetDirection extends Token {\n    override def changeState(state: State): List[State] = {\n      (this match {\n        case SetToLeft ⇒ Left\n        case SetToRight ⇒ Right\n        case SetToUp ⇒ Up\n        case SetToDown ⇒ Down\n      }).let{dir ⇒ List(state.copy(direction = dir))}\n    }\n  }\n  case object SetToLeft extends SetDirection\n  case object SetToRight extends SetDirection\n  case object SetToUp extends SetDirection\n  case object SetToDown extends SetDirection\n  sealed trait ChangeDirection extends Token\n  case object Horizontal extends ChangeDirection {\n    override def changeState(state: State): List[State]= List(if (state.memory == 0) state.copy(direction = Right) else state.copy(direction = Left))\n  }\n  case object Vertical extends ChangeDirection {\n    override def changeState(state: State): List[State] = List(if (state.memory == 0) state.copy(direction = Down) else state.copy(direction = Up))\n  }\n  case object Random extends Token {\n    override def changeState(state: State): List[State] = {\n      List(Right, Left, Down, Up).map{dir ⇒ state.copy(direction = dir)}\n    }\n  }\n  case object DoNothing extends Token {\n    override def changeState(state: State): List[State] = List(state)\n  }\n  case object End extends Token {\n    override def changeState(state: State): List[State] = Nil\n  }\n  sealed trait ChangeMemory extends Token\n  case class Write(value: Int) extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = value))\n  }\n  case object Increment extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = (state.memory + 1) % 16))\n  }\n  case object Decrement extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = (state.memory + 15) % 16))\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val Array(r, c) = readLine.trim.split(' ').map(_.toInt)\n  val arg = Array.tabulate(r){_ ⇒ readLine.trim}\n  val program = new Program(arg)\n  val isReach = Array.tabulate(r){_ ⇒ Array.tabulate(c){_ ⇒ Array.tabulate(16){_ ⇒ Array.tabulate(4){_ ⇒ false}}}}\n  var state = List(State(Position(0, 0), Right, 0))\n  var reachToGoal = false\n  while (!reachToGoal && state.nonEmpty){\n    state.foreach{\n      case State(p@Position(x, y), direction, memory) ⇒\n        isReach(y)(x)(memory)(direction.asInt) = true\n        if (program(p) == End)\n          reachToGoal = true\n    }\n    state = state.flatMap{s ⇒\n      program.doStep(s)\n    }.filterNot{\n      case State(Position(x, y), direction, memory) ⇒ isReach(y)(x)(memory)(direction.asInt)\n    }\n  }\n  println(\n    if (reachToGoal) \"YES\" else \"NO\"\n  )\n\n  class Program(state: Array[String]) {\n    private val mState = state.map{line ⇒ line.map{\n      case '<' ⇒ SetToLeft\n      case '>' ⇒ SetToRight\n      case '^' ⇒ SetToUp\n      case 'v' ⇒ SetToDown\n      case '_' ⇒ Horizontal\n      case '|' ⇒ Vertical\n      case '?' ⇒ Random\n      case '.' ⇒ DoNothing\n      case '@' ⇒ End\n      case h if h.isDigit ⇒ Write(h.asDigit)\n      case '+' ⇒ Increment\n      case '-' ⇒ Decrement\n      case _ ⇒ ???\n    }.toArray}\n    private val mHeight = mState.length\n    private val mWidth = mState.head.length\n    def apply(position: Position): Token = mState(position.y)(position.x)\n    def doStep(state: State): List[State] = {\n      this(state.position).changeState(state).map{st ⇒ st.copy(position = st.position.move(st.direction)).let{s ⇒ s.copy(position = Position((s.position.x + mWidth) % mWidth, (s.position.y + mHeight) % mHeight))}}\n    }\n  }\n  case class State(position: Position, direction: Direction, memory: Int)\n\n  case class Position(x: Int, y: Int) {\n    def move(direction: Direction): Position = {\n      direction match {\n        case Right ⇒ Position(x + 1, y)\n        case Left ⇒ Position(x - 1, y)\n        case Up ⇒ Position(x, y - 1)\n        case Down ⇒ Position(x, y + 1)\n      }\n    }\n  }\n\n  sealed trait Direction {\n    def asInt: Int = this match {\n      case Right ⇒ 0\n      case Left ⇒ 1\n      case Up ⇒ 2\n      case Down ⇒ 3\n    }\n  }\n  case object Right extends Direction\n  case object Left extends Direction\n  case object Down extends Direction\n  case object Up extends Direction\n\n  sealed trait Token {\n    def changeState(state: State): List[State]\n  }\n  sealed trait SetDirection extends Token {\n    override def changeState(state: State): List[State] = {\n      (this match {\n        case SetToLeft ⇒ Left\n        case SetToRight ⇒ Right\n        case SetToUp ⇒ Up\n        case SetToDown ⇒ Down\n      }).let{dir ⇒ List(state.copy(direction = dir))}\n    }\n  }\n  case object SetToLeft extends SetDirection\n  case object SetToRight extends SetDirection\n  case object SetToUp extends SetDirection\n  case object SetToDown extends SetDirection\n  sealed trait ChangeDirection extends Token\n  case object Horizontal extends ChangeDirection {\n    override def changeState(state: State): List[State]= List(if (state.memory == 0) state.copy(direction = Right) else state.copy(direction = Left))\n  }\n  case object Vertical extends ChangeDirection {\n    override def changeState(state: State): List[State] = List(if (state.memory == 0) state.copy(direction = Down) else state.copy(direction = Up))\n  }\n  case object Random extends Token {\n    override def changeState(state: State): List[State] = {\n      List(Right, Left, Down, Up).map{dir ⇒ state.copy(direction = dir)}\n    }\n  }\n  case object DoNothing extends Token {\n    override def changeState(state: State): List[State] = List(state)\n  }\n  case object End extends Token {\n    override def changeState(state: State): List[State] = Nil\n  }\n  sealed trait ChangeMemory extends Token\n  case class Write(value: Int) extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = value))\n  }\n  case object Increment extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = (state.memory + 1) % 16))\n  }\n  case object Decrement extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = (state.memory + 15) % 16))\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  val Array(r, c) = readLine.trim.split(' ').map(_.toInt)\n  val arg = Array.tabulate(r){_ ⇒ readLine.trim}\n  val program = new Program(arg)\n  val isReach = Array.tabulate(r){_ ⇒ Array.tabulate(c){_ ⇒ Array.tabulate(16){_ ⇒ Array.tabulate(4){_ ⇒ false}}}}.also{m ⇒ m(0)(0)(0)(Right.asInt) = true}\n  var state = List(State(Position(0, 0), Right, 0))\n  var reachToGoal = program(Position(0, 0)) == End\n  while (!reachToGoal && state.nonEmpty){\n    state = state.flatMap{s ⇒\n      program.doStep(s)\n    }.filterNot{\n      case State(p@Position(x, y), direction, memory) if !isReach(y)(x)(memory)(direction.asInt) ⇒\n        isReach(y)(x)(memory)(direction.asInt) = true\n        if (program(p) == End)\n          reachToGoal = true\n        false\n      case _ ⇒ true: Boolean\n    }\n  }\n  println(\n    if (reachToGoal) \"YES\" else \"NO\"\n  )\n\n  class Program(state: Array[String]) {\n    private val mState = state.map{line ⇒ line.map{\n      case '<' ⇒ SetToLeft\n      case '>' ⇒ SetToRight\n      case '^' ⇒ SetToUp\n      case 'v' ⇒ SetToDown\n      case '_' ⇒ Horizontal\n      case '|' ⇒ Vertical\n      case '?' ⇒ Random\n      case '.' ⇒ DoNothing\n      case '@' ⇒ End\n      case h if h.isDigit ⇒ Write(h.asDigit)\n      case '+' ⇒ Increment\n      case '-' ⇒ Decrement\n      case _ ⇒ ???\n    }.toArray}\n    private val mHeight = mState.length\n    private val mWidth = mState.head.length\n    def apply(position: Position): Token = mState(position.y)(position.x)\n    def doStep(state: State): List[State] = {\n      this(state.position).changeState(state).map{st ⇒ st.copy(position = st.position.move(st.direction)).let{s ⇒ s.copy(position = Position((s.position.x + mWidth) % mWidth, (s.position.y + mHeight) % mHeight))}}\n    }\n  }\n  case class State(position: Position, direction: Direction, memory: Int)\n\n  case class Position(x: Int, y: Int) {\n    def move(direction: Direction): Position = {\n      direction match {\n        case Right ⇒ Position(x + 1, y)\n        case Left ⇒ Position(x - 1, y)\n        case Up ⇒ Position(x, y - 1)\n        case Down ⇒ Position(x, y + 1)\n      }\n    }\n  }\n\n  sealed trait Direction {\n    def asInt: Int = this match {\n      case Right ⇒ 0\n      case Left ⇒ 1\n      case Up ⇒ 2\n      case Down ⇒ 3\n    }\n  }\n  case object Right extends Direction\n  case object Left extends Direction\n  case object Down extends Direction\n  case object Up extends Direction\n\n  sealed trait Token {\n    def changeState(state: State): List[State]\n  }\n  sealed trait SetDirection extends Token {\n    override def changeState(state: State): List[State] = {\n      (this match {\n        case SetToLeft ⇒ Left\n        case SetToRight ⇒ Right\n        case SetToUp ⇒ Up\n        case SetToDown ⇒ Down\n      }).let{dir ⇒ List(state.copy(direction = dir))}\n    }\n  }\n  case object SetToLeft extends SetDirection\n  case object SetToRight extends SetDirection\n  case object SetToUp extends SetDirection\n  case object SetToDown extends SetDirection\n  sealed trait ChangeDirection extends Token\n  case object Horizontal extends ChangeDirection {\n    override def changeState(state: State): List[State]= List(if (state.memory == 0) state.copy(direction = Right) else state.copy(direction = Left))\n  }\n  case object Vertical extends ChangeDirection {\n    override def changeState(state: State): List[State] = List(if (state.memory == 0) state.copy(direction = Down) else state.copy(direction = Up))\n  }\n  case object Random extends Token {\n    override def changeState(state: State): List[State] = {\n      List(Right, Left, Down, Up).map{dir ⇒ state.copy(direction = dir)}\n    }\n  }\n  case object DoNothing extends Token {\n    override def changeState(state: State): List[State] = List(state)\n  }\n  case object End extends Token {\n    override def changeState(state: State): List[State] = Nil\n  }\n  sealed trait ChangeMemory extends Token\n  case class Write(value: Int) extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = value))\n  }\n  case object Increment extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = (state.memory + 1) % 16))\n  }\n  case object Decrement extends ChangeMemory {\n    override def changeState(state: State): List[State] = List(state.copy(memory = (state.memory + 15) % 16))\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// right, down, left, up\nconst int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nint H, W;\nchar Prog[20][20];\n\nbool G[20][20][4][16]; // y, x, cour, memory\n\nbool run(int x, int y, int cour, int mem) {\n    while (!G[y][x][cour][mem]) {\n        G[y][x][cour][mem] = true;\n\n        switch (Prog[y][x]) {\n        case '<':\n            cour = 2;\n            break;\n        case '>':\n            cour = 0;\n            break;\n        case '^':\n            cour = 3;\n            break;\n        case 'v':\n            cour = 1;\n            break;\n        case '_':\n            if (mem == 0) {\n                cour = 0;\n            } else {\n                cour = 2;\n            }\n            break;\n        case '|':\n            if (mem == 0) {\n                cour = 1;\n            } else {\n                cour = 3;\n            }\n            break;\n        case '?':\n            REP(i, 4) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (sx < 0)  sx = W-1;\n                if (sx >= W) sx = 0;\n                if (sy < 0)  sy = H-1;\n                if (sy >= H) sy = 0;\n                if (run(sx, sy, i, mem)) return true;\n            }\n            return false;\n        case '.':\n            break;\n        case '@':\n            return true;\n        case '+':\n            if (mem == 15) {\n                mem = 0;\n            } else {\n                mem++;\n            }\n            break;\n        case '-':\n            if (mem == 0) {\n                mem = 15;\n            } else {\n                mem--;\n            }\n            break;\n        default: // number\n            mem = Prog[y][x] - '0';\n        }\n\n        x += dx[cour];\n        y += dy[cour];\n        if (x < 0)  x = W-1;\n        if (x >= W) x = 0;\n        if (y < 0)  y = H-1;\n        if (y >= H) y = 0;\n\n//        LOG(\"%02d\\n\", mem);\n//        REP(sy, H) {\n//            REP(sx, W) {\n//                if (sx == x && sy == y) {\n//                    LOG(\"#\");\n//                } else {\n//                    LOG(\"%c\", Prog[sy][sx]);\n//                }\n//            }\n//            LOG(\"\\n\");\n//        }\n//        getchar();\n    }\n    return false;\n}\n\nint main() {\n    cin >> H >> W;\n    bool stoppable = false;\n    REP(y, H) REP(x, W) {\n        cin >> Prog[y][x];\n        if (Prog[y][x] == '@') {\n            stoppable = true;\n        }\n    }\n    cout << (stoppable && run(0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 16;\n\nint H, W;\nstring M[MAX_H];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  case '?':\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i]+W)%W, (y+dy[i]+H)%H, i, mem)) return 1;\n    }\n    return 0;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n  return run((x+dx[dir]+W)%W, (y+dy[dir]+H)%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory+1 == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory-1 == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nbool visited[21][21][16];\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><v^\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (order[y][x] == '@')\n    return true;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') {\n    if (mem == 0)\n      d = change('>');\n    else \n      d = change('<');\n  }\n  else if (ch == '|') {\n    if (mem == 0)\n      d = change('v');\n    else\n      d = change('^');\n  }\n  else if (ch >= '0' && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    (mem == 15) ? (mem = 0) : mem++;\n  else if (ch == '-')\n    (mem == 0) ? (mem = 15) : mem--;\n\n\n  if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  else \n    return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int mem=0;mem<=15;mem++){\n    for(int dir=0;dir<4;dir++){\n      if(visited[gx][gy][mem][dir]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n\n    que.push(State((1<<1),0,0,0));\n\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM next_dir_mem = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(next_dir_mem.mDir & (1<<dir))) continue;\n\tint dx = (tx[dir] + x + W) % W;\n\tint dy = (ty[dir] + y + H) % H;\n\n\tif(visited[dx][dy][next_dir_mem.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),next_dir_mem.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][next_dir_mem.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n??\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n??\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n??\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n??\n#define DOWN?? 0\n#define RIGHT 1\n#define UP?????? 2\n#define LEFT?? 3\n??\nstruct State {\n????int x, y;\n????int mem;\n????int dir;\n??\n????State() :\n????????????x(0),\n????????????y(0),\n????????????mem(0),\n????????????dir(RIGHT) {}\n??\n????State(int x, int y, int mem, int dir) :\n????????????x(x),\n????????????y(y),\n????????????mem(mem),\n????????????dir(dir) {}\n??\n????bool operator<(const State & rhs) const {\n????????if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n????????if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n????????if (x == rhs.x) return y < rhs.y;\n????????return x < rhs.x;\n????}\n};\n??\nint main() {\n????ios_base::sync_with_stdio(false); cin.tie(0);\n????int R, C;\n????cin >> R >> C;\n????vector<string> prog(R);\n????rep(i, R) cin >> prog[i];\n??\n????set<State> visited;\n????queue<State> Q;\n????ll ok = false;\n??\n????Q.push(State());\n????while (!Q.empty()) {\n????????State st = Q.front();\n????????Q.pop();\n??\n????????st.x = (st.x + C) % C;\n????????st.y = (st.y + R) % R;\n??\n????????if (visited.find(st) != visited.end())\n????????????continue;\n??????????\n????????visited.insert(st);\n??\n????????char p;\n????????p = prog[st.y][st.x];\n??\n????????if (p == '@') {\n????????????ok = true;\n????????????break;\n????????}\n??\n????????switch (p) {\n????????????case '0'...'9':\n????????????????st.mem = p - '0';\n????????????????break;\n????????????case '_':\n????????????????if (st.mem == 0) st.dir = RIGHT;\n????????????????else st.dir = LEFT;\n????????????????break;\n????????????case '|':\n????????????????if (st.mem == 0) st.dir = DOWN;\n????????????????else st.dir = UP;\n????????????????break;\n????????????case '+':\n????????????????st.mem = (st.mem + 1) % 16;\n????????????????break;\n????????????case '-':\n????????????????st.mem = st.mem - 1;\n????????????????if (st.mem < 0) st.mem += 16;\n????????????????break;\n????????????case '^':\n????????????????st.dir = UP;\n????????????????break;\n????????????case 'v':\n????????????????st.dir = DOWN;\n????????????????break;\n????????????case '<':\n????????????????st.dir = LEFT;\n????????????????break;\n????????????case '>':\n????????????????st.dir = RIGHT;\n????????????????break;\n????????}\n??\n????????if (p != '?') {\n????????????Q.push(State(st.x + dx[st.dir], st.y + dy[st.dir], st.mem, st.dir));\n????????} else {\n????????????Q.push(State(st.x + dx[LEFT],???? st.y + dy[LEFT],?? st.mem, LEFT));\n????????????Q.push(State(st.x + dx[RIGHT],?? st.y + dy[RIGHT], st.mem, RIGHT));\n????????????Q.push(State(st.x + dx[UP],???????? st.y + dy[UP],?????? st.mem, UP));\n????????????Q.push(State(st.x + dx[DOWN],???? st.y + dy[DOWN],?? st.mem, DOWN));\n????????}\n????}\n??????\n????if (ok) cout << \"YES\" << endl;\n????else cout << \"NO\" << endl;\n????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][16];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s(0,0,LEFT,0);\n  Q.push(s);\n  visited[s.x][s.y][s.d][s.m] = true;\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C;\n  cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  visited[s.x][s.y][s.d][s.m] = true;\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C;\n  cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  //DbgPrint(21*21*4*16);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\n\nchar T[22]=\"0123456789^>v<?_|.+-@\";\nint x[25][25],h,w;char c;\nint dp[25][25][16][4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint ab,a1,a2,a3,a4,X;\ntuple<int,int,int,int>tup;\nqueue<tuple<int,int,int,int>>Q;\n\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>c;\n\t\t\tfor(int k=0;k<21;k++){\n\t\t\t\tif(T[k]==c){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][1]=1;\n\tQ.push(make_tuple(0,0,0,1));\n\twhile(!Q.empty()){\n\t\ttup=Q.front();\n\t\tQ.pop();\n\t\ta1=get<0>(tup);\n\t\ta2=get<1>(tup);\n\t\ta3=get<2>(tup);\n\t\ta4=get<3>(tup);\n\t\tX=x[a1][a2];\n\t\tif(X>=0 && X<=9){\n\t\t\ta3=X;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X>=10 && X<=13){\n\t\t\ta4=X-10;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==14){\n\t\t\tfor(int n=0;n<4;n++){\n\t\t\t\ta4=n;\n\t\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(X==15){\n\t\t\tif(a3==0){\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==16){\n\t\t\tif(a3==0){\n\t\t\t\ta4=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=0;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==17){\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tab=1;\n\t\tif(X==18 || X==19){\n\t\t\tif(X==19){ab=-1;}\n\t\t\ta3=(a3+ab+16)%16;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==20){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tgoto E;\n\t\t}\n\t}\n\tcout<<\"NO\"<<endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nstruct S{\n  int x,y,r,m;\n  S(int x,int y,int r,int m) :\n    x(x),y(y),r(r),m(m) {}\n  bool operator < (const S& s) const {\n    return (x!=s.x)?(x<s.x):(y!=s.y)?(y<s.y):(r!=s.r)?(r<s.r):(m<s.m);\n  }\n};\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main(){\n  int h,w;\n  while(cin>>h>>w){\n    vector<string> grid(h);\n    REP(i,h)cin>>grid[i];\n    queue<S> que;\n    set<S> used;\n    que.push(S(0,0,0,0));\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(used.find(s)!=used.end()) continue;\n      used.insert(s);\n      bool all = false;\n      bool end = false;\n      switch(grid[s.y][s.x]){\n        case '<':\n          s.r = 2;\n          break;\n        case '>':\n          s.r = 0;\n          break;\n        case '^':\n          s.r = 3;\n          break;\n        case 'v':\n          s.r = 1;\n          break;\n        case '_':\n          s.r = ((s.m)?2:0);\n          break;\n        case '|':\n          s.r = ((s.m)?3:1);\n          break;\n        case '?':\n          all = true;\n          break;\n        case '.':\n          break;\n        case '@':\n          end = true;\n          break;\n        case '+':\n          s.m = (s.m+1)%16;\n          break;\n        case '-':\n          s.m = (s.m+16-1)%16;\n          break;\n      }\n      if(end){\n        cout<<\"YES\"<<endl;\n        goto END;\n      }\n      if(grid[s.y][s.x]<='9'&&grid[s.y][s.x]>='0'){\n        s.m = (grid[s.y][s.x]-'0');\n      }\n      for(int r = 0; r < 4; r++){\n        if(all || s.r == r){\n          int nx = (s.x+dx[r]+w)%w;\n          int ny = (s.y+dy[r]+h)%h;\n          que.push(S(nx,ny,r,s.m));\n        }\n      }\n    }\n    cout<<\"NO\"<<endl;  \nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar map[23][23], dp[20][20][4][16];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\n\nint search(int x,int y, int d, int m){\n\twhile(1){\n\t\tx=(x+w)%w;y=(y+h)%h;\n\t\tchar c = map[y][x];\n\t\tif(dp[x][y][d][m]) return 0;\n\t\tdp[x][y][d][m] = 1;\n\t\tif(c == '<') d = 2;\n\t\tif(c == '>') d = 0;\n\t\tif(c == '^') d = 3;\n\t\tif(c == 'v') d = 1;\n\t\tif(c == '_') d = (m)?2:0;\n\t\tif(c == '|') d = (m)?3:1;\n\t\tif(c == '@') return 1;\n\t\tif(c == '+') m=(m+1)%16;\n\t\tif(c == '-') m=(m+15)%16;\n\t\tif(c >= '0' && c <= '9') m=c-'0';\n\t\tif(c == '?'){\n\t\t\tfor(d=0;d<4;d++) if(search(x+dx[d],y+dy[d],d,m)) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tx += dx[d];y += dy[d];\n\t}\n}\nmain(){\n\tint i,j;\n\tchar *p,*q;\n\tcin>>h>>w;\n\tfor(i=0;i<h;i++) cin>>map[i];\n\tcout << ((search(0, 0, 0, 0))?\"YES\":\"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\nbool random_flag[MAX][MAX][4];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, int& dir, int& memory) {\n    switch (symbol) {\n        case '<':\n            dir = 2;\n            break;\n\n        case '>':\n            dir = 0;\n            break;\n\n        case '^':\n            dir = 1;\n            break;\n\n        case 'v':\n            dir = 3;\n            break;\n\n        case '_':\n            if (memory == 0) dir = 0;\n            else dir = 2;\n            break;\n\n        case '|':\n            if (memory == 0) dir = 3;\n            else dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (memory == 15) memory = 0;\n            else memory++;\n            break;\n\n        case '-':\n            if (memory == 0) memory = 15;\n            else memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col, int dir, int memory) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col], dir, memory);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            nx = (nx + C) % C;\n            ny = (ny + R) % R;\n            dfs(ny, nx, dir, memory);\n        }\n    }else {\n        nx = col + dx[dir];\n        ny = row + dy[dir];\n        nx = (nx + C) % C;\n        ny = (ny + R) % R;\n        dfs(ny, nx, dir, memory);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            for (int k = 0; k < 4; k++) {\n                random_flag[i][j][k] = false;\n            }\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0, 0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  int cnt=0;\n  while(!Q.empty()) {\n    if(cnt>21*21*4*16) break;\n    cnt++;\n\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  //DbgPrint(21*21*4*16);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring f[21];\nint w,h;\nbool ans = false;\nint d_[256] = {0};\n\ninline int pow2(int n){\n    return ( 1 << n );\n}\n\nvoid solve( int x , int y , int d , int memory , vector<int> a[500] ){\n    int state = pow2( memory+4 ) + d_[d];\n    if( ans ){\n        return;\n    }\n\n    if( count( a[y*w+x].begin() , a[y*w+x].end() , state ) ){\n        return;\n    }else{\n        a[y*w+x].push_back( state );\n    }\n\n    if( f[y][x] == '<' ){\n        d = '<';\n    }else if( f[y][x] == '>' ){\n        d = '>';\n    }else if( f[y][x] == '^' ){\n        d = '^';\n    }else if( f[y][x] == 'v' ){\n        d = 'v';\n    }else if( f[y][x] == '_' ){\n        d = ( memory )? '<' : '>' ;\n    }else if( f[y][x] == '|' ){\n        d = ( memory )? '^' : 'v' ;\n    }else if( f[y][x] == '?' ){\n        solve( (x+1)%w , y , '>' , memory , a );\n        solve( x , (y+1)%h , 'v' , memory , a );\n        solve( (x+w-1)%w , y , '<' , memory , a );\n        solve( x , (y+h-1)%h , '^' , memory , a );\n        return;\n    }else if( f[y][x] == '.' ){\n        ;\n    }else if( f[y][x] == '@' ){\n        ans = true;\n        return;\n    }else if( f[y][x] >= '0' && f[y][x] <= '9' ){\n        memory = f[y][x] - '0';\n    }else if( f[y][x] == '+' ){\n        memory = (memory + 1) % 16 ;\n    }else if( f[y][x] == '-' ){\n        memory = (memory + 15) % 16;\n    }\n    if( d == '>' ){\n        solve( (x+1)%w , y , d , memory , a );\n    }else if( d == '<' ){\n        solve( (x+w-1)%w , y , d , memory , a );\n    }else if( d == 'v' ){\n        solve( x , (y+1)%h   , d , memory , a );\n    }else if( d == '^' ){\n        solve( x , (y+h-1)%h , d , memory , a );\n    }\n}\nint main(){\n    vector<int> a[500];\n    d_['<'] = 1;\n    d_['>'] = 2;\n    d_['^'] = 4;\n    d_['v'] = 8;\n    cin >> h >> w;\n    for(int i=0 ; i<h ; ++i ){\n        cin >> f[i];\n    }\n    int x = 0;\n    int y = 0;\n    int d = '>';\n    solve( x , y , d , 0 , a );\n    if( ans ){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// right, down, left, up\nconst int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nint H, W;\nchar Prog[20][20];\n\nbool G[20][20][4][16]; // y, x, cour, memory\n\nbool run(int x, int y, int cour, int mem) {\n    do {\n        G[y][x][cour][mem] = true;\n        switch (Prog[y][x]) {\n        case '<':\n            cour = 2;\n            break;\n        case '>':\n            cour = 0;\n            break;\n        case '^':\n            cour = 3;\n            break;\n        case 'v':\n            cour = 1;\n            break;\n        case '_':\n            if (mem == 0) {\n                cour = 0;\n            } else {\n                cour = 2;\n            }\n            break;\n        case '|':\n            if (mem == 0) {\n                cour = 1;\n            } else {\n                cour = 3;\n            }\n            break;\n        case '?':\n            REP(i, 4) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (sx < 0)  sx = W-1;\n                if (sx >= W) sx = 0;\n                if (sy < 0)  sy = H-1;\n                if (sy >= H) sy = 0;\n                if (run(sx, sy, i, mem)) return true;\n            }\n            return false;\n        case '.':\n            break;\n        case '@':\n            return true;\n        case '+':\n            if (mem == 15) {\n                mem = 0;\n            } else {\n                mem++;\n            }\n            break;\n        case '-':\n            if (mem == 0) {\n                mem = 15;\n            } else {\n                mem--;\n            }\n            break;\n        default: // number\n            mem = Prog[y][x] - '0';\n        }\n\n        x += dx[cour];\n        y += dy[cour];\n        if (x < 0)  x = W-1;\n        if (x >= W) x = 0;\n        if (y < 0)  y = H-1;\n        if (y >= H) y = 0;\n\n//        LOG(\"%02d\\n\", mem);\n//        REP(sy, H) {\n//            REP(sx, W) {\n//                if (sx == x && sy == y) {\n//                    LOG(\"#\");\n//                } else {\n//                    LOG(\"%c\", Prog[sy][sx]);\n//                }\n//            }\n//            LOG(\"\\n\");\n//        }\n//        getchar();\n    } while (!G[y][x][cour][mem]);\n\n    return false;\n}\n\nint main() {\n    cin >> H >> W;\n    REP(y, H) REP(x, W) {\n        cin >> Prog[y][x];\n    }\n    cout << (run(0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする．\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();．\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][15],int gx,int gy){\n  for(int i=0;i<15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][15];\n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] = '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d\\n\",s.mMemory,x,y);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 21;\nconst int MAX_W = 21;\nconst int MAX_M = 11;\n\nint H, W;\nstring M[20];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\n#define MAX 25\n\nint H,W,mem;\nchar field[MAX][MAX];\nbool visited[MAX][MAX][16];\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nvoid Nextpos(int &y,int &x){\n  if(x >= W){\n    x = 0;\n  }else if(y >= H){\n    y = 0;\n  }else if(x < 0){\n    x = W-1;\n  }else if(y < 0){\n    y = H-1;\n  }\n}\n\nbool solve(int y,int x,int dir){\n  if(x >= 0 && field[y][x] == '@') return true;\n  if(x >= 0 && visited[y][x][mem]) return false;\n  if(x >= 0) visited[y][x][mem] = true;\n\n  int nx = x + dx[dir], ny = y + dy[dir];\n  Nextpos(ny,nx);\n  \n  if(isdigit(field[ny][nx])){\n    mem = field[ny][nx] - '0';\n  }else{\n    switch(field[ny][nx]){\n    case '>':\n      dir = 0;\n      break;\n    case 'v':\n      dir = 1;\n      break;\n    case '<':\n      dir = 2;\n      break;\n    case '^':\n      dir = 3;\n      break;\n    case '_':\n      dir = (mem == 0 ? 0 : 2);\n      break;\n    case '|':\n      dir = (mem == 0 ? 1 : 3);\n      break;\n    case '?':\n      for(int i = 0 ; i < 4 ; i++){\n        if(solve(ny,nx,i)) return true;\n      }\n      break;\n    case '+':\n      mem = (mem == 15 ? 0 : mem+1);\n      break;\n    case '-':\n      mem = (mem == 0 ? 15 : mem-1);\n      break;\n    }\n  }\n  if(solve(ny,nx,dir)) return true;\n  return false;\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n    }\n  }\n  mem = 0;\n  memset(visited,false,sizeof(visited));\n  cout << (solve(0,-1,0) ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\n\nchar T[22]=\"0123456789^>v<?_|.+-@\";\nint x[25][25],h,w;char c;\nint dp[25][25][16][4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint ab,a1,a2,a3,a4,X;\ntuple<int,int,int,int>tup;\nqueue<tuple<int,int,int,int>>Q;\n\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>c;\n\t\t\tfor(int k=0;k<21;k++){\n\t\t\t\tif(T[k]==c){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][1]=1;\n\tQ.push(make_tuple(0,0,0,1));\n\twhile(!Q.empty()){\n\t\ttup=Q.front();\n\t\tQ.pop();\n\t\ta1=get<0>(tup);\n\t\ta2=get<1>(tup);\n\t\ta3=get<2>(tup);\n\t\ta4=get<3>(tup);\n\t\tX=x[a1][a2];\n\t\tif(X>=0 && X<=9){\n\t\t\ta3=X;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X>=10 && X<=13){\n\t\t\ta4=X-10;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==14){\n\t\t\tfor(int n=0;n<4;n++){\n\t\t\t\ta4=n;\n\t\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(X==15){\n\t\t\tif(a3==0){\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==16){\n\t\t\tif(a3==0){\n\t\t\t\ta4=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=0;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==17){\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tab=1;\n\t\tif(X==18 || X==19){\n\t\t\tif(X==19){ab=-1;}\n\t\t\ta3=(a3+ab+16)%16;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==20){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tgoto E;\n\t\t}\n\t}\n\tcout<<\"NO\"<<endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\ntypedef vector <string> VS;\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> PPP;\ntypedef set <PPP> SPPP;\n\nint R, C;\nVS P;\nSPPP M;\n\nbool dfs( int a, int m, int x, int y ) {\n  int na = a, nm = m, nx = x, ny = y;\n  char op = P[y][x];\n\n  // check\n  PPP q( PII( a, m ), PII( x, y ) );\n  if ( M.find( q ) != M.end() ) {\n    return false;\n  }\n  M.insert( q );\n  \n  // operation\n  if ( op == '<' ) {\n    na = 0;\n  } else if ( op == '^' ) {\n    na = 1;\n  } else if ( op == '>' ) {\n    na = 2;\n  } else if ( op == 'v' ) {\n    na = 3;\n  } else if ( op == '_' ) {\n    if ( m == 0 ) {\n      na = 2;\n    } else {\n      na = 0;\n    }\n  } else if ( op == '|' ) {\n    if ( m == 0 ) {\n      na = 3;\n    } else {\n      na = 1;\n    }\n  } else if ( op == '?' ) {\n    for ( int i = 0; i < 4; i++ ) {\n      na = i;\n      int nnx = x, nny = y;\n      // move\n      if ( na == 0 ) {\n\tnnx--;\n      } else if ( na == 1 ) {\n\tnny--;\n      } else if ( na == 2 ) {\n\tnnx++;\n      } else if ( na == 3 ) {\n\tnny++;\n      }\n\n      if ( nnx >= C ) {\n\tnnx = 0;\n      } else if ( nnx < 0 ) {\n\tnnx = C - 1;\n      }\n      if ( nny >= R ) {\n\tnny = 0;\n      } else if ( nny < 0 ) {\n\tnny = R - 1;\n      }\n\n      if ( dfs( na, nm, nnx, nny ) ) return true;\n    }\n    return false;\n  } else if ( op == '.' ) {\n    // empty\n  } else if ( op == '@' ) {\n    return true;\n  } else if ( op >= '0' && op <= '9' ) {\n    nm = (int)( op - '0' );\n  } else if ( op == '+' ) {\n    nm = ( nm + 1 ) % 16;\n  } else if ( op == '-' ) {\n    nm = ( nm - 1 ) % 16;\n  }\n\n  // move\n  if ( na == 0 ) {\n    nx--;\n  } else if ( na == 1 ) {\n    ny--;\n  } else if ( na == 2 ) {\n    nx++;\n  } else if ( na == 3 ) {\n    ny++;\n  }\n\n  if ( nx >= C ) {\n    nx = 0;\n  } else if ( nx < 0 ) {\n    nx = C - 1;\n  }\n  if ( ny >= R ) {\n    ny = 0;\n  } else if ( ny < 0 ) {\n    ny = R - 1;\n  }\n\n  if ( dfs( na, nm, nx, ny ) ) return true;\n  return false;\n}\n\nint main( void ) {\n  cin >> R >> C;\n  for ( int i = 0; i < R; i++ ) {\n    string line;\n    cin >> line;\n    P.push_back( line );\n  }\n  bool result = dfs( 2, 0, 0, 0 );\n  cout << ( result ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  int dx[4] = { 1, -1,  0,  0 };\n  int dy[4] = { 0,  0,  1, -1 };\n\n  long long int r, c;\n  cin >> r >> c;\n\n  vector< string > p;\n\n  for ( long long int i = 0; i < r; i++ ) {\n\n    string in;\n    cin >> in;\n    p.push_back( in );\n\n  }\n\n  queue< long long int > qx, qy, qm, qd;\n  qx.push(0);\n  qy.push(0);\n  qm.push(0);\n  qd.push(0);\n\n  bool ans = false;\n\n  bool f[21][21][16][4] = {};\n\n  while( qx.size() > 0 ) {\n\n    long long int x, y, m, d;\n    x = qx.front();\n    qx.pop();\n    y = qy.front();\n    qy.pop();\n    m = qm.front();\n    qm.pop();\n    d = qd.front();\n    qd.pop();\n\n    for (;;) {\n\n      //      cout << x << \" \" << y << \" \" << m << \" \" << d << endl;\n\n      f[y][x][m][d] = true;\n\n      if ( p[y][x] == '>' ) {\n\td = 0;\n      }else if ( p[y][x] == '<' ) {\n\td = 1;\n      }else if ( p[y][x] == 'v' ) {\n\td = 2;\n      }else if ( p[y][x] == '^' ) {\n\td = 3;\n      }else if ( p[y][x] == '_' ) {\n\tif ( m == 0 ) {\n\t  d = 0;\n\t}else {\n\t  d = 1;\n\t}\n      }else if ( p[y][x] == '|' ) {\n\tif ( m == 0 ) {\n\t  d = 2;\n\t}else {\n\t  d = 3;\n\t}\n      }else if ( p[y][x] == '@' ) {\n\tans = true;\n\tbreak;\n      }else if ( p[y][x] == '+' ) {\n\tm++;\n\tif ( m == 16 ) m = 0;\n      }else if ( p[y][x] == '-' ) {\n\tm--;\n\tif ( m == -1 ) m = 15;\n      }else if ( p[y][x] == '.' ) {\n      }else if ( p[y][x] == '?' ) {\n\td = 0;\n\tfor ( int j = 1; j < 4; j++ ) {\n\t  int cx = ( x + dx[j] + c ) % c;\n\t  int cy = ( y + dy[j] + r ) % r;\n\t  if ( f[cy][cx][m][j] == true ) continue;\n\t  f[cy][cx][m][j] = true;\n\t  qx.push(cx);\n\t  qy.push(cy);\n\t  qm.push(m);\n\t  qd.push(j);\n\t}\n      }else {\n\tm = p[y][x] - '0';\n      }\n\n      f[y][x][m][d] = true;\n      x = ( x + dx[d] + c ) % c;\n      y = ( y + dy[d] + r ) % r;\n      if ( f[y][x][m][d] == true ) break;\n\n    }\n\n    if ( ans == true ) break;\n\n  }\n\n  if ( ans == true ) {\n    cout << \"YES\" << endl;\n  }else {\n    cout << \"NO\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\n \nusing namespace std;\n \n#define MAX 25\n \nint H,W,mem;\nchar field[MAX][MAX];\nbool visited[MAX][MAX][16][4];\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n \nvoid Nextpos(int &y,int &x){\n    if(x >= W){\n\tx = 0;\n    }else if(y >= H){\n\ty = 0;\n    }else if(x < 0){\n\tx = W-1;\n    }else if(y < 0){\n\ty = H-1;\n    }\n}\n \nbool solve(int y,int x,int dir){\n    if(x >= 0 && field[y][x] == '@') return true;\n    if(x >= 0 && visited[y][x][mem][dir]) return false;\n    if(x >= 0) visited[y][x][mem][dir] = true;\n \n    int nx = x + dx[dir], ny = y + dy[dir];\n    Nextpos(ny,nx);\n   \n    if(isdigit(field[ny][nx])){\n\tmem = field[ny][nx] - '0';\n    }else{\n\tswitch(field[ny][nx]){\n\tcase '>':\n\t    dir = 0;\n\t    break;\n\tcase 'v':\n\t    dir = 1;\n\t    break;\n\tcase '<':\n\t    dir = 2;\n\t    break;\n\tcase '^':\n\t    dir = 3;\n\t    break;\n\tcase '_':\n\t    dir = (mem == 0 ? 0 : 2);\n\t    break;\n\tcase '|':\n\t    dir = (mem == 0 ? 1 : 3);\n\t    break;\n\tcase '?':\n\t    for(int i = 0 ; i < 4 ; i++){\n\t\tif(solve(ny,nx,i)) return true;\n\t    }\n\t    break;\n\tcase '+':\n\t    mem = (mem == 15 ? 0 : mem+1);\n\t    break;\n\tcase '-':\n\t    mem = (mem == 0 ? 15 : mem-1);\n\t    break;\n\t}\n    }\n    if(solve(ny,nx,dir)) return true;\n    return false;\n}\n \nint main(){\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> field[i][j];\n\t}\n    }\n    mem = 0;\n    memset(visited,false,sizeof(visited));\n    cout << (solve(0,-1,0) ? \"YES\" : \"NO\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][15],int gx,int gy){\n  for(int i=0;i<15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][15];\n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] = '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d\\n\",s.mMemory,x,y);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar map[22][22], dp[22][22][4][16];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint search(int x,int y, int d, int m){\n\twhile(1){\n\t\tprintf(\"%d %d %d %d\\n\", x,y,d,m);\n\t\tx=(x+16)%16;y=(y+16)%16;\n\t\tchar c = map[y][x];\n\t\tif(dp[x][y][d][m]) return 0;\n\t\tdp[x][y][d][m] = 1;\n\t\tif(c == '<') d = 2;\n\t\tif(c == '>') d = 0;\n\t\tif(c == '^') d = 3;\n\t\tif(c == 'v') d = 1;\n\t\tif(c == '_') d = (m)?2:0;\n\t\tif(c == '|') d = (m)?3:1;\n\t\tif(c == '@') return 1;\n\t\tif(c == '+') m=(m+1)%16;\n\t\tif(c == '-') m=(m+15)%16;\n\t\tif(c >= '0' && c <= '9') m=c - '0';\n\t\tif(c == '?'){\n\t\t\tfor(d=0;d<4;d++) if(search(x+dx[d],y+dy[d],d,m)) return 1;\n\t\t}\n\t\tx += dx[d];y += dy[d];\n\t}\n}\nmain(){\n\tint w,h,i,j;\n\tchar *p,*q;\n\tcin>>h>>w;\n\tfor(i=1;i<=h;i++) cin>>&map[i][1];\n\tcout << ((search(1, 1, 0, 0))?\"YES\":\"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nchar map[20][20];\nint C,R;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nbool vst[20][20][16][4];\n\nbool dfs(int x,int y,int m,int d) {\n\tif(x==-1) x=C-1;\n\tif(x==C) x=0;\n\tif(y==-1) y=R-1;\n\tif(y==R) y=0;\n\tif(vst[x][y][m][d]) return false;\n\tvst[x][y][m][d]=true;\n\tif(map[x][y]=='<') {\n\t\treturn d=2,dfs(x+dx[d],y,m,d);\n\t}else if(map[x][y]=='>') {\n\t\treturn d=0,dfs(x+dx[d],y,m,d);\n\t}else if(map[x][y]=='^') {\n\t\treturn d=3,dfs(x,y+dy[d],m,d);\n\t}else if(map[x][y]=='v') {\n\t\treturn d=1,dfs(x,y+dy[d],m,d);\n\t}else if(map[x][y]=='_') {\n\t\treturn d=!m?0:2,dfs(x+dx[d],y,m,d);\n\t}else if(map[x][y]=='|') {\n\t\treturn d=!m?1:3,dfs(x,y+dy[d],m,d);\n\t}else if(map[x][y]=='?') {\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(dfs(x+dx[i],y+dy[i],m,i)) return true;\n\t\t}\n\t\treturn false;\n\t}else if(map[x][y]=='.') {\n\t\treturn dfs(x+dx[d],y+dy[d],m,d);\n\t}else if(map[x][y]=='@') {\n\t\treturn true;\n\t}else if('0'<=map[x][y]&&map[x][y]<='9') {\n\t\treturn m=map[x][y]-'0',dfs(x+dx[d],y+dy[d],m,d);\n\t}else if(map[x][y]=='+') {\n\t\treturn m=m<15?m+1:0,dfs(x+dx[d],dy[d],m,d);\n\t}else if(map[x][y]=='-') {\n\t\treturn m=m>0?m-1:15,dfs(x+dx[d],dy[d],m,d);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\",&R,&C);\n\tgetchar();\n\tfor(int j=0;j<R;j++) {\n\t\tfor(int i=0;i<C;i++) {\n\t\t\tmap[i][j]=getchar();\n\t\t}\n\t\tgetchar();\n\t}\n\tprintf(\"%s\\n\",dfs(0,0,0,0)?\"YES\":\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nstruct state{\n    int x;\n    int y;\n    int mem;\n    int dir;\n    state(){}\n    ~state(){}\n    state(int a, int b, int v, int d): x(a), y(b), mem(v), dir(d) {}\n}; \nint main(){\n    string str[20];\n    bool visited[20][20][16];\n    int r, c;\n    cin >> r >> c;\n    for(int i = 0; i < r; i++){\n        cin >> str[i];\n        for(int j = 0; j < c; j++){\n            for(int k = 0; k < 16; k++){\n                visited[i][j][k] = false;\n            }\n        }\n    }\n    queue<state> que;\n    que.push(state(0, 0, 0, 0));\n    bool stop = false;\n    while(!que.empty()){\n        state s = que.front(); que.pop();\n        int x = s.x, y = s.y;\n        if(visited[x][y][s.mem]) continue;\n        visited[x][y][s.mem] = true;\n        if(str[x][y] == '@'){\n            stop = true;\n            break;\n        }\n        if(str[x][y] == '?'){\n            for(int i = 0; i < 4; i++){\n                que.push(state((x+dx[i]+r)%r, (y+dy[i]+c)%c, s.mem, i));\n            }\n        }\n        if(str[x][y] == '<'){\n            s.dir = 2;\n        }\n        if(str[x][y] == '>'){\n            s.dir = 0;\n        }\n        if(str[x][y] == '^'){\n            s.dir = 1;\n        }\n        if(str[x][y] == 'v'){\n            s.dir = 3;\n        }\n        if(str[x][y] == '_'){\n            if(s.mem == 0){\n                s.dir = 0;\n            }else{\n                s.dir = 2;\n            }\n        }\n        if(str[x][y] == '|'){\n            if(s.mem == 0){\n                s.mem = 3;\n            }else{\n                s.mem = 1;\n            }\n        }\n        if('0' <= str[x][y] && str[x][y] <= '9'){\n            s.mem = str[x][y] - '0';\n        }\n        if(str[x][y] == '+'){\n            s.mem = (s.mem+1)%16;\n        }\n        if(str[x][y] == '-'){\n            s.mem = (s.mem+15)%16;\n        }\n        que.push(state((x+dx[s.dir]+r)%r, (y+dy[s.dir]+c)%c, s.mem, s.dir));\n    }\n    if(stop){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint R, C;\nchar mas[20][20];\nint dy[] = { 0, 0, -1, 1}, dx[] = { -1, 1, 0, 0};\nint used[20][20][4][16];\n\nvoid move( int& x, int& y, int pos){\n  x += dx[pos], y += dy[pos];\n  //printf(\"%d %d\\n\", x, y);\n  if(x == -1) x = C - 1;\n  if(x == C) x = 0;\n  if(y == -1) y = R - 1;\n  if(y == R) y = 0;\n  return;\n}\n\nbool dfs(int x, int y, int pos, int memory){\n  move( x, y, pos); //うごく！！！！！\n  if(used[x][y][pos][memory]) return false;\n  used[x][y][pos][memory] = true;\n  if(mas[y][x] == '<') return dfs( x, y, 0, memory);\n  if(mas[y][x] == '>') return dfs( x, y, 1, memory);\n  if(mas[y][x] == '^') return dfs( x, y, 2, memory);\n  if(mas[y][x] == 'v') return dfs( x, y, 3, memory);\n  if(mas[y][x] == '_') {\n    if(memory == 0) return dfs( x, y, 1, memory);\n    else return dfs( x, y, 0, memory);\n  }\n  if(mas[y][x] == '|'){\n    if(memory == 0) return dfs( x, y, 3, memory);\n    else return dfs( x, y, 2, memory);\n  }\n  if(mas[y][x] == '?'){\n    for(int i = 0; i < 4; i++){\n      if(dfs( x, y, i, memory)) return true;\n    }\n    return false;\n  }\n  if(mas[y][x] == '.') return dfs( x, y, pos, memory);\n  if(mas[y][x] == '@') return true;\n  if(mas[y][x] == '0') return dfs( x, y, pos, 0);\n  if(mas[y][x] == '1') return dfs( x, y, pos, 1);\n  if(mas[y][x] == '2') return dfs( x, y, pos, 2);\n  if(mas[y][x] == '3') return dfs( x, y, pos, 3);\n  if(mas[y][x] == '4') return dfs( x, y, pos, 4);\n  if(mas[y][x] == '5') return dfs( x, y, pos, 5);\n  if(mas[y][x] == '6') return dfs( x, y, pos, 6);\n  if(mas[y][x] == '7') return dfs( x, y, pos, 7);\n  if(mas[y][x] == '8') return dfs( x, y, pos, 8);\n  if(mas[y][x] == '9') return dfs( x, y, pos, 9);\n  if(mas[y][x] == '+'){\n    if(memory == 15) return dfs( x, y, pos, 0);\n    else return dfs( x, y, pos, memory + 1);\n  }\n  if(mas[y][x] == '-'){\n    if(memory == 0) return dfs( x, y, pos, 15);\n    else return dfs( x, y, pos, memory - 1);\n  }\n  used[x][y][pos][memory] = false;\n}\n\n\nint main(){\n  cin >> R >> C;\n  for(int i = 0; i < R; i++){\n    for(int j = 0; j < C; j++){\n      cin >> mas[i][j];\n    }\n  }\n  cout << (dfs( -1, 0, 1, 0) ? \"YES\" : \"NO\") << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint R, C;\nchar table[32][32];\nbool visited[16][20][20][4];\n\nstruct State {\n  int m, r, c, d;\n  bool &ref() {\n    return visited[m][r][c][d];\n  }\n  char here() {\n    return table[r][c];\n  }\n\n  State move() {\n    const int dr[] = {0, -1, 0, 1};\n    const int dc[] = {1, 0, -1, 0};\n    State cp = *this;\n    cp.r += dr[d]; cp.r %= R;\n    cp.c += dc[d]; cp.c %= C;\n    return cp;\n  }\n\n};\n\nint main() {\n  while (cin >> R >> C) {\n      memset(visited, 0, sizeof(visited));\n      REP(r, R) {\n          cin >> table[r];\n      }\n\n      queue<State> q;\n      q.push((State){0, 0, 0, 0});\n      visited[0][0][0][0] = true;\n\n      bool stoppable = false;\n      while (!q.empty()) {\n          State cur = q.front(); q.pop();\n\n          switch (cur.here()) {\n          case '<': cur.d = 2; break;\n          case '>': cur.d = 0; break;\n          case '^': cur.d = 1; break;\n          case 'v': cur.d = 3; break;\n          case '_': cur.d = cur.m == 0 ? 0 : 2; break;\n          case '|': cur.d = cur.m == 0 ? 3 : 1; break;\n          case '?': break;\n          case '.': break;\n          case '@': stoppable = true; break;\n          case '+': cur.m = (cur.m + 1) & 15; break;\n          case '-': cur.m = (cur.m + 15) & 15; break;\n          default :\n              cur.m = cur.here() - '0';\n          }\n\n          if (stoppable) break;\n\n          if (cur.here() == '?') {\n              REP(d,4) {\n                  cur.d = d;\n                  State next = cur.move();\n                  if (!next.ref()) {\n                      q.push(next);\n                      next.ref() = true;\n                  }\n              }\n          } else {\n              State next = cur.move();\n              if (!next.ref()) {\n                  q.push(next);\n                  next.ref() = true;\n              }\n          }\n      }\n\n      cout << (stoppable ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint R, C; string s[20]; bool flag, visited[20][20][4][16];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int d, int m) {\n\tif (!visited[y][x][d][m]) {\n\t\tvisited[y][x][d][m] = true;\n\t\tswitch (s[y][x]) {\n\t\tcase '>':\n\t\t\trec((x + 1) % C, y, 0, m); break;\n\t\tcase 'v':\n\t\t\trec(x, (y + 1) % R, 0, m); break;\n\t\tcase '<':\n\t\t\trec((x - 1 + C) % C, y, 0, m); break;\n\t\tcase '^':\n\t\t\trec(x, (y - 1 + R) % R, 0, m); break;\n\t\tcase '_':\n\t\t\tif (m == 0) rec((x + 1) % C, y, 0, m); else rec((x - 1 + C) % C, y, 0, m); break;\n\t\tcase '|':\n\t\t\tif (m == 0) rec(x, (y + 1) % R, 0, m); else rec(x, (y - 1 + R) % R, 0, m); break;\n\t\tcase '?':\n\t\t\tfor (int i = 0; i < 4; i++) rec((x + dx[i] + C) % C, (y + dy[i] + R) % R, i, m); break;\n\t\tcase '.':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, m); break;\n\t\tcase '@':\n\t\t\tflag = true; return;\n\t\tcase '+':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, (m + 1) % 16); break;\n\t\tcase '-':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, (m + 15) % 16); break;\n\t\tdefault:\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, s[y][x] - 48); break;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &R, &C);\n\tfor (int i = 0; i < R; i++) cin >> s[i]; rec(0, 0, 0, 0);\n\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint memo[20][20][4][16];\nchar data[20][20];\nint W,H;\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,-1,1};\n\nchar chg(char c){\n\tstring table = \"<>^v\";\n\treturn table.find(c);\n}\nint dfs(int x,int y,int d,int m){\n\tx = (x+W) % W ;\n\ty = (y+H) % H ;\n\t\n\tif(memo[x][y][d][m]) return 0;\n\telse memo[x][y][d][m] = true;\n\t\n\tchar c = data[y][x];\n\tif(c=='_'){\n\t\td = m ? 0 : 1;\n\t}else if( c == '|'){\n\t\td = m ? 2 : 3;\n\t}else if( c == '?'){\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tif( dfs(x+dx[i],y+dy[i],i,m) ) return 1;\n\t\t}\t\t\n\t\treturn 0;\n\t}else if(c == '.'){\n\t\t\n\t}else if(c == '@'){\n\t\treturn 1;\n\t}else if('0' <= c && c <= '9'){\n\t\tm = c - '0';\n\t}else if(c == '+'){\n\t\tm = (m+1) % 16;\n\t}else if(c == '-'){\n\t\tm = (m+15) % 16;\n\t}else{\n\t\td = chg(c);\n\t}\n\treturn dfs(x+dx[d],y+dy[d],d,m);\n}\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0 ; i < H; i++)\n\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\tcin >> data[i][j];\n\tcout << (dfs(0,0,1,0)?\"YES\":\"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include <iterator>\n#include<queue>\n#include <functional>\n#include <string>\n#include <numeric>\n#include<stack>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) v.begin(),v.end()\nusing namespace std;\nconst int dx[4] = { -1, 1, 0, 0 };\nconst int dy[4] = { 0, 0, -1, 1 };\nstruct aaa{\n\tint x;\n\tint y;\n\tint d;\n\tint m;\n};\n\nstruct data\n{\n\tbool memo[20][20][16][4];\n\tdata(){\n\t\tREP(i, 20)\n\t\t\tREP(j, 20)\n\t\t\tREP(k, 16)\n\t\t\tREP(l, 4)\n\t\t\tmemo[i][j][k][l] = false;\n\t}\n};\nstack<aaa> az;\nbool memo[20][20][16][4] = {};\nvector<string> Fi;\nint R=0, C=0;\nbool a(int ax, int ay,int Memory, int Muki){\n\taz.push({ ax, ay, Memory, Muki });\n\twhile (1){\n\t\tint ax = (az.top().x + C) % C, ay = (az.top().y + R) % R, Memory = az.top().d, Muki = az.top().m;\n\t\taz.pop();\n\t\tif (memo[ax][ay][Memory][Muki])return false;\n\t\tmemo[ax][ay][Memory][Muki] = true;\n\t\tswitch (Fi[ay][ax]){\n\t\tcase '<':Muki = 0; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '>':Muki = 1; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '^':Muki = 2;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase 'v':Muki = 3; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '_':Muki = Memory ? 0 : 1;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '|':Muki = Memory ? 2 : 3;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '?':REP(i, 4){\n\t\t\taz.push({ ax + dx[i], ay + dy[i], Memory, i });\n\t\t}\n\t\t\t\t break;\n\t\tcase '.': ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '@':return true;\n\t\tcase '+':Memory = (Memory + 1) % 16; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '-':Memory = (Memory + 15) % 16; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tdefault:Memory = Fi[ay][ax] - 48; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> R >> C;\n\tFi.resize(20);\n\tREP(i, R){\n\t\tstring st;\n\t\tcin >> Fi[i];\n\t}\n\tdata adata;\n\tif (a(0, 0, 0, 1)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse{\n\t\tcout << \"NO\" << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\nint r, c;\nchar a[21][21];\nbool vis[21][21][17][5];\n\nint xdir[4] = {1, 0, -1, 0}, ydir[4] = {0, 1, 0, -1};\nbool dfs(int x, int y, int m, int d)\n{\n  vis[y][x][m][d] = false;\n  char ch = a[y][x];\n  int nm = m, nd = d; \n\n  if(ch == '@') return true;\n  else if(ch == '<') nd = 2;\n  else if(ch == '>') nd = 0;\n  else if(ch == '^') nd = 3;\n  else if(ch == 'v') nd = 1;\n  else if(ch == '|') nd = (nm == 0)? 1 : 3;\n  else if(ch == '_') nd = (nm == 0)? 0 : 2;\n  else if(ch == '+') nm = (nm+1)%15;\n  else if(ch == '-') nm = (nm-1+16)%16;\n  else if(isdigit(ch)) nm = (int)(ch-'0');\n  \n  if(ch == '?'){\n    for(int i = 0; i < 4; i++){\n      int dx = x+xdir[i], dy = y+ydir[i];\n      if(dx < 0) dx = c-1;\n      if(dx >= c) dx = 0;\n      if(dy < 0) dy = r-1;\n      if(dy >= r) dy = 0;\n\n      if(vis[dy][dx][nm][nd] && dfs(dx, dy, nm, nd)) return true;\n    }\n  } else {\n    int dx = x+xdir[nd], dy = y+ydir[nd];\n    if(dx < 0) dx = c-1;\n    if(dx >= c) dx = 0;\n    if(dy < 0) dy = r-1;\n    if(dy >= r) dy = 0;\n    \n    if(vis[dy][dx][nm][nd] && dfs(dx, dy, nm, nd)) return true;\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>r>>c && (r+c)){\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++) cin >> a[i][j];\n\n    fill(&vis[0][0][0][0], &vis[20][20][16][4], true);\n\n    cout << ((dfs(0, 0, 0, 0))? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar map[23][23], dp[20][20][4][16];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\n\nint search(int x,int y, int d, int m){\n\twhile(1){\n\t\tx=(x+w)%w;y=(y+h)%h;\n\t\tprintf(\"%d %d %d %d\\n\", x,y,d,m);\n\t\tchar c = map[y][x];\n\t\tif(dp[x][y][d][m]) return 0;\n\t\tdp[x][y][d][m] = 1;\n\t\tif(c == '<') d = 2;\n\t\tif(c == '>') d = 0;\n\t\tif(c == '^') d = 3;\n\t\tif(c == 'v') d = 1;\n\t\tif(c == '_') d = (m)?2:0;\n\t\tif(c == '|') d = (m)?3:1;\n\t\tif(c == '@') return 1;\n\t\tif(c == '+') m=(m+1)%16;\n\t\tif(c == '-') m=(m+15)%16;\n\t\tif(c >= '0' && c <= '9') m=c-'0';\n\t\tif(c == '?'){\n\t\t\tfor(d=0;d<4;d++) if(search(x+dx[d],y+dy[d],d,m)) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tx += dx[d];y += dy[d];\n\t}\n}\nmain(){\n\tint i,j;\n\tchar *p,*q;\n\tcin>>h>>w;\n\tfor(i=0;i<h;i++) cin>>map[i];\n\tcout << ((search(0, 0, 0, 0))?\"YES\":\"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nState state(0, 0, 0, 0);\n\nvoid analyzer(char symbol) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col]);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (0 <= nx && nx < C && 0 <= ny && ny < R) {\n                dfs(ny, nx);\n            }\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        dfs(ny, nx);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  visited[s.x][s.y][s.d][s.m] = true;\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  while(cin>>R>>C) {\n    cin.ignore();\n    makeMapFromInput(code,R,C);\n    //DbgMap(code,R,C);\n    cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_R = 20;\nconst int MAX_C = 20;\nconst int MAX_M = 16;\n\nconst int dxs[] = {1, 0, -1, 0};\nconst int dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\nstruct Stat {\n  int x, y, d, m;\n  Stat() {}\n  Stat(int _x, int _y, int _d, int _m): x(_x), y(_y), d(_d), m(_m) {}\n};\n\n/* global variables */\n\nstring prgs[MAX_R];\nbool used[MAX_R][MAX_C][4][MAX_M];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int r, c;\n  cin >> r >> c;\n\n  memset(used, false, sizeof(used));\n\n  for (int y = 0; y < r; y++) cin >> prgs[y];\n\n  queue<Stat> q;\n  q.push(Stat(0, 0, 0, 0));\n  used[0][0][0][0] = true;\n\n  bool ok = false;\n  \n  while (! q.empty()) {\n    Stat u = q.front(); q.pop();\n    char op = prgs[u.y][u.x];\n\n    if (op == '@') {\n      ok = true;\n      break;\n    }\n\n    if (op == '?') {\n      for (int di = 0; di < 4; di++) {\n\tint vx = (u.x + dxs[di]) % c;\n\tint vy = (u.y + dys[di]) % r;\n\tif (! used[vy][vx][di][u.m]) {\n\t  used[vy][vx][di][u.m] = true;\n\t  q.push(Stat(vx, vy, di, u.m));\n\t}\n      }\n    }\n    else {\n      switch (op) {\n      case '<': u.d = 2; break;\n      case '>': u.d = 0; break;\n      case '^': u.d = 1; break;\n      case 'v': u.d = 3; break;\n      case '_': u.d = (u.m == 0) ? 0 : 2; break;\n      case '|': u.d = (u.m == 0) ? 3 : 1; break;\n      case '.': break;\n      case '+': u.m = (u.m + 1) % MAX_M; break;\n      case '-': u.m = (u.m + MAX_M - 1) % MAX_M; break;\n      default: u.m = op - '0';\n      }\n\n      u.x = (u.x + dxs[u.d]) % c;\n      u.y = (u.y + dys[u.d]) % r;\n      if (! used[u.y][u.x][u.d][u.m]) {\n\tused[u.y][u.x][u.d][u.m] = true;\n\tq.push(u);\n      }\n    }\n  }\n\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint R,C,v[22][22][19][5],dy[]={0,0,-1,1},dx[]={-1,1,0,0},a;\nchar c[22][22];\n\nvoid f(int y,int x,int m,int d){\n\tif(v[y][x][m][d])return;\n\tv[y][x][m][d]=1;\n\tif(c[y][x]=='<')d=0;\n\tif(c[y][x]=='>')d=1;\n\tif(c[y][x]=='^')d=2;\n\tif(c[y][x]=='v')d=3;\n\tif(c[y][x]=='_')d=!m;\n\tif(c[y][x]=='|')d=!m+2;\n\tif(isdigit(c[y][x]))m=c[y][x]-'0';\n\tif(c[y][x]=='+')m=(m+1)%16;\n\tif(c[y][x]=='-')m=(m+15)%16;\n\tif(c[y][x]=='@')a=1;\n\tf((y+dy[d]+R)%R,(x+dx[d]+C)%C,m,d);\n\tif(c[y][x]=='?')rep(i,4)f((y+dy[i]+R)%R,(x+dx[i]+C)%C,m,i);\n}\n\nint main(){\n\tcin>>R>>C;\n\trep(i,R)cin>>c[i];\n\tf(0,0,0,1);\n\tcout<<(a?\"YES\":\"NO\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  int dx[4] = { 1, -1,  0,  0 };\n  int dy[4] = { 0,  0,  1, -1 };\n\n  long long int r, c;\n  cin >> r >> c;\n\n  vector< string > p;\n\n  for ( long long int i = 0; i < r; i++ ) {\n\n    string in;\n    cin >> in;\n    p.push_back( in );\n\n  }\n\n  queue< long long int > qx, qy, qm, qd;\n  qx.push(0);\n  qy.push(0);\n  qm.push(0);\n  qd.push(0);\n\n  bool ans = false;\n\n  bool f[21][21][16][4] = {};\n\n  while( qx.size() > 0 ) {\n\n    long long int x, y, m, d;\n    x = qx.front();\n    qx.pop();\n    y = qy.front();\n    qy.pop();\n    m = qm.front();\n    qm.pop();\n    d = qd.front();\n    qd.pop();\n\n    for (;;) {\n\n      if ( x == -1 ) x = c - 1;\n      if ( x == c ) x = 0;\n      if ( y == -1 ) y = r - 1;\n      if ( y == r ) y = 0;\n\n      if ( p[y][x] == '>' ) {\n\td = 0;\n      }else if ( p[y][x] == '<' ) {\n\td = 1;\n      }else if ( p[y][x] == 'v' ) {\n\td = 2;\n      }else if ( p[y][x] == '^' ) {\n\td = 3;\n      }else if ( p[y][x] == '_' ) {\n\tif ( m == 0 ) {\n\t  d = 0;\n\t}else {\n\t  d = 1;\n\t}\n      }else if ( p[y][x] == '|' ) {\n\tif ( m == 0 ) {\n\t  d = 2;\n\t}else {\n\t  d = 3;\n\t}\n      }else if ( p[y][x] == '@' ) {\n\tans = true;\n\tbreak;\n      }else if ( p[y][x] == '+' ) {\n\tm++;\n\tif ( m == 16 ) m = 0;\n      }else if ( p[y][x] == '-' ) {\n\tm--;\n\tif ( m == -1 ) m = 15;\n      }else if ( p[y][x] == '.' ) {\n      }else if ( p[y][x] == '?' ) {\n\td = 0;\n\tqx.push(x-1);\n\tqy.push(y);\n\tqm.push(m);\n\tqd.push(1);\n\tqx.push(x);\n\tqy.push(y+1);\n\tqm.push(m);\n\tqd.push(2);\n\tqx.push(x);\n\tqy.push(y-1);\n\tqm.push(m);\n\tqd.push(3);\n      }else {\n\tm = p[y][x] - '0';\n      }\n\n      if ( f[y][x][m][d] == true ) {\n\tbreak;\n      }\n      f[y][x][m][d] = true;\n      x += dx[d];\n      y += dy[d];\n\n    }\n\n    if ( ans == true ) break;\n\n  }\n\n  if ( ans == true ) {\n    cout << \"YES\" << endl;\n  }else {\n    cout << \"NO\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef vector<xy_t> polygon;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef pair<string, int> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nchar field[30][30];\nbool memo[30][30][20][4];\n\nint n, m;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid doit(int x, int y, int& num, int& d, queue<PPP> &que){\n\tchar c = field[y][x];\n\tif(c == '<'){\n\t\td = 2;\n\t}else if(c == '>'){\n\t\td = 0;\n\t}else if(c == '^') {\n\t\td = 3;\n\t}else if(c == 'v'){\n\t\td = 1;\n\t}else if(c == '_'){\n\t\tif(num == 0) d = 0;\n\t\telse d = 2;\n\t}else if(c == '|'){\n\t\tif(num == 0) d = 1;\n\t\telse d = 3;\n\t}else if(c == '?'){\n\t\tint x2, y2;\n\t\tfor(int d2 = 0; d2 < 4; d2++){\n\t\t\tx2 = (x + dx[d2] + m) % m;\n\t\t\ty2 = (y + dy[d2] + n) % n;\n\t\t\tif(!memo[x2][y2][num][d2]){\n\t\t\t\tmemo[x2][y2][num][d2] = true;\n\t\t\t\tque.push(PPP(d2, PP(num, P(x2, y2))));\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}else if(isdigit(c)){\n\t\tnum = c - '0';\n\t}else if(c == '+'){\n\t\tnum = (num + 1) % 16;\n\t}else if(c == '-'){\n\t\tnum = (num + 15) % 16;\n\t}\n\tx = (x + dx[d] + m) % m;\n\ty = (y + dy[d] + n) % n;\n\tif(!memo[x][y][num][d]){\n\t\tmemo[x][y][num][d] = true;\n\t\tque.push(PPP(d, PP(num, P(x, y))));\n\t}\n}\n\nint main(){\n\tint x, y, d, num;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\tx = 0, y = 0, d = 0, num = 0;\n\tmemset(memo, false, sizeof(memo));\n\tmemo[0][0][0][0] = true;\n\tqueue<PPP> que;\n\tque.push(PPP(d, PP(num, P(x, y))));\n\twhile(!que.empty()){\n\t\tPPP ppp = que.front();\n\t\tque.pop();\n\t\td = ppp.first;\n\t\tnum = ppp.second.first;\n\t\tx = ppp.second.second.first;\n\t\ty = ppp.second.second.second;\n\t\tif(field[y][x] == '@'){\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tdoit(x, y, num, d, que);\n\t}\n\tcout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  queue<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.front(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n    int ty,tx;\n\n    if(grid[y][x] == '.'){\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '>'){\n      d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == 'v'){\n      d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '<'){\n      d = 2;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '^'){\n      d = 3;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '?'){\n      for(int i=0;i<4;i++){\n\tty = (y+dy[i])%r; tx = (x+dx[i])%c;\n\tif(v[ty][tx][i][m])continue;\n\tv[ty][tx][i][m] = true;\n\tq.push(P2(P(ty,tx),P(i,m)));\n      }\n    }\n    else if(grid[y][x] == '_'){\n      if(m)d = 2;\n      else d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '|'){\n      if(m)d = 3;\n      else d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '+'){\n      m = (m+1)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '-'){\n      m = (m+15)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }else if(grid[y][x] == '@'){\n      f = true;\n      break;\n    }\n    else{\n      m = grid[y][x] - '0';\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint R, C;\nchar mas[20][20];\nint dy[] = { 0, 0, -1, 1}, dx[] = { -1, 1, 0, 0};\nint used[20][20][4][16];\n\nvoid move( int& x, int& y, int pos){\n  x += dx[pos], y += dy[pos];\n  if(x == -1) x = C - 1;\n  if(x == C) x = 0;\n  if(y == -1) y = R - 1;\n  if(y == R) y = 0;\n  return;\n}\n\nbool dfs(int x, int y, int pos, int memory){\n  move( x, y, pos); //うごく！！！！！\n  if(used[x][y][pos][memory]) return false;\n  used[x][y][pos][memory] = true;\n  if(mas[y][x] == '<') return dfs( x, y, 0, memory);\n  if(mas[y][x] == '>') return dfs( x, y, 1, memory);\n  if(mas[y][x] == '^') return dfs( x, y, 2, memory);\n  if(mas[y][x] == 'v') return dfs( x, y, 3, memory);\n  if(mas[y][x] == '_') {\n    if(memory == 0) return dfs( x, y, 1, memory);\n    else return dfs( x, y, 0, memory);\n  }\n  if(mas[y][x] == '|'){\n    if(memory == 0) return dfs( x, y, 3, memory);\n    else return dfs( x, y, 2, memory);\n  }\n  if(mas[y][x] == '?'){\n    for(int i = 0; i < 4; i++){\n      if(dfs( x, y, i, memory)) return true;\n    }\n    return false;\n  }\n  if(mas[y][x] == ' ') return dfs( x, y, pos, memory);\n  if(mas[y][x] == '@') return true;\n  if(mas[y][x] == '0') return dfs( x, y, pos, 0);\n  if(mas[y][x] == '1') return dfs( x, y, pos, 1);\n  if(mas[y][x] == '2') return dfs( x, y, pos, 2);\n  if(mas[y][x] == '3') return dfs( x, y, pos, 3);\n  if(mas[y][x] == '4') return dfs( x, y, pos, 4);\n  if(mas[y][x] == '5') return dfs( x, y, pos, 5);\n  if(mas[y][x] == '6') return dfs( x, y, pos, 6);\n  if(mas[y][x] == '7') return dfs( x, y, pos, 7);\n  if(mas[y][x] == '8') return dfs( x, y, pos, 8);\n  if(mas[y][x] == '9') return dfs( x, y, pos, 9);\n  if(mas[y][x] == '+'){\n    if(memory == 15) return dfs( x, y, pos, 0);\n    else return dfs( x, y, pos, memory + 1);\n  }\n  if(mas[y][x] == '-'){\n    if(memory == 0) return dfs( x, y, pos, 15);\n    else return dfs( x, y, pos, memory - 1);\n  }\n  used[x][y][pos][memory] = false;\n}\n\n\nint main(){\n  cin >> R >> C;\n  for(int i = 0; i < R; i++){\n    for(int j = 0; j < C; j++){\n      cin >> mas[i][j];\n    }\n  }\n  cout << (dfs( -1, 0, 1, 0) ? \"YES\" : \"NO\") << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDirBits;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=(1<<_dir);\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int mem=0;mem<=15;mem++){\n    for(int dir=0;dir<4;dir++){\n      if(visited[gx][gy][mem][dir]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n\n    que.push(State(1,0,0,0));\n\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM next_dir_mem = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(next_dir_mem.mDirBits & (1<<dir))) continue;\n\tint dx = (tx[dir] + x + W) % W;\n\tint dy = (ty[dir] + y + H) % H;\n\n\tif(visited[dx][dy][next_dir_mem.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,next_dir_mem.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][next_dir_mem.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define N 20\n#define M 16\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nstring s[N];\nint r,c;\n\nbool bfs(){\n  bool d[N][N][4][M];\n  queue<P1> q;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  memset(d,0,sizeof(d));\n  d[0][0][1][0]=true;\n  q.push(P1(P(0,0),P(1,0)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int y=t.f.f,x=t.f.s;\n    int dir=t.s.f,mem=t.s.s;\n    int ndir=dir,nmem=mem;\n    if(s[y][x]=='@')return true;\n    if(s[y][x]=='<')ndir=3;\n    if(s[y][x]=='>')ndir=1;\n    if(s[y][x]=='^')ndir=0;\n    if(s[y][x]=='v')ndir=2;\n    if(s[y][x]=='_'){\n      if(!mem)ndir=1;\n      else ndir=3;\n    }\n    if(s[y][x]=='|'){\n      if(!mem)ndir=2;\n      else ndir=0;\n    }\n    if('0'<=s[y][x]&&s[y][x]<='9')\n      nmem=s[y][x]-'0';\n    if(s[y][x]=='+')\n      nmem=(mem+1)%16;\n    if(s[y][x]=='-')\n      nmem=(mem+15)%16;\n    if(s[y][x]=='?'){\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(ny<0||nx<0||N<=ny||N<=nx){\n\t  if(ny<0)ny=19;\n\t  if(nx<0)nx=19;\n\t  if(N<=ny)ny=0;\n\t  if(N<=nx)nx=0;\n\t}\n\tif(d[ny][nx][ndir][nmem])continue;\n\td[ny][nx][ndir][nmem]=true;\n\tq.push(P1(P(ny,nx),P(ndir,nmem)));\n      }\n    }else{\n      int ny=y+dy[ndir];\n      int nx=x+dx[ndir];\n      if(ny<0||nx<0||N<=ny||N<=nx){\n\tif(ny<0)ny=19;\n\tif(nx<0)nx=19;\n\tif(N<=ny)ny=0;\n\tif(N<=nx)nx=0;\n      }\n      if(d[ny][nx][ndir][nmem])continue;\n      d[ny][nx][ndir][nmem]=true;\n      q.push(P1(P(ny,nx),P(ndir,nmem)));\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++)cin>>s[i];\n  if(bfs())cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct P{\n  int d;\n  int x, y;\n  int mem;\n  P(int x,int y,int d,int mem):x(x),y(y),d(d),mem(mem) {}\n};\nbool operator<(const P &a, const P &b) {\n  return (a.x!=b.x)? a.x<b.x : a.y!=b.y? a.y<b.y : a.d!=b.d ? a.d < b.d : a.mem < b.mem;\n}\n\nint main() {\n  int H,W;\n  cin >> H >> W;\n  char ba[W][H];\n  REP(y,H) {\n    REP(x,W)\n      cin >> ba[x][y];\n  }\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  queue<P> Q;\n  Q.push(P(-1,0,1,0));\n  set<P> se;\n  bool goal = 0;\n  while(!Q.empty()) {\n    P now = Q.front();\n    Q.pop();\n    if (se.count(now)) continue;\n    se.insert(now);\n\n//    printf(\"%d, %d d = %d mem = %d\\n\", now.x, now.y,now.d, now.mem);\n    \n    int xx = now.x + dx[now.d];\n    int yy = now.y + dy[now.d];\n    if (xx<0) xx = W-1;\n    else if (xx>=W) xx = 0;\n    if (yy<0) yy = H-1;\n    else if (yy>=H) yy = 0;\n    char c = ba[xx][yy];\n    //  cout << c << endl;\n    int d = now.d;\n    int mem = now.mem;\n    if (c == '<') {\n      d = 3;\n    } else if (c == '>') {\n      d = 1;\n    } else if (c == '^') {\n      d = 0;\n    } else if (c == 'v') {\n      d = 2;\n    } else if (c == '_') {\n      if (mem == 0) d = 1;\n      else d = 3;\n    } else if (c == '|') {\n      if (mem == 0) d = 2;\n      else d = 0;  \n    } else if (c == '?') {\n    } else if (c == '.') {\n    } else if (c == '@') {\n      goal = 1;\n      break;\n    } else if (isdigit(c)) {\n      mem = c-'0';\n    } else if (c == '+') {\n      if (mem == 15) mem = 0;\n      else mem++;\n      \n    } else if (c == '-') {\n      if (mem == 0) mem = 15;\n      else mem--;\n    }\n    if (c == '?') {\n      Q.push(P(xx,yy,0,mem));\n      Q.push(P(xx,yy,1,mem));\n      Q.push(P(xx,yy,2,mem));\n      Q.push(P(xx,yy,3,mem));      \n    } else {\n      Q.push(P(xx,yy,d,mem));\n    }\n  }\n  if (goal) {\n    cout << \"YES\" << endl;\n  } else\n    cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define N 20\n#define M 16\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nstring s[N];\nint r,c;\n\nbool bfs(){\n  bool d[N][N][4][M];\n  queue<P1> q;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  memset(d,0,sizeof(d));\n  d[0][0][1][0]=true;\n  q.push(P1(P(0,0),P(1,0)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int y=t.f.f,x=t.f.s;\n    int dir=t.s.f,mem=t.s.s;\n    int ndir=dir,nmem=mem;\n    if(s[y][x]=='@')return true;\n    if(s[y][x]=='<')ndir=3;\n    if(s[y][x]=='>')ndir=1;\n    if(s[y][x]=='^')ndir=0;\n    if(s[y][x]=='v')ndir=2;\n    if(s[y][x]=='_'){\n      if(!mem)ndir=1;\n      else ndir=3;\n    }\n    if(s[y][x]=='|'){\n      if(!mem)ndir=2;\n      else ndir=0;\n    }\n    if('0'<=s[y][x]&&s[y][x]<='9')\n      nmem=s[y][x]-'0';\n    if(s[y][x]=='+')\n      nmem=(mem+1)%16;\n    if(s[y][x]=='-')\n      nmem=(mem+15)%16;\n    if(s[y][x]=='?'){\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(ny<0||nx<0||N<=ny||N<=nx){\n\t  if(ny<0)ny=15;\n\t  if(nx<0)nx=15;\n\t  if(N<=ny)ny=0;\n\t  if(N<=nx)nx=0;\n\t}\n\tif(d[ny][nx][ndir][nmem])continue;\n\td[ny][nx][ndir][nmem]=true;\n\tq.push(P1(P(ny,nx),P(ndir,nmem)));\n      }\n    }else{\n      int ny=y+dy[ndir];\n      int nx=x+dx[ndir];\n      if(ny<0||nx<0||N<=ny||N<=nx){\n\tif(ny<0)ny=15;\n\tif(nx<0)nx=15;\n\tif(N<=ny)ny=0;\n\tif(N<=nx)nx=0;\n      }\n      if(d[ny][nx][ndir][nmem])continue;\n      d[ny][nx][ndir][nmem]=true;\n      q.push(P1(P(ny,nx),P(ndir,nmem)));\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++)cin>>s[i];\n  if(bfs())cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nstruct Task {\n\tint x, y, mem, dir;\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\nbool passed[20][20][16][4] = { { { { false } } } };\n\nint main(){\n\tint R, C;\n\tcin >> R >> C;\n\tvector<string> program(R);\n\tfor(int i = 0; i < R; ++i){ cin >> program[i]; }\n\tint x = 0, y = 0, mem = 0, dir = 0;\n\tbool answer = false;\n\tvector<Task> tasks;\n\tTask initial = { 0, 0, 0, 0 };\n\ttasks.push_back(initial);\n\twhile(!answer && !tasks.empty()){\n\t\tTask &task = tasks.back();\n\t\tpassed[task.y][task.x][task.mem][task.dir] = true;\n\t\tif(program[task.y][task.x] == '?'){\n\t\t\tTask t = task;\n\t\t\ttasks.pop_back();\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tTask next = t;\n\t\t\t\tnext.dir = i;\n\t\t\t\tnext.x = (next.x + C + dx[next.dir]) % C;\n\t\t\t\tnext.y = (next.y + R + dy[next.dir]) % R;\n\t\t\t\tif(!passed[next.y][next.x][next.mem][next.dir]){\n\t\t\t\t\ttasks.push_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(isdigit(program[task.y][task.x])){\n\t\t\t\ttask.mem = program[task.y][task.x] - '0';\n\t\t\t}else{\n\t\t\t\tswitch(program[task.y][task.x]){\n\t\t\t\tcase '<': task.dir = 2; break;\n\t\t\t\tcase '>': task.dir = 0; break;\n\t\t\t\tcase '^': task.dir = 1; break;\n\t\t\t\tcase 'v': task.dir = 3; break;\n\t\t\t\tcase '_': task.dir = (task.mem == 0 ? 0 : 2); break;\n\t\t\t\tcase '|': task.dir = (task.mem == 0 ? 3 : 1); break;\n\t\t\t\tcase '+': task.mem = (task.mem + 1) % 0x0f; break;\n\t\t\t\tcase '-': task.mem = (task.mem - 1) & 0x0f; break;\n\t\t\t\tcase '@': answer = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttask.x = (task.x + C + dx[task.dir]) % C;\n\t\t\ttask.y = (task.y + R + dy[task.dir]) % R;\n\t\t\tif(passed[task.y][task.x][task.mem][task.dir]){ tasks.pop_back(); }\n\t\t}\n\t}\n\tcout << (answer ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef struct{\n  int MEM,MUKI;\n  int used[22][22];\n  int x,y;\n}P;\nchar mas[22][22];\nint R,C,dx[]={0,-1,0,1},dy[]={1,0,-1,0}; //右上左下\nint flg;\nvoid dfs(P p);\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++){\n    for(int j=0;j<C;j++){\n      cin >> mas[i][j];\n    }\n  }\n  flg=0;\n  P p;\n  p.MEM=0;   p.x=0;\n  p.MUKI=0;  p.y=-1;\n  memset(p.used,0,sizeof(p.used));\n  dfs(p);\n  cout << (flg>0?\"NO\":\"YES\") << endl;\n}\nvoid dfs(P p){\n  queue<P> que;\n  que.push(p);\n    P HM = que.front();\n  while(!que.empty()){\n\n    HM.x+=dx[HM.MUKI];\n    HM.y+=dy[HM.MUKI];\n    if(HM.x<0)HM.x=R-1;\n    else if(HM.x>=R)HM.x=0;\n    else if(HM.y<0)HM.y=C-1;\n    else if(HM.y>=C)HM.y=0;\n    if(HM.used[HM.x][HM.y]==4){\n      flg++;\n      que.pop();\n      if(que.empty())return;\n      else{\n\tHM=que.front();\n\tque.pop();\n      }\n    } else{\n      HM.used[HM.x][HM.y]++;\n      if(mas[HM.x][HM.y]=='?'){\n\tfor(int i=0;i<4;i++){\n\t  P HMHM=HM;\n\t  HMHM.MUKI=i;\n\t  que.push(HMHM);\n\t}\n      }else if(mas[HM.x][HM.y]=='@'){\n\tflg = -1000;\n\treturn;\n      }else if(mas[HM.x][HM.y]=='_'){\n\tHM.MEM == 0 ? HM.MUKI=0 : HM.MUKI=2;\n      }else if(mas[HM.x][HM.y]=='|'){\n\tHM.MEM == 0 ? HM.MUKI=3 : HM.MUKI=1;\n      }else if(mas[HM.x][HM.y]=='+'){\n\tHM.MEM == 15 ? HM.MEM=0 : HM.MEM++;\n      }else if(mas[HM.x][HM.y]=='-'){\n\tHM.MEM == 0 ? HM.MEM=15 : HM.MEM--;\n      }else if(mas[HM.x][HM.y]>='0'&&mas[HM.x][HM.y]<='9'){\n\tHM.MEM = mas[HM.x][HM.y]-'0';\n      }else if(mas[HM.x][HM.y]=='.'){\n\n      }else if(mas[HM.x][HM.y]=='<'){\n\tHM.MUKI= 2;\n      }else if(mas[HM.x][HM.y]=='^'){\n\tHM.MUKI= 1;\n      }else if(mas[HM.x][HM.y]=='>'){\n\tHM.MUKI= 0;\n      }else if(mas[HM.x][HM.y]=='v'){\n\tHM.MUKI= 3;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  int cnt=0;\n  while(!Q.empty()) {\n    if(cnt=>21*21*4*15) break;\n    cnt++;\n\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  //DbgPrint(21*21*4*16);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum DIR{\n\tUp,\n\tDown,\n\tLeft,\n\tRight,\n};\n\nstruct Info{\n\tInfo(){\n\t\trow = col = value = 0;\n\t\tdir = Right;\n\t}\n\tInfo(int arg_row,int arg_col,int arg_value,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tvalue = arg_value;\n\t\tdir = arg_dir;\n\t}\n\tint row,col,value;\n\tDIR dir;\n};\n\nint main(){\n\n\tint H,W;\n\tscanf(\"%d %d\",&H,&W);\n\n\tchar table[H][W+1];\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t}\n\n\tbool check[H][W][16][4];\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < 16; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++)check[a][b][c][d] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo first;\n\tcheck[0][0][0][Right] = true;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint next_row,next_col,next_value;\n\n\twhile(!Q.empty()){\n\n\t\tif(table[Q.front().row][Q.front().col] == '@'){\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn 0;\n\t\t}else{\n\n\t\t\tswitch(table[Q.front().row][Q.front().col]){\n\t\t\tcase '<':\n\t\t\t\tnext_row = Q.front().row;\n\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\tnext_col = W-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t}\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Left] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Left] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Left));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tnext_row = Q.front().row;\n\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\tnext_col = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t}\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Right] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Right] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Right));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\tnext_row = H-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t}\n\t\t\t\tnext_col = Q.front().col;\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Up] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Up] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Up));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\tnext_row = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t}\n\t\t\t\tnext_col = Q.front().col;\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Down] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Down] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Down));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\tif(Q.front().value == 0){\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\t\tnext_col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Right] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Right] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Right));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\t\tnext_col = W-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Left] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Left] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Left));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '|':\n\t\t\t\tif(Q.front().value == 0){\n\t\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\t\tnext_row = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Down] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Down] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Down));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\t\tnext_row = H-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Up] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Up] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Up));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tnext_row = Q.front().row;\n\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\tnext_col = W-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t}\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Left] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Left] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Left));\n\t\t\t\t}\n\n\t\t\t\tnext_row = Q.front().row;\n\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\tnext_col = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t}\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Right] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Right] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Right));\n\t\t\t\t}\n\n\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\tnext_row = H-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t}\n\t\t\t\tnext_col = Q.front().col;\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Up] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Up] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Up));\n\t\t\t\t}\n\n\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\tnext_row = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t}\n\t\t\t\tnext_col = Q.front().col;\n\t\t\t\tif(check[next_row][next_col][Q.front().value][Down] == false){\n\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Down] = true;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Down));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase Up:\n\t\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\t\tnext_row = H-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Up] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Up] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Up));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Down:\n\t\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\t\tnext_row = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Down] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Down] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Down));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Left:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\t\tnext_col = W-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Left] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Left] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Left));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Right:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\t\tnext_col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][Q.front().value][Right] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][Q.front().value][Right] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().value,Right));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tif(Q.front().value == 15){\n\t\t\t\t\tnext_value = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnext_value = Q.front().value+1;\n\t\t\t\t}\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase Up:\n\t\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\t\tnext_row = H-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][next_value][Up] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Up] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Up));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Down:\n\t\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\t\tnext_row = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][next_value][Down] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Down] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Down));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Left:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\t\tnext_col = W-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][next_value][Left] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Left] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Left));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Right:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\t\tnext_col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][next_value][Right] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Right] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Right));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(Q.front().value == 0){\n\t\t\t\t\tnext_value = 15;\n\t\t\t\t}else{\n\t\t\t\t\tnext_value = Q.front().value-1;\n\t\t\t\t}\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase Up:\n\t\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\t\tnext_row = H-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][next_value][Up] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Up] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Up));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Down:\n\t\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\t\tnext_row = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][next_value][Down] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Down] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Down));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Left:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\t\tnext_col = W-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][next_value][Left] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Left] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Left));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Right:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\t\tnext_col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][next_value][Right] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Right] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Right));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: //'0'-'9'\n\t\t\t\tnext_value = table[Q.front().row][Q.front().col]-'0';\n\t\t\t\tswitch(Q.front().dir){\n\t\t\t\tcase Up:\n\t\t\t\t\tif(Q.front().row == 0){\n\t\t\t\t\t\tnext_row = H-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row-1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][next_value][Up] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Up] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Up));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Down:\n\t\t\t\t\tif(Q.front().row == H-1){\n\t\t\t\t\t\tnext_row = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_row = Q.front().row+1;\n\t\t\t\t\t}\n\t\t\t\t\tnext_col = Q.front().col;\n\t\t\t\t\tif(check[next_row][next_col][next_value][Down] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Down] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Down));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Left:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == 0){\n\t\t\t\t\t\tnext_col = W-1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col-1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][next_value][Left] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Left] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Left));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Right:\n\t\t\t\t\tnext_row = Q.front().row;\n\t\t\t\t\tif(Q.front().col == W-1){\n\t\t\t\t\t\tnext_col = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnext_col = Q.front().col+1;\n\t\t\t\t\t}\n\t\t\t\t\tif(check[next_row][next_col][next_value][Right] == false){\n\t\t\t\t\t\tcheck[next_row][next_col][next_value][Right] = true;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,next_value,Right));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tprintf(\"NO\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint R, C;\nvector< vector<char> > f;\nvector< vector< vector<int> > > visited;\n\nbool solve(int y, int x, int dir, int mem){\n  //cout << x << \" \" << y << endl;\n  if(find(visited[y][x].begin(), visited[y][x].end(), mem) != visited[y][x].end()) return false;\n  visited[y][x].push_back(mem);\n  //if(visited[y][x] == mem) return false;\n  //visited[y][x] = mem;\n  if(f[y][x] == '@') return true;\n  bool res = false;\n  if(f[y][x] == '<'){\n    res |= solve(y, (x-1 + C) % C, 2, mem);\n  }else if(f[y][x] == '>'){\n    res |= solve(y, (x+1 + C) % C, 0, mem);\n  }else if(f[y][x] == '^'){\n    res |= solve((y-1+R) % R, x, 3, mem);\n  }else if(f[y][x] == 'v'){\n    res |= solve((y+1+R) % R, x, 1, mem);\n  }else{\n    int nx, ny;\n    if(dir == 0){\n      nx = (x+1+C)%C;\n      ny = y;\n    }else if(dir == 1){\n      nx = x;\n      ny = (y+1+R) % R;\n    }else if(dir == 2){\n      nx = (x-1 + C) % C;\n      ny = y;\n    }else{\n      nx = x;\n      ny = (y-1+R) % R;\n    }\n\n    if(f[y][x] == '_'){\n      if(mem == 0){\n\tres |= solve(y, (x+1 + C) % C, 0, mem);\n      }else{\n\tres |= solve(y, (x-1 + C) % C, 2, mem);\n      }\n    }else if(f[y][x] == '|'){\n      if(mem == 0){\n\tres |= solve((y+1+R) % R, x, 1, mem);\n      }else{\n\tres |= solve((y-1+R) % R, x, 3, mem);\n      }\n    }else if(f[y][x] == '?'){\n      res |= solve(y, (x-1 + C) % C, 2, mem);\n      res |= solve(y, (x+1 + C) % C, 0, mem);\n      res |= solve((y-1+R) % R, x, 3, mem);\n      res |= solve((y+1+R) % R, x, 1, mem);\n    }else if(f[y][x] == '.'){\n      res |= solve(ny, nx, dir, mem);\n    }else if(isdigit(f[y][x])){\n      res |= solve(ny, nx, dir, f[y][x] - '0');\n    }else if(f[y][x] == '+'){\n      res |= solve(ny, nx, dir, (mem+1 + 16) % 16);\n    }else if(f[y][x] == '-'){\n      res |= solve(ny, nx, dir, (mem-1 + 16) % 16);\n    }\n  }\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> R >> C;\n  f = vector< vector<char> >(R, vector<char>(C));\n  visited = vector< vector< vector<int> > > (R, vector<vector< int> >(C));\n  for(int i = 0; i < R; i++){\n    for(int j = 0; j < C; j++){\n      cin >> f[i][j];\n    }\n  }\n\n  if(solve(0, 0, 0, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  \n  State st=State(0,0,0,0), ne=State(0,0,0,0);\n  \n  while(!Q.empty()) {\n    st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]+R);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define N 20\n#define M 16\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nstring s[N];\nint r,c;\n\nbool bfs(){\n  bool d[N][N][4][M];\n  queue<P1> q;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  memset(d,0,sizeof(d));\n  q.push(P1(P(0,0),P(1,0)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int y=t.f.f,x=t.f.s;\n    int dir=t.s.f,mem=t.s.s;\n    int ndir=dir,nmem=mem;\n    if(d[y][x][dir][mem])continue;\n    d[y][x][dir][mem]=true;\n    if(s[y][x]=='@')return true;\n    if(s[y][x]=='<')ndir=3;\n    if(s[y][x]=='>')ndir=1;\n    if(s[y][x]=='^')ndir=0;\n    if(s[y][x]=='v')ndir=2;\n    if(s[y][x]=='_'){\n      if(!mem)ndir=1;\n      else ndir=3;\n    }\n    if(s[y][x]=='|'){\n      if(!mem)ndir=2;\n      else ndir=0;\n    }\n    if('0'<=s[y][x]&&s[y][x]<='9')\n      nmem=s[y][x]-'0';\n    if(s[y][x]=='+')\n      nmem=(mem+1)%16;\n    if(s[y][x]=='-')\n      nmem=(mem+15)%16;\n    if(s[y][x]=='?'){\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(ny<0)ny=r-1;\n\tif(nx<0)nx=c-1;\n\tif(r<=ny)ny=0;\n\tif(c<=nx)nx=0;\n\tq.push(P1(P(ny,nx),P(i,nmem)));\n      }\n    }else{\n      int ny=y+dy[ndir];\n      int nx=x+dx[ndir];\n      if(ny<0)ny=r-1;\n      if(nx<0)nx=c-1;\n      if(r<=ny)ny=0;\n      if(c<=nx)nx=0;\n      q.push(P1(P(ny,nx),P(ndir,nmem)));\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++)cin>>s[i];\n  if(bfs())cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAXR = 21;\nconst int MAXC = 21;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nstruct State {\n  int i, j, d, m;\n  State();\n  State(int i, int j, int d, int m) \n    : i(i), j(j), d(d), m(m) {}\n};\n\nint R, C;\nchar G[MAXR][MAXC];\nbool vis[MAXR][MAXC][4][16];\n\nbool canFinish() {\n  State s(0,0,0,0);\n  queue<State> que;\n  que.push(s);\n  fill(vis[0][0][0], vis[MAXR][0][0], false);\n  vis[s.i][s.j][s.d][s.m] = true;\n\n  while(!que.empty()) {\n    s = que.front();\n    que.pop();\n\n    if(isdigit(G[s.i][s.j])) {\n      s.m = G[s.i][s.j] - '0';\n    } else {\n      switch(G[s.i][s.j]) {\n      case '<':\n\ts.d = 2;\n\tbreak;\n      case '>':\n\ts.d = 0;\n\tbreak;\n      case '^':\n\ts.d = 3;\n\tbreak;\n      case 'v':\n\ts.d = 1;\n\tbreak;\n      case '_':\n\tif(s.m == 0) s.d = 0;\n\telse s.d = 2;\n\tbreak;\n      case '|':\n\tif(s.m == 0) s.d = 1;\n\telse s.d = 3;\n\tbreak;\n      case '?':\n\ts.d = -1;\n\tbreak;\n      case '.':\n\t//\n\tbreak;\n      case '@':\n\treturn true;\n      case '+':\n\ts.m = (s.m+1)%16;\n\tbreak;\n      case '-':\n\ts.m = (s.m-1+16)%16;\n\tbreak;\n      }\n    }\n\n    vector<State> next;\n    if(s.d == -1) {\n      for(s.d = 0; s.d < 4; ++s.d) {\n\tnext.push_back(s);\n      }\n    } else {\n      next.push_back(s);\n    }\n\n    for(int k = 0; k < next.size(); ++k) {\n      State &t = next[k];\n      t.i = (t.i + di[t.d] + R) % R;\n      t.j = (t.j + dj[t.d] + C) % C;\n      if(vis[t.i][t.j][t.d][t.m]) continue;\n      vis[t.i][t.j][t.d][t.m] = true;\n      que.push(t);\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> R >> C) {\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(canFinish()) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><^v\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 1 : 0;\n  else if (ch == '|') \n    d = mem ? 2 : 3;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint memc[22][22][20][10]={0};\nchar prog[22][22];\nint dh[5]={0,-1,0,1,0};\nint dw[5]={0,0,1,0,-1};\nint ww,hh;\nbool gogo(int h,int w,int m,int muki);\nmain(){\n  cin>>hh>>ww;\n  for(int i=1;i<=hh;i++){\n    for(int j=1;j<=ww;j++){\n      cin>>prog[i][j];\n    }\n  }\n  if(gogo(1,1,0,2)){\n    cout<<\"YES\"<<endl;\n  }\n  else{\n    cout<<\"NO\"<<endl;\n  } \n}\nbool gogo(int h,int w,int m,int muki){\n  //cout<<h<<\" \"<<w<<\" \"<<m<<\" \"<<muki<<endl;\n  if(prog[h][w]=='@'){\n    return true;\n  }\n  if(memc[h][w][m][muki]==1){\n    return false;\n  }\n  memc[h][w][m][muki]=1;\n  if(prog[h][w]=='^'){\n    muki=1;\n  }\n  if(prog[h][w]=='>'){\n    muki=2;\n  }\n  if(prog[h][w]=='v'){\n    muki=3;\n  }\n  if(prog[h][w]=='<'){\n    muki=4;\n  }\n  if(prog[h][w]=='_'){\n    if(m==0){\n      muki=2;\n    }\n    else{\n      muki=4;\n    }\n  }\n  if(prog[h][w]=='|'){\n    if(m==0){\n      muki=3;\n    }\n    else{\n      muki=1;\n    }\n  }\n  if(prog[h][w]>='0'&&prog[h][w]<='9'){\n    m=prog[h][w]-'0';\n  }\n  if(prog[h][w]=='+'){\n    if(m==15){\n      m=0;\n    }\n    else{\n      m++;  \n    }\n  }\n  if(prog[h][w]=='-'){\n    if(m==0){\n      m=15;\n    }\n    else{\n      m--;\n    }\n  }\n  if(prog[h][w]!='?'){\n    if(h+dh[muki]==0){\n      h=hh+1;\n    }\n    if(h+dh[muki]>hh){\n      h=0;\n    }\n    if(w+dw[muki]==0){\n      w=ww+1;\n    }\n    if(w+dw[muki]>ww){\n      w=0;\n    }\n    return gogo(h+dh[muki],w+dw[muki],m,muki);\n  }\n  else{\n    int a=0;\n    for(int i=1;i<=4;i++){\n      a+=gogo(h+dh[i],w+dw[i],m,muki);\n    }\n    if(a==0){\n      return false;\n    }\n    else{\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 21;\nconst int MAX_W = 21;\nconst int MAX_M = 11;\n\nint H, W;\nstring M[MAX_H];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 16;\n\nint H, W;\nstring M[20];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int R, C;\n  char prog[21][21];\n  cin >> R >> C;\n  for(int i = 0; i < R; i++){\n    for(int j = 0; j < C; j++) cin >> prog[i][j];\n  }\n  typedef pair<int, int> P;\n  typedef pair<P, P> PP;\n  bool visited[21][21][16][5];\n  memset(visited, false, sizeof(visited));\n  queue<PP> que;\n  int left = 0, right = 1, up = 2, down = 3;\n  int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\n  bool flag = false;\n  que.push(PP(P(0, 0), P(right, 0)));\n  while(!que.empty()){\n    PP p = que.front(); que.pop();\n    int x = p.first.first, y = p.first.second, d = p.second.first, mem = p.second.second;\n    if(x < 0 || C <= x || y < 0 || R <= y) continue;\n    if(visited[x][y][d][mem]) continue;\n    visited[x][y][d][mem] = true;\n    switch(prog[y][x]){\n    case '<': que.push(PP(P(x-1, y), P(left, mem))); break;\n    case '>': que.push(PP(P(x+1, y), P(right, mem))); break;\n    case '^': que.push(PP(P(x, y-1), P(up, mem))); break;\n    case 'v': que.push(PP(P(x, y+1), P(down, mem))); break;\n    case '_': \n      if(mem == 0) que.push(PP(P(x+1, y), P(right, mem)));\n      else que.push(PP(P(x-1, y), P(left, mem)));\n      break;\n    case '|':\n      if(mem == 0) que.push(PP(P(x, y+1), P(down, mem)));\n      else que.push(PP(P(x, y-1), P(up, mem)));\n      break;\n    case '?':\n      for(int i = 0; i < 4; i++){\n\tque.push(PP(P(x+dx[i], y+dy[i]), P(i, mem)));\n      }\n      break;\n    case '+': que.push(PP(P(x+dx[d], y+dy[d]), P(d, (mem+1)%16))); break;\n    case '-': que.push(PP(P(x+dx[d], y+dy[d]), P(d, (mem+15)%16))); break;\n    case '@': flag = true; break;\n    case '.': que.push(PP(P(x+dx[d], y+dy[d]), P(d, mem))); break;\n    default:\n      que.push(PP(P(x+dx[d], y+dy[d]), P(d, prog[y][x]-'0')));\n      break;\n    }\n    if(flag) break;\n  }\n  cout << (flag ? \"YES\" : \"NO\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n#define DOWN  0\n#define RIGHT 1\n#define UP    2\n#define LEFT  3\n\nstruct State {\n  int x, y;\n  int mem;\n  int dir;\n\n  State() :\n      x(0),\n      y(0),\n      mem(0),\n      dir(RIGHT) {}\n\n  State(int x, int y, int mem, int dir) :\n      x(x),\n      y(y),\n      mem(mem),\n      dir(dir) {}\n\n  bool operator<(const State & rhs) const {\n    if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n    if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n    if (x == rhs.x) return y < rhs.y;\n    return x < rhs.x;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int R, C;\n  cin >> R >> C;\n  vector<string> prog(R);\n  rep(i, R) cin >> prog[i];\n\n  set<State> visited;\n  queue<State> Q;\n  ll ok = false;\n\n  Q.push(State());\n  while (!Q.empty()) {\n    State st = Q.front();\n    Q.pop();\n\n    if (visited.find(st) != visited.end())\n      break;\n\n    visited.insert(st);\n\n    char p;\n\n    st.x = (st.x + C) % C;\n    st.y = (st.y + R) % R;\n\n    p = prog[st.y][st.x];\n\n    if (p == '@') {\n      ok = true;\n      break;\n    }\n\n    if ('0' <= p && p <= '9') {\n      st.mem = p - 'p';\n    } else if (p == '_') {\n      if (st.mem == 0) st.dir = RIGHT;\n      else st.dir = LEFT;\n    } else if (p == '|') {\n      if (st.mem == 0) st.dir = DOWN;\n      else st.dir = UP;\n    } else if (p == '+') {\n      st.mem = (st.mem + 1) % 16;\n    } else if (p == '-') {\n      st.mem = st.mem - 1;\n      if (st.mem < 0) st.mem += 16;\n    } else if (p == '^') st.dir = UP;\n    else if (p == 'v') st.dir = DOWN;\n    else if (p == '<') st.dir = LEFT;\n    else if (p == '>') st.dir = RIGHT;\n\n    if (p != '?') {\n      st.x += dx[st.dir];\n      st.y += dy[st.dir];\n      Q.push(st);\n    } else {\n      Q.push(State(st.x + dx[LEFT], st.y + dy[LEFT], st.mem, LEFT));\n      Q.push(State(st.x + dx[RIGHT], st.y + dy[RIGHT], st.mem, RIGHT));\n      Q.push(State(st.x + dx[UP], st.y + dy[UP], st.mem, UP));\n      Q.push(State(st.x + dx[DOWN], st.y + dy[DOWN], st.mem, DOWN));\n    }\n  }\n  \n  if (ok) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  \n  State st=State(0,0,0,0), ne=State(0,0,0,0);\n  while(!Q.empty()) {\n    st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\nint r, c;\nchar a[21][21];\nbool vis[22][22][17][5];\n\nint xdir[4] = {1, 0, -1, 0}, ydir[4] = {0, 1, 0, -1};\nbool dfs(int x, int y, int m, int d)\n{\n  if(!vis[y][x][m][d]) return false;\n  vis[y][x][m][d] = false;\n\n  char ch = a[y][x];\n  int nm = m, nd = d, dx, dy; \n\n  if(ch == '@') return true;\n  else if(ch == '<') nd = 2;\n  else if(ch == '>') nd = 0;\n  else if(ch == '^') nd = 3;\n  else if(ch == 'v') nd = 1;\n  else if(ch == '|') nd = (nm == 0)? 1 : 3;\n  else if(ch == '_') nd = (nm == 0)? 0 : 2;\n  else if(ch == '+') nm = (nm+1)%15;\n  else if(ch == '-') nm = (m == 0)? 15 : (m-1);\n  else if(isdigit(ch)) nm = (int)(ch-'0');\n  \n  if(ch == '?'){\n    for(int i = 0; i < 4; i++){\n      dx = x+xdir[i], dy = y+ydir[i];\n      if(dx < 0) dx = c-1;\n      if(dx >= c) dx = 0;\n      if(dy < 0) dy = r-1;\n      if(dy >= r) dy = 0;\n\n      if(dfs(dx, dy, nm, nd)) return true;\n    }\n\n    return false;\n  }\n  \n  dx = x+xdir[nd], dy = y+ydir[nd];\n  if(dx < 0) dx = c-1;\n  if(dx >= c) dx = 0;\n  if(dy < 0) dy = r-1;\n  if(dy >= r) dy = 0;\n  \n  return dfs(dx, dy, nm, nd);\n}\n\nint main()\n{\n  while(cin>>r>>c && (r+c)){\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++) cin >> a[i][j];\n\n    fill(&vis[0][0][0][0], &vis[21][21][16][4], true);\n\n    cout << ((dfs(0, 0, 0, 0))? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]+R);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n#define pb(e) push_back(e)\n\ntypedef long long ll;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n    int r, c;\n    string prog[20];\n    cin >> r >> c;\n    rep(i, r) cin >> prog[i];\n    \n    int x = 0, y = 0, dir = 0, mem = 0;\n    rep(i, 200000000) {\n        switch(prog[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem == 0 ? 0 : 2); break;\n            case '|': dir = (mem == 0 ? 1 : 3); break;\n            case '?': dir = rand() & 3; break;\n            case '.': break;\n            case '@': cout << \"YES\" << endl; return 0;\n            case '+': mem = (mem + 1) & 15; break;\n            case '-': mem = (mem - 1) & 15; break;\n            default:  mem = prog[y][x] - '0';\n        }\n        x += dx[dir]; y += dy[dir];\n        if(x == -1) x = c - 1;\n        if(x == c) x = 0;\n        if(y == -1) y = r - 1;\n        if(y == r) y = 0;\n    }\n    cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint r,c;\nstring str[22];\nstring str2[22];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool visited[22][22][4][17];\n\nbool dfs(int x,int y,int d,int m){\n\tif(visited[x][y][d][m])return false;\n\tvisited[x][y][d][m]=true;\n\t//printf(\"%d %d %d %d\\n\",x,y,d,m);\n\tif(str[x][y]=='@')return true;\n\tif(str[x][y]=='>')d=0;\n\tif(str[x][y]=='<')d=2;\n\tif(str[x][y]=='^')d=3;\n\tif(str[x][y]=='v')d=1;\n\tif(str[x][y]=='_'){\n\t\tif(m==0)d=0;\n\t\tif(m!=0)d=2;\n\t}\n\tif(str[x][y]=='|'){\n\t\tif(m==0)d=1;\n\t\tif(m!=0)d=3;\n\t}\n\tif(str[x][y]>='0' && str[x][y]<='9')m=str[x][y]-'0';\n\tif(str[x][y]=='+')m=(m+1)%16;\n\tif(str[x][y]=='-')m=(m+15)%16;\n\tif(str[x][y]=='?'){\n\t\tbool ch=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(dfs((x+dx[i]+c)%c,(y+dy[i]+r)%r,i,m))ch=true;\n\t\t}\n\t\treturn ch;\n\t}else{\n\t\treturn dfs((x+dx[d]+c)%c,(y+dy[d]+r)%r,d,m);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tstr2[i]=str[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tstr[j][i]=str2[i][j];\n\t\t}\n\t}\n\tmemset(visited,false,sizeof(visited));\n\tprintf(\"%s\\n\",dfs(0,0,0,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n  \nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n  \n#define DOWN   0\n#define RIGHT 1\n#define UP       2\n#define LEFT   3\n  \nstruct State {\n    int x, y;\n    int mem;\n    int dir;\n  \n    State() :\n            x(0),\n            y(0),\n            mem(0),\n            dir(RIGHT) {}\n  \n    State(int x, int y, int mem, int dir) :\n            x(x),\n            y(y),\n            mem(mem),\n            dir(dir) {}\n  \n    bool operator<(const State & rhs) const {\n        if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n        if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n        if (x == rhs.x) return y < rhs.y;\n        return x < rhs.x;\n    }\n};\n  \nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int R, C;\n    cin >> R >> C;\n    vector<string> prog(R);\n    rep(i, R) cin >> prog[i];\n  \n    set<State> visited;\n    queue<State> Q;\n    ll ok = false;\n  \n    Q.push(State());\n    while (!Q.empty()) {\n        State st = Q.front();\n        Q.pop();\n  \n        st.x = (st.x + C) % C;\n        st.y = (st.y + R) % R;\n  \n        if (visited.find(st) != visited.end())\n            continue;\n          \n        visited.insert(st);\n  \n        char p;\n        p = prog[st.y][st.x];\n  \n        if (p == '@') {\n            ok = true;\n            break;\n        }\n  \n        switch (p) {\n            case '0'...'9':\n                st.mem = p - '0';\n                break;\n            case '_':\n                if (st.mem == 0) st.dir = RIGHT;\n                else st.dir = LEFT;\n                break;\n            case '|':\n                if (st.mem == 0) st.dir = DOWN;\n                else st.dir = UP;\n                break;\n            case '+':\n                st.mem = (st.mem + 1) % 16;\n                break;\n            case '-':\n                st.mem = st.mem - 1;\n                if (st.mem < 0) st.mem += 16;\n                break;\n            case '^':\n                st.dir = UP;\n                break;\n            case 'v':\n                st.dir = DOWN;\n                break;\n            case '<':\n                st.dir = LEFT;\n                break;\n            case '>':\n                st.dir = RIGHT;\n                break;\n        }\n  \n        if (p != ' ') {\n            Q.push(State(st.x + dx[st.dir], st.y + dy[st.dir], st.mem, st.dir));\n        } else {\n            Q.push(State(st.x + dx[LEFT],     st.y + dy[LEFT],   st.mem, LEFT));\n            Q.push(State(st.x + dx[RIGHT],   st.y + dy[RIGHT], st.mem, RIGHT));\n            Q.push(State(st.x + dx[UP],         st.y + dy[UP],       st.mem, UP));\n            Q.push(State(st.x + dx[DOWN],     st.y + dy[DOWN],   st.mem, DOWN));\n        }\n    }\n      \n    if (ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"<>^v\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '_') \n    d = mem ? 0 : 1;\n  else if (ch == '|') \n    d = mem ? 2 : 3;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) \n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\treturn true;\n    return false;\n  }\n  else if (ch == '.')\n    ;\n  else if (ch == '@')\n    return true;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else \n    d = change(ch);\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 16;\n\nint H, W;\nstring M[MAX_H];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n\nint main()\n{\n  int R, C;\n  char field[20][20];\n\n  cin >> R >> C;\n\n  for (int r = 0; r < R; r++)\n    for (int c = 0; c < C; c++)\n      cin >> field[r][c];\n\n  int mem = 0, dist = 0, row = 0, col = 0,\n      dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}, tr, tc;\n\n  // visit[mem][dist][row][col]\n  bool visit[16][4][20][20], ok = false;\n  memset(visit, false, sizeof(visit));\n  while (true) {\n\n    if (visit[mem][dist][row][col]) {\n      cout << \"NO\" << endl;\n      break;\n    }\n\n    visit[mem][dist][row][col] = true;\n\n    switch(field[row][col]) {\n      case '<':\n        dist = 2;\n        break;\n      case '>':\n        dist = 0;\n        break;\n      case '^':\n        dist = 3;\n        break;\n      case 'v':\n        dist = 1;\n        break;\n      case '_':\n        if (mem == 0)\n          dist = 0;\n        else\n          dist = 2;\n        break;\n      case '|':\n        if (mem == 0)\n          dist = 1;\n        else\n          dist = 3;\n        break;\n      case '?':\n        tr = row; tc = col;\n        for (dist = 0; dist < 4; dist++) {\n          tr = (row + dy[dist] + R) % R;\n          tc = (col + dx[dist] + C) % C;\n          if (!visit[mem][dist][tr][tc])\n            break;\n        }\n        break;\n      case '.':\n        break;\n      case '@':\n        cout << \"YES\" << endl;\n        ok = true;\n        break;\n      case '+':\n        mem = (mem + 1) % 16;\n        break;\n      case '-':\n        mem = (mem - 1 + 16) % 16;\n        break;\n      default:\n        mem = field[row][col] - '0';\n        break;\n    }\n\n\n    if (ok)\n      break;\n\n    row = (row + dy[dist] + R) % R;\n    col = (col + dx[dist] + C) % C;\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <ctime>\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nclass State\n{\npublic:\n  int x, y, m, d;\n  State(int xx, int yy, int mm, int dd)\n    :x(xx), y(yy), m(mm), d(dd) {}\n};\n\nint main()\n{\n  int R, C;\n  while (cin >> R >> C) {\n    vector<string> c(R);\n    for (int i = 0; i < R; ++i)\n      cin >> c[i];\n\n    bool yes = false;\n    static bool visited[20][20][16][4];\n    for (int i = 0; i < 20; ++i) {\n      for (int j = 0; j < 20; ++j) {\n\tfor (int k = 0; k < 16; ++k) {\n\t  for (int l = 0; l < 4; ++l)\n\t    visited[i][j][k][l] = false;\n\t}\n      }\n    }\n\n    queue<State> que;\n    que.push(State(0, 0, 0, 1));\n    while (!que.empty()) {\n      State st = que.front();\n      que.pop();\n\n      if (visited[st.y][st.x][st.m][st.d])\n\tcontinue;\n\n      char op = c[st.y][st.x];\n      visited[st.y][st.x][st.m][st.d] = true;\n      switch (op) {\n\n      case '<':\n\tst.d = 0;\n\tbreak;\n\n      case '>':\n\tst.d = 1;\n\tbreak;\n\n      case '^':\n\tst.d = 2;\n\tbreak;\n\n      case 'v':\n\tst.d = 3;\n\tbreak;\n\n      case '_':\n\tif (st.m == 0)\n\t  st.d = 1;\n\telse\n\t  st.d = 0;\n\tbreak;\n\n      case '|':\n\tif (st.m == 0)\n\t  st.d = 3;\n\telse\n\t  st.d = 2;\n\tbreak;\n\n      case '?':\n\tst.d = 4;\n\tbreak;\n\n      case '@':\n\tyes = true;\n\tbreak;\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n\tst.m = (op - '0');\n\tbreak;\n\n      case '+':\n\tif (st.m == 15)\n\t  st.m = 0;\n\telse\n\t  ++st.m;\n\tbreak;\n\n      case '-':\n\tif (st.m == 0)\n\t  st.m = 15;\n\telse\n\t  --st.m;\n\tbreak;\n      }\n\n      if (yes)\n\tbreak;\n\n      if (st.d < 4) {\n\tst.x += dx[st.d];\n\tif (st.x < 0)\n\t  st.x = C-1;\n\telse if (st.x >= C)\n\t  st.x = 0;\n\n\tst.y += dy[st.d];\n\tif (st.y < 0)\n\t  st.y = R-1;\n\telse if (st.y >= R)\n\t  st.y = 0;\n\n\tque.push(st);\n      } else {\n\tint x = st.x, y = st.y;\n\tfor (int i = 0; i < 4; ++i) {\n\t  st.x = x + dx[i];\n\t  if (st.x < 0)\n\t    st.x = C-1;\n\t  else if (st.x >= C)\n\t    st.x = 0;\n\n\t  st.y = y + dy[i];\n\t  if (st.y < 0)\n\t    st.y = R-1;\n\t  else if (st.y >= R)\n\t    st.y = 0;\n\n\t  st.d = i;\n\t  que.push(st);\n\t}\n      }\n    }\n\n    if (yes)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define N 20\n#define M 16\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nstring s[N];\nint r,c;\n\nbool bfs(){\n  bool d[N][N][4][M];\n  queue<P1> q;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  memset(d,0,sizeof(d));\n  q.push(P1(P(0,0),P(1,0)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int y=t.f.f,x=t.f.s;\n    int dir=t.s.f,mem=t.s.s;\n    int ndir=dir,nmem=mem;\n    if(d[y][x][dir][mem])continue;\n    d[y][x][dir][mem]=true;\n    if(s[y][x]=='@')return true;\n    if(s[y][x]=='<')ndir=3;\n    if(s[y][x]=='>')ndir=1;\n    if(s[y][x]=='^')ndir=0;\n    if(s[y][x]=='v')ndir=2;\n    if(s[y][x]=='_'){\n      if(!mem)ndir=1;\n      else ndir=3;\n    }\n    if(s[y][x]=='|'){\n      if(!mem)ndir=2;\n      else ndir=0;\n    }\n    if('0'<=s[y][x]&&s[y][x]<='9')\n      nmem=s[y][x]-'0';\n    if(s[y][x]=='+')\n      nmem=(mem+1)%16;\n    if(s[y][x]=='-')\n      nmem=(mem+15)%16;\n    if(s[y][x]=='?'){\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(ny<0)ny=19;\n\tif(nx<0)nx=19;\n\tif(r<=ny)ny=0;\n\tif(c<=nx)nx=0;\n\tq.push(P1(P(ny,nx),P(ndir,nmem)));\n      }\n    }else{\n      int ny=y+dy[ndir];\n      int nx=x+dx[ndir];\n      if(ny<0)ny=19;\n      if(nx<0)nx=19;\n      if(r<=ny)ny=0;\n      if(c<=nx)nx=0;\n      q.push(P1(P(ny,nx),P(ndir,nmem)));\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++)cin>>s[i];\n  if(bfs())cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\nstruct Point{int x,y,d,m;};\nint main(){\n  int r,c;\n  cin >> r >> c;\n  string st[25];\n  int i,j,k;\n  for(i=0;i<r;i++) cin >> st[i];\n  Point p,b;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  p.x=0;p.y=0;p.d=0;p.m=0;\n  queue <Point> q;\n  q.push(p);\n  bool f=true;\n  int vi[25][25][5][20]={{{{}}}};\n \n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(vi[p.x][p.y][p.d][p.m]==1) continue;\n    vi[p.x][p.y][p.d][p.m]=1;\n    char x=st[p.y][p.x];\n    if(x=='<'){\n      p.d=2;\n    }else if(x=='>'){\n      p.d=0;\n    }else if(x=='^'){\n      p.d=3;\n    }else if(x=='v'){\n      p.d=1;\n    }else if(x=='_'){\n      if(p.m==0) p.d=0;\n      else p.d=2;\n    }else if(x=='|'){\n      if(p.m==0) p.d=1;\n      else p.d=3;\n    }else if(x=='?'){\n      for(i=0;i<4;i++){\n        b.d=i;\n        b.x=(p.x+c+ax[b.d])%c;\n        b.y=(p.y+r+ay[b.d])%r;\n        b.m=p.m;\n        q.push(b);\n      }\n      continue;\n    }else if(x=='.'){\n    }else if(x=='@'){\n      f=false;\n      break;\n    }else if(x>='0'&&x<='9'){\n      p.m=x-'0';\n    }else if(x=='+'){\n      p.m=(p.m+1)%16;\n    }else if(x=='-'){\n      p.m=(p.m+15)%16;\n    }\n    b.d=p.d;\n    b.x=(p.x+c+ax[b.d])%c;\n    b.y=(p.y+r+ay[b.d])%r;\n    b.m=p.m;\n    q.push(b);\n  }\n  if(f) cout << \"NO\" << endl;\n  else cout << \"YES\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define R 0\n#define D 1\n#define L 2\n#define U 3\n\n#define MAX_R 20\n#define MAX_C 20\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nint r, c;\nstring pg[MAX_R];\nbool used[MAX_R][MAX_C][4][16]; // 座標, 方向\n\nbool stop(int y, int x, int dir, int m) {\n    while (true) {\n        if (used[y][x][dir][m]) return false;\n        used[y][x][dir][m] = true;\n        switch (pg[y][x]) {\n            case '<':\n                dir = L;\n                break;\n            case '>':\n                dir = R;\n                break;\n            case '^':\n                dir = U;\n                break;\n            case 'v':\n                dir = D;\n                break;\n            case '_':\n                if (m == 0) dir = R;\n                else dir = L;\n                break;\n            case '|':\n                if (m == 0) dir = D;\n                else dir = U;\n                break;\n            case '?':\n                for (int i = 0; i < 4; i++) {\n                    dir = i;\n                    int ny = y + dy[dir];\n                    if (ny < 0) ny = r-1;\n                    if (ny >= r) ny = 0;\n                    int nx = x + dx[dir];\n                    if (nx < 0) nx = c-1;\n                    if (nx >= c) nx = 0;\n                    if (stop(ny, nx, dir, m)) return true;\n                }\n                return false;\n            case '.':\n                // Do nothing\n                break;\n            case '@':\n                return true;\n            case '0':\n            case '1': case '2': case '3': \n            case '4': case '5': case '6':\n            case '7': case '8': case '9':\n                m = pg[y][x] - '0';\n                break;\n            case '+':\n                if (m == 15) m = 0;\n                else m++;\n                break;\n            case '-':\n                if (m == 0) m = 15;\n                else m--;\n                break;\n        }\n        int ny = y + dy[dir];\n        if (ny < 0) ny = r-1;\n        if (ny >= r) ny = 0;\n        int nx = x + dx[dir];\n        if (nx < 0) nx = c-1;\n        if (nx >= c) nx = 0;\n        y = ny;\n        x = nx;\n    }\n}\n\nint main() {\n    cin >> r >> c;\n    for (int i = 0; i < r; i++) cin >> pg[i];\n    int y, x;\n    int m; // memory\n    int dir; // direction\n    y = x = 0;\n    m = 0;\n    dir = R;\n    cout << (stop(y, x, dir, m) ? \"YES\" : \"NO\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <ctype.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int dir;\n  int cnt;\n  int x;\n  int y;\n  Point() {;}\n  Point(int dir, int cnt, int x, int y) : dir(dir), cnt(cnt), x(x), y(y) {;}\n};\n\nint w, h;\nchar field[30][30];\nbool visit[4][20][30][30];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nvoid Push(queue<Point> &que, int dir, int cnt, int x, int y) {\n  int nx = (x + dx[dir] + w) % w;\n  int ny = (y + dy[dir] + h) % h;\n  if (visit[dir][cnt][ny][nx]) { return; }\n  visit[dir][cnt][ny][nx] = true;\n  que.push(Point(dir, cnt, nx, ny));\n}\n\nint main() {\n  while (scanf(\"%d %d\", &h, &w) > 0) {\n    MEMSET(visit, false);\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    queue<Point> que;\n    que.push(Point(0, 0, 0, 0));\n    while (!que.empty()) {\n      int dir = que.front().dir;\n      int cnt = que.front().cnt;\n      int x = que.front().x;\n      int y = que.front().y;\n      int ndir = dir;\n      int ncnt = cnt;\n      que.pop();\n      if (field[y][x] == '@') {\n        puts(\"YES\");\n        goto next;\n      } else if (field[y][x] == '>') {\n        ndir = 0;\n      } else if (field[y][x] == 'v') {\n        ndir = 1;\n      } else if (field[y][x] == '<') {\n        ndir = 2;\n      } else if (field[y][x] == '^') {\n        ndir = 3;\n      } else if (field[y][x] == '_') {\n        if (ncnt == 0) { ndir = 0; }\n        else { ndir = 2; }\n      } else if (field[y][x] == '|') {\n        if (ncnt == 0) { ndir = 1; }\n        else { ndir = 3; }\n      } else if (field[y][x] == '?') {\n        //\n      } else if (field[y][x] == '.') {\n        //\n      } else if (field[y][x] == '+') {\n        ncnt = (ncnt + 1) % 16;\n      } else if (field[y][x] == '-') {\n        ncnt = (ncnt + 15) % 16;\n      } else if (isdigit(field[y][x])) {\n        ncnt = field[y][x] - '0';\n      }\n\n      assert(ndir >= 0 && ndir < 4);\n      assert(ncnt >= 0 && ncnt < 16);\n      if (field[y][x] != '?') {\n        Push(que, ndir, ncnt, x, y);\n      } else {\n        REP(i, 4) { Push(que, i, ncnt, x, y); }\n      }\n    }\n    puts(\"NO\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\n\nchar T[22]=\"0123456789^>v<?_|.+-@\";\nint x[25][25],h,w;char c;\nint dp[25][25][16][4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint ab,a1,a2,a3,a4,X;\ntuple<int,int,int,int>tup;\nqueue<tuple<int,int,int,int>>Q;\n\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>c;\n\t\t\tfor(int k=0;k<21;k++){\n\t\t\t\tif(T[k]==c){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][1]=1;\n\tQ.push(make_tuple(0,0,0,1));\n\twhile(!Q.empty()){\n\t\ttup=Q.front();\n\t\tQ.pop();\n\t\ta1=get<0>(tup);\n\t\ta2=get<1>(tup);\n\t\ta3=get<2>(tup);\n\t\ta4=get<3>(tup);\n\t\tX=x[a1][a2];\n\t\tif(X>=0 && X<=9){\n\t\t\ta3=X;\n\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X>=10 && X<=13){\n\t\t\ta4=X-10;\n\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==14){\n\t\t\tfor(int n=0;n<4;n++){\n\t\t\t\ta4=n;\n\t\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(X==15){\n\t\t\tif(a3==0){\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==16){\n\t\t\tif(a3==0){\n\t\t\t\ta4=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=0;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==17){\n\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tab=1;\n\t\tif(X==18 || X==19){\n\t\t\tif(X==19){ab=-1;}\n\t\t\ta3=(a3+ab+16)%16;\n\t\t\tif(dp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4]+h)%h][(a2+dx[a4]+w)%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4]+h)%h,(a2+dx[a4]+w)%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==20){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tgoto E;\n\t\t}\n\t}\n\tcout<<\"NO\"<<endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\n\nstruct data{\n    int y,x,m,d;\n    data(int y,int x,int m,int d):y(y),x(x),m(m),d(d){}\n};\n\nint H,W;\nchar fld[32][32];\n\nbool memo[20][20][16][4];\n\ndata go(data tmp){\n    int ny=tmp.y+dy[tmp.d],nx=tmp.x+dx[tmp.d];\n    if(ny<0)ny=H-1;\n    if(ny>=H)ny=0;\n    if(nx<0)nx=W-1;\n    if(nx>=W)nx=0;\n    return data(ny,nx,tmp.m,tmp.d);\n}\n\nint main(){\n    cin>>H>>W;\n    rep(i,H)cin>>fld[i];\n\n    queue<data>que;\n    que.push(data(0,0,0,3));\n    memo[0][0][0][3]=true;\n\n    while(que.size()){\n        data tmp=que.front();que.pop();\n\n        char c=fld[tmp.y][tmp.x];\n        if(c=='<'){\n            tmp.d=1;\n        }\n        if(c=='>'){\n            tmp.d=3;\n        }\n        if(c=='^'){\n            tmp.d=0;\n        }\n        if(c=='v'){\n            tmp.d=2;\n        }\n        if(c=='_'){\n            if(tmp.m==0)tmp.d=3;\n            else tmp.d=1;\n        }\n        if(c=='|'){\n            if(tmp.m==0)tmp.d=2;\n            else tmp.d=0;\n        }\n        if(c=='.'){\n\n        }\n        if(c=='@'){\n            cout<<\"YES\"<<endl;\n            return 0;\n        }\n        if(isdigit(c)){\n            tmp.m=c-'0';\n        }\n        if(c=='+'){\n            tmp.m=(tmp.m+1)%16;\n        }\n        if(c=='-'){\n            tmp.m=(tmp.m+15)%16;\n        }\n\n        if(c=='?'){\n            rep(i,4){\n                tmp.d=i;\n                data nxt=go(tmp);\n                if(memo[nxt.y][nxt.x][nxt.m][nxt.d])continue;\n                memo[nxt.y][nxt.x][nxt.m][nxt.d]=true;\n                que.push(nxt);\n            }\n        }\n        else{\n            tmp=go(tmp);\n            if(memo[tmp.y][tmp.x][tmp.m][tmp.d])continue;\n            memo[tmp.y][tmp.x][tmp.m][tmp.d]=true;\n            que.push(tmp);\n        }\n    }\n\n    cout<<\"NO\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define N 20\n#define M 16\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nstring s[N];\nint r,c;\n\nbool bfs(){\n  bool d[N][N][4][M];\n  queue<P1> q;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  memset(d,0,sizeof(d));\n  q.push(P1(P(0,0),P(1,0)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int y=t.f.f,x=t.f.s;\n    int dir=t.s.f,mem=t.s.s;\n    int ndir=dir,nmem=mem;\n    if(d[y][x][dir][mem])continue;\n    d[y][x][dir][mem]=true;\n    if(s[y][x]=='@')return true;\n    if(s[y][x]=='<')ndir=3;\n    if(s[y][x]=='>')ndir=1;\n    if(s[y][x]=='^')ndir=0;\n    if(s[y][x]=='v')ndir=2;\n    if(s[y][x]=='_'){\n      if(!mem)ndir=1;\n      else ndir=3;\n    }\n    if(s[y][x]=='|'){\n      if(!mem)ndir=2;\n      else ndir=0;\n    }\n    if('0'<=s[y][x]&&s[y][x]<='9')\n      nmem=s[y][x]-'0';\n    if(s[y][x]=='+')\n      nmem=(mem+1)%16;\n    if(s[y][x]=='-')\n      nmem=(mem+15)%16;\n    if(s[y][x]=='?'){\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(ny<0||nx<0||N<=ny||N<=nx){\n\t  if(ny<0)ny=19;\n\t  if(nx<0)nx=19;\n\t  if(N<=ny)ny=0;\n\t  if(N<=nx)nx=0;\n\t}\n\tq.push(P1(P(ny,nx),P(ndir,nmem)));\n      }\n    }else{\n      int ny=y+dy[ndir];\n      int nx=x+dx[ndir];\n      if(ny<0||nx<0||N<=ny||N<=nx){\n\tif(ny<0)ny=19;\n\tif(nx<0)nx=19;\n\tif(N<=ny)ny=0;\n\tif(N<=nx)nx=0;\n      }\n      q.push(P1(P(ny,nx),P(ndir,nmem)));\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++)cin>>s[i];\n  if(bfs())cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) FOR(i, 0, n)\n\nusing namespace std;\n\nint visit[20][20][16][4];\nchar field[20][20];\nconst int N = 16;\nint w, h;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nstruct state{\n\tint x, y, mem, dir;\n\tstate(int x, int y, int m, int d):x(x), y(y), mem(m), dir(d){}\n};\n\nvoid move(state &s){\n\ts.x = (s.x + dx[s.dir] + w)%w;\n\ts.y = (s.y + dy[s.dir] + h)%h;\n}\n\nvoid operate(state &s, char x){\n\trep(i, 4){\n\t\tif(x == \"<>^v\"[i]){\n\t\t\ts.dir = i;\n\t\t\treturn;\n\t\t}\n\t}\n\n\trep(i, 2){\n\t\tif(x == \"_|\"[i]){\n\t\t\ts.dir = i*2;\n\t\t\tif(!s.mem) s.dir++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif('0' <= x && x <= '9'){\n\t\ts.mem = x-'0';\n\t\treturn;\n\t}\n\n\tif(x == '+'){\n\t\ts.mem++;\n\t}else if(x == '-'){\n\t\ts.mem--;\n\t}\n\ts.mem = (s.mem+N)%N;\n}\n\nint main(){\n\tcin >> h >> w;\n\trep(i, h) rep(j, w) cin >> field[i][j];\n\n\tstate start(0, 0, 0, 1);\n\tbool ans = false;\n\tqueue<state> q;\n\tq.push(start);\n\twhile(!q.empty()){\n\t\tstate s = q.front();\n\t\tq.pop();\n\n\t\tif(visit[s.y][s.x][s.mem][s.dir]) continue;\n\t\tvisit[s.y][s.x][s.mem][s.dir] = 1;\n\n\t\t//cout << s.x << ' ' << s.y << ' ' << s.mem << ' ' << \"LRUD\"[s.dir] << endl;\n\n\t\tif(field[s.y][s.x] == '@'){\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(field[s.y][s.x] == '?'){\n\t\t\trep(i, 4){\n\t\t\t\tstate next = s;\n\t\t\t\tnext.dir = i;\n\t\t\t\tmove(next);\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}else{\n\t\t\toperate(s, field[s.y][s.x]);\n\t\t\tmove(s);\n\t\t\tq.push(s);\n\t\t}\n\t}\n\tcout << (ans?\"YES\":\"NO\") << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDirBits;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=(1<<_dir);\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    dir = 0;\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],const vector<P>& goals){\n  if(goals.size() == 0) return false;\n  for(int i = 0; i < goals.size();i++){\n    for(int mem=0;mem<=15;mem++){\n      for(int dir=0;dir<4;dir++){\n\tint gx = goals[i].first;\n\tint gy = goals[i].second;\n\tif(visited[gx][gy][mem][dir]) return true;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    memset(visited,0,sizeof(visited));\n\n    vector<P> goals;\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  goals.push_back(P(x,y));\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM next_dir_mem = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(next_dir_mem.mDirBits & (1<<dir))) continue;\n\tint dx = (tx[dir] + x + W) % W;\n\tint dy = (ty[dir] + y + H) % H;\n\n\tif(visited[dx][dy][next_dir_mem.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,next_dir_mem.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][next_dir_mem.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,goals) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\nenum dir{\n  Dup = 0,\n  Dright = 1,\n  Ddown = 2,\n  Dleft = 3\n};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nbool memo[16][4][20][20];\n\nvector<string> g;\nint r, c;\n\nbool solve(int m, int d, int y, int x){\n  if(memo[m][d][y][x]) return false;\n  memo[m][d][y][x] = true;\n\n  switch(g[y][x]){\n  case '<':\n    d = Dleft;\n    break;\n  case '>':\n    d = Dright;\n    break;\n  case '^':\n    d = Dup;\n    break;\n  case 'v':\n    d = Ddown;\n    break;\n  case '_':\n    if(m == 0) d = Dright;\n    else d = Dleft;\n    break;\n  case '|':\n    if(m == 0) d = Ddown;\n    else d = Dup;\n    break;\n  case '?':\n    REP(i,4){\n      int xx = (x + c + _dx[i]) % c;\n      int yy = (y + r + _dy[i]) % r;\n      if(solve(m, i, yy, xx)) return true;\n    }\n    return false;\n  case '.':\n    break;\n  case '@':\n    return true;\n    break;\n  case '+':\n    m = (m + 1) % 16;\n    break;\n  case '-':\n    m = (m + 16 - 1) % 16;\n    break;\n  default:\n    if(!isdigit(g[y][x])){\n      printf(\"error %c\\n\", g[y][x]);\n      exit(0);\n    }\n    m = g[y][x] - '0';\n    break;\n  }\n\n  x = (x + c + _dx[d]) % c;\n  y = (y + r + _dy[d]) % r;\n\n  return solve(m, d, y, x);\n}\n\nint main(){\n  cin >> r >> c;\n\n  g = vector<string>(r);\n  REP(i,r) cin>>g[i];\n\n  puts(solve(0, Dright, 0, 0) ? \"YES\" : \"NO\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\nint r, c;\nchar a[21][21];\nbool vis[22][22][17][5];\n\nint xdir[4] = {1, 0, -1, 0}, ydir[4] = {0, 1, 0, -1};\nbool dfs(int x, int y, int m, int d)\n{\n  if(!vis[y][x][m][d]) return false;\n  vis[y][x][m][d] = false;\n\n  char ch = a[y][x];\n  int nm = m, nd = d, dx, dy; \n\n  if(ch == '@') return true;\n  else if(ch == '<') nd = 2;\n  else if(ch == '>') nd = 0;\n  else if(ch == '^') nd = 3;\n  else if(ch == 'v') nd = 1;\n  else if(ch == '|') nd = (nm == 0)? 1 : 3;\n  else if(ch == '_') nd = (nm == 0)? 0 : 2;\n  else if(ch == '+') nm = (nm+1)%15;\n  else if(ch == '-') nm = (m == 0)? 15 : (m-1);\n  else if(isdigit(ch)) nm = (int)(ch-'0');\n  \n  if(ch == '?'){\n    for(int i = 0; i < 4; i++){\n      dx = x+xdir[i], dy = y+ydir[i];\n      if(dx < 0) dx = c-1;\n      if(dx >= c) dx = 0;\n      if(dy < 0) dy = r-1;\n      if(dy >= r) dy = 0;\n\n      if(dfs(dx, dy, nm, i)) return true;\n    }\n\n    return false;\n  }\n  \n  dx = x+xdir[nd], dy = y+ydir[nd];\n  if(dx < 0) dx = c-1;\n  if(dx >= c) dx = 0;\n  if(dy < 0) dy = r-1;\n  if(dy >= r) dy = 0;\n  \n  return dfs(dx, dy, nm, nd);\n}\n\nint main()\n{\n  while(cin>>r>>c && (r+c)){\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++) cin >> a[i][j];\n\n    fill(&vis[0][0][0][0], &vis[21][21][16][4], true);\n\n    cout << ((dfs(0, 0, 0, 0))? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef struct{\n  int MEM,MUKI;\n  int used[22][22];\n  int x,y;\n}P;\nchar mas[22][22];\nint R,C,dx[]={0,-1,0,1},dy[]={1,0,-1,0}; //右上左下\nint flg;\nvoid dfs(P p);\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++){\n    for(int j=0;j<C;j++){\n      cin >> mas[i][j];\n    }\n  }\n  flg=0;\n  P p;\n  p.MEM=0;   p.x=0;\n  p.MUKI=0;  p.y=-1;\n  memset(p.used,0,sizeof(p.used));\n  dfs(p);\n  cout << (flg>0?\"NO\":\"YES\") << endl;\n}\nvoid dfs(P p){\n  queue<P> que;\n  que.push(p);\n    P HM = que.front();\n  while(!que.empty()){\n\n    HM.x+=dx[HM.MUKI];\n    HM.y+=dy[HM.MUKI];\n    if(HM.x<0)HM.x=R-1;\n    else if(HM.x>=R)HM.x=0;\n    else if(HM.y<0)HM.y=C-1;\n    else if(HM.y>=C)HM.y=0;\n    if(HM.used[HM.x][HM.y]==5){\n      flg++;\n      que.pop();\n      if(que.empty())return;\n      else{\n\tHM=que.front();\n\tque.pop();\n      }\n    } else{\n      HM.used[HM.x][HM.y]++;\n      if(mas[HM.x][HM.y]=='?'){\n\tfor(int i=0;i<4;i++){\n\t  P HMHM=HM;\n\t  HMHM.MUKI=i;\n\t  memset(HMHM.used,0,sizeof(HMHM.used));\n\t  que.push(HMHM);\n\t}\n      }else if(mas[HM.x][HM.y]=='@'){\n\tflg = -1000;\n\treturn;\n      }else if(mas[HM.x][HM.y]=='_'){\n\tHM.MEM == 0 ? HM.MUKI=0 : HM.MUKI=2;\n      }else if(mas[HM.x][HM.y]=='|'){\n\tHM.MEM == 0 ? HM.MUKI=3 : HM.MUKI=1;\n      }else if(mas[HM.x][HM.y]=='+'){\n\tHM.MEM == 15 ? HM.MEM=0 : HM.MEM++;\n      }else if(mas[HM.x][HM.y]=='-'){\n\tHM.MEM == 0 ? HM.MEM=15 : HM.MEM--;\n      }else if(mas[HM.x][HM.y]>='0'&&mas[HM.x][HM.y]<='9'){\n\tHM.MEM = mas[HM.x][HM.y]-'0';\n      }else if(mas[HM.x][HM.y]=='.'){\n\n      }else if(mas[HM.x][HM.y]=='<'){\n\tHM.MUKI= 2;\n      }else if(mas[HM.x][HM.y]=='^'){\n\tHM.MUKI= 1;\n      }else if(mas[HM.x][HM.y]=='>'){\n\tHM.MUKI= 0;\n      }else if(mas[HM.x][HM.y]=='v'){\n\tHM.MUKI= 3;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\n#define FOR(i,n) for(i=0;i<n;i++)\n\nint s[30][30][4][100];\nchar mp[30][30];\n\nstruct ob{int a,b,c,d;};\nstack<ob> o;\nint r,c;\n\nvoid f(ob tmp){\n\tif(tmp.a<0)tmp.a+=c;\n\tif(tmp.a>=c)tmp.a-=c;\n\tif(tmp.b<0)tmp.b+=r;\n\tif(tmp.b>=r)tmp.b-=r;\n\tif(tmp.d>='0'+16)tmp.d-=16;\n\tif(tmp.d<'0')tmp.d+=16;\n\t\n\tif(s[tmp.a][tmp.b][tmp.c][tmp.d]==0){\n\t\ts[tmp.a][tmp.b][tmp.c][tmp.d]=1;\n\t\to.push(tmp);\n\t}\n}\n\nint main(){\n\tbool fr=false;\n\tcin>>r>>c;\n\tint i,j;\n\tfor(j=0;j<r;j++){\n\t\tfor(i=0;i<c;i++){\n\t\t\tcin>>mp[i][j];\n\t\t}\n\t}\n\tob k;\n\tk.a=0;k.b=0;k.c=0;k.d='0'<=mp[0][0]&&'9'>=mp[0][0]?mp[0][0]:'0';\n\to.push(k);\n\ts[0][0][0][k.d]=1;\n\twhile(!o.empty()){\n\t\tob tmp=o.top();\n\t\to.pop();\n\t\tif(mp[tmp.a][tmp.b]=='<'){\n\t\t\ttmp.a--;\n\t\t\tif(tmp.a<0)tmp.a+=c;\n\t\t\ttmp.c=2;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='>'){\n\t\t\ttmp.a++;\n\t\t\tif(tmp.a>=c)tmp.a-=c;\n\t\t\ttmp.c=0;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='^'){\n\t\t\ttmp.b--;\n\t\t\tif(tmp.b<0)tmp.b+=r;\n\t\t\ttmp.c=3;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='v'){\n\t\t\ttmp.b++;\n\t\t\tif(tmp.b>r)tmp.b+=r;\n\t\t\ttmp.c=1;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='_'){\n\t\t\tif(tmp.d=='0'){\n\t\t\t\ttmp.a++;\n\t\t\t\tif(tmp.a>=c)tmp.a-=c;\n\t\t\t\ttmp.c=0;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}else{\n\t\t\t\ttmp.a--;\n\t\t\t\tif(tmp.a<0)tmp.a+=c;\n\t\t\t\ttmp.c=2;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='|'){\n\t\t\tif(tmp.d=='0'){\n\t\t\t\ttmp.b++;\n\t\t\t\tif(tmp.b>=r)tmp.b-=r;\n\t\t\t\ttmp.c=1;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}else{\n\t\t\t\ttmp.b--;\n\t\t\t\tif(tmp.b<0)tmp.b+=r;\n\t\t\t\ttmp.c=3;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='?'){\n\t\t\tob tp=tmp;\n\t\t\ttmp.a--;\n\t\t\tif(tmp.a<0)tmp.a+=c;\n\t\t\ttmp.c=2;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t\ttmp=tp;\n\t\t\ttmp.a++;\n\t\t\tif(tmp.a>=c)tmp.a-=c;\n\t\t\ttmp.c=0;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t\ttmp=tp;\n\t\t\t\ttmp.b--;\n\t\t\tif(tmp.b<0)tmp.b+=r;\n\t\t\ttmp.c=3;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t\ttmp=tp;\n\t\t\t\ttmp.b++;\n\t\t\tif(tmp.b>=r)tmp.b-=r;\n\t\t\ttmp.c=1;\n\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\tf(tmp);\n\t\t}else if((mp[tmp.a][tmp.b]=='.')||('0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b])){\n\t\t\tif(tmp.c==0){\n\t\t\t\ttmp.a++;\n\t\t\t\tif(tmp.a>=c)tmp.a-=c;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}else if(tmp.c==1){\n\t\t\t\ttmp.b++;\n\t\t\t\tif(tmp.b>=r)tmp.b-=r;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}else if(tmp.c==2){\n\t\t\t\ttmp.a--;\n\t\t\t\tif(tmp.a<0)tmp.a+=c;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}else if(tmp.c==3){\n\t\t\t\ttmp.b--;\n\t\t\t\tif(tmp.b<0)tmp.b+=r;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d;\n\t\t\t}\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='@'){\n\t\t\tfr=true;\n\t\t\tbreak;\n\t\t}else if(mp[tmp.a][tmp.b]=='+'){\n\t\t\tif(tmp.c==0){\n\t\t\t\ttmp.a++;\n\t\t\t\tif(tmp.a>=c)tmp.a-=c;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d+1;\n\t\t\t}else if(tmp.c==1){\n\t\t\t\ttmp.b++;\n\t\t\t\tif(tmp.b>=r)tmp.b-=r;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d+1;\n\t\t\t}else if(tmp.c==2){\n\t\t\t\ttmp.a--;\n\t\t\t\tif(tmp.a<0)tmp.a+=c;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d+1;\n\t\t\t}else if(tmp.c==3){\n\t\t\t\ttmp.b--;\n\t\t\t\tif(tmp.b<0)tmp.b+=r;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d+1;\n\t\t\t}\n\t\t\tf(tmp);\n\t\t}else if(mp[tmp.a][tmp.b]=='-'){\n\t\t\tif(tmp.c==0){\n\t\t\t\ttmp.a++;\n\t\t\t\tif(tmp.a>=c)tmp.a-=c;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d-1;\n\t\t\t}else if(tmp.c==1){\n\t\t\t\ttmp.b++;\n\t\t\t\tif(tmp.b>=r)tmp.b-=r;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d-1;\n\t\t\t}else if(tmp.c==2){\n\t\t\t\ttmp.a--;\n\t\t\t\tif(tmp.a<0)tmp.a+=c;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d-1;\n\t\t\t}else if(tmp.c==3){\n\t\t\t\ttmp.b--;\n\t\t\t\tif(tmp.b<0)tmp.b+=r;\n\t\t\t\ttmp.d='0'<=mp[tmp.a][tmp.b]&&'9'>=mp[tmp.a][tmp.b]?mp[tmp.a][tmp.b]:tmp.d-1;\n\t\t\t}\n\t\t\tf(tmp);\n\t\t}\n\t}\n\tcout<<(fr?\"YES\\n\":\"NO\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n#define pb(e) push_back(e)\n\ntypedef long long ll;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n    int r, c;\n    string prog[20];\n    cin >> r >> c;\n    rep(i, r) cin >> prog[i];\n    \n    int x = 0, y = 0, dir = 0, mem = 0;\n    rep(i, 10000000) {\n        switch(prog[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem == 0 ? 0 : 2); break;\n            case '|': dir = (mem == 0 ? 1 : 3); break;\n            case '?': dir = rand() & 3; break;\n            case '.': break;\n            case '@': cout << \"YES\" << endl; return 0;\n            case '+': mem = (mem + 1) & 15; break;\n            case '-': mem = (mem - 1) & 15; break;\n            default:  mem = prog[y][x] - '0';\n        }\n        x += dx[dir]; y += dy[dir];\n        if(x == -1) x = c - 1;\n        if(x == c) x = 0;\n        if(y == -1) y = r - 1;\n        if(y == r) y = 0;\n    }\n    cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nstruct S{\n  int x,y,r,m;\n  S(int x,int y,int r,int m) :\n    x(x),y(y),r(r),m(m) {}\n  bool operator < (const S& s) const {\n    return (x!=s.x)?(x<s.x):(y!=s.y)?(y<s.y):(r!=s.r)?(r<s.r):(m<s.m);\n  }\n};\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main(){\n  int h,w;\n  while(cin>>h>>w){\n    vector<string> grid(h);\n    REP(i,h)cin>>grid[i];\n    queue<S> que;\n    set<S> used;\n    que.push(S(0,0,0,0));\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(used.find(s)!=used.end()) continue;\n      used.insert(s);\n      bool all = false;\n      bool end = false;\n      switch(grid[s.y][s.x]){\n        case '<':\n          s.r = 2;\n          break;\n        case '>':\n          s.r = 0;\n          break;\n        case '^':\n          s.r = 3;\n          break;\n        case 'v':\n          s.r = 1;\n          break;\n        case '_':\n          s.r = ((s.m)?2:0);\n          break;\n        case '|':\n          s.r = ((s.m)?3:1);\n          break;\n        case '?':\n          all = true;\n          break;\n        case '.':\n          break;\n        case '@':\n          end = true;\n          break;\n        case '+':\n          s.m = (s.m+1)%16;\n          break;\n        case '-':\n          s.m = (s.m+16-1)%16;\n          break;\n      }\n      if(end){\n        cout<<\"YES\"<<endl;\n        goto END;\n      }\n      if(grid[s.y][s.x]<='9'&&grid[s.y][s.x]>='0'){\n        s.m = (grid[s.y][s.x]-'0');\n      }\n      for(int r = 0; r < 4; r++){\n        if(all || s.r == r){\n          int nx = (s.x+dx[r])%w;\n          int ny = (s.y+dy[r])%h;\n          que.push(S(nx,ny,r,s.m));\n        }\n      }\n    }\n    cout<<\"NO\"<<endl;  \nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <sstream>\n#include <stdlib.h>\n#include <string>\n\nusing namespace std;\n\nbool flag = 0;\nbool data[20][20][16][4] = {0};\nstring inp[20];\nint R, C;\n\n\nvoid dfs(int x, int y, int m, int d){\n  if(x == C){\n    x = 0;\n  } else if (x == -1){\n    x = C-1;\n  }\n\n  if(y == R){\n    y = 0;\n  } else if (y == -1){\n    y = R-1;\n  }\n\n  if(data[x][y][m][d] == 1) {\n    return;\n  } else{\n    data[x][y][m][d] = 1;\n  }\n\n  if(inp[y][x] == '@'){\n    flag = 1;\n  }\n\n  if('0' <= inp[y][x] && inp[y][x] <= '9'){\n    if(d==0){\n      dfs(x-1, y, inp[y][x]-'0', d);\n    }else if(d==1){\n      dfs(x+1, y, inp[y][x]-'0', d);\n    }else if(d==2){\n      dfs(x, y-1, inp[y][x]-'0', d);\n    }else {\n      dfs(x, y+1, inp[y][x]-'0', d);\n    }\n  } else if (inp[y][x] == '_'){\n    if(m==0){\n      dfs(x+1, y, m, 1);\n    } else {\n      dfs(x-1, y, m, 0);\n    }\n  } else if (inp[y][x] == '|'){\n    if(m == 0){\n      dfs(x, y+1, m, 3);\n    } else {\n      dfs(x, y-1, m, 2);\n    }\n  } else if (inp[y][x] == '.'){\n    if(d == 0) {\n      dfs(x-1, y, m, d);\n    } else if (d == 1){\n      dfs(x+1, y, m, d);\n    } else if (d == 2){\n      dfs(x, y-1, m, d);\n    } else {\n      dfs(x, y+1, m, d);\n    }\n  } else if (inp[y][x] == '<') {\n    dfs(x-1, y, m, 0);\n  } else if (inp[y][x] == '>'){\n    dfs(x+1, y, m, 1);\n  } else if (inp[y][x] == '^'){\n    dfs(x, y-1, m, 2);\n  } else if (inp[y][x] == 'v'){\n    dfs(x, y+1, m, 3);\n  } else if (inp[y][x] == '?'){\n    dfs(x-1, y, m, 0);\n    dfs(x+1, y, m, 1);\n    dfs(x, y-1, m, 2);\n    dfs(x, y+1, m, 3);\n  } else if(inp[y][x] == '+'){\n    if(m == 15){\n      if(d == 0){\n        dfs(x-1, y, 0, d);\n      } else if (d == 1){\n        dfs(x+1, y, 0, d);\n      } else if (d == 2){\n        dfs(x, y-1, 0, d);\n      } else if (d == 3){\n        dfs(x, y+1, 0, d);\n      }\n    } else {\n      if(d == 0){\n        dfs(x-1, y, m+1, d);\n      } else if (d == 1){\n        dfs(x+1, y, m+1, d);\n      } else if (d == 2){\n        dfs(x, y-1, m+1, d);\n      } else if (d == 3){\n        dfs(x, y+1, m+1, d);\n      }\n    }\n  } else if (inp[y][x] == '-'){\n    if(m == 0){\n      if(d == 0){\n        dfs(x-1, y, 15, d);\n      } else if (d == 1){\n        dfs(x+1, y, 15, d);\n      } else if (d == 2){\n        dfs(x, y-1, 15, d);\n      } else if (d == 3){\n        dfs(x, y+1, 15, d);\n      }\n    } else {\n      if(d == 0){\n        dfs(x-1, y, m-1, d);\n      } else if (d == 1){\n        dfs(x+1, y, m-1, d);\n      } else if (d == 2){\n        dfs(x, y-1, m-1, d);\n      } else if (d == 3){\n        dfs(x, y+1, m-1, d);\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> R >> C;\n\n  for(int i = 0;i < R;i++){\n    cin >> inp[i];\n  }\n\n  dfs(0, 0, 0, 1);\n\n  if(flag == 1){\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconst int dy[] = { 0, 1, 0, -1 };\nconst int dx[] = { 1, 0, -1, 0 };\nint main() {\n    // input\n    int h, w; cin >> h >> w;\n    vector<string> code(h);\n    REP (y, h) cin >> code[y];\n    // solve\n    auto used = vectors(h, w, array<bitset<16>, 4>());\n    function<bool (int, int, int, int)> go = [&](int y, int x, int dir, int mem) {\n        y = (y + h) % h;\n        x = (x + w) % w;\n        if (used[y][x][dir][mem]) return false;\n        used[y][x][dir][mem] = true;\n        switch (code[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem ? 2 : 0); break;\n            case '|': dir = (mem ? 3 : 1); break;\n            case '?': {\n                REP (dir, 4) {\n                    if (go(y + dy[dir], x + dx[dir], dir, mem)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            case '.': break;\n            case '@': return true;\n            case '+': mem = (mem +  1) % 16; break;\n            case '-': mem = (mem + 15) % 16; break;\n            default: assert (isdigit(code[y][x])); mem = code[y][x] - '0'; break;\n        }\n        return go(y + dy[dir], x + dx[dir], dir, mem);\n    };\n    bool halt = go(0, 0, 0, 0);\n    // output\n    cout << (halt ? \"YES\" : \"NO\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool used[30][30][4][16];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s[30];\nint h,w;\nvoid END(){\n  cout<<\"YES\"<<endl;\n  exit(0);\n}\nvoid dfs(int x,int y,int d,int m){\n  while(1){\n    if(s[y][x]=='<'){d=3;}\n    else if(s[y][x]=='>'){d=1;}\n    else if(s[y][x]=='^'){d=0;}\n    else if(s[y][x]=='v'){d=2;}\n    else if(s[y][x]=='_'){\n      if(m)d=3;\n      else d=1;\n    }\n    else if(s[y][x]=='|'){\n      if(m)d=0;\n      else d=2;\n    }\n    else if(s[y][x]=='?'){\n      r(i,4)dfs(x,y,i,m);\n    }\n    else if(s[y][x]=='.'){}\n    else if(s[y][x]=='@'){END();}\n    else if(s[y][x]=='-'){m=(m-1+16)%16;}\n    else if(s[y][x]=='+'){m=(m+1)%16;}\n    else if(isdigit(s[y][x])){m=s[y][x]-'0';}\n    if(used[y][x][d][m])return ;\n    used[y][x][d][m]=1;\n    x+=dx[d];\n    y+=dy[d];\n    x+=w;\n    y+=h;\n    x%=w;\n    y%=h;\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  dfs(0,0,1,0);\n  cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint r,c;\nchar f[22][22];\nbool used[22][22][5][22];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nbool solve(int x,int y,int a,int m){\n  if(x < 0) x = c-1;\n  if(c <= x) x = 0;\n  if(y < 0) y = r-1;\n  if(r <= y) y = 0;\n  if(m < 0) m = 15;\n  if(15 < m) m = 0;\n  if(used[x][y][a][m]) return false;\n  used[x][y][a][m] = true;\n  switch(f[x][y]){\n  case '@': return true;\n  case '>': return solve(x+dx[0],y+dy[0],0,m);\n  case '<': return solve(x+dx[1],y+dy[1],1,m);\n  case 'v': return solve(x+dx[2],y+dy[2],2,m);\n  case '^': return solve(x+dx[3],y+dy[3],3,m);\n  case '.': return solve(x+dx[a],y+dy[a],a,m);\n  case '+': return solve(x+dx[a],y+dy[a],a,m+1);\n  case '-': return solve(x+dx[a],y+dy[a],a,m-1);\n  case '_': return solve(x+dx[m?1:0],y+dy[m?1:0],m?1:0,m);\n  case '|': return solve(x+dx[m?3:2],y+dy[m?3:2],m?3:2,m);\n  case '?': for(int i = 0; i <4; i++)if(solve(x+dx[i],y+dy[i],i,m))return true; return false;\n  default : return solve(x+dx[a],y+dy[a],a,f[x][y]-'0');\n  }\n}\n\nint main(void){\n  cin >> r >> c;\n  for(int y = 0; y < r; y++){\n    for(int x = 0; x < c; x++){\n      cin >> f[x][y];\n    }\n  }\n  if(solve(0,0,0,0)){\n    cout << \"YES\" << endl;\n  }else{\n    cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Stat{\n\tint x,y,dir,mem;\n\tStat(){}\n\tStat(int X,int Y,int D,int M):x(X),y(Y),dir(D),mem(M){}\n};\n\nvoid update(int &x,int &y,int dir,int r,int c){\n\tx=(x+dx[dir]+c)%c;\n\ty=(y+dy[dir]+r)%r;\n}\n\nint main(){\n\tint r,c; scanf(\"%d%d\",&r,&c);\n\tchar prog[20][21];\n\trep(i,r) scanf(\"%s\",prog[i]);\n\n\tbool end=false;\n\tbool visited[20][20][4][16]={};\n\tqueue<Stat> qu; qu.push(Stat(0,0,0,0));\n\twhile(!qu.empty()){\n\t\tStat s=qu.front(); qu.pop();\n\t\tint x=s.x,y=s.y,dir=s.dir,mem=s.mem;\n\n\t\tif(visited[x][y][dir][mem]) continue;\n\t\tvisited[x][y][dir][mem]=true;\n\n\t\tif(prog[y][x]=='@'){ end=true; break; }\n\n\t\tswitch(prog[y][x]){\n\t\t\tcase '<':\n\t\t\t\tdir=2;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tdir=0;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '^':\n\t\t\t\tdir=1;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tdir=3;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '_':\n\t\t\t\tif(mem==0) dir=0;\n\t\t\t\telse       dir=2;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '|':\n\t\t\t\tif(mem==0) dir=3;\n\t\t\t\telse       dir=1;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '?':\n\t\t\t\tfor(dir=0;dir<4;dir++){\n\t\t\t\t\tint xx=x,yy=y;\n\t\t\t\t\tupdate(xx,yy,dir,r,c);\n\t\t\t\t\tqu.push(Stat(xx,yy,dir,mem));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '.':\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '0': case '1': case '2': case '3': case '4':\n\t\t\tcase '5': case '6': case '7': case '8': case '9':\n\t\t\t\tmem=prog[y][x]-'0';\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '+':\n\t\t\t\tmem=(mem+1)%16;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\n\t\t\tcase '-':\n\t\t\t\tmem=(mem-1+16)%16;\n\t\t\t\tupdate(x,y,dir,r,c);\n\t\t\t\tqu.push(Stat(x,y,dir,mem));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tputs(end?\"YES\":\"NO\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint r,c;\nstring str[22];\nstring str2[22];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool visited[22][22][4][17];\n\nbool dfs(int x,int y,int d,int m){\n\tif(visited[x][y][d][m])return false;\n\tvisited[x][y][d][m]=true;\n\t//printf(\"%d %d %d %d\\n\",x,y,d,m);\n\tif(str[x][y]=='@')return true;\n\tif(str[x][y]=='>')d=0;\n\tif(str[x][y]=='<')d=2;\n\tif(str[x][y]=='^')d=3;\n\tif(str[x][y]=='v')d=1;\n\tif(str[x][y]=='_'){\n\t\tif(m==0)d=0;\n\t\tif(m!=0)d=2;\n\t}\n\tif(str[x][y]=='|'){\n\t\tif(m==0)d=1;\n\t\tif(m!=0)d=3;\n\t}\n\tif(str[x][y]>='0' && str[x][y]<='9')m=str[x][y]-'0';\n\tif(str[x][y]=='+')m=(m+1)%16;\n\tif(str[x][y]=='-')m=(m+15)%16;\n\tif(str[x][y]=='?'){\n\t\tbool ch=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(dfs((x+dx[i]+c)%c,(y+dy[i]+r)%r,i,m))ch=true;\n\t\t}\n\t\treturn ch;\n\t}else{\n\t\treturn dfs((x+dx[d]+c)%c,(y+dy[d]+r)%r,d,m);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tstr2[i]=str[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tstr[j][i]=str2[i][j];\n\t\t}\n\t}\n\tmemset(visited,false,sizeof(visited));\n\tprintf(\"%s\\n\",dfs(0,0,0,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<queue>\nstruct S{int x,y,m,a;};\nint R,C,d[]={0,1,0,-1,0},f[20][20][16][4];\nchar M[20][21];\nint F()\n{\n\tS s={0,0,0,1},t;\n\tstd::queue<S>q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\ts=q.front();q.pop();\n\t\ts.x=(s.x+C)%C;\n\t\ts.y=(s.y+R)%R;\n\t\tif(f[s.x][s.y][s.m][s.a]++)continue;\n\t\tchar c=M[s.y][s.x];\n\t\tif(c=='@')return 1;\n\t\tif(c=='?')\n\t\t{\n\t\t\tfor(int i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tt=s;\n\t\t\t\tt.x+=d[i];t.y+=d[i+1];t.a=i;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t\tif(isdigit(c))s.m=c-'0';\n\t\tif(c=='^')s.a=0;\n\t\tif(c=='>')s.a=1;\n\t\tif(c=='v')s.a=2;\n\t\tif(c=='<')s.a=3;\n\t\tif(c=='_')s.a=(s.m?3:1);\n\t\tif(c=='|')s.a=(s.m?2:0);\n\t\tif(c=='+')s.m=(s.m+1)%16;\n\t\tif(c=='-')s.m=(s.m+15)%16;\n\t\ts.x+=d[s.a];\n\t\ts.y+=d[s.a+1];\n\t\tq.push(s);\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&R,&C);\n\tfor(int i=0;i<R;++i)scanf(\"%s\",M[i]);\n\treturn puts(F()?\"YES\":\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint r,c,d;\nint h,w;\nbool table[20][20][16][4];\n\nvoid move(void){\n  if(d == 0){\n    w++;\n    if(w == c)w = 0;\n  }\n  else if(d == 2){\n    w--;\n    if(w < 0)w = c-1;\n  }\n  else if(d == 3){\n    h--;\n    if(h < 0)h = r-1;\n  }\n  else if(d == 1){\n    h++;\n    if(h == r)h = 0;\n  }\n}\n\nbool check(int h,int w,int m,int l){\n  if(table[h][w][m][l])return false;\n  else table[h][w][m][l] = true;\n  return true;\n}\n\nint main(){\n  string tmp;\n  vector<string> map;\n  int m,pos,flag;\n  vector<int> qh,qw,qm,qd;\n\n  m = 0;\n  d = 0;\n  h = 0;\n  w = 0;\n\n  cin >> r >> c;\n\n  for(int i=0;i<r;i++){\n    cin >> tmp;\n    map.push_back(tmp);\n  }\n\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++){\n      for(int k=0;k<16;k++){\n\tfor(int l=0;l<4;l++)table[i][j][k][l] = false;\n      }\n    }\n  }\n\n  qh.clear();\n  qw.clear();\n  qm.clear();\n  qd.clear();\n  pos = 0;\n\n  while(1){\n    if(!check(h,w,m,d)){\n      if(pos == qh.size()){\n\tcout << \"NO\" << endl;\n\treturn 0;\n      }else{\n\th = qh[pos];\n\tw = qw[pos];\n\tm = qm[pos];\n\td = qd[pos];\n\tpos++;\n      }\n    }\n\n    if(map[h][w] == '@'){\n      cout << \"YES\" << endl;\n      return 0;\n    }else if(map[h][w] == '>'){\n      d = 0;\n    }else if(map[h][w] == 'v'){\n      d = 1;\n    }else if(map[h][w] == '<'){\n      d = 2;\n    }else if(map[h][w] == '^'){\n      d = 3;\n    }else if(map[h][w] == '_'){\n      if(m)d = 2;\n      else d = 0;\n    }else if(map[h][w] == '|'){\n      if(m)d = 3;\n      else d = 1;\n    }else if(map[h][w] == '+'){\n      m++;\n      if(m == 16)m = 0;\n    }else if(map[h][w] == '-'){\n      m--;\n      if(m < 0)m = 15;\n    }else if(map[h][w] == '?'){\n      flag = 1;\n      for(int i=0;i<qh.size();i++){\n\tif(h == qh[i] && w == qw[i] && m == qm[i]){\n\t  flag = 0;\n\t  break;\n\t}\n      }\n      if(flag){\n\td = 0;\n\tqh.push_back(h);\n\tqw.push_back(w);\n\tqm.push_back(m);\n\tqd.push_back(1);\n\n\tqh.push_back(h);\n\tqw.push_back(w);\n\tqm.push_back(m);\n\tqd.push_back(2);\n\n\tqh.push_back(h);\n\tqw.push_back(w);\n\tqm.push_back(m);\n\tqd.push_back(3);\n      }\n    }else if(map[h][w] == '.'){\n    }else{\n      m = map[h][w] - '0';\n    }\n\n    move();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef struct{\n  int MEM,MUKI;\n  int used[22][22];\n  int x,y;\n}P;\nchar mas[22][22];\nint R,C,dx[]={0,-1,0,1},dy[]={1,0,-1,0}; //右上左下\nint flg;\nvoid dfs(P p);\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++){\n    for(int j=0;j<C;j++){\n      cin >> mas[i][j];\n    }\n  }\n  flg=0;\n  P p;\n  p.MEM=0;   p.x=0;\n  p.MUKI=0;  p.y=-1;\n  memset(p.used,0,sizeof(p.used));\n  dfs(p);\n  cout << (flg>0?\"NO\":\"YES\") << endl;\n}\nvoid dfs(P p){\n  queue<P> que;\n  que.push(p);\n    P HM = que.front();\n  while(!que.empty()){\n\n    HM.x+=dx[HM.MUKI];\n    HM.y+=dy[HM.MUKI];\n    if(HM.x<0)HM.x=R-1;\n    else if(HM.x>=R)HM.x=0;\n    else if(HM.y<0)HM.y=C-1;\n    else if(HM.y>=C)HM.y=0;\n    if(HM.used[HM.x][HM.y]==10){\n      flg++;\n      que.pop();\n      if(que.empty())return;\n      else{\n\tHM=que.front();\n\tque.pop();\n      }\n    } else{\n      HM.used[HM.x][HM.y]++;\n      if(mas[HM.x][HM.y]=='?'){\n\tfor(int i=0;i<4;i++){\n\t  P HMHM=HM;\n\t  HMHM.MUKI=i;\n\t  for(int j=0;j<22;j++){\n\t    for(int l=0;l<22;l++){\n\t      HMHM.used[j][l]=0;\n\t    }\n\t  }\n\t  que.push(HMHM);\n\t}\n      }else if(mas[HM.x][HM.y]=='@'){\n\tflg = -1000;\n\treturn;\n      }else if(mas[HM.x][HM.y]=='_'){\n\tHM.MEM == 0 ? HM.MUKI=0 : HM.MUKI=2;\n      }else if(mas[HM.x][HM.y]=='|'){\n\tHM.MEM == 0 ? HM.MUKI=3 : HM.MUKI=1;\n      }else if(mas[HM.x][HM.y]=='+'){\n\tHM.MEM == 15 ? HM.MEM=0 : HM.MEM++;\n      }else if(mas[HM.x][HM.y]=='-'){\n\tHM.MEM == 0 ? HM.MEM=15 : HM.MEM--;\n      }else if(mas[HM.x][HM.y]>='0'&&mas[HM.x][HM.y]<='9'){\n\tHM.MEM = mas[HM.x][HM.y]-'0';\n      }else if(mas[HM.x][HM.y]=='.'){\n\n      }else if(mas[HM.x][HM.y]=='<'){\n\tHM.MUKI= 2;\n      }else if(mas[HM.x][HM.y]=='^'){\n\tHM.MUKI= 1;\n      }else if(mas[HM.x][HM.y]=='>'){\n\tHM.MUKI= 0;\n      }else if(mas[HM.x][HM.y]=='v'){\n\tHM.MUKI= 3;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int R, C;\n  char prog[21][21];\n  cin >> R >> C;\n  for(int i = 0; i < R; i++){\n    for(int j = 0; j < C; j++) cin >> prog[i][j];\n  }\n  typedef pair<int, int> P;\n  typedef pair<P, P> PP;\n  bool visited[21][21][16][5];\n  memset(visited, false, sizeof(visited));\n  queue<PP> que;\n  int left = 0, right = 1, up = 2, down = 3;\n  int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\n  bool flag = false;\n  que.push(PP(P(0, 0), P(right, 0)));\n  while(!que.empty()){\n    PP p = que.front(); que.pop();\n    int x = p.first.first, y = p.first.second, d = p.second.first, mem = p.second.second;\n    if(x < 0 || C <= x || y < 0 || R <= y){\n      x = (x + C) % C;\n      y = (y + R) % R;\n    }\n    if(visited[x][y][d][mem]) continue;\n    visited[x][y][d][mem] = true;\n    switch(prog[y][x]){\n    case '<': que.push(PP(P(x-1, y), P(left, mem))); break;\n    case '>': que.push(PP(P(x+1, y), P(right, mem))); break;\n    case '^': que.push(PP(P(x, y-1), P(up, mem))); break;\n    case 'v': que.push(PP(P(x, y+1), P(down, mem))); break;\n    case '_': \n      if(mem == 0) que.push(PP(P(x+1, y), P(right, mem)));\n      else que.push(PP(P(x-1, y), P(left, mem)));\n      break;\n    case '|':\n      if(mem == 0) que.push(PP(P(x, y+1), P(down, mem)));\n      else que.push(PP(P(x, y-1), P(up, mem)));\n      break;\n    case '?':\n      for(int i = 0; i < 4; i++){\n\tque.push(PP(P(x+dx[i], y+dy[i]), P(i, mem)));\n      }\n      break;\n    case '+': que.push(PP(P(x+dx[d], y+dy[d]), P(d, (mem+1)%16))); break;\n    case '-': que.push(PP(P(x+dx[d], y+dy[d]), P(d, (mem+15)%16))); break;\n    case '@': flag = true; break;\n    case '.': que.push(PP(P(x+dx[d], y+dy[d]), P(d, mem))); break;\n    default:\n      que.push(PP(P(x+dx[d], y+dy[d]), P(d, prog[y][x]-'0')));\n      break;\n    }\n    if(flag) break;\n  }\n  cout << (flag ? \"YES\" : \"NO\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n#define DOWN  0\n#define RIGHT 1\n#define UP    2\n#define LEFT  3\n\nstruct State {\n  int x, y;\n  int mem;\n  int dir;\n\n  State() :\n      x(0),\n      y(0),\n      mem(0),\n      dir(RIGHT) {}\n\n  State(int x, int y, int mem, int dir) :\n      x(x),\n      y(y),\n      mem(mem),\n      dir(dir) {}\n\n  bool operator<(const State & rhs) const {\n    if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n    if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n    if (x == rhs.x) return y < rhs.y;\n    return x < rhs.x;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int R, C;\n  cin >> R >> C;\n  vector<string> prog(R);\n  rep(i, R) cin >> prog[i];\n\n  set<State> visited;\n  queue<State> Q;\n  ll ok = false;\n\n  Q.push(State());\n  while (!Q.empty()) {\n    State st = Q.front();\n    Q.pop();\n\n    st.x = (st.x + C) % C;\n    st.y = (st.y + R) % R;\n\n    if (visited.find(st) != visited.end())\n      break;\n    \n    visited.insert(st);\n\n    char p;\n    p = prog[st.y][st.x];\n\n    if (p == '@') {\n      ok = true;\n      break;\n    }\n\n    switch (p) {\n      case '0'...'9':\n        st.mem = p - '0';\n        break;\n      case '_':\n        if (st.mem == 0) st.dir = RIGHT;\n        else st.dir = LEFT;\n        break;\n      case '|':\n        if (st.mem == 0) st.dir = DOWN;\n        else st.dir = UP;\n        break;\n      case '+':\n        st.mem = (st.mem + 1) % 16;\n        break;\n      case '-':\n        st.mem = st.mem - 1;\n        if (st.mem < 0) st.mem += 16;\n        break;\n      case '^':\n        st.dir = UP;\n        break;\n      case 'v':\n        st.dir = DOWN;\n        break;\n      case '<':\n        st.dir = LEFT;\n        break;\n      case '>':\n        st.dir = RIGHT;\n        break;\n    }\n\n    if (p != '?') {\n      Q.push(State(st.x + dx[st.dir], st.y + dy[st.dir], st.mem, st.dir));\n    } else {\n      Q.push(State(st.x + dx[LEFT],   st.y + dy[LEFT],  st.mem, LEFT));\n      Q.push(State(st.x + dx[RIGHT],  st.y + dy[RIGHT], st.mem, RIGHT));\n      Q.push(State(st.x + dx[UP],     st.y + dy[UP],    st.mem, UP));\n      Q.push(State(st.x + dx[DOWN],   st.y + dy[DOWN],  st.mem, DOWN));\n    }\n  }\n  \n  if (ok) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint memc[22][22][16]={0};\nchar prog[22][22];\nint dh[5]={0,-1,0,1,0};\nint dw[5]={0,0,1,0,-1};\nint ww,hh;\nbool gogo(int h,int w,int m,int muki);\nmain(){\n  cin>>hh>>ww;\n  for(int i=1;i<=hh;i++){\n    for(int j=1;j<=ww;j++){\n      cin>>prog[i][j];\n    }\n  }\n  if(gogo(1,1,0,2)){\n    cout<<\"YES\"<<endl;\n  }\n  else{\n    cout<<\"NO\"<<endl;\n  } \n}\nbool gogo(int h,int w,int m,int muki){\n  //cout<<h<<\" \"<<w<<\" \"<<m<<\" \"<<muki<<endl;\n  if(prog[h][w]=='@'){\n    return true;\n  }\n  if(memc[h][w][m]==1){\n    return false;\n  }\n  memc[h][w][m]=1;\n  if(prog[h][w]=='^'){\n    muki=1;\n  }\n  if(prog[h][w]=='>'){\n    muki=2;\n  }\n  if(prog[h][w]=='v'){\n    muki=3;\n  }\n  if(prog[h][w]=='<'){\n    muki=4;\n  }\n  if(prog[h][w]=='_'){\n    if(m==0){\n      muki=2;\n    }\n    else{\n      muki=4;\n    }\n  }\n  if(prog[h][w]=='|'){\n    if(m==0){\n      muki=3;\n    }\n    else{\n      muki=1;\n    }\n  }\n  if(prog[h][w]>='0'&&prog[h][w]<='9'){\n    m=prog[h][w]-'0';\n  }\n  if(prog[h][w]=='+'){\n    if(m==15){\n      m=0;\n    }\n    else{\n      m++;  \n    }\n  }\n  if(prog[h][w]=='-'){\n    if(m==0){\n      m=15;\n    }\n    else{\n      m--;\n    }\n  }\n  if(prog[h][w]!='?'){\n    if(h+dh[muki]==0){\n      h=hh+1;\n    }\n    if(h+dh[muki]>hh){\n      h=0;\n    }\n    if(w+dw[muki]==0){\n      w=ww+1;\n    }\n    if(w+dw[muki]>ww){\n      w=0;\n    }\n    return gogo(h+dh[muki],w+dw[muki],m,muki);\n  }\n  else{\n    int a=0;\n    for(int i=1;i<=4;i++){\n      a+=gogo(h+dh[i],w+dw[i],m,muki);\n    }\n    if(a==0){\n      return false;\n    }\n    else{\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n\nusing namespace std;\n\nint r,c;\nchar field[30][30];\n\nconst int dy[]={0,1,0,-1};\nconst int dx[]={1,0,-1,0};\n\nint main(){\n\n  while(cin>>r>>c&&!(r==0&&c==0)){\n    bool passed[30][30][30][30];\n    memset(passed,0,sizeof(passed));\n    // 0:ツ右,1:ツ可コ,2:ツ債カ,3:ツ湘」\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++)\n\tcin>>field[i][j];\n    // ツ債カツ湘」ツつゥツづァツ開ツ始\n    int sx=0;\n    int sy=0;\n    bool isLoop=true;\n    queue<pair<pair<int,int>,pair<int,int> > > *prv\n      =new queue<pair<pair<int,int>,pair<int,int> > >();\n    queue<pair<pair<int,int>,pair<int,int> > > *nxt\n      =new queue<pair<pair<int,int>,pair<int,int > > >();\n    prv->push(make_pair(make_pair(sy,sx),make_pair(0,0)));\n    while(prv->size()){\n      while(prv->size()){\n\tpair<pair<int,int>,pair<int,int> > p=prv->front();prv->pop();\n\tint y=(p.first.first+r)%r;\n\tint x=(p.first.second+c)%c;\n\tint mem=p.second.first;\n\tint angle=p.second.second;\n\tif(passed[y][x][mem][angle])\n\t  continue;\n\tpassed[y][x][mem][angle]=true;\n\tif(field[y][x]=='@'){\n\t  isLoop=false;\n\t  break;\n\t}\n\telse if(field[y][x]=='<'){\n\t  angle=2;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='>'){\n\t  angle=0;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='^'){\n\t  angle=3;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='v'){\n\t  angle=1;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='_'){\n\t  if(mem==0)\n\t    angle=0;\n\t  else\n\t    angle=2;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='|'){\n\t  if(mem==0)\n\t    angle=1;\n\t  else\n\t    angle=3;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='?'){\n\t  for(int i = 0; i < 4; i++){\n\t    nxt->push(make_pair(make_pair(y+dy[i],x+dx[i]),make_pair(mem,i)));\n\t  }\n\t}\n\telse if(field[y][x]>='0'&&field[y][x]<='9'){\n\t  mem=field[y][x]-'0';\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='+'){\n\t  mem=(mem+1)%16;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='-'){\n\t  mem=(mem-1+16)%16;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse{\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n      }\n      if(!isLoop)\n\tbreak;\n      swap(prv,nxt);\n    }\n    if(isLoop){\n      cout<<\"NO\"<<endl;\n    }\n    else\n      cout<<\"YES\"<<endl;\n    delete prv,nxt;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  int dx[4] = { 1, -1,  0,  0 };\n  int dy[4] = { 0,  0,  1, -1 };\n\n  long long int r, c;\n  cin >> r >> c;\n\n  vector< string > p;\n\n  for ( long long int i = 0; i < r; i++ ) {\n\n    string in;\n    cin >> in;\n    p.push_back( in );\n\n  }\n\n  queue< long long int > qx, qy, qm, qd;\n  qx.push(0);\n  qy.push(0);\n  qm.push(0);\n  qd.push(0);\n\n  bool ans = false;\n\n  bool f[21][21][16][4] = {};\n\n  while( qx.size() > 0 ) {\n\n    long long int x, y, m, d;\n    x = qx.front();\n    qx.pop();\n    y = qy.front();\n    qy.pop();\n    m = qm.front();\n    qm.pop();\n    d = qd.front();\n    qd.pop();\n\n    for (;;) {\n\n      if ( p[y][x] == '>' ) {\n\td = 0;\n      }else if ( p[y][x] == '<' ) {\n\td = 1;\n      }else if ( p[y][x] == 'v' ) {\n\td = 2;\n      }else if ( p[y][x] == '^' ) {\n\td = 3;\n      }else if ( p[y][x] == '_' ) {\n\tif ( m == 0 ) {\n\t  d = 0;\n\t}else {\n\t  d = 1;\n\t}\n      }else if ( p[y][x] == '|' ) {\n\tif ( m == 0 ) {\n\t  d = 2;\n\t}else {\n\t  d = 3;\n\t}\n      }else if ( p[y][x] == '@' ) {\n\tans = true;\n\tbreak;\n      }else if ( p[y][x] == '+' ) {\n\tm++;\n\tif ( m == 16 ) m = 0;\n      }else if ( p[y][x] == '-' ) {\n\tm--;\n\tif ( m == -1 ) m = 15;\n      }else if ( p[y][x] == '.' ) {\n      }else if ( p[y][x] == '?' ) {\n\td = 0;\n\tfor ( int j = 1; j < 4; j++ ) {\n\t  int cx = ( x + dx[j] + c ) % c;\n\t  int cy = ( y + dy[j] + r ) % r;\n\t  if ( f[cy][cx][m][j] == true ) continue;\n\t  f[cy][cx][m][j] = true;\n\t  qx.push(cx);\n\t  qy.push(cy);\n\t  qm.push(m);\n\t  qd.push(j);\n\t}\n      }else {\n\tm = p[y][x] - '0';\n      }\n\n      f[y][x][m][d] = true;\n      x = ( x + dx[d] + c ) % c;\n      y = ( y + dy[d] + r ) % r;\n      if ( f[y][x][m][d] == true ) break;\n\n    }\n\n    if ( ans == true ) break;\n\n  }\n\n  if ( ans == true ) {\n    cout << \"YES\" << endl;\n  }else {\n    cout << \"NO\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  int var, x, y, dir;\n  State(int v, int _x, int _y, int d) : var(v), x(_x), y(_y), dir(d) {}\n};\n\nstring s[22];\nint row, col, dp[22][22];\n\ninline int c2dir(char c) {\n  return c == '^' ? 0 : ( c == '>' ? 1 : ( c == 'v' ? 2 : 3 ) );\n}\n\ninline int c2i(char c) { return 0 + (c - '0'); }\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nint main() {\n  cin >> row >> col;\n  rep (i,row) cin >> s[i];\n  memset(dp, 0, sizeof dp);\n  bool will_be_stopped = false;\n    \n  queue<State> q;\n  q.push(State(0, 0, 0, 1));\n\n  while (!q.empty()) {\n    State i = q.front(); q.pop();\n    if (dp[i.y][i.x] >> i.var & 1) continue;\n    dp[i.y][i.x] |= (1 << i.var);\n    char c = s[i.y][i.x];\n    //printf(\"(%d,%d:%d) -> \", i.x, i.y, i.var);\n\n    if (c == '>' || c == '<' || c == '^' || c == 'v') {\n      i.dir = c2dir(c);\n    } else if (c == '_' || c == '|') {\n      i.dir = c == '_' ? (i.var == 0 ? 1 : 3 ) : (i.var == 0 ? 2 : 0);\n      //if (c == '_') { i.dir = i.var == 0 ? 1 : 3; }\n      //else { i.dir = i.var == 0 ? 2 : 0; }\n    } else if (c == '?') {\n      rep (j,4) {\n        int tx = i.x + dx[j], ty = i.y + dy[j];\n        if (tx == -1) { tx = col-1; }\n        else if (tx == col) { tx = 0; }\n        if (ty == -1) { ty = row-1; }\n        else if (ty == row) { ty = 0; }\n        if (tx < 0 || ty < 0 || tx >= col || ty >= row) continue;\n        q.push(State(i.var, tx, ty, j));\n      }\n      continue;\n    } else if (c == '@') {\n      will_be_stopped = true; break;\n    } else if (c == '+' || c == '-') {\n      c == '+' ? i.var++ : i.var--;\n      if (i.var == -1) i.var = 15;\n      else if (i.var == 16) i.var = 0;\n    } else if (c == '.') {\n    } else if (c >= '0' && c <= '9') {\n      i.var = c2i(c);\n    }\n    \n    int nx = dx[i.dir] + i.x, ny = dy[i.dir] + i.y;\n    if (nx == -1) { nx = col-1; }\n    else if (nx == col) { nx = 0; }\n    if (ny == -1) { ny = row-1; }\n    else if (ny == row) { ny = 0; }\n    //printf(\"(%d,%d:%d)\\n\", nx, ny, i.var);\n    q.push(State(i.var, nx, ny, i.dir));\n  }\n  \n  printf(\"%s\\n\", (will_be_stopped) ? \"YES\" : \"NO\" );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\n\nchar T[22]=\"0123456789^>v<?_|.+-@\";\nint x[25][25],h,w;char c;\nint dp[25][25][16][4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint ab,a1,a2,a3,a4,X;\ntuple<int,int,int,int>tup;\nqueue<tuple<int,int,int,int>>Q;\n\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>c;\n\t\t\tfor(int k=0;k<21;k++){\n\t\t\t\tif(T[k]==c){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][1]=1;\n\tQ.push(make_tuple(0,0,0,1));\n\twhile(!Q.empty()){\n\t\ttup=Q.front();\n\t\tQ.pop();\n\t\ta1=get<0>(tup);\n\t\ta2=get<1>(tup);\n\t\ta3=get<2>(tup);\n\t\ta4=get<3>(tup);\n\t\tX=x[a1][a2];\n\t\tif(X>=0 && X<=9){\n\t\t\ta3=X;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X>=10 && X<=13){\n\t\t\ta4=X-10;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==14){\n\t\t\tfor(int n=0;n<4;n++){\n\t\t\t\ta4=n;\n\t\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(X==15){\n\t\t\tif(a3==0){\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==16){\n\t\t\tif(a3==0){\n\t\t\t\ta4=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=0;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==17){\n\t\t\tif(a3==0){\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tab=1;\n\t\tif(X==18 || X==19){\n\t\t\tif(X==19){ab=-1;}\n\t\t\ta3=(a3+ab+16)%16;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==20){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tgoto E;\n\t\t}\n\t}\n\tcout<<\"NO\"<<endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory){\n  int memory=_memory;\n  int dir=0;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};;\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  \n  State st, ne;\n  \n  while(!Q.empty()) {\n    st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]+R);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n#include<cctype>\n\nusing namespace std;\n\nbool p[20][20][16][4];\nint r,c;\nchar g[20][21];\n\nbool dfs(int,int,int,int);\n\nbool mv(int x,int y,int m,int d){\n  int dx[]={1,0,-1,0};\n  int dy[]={0,1,0,-1};\n  return dfs((x+c+dx[d])%c,(y+r+dy[d])%r,m,d);\n}\n\nbool dfs(int x,int y,int m,int d){\n  if(p[x][y][m][d]++){\n    return false;\n  }else{\n    char c=g[y][x];\n    if(c=='<'){\n      d=2;\n    }else if(c=='>'){\n      d=0;\n    }else if(c=='^'){\n      d=3;\n    }else if(c=='v'){\n      d=1;\n    }else if(c=='_'){\n      d=m?2:0;\n    }else if(c=='|'){\n      d=m?3:1;\n    }else if(c=='?'){\n      for(int i=0;i<4;i++){\n\tif(mv(x,y,m,i)){\n\t  return true;\n\t}\n      }\n      return false;\n    }else if(c=='@'){\n      return true;\n    }else if(isdigit(c)){\n      m=c-'0';\n    }else if(c=='+'){\n      m=(m+1)%16;\n    }else if(c=='-'){\n      m=(m+15)%16;\n    }\n    return mv(x,y,m,d);\n  }\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++){\n    cin>>g[i];\n  }\n  cout<<(dfs(0,0,0,0)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"<>^v\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 0 : 1;\n  else if (ch == '|') \n    d = mem ? 2 : 3;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '.')\n    ;\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool used[30][30][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s[30];\nint h,w,m;\nvoid END(){\n  cout<<\"YES\"<<endl;\n  exit(0);\n}\nvoid dfs(int x,int y,int d){\n  while(1){\n    if(used[y][x][d])return ;\n    used[y][x][d]=1;\n    x+=dx[d];\n    y+=dy[d];\n    x+=w;\n    y+=h;\n    x%=w;\n    y%=h;\n    if(s[y][x]=='<'){d=3;}\n    else if(s[y][x]=='>'){d=1;}\n    else if(s[y][x]=='^'){d=0;}\n    else if(s[y][x]=='v'){d=2;}\n    else if(s[y][x]=='_'){\n      if(m)d=3;\n      else d=1;\n    }\n    else if(s[y][x]=='|'){\n      if(m)d=0;\n      else d=2;\n    }\n    else if(s[y][x]=='?'){\n      r(i,4)dfs(x,y,i);\n    }\n    else if(s[y][x]=='.'){}\n    else if(s[y][x]=='@'){END();}\n    else if(s[y][x]=='-'){m=(m-1+15)%15;}\n    else if(s[y][x]=='+'){m=(m+1)%15;}\n    else if(isdigit(s[y][x])){m=s[y][x]-'0';}\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  dfs(0,0,1);\n  cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nenum dir{ RIGHT = 0, UP = 1, LEFT = 2, DOWN = 3 };\n\nstruct state{\n    int x;\n    int y;\n    int mem;\n    dir vec;\n    state(){}\n    ~state(){}\n    state(int a, int b, int v, dir d): x(a), y(b), mem(v), vec(d) {}\n}; \nint main(){\n    string str[20];\n    bool visited[20][20][16][4];\n    int r, c;\n    cin >> r >> c;\n    for(int i = 0; i < r; i++){\n        cin >> str[i];\n        for(int j = 0; j < c; j++){\n            for(int k = 0; k < 16; k++){\n                for(int l = 0; l < 4; l++){\n                    visited[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n    queue<state> que;\n    que.push(state(0, 0, 0, (dir)0));\n    bool stop = false;\n    while(!que.empty()){\n        state s = que.front(); que.pop();\n        int x = s.x, y = s.y;\n        if(visited[x][y][s.mem][s.vec]) continue;\n        visited[x][y][s.mem][s.vec] = true;\n        if(str[x][y] == '@'){\n            stop = true;\n            break;\n        }\n        if(str[x][y] == '?'){\n            for(int i = 0; i < 4; i++){\n                que.push(state((x+dx[i]+r)%r, (y+dy[i]+c)%c, s.mem, (dir)i));\n            }\n            continue;\n        }\n        if(str[x][y] == '<'){\n            s.vec = LEFT;\n        }\n        if(str[x][y] == '>'){\n            s.vec = RIGHT;\n        }\n        if(str[x][y] == '^'){\n            s.vec = UP;\n        }\n        if(str[x][y] == 'v'){\n            s.vec = DOWN;\n        }\n        if(str[x][y] == '_'){\n            if(s.mem == 0){\n                s.vec = RIGHT;\n            }else{\n                s.vec = LEFT;\n            }\n        }\n        if(str[x][y] == '|'){\n            if(s.mem == 0){\n                s.vec = DOWN;\n            }else{\n                s.vec = UP;\n            }\n        }\n        if('0' <= str[x][y] && str[x][y] <= '9'){\n            s.mem = str[x][y] - '0';\n        }\n        if(str[x][y] == '+'){\n            s.mem = (s.mem+1)%16;\n        }\n        if(str[x][y] == '-'){\n            s.mem = (s.mem+15)%16;\n        }\n        que.push(state((x+dx[s.vec]+r)%r, (y+dy[s.vec]+c)%c, s.mem, s.vec));\n    }\n    if(stop){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r)rep(sysJ,c)cin>>m[sysI][sysJ]\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][16];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  visited[s.x][s.y][s.d][s.m] = true;\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    switch(code[st.y][st.x]) {\n    case '<': st.d = LEFT;  break;\n    case '^': st.d = UP;    break;\n    case '>': st.d = RIGHT; break;\n    case 'v': st.d = DOWN;  break;\n    case '.': break;\n    case '@': return true;\n    case '+': st.m = (st.m+1)%16;  break;\n    case '-': st.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) st.d = RIGHT;\n      else st.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) st.d = DOWN;\n      else st.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) st.m = code[st.y][st.x]-'0';\n    }\n    \n    State ne = st;\n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), st.d = ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C;\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n#define pb(e) push_back(e)\n\ntypedef long long ll;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint r, c;\nbool memo[20][20][16];\nstring prog[20];\n\nbool dfs(int x, int y, int dir, int mem)\n{\n    x = (x + c) % c, y = (y + r) % r;\n    while(true) {\n        if(memo[x][y][mem]) return false;\n        memo[x][y][mem] = true;\n        switch(prog[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem == 0 ? 0 : 2); break;\n            case '|': dir = (mem == 0 ? 1 : 3); break;\n            case '.': break;\n            case '+': mem = (mem + 1) & 15; break;\n            case '-': mem = (mem - 1) & 15; break;\n            case '@': return true;\n            case '?':\n                rep(i, 4)\n                    if(dfs(x+dx[i], y+dy[i], i, mem))\n                        return true;\n                return false;\n            default:  mem = prog[y][x] - '0'; break;\n        }\n        x = (x + dx[dir] + c) % c;\n        y = (y + dy[dir] + r) % r;\n    }\n}\n\nint main()\n{\n    cin >> r >> c;\n    rep(i, r) cin >> prog[i];\n    cout << (dfs(0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//テ」ツつーテ」ツδュテ」ツδシテ」ツδ静」ツδォテ・ツ、ツ嘉ヲツ閉ー\nint r, c;\nstring str[21];\nstruct pos{\n\tint x,y;\n\tint num;\n};\npos p[410];\nint p_num=0;\n\nvoid f(int &num, int &muki, char in){\n\tif(in == '<'){\n\t\tmuki = 2;\n\t}\n\tif(in == '>'){\n\t\tmuki = 0;\n\t}\n\tif(in == '^'){\n\t\tmuki = 1;\n\t}\n\tif(in == 'v'){\n\t\tmuki = 3;\n\t}\n\tif(in == '_'){\n\t\tif(num){\n\t\t\tmuki = 2;\n\t\t}else{\n\t\t\tmuki = 0;\n\t\t}\n\t}\n\tif(in == '|'){\n\t\tif(num){\n\t\t\tmuki = 1;\n\t\t}else{\n\t\t\tmuki = 3;\n\t\t}\n\t}\n\tif('0'<=in && in<='9'){\n\t\tnum = in-'0';\n\t}\n\tif(in == '+'){\n\t\tnum = (num+1)%16;\n\t}\n\tif(in == '-'){\n\t\tnum = (num+15)%16;\n\t}\n}\n\nbool F(int i, int j, int num, int muki){\n//\tcout<< i<< \" \"<< j<< \" \"<< num<<endl;\n\tfor(int k=0;k<p_num;k++){\n\t\tif(p[k].x==i && p[k].y==j && p[k].num==num){\n//\t\t\tcout<<\"F\"<<endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\tp[p_num].x = i;\n\tp[p_num].y = j;\n\tp[p_num].num = num;\n\tp_num++;\n\n\tchar in = str[i][j];\n\tif(in == '@'){\n//\t\tcout<<\"Y\"<<endl;\n\t\treturn true;\n\t}\n\tif(in == '?'){\n//\t\tcout<<\"?\"<<endl;\n\t\tif(    F(i, (j+1)%c, num, 0)\n\t\t\t|| F((i+r-1)%c, j, num, 1)\n\t\t\t|| F(i, (j+c-1)%c, num, 2)\n\t\t\t|| F((i+1)%r, j, num, 3)\n\t\t){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tf(num, muki, in);\n\t\tswitch(muki){\n\t\tcase 0:\n\t\t\tj = (j+1)%c;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti = (i+r-1)%r;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tj = (j+c-1)%c;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ti = (i+1)%c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout<<\"muki error\"<<endl;\n\t\t\tbreak;\n\t\t}\n\t\treturn F(i,j,num,muki);\n\t}\n}\n\nbool solve(){\n\tcin>> r>> c;\n\tfor(int i=0;i<r;i++){\n\t\tcin>> str[i];\n\t}\n\tif(F(0,0,0,0)){\n\t\tcout<<\"YES\"<<endl;\n\t}else{\n\t\tcout<<\"NO\"<<endl;\n\t}\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n#define DOWN  0\n#define RIGHT 1\n#define UP    2\n#define LEFT  3\n\nstruct State {\n  int x, y;\n  int mem;\n  int dir;\n\n  State() :\n      x(0),\n      y(0),\n      mem(0),\n      dir(RIGHT) {}\n\n  State(int x, int y, int mem, int dir) :\n      x(x),\n      y(y),\n      mem(mem),\n      dir(dir) {}\n\n  bool operator<(const State & rhs) const {\n    if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n    if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n    if (x == rhs.x) return y < rhs.y;\n    return x < rhs.x;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int R, C;\n  cin >> R >> C;\n  vector<string> prog(R);\n  rep(i, R) cin >> prog[i];\n\n  set<State> visited;\n  queue<State> Q;\n  ll ok = false;\n\n  Q.push(State());\n  while (!Q.empty()) {\n    State st = Q.front();\n    Q.pop();\n\n    if (visited.find(st) != visited.end())\n      break;\n\n    visited.insert(st);\n\n    int x, y;\n    char p;\n    x = st.x;\n    y = st.y;\n\n    if (x < 0 || x >= C || y < 0 || y >= R)\n      continue;\n\n    p = prog[y][x];\n\n    if (p == '@') {\n      ok = true;\n      break;\n    }\n\n    if ('0' <= p && p <= '9') {\n      st.mem = p - 'p';\n    } else if (p == '_') {\n      if (st.mem == 0) st.dir = RIGHT;\n      else st.dir = LEFT;\n    } else if (p == '|') {\n      if (st.mem == 0) st.dir = DOWN;\n      else st.dir = UP;\n    } else if (p == '+') {\n      st.mem = (st.mem + 1) % 16;\n    } else if (p == '-') {\n      st.mem = st.mem - 1;\n      if (st.mem < 0) st.mem += 16;\n    } else if (p == '^') st.dir = UP;\n    else if (p == 'v') st.dir = DOWN;\n    else if (p == '<') st.dir = LEFT;\n    else if (p == '>') st.dir = RIGHT;\n\n    if (p != '?') {\n      st.x += dx[st.dir];\n      st.y += dy[st.dir];\n      Q.push(st);\n    } else {\n      Q.push(State(x + dx[LEFT], y + dy[LEFT], st.mem, LEFT));\n      Q.push(State(x + dx[RIGHT], y + dy[RIGHT], st.mem, RIGHT));\n      Q.push(State(x + dx[UP], y + dy[UP], st.mem, UP));\n      Q.push(State(x + dx[DOWN], y + dy[DOWN], st.mem, DOWN));\n    }\n  }\n  \n  if (ok) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 21;\nconst int MAX_W = 21;\nconst int MAX_M = 11;\n\nint H, W;\nstring M[20];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  int cnt=0;\n  while(!Q.empty()) {\n    if(cnt>=21*21*4*15) break;\n    cnt++;\n\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  //DbgPrint(21*21*4*16);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint r,c;\nstring str[21];\nstring str2[21];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool visited[21][21][4][17];\n\nbool dfs(int x,int y,int d,int m){\n\tif(visited[x][y][d][m])return false;\n\tvisited[x][y][d][m]=true;\n\t//printf(\"%d %d %d %d\\n\",x,y,d,m);\n\tif(str[x][y]=='@')return true;\n\tif(str[x][y]=='>')d=0;\n\tif(str[x][y]=='<')d=2;\n\tif(str[x][y]=='^')d=3;\n\tif(str[x][y]=='v')d=1;\n\tif(str[x][y]=='_'){\n\t\tif(m==0)d=0;\n\t\tif(m!=0)d=2;\n\t}\n\tif(str[x][y]=='|'){\n\t\tif(m==0)d=1;\n\t\tif(m!=0)d=3;\n\t}\n\tif(str[x][y]>='0' && str[x][y]<='9')m=str[x][y]-'0';\n\tif(str[x][y]=='+')m=(m+1)%16;\n\tif(str[x][y]=='-')m=(m+15)%16;\n\tif(str[x][y]=='?'){\n\t\tbool ch=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(dfs((x+dx[i]+c)%c,(y+dy[i]+r)%r,i,m))ch=true;\n\t\t}\n\t\treturn ch;\n\t}else{\n\t\treturn dfs((x+dx[d]+c)%c,(y+dy[d]+r)%r,d,m);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tstr2[i]=str[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tstr[j][i]=str2[i][j];\n\t\t}\n\t}\n\tmemset(visited,0,sizeof(visited));\n\tprintf(\"%s\\n\",dfs(0,0,0,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tchar x,y,p,mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> &visited){\n  char op=code[A.y][A.x];\n  while(op!='@'){\n  \tif(find(visited.begin(),visited.end(),A)!=visited.end())return false;\n  \tvisited.push_back(A);\n  \top=code[A.y][A.x];\n  \t//cerr<<(int)A.x<<\",\"<<(int)A.y<<endl;\n  \tif(op=='>')A.p=0;\n  \tif(op=='v')A.p=1;\n  \tif(op=='<')A.p=2;\n  \tif(op=='^')A.p=3;\n  \tif(op=='_')A.p=(A.mem)?2:0;\n  \tif(op=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=op&&op<='9')A.mem=op-'0';\n   \tif(op=='+')A.mem=(A.mem+1)%16;\n   \tif(op=='-')A.mem=(A.mem+15)%16;\n   \tif(op=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p]+c)%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4]+r)%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p]+c)%c;A.y=(A.y+pos[(A.p+3)%4]+r)%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint N, K;\n\nbool cmp(const pii &a, const pii &b){\n    if(a.first == b.first) return a.second < b.second;\n    return a.first < b.first;\n}\n\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\n\nvi dist;\nint d[110][110];\n\nbool bellman_ford(int n, int s) { // nは頂点数、sは開始頂点\n    dist = vector<int>(n, INF);\n    dist[s] = 0; // 開始点の距離は0\n    for (int i = 0; i < n; i++) {\n        for (int v = 0; v < n; v++) {\n            for (int u = 0; u < n; u++) {\n                if (dist[v] != INF && dist[u] > dist[v] + d[v][u]) {\n                    dist[u] = dist[v] + d[v][u];\n                    if (i == n - 1) return true; // n回目にも更新があるなら負の閉路が存在\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvector<string> field;\nbool f = false;\nint R, C;\nbool state[25][25][20][4];\nmap<char, int> mp;\nvoid dfs(int y, int x, int mem, char dir, int cnt){\n    if(f) return;\n\n    if(state[y][x][mem][mp[dir]] == true) return;\n    state[y][x][mem][mp[dir]] = true;\n\n    if(field[y][x] == '@'){\n        f = true;\n        return;\n    }\n    if(field[y][x] >= '0' && field[y][x] <= '9'){\n        if(dir == 'N') {\n            dfs((y-1+R)%R, x, field[y][x] - '0', 'N', cnt+1);\n        }else if(dir == 'S'){\n            dfs((y+1+R)%R, x, field[y][x] - '0', 'S', cnt+1);\n        }else if(dir == 'E'){\n            dfs(y, (x+1+C)%C, field[y][x] - '0', 'E', cnt+1);\n        }else {\n            dfs(y, (x-1+C)%C, field[y][x] -'0', 'W', cnt+1);\n        }\n    }\n\n    if(field[y][x] == '<'){\n        dfs(y, (x-1+C)%C, mem, 'W', cnt+1);\n    }\n\n    if(field[y][x] == '>'){\n        dfs(y, (x+1+C)%C, mem, 'E', cnt+1);\n    }\n\n    if(field[y][x]== '^'){\n        dfs((y-1+R)%R, x, mem, 'N', cnt+1);\n    }\n\n    if(field[y][x] == 'v'){\n        dfs((y+1+R)%R, x, mem, 'S', cnt+1);\n    }\n\n    if(field[y][x] == '_'){\n        if(mem == 0){\n            dfs(y, (x+1+C)%C, mem, 'E', cnt+1);\n        }else{\n            dfs(y, (x-1+C)%C, mem, 'W', cnt+1);\n        }\n    }\n\n    if(field[y][x] == '|'){\n        if(mem == 0){\n            dfs((y+1+R)%R, x, mem, 'S', cnt+1);\n        }else{\n            dfs((y-1+R)%R, x, mem, 'N', cnt+1);\n        }\n    }\n\n    if(field[y][x] == '?'){\n        dfs(y, (x-1+C)%C, mem, 'W', cnt+1);\n        dfs(y, (x+1+C)%C, mem, 'E', cnt+1);\n        dfs((y+1+R)%R, x, mem, 'S', cnt+1);\n        dfs((y-1+R)%R, x, mem, 'N', cnt+1);\n    }\n\n    if(field[y][x] == '.'){\n        if(dir == 'N') {\n            dfs((y-1+R)%R, x, mem, 'N', cnt+1);\n        }else if(dir == 'S'){\n            dfs((y+1+R)%R, x, mem, 'S', cnt+1);\n        }else if(dir == 'E'){\n            dfs(y, (x+1+C)%C, mem, 'E', cnt+1);\n        }else {\n            dfs(y, (x-1+C)%C, mem, 'W', cnt+1);\n        }\n    }\n\n    if(field[y][x] == '+'){\n        if(dir == 'N') {\n            dfs((y-1+R)%R, x, (mem+1+16)%16, 'N', cnt+1);\n        }else if(dir == 'S'){\n            dfs((y+1+R)%R, x, (mem+1+16)%16, 'S', cnt+1);\n        }else if(dir == 'E'){\n            dfs(y, (x+1+C)%C, (mem+1+16)%16, 'E', cnt+1);\n        }else {\n            dfs(y, (x-1+C)%C, (mem+1+16)%16, 'W', cnt+1);\n        }\n    }\n\n    if(field[y][x] == '-'){\n        if(dir == 'N') {\n            dfs((y-1+R)%R, x, (mem-1+16)%16, 'N', cnt+1);\n        }else if(dir == 'S'){\n            dfs((y+1+R)%R, x, (mem-1+16)%16, 'S', cnt+1);\n        }else if(dir == 'E'){\n            dfs(y, (x+1+C)%C, (mem-1+16)%16, 'E', cnt+1);\n        }else {\n            dfs(y, (x-1+C)%C, (mem-1+16)%16, 'W', cnt+1);\n        }\n    }\n}\nint main() {\n    //cout << fixed << setprecision(15);\n\n    cin >> R >> C;\n    REP(i, R){\n        string str; cin >> str;\n        field.push_back(str);\n    }\n\n    bool state[25][25][20][4];\n    mp['N'] = 0;\n    mp['S'] = 1;\n    mp['W'] = 2;\n    mp['E'] = 3;\n    REP(i, 25) REP(j, 25) REP(k, 20) REP(l, 4) state[i][j][k][l]=false;\n\n    dfs(0, 0, 0, 'E', 0);\n\n    if(f) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n??\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n??\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n??\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n??\n#define DOWN?? 0\n#define RIGHT 1\n#define UP?????? 2\n#define LEFT?? 3\n??\nstruct State {\n????int x, y;\n????int mem;\n????int dir;\n??\n????State() :\n????????????x(0),\n????????????y(0),\n????????????mem(0),\n????????????dir(RIGHT) {}\n??\n????State(int x, int y, int mem, int dir) :\n????????????x(x),\n????????????y(y),\n????????????mem(mem),\n????????????dir(dir) {}\n??\n????bool operator<(const State & rhs) const {\n????????if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n????????if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n????????if (x == rhs.x) return y < rhs.y;\n????????return x < rhs.x;\n????}\n};\n??\nint main() {\n????ios_base::sync_with_stdio(false); cin.tie(0);\n????int R, C;\n????cin >> R >> C;\n????vector<string> prog(R);\n????rep(i, R) cin >> prog[i];\n??\n????set<State> visited;\n????queue<State> Q;\n????ll ok = false;\n??\n????Q.push(State());\n????while (!Q.empty()) {\n????????State st = Q.front();\n????????Q.pop();\n??\n????????st.x = (st.x + C) % C;\n????????st.y = (st.y + R) % R;\n??\n????????if (visited.find(st) != visited.end())\n????????????continue;\n??????????\n????????visited.insert(st);\n??\n????????char p;\n????????p = prog[st.y][st.x];\n??\n????????if (p == '@') {\n????????????ok = true;\n????????????break;\n????????}\n??\n????????switch (p) {\n????????????case '0'...'9':\n????????????????st.mem = p - '0';\n????????????????break;\n????????????case '_':\n????????????????if (st.mem == 0) st.dir = RIGHT;\n????????????????else st.dir = LEFT;\n????????????????break;\n????????????case '|':\n????????????????if (st.mem == 0) st.dir = DOWN;\n????????????????else st.dir = UP;\n????????????????break;\n????????????case '+':\n????????????????st.mem = (st.mem + 1) % 16;\n????????????????break;\n????????????case '-':\n????????????????st.mem = st.mem - 1;\n????????????????if (st.mem < 0) st.mem += 16;\n????????????????break;\n????????????case '^':\n????????????????st.dir = UP;\n????????????????break;\n????????????case 'v':\n????????????????st.dir = DOWN;\n????????????????break;\n????????????case '<':\n????????????????st.dir = LEFT;\n????????????????break;\n????????????case '>':\n????????????????st.dir = RIGHT;\n????????????????break;\n????????}\n??\n????????if (p != '?') {\n????????????Q.push(State(st.x + dx[st.dir], st.y + dy[st.dir], st.mem, st.dir));\n????????} else {\n????????????Q.push(State(st.x + dx[LEFT],???? st.y + dy[LEFT],?? st.mem, LEFT));\n????????????Q.push(State(st.x + dx[RIGHT],?? st.y + dy[RIGHT], st.mem, RIGHT));\n????????????Q.push(State(st.x + dx[UP],???????? st.y + dy[UP],?????? st.mem, UP));\n????????????Q.push(State(st.x + dx[DOWN],???? st.y + dy[DOWN],?? st.mem, DOWN));\n????????}\n????}\n??????\n????if (ok) cout << \"YES\" << endl;\n????else cout << \"NO\" << endl;\n????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar fie[30][30];\nint R,C;\n\nstruct state{\n  int x,y,m,d;\n};\n\nbool M[30][30][20][4];\nint dx[]={1,0,-1,0};//0> 1v 2< 3^ \nint dy[]={0,1,0,-1};\n\nbool next(int &x,int &y,int d){\n  x+=dx[d];\n  y+=dy[d];\n  if( x == -1 ) x = C-1;\n  else if( y == -1 ) y = R-1;\n  else if( x == C+1 ) x = 0;\n  else if( y == R+1 ) y = 0;\n  return true;\n}\n\nbool calc(int x,int y,int &m,int &d){\n  if( fie[x][y] == '<' ) d = 2;\n  else if( fie[x][y] == '>' ) d = 0;\n  else if( fie[x][y] == '^' ) d = 3;\n  else if( fie[x][y] == 'v' ) d = 1;\n  else if( fie[x][y] == '_' ){\n    if( m == 0 ) d = 0;\n    else d = 2;\n  } else if( fie[x][y] == '|' ){\n    if( m == 0 ) d = 1;\n    else d = 3;\n  } else if( fie[x][y] == '@' ) return true;\n  else if( isdigit(fie[x][y] )  )m = fie[x][y] - '0';\n  else if( fie[x][y] == '+' ) m = (m+1)%16;\n  else if( fie[x][y] == '-' ) m = (m+15)%16;\n  return false;\n}\n\nbool solve(){\n  memset(M,0,sizeof(M));\n  queue<state> q;\n  q.push( (state){0,0,0,0} );\n  M[0][0][0][0] = 1;\n  while( !q.empty() ){\n    state st = q.front(); q.pop();\n    //cout << st.x << \" \" << st.y << \" \" << st.m << \" \"<< st.d << endl;\n    if( fie[st.x][st.y] == '?' ){\n      for(int i=0;i<4;i++){\n        int nx = st.x, ny = st.y;\n        next( nx, ny, i );\n        if( M[nx][ny][st.m][i] ) continue;\n        M[nx][ny][st.m][i] = 1;\n        q.push( (state){nx,ny,st.m,i} );\n      }\n    } else {\n      int nx = st.x, ny = st.y, nm = st.m, nd = st.d;\n      if( calc( nx, ny, nm, nd ) ) return true;\n      next( nx, ny, nd );\n      if( M[nx][ny][nm][nd] ) continue;\n      M[nx][ny][nm][nd] = 1;\n      q.push( (state){nx,ny,nm,nd} );\n    }\n  }\n  \n  return false;\n}\n\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++)\n    for(int j=0;j<C;j++)\n      cin >> fie[j][i];\n\n  if( solve() ) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include <iterator>\n#include<queue>\n#include <functional>\n#include <string>\n#include <numeric>\n#include<stack>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) v.begin(),v.end()\nusing namespace std;\nconst int dx[4] = { -1, 1, 0, 0 };\nconst int dy[4] = { 0, 0, -1, 1 };\nstruct aaa{\n\tint x;\n\tint y;\n\tint d;\n\tint m;\n};\n\nstruct data\n{\n\tbool memo[20][20][16][4];\n\tdata(){\n\t\tREP(i, 20)\n\t\t\tREP(j, 20)\n\t\t\tREP(k, 16)\n\t\t\tREP(l, 4)\n\t\t\tmemo[i][j][k][l] = false;\n\t}\n};\nstack<aaa> az;\nbool memo[20][20][16][4] = {};\nvector<string> Fi;\nint R=0, C=0;\nbool a(int ax, int ay,int Memory, int Muki){\n\taz.push({ ax, ay, Memory, Muki });\n\twhile (!az.empty()){\n\t\tint ax = (az.top().x + C) % C, ay = (az.top().y + R) % R, Memory = az.top().d, Muki = az.top().m;\n\t\taz.pop();\n\t\tif (memo[ax][ay][Memory][Muki])continue;\n\t\tmemo[ax][ay][Memory][Muki] = true;\n\t\tswitch (Fi[ay][ax]){\n\t\tcase '<':Muki = 0; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '>':Muki = 1; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '^':Muki = 2;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase 'v':Muki = 3; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '_':Muki = Memory ? 0 : 1;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '|':Muki = Memory ? 2 : 3;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '?':REP(i, 4){\n\t\t\taz.push({ ax + dx[i], ay + dy[i], Memory, i });\n\t\t}\n\t\t\t\t break;\n\t\tcase '.': ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '@':return true;\n\t\tcase '+':Memory = (Memory + 1) % 16; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '-':Memory = (Memory + 15) % 16; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tdefault:Memory = Fi[ay][ax] - 48; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin >> R >> C;\n\tFi.resize(20);\n\tREP(i, R){\n\t\tstring st;\n\t\tcin >> Fi[i];\n\t}\n\tdata adata;\n\tif (a(0, 0, 0, 1)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse{\n\t\tcout << \"NO\" << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint r,c;\nchar str[22][22];\nstring str2[22];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool visited[22][22][4][17];\n\nbool dfs(int x,int y,int d,int m){\n\tif(visited[x][y][d][m])return false;\n\tvisited[x][y][d][m]=true;\n\t//printf(\"%d %d %d %d\\n\",x,y,d,m);\n\tif(str[x][y]=='@')return true;\n\tif(str[x][y]=='>')d=0;\n\tif(str[x][y]=='<')d=2;\n\tif(str[x][y]=='^')d=3;\n\tif(str[x][y]=='v')d=1;\n\tif(str[x][y]=='_'){\n\t\tif(m==0)d=0;\n\t\tif(m!=0)d=2;\n\t}\n\tif(str[x][y]=='|'){\n\t\tif(m==0)d=1;\n\t\tif(m!=0)d=3;\n\t}\n\tif(str[x][y]>='0' && str[x][y]<='9')m=str[x][y]-'0';\n\tif(str[x][y]=='+')m=(m+1)%16;\n\tif(str[x][y]=='-')m=(m+15)%16;\n\tif(str[x][y]=='?'){\n\t\tbool ch=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(dfs((x+dx[i]+c)%c,(y+dy[i]+r)%r,i,m))ch=true;\n\t\t}\n\t\treturn ch;\n\t}else{\n\t\treturn dfs((x+dx[d]+c)%c,(y+dy[d]+r)%r,d,m);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str2[i];\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tstr[j][i]=str2[i][j];\n\t\t}\n\t}\n\tmemset(visited,false,sizeof(visited));\n\tprintf(\"%s\\n\",dfs(0,0,0,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// right, down, left, up\nconst int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nint H, W;\nchar Prog[20][20];\n\nbool G[20][20][4][16]; // y, x, cour, memory\n\nbool run(int x, int y, int cour, int mem) {\n    do {\n        G[y][x][cour][mem] = true;\n        switch (Prog[y][x]) {\n        case '<':\n            cour = 2;\n            break;\n        case '>':\n            cour = 0;\n            break;\n        case '^':\n            cour = 3;\n            break;\n        case 'v':\n            cour = 1;\n            break;\n        case '_':\n            if (mem == 0) {\n                cour = 0;\n            } else {\n                cour = 2;\n            }\n            break;\n        case '|':\n            if (mem == 0) {\n                cour = 1;\n            } else {\n                cour = 3;\n            }\n            break;\n        case '?':\n            REP(i, 4) {\n                int sx = x + dx[i], sy = y + dy[i];\n                if (sx < 0)  sx = W;\n                if (sx >= W) sx = 0;\n                if (sy < 0)  sy = H;\n                if (sy >= H) sy = 0;\n                if (run(sx, sy, i, mem)) return true;\n            }\n            return false;\n        case '.':\n            break;\n        case '@':\n            return true;\n        case '+':\n            if (mem == 15) {\n                mem = 0;\n            } else {\n                mem++;\n            }\n            break;\n        case '-':\n            if (mem == 0) {\n                mem = 15;\n            } else {\n                mem--;\n            }\n            break;\n        default: // number\n            mem = Prog[y][x] - '0';\n        }\n\n        x += dx[cour];\n        y += dy[cour];\n        if (x < 0)  x = W;\n        if (x >= W) x = 0;\n        if (y < 0)  y = H;\n        if (y >= H) y = 0;\n\n//        LOG(\"%02d\\n\", mem);\n//        REP(sy, H) {\n//            REP(sx, W) {\n//                if (sx == x && sy == y) {\n//                    LOG(\"#\");\n//                } else {\n//                    LOG(\"%c\", Prog[sy][sx]);\n//                }\n//            }\n//            LOG(\"\\n\");\n//        }\n//        getchar();\n    } while (!G[y][x][cour][mem]);\n\n    return false;\n}\n\nint main() {\n    cin >> H >> W;\n    REP(y, H) REP(x, W) {\n        cin >> Prog[y][x];\n    }\n    cout << (run(0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><v^\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 1 : 0;\n  else if (ch == '|') \n    d = mem ? 3 : 2;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  for (int i = 0; i < 22; i++)\n    for (int j = 0; j < 22; j++)\n      for (int k = 0; k < 4; k++)\n\tfor (int r = 0; r < 16; r++)\n\t  memo[i][j][k][r] = false;\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint R, C;\n\nconst int DOWN  = 0;\nconst int LEFT  = 1;\nconst int RIGHT = 2;\nconst int UP    = 3;\n\nstruct State {\n    int x, y, memory, direction;\n    bool operator<(const State &rhs) const \n    {\n        if (x == rhs.x) {\n           if (y == rhs.y) {\n               if (memory == rhs.memory) return direction < rhs.direction;\n               else return memory < rhs.memory;\n           } else {\n               return y < rhs.y;\n           }\n        } else {\n            return x < rhs.x;\n        }\n    }\n    \n};\n\nPII move(int x, int y, int dir)\n{\n    PII res(x + dx[dir], y + dy[dir]);\n    res.first = (res.first + C) % C;\n    res.second = (res.second + R) % R;\n    return res;\n}\n\nint increment(int x)\n{\n    return (x+1)%16;\n}\n\nint decrement(int x)\n{\n    return (x - 1 + 16) % 16;\n}\n\nbool solve(vector<string> P)\n{\n   map<State, bool> vis;\n    queue<State> Q;\n    Q.push({0, 0, 0, RIGHT});\n    vis[State({0, 0, 0, RIGHT})] = true;\n\n    while (Q.size()) {\n        State s = Q.front(); Q.pop();\n        vector<State> ns;\n\n#ifdef DEBUG\n        cerr << s.x << \" \" << s.y << \" \" << s.memory << \" \" << \"<^>v\"[s.direction] << endl;\n#endif\n\n        switch (P[s.y][s.x]) {\n            case '<':\n                {\n                    PII npos = move(s.x, s.y, LEFT);\n                    ns.push_back({npos.first, npos.second, s.memory, LEFT});\n                }\n                break;\n            case '>':\n                {\n                    PII npos = move(s.x, s.y, RIGHT);\n                    ns.push_back({npos.first, npos.second, s.memory, RIGHT});\n                }\n                break;\n            case '^':\n                {\n                    PII npos = move(s.x, s.y, UP);\n                    ns.push_back({npos.first, npos.second, s.memory, UP});\n                }\n                break;\n            case 'v':\n                {\n                    PII npos = move(s.x, s.y, DOWN);\n                    ns.push_back({npos.first, npos.second, s.memory, DOWN});\n                }\n                break;\n            case '_':\n                {\n                    int ndir = (!s.memory ? RIGHT : LEFT);\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '|':\n                {\n                    int ndir = (!s.memory ? DOWN : UP);\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '?':\n                rep(i, 4) {\n                    int ndir = i;\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '.':\n                {\n                    int ndir = s.direction;\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '@':\n                return true;\n            case '+':\n                {\n                    int nmemory = increment(s.memory);\n                    PII npos = move(s.x, s.y, s.direction);\n                    ns.push_back({npos.first, npos.second, nmemory, s.direction});\n                }\n                break;\n            case '-':\n                {\n                    int nmemory = decrement(s.memory);\n                    PII npos = move(s.x, s.y, s.direction);\n                    ns.push_back({npos.first, npos.second, nmemory, s.direction});\n                }\n                break;\n            default:\n                {\n                    int nmemory = (P[s.y][s.x] - '0');\n                    PII npos = move(s.x, s.y, s.direction);\n                    ns.push_back({npos.first, npos.second, nmemory, s.direction});\n                }\n                break;\n        }\n\n        for (State m : ns) {\n            if (!vis[m]) {\n                vis[m] = true;\n                Q.push(m);\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    cin >> R >> C;\n    vector<string> P(R);\n    rep(i, R) cin >> P[i];\n    cout << (solve(P) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2262 : Stopping Problem **/\nvector<string> b;\nbool vis[4][20][20][16];\nint R, C;\n\nbool solve(int d, int x, int y, int m)\n{\n\twhile (1) {\n\t\tchar c = b[y][x];\n\t\t\n\t\tif (c == '<')\n\t\t\td = 3;\n\t\telse if (c == '>')\n\t\t\td = 1;\n\t\telse if (c == '^')\n\t\t\td = 0;\n\t\telse if (c == 'v')\n\t\t\td = 2;\n\t\t\n\t\telse if (c == '_') {\n\t\t\tif (m == 0)\n\t\t\t\td = 1;\n\t\t\telse\n\t\t\t\td = 3;\n\t\t}\n\t\t\n\t\telse if (c == '|') {\n\t\t\tif (m == 0)\n\t\t\t\td = 2;\n\t\t\telse\n\t\t\t\td = 0;\n\t\t}\n\t\t\n\t\telse if (c == '.')\n\t\t\t;\n\t\t\n\t\telse if (c == '@')\n\t\t\treturn true;\n\t\t\n\t\telse if (isdigit(c)) {\n\t\t\tm = c-'0';\n\t\t}\n\t\t\n\t\telse if (c == '+') {\n\t\t\tm++; if (m==16) m=0;\n\t\t}\n\t\t\n\t\telse if (c == '-') {\n\t\t\tm--; if (m<0) m=15;\n\t\t}\n\t\t\n\t\telse if (c == '?') {\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif (x < 0) x = C-1;\n\t\t\t\telse if (x>=C) x = 0;\n\t\t\t\tif (y < 0) y = R-1;\n\t\t\t\tif (y >= R) y = 0;\n\t\t\t\t\n\t\t\t\tif (vis[i][nx][ny][m]) continue;\n\t\t\t\tvis[i][nx][ny][m] = true;\n\t\t\t\t\n\t\t\t\tif (solve(i, x, y, m))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (vis[d][x][y][m])\n\t\t\treturn false;\n\t\tvis[d][x][y][m] = true;\n\t\t\n\t\tx += dx[d], y += dy[d];\n\t\tif (x < 0) x = C-1;\n\t\telse if (x>=C) x = 0;\n\t\tif (y < 0) y = R-1;\n\t\tif (y >= R) y = 0;\n\t}\n}\n\nint main()\n{\n\tcin>>R>>C;\n\tb.resize(R);\n\trep(i, R) cin>>b[i];\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tcout << (solve(1, 0, 0, 0)?\"YES\":\"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n#define pb(e) push_back(e)\n\ntypedef long long ll;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint r, c;\nbool memo[20][20][4][16];\nstring prog[20];\n\nbool dfs(int x, int y, int dir, int mem)\n{\n    x = (x + c) % c, y = (y + r) % r;\n    while(true) {\n        if(memo[x][y][dir][mem]) return false;\n        memo[x][y][dir][mem] = true;\n        switch(prog[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem == 0 ? 0 : 2); break;\n            case '|': dir = (mem == 0 ? 1 : 3); break;\n            case '.': break;\n            case '+': mem = (mem + 1) & 15; break;\n            case '-': mem = (mem - 1) & 15; break;\n            case '@': return true;\n            case '?':\n                rep(i, 4)\n                    if(dfs(x+dx[i], y+dy[i], i, mem))\n                        return true;\n                return false;\n            default:  mem = prog[y][x] - '0'; break;\n        }\n        x = (x + dx[dir] + c) % c;\n        y = (y + dy[dir] + r) % r;\n    }\n}\n\nint main()\n{\n    cin >> r >> c;\n    rep(i, r) cin >> prog[i];\n    cout << (dfs(0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint R, C; string s[20]; bool flag, visited[20][20][4][16];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int d, int m) {\n\tif (!visited[y][x][d][m]) {\n\t\tvisited[y][x][d][m] = true;\n\t\tswitch (s[y][x]) {\n\t\tcase '>':\n\t\t\trec((x + 1) % C, y, 0, m); break;\n\t\tcase 'v':\n\t\t\trec(x, (y + 1) % R, 0, m); break;\n\t\tcase '<':\n\t\t\trec((x - 1 + C) % C, y, 0, m); break;\n\t\tcase '^':\n\t\t\trec(x, (y - 1 + R) % R, 0, m); break;\n\t\tcase '_':\n\t\t\tif (m == 0) rec((x + 1) % C, y, 0, m); else rec((x - 1 + C) % C, y, 2, m); break;\n\t\tcase '|':\n\t\t\tif (m == 0) rec(x, (y + 1) % R, 1, m); else rec(x, (y - 1 + R) % R, 3, m); break;\n\t\tcase '?':\n\t\t\tfor (int i = 0; i < 4; i++) rec((x + dx[i] + C) % C, (y + dy[i] + R) % R, i, m); break;\n\t\tcase '.':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, m); break;\n\t\tcase '@':\n\t\t\tflag = true; return;\n\t\tcase '+':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, (m + 1) % 16); break;\n\t\tcase '-':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, (m + 15) % 16); break;\n\t\tdefault:\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, s[y][x] - 48); break;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &R, &C);\n\tfor (int i = 0; i < R; i++) cin >> s[i]; rec(0, 0, 0, 0);\n\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint R, C;\n\nconst int UP    = 0;\nconst int LEFT  = 1;\nconst int RIGHT = 2;\nconst int DOWN  = 3;\n\nstruct State {\n    int x, y, memory, direction;\n    bool operator<(const State &rhs) const \n    {\n        if (x == rhs.x) {\n           if (y == rhs.y) {\n               if (memory == rhs.memory) return direction < rhs.direction;\n               else return memory < rhs.memory;\n           } else {\n               return y < rhs.y;\n           }\n        } else {\n            return x < rhs.x;\n        }\n    }\n    \n};\n\nPII move(int x, int y, int dir)\n{\n    PII res(x + dx[dir], y + dy[dir]);\n    res.first = (res.first + C) % C;\n    res.second = (res.second + R) % R;\n    return res;\n}\n\nint increment(int x)\n{\n    return (x+1)%16;\n}\n\nint decrement(int x)\n{\n    return (x - 1 + 16) % 16;\n}\n\nbool solve(vector<string> P)\n{\n   map<State, bool> vis;\n    queue<State> Q;\n    Q.push({0, 0, 0, RIGHT});\n    vis[State({0, 0, 0, RIGHT})] = true;\n\n    while (Q.size()) {\n        State s = Q.front(); Q.pop();\n        vector<State> ns;\n\n#ifdef DEBUG\n        cerr << s.x << \" \" << s.y << \" \" << s.memory << \" \" << \"<^>v\"[s.direction] << endl;\n#endif\n\n        switch (P[s.y][s.x]) {\n            case '<':\n                {\n                    PII npos = move(s.x, s.y, LEFT);\n                    ns.push_back({npos.first, npos.second, s.memory, LEFT});\n                }\n                break;\n            case '>':\n                {\n                    PII npos = move(s.x, s.y, RIGHT);\n                    ns.push_back({npos.first, npos.second, s.memory, RIGHT});\n                }\n                break;\n            case '^':\n                {\n                    PII npos = move(s.x, s.y, UP);\n                    ns.push_back({npos.first, npos.second, s.memory, UP});\n                }\n                break;\n            case 'v':\n                {\n                    PII npos = move(s.x, s.y, DOWN);\n                    ns.push_back({npos.first, npos.second, s.memory, DOWN});\n                }\n                break;\n            case '_':\n                {\n                    int ndir = (!s.memory ? RIGHT : LEFT);\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '|':\n                {\n                    int ndir = (!s.memory ? DOWN : UP);\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '?':\n                rep(i, 4) {\n                    int ndir = i;\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '.':\n                {\n                    int ndir = s.direction;\n                    PII npos = move(s.x, s.y, ndir);\n                    ns.push_back({npos.first, npos.second, s.memory, ndir});\n                }\n                break;\n            case '@':\n                return true;\n            case '+':\n                {\n                    int nmemory = increment(s.memory);\n                    PII npos = move(s.x, s.y, s.direction);\n                    ns.push_back({npos.first, npos.second, nmemory, s.direction});\n                }\n                break;\n            case '-':\n                {\n                    int nmemory = decrement(s.memory);\n                    PII npos = move(s.x, s.y, s.direction);\n                    ns.push_back({npos.first, npos.second, nmemory, s.direction});\n                }\n                break;\n            default:\n                {\n                    int nmemory = (P[s.y][s.x] - '0');\n                    PII npos = move(s.x, s.y, s.direction);\n                    ns.push_back({npos.first, npos.second, nmemory, s.direction});\n                }\n                break;\n        }\n\n        for (State m : ns) {\n            if (!vis[m]) {\n                vis[m] = true;\n                Q.push(m);\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    cin >> R >> C;\n    vector<string> P(R);\n    rep(i, R) cin >> P[i];\n    cout << (solve(P) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w;\nchar data[20][20];\nbool visited[20][20][4][16];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool solve(int y, int x, int d, int m){\n  while(1){\n    if(visited[y][x][d][m]) break;\n    visited[y][x][d][m] = true;\n    switch(data[y][x]){\n      case '<':\n        d = 3;\n        break;\n      case '>':\n        d = 1;\n        break;\n      case '^':\n        d = 0;\n        break;\n      case 'v':\n        d = 2;\n        break;\n      case '_':\n        if(m) d = 3;\n        else d = 1;\n        break;\n      case '|':\n        if(m) d = 0;\n        else d = 2;\n        break;\n      case '.':\n        break;\n      case '@':\n        return true;\n        break;\n      case '+':\n        m = (m+1)%16;\n        break;\n      case '-':\n        m = (m+15)%16;\n        break;\n    }\n    if('0' <= data[y][x] && data[y][x] <= '9') m = data[y][x] - '0';\n    if(data[y][x] == '?'){\n      for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny == h) ny = 0;\n        if(ny == -1) ny = h-1;\n        if(nx == w) nx = 0;\n        if(nx == -1) nx = w-1;\n        if(solve(ny, nx, i, m)) return true;\n      }\n      return false;\n    }\n    int ny = y + dy[d], nx = x + dx[d];\n    if(ny == h) ny = 0;\n    if(ny == -1) ny = h-1;\n    if(nx == w) nx = 0;\n    if(nx == -1) nx = w-1;\n    y = ny;\n    x = nx;\n  }\n  return false;\n}\n\nmain(){\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> data[i][j];\n    }\n  }\n  fill(visited[0][0][0], visited[20][0][0], false);\n  if(solve(0, 0, 1, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define N 20\n#define M 16\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\nstring s[N];\nint r,c;\n\nbool bfs(){\n  bool d[N][N][4][M];\n  queue<P1> q;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  memset(d,0,sizeof(d));\n  q.push(P1(P(0,0),P(1,0)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int y=t.f.f,x=t.f.s;\n    int dir=t.s.f,mem=t.s.s;\n    int ndir=dir,nmem=mem;\n    if(d[y][x][dir][mem])continue;\n    d[y][x][dir][mem]=true;\n    if(s[y][x]=='@')return true;\n    if(s[y][x]=='<')ndir=3;\n    if(s[y][x]=='>')ndir=1;\n    if(s[y][x]=='^')ndir=0;\n    if(s[y][x]=='v')ndir=2;\n    if(s[y][x]=='_'){\n      if(!mem)ndir=1;\n      else ndir=3;\n    }\n    if(s[y][x]=='|'){\n      if(!mem)ndir=2;\n      else ndir=0;\n    }\n    if('0'<=s[y][x]&&s[y][x]<='9')\n      nmem=s[y][x]-'0';\n    if(s[y][x]=='+')\n      nmem=(mem+1)%16;\n    if(s[y][x]=='-')\n      nmem=(mem+15)%16;\n    if(s[y][x]=='?'){\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(ny<0)ny=r-1;\n\tif(nx<0)nx=c-1;\n\tif(r<=ny)ny=0;\n\tif(c<=nx)nx=0;\n\tq.push(P1(P(ny,nx),P(ndir,nmem)));\n      }\n    }else{\n      int ny=y+dy[ndir];\n      int nx=x+dx[ndir];\n      if(ny<0)ny=r-1;\n      if(nx<0)nx=c-1;\n      if(r<=ny)ny=0;\n      if(c<=nx)nx=0;\n      q.push(P1(P(ny,nx),P(ndir,nmem)));\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++)cin>>s[i];\n  if(bfs())cout<<\"YES\"<<endl;\n  else cout<<\"NO\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\n#define MAX 25\n\nint H,W,mem;\nchar field[MAX][MAX];\nbool visited[MAX][MAX][16];\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nvoid Nextpos(int &y,int &x){\n  if(x >= W){\n    x = 0;\n  }else if(y >= H){\n    y = 0;\n  }else if(x < 0){\n    x = W-1;\n  }else if(y < 0){\n    y = H-1;\n  }\n}\n\nbool solve(int y,int x,int dir){\n  if(x >= 0 && field[y][x] == '@') return true;\n  if(x >= 0 && visited[y][x][mem]) return false;\n  if(x >= 0) visited[y][x][mem] = true;\n\n  int nx = x + dx[dir], ny = y + dy[dir];\n  Nextpos(ny,nx);\n  \n  if(isdigit(field[ny][nx])){\n    mem = field[ny][nx] - '0';\n  }else{\n    switch(field[ny][nx]){\n    case '>':\n      dir = 0;\n      break;\n    case 'v':\n      dir = 1;\n      break;\n    case '<':\n      dir = 2;\n      break;\n    case '^':\n      dir = 3;\n      break;\n    case '_':\n      dir = (mem == 0 ? 0 : 2);\n      break;\n    case '|':\n      dir = (mem == 0 ? 1 : 3);\n      break;\n    case '?':\n      for(int i = 0 ; i < 4 ; i++){\n        int nnx = nx + dx[i];\n        int nny = ny + dy[i];\n        Nextpos(nny,nnx);\n        if(visited[nny][nnx][mem]) continue;\n        if(solve(nny,nnx,i)) return true;\n      }\n      break;\n    case '+':\n      mem = (mem == 15 ? 0 : mem+1);\n      break;\n    case '-':\n      mem = (mem == 0 ? 15 : mem-1);\n      break;\n    }\n  }\n  if(solve(ny,nx,dir)) return true;\n  return false;\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n    }\n  }\n  mem = 0;\n  memset(visited,false,sizeof(visited));\n  cout << (solve(0,-1,0) ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint memo[20][20][4][16];\nchar data[20][20];\nint W,H;\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,-1,1};\n \nchar chg(char c){\n    string table = \"<>^v\";\n    return table.find(c);\n}\nint dfs(int x,int y,int d,int m){\n    x = (x+W) % W ;\n    y = (y+H) % H ;\n     \n    if(memo[x][y][d][m]) return 0;\n    else memo[x][y][d][m] = true;\n     \n    char c = data[y][x];\n    if(c=='_'){\n        d = m ? 0 : 1;\n    }else if( c == '|'){\n        d = m ? 2 : 3;\n    }else if( c == '?'){\n        for(int i = 0 ; i < 4 ; i++){\n            if( dfs(x+dx[i],y+dy[i],i,m) ) return 1;\n        }       \n        return 0;\n    }else if(c == '.'){\n         \n    }else if(c == '@'){\n        return 1;\n    }else if('0' <= c && c <= '9'){\n        m = c - '0';\n    }else if(c == '+'){\n        m = (m+1) % 16;\n    }else if(c == '-'){\n        m = (m+15) % 16;\n    }else{\n        d = chg(c);\n    }\n    return dfs(x+dx[d],y+dy[d],d,m);\n}\nint main(){\n    cin >> H >> W;\n    for(int i = 0 ; i < H; i++)\n        for(int j = 0 ; j < W ; j++)\n            cin >> data[i][j];\n    cout << (dfs(0,0,1,0)?\"YES\":\"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool used[30][30][4][16];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s[30];\nint h,w;\nvoid END(){\n  cout<<\"YES\"<<endl;\n  exit(0);\n}\nvoid dfs(int x,int y,int d,int m,int D){\n  if(!D){\n    if(s[y][x]=='<'){d=3;}\n    else if(s[y][x]=='>'){d=1;}\n    else if(s[y][x]=='^'){d=0;}\n    else if(s[y][x]=='v'){d=2;}\n    else if(s[y][x]=='_'){\n      if(m)d=3;\n      else d=1;\n    }\n    else if(s[y][x]=='|'){\n      if(m)d=0;\n      else d=2;\n    }\n    else if(s[y][x]=='?'){\n      r(i,4)dfs(x,y,i,m,1);\n    }\n    else if(s[y][x]=='.'){}\n    else if(s[y][x]=='@'){END();}\n    else if(s[y][x]=='-'){m=(m-1+16)%16;}\n    else if(s[y][x]=='+'){m=(m+1)%16;}\n    else if(isdigit(s[y][x])){m=s[y][x]-'0';}\n  }\n  while(1){\n    if(used[y][x][d][m])return ;\n    used[y][x][d][m]=1;\n    x+=dx[d];\n    y+=dy[d];\n    x+=w;\n    y+=h;\n    x%=w;\n    y%=h;\n    if(s[y][x]=='<'){d=3;}\n    else if(s[y][x]=='>'){d=1;}\n    else if(s[y][x]=='^'){d=0;}\n    else if(s[y][x]=='v'){d=2;}\n    else if(s[y][x]=='_'){\n      if(m)d=3;\n      else d=1;\n    }\n    else if(s[y][x]=='|'){\n      if(m)d=0;\n      else d=2;\n    }\n    else if(s[y][x]=='?'){\n      r(i,4)dfs(x,y,i,m,1);\n    }\n    else if(s[y][x]=='.'){}\n    else if(s[y][x]=='@'){END();}\n    else if(s[y][x]=='-'){m=(m-1+16)%16;}\n    else if(s[y][x]=='+'){m=(m+1)%16;}\n    else if(isdigit(s[y][x])){m=s[y][x]-'0';}\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  dfs(0,0,1,0,0);\n  cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\nint r, c;\nchar a[21][21];\nbool vis[22][22][17][5];\n\nint xdir[4] = {1, 0, -1, 0}, ydir[4] = {0, 1, 0, -1};\nbool dfs(int x, int y, int m, int d)\n{\n  if(!vis[y][x][m][d]) return false;\n  vis[y][x][m][d] = false;\n\n  char ch = a[y][x];\n  int nm = m, nd = d, dx, dy; \n\n  if(ch == '@') return true;\n  else if(ch == '<') nd = 2;\n  else if(ch == '>') nd = 0;\n  else if(ch == '^') nd = 3;\n  else if(ch == 'v') nd = 1;\n  else if(ch == '|') nd = (m == 0)? 1 : 3;\n  else if(ch == '_') nd = (m == 0)? 0 : 2;\n  else if(ch == '+') nm = (m == 15)? 0 : m+1;\n  else if(ch == '-') nm = (m == 0)? 15 : (m-1);\n  else if(isdigit(ch)) nm = (int)(ch-'0');\n  \n  if(ch == '?'){\n    for(int i = 0; i < 4; i++){\n      dx = x+xdir[i], dy = y+ydir[i];\n      if(dx < 0) dx = c-1;\n      if(dx >= c) dx = 0;\n      if(dy < 0) dy = r-1;\n      if(dy >= r) dy = 0;\n\n      if(dfs(dx, dy, nm, i)) return true;\n    }\n\n    return false;\n  }\n  \n  dx = x+xdir[nd], dy = y+ydir[nd];\n  if(dx < 0) dx = c-1;\n  if(dx >= c) dx = 0;\n  if(dy < 0) dy = r-1;\n  if(dy >= r) dy = 0;\n  \n  return dfs(dx, dy, nm, nd);\n}\n\nint main()\n{\n  while(cin>>r>>c && (r+c)){\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++) cin >> a[i][j];\n\n    fill(&vis[0][0][0][0], &vis[21][21][16][4], true);\n    cout << ((dfs(0, 0, 0, 0))? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nconstexpr int MAX = 20;\nconstexpr int mask = 0xf;\nconstexpr int dx[4] = {1, -1, 0, 0};\nconstexpr int dy[4] = {0, 0, 1, -1};\n\nconst unordered_map<char, int> dir{{'>', 0}, {'<', 1}, {'v', 2}, {'^', 3}, {'_', 0}, {'|', 2}};\n\nint h, w;\nbool visited[MAX][MAX][4][mask];\nstring program[MAX];\n\nbool dfs(int x, int y, int d, int m) {\n\tif(program[y][x] == '@') {\n\t\treturn true;\n\t}\n\telse if(dir.count(program[y][x])) {\n\t\td = dir.at(program[y][x]);\n\t\tif(m && (program[y][x] == '_' || program[y][x] == '|')) ++d;\n\t}\n\telse if(isdigit(program[y][x])) {\n\t\tm = program[y][x] - '0';\n\t}\n\telse if(program[y][x] == '+') {\n\t\tm = ((m + 1) & mask);\n\t}\n\telse if(program[y][x] == '-') {\n\t\tm = ((m - 1) & mask);\n\t}\n\n\tif(visited[x][y][d][m]) return false;\n\n\tif(program[y][x] == '?') {\n\t\tfor(int i = 0; i < 4; ++i) visited[x][y][i][m] = true;\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tif(dfs((x + dx[i] + w) % w, (y + dy[i] + h) % h, i, m)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\telse {\n\t\tvisited[x][y][d][m] = true;\n\t\treturn dfs((x + dx[d] + w) % w, (y + dy[d] + h) % h, d, m);\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> h >> w;\n\n\tfor(int i = 0; i < h; ++i) cin >> program[i];\n\tcout << (dfs(0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  int var, x, y, dir;\n  State(int v, int _x, int _y, int d) : var(v), x(_x), y(_y), dir(d) {}\n};\n\nstring s[22];\nint row, col, dp[22][22];\n\ninline int c2dir(char c) {\n  return c == '^' ? 0 : ( c == '>' ? 1 : ( c == 'v' ? 2 : 3 ) );\n}\n\ninline int c2i(char c) { return 0 + (c - '0'); }\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nint main() {\n  cin >> row >> col;\n  rep (i,row) cin >> s[i];\n  memset(dp, 0, sizeof dp);\n  bool will_be_stopped = false;\n    \n  queue<State> q;\n  q.push(State(0, 0, 0, 1));\n\n  while (!q.empty()) {\n    State i = q.front(); q.pop();\n    if (dp[i.y][i.x] >> i.var & 1) continue;\n    dp[i.y][i.x] |= (1 << i.var);\n    char c = s[i.y][i.x];\n    //printf(\"(%d,%d:%d) -> \", i.x, i.y, i.var);\n\n    if (c == '>' || c == '<' || c == '^' || c == 'v') {\n      i.dir = c2dir(c);\n    } else if (c == '_' || c == '|') {\n      i.dir = c == '_' ? (i.var == 0 ? 1 : 3 ) : (i.var == 0 ? 2 : 0);\n      //if (c == '_') { i.dir = i.var == 0 ? 1 : 3; }\n      //else { i.dir = i.var == 0 ? 2 : 0; }\n    } else if (c == '?') {\n      rep (j,4) {\n        int tx = i.x + dx[j], ty = i.y + dy[j];\n        if (tx == -1) { tx = col-1; }\n        else if (tx == col) { tx = 0; }\n        if (ty == -1) { ty = row-1; }\n        else if (ty == row) { ty = 0; }\n        q.push(State(i.var, tx, ty, j));\n      }\n      continue;\n    } else if (c == '@') {\n      will_be_stopped = true; break;\n    } else if (c == '+' || c == '-') {\n      c == '+' ? i.var++ : i.var--;\n      if (i.var == -1) i.var = 15;\n      else if (i.var == 16) i.var = 0;\n    } else if (c == '.') {\n    } else if (c >= '0' && c <= '9') {\n      i.var = c2i(c);\n    }\n    \n    int nx = dx[i.dir] + i.x, ny = dy[i.dir] + i.y;\n    if (nx == -1) { nx = col-1; }\n    else if (nx == col) { nx = 0; }\n    if (ny == -1) { ny = row-1; }\n    else if (ny == row) { ny = 0; }\n    //printf(\"(%d,%d:%d)\\n\", nx, ny, i.var);\n    q.push(State(i.var, nx, ny, i.dir));\n  }\n  \n  printf(\"%s\\n\", (will_be_stopped) ? \"YES\" : \"NO\" );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n  \nconst int MAXR = 21;\nconst int MAXC = 21;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n  \nstruct State {\n  int i, j, d, m;\n  State();\n  State(int i, int j, int d, int m)\n    : i(i), j(j), d(d), m(m) {}\n};\n  \nint R, C;\nchar G[MAXR][MAXC];\nbool vis[MAXR][MAXC][4][16];\n  \nbool canFinish() {\n  State s(0,0,0,0);\n  queue<State> que;\n  que.push(s);\n  fill(vis[0][0][0], vis[MAXR][0][0], false);\n  vis[s.i][s.j][s.d][s.m] = true;\n  \n  while(!que.empty()) {\n    s = que.front();\n    que.pop();\n  \n    if(isdigit(G[s.i][s.j])) {\n      s.m = G[s.i][s.j] - '0';\n    } else {\n      switch(G[s.i][s.j]) {\n      case '<':\n        s.d = 2;\n        break;\n      case '>':\n        s.d = 0;\n        break;\n      case '^':\n        s.d = 3;\n        break;\n      case 'v':\n        s.d = 1;\n        break;\n      case '_':\n        if(s.m == 0) s.d = 0;\n        else s.d = 2;\n        break;\n      case '|':\n        if(s.m == 0) s.d = 1;\n        else s.d = 3;\n        break;\n      case '?':\n        s.d = -1;\n        break;\n      case '.':\n        //\n        break;\n      case '@':\n        return true;\n      case '+':\n        s.m = (s.m+1)%16;\n        break;\n      case '-':\n        s.m = (s.m-1+16)%16;\n        break;\n      }\n    }\n  \n    vector<State> next;\n    if(s.d == -1) {\n      for(s.d = 0; s.d < 4; ++s.d) {\n        next.push_back(s);\n      }\n    } else {\n      next.push_back(s);\n    }\n  \n    for(int k = 0; k < next.size(); ++k) {\n      State &t = next[k];\n      t.i = (t.i + di[t.d] + R) % R;\n      t.j = (t.j + dj[t.d] + C) % C;\n      if(vis[t.i][t.j][t.d][t.m]) continue;\n      vis[t.i][t.j][t.d][t.m] = true;\n      que.push(t);\n    }\n  }\n  return false;\n}\n  \nint main() {\n  while(cin >> R >> C) {\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    if(canFinish()) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, State& state) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col, State state) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    //cout<<program[row][col]<<\" \";\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col], state);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (C-1 < nx) nx = 0;\n            if (nx < 0) nx = C-1;\n            if (R-1 < ny) ny = 0;\n            if (ny < 0) ny = R-1;\n            dfs(ny, nx, state);\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        if (C-1 < nx) nx = 0;\n        if (nx < 0) nx = C-1;\n        if (R-1 < ny) ny = 0;\n        if (ny < 0) ny = R-1;\n        dfs(ny, nx, state);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    State state(0, 0, 0, 0);\n    dfs(0, 0, state);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAXR = 21;\nconst int MAXC = 21;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nstruct State {\n  int i, j, d, m;\n  State();\n  State(int i, int j, int d, int m) \n    : i(i), j(j), d(d), m(m) {}\n};\n\nint R, C;\nchar G[MAXR][MAXC];\nbool vis[MAXR][MAXC][4][16];\n\nbool canFinish() {\n  State s(0,0,0,0);\n  queue<State> que;\n  que.push(s);\n  fill(vis[0][0][0], vis[MAXR][0][0], false);\n  vis[s.i][s.j][s.d][s.m] = true;\n\n  while(!que.empty()) {\n    s = que.front();\n    que.pop();\n\n    if(isdigit(G[s.i][s.j])) {\n      s.m = G[s.i][s.j] - '0';\n    } else {\n      switch(G[s.i][s.j]) {\n      case '<':\n\ts.d = 2;\n\tbreak;\n      case '>':\n\ts.d = 0;\n\tbreak;\n      case '^':\n\ts.d = 3;\n\tbreak;\n      case 'v':\n\ts.d = 1;\n\tbreak;\n      case '_':\n\tif(s.m == 0) s.d = 0;\n\telse s.d = 2;\n\tbreak;\n      case '|':\n\tif(s.m == 0) s.d = 1;\n\telse s.d = 3;\n\tbreak;\n      case '?':\n\ts.d = -1;\n\tbreak;\n      case '.':\n\t//\n\tbreak;\n      case '@':\n\treturn true;\n      case '+':\n\ts.m = (s.m+1)%16;\n      case '-':\n\ts.m = (s.m-1+16)%16;\n      }\n    }\n\n    vector<State> next;\n    if(s.d == -1) {\n      for(s.d = 0; s.d < 4; ++s.d) {\n\tnext.push_back(s);\n      }\n    } else {\n      next.push_back(s);\n    }\n\n    for(int k = 0; k < next.size(); ++k) {\n      State &t = next[k];\n      t.i = (t.i + di[t.d] + R) % R;\n      t.j = (t.j + dj[t.d] + C) % C;\n      if(vis[t.i][t.j][t.d][t.m]) continue;\n      vis[t.i][t.j][t.d][t.m] = true;\n      que.push(t);\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> R >> C) {\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    if(canFinish()) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int mem=0;mem<=15;mem++){\n    for(int dir=0;dir<4;dir++){\n      if(visited[gx][gy][mem][dir]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nstruct Task {\n\tint x, y, mem, dir;\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\nbool passed[20][20][16][4] = { { { { false } } } };\n\nint main(){\n\tint R, C;\n\tcin >> R >> C;\n\tvector<string> program(R);\n\tfor(int i = 0; i < R; ++i){ cin >> program[i]; }\n\tint x = 0, y = 0, mem = 0, dir = 0;\n\tbool answer = false;\n\tvector<Task> tasks;\n\tTask initial = { 0, 0, 0, 0 };\n\ttasks.push_back(initial);\n\twhile(!answer && !tasks.empty()){\n\t\tTask &task = tasks.back();\n\t\tpassed[task.y][task.x][task.mem][task.dir] = true;\n\t\tif(program[task.y][task.x] == '?'){\n\t\t\tTask t = task;\n\t\t\ttasks.pop_back();\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tTask next = t;\n\t\t\t\tnext.dir = i;\n\t\t\t\tnext.x = (next.x + C + dx[next.dir]) % C;\n\t\t\t\tnext.y = (next.y + R + dy[next.dir]) % R;\n\t\t\t\tif(!passed[next.y][next.x][next.mem][next.dir]){\n\t\t\t\t\ttasks.push_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(isdigit(program[task.y][task.x])){\n\t\t\t\ttask.mem = program[task.y][task.x] - '0';\n\t\t\t}else{\n\t\t\t\tswitch(program[task.y][task.x]){\n\t\t\t\tcase '<': task.dir = 2; break;\n\t\t\t\tcase '>': task.dir = 0; break;\n\t\t\t\tcase '^': task.dir = 1; break;\n\t\t\t\tcase 'v': task.dir = 3; break;\n\t\t\t\tcase '_': task.dir = (task.mem == 0 ? 0 : 2); break;\n\t\t\t\tcase '|': task.dir = (task.mem == 0 ? 3 : 1); break;\n\t\t\t\tcase '+': task.mem = (task.mem + 1) & 0x0f; break;\n\t\t\t\tcase '-': task.mem = (task.mem - 1) & 0x0f; break;\n\t\t\t\tcase '@': answer = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttask.x = (task.x + C + dx[task.dir]) % C;\n\t\t\ttask.y = (task.y + R + dy[task.dir]) % R;\n\t\t\tif(passed[task.y][task.x][task.mem][task.dir]){ tasks.pop_back(); }\n\t\t}\n\t}\n\tcout << (answer ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2262 : Stopping Problem **/\nvector<string> b;\nbool vis[4][20][20][16];\nint R, C;\n\nbool solve(int d, int x, int y, int m)\n{\n\twhile (1) {\n\t\tchar c = b[y][x];\n\t\t\n\t\tif (c == '<')\n\t\t\td = 3;\n\t\telse if (c == '>')\n\t\t\td = 1;\n\t\telse if (c == '^')\n\t\t\td = 0;\n\t\telse if (c == 'v')\n\t\t\td = 2;\n\t\t\n\t\telse if (c == '_') {\n\t\t\tif (m == 0)\n\t\t\t\td = 1;\n\t\t\telse\n\t\t\t\td = 3;\n\t\t}\n\t\t\n\t\telse if (c == '|') {\n\t\t\tif (m == 0)\n\t\t\t\td = 2;\n\t\t\telse\n\t\t\t\td = 0;\n\t\t}\n\t\t\n\t\telse if (c == '.')\n\t\t\t;\n\t\t\n\t\telse if (c == '@')\n\t\t\treturn true;\n\t\t\n\t\telse if (isdigit(c)) {\n\t\t\tm = c-'0';\n\t\t}\n\t\t\n\t\telse if (c == '+') {\n\t\t\tm++; if (m==16) m=0;\n\t\t}\n\t\t\n\t\telse if (c == '-') {\n\t\t\tm--; if (m<0) m=15;\n\t\t}\n\t\t\n\t\telse if (c == '?') {\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tnx = (x+C)%C;\n\t\t\t\tny = (y+R)%R;\n\t\t\t\t\n\t\t\t\tif (vis[i][nx][ny][m]) continue;\n\t\t\t\tvis[i][nx][ny][m] = true;\n\t\t\t\t\n\t\t\t\tif (solve(i, nx, ny, m))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tx += dx[d], y += dy[d];\n\t\tx = (x+C)%C;\n\t\ty = (y+R)%R;\n\t\t\n\t\tif (vis[d][x][y][m])\n\t\t\treturn false;\n\t\tvis[d][x][y][m] = true;\n\t}\n}\n\nint main()\n{\n\tcin>>R>>C;\n\tb.resize(R);\n\trep(i, R) cin>>b[i];\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tvis[0][1][0][0] = true;\n\tcout << (solve(1, 0, 0, 0)?\"YES\":\"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX][4][16];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, int& dir, int& memory) {\n    switch (symbol) {\n        case '<':\n            dir = 2;\n            break;\n\n        case '>':\n            dir = 0;\n            break;\n\n        case '^':\n            dir = 1;\n            break;\n\n        case 'v':\n            dir = 3;\n            break;\n\n        case '_':\n            if (memory == 0) dir = 0;\n            else dir = 2;\n            break;\n\n        case '|':\n            if (memory == 0) dir = 3;\n            else dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (memory == 15) memory = 0;\n            else memory++;\n            break;\n\n        case '-':\n            if (memory == 0) memory = 15;\n            else memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            memory = num;\n            break;\n    }\n}\n\nbool dfs(int row, int col, int dir, int memory) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row][dir][memory]) return false;\n    else log[col][row][dir][memory] = true;\n\n    analyzer(program[row][col], dir, memory);\n\n    if (stop) return true;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            nx = (nx + C) % C;\n            ny = (ny + R) % R;\n            if (dfs(ny, nx, i, memory)) return true;\n        }\n        return false;\n    }else {\n        nx = col + dx[dir];\n        ny = row + dy[dir];\n        nx = (nx + C) % C;\n        ny = (ny + R) % R;\n        return dfs(ny, nx, dir, memory);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    dfs(0, 0, 0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2262 : Stopping Problem **/\nvector<string> b;\nbool vis[4][20][20][16];\nint R, C;\n\nbool solve(int d, int x, int y, int m)\n{\n\twhile (1) {\n\t\tchar c = b[y][x];\n\t\t\n\t\tif (c == '<')\n\t\t\td = 3;\n\t\telse if (c == '>')\n\t\t\td = 1;\n\t\telse if (c == '^')\n\t\t\td = 0;\n\t\telse if (c == 'v')\n\t\t\td = 2;\n\t\t\n\t\telse if (c == '_') {\n\t\t\tif (m == 0)\n\t\t\t\td = 1;\n\t\t\telse\n\t\t\t\td = 3;\n\t\t}\n\t\t\n\t\telse if (c == '|') {\n\t\t\tif (m == 0)\n\t\t\t\td = 2;\n\t\t\telse\n\t\t\t\td = 0;\n\t\t}\n\t\t\n\t\telse if (c == '.')\n\t\t\t;\n\t\t\n\t\telse if (c == '@')\n\t\t\treturn true;\n\t\t\n\t\telse if (isdigit(c)) {\n\t\t\tm = c-'0';\n\t\t}\n\t\t\n\t\telse if (c == '+') {\n\t\t\tm++; if (m==16) m=0;\n\t\t}\n\t\t\n\t\telse if (c == '-') {\n\t\t\tm--; if (m<0) m=15;\n\t\t}\n\t\t\n\t\telse if (c == '?') {\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif (x < 0) x = C-1;\n\t\t\t\telse if (x>=C) x = 0;\n\t\t\t\tif (y < 0) y = R-1;\n\t\t\t\tif (y >= R) y = 0;\n\t\t\t\t\n\t\t\t\tif (vis[i][nx][ny][m]) continue;\n\t\t\t\tvis[i][nx][ny][m] = true;\n\t\t\t\t\n\t\t\t\tif (solve(i, x, y, m))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (vis[d][x][y][m])\n\t\t\treturn false;\n\t\tvis[d][x][y][m] = true;\n\t\t\n\t\tx += dx[d], y += dy[d];\n\t\tif (x < 0) x = C-1;\n\t\telse if (x>=C) x = 0;\n\t\tif (y < 0) y = R-1;\n\t\tif (y >= R) y = 0;\n\t}\n}\n\nint main()\n{\n\tcin>>R>>C;\n\tb.resize(R);\n\trep(i, R) cin>>b[i];\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tcout << (solve(1, 0, 0, 0)?\"Yes\":\"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n\nusing namespace std;\n\nbool p[20][20][16][4];\nint r,c;\nchar g[20][21];\n\nbool dfs(int,int,int,int);\n\nbool mv(int x,int y,int m,int d){\n  int dx[]={1,0,-1,0};\n  int dy[]={0,1,0,-1};\n  return dfs((x+dx[d])%c,(y+dy[d])%r,m,d);\n}\n\nbool dfs(int x,int y,int m,int d){\n  if(p[x][y][m][d]++){\n    return false;\n  }else{\n    char c=g[y][x];\n    if(c=='<'){\n      d=2;\n    }else if(c=='>'){\n      d=0;\n    }else if(c=='^'){\n      d=3;\n    }else if(c=='v'){\n      d=1;\n    }else if(c=='_'){\n      d=m?2:0;\n    }else if(c=='|'){\n      d=m?3:1;\n    }else if(c=='?'){\n      for(int i=0;i<4;i++){\n\tif(mv(x,y,m,i)){\n\t  return true;\n\t}\n      }\n      return false;\n    }else if(c=='@'){\n      return true;\n    }else if(isdigit(c)){\n      m=c-'0';\n    }else if(c=='+'){\n      m=(m+1)%16;\n    }else if(c=='-'){\n      m=(m+15)%16;\n    }\n    return mv(x,y,m,d);\n  }\n}\n      \n\nint main(){\n  cin>>r>>c;\n  for(int i=0;i<r;i++){\n    cin>>g[i];\n  }\n  cout<<(dfs(0,0,0,0)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tint x,y,p;\n\tchar mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> visited){\n  while(code[A.y][A.x]!='@'){\n  \tif(count(visited.begin(),visited.end(),A))return false;\n  \tvisited.push_back(A);\n  \t//cerr<<A.x<<\",\"<<A.y<<endl;\n  \tif(code[A.y][A.x]=='>')A.p=0;\n  \tif(code[A.y][A.x]=='v')A.p=1;\n  \tif(code[A.y][A.x]=='<')A.p=2;\n  \tif(code[A.y][A.x]=='^')A.p=3;\n  \tif(code[A.y][A.x]=='_')A.p=(A.mem)?2:0;\n  \tif(code[A.y][A.x]=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=code[A.y][A.x]&&code[A.y][A.x]<='9')A.mem=code[A.y][A.x]-'0';\n   \tif(code[A.y][A.x]=='+')A.mem=(A.mem+1)%16;\n   \tif(code[A.y][A.x]=='-')A.mem=(A.mem+15)%16;\n   \tif(code[A.y][A.x]=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p])%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4])%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p])%c;A.y=(A.y+pos[(A.p+3)%4])%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[20];\nbool memo[20][20][4][16];\nint W, H;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"<>^v\";\n\nchar change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[x][y][d][mem])\n    return false;\n  else\n    memo[x][y][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '_') \n    d = mem ? 0 : 1;\n  else if (ch == '|') \n    d = mem ? 2 : 3;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) \n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\treturn true;\n    return false;\n  }\n  else if (ch == '.')\n    ;\n  else if (ch == '@')\n    return true;\n  else if ('0' <= ch && ch <= '9') \n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else \n    d = change(ch);\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tchar x,y,p,mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> &visited){\n  char op=code[A.y][A.x];\n  while(op!='@'){\n  \tif(count(visited.begin(),visited.end(),A))return false;\n  \tvisited.push_back(A);\n  \top=code[A.y][A.x];\n  \t//cerr<<A.x<<\",\"<<A.y<<endl;\n  \tif(op=='>')A.p=0;\n  \tif(op=='v')A.p=1;\n  \tif(op=='<')A.p=2;\n  \tif(op=='^')A.p=3;\n  \tif(op=='_')A.p=(A.mem)?2:0;\n  \tif(op=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=op&&op<='9')A.mem=op-'0';\n   \tif(op=='+')A.mem=(A.mem+1)%16;\n   \tif(op=='-')A.mem=(A.mem+15)%16;\n   \tif(op=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p]+c)%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4]+r)%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p])%c;A.y=(A.y+pos[(A.p+3)%4])%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint W, H;\nchar board[22][22];\nint dy[] = {-1,1,0,0};\nint dx[] = {0,0,1,-1};\nbool visited[22][22][22][4];\n\nbool dfs(int y, int x, int a, int d){\n\tif(y==-1) y=H-1;\n\tif(y==H) y = 0;\n\tif(x==-1) x=W-1;\n\tif(x==W) x = 0;\n\tif(visited[y][x][a][d]) return false;\n\tvisited[y][x][a][d] = true;\n\tif(board[y][x]=='@') return true;\n\tif(board[y][x]=='<'){d = 3; return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='>'){d = 2; return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='^'){d = 0; return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='v'){d = 1; return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='_'){d = (a?3:2); return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='|'){d = (a?0:1); return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='.' || board[y][x]=='G'){return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='+'){a = ((a+1)&15); return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='-'){a = ((a-1)&15); return dfs(y+dy[d],x+dx[d],a,d); }\n\tif(board[y][x]=='?'){\n\t\tfor(d=0; d<4; d++){\n\t\t\tif(dfs(y+dy[d],x+dx[d],a,d)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\ta = (board[y][x]&15);\n\treturn dfs(y+dy[d], x+dx[d], a, d);\n}\n\nint main(){\n\tscanf(\"%d%d \",&H,&W);\n\tfor(int i=0; i<H; i++){\n\t\tscanf(\"%s \",board[i]);\n\t}\n\tputs(dfs(0,0,0,2)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nenum dir{ RIGHT = 0, UP = 1, LEFT = 2, DOWN = 3 };\n\nstruct state{\n    int x;\n    int y;\n    int mem;\n    dir vec;\n    state(){}\n    ~state(){}\n    state(int a, int b, int v, dir d): x(a), y(b), mem(v), vec(d) {}\n}; \nint main(){\n    string str[20];\n    bool visited[20][20][16];\n    int r, c;\n    cin >> r >> c;\n    for(int i = 0; i < r; i++){\n        cin >> str[i];\n        for(int j = 0; j < c; j++){\n            for(int k = 0; k < 16; k++){\n                visited[i][j][k] = false;\n            }\n        }\n    }\n    queue<state> que;\n    que.push(state(0, 0, 0, (dir)0));\n    bool stop = false;\n    while(!que.empty()){\n        state s = que.front(); que.pop();\n        int x = s.x, y = s.y;\n        if(visited[x][y][s.mem]) continue;\n        visited[x][y][s.mem] = true;\n        if(str[x][y] == '@'){\n            stop = true;\n            break;\n        }\n        if(str[x][y] == '?'){\n            for(int i = 0; i < 4; i++){\n                que.push(state((x+dx[i]+r)%r, (y+dy[i]+c)%c, s.mem, (dir)i));\n            }\n            continue;\n        }\n        if(str[x][y] == '<'){\n            s.vec = LEFT;\n        }\n        if(str[x][y] == '>'){\n            s.vec = RIGHT;\n        }\n        if(str[x][y] == '^'){\n            s.vec = UP;\n        }\n        if(str[x][y] == 'v'){\n            s.vec = DOWN;\n        }\n        if(str[x][y] == '_'){\n            if(s.mem == 0){\n                s.vec = RIGHT;\n            }else{\n                s.vec = LEFT;\n            }\n        }\n        if(str[x][y] == '|'){\n            if(s.mem == 0){\n                s.vec = DOWN;\n            }else{\n                s.vec = UP;\n            }\n        }\n        if('0' <= str[x][y] && str[x][y] <= '9'){\n            s.mem = str[x][y] - '0';\n        }\n        if(str[x][y] == '+'){\n            s.mem = (s.mem+1)%16;\n        }\n        if(str[x][y] == '-'){\n            s.mem = (s.mem+15)%16;\n        }\n        que.push(state((x+dx[s.vec]+r)%r, (y+dy[s.vec]+c)%c, s.mem, s.vec));\n    }\n    if(stop){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><v^\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (order[y][x] == '@')\n    return true;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') {\n    if (mem == 0)\n      d = change('>');\n    else \n      d = change('<');\n  }\n  else if (ch == '|') {\n    if (mem == 0)\n      d = change('v');\n    else\n      d = change('^');\n  }\n  else if (ch >= '0' && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    (mem == 15) ? (mem = 0) : mem++;\n  else if (ch == '-')\n    (mem == 0) ? (mem = 15) : mem--;\n\n\n  if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n  }\n  else \n    return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  while (cin >> H >> W) {\n    for (int i = 0; i < H; i++)\n      cin >> order[i];\n\n    if (dfs(0, 0, 0, 0))\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  \n  State st=State(0,0,0,0), ne=State(0,0,0,0);\n  while(!Q.empty()) {\n    st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+16)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tchar x,y,p,mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> &visited){\n  char op=code[A.y][A.x];\n  while(op!='@'){\n  \tif(count(visited.begin(),visited.end(),A))return false;\n  \tvisited.push_back(A);\n  \top=code[A.y][A.x];\n  \t//cerr<<(int)A.x<<\",\"<<(int)A.y<<endl;\n  \tif(op=='>')A.p=0;\n  \tif(op=='v')A.p=1;\n  \tif(op=='<')A.p=2;\n  \tif(op=='^')A.p=3;\n  \tif(op=='_')A.p=(A.mem)?2:0;\n  \tif(op=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=op&&op<='9')A.mem=op-'0';\n   \tif(op=='+')A.mem=(A.mem+1)%16;\n   \tif(op=='-')A.mem=(A.mem+15)%16;\n   \tif(op=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p]+c)%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4]+r)%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p]+c)%c;A.y=(A.y+pos[(A.p+3)%4]+r)%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><v^\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 1 : 0;\n  else if (ch == '|') \n    d = mem ? 3 : 2;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n    for(int i=0;i<=20;i++){\n      memset(visited[i],0,sizeof(visited[i]));\n    }\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool used[30][30][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s[30];\nint h,w,m;\nvoid END(){\n  cout<<\"YES\"<<endl;\n  exit(0);\n}\nvoid dfs(int x,int y,int d){\n  while(1){\n    if(used[y][x][d])return ;\n    used[y][x][d]=1;\n    x+=dx[d];\n    y+=dy[d];\n    x+=w;\n    y+=h;\n    x%=w;\n    y%=h;\n    if(s[y][x]=='<'){d=3;}\n    else if(s[y][x]=='>'){d=1;}\n    else if(s[y][x]=='^'){d=0;}\n    else if(s[y][x]=='v'){d=2;}\n    else if(s[y][x]=='_'){\n      if(m)d=3;\n      else d=1;\n    }\n    else if(s[y][x]=='|'){\n      if(m)d=2;\n      else d=0;\n    }\n    else if(s[y][x]=='?'){\n      r(i,4)dfs(x,y,i);\n    }\n    else if(s[y][x]=='.'){}\n    else if(s[y][x]=='@'){END();}\n    else if(s[y][x]=='-'){m=(m-1+15)%15;}\n    else if(s[y][x]=='+'){m=(m+1)%15;}\n    else if(isdigit(s[y][x])){m=s[y][x]-'0';}\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  dfs(0,0,1);\n  cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\nint R,C,d[]={0,1,0,-1,0},f[20][20][16][4];\nchar M[20][21];\nint F(int x,int y,int m,int a)\n{\n\tx=(x+C)%C;\n\ty=(y+R)%R;\n\tif(f[x][y][m][a]++)return 0; \n\tchar c=M[y][x];\n\tif(c=='@')return 1;\n\tif(c=='?')\n\t{\n\t\tint r=0,i;\n\t\tfor(i=0;i<4;++i)r=r||F(x+d[i],y+d[i+1],m,i);\n\t\treturn r;\n\t}\n\tif(isdigit(c))m=c-'0';\n\tif(c=='^')a=0;\n\tif(c=='>')a=1;\n\tif(c=='v')a=2;\n\tif(c=='<')a=3;\n\tif(c=='_')a=(m?3:1);\n\tif(c=='|')a=(m?2:0);\n\tif(c=='+')m=(m+1)%16;\n\tif(c=='-')m=(m+15)%16;\n\treturn F(x+d[a],y+d[a+1],m,a);\n}\nint main()\n{\n\tscanf(\"%d%d\",&R,&C);\n\tfor(int i=0;i<R;++i)scanf(\"%s\",M[i]);\n\treturn puts(F(0,0,0,1)?\"YES\":\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDirBits;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=(1<<_dir);\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    dir = 0;\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int mem=0;mem<=15;mem++){\n    for(int dir=0;dir<4;dir++){\n      if(visited[gx][gy][mem][dir]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM next_dir_mem = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(next_dir_mem.mDirBits & (1<<dir))) continue;\n\tint dx = (tx[dir] + x + W) % W;\n\tint dy = (ty[dir] + y + H) % H;\n\n\tif(visited[dx][dy][next_dir_mem.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,next_dir_mem.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][next_dir_mem.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <cctype>\n#define Pf p.first\n#define Ps p.second\n#define PP mas[Ps][Pf]\nusing namespace std;\n\ntypedef pair<int,int> P;\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nchar mas[101][101];\nbool used[50][50][4][16];\nint w,h,muki = 0 ,memo = 0;\n\nP move(P p,int i){\n    Pf += dx[i];\n    Ps += dy[i];\n    if(Pf < 0) Pf = w-1;\n    else if(Pf >= w) Pf = 0;\n    if(Ps < 0) Ps = h-1;\n    else if(Ps >= h) Ps = 0;\n    return p;\n}\n\nbool solve(P p,int muki){\n    while(1){\n        if(!used[Ps][Pf][muki][memo]) return false;\n        else if(PP == '@') return true;\n        used[Ps][Pf][muki][memo] = false;\n        if(PP == '>') muki = 0;\n        else if(PP == 'v') muki = 1;\n        else if(PP == '<') muki = 2;\n        else if(PP == '^') muki = 3;\n        else if(PP == '_') muki = (memo == 0)? 0 : 2;\n        else if(PP == '|') muki = (memo == 0)? 1 : 3;\n        else if(PP == '.'){}\n        else if(isdigit(PP)) memo = PP - '0';\n        else if(PP == '+') memo = (memo == 15)? 0 : memo + 1;\n        else if(PP == '-') memo = (memo == 0)? 15 : memo - 1;\n        else if(PP == '?'){\n            for(int i=0;i<4;i++){\n                if(solve(move(p,i),i)) return true;\n            }\n            return false;\n        }\n        p = move(p,muki);\n    }\n}\n\nint main(){\n    cin >> h >> w;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++) cin >> mas[i][j];\n    }\n    memset(used,true,sizeof(used));\n    if(solve(P(0,0),0)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nenum dir{ RIGHT = 0, UP = 1, LEFT = 2, DOWN = 3 };\n\nstruct state{\n    int x;\n    int y;\n    int mem;\n    dir vec;\n    state(){}\n    ~state(){}\n    state(int a, int b, int v, dir d): x(a), y(b), mem(v), vec(d) {}\n}; \nint main(){\n    string str[20];\n    bool visited[20][20][16];\n    int r, c;\n    cin >> r >> c;\n    for(int i = 0; i < r; i++){\n        cin >> str[i];\n        for(int j = 0; j < c; j++){\n            for(int k = 0; k < 16; k++){\n                visited[i][j][k] = false;\n            }\n        }\n    }\n    queue<state> que;\n    que.push(state(0, 0, 0, (dir)0));\n    bool stop = false;\n    while(!que.empty()){\n        state s = que.front(); que.pop();\n        int x = s.x, y = s.y;\n        if(visited[x][y][s.mem]) continue;\n        visited[x][y][s.mem] = true;\n        if(str[x][y] == '@'){\n            stop = true;\n            break;\n        }\n        if(str[x][y] == '?'){\n            for(int i = 0; i < 4; i++){\n                que.push(state((x+dx[i]+r)%r, (y+dy[i]+c)%c, s.mem, (dir)i));\n            }\n        }\n        if(str[x][y] == '<'){\n            s.vec = LEFT;\n        }\n        if(str[x][y] == '>'){\n            s.vec = RIGHT;\n        }\n        if(str[x][y] == '^'){\n            s.vec = UP;\n        }\n        if(str[x][y] == 'v'){\n            s.vec = DOWN;\n        }\n        if(str[x][y] == '_'){\n            if(s.mem == 0){\n                s.vec = RIGHT;\n            }else{\n                s.vec = LEFT;\n            }\n        }\n        if(str[x][y] == '|'){\n            if(s.mem == 0){\n                s.vec = DOWN;\n            }else{\n                s.vec = UP;\n            }\n        }\n        if('0' <= str[x][y] && str[x][y] <= '9'){\n            s.mem = str[x][y] - '0';\n        }\n        if(str[x][y] == '+'){\n            s.mem = (s.mem+1)%16;\n        }\n        if(str[x][y] == '-'){\n            s.mem = (s.mem+15)%16;\n        }\n        que.push(state((x+dx[s.vec]+r)%r, (y+dy[s.vec]+c)%c, s.mem, s.vec));\n    }\n    if(stop){\n        cout << \"YES\" << endl;\n    }else{\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct State{\n    int Y,X,M,D;\n};\n\nint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\nbool vis[20][20][16][4]={};\n\nint main()\n{\n    int R,C;\n    cin >>R >>C;\n    vector<string> s(R);\n    rep(i,R) cin >>s[i];\n\n    queue<State> que;\n    que.push({0,0,0,0});\n    vis[0][0][0][0]=true;\n    while(!que.empty())\n    {\n        State S = que.front(); que.pop();\n        int y = S.Y, x = S.X, m = S.M, d = S.D;\n        // printf(\"%d %d %d %d\\n\", y,x,m,d);\n\n        vis[y][x][m][d] = true;\n\n        char c = s[y][x];\n        if(c=='@') break;\n\n        if(c=='?')\n        {\n            rep(i,4)\n            {\n                // move\n                int ny = (y+dy[i]+R)%R;\n                int nx = (x+dx[i]+C)%C;\n                if(!vis[ny][nx][m][i])\n                {\n                    vis[ny][nx][m][i] = true;\n                    que.push({ny,nx,m,i});\n                }\n            }\n        }\n        else\n        {\n            if(c=='<' || c=='>' || c=='v' || c=='^')\n            {\n                if(c=='<') d = 2;\n                if(c=='>') d = 0;\n                if(c=='v') d = 1;\n                if(c=='^') d = 3;\n            }\n            else if(c=='_')\n            {\n                if(m==0) d = 0;\n                else d = 2;\n            }\n            else if(c=='|')\n            {\n                if(m==0) d = 1;\n                else d = 3;\n            }\n            else if('0'<=c && c<='9') m = c-'0';\n            else if(c=='+') m = (m+1)%16;\n            else if(c=='-') m = (m+15)%16;\n\n            // move\n            int ny = (y+dy[d]+R)%R;\n            int nx = (x+dx[d]+C)%C;\n            if(!vis[ny][nx][m][d])\n            {\n                vis[ny][nx][m][d] = true;\n                que.push({ny,nx,m,d});\n            }\n        }\n    }\n\n    string ans = \"NO\";\n    rep(i,R)rep(j,C)if(s[i][j]=='@')\n    {\n        rep(k,16)rep(l,4)if(vis[i][j][k][l]) ans = \"YES\";\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n#define pb(e) push_back(e)\n\ntypedef long long ll;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n    int r, c;\n    string prog[20];\n    cin >> r >> c;\n    rep(i, r) cin >> prog[i];\n    \n    int x = 0, y = 0, dir = 0, mem = 0;\n    rep(i, 100000) {\n        switch(prog[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem == 0 ? 0 : 2); break;\n            case '|': dir = (mem == 0 ? 1 : 3); break;\n            case '?': dir = rand() & 3; break;\n            case '.': break;\n            case '@': cout << \"YES\" << endl; return 0;\n            case '+': mem = (mem + 1) & 15; break;\n            case '-': mem = (mem - 1) & 15; break;\n            default:  mem = prog[y][x] - '0';\n        }\n        x += dx[dir]; y += dy[dir];\n        if(x == -1) x = c - 1;\n        if(x == c) x = 0;\n        if(y == -1) y = r - 1;\n        if(y == r) y = 0;\n    }\n    cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nState state(0, 0, 1, 0);\n\nvoid analyzer(char symbol) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col]);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (0 <= nx && nx < C && 0 <= ny && ny < R) {\n                dfs(ny, nx);\n            }\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        dfs(ny, nx);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint H,W;\nconst int MAX_R = 20;\nconst int MAX_C = 20;\n\nchar data[MAX_R][MAX_C];\nbool vis[16][4][MAX_R][MAX_C];\n\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> data[i][j];\n    }\n  }\n}\n\nbool run(int d,int x,int y,int buf){\n  while(1){\n    switch(data[y][x]){\n    case '<': \n      d = L;\n      break;\n    case '>':\n      d = R;\n      break;\n    case '^':\n      d = U;\n      break;\n    case 'v':\n      d = D;\n      break;\n    case '_':\n      if(buf == 0)d = R;\n      else d = L;\n      break;\n    case '|':\n      if(buf == 0)d = D;\n      else d = U;\n      break;\n    case '?':\n      for(int i = 0 ; i < 4 ; i++){\n\tint nx,ny;\n\tnx = (x + dx[i] + W)%W;\n\tny = (y + dy[i] + H)%H;\n\tif(vis[buf][i][ny][nx])continue;\n\tvis[buf][i][ny][nx] = true;\n\tif(run(i,nx,ny,buf))return true;\n      }\n      break;\n    case '.':\n      break;\n    case '@':\n      return true;\n      break;\n    case '+':\n      buf = (buf+1)%16;\n      break;\n    case '-':\n      buf = (16+buf-1)%16;\n      break;\n    default: // numbe\n      buf = (data[y][x] - '0');\n      break;\n    }\n    x = (x + dx[d] + W)%W;\n    y = (y + dy[d] + H)%H;\n    if(vis[buf][d][y][x])return false;\n    vis[buf][d][y][x] = true;\n  }\n  return false;\n}\n\nint main(){\n  input();\n  for(int ii = 0 ; ii < 16 ; ii++){\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < H ; j++){\n\tfor(int k = 0 ; k < W ; k++){\n\t  vis[ii][i][j][k] = false;\n\t}\n      }\n    }\n  }\n  vis[0][R][0][0] = true;\n  if(run(R,0,0,0))cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n\nusing namespace std;\n\nint r,c;\nchar field[30][30];\n\nconst int dy[]={0,1,0,-1};\nconst int dx[]={1,0,-1,0};\n\nint main(){\n\n  while(cin>>r>>c&&!(r==0&&c==0)){\n    bool passed[30][30][30][30];\n    memset(passed,0,sizeof(passed));\n    // 0:ツ右,1:ツ可コ,2:ツ債カ,3:ツ湘」\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++)\n\tcin>>field[i][j];\n    // ツ債カツ湘」ツつゥツづァツ開ツ始\n    int sx=0;\n    int sy=0;\n    bool isLoop=true;\n    queue<pair<pair<int,int>,pair<int,int> > > *prv\n      =new queue<pair<pair<int,int>,pair<int,int> > >();\n    queue<pair<pair<int,int>,pair<int,int> > > *nxt\n      =new queue<pair<pair<int,int>,pair<int,int > > >();\n    prv->push(make_pair(make_pair(sy,sx),make_pair(0,0)));\n    while(prv->size()){\n      while(prv->size()){\n\tpair<pair<int,int>,pair<int,int> > p=prv->front();prv->pop();\n\tint y=(p.first.first+r)%r;\n\tint x=(p.first.second+c)%c;\n\tint mem=p.second.first;\n\tint angle=p.second.second;\n\tif(passed[y][x][mem][angle])\n\t  continue;\n\tpassed[y][x][mem][angle]=true;\n\tif(field[y][x]=='@'){\n\t  isLoop=false;\n\t  break;\n\t}\n\telse if(field[y][x]=='<'){\n\t  angle=2;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='>'){\n\t  angle=0;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='^'){\n\t  angle=3;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='v'){\n\t  angle=1;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='_'){\n\t  if(mem==0)\n\t    angle=0;\n\t  else\n\t    angle=2;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='|'){\n\t  if(mem==0)\n\t    angle=1;\n\t  else\n\t    angle=3;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='?'){\n\t  for(int i = 0; i < 4; i++){\n\t    nxt->push(make_pair(make_pair(y+dy[i],x+dx[i]),make_pair(mem,angle)));\n\t  }\n\t}\n\telse if(field[y][x]>='0'&&field[y][x]<='9'){\n\t  mem=field[y][x]-'0';\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='+'){\n\t  mem=(mem+1)%16;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse if(field[y][x]=='-'){\n\t  mem=(mem-1+16)%16;\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n\telse{\n\t  nxt->push(make_pair(make_pair(y+dy[angle],x+dx[angle]),make_pair(mem,angle)));\n\t}\n      }\n      if(!isLoop)\n\tbreak;\n      swap(prv,nxt);\n    }\n    if(isLoop){\n      cout<<\"NO\"<<endl;\n    }\n    else\n      cout<<\"YES\"<<endl;\n    delete prv,nxt;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  int var, x, y, dir;\n  State(int v, int _x, int _y, int d) : var(v), x(_x), y(_y), dir(d) {}\n};\n\nstring s[22];\nint row, col, dp[22][22][6];\n\ninline int c2dir(char c) {\n  return c == '^' ? 0 : ( c == '>' ? 1 : ( c == 'v' ? 2 : 3 ) );\n}\n\ninline int c2i(char c) { return 0 + (c - '0'); }\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nint main() {\n  cin >> row >> col;\n  rep (i,row) cin >> s[i];\n  memset(dp, 0, sizeof dp);\n  bool will_be_stopped = false;\n  \n  queue<State> q;\n  q.push(State(0, 0, 0, 1));\n\n  while (!q.empty()) {\n    State i = q.front(); q.pop();\n    if (dp[i.y][i.x][i.dir] >> i.var & 1) continue;\n    dp[i.y][i.x][i.dir] |= (1 << i.var);\n    char c = s[i.y][i.x];\n\n    if (c == '>' || c == '<' || c == '^' || c == 'v') {\n      i.dir = c2dir(c);\n    } else if (c == '_' || c == '|') {\n      i.dir = c == '_' ? (i.var == 0 ? 1 : 3 ) : (i.var == 0 ? 2 : 0);\n    } else if (c == '?') {\n      rep (j,4) {\n        int tx = i.x + dx[j], ty = i.y + dy[j];\n        if (tx == -1) { tx = col-1; } else if (tx == col) { tx = 0; }\n        if (ty == -1) { ty = row-1; } else if (ty == row) { ty = 0; }\n        if (tx < 0 || ty < 0 || tx >= col || ty >= row) continue;\n        q.push(State(i.var, tx, ty, j));\n      }\n      continue;\n    } else if (c == '@') {\n      will_be_stopped = true; break;\n    } else if (c == '+' || c == '-') {\n      c == '+' ? i.var++ : i.var--;\n      if (i.var == -1) i.var = 15;\n      else if (i.var == 16) i.var = 0;\n    } else if (c == '.') {\n    } else if (c >= '0' && c <= '9') {\n      i.var = c2i(c);\n    }\n    \n    int nx = dx[i.dir] + i.x, ny = dy[i.dir] + i.y;\n    if (nx == -1) { nx = col-1; } else if (nx == col) { nx = 0; }\n    if (ny == -1) { ny = row-1; } else if (ny == row) { ny = 0; }\n    q.push(State(i.var, nx, ny, i.dir));\n  }\n  \n  printf(\"%s\\n\", (will_be_stopped) ? \"YES\" : \"NO\" );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><v^\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (order[y][x] == '@')\n    return true;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') {\n    if (mem == 0)\n      d = change('>');\n    else \n      d = change('<');\n  }\n  else if (ch == '|') {\n    if (mem == 0)\n      d = change('v');\n    else\n      d = change('^');\n  }\n  else if (ch >= '0' && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    (mem == 15) ? (mem = 0) : mem++;\n  else if (ch == '-')\n    (mem == 0) ? (mem = 15) : mem--;\n\n\n  if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  else \n    return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  while (cin >> H >> W) {\n    for (int i = 0; i < H; i++)\n      cin >> order[i];\n\n    if (dfs(0, 0, 0, 0))\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\nbool random_flag[MAX][MAX][4];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, int& dir, int& memory) {\n    switch (symbol) {\n        case '<':\n            dir = 2;\n            break;\n\n        case '>':\n            dir = 0;\n            break;\n\n        case '^':\n            dir = 1;\n            break;\n\n        case 'v':\n            dir = 3;\n            break;\n\n        case '_':\n            if (memory == 0) dir = 0;\n            else dir = 2;\n            break;\n\n        case '|':\n            if (memory == 0) dir = 3;\n            else dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (memory == 15) memory = 0;\n            else memory++;\n            break;\n\n        case '-':\n            if (memory == 0) memory = 15;\n            else memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col, int dir, int memory) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col], dir, memory);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            nx = (nx + C) % C;\n            ny = (ny + R) % R;\n            dir = i;\n            dfs(ny, nx, dir, memory);\n        }\n    }else {\n        nx = col + dx[dir];\n        ny = row + dy[dir];\n        nx = (nx + C) % C;\n        ny = (ny + R) % R;\n        dfs(ny, nx, dir, memory);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            for (int k = 0; k < 4; k++) {\n                random_flag[i][j][k] = false;\n            }\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0, 0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct State {\n  int mem, dist, row, col;\n  State(int mem, int dist, int row, int col): mem(mem), dist(dist), row(row), col(col) {;}\n};\n\nint main()\n{\n  int R, C;\n  char field[20][20];\n\n  cin >> R >> C;\n\n  for (int r = 0; r < R; r++)\n    for (int c = 0; c < C; c++)\n      cin >> field[r][c];\n\n  int mem = 0, dist = 0, row = 0, col = 0,\n      dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}, tr, tc;\n\n  // visit[mem][dist][row][col]\n  bool visit[16][4][20][20], ok = false;\n  memset(visit, false, sizeof(visit));\n\n  queue<State> que;\n  que.push(State(0, 0, 0, 0));\n\n  while (true) {\n\n    State s = que.front(); que.pop();\n\n    mem = s.mem;\n    dist = s.dist;\n    row = s.row;\n    col = s.col;\n\n    if (visit[mem][dist][row][col]) {\n      cout << \"NO\" << endl;\n      break;\n    }\n\n    visit[mem][dist][row][col] = true;\n    bool do_push = true;\n\n    switch(field[row][col]) {\n      case '<':\n        dist = 2;\n        break;\n      case '>':\n        dist = 0;\n        break;\n      case '^':\n        dist = 3;\n        break;\n      case 'v':\n        dist = 1;\n        break;\n      case '_':\n        if (mem == 0)\n          dist = 0;\n        else\n          dist = 2;\n        break;\n      case '|':\n        if (mem == 0)\n          dist = 1;\n        else\n          dist = 3;\n        break;\n      case '?':\n        do_push = false;\n        for (dist = 0; dist < 4; dist++) {\n          tr = (row + dy[dist] + R) % R;\n          tc = (col + dx[dist] + C) % C;\n          if (!visit[mem][dist][tr][tc]) \n            que.push(State(mem, dist, tr, tc));\n        }\n        break;\n      case '.':\n        break;\n      case '@':\n        cout << \"YES\" << endl;\n        ok = true;\n        break;\n      case '+':\n        mem = (mem + 1) % 16;\n        break;\n      case '-':\n        mem = (mem - 1 + 16) % 16;\n        break;\n      default:\n        mem = field[row][col] - '0';\n        break;\n    }\n\n    if (ok)\n      break;\n\n    if (do_push) {\n      row = (row + dy[dist] + R) % R;\n      col = (col + dx[dist] + C) % C;\n      que.push(State(mem, dist, row, col));\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 17;\n\nint H, W;\nstring M[MAX_H];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 21;\nconst int  INF = (1<<25);\nconst int DM = 4; //number of direction\nconst int MM = 16;//number that memory can be set\n\n\nchar M[MAX][MAX];\nint T[DM][MM][MAX][MAX];\nint R,C,gx,gy;\nbool ans;\n\nconst int UP = 0;\nconst int RIGHT = 1;\nconst int DOWN = 2;\nconst int LEFT = 3;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nvoid input(){\n  cin >> R >> C;\n  for(int i = 0; i < R; i++)\n    for(int j = 0; j < C; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '@'){\n\tgx = j;\n\tgy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<C&&0<=y&&y<R;}\n    \nvoid dfs(int dir, int mem, int y, int x){\n  \n  if(T[dir][mem][y][x]) return;\n  T[dir][mem][y][x] = true;\n\n  int nx,ny;\n\n  if(x == -1 && y == -1){\n    nx = 0;\n    ny = 0;\n  }else{\n    nx = x+dx[dir];\n    ny = y+dy[dir];\n  }\n\n  //  cout << \"come \" << mem  << \" \" << nx  << \" \" << ny  << M[ny][nx] << endl;\n  //  if(!isInside(nx,ny)) return;\n  if(nx >= C) nx = 0;\n  if(nx < 0) nx = C-1;\n  if(ny >= R) ny = 0;\n  if(ny < 0) ny = R-1;\n  \n  if(M[ny][nx] == '<') dfs(LEFT,mem,ny,nx);\n  if(M[ny][nx] == '>') dfs(RIGHT,mem,ny,nx);\n  if(M[ny][nx] == '^') dfs(UP,mem,ny,nx);\n  if(M[ny][nx] == 'v') dfs(DOWN,mem,ny,nx);\n  if(M[ny][nx] == '_' && mem == 0) dfs(RIGHT,mem,ny,nx);\n  if(M[ny][nx] == '_' && mem != 0) dfs(LEFT,mem,ny,nx);\n  if(M[ny][nx] == '|' && mem == 0) dfs(DOWN,mem,ny,nx);\n  if(M[ny][nx] == '|' && mem != 0) dfs(UP,mem,ny,nx);\n  if(M[ny][nx] == '?') dfs(UP,mem,ny,nx),dfs(RIGHT,mem,ny,nx),dfs(DOWN,mem,ny,nx),dfs(LEFT,mem,ny,nx);\n  if('0' <= M[ny][nx] && M[ny][nx] <= '9') dfs(dir,M[ny][nx]-'0',ny,nx);\n  if(M[ny][nx] == '+') dfs(dir,(mem+1)%16,ny,nx);\n  if(M[ny][nx] == '-') dfs(dir,(mem+15)%16,ny,nx);\n  if(M[ny][nx] == '.') dfs(dir,mem,ny,nx);\n  if(M[ny][nx] == '@'){\n    ans = true;\n    return;\n  }\n}\n\nint main(){\n  input();\n  dfs(RIGHT,0,-1,-1);\n  if(ans) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespcae std;\nint main()\n{\nstring s;\nwhile (cin >> s)\nceer << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\nint r, c;\nchar a[21][21];\n\nstruct St{\n  int x, y, m, d;\n  St() {}\n  St(int _x, int _y, int _m, int _d): x(_x), y(_y), m(_m), d(_d) {}\n};\n\nint ydir[4] = {0, 1, 0, -1}, xdir[4] = {1, 0, -1, 0};\nbool bfs()\n{\n  bool vis[21][21][17];\n  fill(&vis[0][0][0], &vis[20][20][16], true);\n  queue<St> que;\n  que.push(St(0, 0, 0, 0));\n  vis[0][0][0] = false;\n\n  while(!que.empty()){\n    St st = que.front();\n    que.pop();\n    char ch = a[st.y][st.x];\n    bool f = true;\n    if(ch == '@') return true;\n    else if(isdigit(ch)) st.m = (int)(ch-'0');\n    else if(ch == '_') st.d = (st.m == 0)? 0 : 2;\n    else if(ch == '|') st.d = (st.m == 0)? 1 : 3;\n    else if(ch == '+') st.m = (st.m+1)%15;\n    else if(ch == '-') st.m = (st.m == 0)? 15 : (st.m-1);\n    else if(ch == '<') st.d = 2;\n    else if(ch == '>') st.d = 0;\n    else if(ch == '^') st.d = 3;\n    else if(ch == 'v') st.d = 1;\n    else if(ch == '?'){\n      for(int i = 0; i < 4; i++){\n\tint dx = st.x+xdir[i], dy = st.y+ydir[i];\n\tif(0 <= dx < c && 0 <= dy < r && vis[dy][dx][st.m]){\n\t  vis[dy][dx][st.m] = false;\n\t  que.push(St(dx, dy, st.m, i));\n\t}\n      }\n      f = false;\n    }\n\n    if(f){\n      int dx = st.x+xdir[st.d], dy = st.y+ydir[st.d];\n      if(0 <= dx < c && 0 <= dy < r && vis[dy][dx][st.m]){\n\tvis[dy][dx][st.m] = false;\n\tque.push(St(dx, dy, st.m, st.d));\n      }\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>r>>c && (r+c)){\n    for(int i = 0; i < r; i++)\n      for(int j = 0; j < c; j++) cin >> a[i][j];\n\n    cout << ((bfs())? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  stack<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n\n    for(;;){\n      if(grid[y][x] == '?'){\n\tfor(int i=0;i<4;i++){\n\t  int ty = (y+dy[i])%r, tx = (x+dx[i])%c;\n\t  if(v[ty][tx][i][m])continue;\n\t  v[ty][tx][i][m] = true;\n\t  q.push(P2(P(ty,tx),P(i,m)));\n\t}\n\tbreak;\n      }else if(grid[y][x] == '@'){\n\tf = true;\n\tbreak;\n      }else{\n\tif(grid[y][x] == '>')d = 0;\n\telse if(grid[y][x] == 'v')d = 1;\n\telse if(grid[y][x] == '<')d = 2;\n\telse if(grid[y][x] == '^')d = 3;\n\telse if(grid[y][x] == '_'){\n\t  if(m)d = 2;\n\t  else d = 0;\n\t}\n\telse if(grid[y][x] == '|'){\n\t  if(m)d = 3;\n\t  else d = 1;\n\t}\n\telse if(grid[y][x] == '+')m = (m+1)%16;\n\telse if(grid[y][x] == '-')m = (m+15)%16;\n\telse if(grid[y][x] != '.')m = grid[y][x] - '0';\n\t\n\ty = (y+dy[d])%r; x = (x+dx[d])%c;\n\tif(v[y][x][d][m])break;\n\tv[y][x][d][m] = true;\n      }\n    }\n    if(f)break;\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][16];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  visited[s.x][s.y][s.d][s.m] = true;\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C;\n  for(int i = 0; i < R; i++) {\n    for(int j = 0; j < C; j++) {\n      cin >> code[i][j];\n    }\n  }\n  //DbgMap(code,R,C);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][16];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  visited[s.x][s.y][s.d][s.m] = true;\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C;\n  cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint R, C;\nvector< vector<char> > f;\nvector< vector< vector<int> > > visited;\n\nbool solve(int y, int x, int dir, int mem){\n  //cout << x << \" \" << y << endl;\n  if(find(visited[y][x].begin(), visited[y][x].end(), mem) != visited[y][x].end()) return false;\n  visited[y][x].push_back(mem);\n  //if(visited[y][x] == mem) return false;\n  //visited[y][x] = mem;\n  if(f[y][x] == '@') return true;\n  bool res = false;\n  if(f[y][x] == '<'){\n    res |= solve(y, (x-1 + C) % C, 2, mem);\n  }else if(f[y][x] == '>'){\n    res |= solve(y, (x+1 + C) % C, 0, mem);\n  }else if(f[y][x] == '^'){\n    res |= solve((y-1+R) % R, x, 3, mem);\n  }else if(f[y][x] == 'v'){\n    res |= solve((y+1+R) % R, x, 1, mem);\n  }else{\n    int nx, ny;\n    if(dir == 0){\n      nx = (x+1+C)%C;\n      ny = y;\n    }else if(dir == 1){\n      nx = x;\n      ny = (y+1+R) % R;\n    }else if(dir == 2){\n      nx = (x-1 + C) % C;\n      ny = y;\n    }else{\n      nx = x;\n      ny = (y-1+R) % R;\n    }\n\n    if(f[y][x] == '_'){\n      if(mem == 0){\n\tres |= solve(y, (x+1 + C) % C, 0, mem);\n      }else{\n\tres |= solve(y, (x-1 + C) % C, 2, mem);\n      }\n    }else if(f[y][x] == '|'){\n      if(mem == 0){\n\tres |= solve((y+1+R) % R, x, 1, mem);\n      }else{\n\tres |= solve((y-1+R) % R, x, 3, mem);\n      }\n    }else if(f[y][x] == '?'){\n      res |= solve(y, (x-1 + C) % C, 2, mem);\n      res |= solve(y, (x+1 + C) % C, 0, mem);\n      res |= solve((y-1+R) % R, x, 3, mem);\n      res |= solve((y+1+R) % R, x, 1, mem);\n    }else if(f[y][x] == '.'){\n      res |= solve(ny, nx, dir, mem);\n    }else if(isdigit(f[y][x])){\n      res |= solve(ny, nx, dir, f[y][x] - '0');\n    }else if(f[y][x] == '+'){\n      res |= solve(ny, nx, dir, (mem+1 + 16) % 16);\n    }else if(f[y][x] == '-'){\n      res |= solve(ny, nx, dir, (mem-1 + 16) % 16);\n    }\n  }\n  return res;\n}\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> R >> C;\n  f = vector< vector<char> >(R, vector<char>(C));\n  visited = vector< vector< vector<int> > > (R, vector<vector< int> >(C));\n  for(int i = 0; i < R; i++){\n    for(int j = 0; j < C; j++){\n      cin >> f[i][j];\n    }\n  }\n\n  if(solve(0, 0, 0, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 25\n\nint H,W,mem;\nchar field[MAX][MAX];\nbool visited[MAX][MAX][16];\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nvoid Nextpos(int &y,int &x){\n  if(x >= W){\n    x -= W;\n  }else if(y >= H){\n    y -= H;\n  }else if(x < 0){\n    x += W;\n  }else if(y < 0){\n    y += H;\n  }\n}\n\nbool solve(int y,int x,int dir){\n  if(x >= 0 && field[y][x] == '@') return true;\n  if(visited[y][x][mem]) return false;\n  visited[y][x][mem] = true;\n\n  int nx = x + dx[dir], ny = y + dy[dir];\n  Nextpos(ny,nx);\n  \n  if(isdigit(field[ny][nx])){\n    mem = field[ny][nx] - '0';\n  }else{\n    switch(field[ny][nx]){\n    case '>':\n      dir = 0;\n      break;\n    case 'v':\n      dir = 1;\n      break;\n    case '<':\n      dir = 2;\n      break;\n    case '^':\n      dir = 3;\n      break;\n    case '_':\n      dir = (mem == 0 ? 0 : 2);\n      break;\n    case '|':\n      dir = (mem == 0 ? 1 : 3);\n      break;\n    case '?':\n      for(int i = 0 ; i < 4 ; i++){\n        int nnx = nx + dx[i];\n        int nny = ny + dy[i];\n        Nextpos(nny,nnx);\n        if(visited[nny][nnx][mem]) continue;\n        if(solve(nny,nnx,dir)) return true;\n      }\n      break;\n    case '+':\n      mem = (mem == 15 ? 0 : mem+1);\n      break;\n    case '-':\n      mem = (mem == 0 ? 15 : mem-1);\n      break;\n    }\n  }\n  if(solve(ny,nx,dir)) return true;\n  return false;\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n    }\n  }\n  mem = 0;\n  memset(visited,false,sizeof(visited));\n  cout << (solve(0,-1,0) ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nchar t[50][50];\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nbool visited[50][50][4][16];\n\nbool dfs(int py,int px,int dir,int mem){\n  py=(py+H)%H;\n  px=(px+W)%W;\n  char ch=t[py][px];\n  if(visited[py][px][dir][mem])return false;\n  visited[py][px][dir][mem]=true;\n  \n  if(ch=='@'){\n    return true;\n  }else if(ch=='<' || (ch=='_'&&mem!=0) ){\n    dir=3;\n  }else if(ch=='>' || (ch=='_'&&mem==0)){\n    dir=1;\n  }else if(ch=='^' || (ch=='|'&&mem!=0)){\n    dir=0;\n  }else if(ch=='v' || (ch=='|'&&mem==0)){\n    dir=2;\n  }else if(ch=='?'){\n    for(int i=0;i<4;i++){\n      int ny=py+dy[i];\n      int nx=px+dx[i];\n      if( dfs(ny,nx,i,mem) )return true;\n    }\n    return false;\n  }else if('0'<=ch&&ch<='9'){\n    mem=(ch-'0');\n  }else if(ch=='+'){\n    mem=(mem+1)%16;\n  }else if(ch=='-'){\n    mem=(mem+15)%16;\n  }\n  py+=dy[dir];\n  px+=dx[dir];\n  if(dfs(py,px,dir,mem))return true;\n  else return false;\n}\n\nint main(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  cout<< (dfs(0,0,1,0)?\"YES\":\"NO\") <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define dbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define dbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //dbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = st.x+dx[i], ne.y = st.y+dy[i], ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //dbgPass(\"move\");\n      ne.x = (st.x+dx[ne.d]+C)%C, ne.y = (st.y+dy[ne.d]+R)%R;\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //dbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cctype>\nusing namespace std;\n\n#define inRange(x,a,b) (a <= x && x < b)\nint di[4] = {-1, 0, 1, 0};\nint dj[4] = { 0, 1, 0,-1};\n\n// memory, row, column, direction\nbool visit[16][20][20][4] = {};\n\nstruct data{\n    int m, i, j, d;\n};\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n    char mat[h][w];\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> mat[i][j];\n        }\n    }\n    queue<data> q;\n    q.push(data({0, 0, 0, 1}));\n    while(!q.empty()){\n        data x = q.front(); q.pop();\n        int m = x.m, i = x.i, j = x.j, d = x.d;\n        if(mat[i][j] == '@'){\n            cout << \"YES\" << endl;\n            return 0;\n        }\n        if(mat[i][j] == '<')    d = 3;\n        if(mat[i][j] == 'v')    d = 2;\n        if(mat[i][j] == '>')    d = 1;\n        if(mat[i][j] == '^')    d = 0;\n        if(mat[i][j] == '_')    if(m == 0)  d = 1; else d = 3;\n        if(mat[i][j] == '|')    if(m == 0)  d = 2; else d = 0;\n        if(isdigit(mat[i][j]))  m = mat[i][j]-'0';\n        if(mat[i][j] == '+')    m = (m+1)%16;\n        if(mat[i][j] == '-')    m = (m+15)%16;\n\n        if(mat[i][j] == '?'){\n            for(int dir = 0; dir < 4; dir++){\n                int ni = (i+di[dir]+h)%h, nj = (j+dj[dir]+w)%w;\n                if(!visit[m][ni][nj][dir]){\n                    visit[m][ni][nj][dir] = true;\n                    q.push(data({m,ni,nj,dir}));\n                }\n            }\n        }else{\n            int ni = (i+di[d]+h)%h, nj = (j+dj[d]+w)%w;\n            if(!visit[m][ni][nj][d]){\n                visit[m][ni][nj][d] = true;\n                q.push(data({m,ni,nj,d}));\n            }\n        }\n    }\n    cout << \"NO\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  stack<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.front(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n    int ty,tx;\n\n    if(grid[y][x] == '.'){\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '>'){\n      d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == 'v'){\n      d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '<'){\n      d = 2;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '^'){\n      d = 3;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '?'){\n      for(int i=0;i<4;i++){\n\tty = (y+dy[i])%r; tx = (x+dx[i])%c;\n\tif(v[ty][tx][i][m])continue;\n\tv[ty][tx][i][m] = true;\n\tq.push(P2(P(ty,tx),P(i,m)));\n      }\n    }\n    else if(grid[y][x] == '_'){\n      if(m)d = 2;\n      else d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '|'){\n      if(m)d = 3;\n      else d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '+'){\n      m = (m+1)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '-'){\n      m = (m+15)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }else if(grid[y][x] == '@'){\n      f = true;\n      break;\n    }\n    else{\n      m = grid[y][x] - '0';\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int mem=0;mem<=15;mem++){\n    for(int dir=0;dir<4;dir++){\n      if(visited[gx][gy][mem][dir]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = (tx[dir] + x + W) % W;\n\tint dy = (ty[dir] + y + H) % H;\n\n\tif(visited[dx][dy][dm.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nState state(0, 0, 1, 0);\n\nvoid analyzer(char symbol) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col]);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (0 <= nx && nx < C && 0 <= ny && ny < R) {\n                dfs(ny, nx);\n            }\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        dfs(ny, nx);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDirBits;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=(1<<_dir);\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16][4],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int mem=0;mem<=15;mem++){\n    for(int dir=0;dir<4;dir++){\n      if(visited[gx][gy][mem][dir]) return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int H,W;\n  int commands[21][21];\n  bool visited[21][21][16][4];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n\n    que.push(State((1<<1),0,0,0));\n\n    visited[0][0][0][1] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM next_dir_mem = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(next_dir_mem.mDirBits & (1<<dir))) continue;\n\tint dx = (tx[dir] + x + W) % W;\n\tint dy = (ty[dir] + y + H) % H;\n\n\tif(visited[dx][dy][next_dir_mem.mMemory][dir]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,next_dir_mem.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][next_dir_mem.mMemory][dir] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 16;\n\nint H, W;\nstring M[MAX_H];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  case '?':\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i]+W)%W, (y+dy[i]+H)%H, i, mem)) return 1;\n    }\n    return 0;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n  return run((x+dx[dir]+W)%W, (y+dy[dir]+H)%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\nbool random_flag[MAX][MAX][4];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, int& dir, int& memory) {\n    switch (symbol) {\n        case '<':\n            dir = 2;\n            break;\n\n        case '>':\n            dir = 0;\n            break;\n\n        case '^':\n            dir = 1;\n            break;\n\n        case 'v':\n            dir = 3;\n            break;\n\n        case '_':\n            if (memory == 0) dir = 0;\n            else dir = 2;\n            break;\n\n        case '|':\n            if (memory == 0) dir = 3;\n            else dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (memory == 15) memory = 0;\n            else memory++;\n            break;\n\n        case '-':\n            if (memory == 0) memory = 15;\n            else memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col, int dir, int memory) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    cout<<program[row][col]<<\" \";\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col], dir, memory);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            nx = (nx + C) % C;\n            ny = (ny + R) % R;\n            if (random_flag[row][col][i]) return;\n            random_flag[row][col][i] = true;\n            dfs(ny, nx, dir, memory);\n        }\n    }else {\n        nx = col + dx[dir];\n        ny = row + dy[dir];\n        nx = (nx + C) % C;\n        ny = (ny + R) % R;\n        dfs(ny, nx, dir, memory);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            for (int k = 0; k < 4; k++) {\n                random_flag[i][j][k] = false;\n            }\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0, 0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstring>\n#include<queue>\n#define Pf p.first\n#define Ps p.second\n#define Pt MAS[Pf][Ps]\nusing namespace std;\ntypedef pair<int,int>P;\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0},h,w;\nchar MAS[22][22];\nbool used[22][22][4][16]; //縦 横 向き メモリー //\nP moveover(P,int);\nbool search(P p,int MUKI,int memory){\n  // ※向きの順番 右上左下※ //\n  while(true){\n    if(used[Pf][Ps][MUKI][memory]==true) return false; // ループ判定 //\n    else used[Pf][Ps][MUKI][memory] = true;\n\n    if(Pt == '<') MUKI = 2;\n    else if(Pt == '>') MUKI = 0;\n    else if(Pt == '^') MUKI = 1;\n    else if(Pt == 'v') MUKI = 3;\n    else if(Pt == '_') MUKI = (memory==0 ? 0 : 2);\n    else if(Pt == '|') MUKI = (memory==0 ? 3 : 1);\n    else if(Pt == '?'){\n      for(int i=0;i<4;i++){\n\tif(search(moveover(p,i),i,memory)) return true;\n      }\n      return false;\n    }\n    else if(Pt == '@') return true; // Stop!! //\n    else if(Pt == '+') memory == 15 ? memory = 0 : memory++;\n    else if(Pt == '-') memory == 0 ? memory = 15 : memory--;\n    else if(Pt != '.') memory = Pt - '0';\n    p = moveover(p,MUKI);\n  }\n}\nint main(){\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> MAS[i][j];\n    }\n  }\n  memset(used,false,sizeof(used));\n  cout << (search(P(0,0),0,0)?\"YES\":\"NO\") << endl;\n}\nP moveover(P p,int MUKI){\n  Pf += dx[MUKI];\n  Ps += dy[MUKI];\n  if(Pf < 0) Pf = h-1;\n  else if(Pf >= h) Pf = 0;\n  if(Ps < 0) Ps = w-1;\n  else if(Ps >= w) Ps = 0;\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 16;\n\nint H, W;\nstring M[20];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint w, h;\nstring s[21];\n\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\n\nchar f[256] = {0};\nbool ans = false;\nbool memo[21][21][4][16];\n\nvoid init(){\n\tf['>'] = 0;\n\tf['<'] = 1;\n\tf['v'] = 2;\n\tf['^'] = 3;\n\tfor(int y=0 ; y < 21 ; y++ ){\n\t\tfor(int x=0 ; x < 21 ; x++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tfor(int m=0 ; m < 16 ; m++ ){\n\t\t\t\t\tmemo[y][x][i][m] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(int x, int y, int dir, int memory){\n\tif( ans ) return;\n\tif( memo[y][x][dir][memory] ) return;\n\tmemo[y][x][dir][memory] = true;\n\t\n\tif( s[y][x] == '<' || s[y][x] == '>' || s[y][x] == '^' || s[y][x] == 'v' ){\n\t\tdir = f[ s[y][x] ];\n\t\tint mx = (x + dx[dir] + w) % w ;\n\t\tint my = (y + dy[dir] + h) % h ;\n\t\tsolve( mx , my , dir , memory );\n\t}else if( s[y][x] == '_' ){\n\t\tif( memory == 0 ){\n\t\t\tdir = f['>'];\n\t\t\tint mx = (x + dx[dir] + w) % w ;\n\t\t\tint my = (y + dy[dir] + h) % h ;\n\t\t\tsolve( mx , my , dir , memory );\n\t\t}else{\n\t\t\tdir = f['<'];\n\t\t\tint mx = (x + dx[dir] + w) % w ;\n\t\t\tint my = (y + dy[dir] + h) % h ;\n\t\t\tsolve( mx , my , dir , memory );\n\t\t}\n\t}else if( s[y][x] == '|' ){\n\t\tif( memory == 0 ){\n\t\t\tdir = f['v'];\n\t\t\tint mx = (x + dx[dir] + w) % w ;\n\t\t\tint my = (y + dy[dir] + h) % h ;\n\t\t\tsolve( mx , my , dir , memory );\n\t\t}else{\n\t\t\tdir = f['^'];\n\t\t\tint mx = (x + dx[dir] + w) % w ;\n\t\t\tint my = (y + dy[dir] + h) % h ;\n\t\t\tsolve( mx , my , dir , memory );\n\t\t}\n\t}else if( s[y][x] == '+' ){\n\t\tmemory = (memory + 1) % 16;\n\t\tint mx = (x + dx[dir] + w) % w ;\n\t\tint my = (y + dy[dir] + h) % h ;\n\t\tsolve( mx , my , dir , memory );\n\t}else if( s[y][x] == '-' ){\n\t\tmemory = (memory + 15) % 16;\n\t\tint mx = (x + dx[dir] + w) % w ;\n\t\tint my = (y + dy[dir] + h) % h ;\n\t\tsolve( mx , my , dir , memory );\n\t}else if( s[y][x] >= '0' && s[y][x] <= '9' ){\n\t\tmemory = s[y][x] - '0';\n\t\tint mx = (x + dx[dir] + w) % w ;\n\t\tint my = (y + dy[dir] + h) % h ;\n\t\tsolve( mx , my , dir , memory );\n\t}else if( s[y][x] == '.' ){\n\t\tint mx = (x + dx[dir] + w) % w ;\n\t\tint my = (y + dy[dir] + h) % h ;\n\t\tsolve( mx , my , dir , memory );\n\t}else if( s[y][x] == '?' ){\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = (x + dx[i] + w) % w ;\n\t\t\tint my = (y + dy[i] + h) % h ;\n\t\t\tsolve( mx , my , i , memory );\n\t\t}\n\t}else if( s[y][x] == '@' ){\n\t\tans = true;\n\t\treturn;\n\t}\n}\n\nint main(){\n\tinit();\n\t\n\tcin >> h >> w;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> s[y];\n\t}\n\tsolve( 0 , 0 , 0 , 0 );\n\tif( ans )\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint r,c;\nstring s[100];\nbool ans = false;\nint x = 1,y = 0;\nint xi[] = {0,0,1,-1};\nint yi[] = {1,-1,0,0};\nbool memo[100][100][20];\n\nvoid solve(int h,int w,int d){\n\n  if(ans) return;\n  if(memo[h][w][d]) return;\n  if(h < 0) h = r-1;\n  if(w < 0) w = c-1;\n  if(h == r) h = 0;\n  if(w == c) w = 0;\n\n  memo[h][w][d] = true;\n\n  if(s[h][w] == '<') x = -1, y = 0;\n  if(s[h][w] == '>') x = 1, y = 0;\n  if(s[h][w] == '^') x = 0, y = -1;\n  if(s[h][w] == 'v') x = 0, y = 1;\n  if(s[h][w] == '_'){\n    if(!d) x = 1, y = 0;\n    else x = -1, y = 0;\n  }\n  if(s[h][w] == '|'){\n    if(!d) x = 0, y = 1;\n    else x = 0, y = -1;\n  }\n  if(s[h][w] <= '9' && s[h][w] >= '0') d = s[h][w] - '0';\n  if(s[h][w] == '+') d = (++d)%15;\n  if(s[h][w] == '-'){\n    if(!d) d = 15;\n    else d--;\n  }\n  if(s[h][w] == '@') ans = true;\n  if(s[h][w] == '?'){\n    for(int i=0;i<4;i++) solve(h+yi[i],w+xi[i],d);\n  }\n\n  solve(h+y,w+x,d);\n}\n\nint main(){\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++) cin >> s[i];\n\n  solve(0,0,0);\n\n  if(ans) cout << \"YES\";\n  else cout << \"NO\";\n  cout << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  int dx[4] = { 1, -1,  0,  0 };\n  int dy[4] = { 0,  0,  1, -1 };\n\n  long long int r, c;\n  cin >> r >> c;\n\n  vector< string > p;\n\n  for ( long long int i = 0; i < r; i++ ) {\n\n    string in;\n    cin >> in;\n    p.push_back( in );\n\n  }\n\n  queue< long long int > qx, qy, qm, qd;\n  qx.push(0);\n  qy.push(0);\n  qm.push(0);\n  qd.push(0);\n\n  bool ans = false;\n\n  bool f[21][21][16][4] = {};\n\n  while( qx.size() > 0 ) {\n\n    long long int x, y, m, d;\n    x = qx.front();\n    qx.pop();\n    y = qy.front();\n    qy.pop();\n    m = qm.front();\n    qm.pop();\n    d = qd.front();\n    qd.pop();\n\n    for (;;) {\n\n      if ( x == -1 ) x = c - 1;\n      if ( x == c ) x = 0;\n      if ( y == -1 ) y = r - 1;\n      if ( y == r ) y = 0;\n\n      if ( f[y][x][m][d] == true ) {\n\tbreak;\n      }\n\n      if ( p[y][x] == '>' ) {\n\td = 0;\n      }else if ( p[y][x] == '<' ) {\n\td = 1;\n      }else if ( p[y][x] == 'v' ) {\n\td = 2;\n      }else if ( p[y][x] == '^' ) {\n\td = 3;\n      }else if ( p[y][x] == '_' ) {\n\tif ( m == 0 ) {\n\t  d = 0;\n\t}else {\n\t  d = 1;\n\t}\n      }else if ( p[y][x] == '|' ) {\n\tif ( m == 0 ) {\n\t  d = 2;\n\t}else {\n\t  d = 3;\n\t}\n      }else if ( p[y][x] == '@' ) {\n\tans = true;\n\tbreak;\n      }else if ( p[y][x] == '+' ) {\n\tm++;\n\tif ( m == 16 ) m = 0;\n      }else if ( p[y][x] == '-' ) {\n\tm--;\n\tif ( m == -1 ) m = 15;\n      }else if ( p[y][x] == '.' ) {\n      }else if ( p[y][x] == '?' ) {\n\td = 0;\n\tqx.push(x-1);\n\tqy.push(y);\n\tqm.push(m);\n\tqd.push(1);\n\tqx.push(x);\n\tqy.push(y+1);\n\tqm.push(m);\n\tqd.push(2);\n\tqx.push(x);\n\tqy.push(y-1);\n\tqm.push(m);\n\tqd.push(3);\n      }else {\n\tm = p[y][x] - '0';\n      }\n\n      f[y][x][m][d] = true;\n      x += dx[d];\n      y += dy[d];\n\n    }\n\n    if ( ans == true ) break;\n\n  }\n\n  if ( ans == true ) {\n    cout << \"YES\" << endl;\n  }else {\n    cout << \"NO\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  stack<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n    int ty,tx;\n\n    if(grid[y][x] == '.'){\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '>'){\n      d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == 'v'){\n      d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '<'){\n      d = 2;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '^'){\n      d = 3;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '?'){\n      for(int i=0;i<4;i++){\n\tty = (y+dy[i])%r; tx = (x+dx[i])%c;\n\tif(v[ty][tx][i][m])continue;\n\tv[ty][tx][i][m] = true;\n\tq.push(P2(P(ty,tx),P(i,m)));\n      }\n    }\n    else if(grid[y][x] == '_'){\n      if(m)d = 2;\n      else d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '|'){\n      if(m)d = 3;\n      else d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '+'){\n      m = (m+1)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n    else if(grid[y][x] == '-'){\n      m = (m+15)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }else if(grid[y][x] == '@'){\n      f = true;\n      break;\n    }\n    else{\n      m = grid[y][x] - '0';\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      if(v[ty][tx][d][m])continue;\n      v[ty][tx][d][m] = true;\n      q.push(P2(P(ty,tx),P(d,m)));\n    }\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n#define pb(e) push_back(e)\n\ntypedef long long ll;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n    int r, c;\n    string prog[20];\n    cin >> r >> c;\n    rep(i, r) cin >> prog[i];\n    \n    int x = 0, y = 0, dir = 0, mem = 0;\n    rep(i, 1000000) {\n        switch(prog[y][x]) {\n            case '<': dir = 2; break;\n            case '>': dir = 0; break;\n            case '^': dir = 3; break;\n            case 'v': dir = 1; break;\n            case '_': dir = (mem == 0 ? 0 : 2); break;\n            case '|': dir = (mem == 0 ? 1 : 3); break;\n            case '?': dir = rand() & 3; break;\n            case '.': break;\n            case '@': cout << \"YES\" << endl; return 0;\n            case '+': mem = (mem + 1) & 15; break;\n            case '-': mem = (mem - 1) & 15; break;\n            default:  mem = prog[y][x] - '0';\n        }\n        x += dx[dir]; y += dy[dir];\n        if(x == -1) x = c - 1;\n        if(x == c) x = 0;\n        if(y == -1) y = r - 1;\n        if(y == r) y = 0;\n    }\n    cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\nusing namespace std;\n\nint dx[4] = { 0, 1, 0, -1};\nint dy[4] = { 1, 0, -1, 0};\nchar map[22][22];\nbool memo[16][22][22][4];\nint f;\n\nvoid search(int m, int x, int y, int d){\n\tif(memo[m][x][y][d]) return;\n\tmemo[m][x][y][d] = 1;\n\tif(map[x][y] == NULL) return;\n\telse if(map[x][y] >= '0' && map[x][y] <= '9') m = (int)(map[x][y] - '0');\n\n\tswitch(map[x][y]){\n\t\tcase '<': d = 2; break;\n\t  case '>': d = 0; break;\n\t\tcase '^': d = 3; break;\n\t\tcase 'v': d = 1; break;\n\t\tcase '_':\tif(m) d = 2;\n\t\t\t\t\t\t\telse  d = 0;\n\t\t\t\t\t\t\tbreak;\n\t\tcase '|': if(m) d = 3;\n\t\t\t\t\t\t\telse  d = 1;\n\t\t\t\t\t\t\tbreak;\n\t\tcase '+': m = (m+1)%16; break;\n\t\tcase '-': m = (m+15)%16; break;\n\t\tcase '@': f=1; return;\n\t}\n\n\tif(map[x][y] == '?')\n\t\tfor(int i = 0; i < 4; i++) search( m, x + dx[i], y + dy[i], i);\n\telse search( m, x + dx[d], y + dy[d], d);\n}\n\nint main(){\n\tint r,c,i,j;\n\tchar s;\n\tcin >> r >> c;\n\tfor(i = 1; i <= r; i++)\n\t\tfor(j = 1; j <= c; j++){ cin >> s; map[i][j] =s;}\n\n\tsearch( 0, 1, 1, 0);\n\tif(f) cout << \"YES\" <<endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\nstruct Point{int x,y,d,m;};\nint main(){\n  int r,c;\n  cin >> r >> c;\n  string st[25];\n  int i,j,k;\n  for(i=0;i<r;i++) cin >> st[i];\n  Point p,b;\n  int ax[]={1,0,-1,0};\n  int ay[]={0,1,0,-1};\n  p.x=0;p.y=0;p.d=0;p.m=0;\n  queue <Point> q;\n  q.push(p);\n  bool f=true;\n  int vi[25][25][5][20]={{{{}}}};\n\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(vi[p.x][p.y][p.d][p.m]==1) continue;\n    vi[p.x][p.y][p.d][p.m]=1;\n    char x=st[p.y][p.x];\n    if(x=='<'){\n      p.d=2;\n    }else if(x=='>'){\n      p.d=0;\n    }else if(x=='^'){\n      p.d=3;\n    }else if(x=='v'){\n      p.d=1;\n    }else if(x=='_'){\n      if(p.m==0) p.d=0;\n      else p.d=2;\n    }else if(x=='|'){\n      if(p.m==0) p.d=1;\n      else p.d=3;\n    }else if(x=='?'){\n      for(i=0;i<4;i++){\n        b.d=i;\n        b.x=(p.x+c+ax[b.d])%c;\n        b.y=(p.y+r+ay[b.d])%r;\n        b.m=p.m;\n        q.push(b);\n      }\n      continue;\n    }else if(x=='.'){\n    }else if(x=='@'){\n      f=false;\n      break;\n    }else if(x>='0'&&x<='9'){\n      p.m=x-'0';\n    }else if(x=='+'){\n      p.m=(p.m+1)%16;\n    }else if(x=='-'){\n      p.m=(p.m+15)%16;\n    }\n    b.d=p.d;\n    b.x=(p.x+c+ax[b.d])%c;\n    b.y=(p.y+r+ay[b.d])%r;\n    b.m=p.m;\n    q.push(b);\n  }\n  if(f) cout << \"NO\" << endl;\n  else cout << \"YES\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstring>\n#include<queue>\n#define Pf p.first\n#define Ps p.second\n#define Pt MAS[Pf][Ps]\nusing namespace std;\ntypedef pair<int,int>P;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0},h,w,MUKI;\nchar MAS[22][22];\nbool used[22][22][4][16]; //縦 横 向き メモリー //\nP moveover(P,int);\nbool search(P p,int MUKI,int memory){\n  // ※向きの順番 右上左下※ //\n  while(true){\n    if(used[Pf][Ps][MUKI][memory]==true) return false; // ループ判定 //\n    else used[Pf][Ps][MUKI][memory] = true;\n\n    if(Pt == '<') MUKI = 2;\n    else if(Pt == '>') MUKI = 0;\n    else if(Pt == '^') MUKI = 1;\n    else if(Pt == 'v') MUKI = 3;\n    else if(Pt == '_') MUKI = (memory==0 ? 0 : 2);\n    else if(Pt == '|') MUKI = (memory==0 ? 3 : 1);\n    else if(Pt == '?'){\n      for(int i=0;i<4;i++){\n\tif(search(moveover(p,i),i,memory)) return true;\n      }\n      return false;\n    }\n    else if(Pt == '@') return true; // Stop!! //\n    else if(Pt == '+') memory == 15 ? memory = 0 : memory++;\n    else if(Pt == '-') memory == 0 ? memory = 15 : memory--;\n    else if(Pt != '.') memory = Pt - '0';\n    p = moveover(p,MUKI);\n  }\n}\nint main(){\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> MAS[i][j];\n    }\n  }\n  memset(used,false,sizeof(used));\n  cout << (search(P(0,0),0,0)?\"YES\":\"NO\") << endl;\n}\nP moveover(P p,int MUKI){\n  Pf += dx[MUKI];\n  Ps += dy[MUKI];\n  if(Pf < 0) Pf = h-1;\n  else if(Pf >= h) Pf = 0;\n  if(Ps < 0) Ps = w-1;\n  else if(Ps >= w) Ps = 0;\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"<>^v\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '_') \n    d = mem ? 0 : 1;\n  else if (ch == '|') \n    d = mem ? 2 : 3;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '.')\n    ;\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) \n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\treturn true;\n    return false;\n  }\n  else \n    d = change(ch);\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_R = 20;\nconst int MAX_C = 20;\nconst int MAX_M = 16;\n\nconst int dxs[] = {1, 0, -1, 0};\nconst int dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\nenum { D_R, D_U, D_L, D_D };\n\nstruct Stat {\n  int x, y, d, m;\n  Stat() {}\n  Stat(int _x, int _y, int _d, int _m): x(_x), y(_y), d(_d), m(_m) {}\n  void print() { printf(\"(%d,%d)(%d):%d\\n\", x, y, d, m); }\n};\n\n/* global variables */\n\nstring prgs[MAX_R];\nbool used[MAX_R][MAX_C][4][MAX_M];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int r, c;\n  cin >> r >> c;\n\n  memset(used, false, sizeof(used));\n\n  for (int y = 0; y < r; y++) cin >> prgs[y];\n\n  queue<Stat> q;\n  q.push(Stat(0, 0, D_R, 0));\n  used[0][0][D_R][0] = true;\n\n  bool ok = false;\n  \n  while (! q.empty()) {\n    Stat u = q.front(); q.pop();\n    char op = prgs[u.y][u.x];\n    //cout << op; u.print();\n    \n    if (op == '@') {\n      ok = true;\n      break;\n    }\n\n    if (op == '?') {\n      for (int di = 0; di < 4; di++) {\n\tint vx = (u.x + c + dxs[di]) % c;\n\tint vy = (u.y + r + dys[di]) % r;\n\tif (! used[vy][vx][di][u.m]) {\n\t  used[vy][vx][di][u.m] = true;\n\t  q.push(Stat(vx, vy, di, u.m));\n\t}\n      }\n    }\n    else {\n      switch (op) {\n      case '<': u.d = D_L; break;\n      case '>': u.d = D_R; break;\n      case '^': u.d = D_U; break;\n      case 'v': u.d = D_D; break;\n      case '_': u.d = (u.m == 0) ? D_R : D_L; break;\n      case '|': u.d = (u.m == 0) ? D_D : D_U; break;\n      case '.': break;\n      case '+': u.m = (u.m + 1) % MAX_M; break;\n      case '-': u.m = (u.m + MAX_M - 1) % MAX_M; break;\n      default: if (op >= '0' && op <= '9') u.m = op - '0';\n      }\n\n      u.x = (u.x + c + dxs[u.d]) % c;\n      u.y = (u.y + r + dys[u.d]) % r;\n      if (! used[u.y][u.x][u.d][u.m]) {\n\tused[u.y][u.x][u.d][u.m] = true;\n\tq.push(u);\n      }\n    }\n  }\n\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nState state(0, 0, 0, 0);\n\nvoid analyzer(char symbol) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col]);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (0 <= nx && nx < C && 0 <= ny && ny < R) {\n                dfs(ny, nx);\n            }\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        if (0 <= nx && nx < C && 0 <= ny && ny < R) {\n            dfs(ny, nx);\n        }\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nusing vec1 = vector<T>;\n\ntemplate <typename T>\nusing vec2 = vec1<vec1<T>>;\n\ntemplate <typename T>\nT Get(const vec2<T>& v2, size_t x, size_t y)\n{\n    return v2[y][x];\n}\n\ntemplate <typename T>\nT cin2var()\n{\n    T val;\n    cin >> val;\n    return val;\n}\n\ntemplate <typename T>\nvec1<T> cin2vec(size_t size)\n{\n    vec1<T> vec1(size);\n    for (auto& v : vec1) {\n        v = cin2var<T>();\n    }\n    return vec1;\n}\n\nenum class VecType\n{\n    Up,\n    Down,\n    Left,\n    Right,\n};\n\nusing VisitInfo = tuple<size_t, size_t, VecType, char>;\n\nsize_t         R_;\nsize_t         C_;\nvec2<char>     vec2_prog_;\nset<VisitInfo> set_visit_;\n\nsize_t GetUp(size_t y)\n{\n    if (y == 0) y = R_;\n    return y - 1;\n}\n\nsize_t GetDown(size_t y)\n{\n    ++y;\n    if (y >= R_) y = 0;\n    return y;\n}\n\nsize_t GetLeft(size_t x)\n{\n    if (x == 0) x = C_;\n    return x - 1;\n}\n\nsize_t GetRight(size_t x)\n{\n    ++x;\n    if (x >= C_) x = 0;\n    return x;\n}\n\n// prototype\nvoid Run(size_t x, size_t y, VecType vt, char mem);\n\nvoid Next(size_t x, size_t y, VecType vt, char mem)\n{\n    switch (vt) {\n    case VecType::Up:\n        Run(x, GetUp(y), vt, mem);\n        break;\n    case VecType::Down:\n        Run(x, GetDown(y), vt, mem);\n        break;\n    case VecType::Left:\n        Run(GetLeft(x), y, vt, mem);\n        break;\n    case VecType::Right:\n        Run(GetRight(x), y, vt, mem);\n        break;\n    }\n}\n\n// 発見！\nclass found : exception\n{\n};\n\nvoid Run(size_t x, size_t y, VecType vt, char mem)\n{\n    {\n        const VisitInfo vi(make_tuple(x, y, vt, mem));\n        if (!set_visit_.insert(vi).second) {\n            // 同じ条件で通過済み\n            return;\n        }\n    }\n    const auto c = Get(vec2_prog_, x, y);\n    // cout << c << ' ' << static_cast<int>(mem) << endl;\n    switch (c) {\n    case '<':\n        vt = VecType::Left;\n        Next(x, y, vt, mem);\n        break;\n    case '>':\n        vt = VecType::Right;\n        Next(x, y, vt, mem);\n        break;\n    case '^':\n        vt = VecType::Up;\n        Next(x, y, vt, mem);\n        break;\n    case 'v':\n        vt = VecType::Down;\n        Next(x, y, vt, mem);\n        break;\n    case '_':\n        vt = mem == 0 ? VecType::Right : VecType::Left;\n        Next(x, y, vt, mem);\n        break;\n    case '|':\n        vt = mem == 0 ? VecType::Down : VecType::Up;\n        Next(x, y, vt, mem);\n        break;\n    case '?':\n        Run(GetLeft(x), y, VecType::Left, mem);\n        Run(GetRight(x), y, VecType::Right, mem);\n        Run(x, GetUp(y), VecType::Up, mem);\n        Run(x, GetDown(y), VecType::Down, mem);\n        break;\n    case '@':\n        throw found();\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        mem = c - '0';\n        assert(0 <= mem && mem <= 9);\n        // break;\n    case '.':\n        Next(x, y, vt, mem);\n        break;\n    case '+':\n        if (++mem > 15) mem = 0;\n        Next(x, y, vt, mem);\n        break;\n    case '-':\n        if (--mem < 0) mem = 15;\n        Next(x, y, vt, mem);\n        break;\n    default:\n        assert(!\"switch\");\n        return;\n    }\n}\n\nvoid sub()\n{\n    R_ = cin2var<size_t>();\n    C_ = cin2var<size_t>();\n    for (size_t i = 0; i < R_; ++i) {\n        const auto vec1(cin2vec<char>(C_));\n        vec2_prog_.push_back(vec1);\n    }\n    string ans;\n    try {\n        Run(0, 0, VecType::Right, 0);\n        ans = \"NO\";\n    }\n    catch (found& ex) {\n        ans = \"YES\";\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    sub();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nState state(0, 0, 0, 0);\n\nvoid analyzer(char symbol) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col]);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (C-1 < nx) nx = 0;\n            if (nx < 0) nx = C-1;\n            if (R-1 < ny) ny = 0;\n            if (ny < 0) ny = R-1;\n            dfs(ny, nx);\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        if (C-1 < nx) nx = 0;\n        if (nx < 0) nx = C-1;\n        if (R-1 < ny) ny = 0;\n        if (ny < 0) ny = R-1;\n        dfs(ny, nx);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\n#define MAX 25\n\nint H,W,mem;\nchar field[MAX][MAX];\nbool visited[MAX][MAX][16][4];\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nvoid Nextpos(int &y,int &x){\n  if(x >= W){\n    x = 0;\n  }else if(y >= H){\n    y = 0;\n  }else if(x < 0){\n    x = W-1;\n  }else if(y < 0){\n    y = H-1;\n  }\n}\n\nbool solve(int y,int x,int dir){\n  if(x >= 0 && field[y][x] == '@') return true;\n  if(x >= 0 && visited[y][x][mem][dir]) return false;\n  if(x >= 0) visited[y][x][mem][dir] = true;\n\n  int nx = x + dx[dir], ny = y + dy[dir];\n  Nextpos(ny,nx);\n  \n  if(isdigit(field[ny][nx])){\n    mem = field[ny][nx] - '0';\n  }else{\n    switch(field[ny][nx]){\n    case '>':\n      dir = 0;\n      break;\n    case 'v':\n      dir = 1;\n      break;\n    case '<':\n      dir = 2;\n      break;\n    case '^':\n      dir = 3;\n      break;\n    case '_':\n      dir = (mem == 0 ? 0 : 2);\n      break;\n    case '|':\n      dir = (mem == 0 ? 1 : 3);\n      break;\n    case '?':\n      for(int i = 0 ; i < 4 ; i++){\n        if(solve(ny,nx,i)) return true;\n      }\n      break;\n    case '+':\n      mem = (mem == 15 ? 0 : mem+1);\n      break;\n    case '-':\n      mem = (mem == 0 ? 15 : mem-1);\n      break;\n    }\n  }\n  if(solve(ny,nx,dir)) return true;\n  return false;\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n    }\n  }\n  mem = 0;\n  memset(visited,false,sizeof(visited));\n  cout << (solve(0,-1,0) ? \"YES\" : \"NO\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define dbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define dbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //dbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = st.x+dx[i], ne.y = st.y+dy[i], ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //dbgPass(\"move\");\n      ne.x = (st.x+dx[ne.d]+C)%C, ne.y = (st.y+dy[ne.d]+R)%R;\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //dbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Stopping Problem\n//Level: 2\n//Category: シミュレーション,幅優先探索,BFS\n//Note:\n\n/**\n * 状態は「どのマスにいるか」、「どの方向に進んでいるか」、「メモリの値がいくつか」の3つ。\n * 同じ状態からは同じ遷移しか発生しないので、一度通った状態は2回目以降は無視して良い。\n *\n * オーダーは O(RCDM)。\n * ただしDは進行方向の種類数、Mはメモリのとり得る値の種類数で、D=4, M=16。\n */\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nconst int DR[] = {0, -1, 0, 1};\nconst int DC[] = {1, 0, -1, 0};\n\nint hashf(int r, int c, int d, int m) {\n    return ((((r) * 20 + c) * 20 + d) * 20 + m);\n}\n\nbool solve() {\n    int R, C;\n    if(!(cin >> R >> C)) return false;\n\n    vector<string> prog(R);\n    for(int r = 0; r < R; ++r) {\n        cin >> prog[r];\n    }\n\n    unordered_set<int> memo;\n    queue<tuple<int,int,int,int>> q;\n    q.push(make_tuple(0, 0, 0, 0));\n    memo.insert(0);\n    bool ans = false;\n    while(!q.empty()) {\n        int r, c, d, m;\n        tie(r, c, d, m) = q.front();\n        q.pop();\n\n        switch(prog[r][c]) {\n        case '<':\n            d = 2;\n            break;\n        case '>':\n            d = 0;\n            break;\n        case '^':\n            d = 1;\n            break;\n        case 'v':\n            d = 3;\n            break;\n        case '_':\n            d = (m ? 2 : 0);\n            break;\n        case '|':\n            d = (m ? 1 : 3);\n            break;\n        case '@':\n            ans = true;\n            goto end;\n        case '+':\n            m = (m + 1) % 16;\n            break;\n        case '-':\n            m = (m + 15) % 16;\n            break;\n        default:\n            if(isdigit(prog[r][c])) {\n                m = prog[r][c] - '0';\n            }\n        }\n        if(prog[r][c] == '?') {\n            for(d = 0; d < 4; ++d) {\n                const int nr = (r + DR[d] + R) % R;\n                const int nc = (c + DC[d] + C) % C;\n                const int h = hashf(nr, nc, d, m);\n                if(!memo.count(h)) {\n                    memo.insert(h);\n                    q.push(make_tuple(nr, nc, d, m));\n                }\n            }\n        } else {\n            const int nr = (r + DR[d] + R) % R;\n            const int nc = (c + DC[d] + C) % C;\n            const int h = hashf(nr, nc, d, m);\n            if(!memo.count(h)) {\n                memo.insert(h);\n                q.push(make_tuple(nr, nc, d, m));\n            }\n        }\n    }\nend:\n    cout << (ans ? \"YES\" : \"NO\") << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool used[30][30][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s[30];\nint h,w,m;\nvoid END(){\n  cout<<\"YES\"<<endl;\n  exit(0);\n}\nvoid dfs(int x,int y,int d){\n  while(1){\n    if(used[y][x][d])return ;\n    used[y][x][d]=1;\n    x+=dx[d];\n    y+=dy[d];\n    x+=w;\n    y+=h;\n    x%=w;\n    y%=h;\n    if(s[y][x]=='<'){d=3;}\n    else if(s[y][x]=='>'){d=1;}\n    else if(s[y][x]=='^'){d=0;}\n    else if(s[y][x]=='v'){d=2;}\n    else if(s[y][x]=='_'){\n      if(m)d=3;\n      else d=1;\n    }\n    else if(s[y][x]=='|'){\n      if(m)d=0;\n      else d=2;\n    }\n    else if(s[y][x]=='?'){\n      r(i,4)dfs(x,y,i);\n    }\n    else if(s[y][x]=='.'){}\n    else if(s[y][x]=='@'){END();}\n    else if(s[y][x]=='-'){m=(m-1+16)%16;}\n    else if(s[y][x]=='+'){m=(m+1)%16;}\n    else if(isdigit(s[y][x])){m=s[y][x]-'0';}\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)cin>>s[i];\n  dfs(0,0,1);\n  cout<<\"NO\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include <iterator>\n#include<queue>\n#include <functional>\n#include <string>\n#include <numeric>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) v.begin(),v.end()\nusing namespace std;\nconst int dx[4] = { -1, 1, 0, 0 };\nconst int dy[4] = { 0, 0, -1, 1 };\nstruct data\n{\n\tbool memo[20][20][16][4] = {};\n};\nint R=0, C=0;\nbool a(int ax, int ay, vector<string> Fi,int Memory, int Muki,data aa){\n\tax=(ax+C)% C;ay=(ay+R) % R;\n\tif (aa.memo[ax][ay][Memory][Muki])return false;\n\taa.memo[ax][ay][Memory][Muki] = true;\n\tswitch (Fi[ay][ax]){\n\tcase '<':Muki = 0; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki,aa);\n\tcase '>':Muki = 1;; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '^':Muki = 2; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase 'v':Muki = 3; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '_':Muki = Memory ? 0 : 1; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '|':Muki = Memory ? 2 : 3; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '?': return a(ax + dx[0], ay + dy[0], Fi, Memory, 0, aa) || a(ax + dx[1], ay + dy[1], Fi, Memory, 1, aa) || a(ax + dx[2], ay + dy[2], Fi, Memory, 2, aa) || a(ax + dx[3], ay + dy[3], Fi, Memory, 3, aa);\n\tcase '.':return a(ax + dx[Muki], ay + dy[Muki], Fi,Memory, Muki, aa);\n\tcase '@':return true;\n\tcase '+':return a(ax + dx[Muki], ay + dy[Muki], Fi, (Memory + 1) % 16, Muki, aa);\n\tcase '-':return a(ax + dx[Muki], ay + dy[Muki], Fi, (Memory+15) % 16, Muki, aa);\n\tdefault:return a(ax + dx[Muki], ay + dy[Muki], Fi, Fi[ay][ax]-48, Muki, aa);\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> R >> C;\n\tvector<string> Field(R);\n\tREP(i, R){\n\t\tstring st;\n\t\tcin >> Field[i];\n\t}\n\tdata adata;\n\tif (a(0, 0, Field, 0, 1,adata)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse{\n\t\tcout << \"NO\" << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint R, C; string s[20]; bool flag, visited[20][20][4][16];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int d, int m) {\n\tif (!visited[y][x][d][m]) {\n\t\tvisited[y][x][d][m] = true;\n\t\tswitch (s[y][x]) {\n\t\tcase '>':\n\t\t\trec((x + 1) % C, y, 0, m); break;\n\t\tcase 'v':\n\t\t\trec(x, (y + 1) % R, 1, m); break;\n\t\tcase '<':\n\t\t\trec((x - 1 + C) % C, y, 2, m); break;\n\t\tcase '^':\n\t\t\trec(x, (y - 1 + R) % R, 3, m); break;\n\t\tcase '_':\n\t\t\tif (m == 0) rec((x + 1) % C, y, 0, m); else rec((x - 1 + C) % C, y, 2, m); break;\n\t\tcase '|':\n\t\t\tif (m == 0) rec(x, (y + 1) % R, 1, m); else rec(x, (y - 1 + R) % R, 3, m); break;\n\t\tcase '?':\n\t\t\tfor (int i = 0; i < 4; i++) rec((x + dx[i] + C) % C, (y + dy[i] + R) % R, i, m); break;\n\t\tcase '.':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, m); break;\n\t\tcase '@':\n\t\t\tflag = true; return;\n\t\tcase '+':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, (m + 1) % 16); break;\n\t\tcase '-':\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, (m + 15) % 16); break;\n\t\tdefault:\n\t\t\trec((x + dx[d] + C) % C, (y + dy[d] + R) % R, d, s[y][x] - 48); break;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &R, &C);\n\tfor (int i = 0; i < R; i++) cin >> s[i]; rec(0, 0, 0, 0);\n\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef struct{\n  int MEM,MUKI;\n  int used[22][22];\n  int x,y;\n}P;\nchar mas[22][22];\nint R,C,dx[]={0,-1,0,1},dy[]={1,0,-1,0}; //右上左下\nint flg;\nvoid dfs(P p);\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++){\n    for(int j=0;j<C;j++){\n      cin >> mas[i][j];\n    }\n  }\n  flg=0;\n  P p;\n  p.MEM=0;   p.x=0;\n  p.MUKI=0;  p.y=-1;\n  memset(p.used,0,sizeof(p.used));\n  dfs(p);\n  cout << (flg>0?\"NO\":\"YES\") << endl;\n}\nvoid dfs(P p){\n  queue<P> que;\n  que.push(p);\n    P HM = que.front();\n  while(!que.empty()){\n\n    HM.x+=dx[HM.MUKI];\n    HM.y+=dy[HM.MUKI];\n    if(HM.x<0)HM.x=R-1;\n    else if(HM.x>=R)HM.x=0;\n    else if(HM.y<0)HM.y=C-1;\n    else if(HM.y>=C)HM.y=0;\n    if(HM.used[HM.x][HM.y]==10){\n      flg++;\n      que.pop();\n      if(que.empty())return;\n      else{\n\tHM=que.front();\n\tque.pop();\n      }\n    } else{\n      HM.used[HM.x][HM.y]++;\n      if(mas[HM.x][HM.y]=='?'){\n\tfor(int i=0;i<4;i++){\n\t  P HMHM=HM;\n\t  HMHM.MUKI=i;\n\t  que.push(HMHM);\n\t}\n      }else if(mas[HM.x][HM.y]=='@'){\n\tflg = -1000;\n\treturn;\n      }else if(mas[HM.x][HM.y]=='_'){\n\tHM.MEM == 0 ? HM.MUKI=0 : HM.MUKI=2;\n      }else if(mas[HM.x][HM.y]=='|'){\n\tHM.MEM == 0 ? HM.MUKI=3 : HM.MUKI=1;\n      }else if(mas[HM.x][HM.y]=='+'){\n\tHM.MEM == 15 ? HM.MEM=0 : HM.MEM++;\n      }else if(mas[HM.x][HM.y]=='-'){\n\tHM.MEM == 0 ? HM.MEM=15 : HM.MEM--;\n      }else if(mas[HM.x][HM.y]>='0'&&mas[HM.x][HM.y]<='9'){\n\tHM.MEM = mas[HM.x][HM.y]-'0';\n      }else if(mas[HM.x][HM.y]=='.'){\n\n      }else if(mas[HM.x][HM.y]=='<'){\n\tHM.MUKI= 2;\n      }else if(mas[HM.x][HM.y]=='^'){\n\tHM.MUKI= 1;\n      }else if(mas[HM.x][HM.y]=='>'){\n\tHM.MUKI= 0;\n      }else if(mas[HM.x][HM.y]=='v'){\n\tHM.MUKI= 3;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tchar x,y,p,mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> visited){\n  while(code[A.y][A.x]!='@'){\n  \tif(count(visited.begin(),visited.end(),A))return false;\n  \tvisited.push_back(A);\n  \t//cerr<<A.x<<\",\"<<A.y<<endl;\n  \tif(code[A.y][A.x]=='>')A.p=0;\n  \tif(code[A.y][A.x]=='v')A.p=1;\n  \tif(code[A.y][A.x]=='<')A.p=2;\n  \tif(code[A.y][A.x]=='^')A.p=3;\n  \tif(code[A.y][A.x]=='_')A.p=(A.mem)?2:0;\n  \tif(code[A.y][A.x]=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=code[A.y][A.x]&&code[A.y][A.x]<='9')A.mem=code[A.y][A.x]-'0';\n   \tif(code[A.y][A.x]=='+')A.mem=(A.mem+1)%16;\n   \tif(code[A.y][A.x]=='-')A.mem=(A.mem+15)%16;\n   \tif(code[A.y][A.x]=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p])%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4])%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p])%c;A.y=(A.y+pos[(A.p+3)%4])%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstring>\n#include<queue>\n#define Pf p.first\n#define Ps p.second\n#define Pt MAS[Pf][Ps]\nusing namespace std;\ntypedef pair<int,int>P;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0},h,w,MUKI;\nchar MAS[22][22];\nbool used[22][22][4][16]; //縦 横 向き メモリー //\nP moveover(P,int);\nbool search(P p,int MUKI,int memory){\n  // ※向きの順番 右上左下※ //\n  while(true){\n    if(used[Pf][Ps][MUKI][memory]==true) return true; // ループ判定 //\n    else used[Pf][Ps][MUKI][memory] = true;\n\n    if(Pt == '<') MUKI = 2;\n    else if(Pt == '>') MUKI = 0;\n    else if(Pt == '^') MUKI = 1;\n    else if(Pt == 'v') MUKI = 3;\n    else if(Pt == '_') MUKI = (memory==0 ? 0 : 2);\n    else if(Pt == '|') MUKI = (memory==0 ? 3 : 1);\n    else if(Pt == '?'){\n      for(int i=0;i<4;i++){\n\tif(!search(moveover(p,i),i,memory)) return false;\n\treturn true;\n      }\n    }\n    else if(Pt == '@') return false; // Stop!! //\n    else if(Pt == '+') memory == 15 ? memory = 0 : memory++;\n    else if(Pt == '-') memory == 0 ? memory = 15 : memory--;\n    else if(Pt != '.') memory = Pt - '0';\n    p = moveover(p,MUKI);\n  }\n}\nint main(){\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> MAS[i][j];\n    }\n  }\n  memset(used,false,sizeof(used));\n  cout << (search(P(0,0),0,0)?\"NO\":\"YES\") << endl;\n}\nP moveover(P p,int MUKI){\n  Pf += dx[MUKI];\n  Ps += dy[MUKI];\n  if(Pf < 0) Pf = h-1;\n  else if(Pf >= h) Pf = 0;\n  if(Ps < 0) Ps = w-1;\n  else if(Ps >= w) Ps = 0;\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n  \nconst int MAXR = 21;\nconst int MAXC = 21;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n  \nstruct State {\n  int i, j, d, m;\n  State();\n  State(int i, int j, int d, int m)\n    : i(i), j(j), d(d), m(m) {}\n};\n  \nint R, C;\nchar G[MAXR][MAXC];\nbool vis[MAXR][MAXC][4][16];\n  \nbool canFinish() {\n  State s(0,0,0,0);\n  queue<State> que;\n  que.push(s);\n  fill(vis[0][0][0], vis[MAXR][0][0], false);\n  vis[s.i][s.j][s.d][s.m] = true;\n  \n  while(!que.empty()) {\n    s = que.front();\n    que.pop();\n  \n    if(isdigit(G[s.i][s.j])) {\n      s.m = G[s.i][s.j] - '0';\n    } else {\n      switch(G[s.i][s.j]) {\n      case '<':\n        s.d = 2;\n        break;\n      case '>':\n        s.d = 0;\n        break;\n      case '^':\n        s.d = 3;\n        break;\n      case 'v':\n        s.d = 1;\n        break;\n      case '_':\n        if(s.m == 0) s.d = 0;\n        else s.d = 2;\n        break;\n      case '|':\n        if(s.m == 0) s.d = 1;\n        else s.d = 3;\n        break;\n      case '?':\n        s.d = -1;\n        break;\n      case '.':\n        //\n        break;\n      case '@':\n        return true;\n      case '+':\n        s.m = (s.m+1)%16;\n        break;\n      case '-':\n        s.m = (s.m-1+16)%16;\n        break;\n      }\n    }\n  \n    vector<State> next;\n    if(s.d == -1) {\n      for(s.d = 0; s.d < 4; ++s.d) {\n        next.push_back(s);\n      }\n    } else {\n      next.push_back(s);\n    }\n  \n    for(int k = 0; k < next.size(); ++k) {\n      State &t = next[k];\n      t.i = (t.i + di[t.d] + R) % R;\n      t.j = (t.j + dj[t.d] + C) % C;\n      if(vis[t.i][t.j][t.d][t.m]) continue;\n      vis[t.i][t.j][t.d][t.m] = true;\n      que.push(t);\n    }\n  }\n  return false;\n}\n  \nint main() {\n  cin >> R >> C;\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    if(canFinish()) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nint h, w;\nvector<string> program;\nvector<vector<vector<vector<bool> > > > check;\n\nbool solve(int y, int x, int d, int m)\n{\n    if(check[y][x][d][m])\n        return false;\n    check[y][x][d][m] = true;\n\n    char c = program[y][x];\n    if(c == '@'){\n        return true;\n    }else if(c == '>'){\n        d = 0;\n    }else if(c == 'v'){\n        d = 1;\n    }else if(c == '<'){\n        d = 2;\n    }else if(c == '^'){\n        d = 3;\n    }else if(c == '_'){\n        if(m == 0)\n            d = 0;\n        else\n            d = 2;\n    }else if(c == '|'){\n        if(m == 0)\n            d = 1;\n        else\n            d = 3;\n    }else if('0' <= c && c <= '9'){\n        m = c - '0';\n    }else if(c == '+'){\n        ++ m;\n        m %= 16;\n    }else if(c == '-'){\n        m += 15;\n        m %= 16;\n    }\n\n    if(c == '?'){\n        for(int i=0; i<4; ++i){\n            int y1 = (y + dy[i] + h) % h;\n            int x1 = (x + dx[i] + w) % w;\n            if(solve(y1, x1, i, m))\n                return true;\n        }\n        return false;\n    }else{\n        y += dy[d] + h;\n        y %= h;\n        x += dx[d] + w;\n        x %= w;\n        return solve(y, x, d, m);\n    }\n}\n\nint main()\n{\n    cin >> h >> w;\n\n    program.resize(h);\n    for(int i=0; i<h; ++i)\n        cin >> program[i];\n\n    check.assign(h, vector<vector<vector<bool> > >(w, vector<vector<bool> >(4, vector<bool>(16, false))));\n\n    if(solve(0, 0, 0, 0))\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><^v\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 1 : 0;\n  else if (ch == '|') \n    d = mem ? 3 : 2;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\nbool random_flag[MAX][MAX][4];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, int& dir, int& memory) {\n    switch (symbol) {\n        case '<':\n            dir = 2;\n            break;\n\n        case '>':\n            dir = 0;\n            break;\n\n        case '^':\n            dir = 1;\n            break;\n\n        case 'v':\n            dir = 3;\n            break;\n\n        case '_':\n            if (memory == 0) dir = 0;\n            else dir = 2;\n            break;\n\n        case '|':\n            if (memory == 0) dir = 3;\n            else dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (memory == 15) memory = 0;\n            else memory++;\n            break;\n\n        case '-':\n            if (memory == 0) memory = 15;\n            else memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col, int dir, int memory) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 5) return;\n\n    log[col][row]++;\n    analyzer(program[row][col], dir, memory);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            nx = (nx + C) % C;\n            ny = (ny + R) % R;\n            dir = i;\n            dfs(ny, nx, dir, memory);\n        }\n    }else {\n        nx = col + dx[dir];\n        ny = row + dy[dir];\n        nx = (nx + C) % C;\n        ny = (ny + R) % R;\n        dfs(ny, nx, dir, memory);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            for (int k = 0; k < 4; k++) {\n                random_flag[i][j][k] = false;\n            }\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0, 0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] = '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d\\n\",s.mMemory,x,y);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint memc[22][22][16][5]={0};\nchar prog[22][22];\nint dh[5]={0,-1,0,1,0};\nint dw[5]={0,0,1,0,-1};\nint ww,hh;\nbool gogo(int h,int w,int m,int muki);\nmain(){\n  cin>>hh>>ww;\n  for(int i=1;i<=hh;i++){\n    for(int j=1;j<=ww;j++){\n      cin>>prog[i][j];\n    }\n  }\n  if(gogo(1,1,0,2)){\n    cout<<\"YES\"<<endl;\n  }\n  else{\n    cout<<\"NO\"<<endl;\n  } \n}\nbool gogo(int h,int w,int m,int muki){\n  //cout<<h<<\" \"<<w<<\" \"<<m<<\" \"<<muki<<endl;\n  if(prog[h][w]=='@'){\n    return true;\n  }\n  if(memc[h][w][m][muki]==1){\n    return false;\n  }\n  memc[h][w][m][muki]=1;\n  if(prog[h][w]=='^'){\n    muki=1;\n  }\n  if(prog[h][w]=='>'){\n    muki=2;\n  }\n  if(prog[h][w]=='v'){\n    muki=3;\n  }\n  if(prog[h][w]=='<'){\n    muki=4;\n  }\n  if(prog[h][w]=='_'){\n    if(m==0){\n      muki=2;\n    }\n    else{\n      muki=4;\n    }\n  }\n  if(prog[h][w]=='|'){\n    if(m==0){\n      muki=3;\n    }\n    else{\n      muki=1;\n    }\n  }\n  if(prog[h][w]>='0'&&prog[h][w]<='9'){\n    m=prog[h][w]-'0';\n  }\n  if(prog[h][w]=='+'){\n    if(m==15){\n      m=0;\n    }\n    else{\n      m++;  \n    }\n  }\n  if(prog[h][w]=='-'){\n    if(m==0){\n      m=15;\n    }\n    else{\n      m--;\n    }\n  }\n  if(prog[h][w]!='?'){\n    if(h+dh[muki]==0){\n      h=hh+1;\n    }\n    if(h+dh[muki]>hh){\n      h=0;\n    }\n    if(w+dw[muki]==0){\n      w=ww+1;\n    }\n    if(w+dw[muki]>ww){\n      w=0;\n    }\n    return gogo(h+dh[muki],w+dw[muki],m,muki);\n  }\n  else{\n    int a=0;\n    for(int i=1;i<=4;i++){\n      a+=gogo(h+dh[i],w+dw[i],m,muki);\n    }\n    if(a==0){\n      return false;\n    }\n    else{\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPrint(a) cout<<\"Debug: \"<<a<<endl\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r)rep(sysJ,c)cin>>m[sysI][sysJ]\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][16];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\nint getX(int xx) { return (xx+C)%C; }\nint getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  visited[s.x][s.y][s.d][s.m] = true;\n\n  while(!Q.empty()) {\n    State st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n\n    State ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = getX(st.x+dx[i]), ne.y = getY(st.y+dy[i]), ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\t  visited[ne.x][ne.y][ne.d][ne.m] = true;\n\t  Q.push(ne);\n\t}\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = getX(st.x+dx[ne.d]), ne.y = getY(st.y+dy[ne.d]);\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) {\n\tvisited[ne.x][ne.y][ne.d][ne.m] = true;\n\tQ.push(ne);\n      }\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C;\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint R, C;\nchar table[32][32];\nbool visited[16][20][20][4];\n\nstruct State {\n  int m, r, c, d;\n  bool &ref() {\n    return visited[m][r][c][d];\n  }\n  char here() {\n    return table[r][c];\n  }\n\n  State move() {\n    const int dr[] = {0, -1, 0, 1};\n    const int dc[] = {1, 0, -1, 0};\n    State cp = *this;\n    cp.r += dr[d]; cp.r %= R;\n    cp.c += dc[d]; cp.c %= C;\n    if (cp.r < 0) cp.r += R;\n    if (cp.c < 0) cp.c += C;\n    return cp;\n  }\n\n};\n\nint main() {\n  while (cin >> R >> C) {\n      memset(visited, 0, sizeof(visited));\n      REP(r, R) {\n          cin >> table[r];\n      }\n\n      queue<State> q;\n      q.push((State){0, 0, 0, 0});\n      visited[0][0][0][0] = true;\n\n      bool stoppable = false;\n      while (!q.empty()) {\n          State cur = q.front(); q.pop();\n\n          switch (cur.here()) {\n          case '<': cur.d = 2; break;\n          case '>': cur.d = 0; break;\n          case '^': cur.d = 1; break;\n          case 'v': cur.d = 3; break;\n          case '_': cur.d = cur.m == 0 ? 0 : 2; break;\n          case '|': cur.d = cur.m == 0 ? 3 : 1; break;\n          case '?': break;\n          case '.': break;\n          case '@': stoppable = true; break;\n          case '+': cur.m = (cur.m + 1) & 15; break;\n          case '-': cur.m = (cur.m + 15) & 15; break;\n          default : cur.m = cur.here() - '0'; break;\n          }\n\n          if (stoppable) break;\n\n          if (cur.here() == '?') {\n              REP(d,4) {\n                  cur.d = d;\n                  State next = cur.move();\n                  if (!next.ref()) {\n                      q.push(next);\n                      next.ref() = true;\n                  }\n              }\n          } else {\n              State next = cur.move();\n              if (!next.ref()) {\n                  q.push(next);\n                  next.ref() = true;\n              }\n          }\n      }\n\n      cout << (stoppable ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする．\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される．\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][15],int gx,int gy){\n  for(int i=0;i<15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][15];\n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] = '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d\\n\",s.mMemory,x,y);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16];\nint W, H;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"<>^v\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 0 : 1;\n  else if (ch == '|') \n    d = mem ? 2 : 3;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '.')\n    ;\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) \n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\treturn true;\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<cctype>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a ; i < n ;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nclass State{\npublic:\n  int x,y,d,memory;\n\n  State(int _x,int _y,int _d,int _memory){\n    x = _x;\n    y = _y;\n    d = _d;\n    memory = _memory;\n  }\n};\n\nint h,w;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nchar t[22][22];\nbool closed[22][22][4][16];\n\nvoid solve(){\n  queue<State> open;\n  memset(closed,false,sizeof(closed));\n  open.push(State(0,0,1,0));\n\n  while(!open.empty()){\n    State st = open.front(); open.pop();\n    if(closed[st.y][st.x][st.d][st.memory]) continue;\n    closed[st.y][st.x][st.d][st.memory] = true;\n\n    if(t[st.y][st.x] == '@'){\n      cout<<\"YES\\n\";\n      return;\n    }\n\n    bool flg = false;\n\n    switch(t[st.y][st.x]){\n    case '<': st.d = 3; break;\n    case '>': st.d = 1; break;\n    case '^': st.d = 0; break;\n    case 'v': st.d = 2; break;\n    case '_': st.d = (st.memory==0 ? 1 : 3); break;\n    case '|': st.d = (st.memory==0 ? 2 : 0); break;\n    case '?': flg = true; break;\n    case '+': st.memory = (st.memory+1)%16; break;\n    case '-': st.memory = (st.memory+15)%16; break;\n    }\n\n    if(isdigit(t[st.y][st.x])){\n      st.memory = t[st.y][st.x] - '0';\n    }\n\n    if(flg){\n      rep(i,4){\n        int nx = (st.x + dx[i] + w) % w;\n        int ny = (st.y + dy[i] + h) % h;\n        open.push(State(nx,ny,i,st.memory));\n      }\n    }\n    else{\n      int nx = (st.x + dx[st.d] + w) % w;\n      int ny = (st.y + dy[st.d] + h) % h;\n      open.push(State(nx,ny,st.d,st.memory));\n    }\n  }\n\n  cout<<\"NO\\n\";\n}\n\nint main(){\n  while(cin>>h>>w){\n    rep(i,h){\n      cin>>t[i];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tchar x,y,p,mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> &visited){\n  while(code[A.y][A.x]!='@'){\n  \tif(count(visited.begin(),visited.end(),A))return false;\n  \tvisited.push_back(A);\n  \t//cerr<<A.x<<\",\"<<A.y<<endl;\n  \tif(code[A.y][A.x]=='>')A.p=0;\n  \tif(code[A.y][A.x]=='v')A.p=1;\n  \tif(code[A.y][A.x]=='<')A.p=2;\n  \tif(code[A.y][A.x]=='^')A.p=3;\n  \tif(code[A.y][A.x]=='_')A.p=(A.mem)?2:0;\n  \tif(code[A.y][A.x]=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=code[A.y][A.x]&&code[A.y][A.x]<='9')A.mem=code[A.y][A.x]-'0';\n   \tif(code[A.y][A.x]=='+')A.mem=(A.mem+1)%16;\n   \tif(code[A.y][A.x]=='-')A.mem=(A.mem+15)%16;\n   \tif(code[A.y][A.x]=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p])%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4])%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p])%c;A.y=(A.y+pos[(A.p+3)%4])%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 21;\nconst int  INF = (1<<25);\nconst int DM = 4; //number of direction\nconst int MM = 16;//number that memory can be set\n\n\nchar M[MAX][MAX];\nint T[DM][MM][MAX][MAX];\nint R,C,gx,gy;\nbool ans;\n\nconst int UP = 0;\nconst int RIGHT = 1;\nconst int DOWN = 2;\nconst int LEFT = 3;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nvoid input(){\n  cin >> R >> C;\n  for(int i = 0; i < R; i++)\n    for(int j = 0; j < C; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '@'){\n\tgx = j;\n\tgy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<C&&0<=y&&y<R;}\n    \nvoid dfs(int dir, int mem, int y, int x){\n  \n  if(T[dir][mem][y][x]) return;\n  T[dir][mem][y][x] = true;\n\n  int nx,ny;\n\n  if(x == -1 && y == -1){\n    nx = 0;\n    ny = 0;\n  }else{\n    nx = x+dx[dir];\n    ny = y+dy[dir];\n  }\n\n  //  cout << \"come \" << mem  << \" \" << nx  << \" \" << ny  << M[ny][nx] << endl;\n  //  if(!isInside(nx,ny)) return;\n  if(nx > C) nx = 0;\n  if(nx < 0) nx = C-1;\n  if(ny > R) ny = 0;\n  if(ny < 0) ny = R-1;\n  \n  if(M[ny][nx] == '<') dfs(LEFT,mem,ny,nx);\n  if(M[ny][nx] == '>') dfs(RIGHT,mem,ny,nx);\n  if(M[ny][nx] == '^') dfs(UP,mem,ny,nx);\n  if(M[ny][nx] == 'v') dfs(DOWN,mem,ny,nx);\n  if(M[ny][nx] == '_' && mem == 0) dfs(RIGHT,mem,ny,nx);\n  if(M[ny][nx] == '_' && mem != 0) dfs(LEFT,mem,ny,nx);\n  if(M[ny][nx] == '|' && mem == 0) dfs(DOWN,mem,ny,nx);\n  if(M[ny][nx] == '|' && mem != 0) dfs(UP,mem,ny,nx);\n  if(M[ny][nx] == '?') dfs(UP,mem,ny,nx),dfs(RIGHT,mem,ny,nx),dfs(DOWN,mem,ny,nx),dfs(LEFT,mem,ny,nx);\n  if('0' <= M[ny][nx] && M[ny][nx] <= '9') dfs(dir,M[ny][nx]-'0',ny,nx);\n  if(M[ny][nx] == '+') dfs(dir,(mem+1)%16,ny,nx);\n  if(M[ny][nx] == '-') dfs(dir,(mem+15)%16,ny,nx);\n  if(M[ny][nx] == '.') dfs(dir,mem,ny,nx);\n  if(M[ny][nx] == '@'){\n    ans = true;\n    return;\n  }\n}\n\nint main(){\n  input();\n  dfs(RIGHT,0,-1,-1);\n  if(ans) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nchar map[20][20];\nint C,R;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nbool vst[20][20][16][4];\n\nbool dfs(int x,int y,int m,int d) {\n\tif(x==-1) x=C-1;\n\tif(x==C) x=0;\n\tif(y==-1) y=R-1;\n\tif(y==R) y=0;\n\tif(vst[x][y][m][d]) return false;\n\tvst[x][y][m][d]=true;\n\tif(map[x][y]=='<') {\n\t\treturn d=2,dfs(x+dx[d],y,m,d);\n\t}else if(map[x][y]=='>') {\n\t\treturn d=0,dfs(x+dx[d],y,m,d);\n\t}else if(map[x][y]=='^') {\n\t\treturn d=3,dfs(x,y+dy[d],m,d);\n\t}else if(map[x][y]=='v') {\n\t\treturn d=1,dfs(x,y+dy[d],m,d);\n\t}else if(map[x][y]=='_') {\n\t\treturn d=!m?0:2,dfs(x+dx[d],y,m,d);\n\t}else if(map[x][y]=='|') {\n\t\treturn d=!m?1:3,dfs(x,y+dy[d],m,d);\n\t}else if(map[x][y]=='?') {\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(dfs(x+dx[i],y+dy[i],m,i)) return true;\n\t\t}\n\t\treturn false;\n\t}else if(map[x][y]=='.') {\n\t\treturn dfs(x+dx[d],y+dy[d],m,d);\n\t}else if(map[x][y]=='@') {\n\t\treturn true;\n\t}else if('0'<=map[x][y]&&map[x][y]<='9') {\n\t\treturn m=map[x][y]-'0',dfs(x+dx[d],y+dy[d],m,d);\n\t}else if(map[x][y]=='+') {\n\t\treturn m=m<15?m+1:0,dfs(x+dx[d],y+dy[d],m,d);\n\t}else if(map[x][y]=='-') {\n\t\treturn m=m>0?m-1:15,dfs(x+dx[d],y+dy[d],m,d);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\",&R,&C);\n\tgetchar();\n\tfor(int j=0;j<R;j++) {\n\t\tfor(int i=0;i<C;i++) {\n\t\t\tmap[i][j]=getchar();\n\t\t}\n\t\tgetchar();\n\t}\n\tprintf(\"%s\\n\",dfs(0,0,0,0)?\"YES\":\"NO\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  stack<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n\n    for(;;){\n      if(grid[y][x] == '?'){\n\tfor(int i=0;i<4;i++){\n\t  int ty = (y+dy[i]+r)%r, tx = (x+dx[i]+c)%c;\n\t  if(v[ty][tx][i][m])continue;\n\t  v[ty][tx][i][m] = true;\n\t  q.push(P2(P(ty,tx),P(i,m)));\n\t}\n\tbreak;\n      }else if(grid[y][x] == '@'){\n\tf = true;\n\tbreak;\n      }else{\n\tif(grid[y][x] == '>')d = 0;\n\telse if(grid[y][x] == 'v')d = 1;\n\telse if(grid[y][x] == '<')d = 2;\n\telse if(grid[y][x] == '^')d = 3;\n\telse if(grid[y][x] == '_'){\n\t  if(m)d = 2;\n\t  else d = 0;\n\t}\n\telse if(grid[y][x] == '|'){\n\t  if(m)d = 3;\n\t  else d = 1;\n\t}\n\telse if(grid[y][x] == '+')m = (m+1)%16;\n\telse if(grid[y][x] == '-')m = (m+15)%16;\n\telse if(grid[y][x] != '.')m = grid[y][x] - '0';\n\t\n\ty = (y+dy[d]+r)%r; x = (x+dx[d]+c)%c;\n\tif(v[y][x][d][m])break;\n\tv[y][x][d][m] = true;\n      }\n    }\n    if(f)break;\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint r,c;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nstring str[20], ans;\nbool f[20][20][16][4];\n\nvoid func(int y, int x, int cnt, int d){\n  if(str[y][x] == '^') d = 2;\n  else if(str[y][x] == '>') d = 1;\n  else if(str[y][x] == '<') d = 3;\n  else if(str[y][x] == 'v') d = 0;\n  else if(str[y][x] == '_') d = cnt == 0 ? 1 : 3;\n  else if(str[y][x] == '|') d = cnt == 0 ? 0 : 2;\n  else if(str[y][x] >= '0' && str[y][x] <= '9') cnt = str[y][x] - '0';\n  else if(str[y][x] == '+') cnt = (cnt + 1) % 16;\n  else if(str[y][x] == '-') cnt = (cnt + 15) % 16;\n  else if(str[y][x] == '@'){\n    ans = \"YES\";\n    return;\n  } else if(str[y][x] == '?'){\n    for(int i=0;i<4;i++){\n      if(!f[y][x][cnt][i]){\n        f[y][x][cnt][i] = true;\n        func((y+dy[i])%r, (x+dx[i])%c, cnt, i);\n      }\n    }\n  }\n\n  /*\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++){\n      if(i == y && j == x) cout << cnt;\n      else cout << '.';\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n\n  if(!f[y][x][cnt][d]){\n    f[y][x][cnt][d] = true;\n    func((y+dy[d])%r, (x+dx[d])%c, cnt, d);\n  }\n}\n\nint main(){\n  while(cin >> r >> c){\n    for(int i=0;i<r;i++)\n      for(int j=0;j<c;j++)\n        for(int k=0;k<16;k++)\n          for(int l=0;l<4;l++)\n            f[i][j][k][l] = false;\n    for(int i=0;i<r;i++) cin >> str[i];\n    dy[2] = r - 1;\n    dx[3] = c - 1;\n\n    ans = \"NO\";\n    func(0,0,0,1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar map[22][22], dp[22][22][4][16];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\n\nint search(int x,int y, int d, int m){\n\twhile(1){\n\t\tprintf(\"%d %d %d %d\\n\", x,y,d,m);\n\t\tx=(x+w-1)%w+1;y=(y+h-1)%h+1;\n\t\tchar c = map[y][x];\n\t\tif(dp[x][y][d][m]) return 0;\n\t\tdp[x][y][d][m] = 1;\n\t\tif(c == '<') d = 2;\n\t\tif(c == '>') d = 0;\n\t\tif(c == '^') d = 3;\n\t\tif(c == 'v') d = 1;\n\t\tif(c == '_') d = (m)?2:0;\n\t\tif(c == '|') d = (m)?3:1;\n\t\tif(c == '@') return 1;\n\t\tif(c == '+') m=(m+1)%16;\n\t\tif(c == '-') m=(m+15)%16;\n\t\tif(c >= '0' && c <= '9') m=c - '0';\n\t\tif(c == '?'){\n\t\t\tfor(d=0;d<4;d++) if(search(x+dx[d],y+dy[d],d,m)) return 1;\n\t\t}\n\t\tx += dx[d];y += dy[d];\n\t}\n}\nmain(){\n\tint i,j;\n\tchar *p,*q;\n\tcin>>h>>w;\n\tfor(i=1;i<=h;i++) cin>>&map[i][1];\n\tcout << ((search(1, 1, 0, 0))?\"YES\":\"NO\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<queue>\nstruct S{int x,y,m,a;};\nint R,C,d[]={0,1,0,-1,0},f[20][20][16][4];\nchar M[32][32];\nint F()\n{\n\tS s={0,0,0,1};\n\tstd::queue<S>q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\ts=q.front();q.pop();\n\t\ts.x=(s.x+C)%C;\n\t\ts.y=(s.y+R)%R;\n\t\tif(f[s.x][s.y][s.m][s.a]++)continue;\n\t\tchar c=M[s.y][s.x];\n\t\tif(c=='@')return 1;\n\t\tif(c=='?')\n\t\t{\n\t\t\tfor(int i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tS t={s.x+d[i],s.y+d[i+1],s.m,i};\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t\tif(isdigit(c))s.m=c-'0';\n\t\tif(c=='v')s.a=0;\n\t\tif(c=='>')s.a=1;\n\t\tif(c=='^')s.a=2;\n\t\tif(c=='<')s.a=3;\n\t\tif(c=='_')s.a=(s.m?3:1);\n\t\tif(c=='|')s.a=(s.m?2:0);\n\t\tif(c=='+')s.m=(s.m+1)%16;\n\t\tif(c=='-')s.m=(s.m+15)%16;\n\t\ts.x+=d[s.a];\n\t\ts.y+=d[s.a+1];\n\t\tq.push(s);\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&R,&C);\n\tfor(int i=0;i<R;++i)scanf(\"%s\",M[i]);\n\tputs(F()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<queue>\nstruct S{int x,y,m,a;};\nint R,C,d[]={0,1,0,-1,0},f[20][20][16][4];\nchar M[32][32];\nint F()\n{\n\tS s={0,0,0,1};\n\tstd::queue<S>q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\ts=q.front();q.pop();\n\t\ts.x=(s.x+C)%C;\n\t\ts.y=(s.y+R)%R;\n\t\tif(f[s.x][s.y][s.m][s.a]++)continue;\n\t\tchar c=M[s.y][s.x];\n\t\tif(c=='@')return 1;\n\t\tif(c=='?')\n\t\t{\n\t\t\tfor(int i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tS t={s.x+d[i],s.y+d[i+1],s.m,i};\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t}\n\t\tif(isdigit(c))s.m=c-'0';\n\t\tif(c=='^')s.a=0;\n\t\tif(c=='>')s.a=1;\n\t\tif(c=='v')s.a=2;\n\t\tif(c=='<')s.a=3;\n\t\tif(c=='_')s.a=(s.m?3:1);\n\t\tif(c=='|')s.a=(s.m?0:2);\n\t\tif(c=='+')s.m=(s.m+1)%16;\n\t\tif(c=='-')s.m=(s.m+15)%16;\n\t\ts.x+=d[s.a];\n\t\ts.y+=d[s.a+1];\n\t\tq.push(s);\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&R,&C);\n\tfor(int i=0;i<R;++i)scanf(\"%s\",M[i]);\n\tputs(F()?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\nusing namespace std;\n\nchar T[22]=\"0123456789^>v<?_|.+-@\";\nint x[25][25],h,w;char c;\nint dp[25][25][16][4];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint ab,a1,a2,a3,a4,X;\ntuple<int,int,int,int>tup;\nqueue<tuple<int,int,int,int>>Q;\n\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>c;\n\t\t\tfor(int k=0;k<21;k++){\n\t\t\t\tif(T[k]==c){\n\t\t\t\t\tx[i][j]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0][1]=1;\n\tQ.push(make_tuple(0,0,0,1));\n\twhile(!Q.empty()){\n\t\ttup=Q.front();\n\t\tQ.pop();\n\t\ta1=get<0>(tup);\n\t\ta2=get<1>(tup);\n\t\ta3=get<2>(tup);\n\t\ta4=get<3>(tup);\n\t\tX=x[a1][a2];\n\t\tif(X>=0 && X<=9){\n\t\t\ta3=X;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X>=10 && X<=13){\n\t\t\ta4=X-10;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==14){\n\t\t\tfor(int n=0;n<4;n++){\n\t\t\t\ta4=n;\n\t\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(X==15){\n\t\t\tif(a3==0){\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==16){\n\t\t\tif(a3==0){\n\t\t\t\ta4=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=0;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==17){\n\t\t\tif(a3==0){\n\t\t\t\ta4=3;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta4=1;\n\t\t\t}\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tab=1;\n\t\tif(X==18 || X==19){\n\t\t\tif(X==19){ab=-1;}\n\t\t\ta3=(a3+ab+16)%16;\n\t\t\tif(dp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]==0){\n\t\t\t\tdp[(a1+dy[a4])%h][(a2+dx[a4])%w][a3][a4]=1;\n\t\t\t\tQ.push(make_tuple((a1+dy[a4])%h,(a2+dx[a4])%w,a3,a4));\n\t\t\t}\n\t\t}\n\t\tif(X==20){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tgoto E;\n\t\t}\n\t}\n\tcout<<\"NO\"<<endl;\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring order[21];\nbool memo[22][22][4][16] = {false};\nint W, H;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst string dir = \"><v^\";\n\nint change(char ch)\n{\n  return dir.find(ch);\n}\n\nbool dfs(int x, int y, int d, int mem) \n{\n  x = (x + W) % W;\n  y = (y + H) % H;\n\n  if (memo[y][x][d][mem])\n    return false;\n  else\n    memo[y][x][d][mem] = true;\n\n  char ch = order[y][x];\n  if (ch == '@')\n    return true;\n  else if (ch == '>' || ch == '<' || ch == 'v' || ch == '^') \n    d = change(ch);\n  else if (ch == '_') \n    d = mem ? 1 : 0;\n  else if (ch == '|') \n    d = mem ? 3 : 2;\n  else if ('0' <= ch && ch <= '9')\n    mem = ch - '0';\n  else if (ch == '+')\n    mem = (mem + 1) % 16;\n  else if (ch == '-')\n    mem = (mem + 15) % 16;\n  else if (ch == '?') {\n    for (int i = 0; i < 4; i++) {\n      if (dfs(x + dx[i], y + dy[i], i, mem))\n\ttrue;\n    }\n    return false;\n  }\n  \n  return dfs(x + dx[d], y + dy[d], d, mem);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> order[i];\n\n  if (dfs(0, 0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int h,w;\n  cin>>h>>w;\n  char a[20][20];\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      cin>>a[j][i];\n  int b[20][20][4][16];\n  memset(b,0,sizeof(b));\n  queue<pair<pair<int,int>,pair<int,int> > > c;\n  c.push(make_pair(make_pair(0,0),make_pair(0,0)));\n  while(c.empty()==0){\n    int x,y,d,m;\n    x=c.front().first.first;\n    y=c.front().first.second;\n    d=c.front().second.first;\n    m=c.front().second.second;\n    if(a[x][y]=='@')\n      break;\n    c.pop();\n    if(b[x][y][d][m]==0){\n      b[x][y][d][m]=1;\n      switch(a[x][y]){\n      case '<':\n\tc.push(make_pair(make_pair(x?x-1:w-1,y),make_pair(2,m)));\n\tbreak;\n      case '>':\n\tc.push(make_pair(make_pair(x+1==w?0:x+1,y),make_pair(0,m)));\n\tbreak;\n      case '^':\n\tc.push(make_pair(make_pair(x,y?y-1:h-1),make_pair(3,m)));\n\tbreak;\n      case 'v':\n\tc.push(make_pair(make_pair(x,y+1==h?0:y+1),make_pair(1,m)));\n\tbreak;\n      case '_':\n\tif(m){\n\t  c.push(make_pair(make_pair(x?x-1:w-1,y),make_pair(2,m)));\n\t}else{\n\t  c.push(make_pair(make_pair(x+1==w?0:x+1,y),make_pair(0,m)));\n\t}\n\tbreak;\n      case '|':\n\tif(m){\n\t  c.push(make_pair(make_pair(x,y?y-1:h-1),make_pair(3,m)));\n\t}else{\n\t  c.push(make_pair(make_pair(x,y+1==h?0:y+1),make_pair(1,m)));\n\t}\n\tbreak;\n      case '?':\n\tc.push(make_pair(make_pair(x?x-1:w-1,y),make_pair(2,m)));\n\tc.push(make_pair(make_pair(x+1==w?0:x+1,y),make_pair(0,m)));\n\tc.push(make_pair(make_pair(x,y?y-1:h-1),make_pair(3,m)));\n\tc.push(make_pair(make_pair(x,y+1==h?0:y+1),make_pair(1,m)));\n\tbreak;\n      case '+':\n      case '-':\n\tif(a[x][y]=='+')\n\t  m=(m+1)%16;\n\telse\n\t  m=m?m-1:15;\n      case '.':\n\tif(0){\n\t}else if(d==0){\n\t  c.push(make_pair(make_pair(x+1==w?0:x+1,y),make_pair(0,m)));\n\t}else if(d==1){\n\t  c.push(make_pair(make_pair(x,y+1==h?0:y+1),make_pair(1,m)));\n\t}else if(d==2){\n\t  c.push(make_pair(make_pair(x?x-1:w-1,y),make_pair(2,m)));\n\t}else if(d==3){\n\t  c.push(make_pair(make_pair(x,y?y-1:h-1),make_pair(3,m)));\n\t}\n\tbreak;\n      default:\n\tm=a[x][y]-'0';\n\tif(0){\n\t}else if(d==0){\n\t  c.push(make_pair(make_pair(x+1==w?0:x+1,y),make_pair(0,m)));\n\t}else if(d==1){\n\t  c.push(make_pair(make_pair(x,y+1==h?0:y+1),make_pair(1,m)));\n\t}else if(d==2){\n\t  c.push(make_pair(make_pair(x?x-1:w-1,y),make_pair(2,m)));\n\t}else if(d==3){\n\t  c.push(make_pair(make_pair(x,y?y-1:h-1),make_pair(3,m)));\n\t}\n\tbreak;\n      }\n    }\n  }\n  cout<<(c.empty()?\"NO\":\"YES\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint H,W;\nconst int MAX_R = 20;\nconst int MAX_C = 20;\n\nchar data[MAX_R][MAX_C];\nbool vis[16][4][MAX_R][MAX_C];\n\n\nint dy[] = {-1,0,1,0};\nint dx[] = {0,1,0,-1};\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nvoid input(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> data[i][j];\n    }\n  }\n}\n\nbool run(int d,int x,int y,int buf){\n  vis[buf][d][x][y] = true;\n  while(1){\n    switch(data[y][x]){\n    case '<': \n      d = L;\n      break;\n    case '>':\n      d = R;\n      break;\n    case '^':\n      d = U;\n      break;\n    case 'v':\n      d = D;\n      break;\n    case '_':\n      if(buf == 0)d = R;\n      else d = L;\n      break;\n    case '|':\n      if(buf == 0)d = D;\n      else d = U;\n      break;\n    case '?':\n      for(int i = 0 ; i < 4 ; i++){\n\tint nx,ny;\n\n\tnx = (x + dx[i])%W;\n\tny = (y + dy[i])%H;\n\tif(vis[buf][i][ny][nx])continue;\n\tvis[buf][i][ny][nx] = true;\n\tif(run(i,nx,ny,buf))return true;\n      }\n      break;\n    case '.':\n      break;\n    case '@':\n      return true;\n      break;\n    case '+':\n      buf = (buf+1)%16;\n      break;\n    case '-':\n      buf = (16+buf-1)%16;\n      break;\n    default: // numbe\n      buf = (data[y][x] - '0');\n      break;\n    }\n    x = (x + dx[d])%W;\n    y = (y + dy[d])%H;\n    if(vis[buf][d][y][x])return false;\n    vis[buf][d][y][x] = true;\n  }\n  return false;\n}\n\nint main(){\n  input();\n  for(int ii = 0 ; ii < 16 ; ii++){\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < H ; j++){\n\tfor(int k = 0 ; k < W ; k++){\n\t  vis[ii][i][j][k] = false;\n\t}\n      }\n    }\n  }\n  if(run(R,0,0,0))cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\nchar dir[7]=\"<>^v\";\nchar m[30][30];\nint bfs[30][30][20][4];\nstruct wolf{\n\tint r,c,b,d;\n\twolf(){}\n\twolf(int R,int C,int B,int D){\n\t\tr=R;c=C;b=B;d=D;\n\t}\n};\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",m[i]);\n\tqueue<wolf>Q;\n\tif(m[0][0]=='?'){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tbfs[0][0][0][i]=1;\n\t\t\tQ.push(wolf(0,0,0,i));\n\t\t}\n\t}else{\n\t\tint fb=0;int fd=1;\n\t\t\n\t\tif(m[0][0]=='|'){\n\t\t\tfd=3;\n\t\t}\n\t\tif(m[0][0]=='_'){\n\t\t\tfd=1;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(m[0][0]==dir[i]){\n\t\t\t\tfd=i;\n\t\t\t}\n\t\t}\n\t\tif(m[0][0]=='+')fb=1;\n\t\tif(m[0][0]=='-')fb=15;\n\t\tif('0'<=m[0][0]&&m[0][0]<='9')fb=m[0][0]-'0';\n\t\t\n\t\tbfs[0][0][fb][fd]=1;\n\t\tQ.push(wolf(0,0,fb,fd));\n\t}\n\twhile(Q.size()){\n\t\twolf at=Q.front();\n\t\tQ.pop();\n\t\tint tr=(at.r+dx[at.d]+a)%a;\n\t\tint tc=(at.c+dy[at.d]+b)%b;\n\t\tint tb=at.b;\n\t\tint td=at.d;\n\t\tif(m[tr][tc]=='?'){\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(!bfs[tr][tc][tb][i]){\n\t\t\t\t\tbfs[tr][tc][tb][i]=1;\n\t\t\t\t\tQ.push(wolf(tr,tc,tb,i));\n\t\t\t\t}\n\t\t\t}continue;\n\t\t}\n\t\tif(m[tr][tc]=='|'){\n\t\t\tif(tb){\n\t\t\t\ttd=2;\n\t\t\t}else{\n\t\t\t\ttd=3;\n\t\t\t}\n\t\t}\n\t\tif(m[tr][tc]=='_'){\n\t\t\tif(tb)td=0;\n\t\t\telse td=1;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(m[tr][tc]==dir[i]){\n\t\t\t\ttd=i;\n\t\t\t}\n\t\t}\n\t\tif(m[tr][tc]=='+')tb=(tb+1)%16;\n\t\tif(m[tr][tc]=='-')tb=(tb+15)%16;\n\t\tif('0'<=m[tr][tc]&&m[tr][tc]<='9')tb=m[tr][tc]-'0';\n\t\tif(!bfs[tr][tc][tb][td]){\n\t\t\tbfs[tr][tc][tb][td]=1;\n\t\t\tQ.push(wolf(tr,tc,tb,td));\n\t\t}\n\t}\n\tbool ok=false;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(m[i][j]=='@'){\n\t\tfor(int k=0;k<16;k++)for(int l=0;l<4;l++)if(bfs[i][j][k][l])ok=true;\n\t}\n\tif(ok)printf(\"YES\\n\");else printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  queue<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.front(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n    int ty,tx;\n\n    if(grid[y][x] == '.'){\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == '>'){\n      d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == 'v'){\n      d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == '<'){\n      d = 2;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == '^'){\n      d = 3;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == '?'){\n      for(int i=0;i<4;i++){\n\tty = (y+dy[i])%r; tx = (x+dx[i])%c;\n\tv[ty][tx][i][m] = true;\n      }\n    }\n    else if(grid[y][x] == '_'){\n      if(m)d = 2;\n      else d = 0;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == '|'){\n      if(m)d = 3;\n      else d = 1;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n    else if(grid[y][x] == '+'){\n      m = (m+1)%16;\n      ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n      v[ty][tx][d][m] = true;\n    }\n   else if(grid[y][x] == '+'){\n     m = (m+15)%16;\n     ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n     v[ty][tx][d][m] = true;\n   }else if(grid[y][x] = '@'){\n     f = true;\n     break;\n   }\n   else{\n     m = grid[y][x] - '0';\n     ty = (y+dy[d])%r; tx = (x+dx[d])%c;\n     v[ty][tx][d][m] = true;\n   }\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n \nconst int MAXR = 21;\nconst int MAXC = 21;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n \nstruct State {\n  int i, j, d, m;\n  State();\n  State(int i, int j, int d, int m)\n    : i(i), j(j), d(d), m(m) {}\n};\n \nint R, C;\nchar G[MAXR][MAXC];\nbool vis[MAXR][MAXC][4][16];\n \nbool canFinish() {\n  State s(0,0,0,0);\n  queue<State> que;\n  que.push(s);\n  fill(vis[0][0][0], vis[MAXR][0][0], false);\n  vis[s.i][s.j][s.d][s.m] = true;\n \n  while(!que.empty()) {\n    s = que.front();\n    que.pop();\n \n    if(isdigit(G[s.i][s.j])) {\n      s.m = G[s.i][s.j] - '0';\n    } else {\n      switch(G[s.i][s.j]) {\n      case '<':\n        s.d = 2;\n        break;\n      case '>':\n        s.d = 0;\n        break;\n      case '^':\n        s.d = 3;\n        break;\n      case 'v':\n        s.d = 1;\n        break;\n      case '_':\n        if(s.m == 0) s.d = 0;\n        else s.d = 2;\n        break;\n      case '|':\n        if(s.m == 0) s.d = 1;\n        else s.d = 3;\n        break;\n      case '?':\n        s.d = -1;\n        break;\n      case '.':\n        //\n        break;\n      case '@':\n        return true;\n      case '+':\n        s.m = (s.m+1)%16;\n        break;\n      case '-':\n        s.m = (s.m-1+16)%16;\n        break;\n      }\n    }\n \n    vector<State> next;\n    if(s.d == -1) {\n      for(s.d = 0; s.d < 4; ++s.d) {\n        next.push_back(s);\n      }\n    } else {\n      next.push_back(s);\n    }\n \n    for(int k = 0; k < next.size(); ++k) {\n      State &t = next[k];\n      t.i = (t.i + di[t.d] + R) % R;\n      t.j = (t.j + dj[t.d] + C) % C;\n      if(vis[t.i][t.j][t.d][t.m]) continue;\n      vis[t.i][t.j][t.d][t.m] = true;\n      que.push(t);\n    }\n  }\n  return false;\n}\n \nint main() {\n  while(cin >> R >> C) {\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    if(canFinish()) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include <iterator>\n#include<queue>\n#include <functional>\n#include <string>\n#include <numeric>\n#include<stack>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) v.begin(),v.end()\nusing namespace std;\nconst int dx[4] = { -1, 1, 0, 0 };\nconst int dy[4] = { 0, 0, -1, 1 };\nstruct aaa{\n\tint x;\n\tint y;\n\tint d;\n\tint m;\n};\n\nstruct data\n{\n\tbool memo[20][20][16][4];\n\tdata(){\n\t\tREP(i, 20)\n\t\t\tREP(j, 20)\n\t\t\tREP(k, 16)\n\t\t\tREP(l, 4)\n\t\t\tmemo[i][j][k][l] = false;\n\t}\n};\nstack<aaa> az;\nbool memo[20][20][16][4] = {};\nvector<string> Fi;\nint R=0, C=0;\nbool a(int ax, int ay,int Memory, int Muki){\n\taz.push({ ax, ay, Memory, Muki });\n\twhile (!az.empty()){\n\t\tint ax = (az.top().x + C) % C, ay = (az.top().y + R) % R, Memory = az.top().d, Muki = az.top().m;\n\t\taz.pop();\n\t\tif (memo[ax][ay][Memory][Muki])break;\n\t\tmemo[ax][ay][Memory][Muki] = true;\n\t\tswitch (Fi[ay][ax]){\n\t\tcase '<':Muki = 0; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '>':Muki = 1; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '^':Muki = 2;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase 'v':Muki = 3; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '_':Muki = Memory ? 0 : 1;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '|':Muki = Memory ? 2 : 3;  ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '?':REP(i, 4){\n\t\t\taz.push({ ax + dx[i], ay + dy[i], Memory, i });\n\t\t}\n\t\t\t\t break;\n\t\tcase '.': ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '@':return true;\n\t\tcase '+':Memory = (Memory + 1) % 16; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tcase '-':Memory = (Memory + 15) % 16; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\tdefault:Memory = Fi[ay][ax] - 48; ax += dx[Muki], ay += dy[Muki]; az.push({ ax, ay, Memory, Muki }); break;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin >> R >> C;\n\tFi.resize(20);\n\tREP(i, R){\n\t\tstring st;\n\t\tcin >> Fi[i];\n\t}\n\tdata adata;\n\tif (a(0, 0, 0, 1)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse{\n\t\tcout << \"NO\" << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n/*\n memory????????±???????????§??±????????????????????£?????????\n*/\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nvoid analyzer(char symbol, State& state) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col, State state) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    cout<<program[row][col]<<\" \";\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col], state);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (C-1 < nx) nx = 0;\n            if (nx < 0) nx = C-1;\n            if (R-1 < ny) ny = 0;\n            if (ny < 0) ny = R-1;\n            dfs(ny, nx, state);\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        if (C-1 < nx) nx = 0;\n        if (nx < 0) nx = C-1;\n        if (R-1 < ny) ny = 0;\n        if (ny < 0) ny = R-1;\n        dfs(ny, nx, state);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    State state(0, 0, 0, 0);\n    dfs(0, 0, state);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nbool visited[21][21][16];\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[4] = { 0, 1, 0, -1};\nint dy[4] = { 1, 0, -1, 0};\nchar map[22][22];\nbool memo[16][22][22][4];\nint f,r,c;\n\nvoid search(int m, int x, int y, int d){\n//cout<<x<<y<<endl;\n\n\tif(memo[m][x][y][d]) return;\n\tmemo[m][x][y][d] = 1;\n\tif(map[x][y] == NULL) return;\n\telse if(map[x][y] >= '0' && map[x][y] <= '9') m = (int)(map[x][y] - '0');\n\n\tswitch(map[x][y]){\n\t\tcase '<': d = 2; break;\n\t  case '>': d = 0; break;\n\t\tcase '^': d = 3; break;\n\t\tcase 'v': d = 1; break;\n\t\tcase '_':\tif(m) d = 2;\n\t\t\t\t\t\t\telse  d = 0;\n\t\t\t\t\t\t\tbreak;\n\t\tcase '|': if(m) d = 3;\n\t\t\t\t\t\t\telse  d = 1;\n\t\t\t\t\t\t\tbreak;\n\t\tcase '+': m = (m+1)%16; break;\n\t\tcase '-': m = (m+15)%16; break;\n\t\tcase '@': f=1; return;\n\t}\n\n\tif(map[x][y] == '?')\n\t\tfor(int i = 0; i < 4; i++) search( m, (x + dx[i]+r)%r, (y + dy[i]+c)%c, i);\n\telse search( m, (x + dx[d]+r)%r, (y + dy[d]+c)%c, d);\n}\n\nint main(){\n\tint i,j;\n\tchar s;\n\tcin >> r >> c;\n\tfor(i = 0; i < r; i++)\n\t\tfor(j = 0; j < c; j++){ cin >> s; map[i][j] =s;}\n\n\tsearch( 0, 0, 0, 0);\n\tif(f) cout << \"YES\" <<endl;\n\telse cout << \"NO\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  int mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mDir(dir),mMemory(memory),mX(x),mY(y) {}\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {}\n};\nstruct DIR_MEM{\n  int mDir;\n  int mMemory;\n};\n\nstruct DIR_MEM ReadCommand(char _command,int _memory,int _dir){\n  int memory=_memory;\n  int dir=_dir;\n  switch(_command){\n  case '<':// '<' … 実行の向きを左にする．\n    dir = (1<<3);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '>':// '>' … 実行の向きを右にする．\n    dir = (1<<1);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '^':// '^' … 実行の向きを上にする\n    dir = (1<<0);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case 'v':// 'v' … 実行の向きを下にする．\n    dir = (1<<2);//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n    dir = (_memory == 0 ? (1<<1) : (1<<3));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n    dir = (_memory == 0 ? (1<<2) : (1<<0));//U:=0,R:=1,D:=2,L:=3\n    break;\n  case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n    dir = (1<<4) - 1;\n    break;\n  case '.':// '.' … 何もしない．\n    break;\n  case '@':// '@' … プログラムの実行を停止する．\n    break;\n  case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n  case '3':case '4':case '5':\n  case '6':case '7':case '8':case '9':\n    memory = _command - '0';\n    break;\n  case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n    memory = (_memory == 15 ? 0 : _memory + 1);\n    break;\n  case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n    memory = (_memory == 0 ? 15 : _memory - 1);\n    break;\n  default:\n    break;\n  }\n\n  struct DIR_MEM dm = {dir,memory};\n  return dm;\n}\n\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  if(gx == -1 && gy == -1)return false;\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nbool visited[21][21][16];\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx=-1;\n    int gy=-1;\n\n\n    memset(visited,0,sizeof(visited));\n\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State((1<<1),0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      struct DIR_MEM dm = ReadCommand(command,s.mMemory,s.mDir);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      for(int dir=0;dir<4;dir++){\n\tif(!(dm.mDir & (1<<dir))) continue;\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][dm.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next((1<<dir),dm.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][dm.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 21;\nconst int MAX_W = 21;\nconst int MAX_M = 17;\n\nint H, W;\nstring M[MAX_H];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory+1 == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory-1 == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n    for(int i=0;i<=20;i++){\n      memset(visited[i],0,sizeof(visited[i]));\n    }\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] == '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d command:%c\\n\",s.mMemory,x,y,command);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    // printf(\"%d %d\\n\",gx,gy);\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n#define INF (1<<30)\n#define INFLL (1LL<<62LL)\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n  \nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n  \n#define DOWN   0\n#define RIGHT 1\n#define UP       2\n#define LEFT   3\n  \nstruct State {\n    int x, y;\n    int mem;\n    int dir;\n  \n    State() :\n            x(0),\n            y(0),\n            mem(0),\n            dir(RIGHT) {}\n  \n    State(int x, int y, int mem, int dir) :\n            x(x),\n            y(y),\n            mem(mem),\n            dir(dir) {}\n  \n    bool operator<(const State & rhs) const {\n        if (x == rhs.x && y == rhs.y && mem == rhs.mem) return dir < rhs.dir;\n        if (x == rhs.x && y == rhs.y) return mem < rhs.mem;\n        if (x == rhs.x) return y < rhs.y;\n        return x < rhs.x;\n    }\n};\n  \nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int R, C;\n    cin >> R >> C;\n    vector<string> prog(R);\n    rep(i, R) cin >> prog[i];\n  \n    set<State> visited;\n    queue<State> Q;\n    ll ok = false;\n  \n    Q.push(State());\n    while (!Q.empty()) {\n        State st = Q.front();\n        Q.pop();\n  \n        st.x = (st.x + C) % C;\n        st.y = (st.y + R) % R;\n  \n        if (visited.find(st) != visited.end())\n            continue;\n          \n        visited.insert(st);\n  \n        char p;\n        p = prog[st.y][st.x];\n  \n        if (p == '@') {\n            ok = true;\n            break;\n        }\n  \n        switch (p) {\n            case '0'...'9':\n                st.mem = p - '0';\n                break;\n            case '_':\n                if (st.mem == 0) st.dir = RIGHT;\n                else st.dir = LEFT;\n                break;\n            case '|':\n                if (st.mem == 0) st.dir = DOWN;\n                else st.dir = UP;\n                break;\n            case '+':\n                st.mem = (st.mem + 1) % 16;\n                break;\n            case '-':\n                st.mem = st.mem - 1;\n                if (st.mem < 0) st.mem += 16;\n                break;\n            case '^':\n                st.dir = UP;\n                break;\n            case 'v':\n                st.dir = DOWN;\n                break;\n            case '<':\n                st.dir = LEFT;\n                break;\n            case '>':\n                st.dir = RIGHT;\n                break;\n        }\n  \n        if (p != '?') {\n            Q.push(State(st.x + dx[st.dir], st.y + dy[st.dir], st.mem, st.dir));\n        } else {\n            Q.push(State(st.x + dx[LEFT],     st.y + dy[LEFT],   st.mem, LEFT));\n            Q.push(State(st.x + dx[RIGHT],   st.y + dy[RIGHT], st.mem, RIGHT));\n            Q.push(State(st.x + dx[UP],         st.y + dy[UP],       st.mem, UP));\n            Q.push(State(st.x + dx[DOWN],     st.y + dy[DOWN],   st.mem, DOWN));\n        }\n    }\n      \n    if (ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int pos[]={1,0,-1,0};\nstruct state{\n\tchar x,y,p,mem;\n\tbool operator==(const state &A)const{\n\t\treturn A.x==x&&A.y==y&&A.p==p&&A.mem==mem;\n\t}\n};\n\nbool check(state A,const vector<string> &code,int r,int c,vector<state> &visited){\n  char op=code[A.y][A.x];\n  while(op!='@'){\n  \tif(count(visited.begin(),visited.end(),A))return false;\n  \tvisited.push_back(A);\n  \top=code[A.y][A.x];\n  \t//cerr<<A.x<<\",\"<<A.y<<endl;\n  \tif(op=='>')A.p=0;\n  \tif(op=='v')A.p=1;\n  \tif(op=='<')A.p=2;\n  \tif(op=='^')A.p=3;\n  \tif(op=='_')A.p=(A.mem)?2:0;\n  \tif(op=='|')A.p=(A.mem)?3:1;\n   \tif('0'<=op&&op<='9')A.mem=op-'0';\n   \tif(op=='+')A.mem=(A.mem+1)%16;\n   \tif(op=='-')A.mem=(A.mem+15)%16;\n   \tif(op=='?'){\n   \t\tbool f=false;\n   \t\tfor(int i=0;i<4;++i){\n   \t\t\tstate tmp=A;\n   \t\t\ttmp.p=i;\n   \t\t\ttmp.x=(tmp.x+pos[tmp.p]+c)%c;tmp.y=(tmp.y+pos[(tmp.p+3)%4]+r)%r;\n   \t\t\tif(check(tmp,code,r,c,visited))return true;\n   \t\t}\n   \t\treturn false;\n   \t}\n   \t\n  \tA.x=(A.x+pos[A.p]+c)%c;A.y=(A.y+pos[(A.p+3)%4+r])%r;\n  }\n  return true;\n}\n\nint main(void){\n  int r,c;\n  cin>>r>>c;\n  vector<string> code;\n  for(int i=0;i<r;++i){string s;cin>>s;code.push_back(s);}\n  state A={0,0,0,0};\n  vector<state> visited;\n  cout<<(check(A,code,r,c,visited)?\"YES\":\"NO\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DbgPass(a) cout<<\"-- pass: \"<< a << endl\n#define DbgMap(m,r,c) rep(dbgI,r){rep(dbgJ,c){cout<<m[dbgI][dbgJ];}cout<<endl;}\n#define makeMapFromInput(m,r,c) rep(sysI,r){rep(sysJ,c){cin>>m[sysI][sysJ];}cin.ignore();}\n\n#define LEFT  0\n#define UP    1\n#define RIGHT 2\n#define DOWN  3\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nchar code[21][21];\nint R, C;\nbool visited[21][21][4][15];\n\nstruct State {\n  int x,y,d,m;\n  State();\n  State(int xx, int yy, int dd, int mm)\n    : x(xx),y(yy),d(dd),m(mm) {}\n};\n\n//int getX(int xx) { return (xx+C)%C; }\n//int getY(int yy) { return (yy+R)%R; }\n\nbool run() {\n  queue<State> Q;\n  State s = State(0,0,LEFT,0);\n  Q.push(s);\n  fill(visited[0][0][0], visited[21][0][0], false);\n  \n  State st=State(0,0,0,0), ne=State(0,0,0,0);\n  while(!Q.empty()) {\n    st = Q.front(); Q.pop();\n    //DbgPass(code[st.y][st.x]);\n    visited[st.x][st.y][st.d][st.m] = true;\n\n    ne = st;\n    switch(code[st.y][st.x]) {\n    case '<': ne.d = LEFT;  break;\n    case '^': ne.d = UP;    break;\n    case '>': ne.d = RIGHT; break;\n    case 'v': ne.d = DOWN;  break;\n    case '.': ne.d = st.d;  break;\n    case '@': return true;\n    case '+': ne.m = (st.m+1)%16;  break;\n    case '-': ne.m = (st.m+15)%16; break;\n    case '_':\n      if(st.m==0) ne.d = RIGHT;\n      else ne.d = LEFT;\n      break;\n    case '|':\n      if(st.m==0) ne.d = DOWN;\n      else ne.d = UP;\n      break;\n    default:\n      if(isdigit(code[st.y][st.x])) ne.m = code[st.y][st.x]-'0';\n      else assert(1);\n    }\n    \n    if(code[st.y][st.x]=='?') {\n      for(int i=0; i<4; i++) {\n\tne.x = (st.x+dx[i]+C)%C, ne.y = (st.y+dy[i]+R)%R, ne.d = i;\n\tif(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n      }\n    }\n    else {\n      //DbgPass(\"move\");\n      ne.x = (st.x+dx[ne.d]+C)%C, ne.y = (st.y+dy[ne.d]+R)%R;\n      if(!visited[ne.x][ne.y][ne.d][ne.m]) Q.push(ne);\n    }\n  }\n  \n  return false;\n}\n\nint main() {\n  cin>>R>>C; cin.ignore();\n  makeMapFromInput(code,R,C);\n  //DbgMap(code,R,C);\n\n  cout << ( run() ? \"YES\" : \"NO\" ) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX = 20;\n\nstring program[MAX];\nint log[MAX][MAX];\n\nint R, C;\nbool stop;\n\nstruct State {\n    State(int r, int c, int m, int d) \n        : row(r), col(c), memory(m), dir(d) {}\n\n    int row;\n    int col;\n    int memory;\n\n    /*  \n        1\n\n    2       0\n        \n        3\n    */\n    int dir;\n};\n\nState state(0, 0, 1, 0);\n\nvoid analyzer(char symbol) {\n    switch (symbol) {\n        case '<':\n            state.dir = 2;\n            break;\n\n        case '>':\n            state.dir = 0;\n            break;\n\n        case '^':\n            state.dir = 1;\n            break;\n\n        case 'v':\n            state.dir = 3;\n            break;\n\n        case '_':\n            if (state.memory == 0) state.dir = 0;\n            else state.dir = 2;\n            break;\n\n        case '|':\n            if (state.memory == 0) state.dir = 3;\n            else state.dir = 1;\n            break;\n\n        case '?':\n            break;\n\n        case '.':\n            break;\n\n        case '@':\n            stop = true;\n            break;\n\n        case '+':\n            if (state.memory == 15) state.memory = 0;\n            else state.memory++;\n            break;\n\n        case '-':\n            if (state.memory == 0) state.memory = 15;\n            else state.memory--;\n            break;\n\n        default: \n            int num = atoi(&symbol);\n            state.memory = num;\n            break;\n    }\n}\n\nvoid dfs(int row, int col) {\n    int nx, ny;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n\n    if (log[col][row] > 10) return;\n\n    log[col][row]++;\n    analyzer(program[row][col]);\n\n    if (stop) return;\n\n    if (program[row][col] == '?') {\n        for (int i = 0; i < 4; i++) {\n            nx = col + dx[i];\n            ny = row + dy[i];\n            if (0 <= nx && nx < C && 0 <= ny && ny < R) {\n                dfs(ny, nx);\n            }\n        }\n    }else {\n        nx = col + dx[state.dir];\n        ny = row + dy[state.dir];\n        dfs(ny, nx);\n    }\n}\n\n\nint main(int argc, char const *argv[]) {\n    cin>>R>>C;\n    for (int row = 0; row < R; row++) {\n        cin>>program[row];\n    }\n\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            log[i][j] = -1;\n        }\n    }\n\n    dfs(0, 0);\n\n    if (stop) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\nconst int MAX_M = 15;\n\nint H, W;\nstring M[20];\nbool vis[MAX_M][4][MAX_H][MAX_W];\n\nbool run( int x, int y, int dir, int mem ) {\n  \n  if(vis[mem][dir][y][x]) return 0;\n  vis[mem][dir][y][x] = 1;\n  \n  bool flag = 0;\n  \n  switch(M[y][x]) {\n  case '<': dir = 0; break;\n  case '>': dir = 2; break;\n  case '^': dir = 1; break;\n  case 'v': dir = 3; break;\n  case '_': dir = ( mem ? 0 : 2 ); break;\n  case '|': dir = ( mem ? 1 : 3 ); break;\n  case '?': flag = 1; break;\n  case '.': break;\n  case '@': return 1;\n  case '+': mem = ( mem + 1 ) % 16; break;\n  case '-': mem = ( mem + 15 ) % 16; break;\n  default:\n    if(isdigit(M[y][x])) {\n      mem = M[y][x]-'0';\n    }\n  }\n\n  if(flag) {\n    for(int i=0; i<4; i++) {\n      if(run((x+dx[i])%W, (y+dy[i])%H, i, mem)) return 1;\n    }\n    return 0;\n  }\n  \n  return run((x+dx[dir])%W, (y+dy[dir])%H, dir, mem);\n}\n\nint main() {\n  \n  cin >> H >> W;\n  cin.ignore();\n  \n  for(int i=0; i<H; i++) getline(cin, M[i]);\n  \n  if(run(0, 0, 2, 0)) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n#define Iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(Iter(c) i = (c).begin();i != (c).end();++i)\n#define Right 1\n#define Left 3\n#define Top 2\n#define Bottom 0\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint R,C;\nchar cmap[20][20];\nbool used[20][20][16][4];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid move(P *coor,int dir,int mem){\n  if(!(0<= (*coor).F+dx[dir] && (*coor).F+dx[dir] < C && 0<= (*coor).S+dy[dir] && (*coor).S+dy[dir] < R)){\n    if(!(0<= (*coor).F+dx[dir] && (*coor).F+dx[dir] < C)){\n      if((*coor).F+dx[dir] >= C){\n\t(*coor).F = 0;\n      }\n      else if((*coor).F+dx[dir] < 0){\n\t(*coor).F = C-1;\n      }\n      else assert(false);\n    }\n    else if(!(0<= (*coor).S+dy[dir] && (*coor).S+dy[dir] < R)){\n      if((*coor).S+dy[dir] >= R){\n\t(*coor).S = 0;\n      }\n      else if((*coor).S+dy[dir] < 0){\n\t(*coor).S = R-1;\n      }\n      else assert(false);\n    }\n    else assert(false);\n\n  }\n  else (*coor).F += dx[dir],(*coor).S += dy[dir];\n \n}\n\n\nint main(){\n \n  cin >> R >> C;\n  \n  \n  rep(i,R){\n    string s;\n    cin >> s;\n    rep(j,C){\n      cmap[i][j] = s[j];\n      rep(k,16)\n\trep(l,4)used[i][j][k][l] = false;\n    }\n  }\n\n  \n  queue<PP> que;\n  que.push(PP(P(0,0),P(0,1)));//PP(P(x,y),P(memory,direction))\n  //used[0][0][0][1] = true;\n\n  while(!que.empty()){\n    PP pi = que.front(); que.pop();\n    P coor = pi.F;\n    int mem = pi.S.F;\n    int dir = pi.S.S;\n    //cout << cmap[coor.S][coor.F] << \" : coor(\" << coor.F << \",\" << coor.S << \") , mem: \" << mem << \", dir : \"  << dir << endl;\n    if(cmap[coor.S][coor.F] == '@'){\n      cout << \"YES\" << endl;\n      return 0;\n    }\n\n    if(used[coor.S][coor.F][mem][dir])continue;\n    used[coor.S][coor.F][mem][dir] = true;\n\n    if('0' <= cmap[coor.S][coor.F] && cmap[coor.S][coor.F] <= '9'){\n      mem = (int)(cmap[coor.S][coor.F]-'0');\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    }\n    else if(cmap[coor.S][coor.F] == '.'){\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    }\n    else if(cmap[coor.S][coor.F] == '+'){\n      mem = (mem+1)%16;\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    }\n    else if(cmap[coor.S][coor.F] == '-'){\n      mem--;\n      if(mem < 0)mem = 15;\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    }\n    else if(cmap[coor.S][coor.F] == '_'){\n      dir = !mem?1:3;\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    }\n    else if(cmap[coor.S][coor.F] == '|'){\n      dir = !mem?0:2;\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    }\n    else if(cmap[coor.S][coor.F] == '?'){\n      rep(i,4){\n\tP coor_bk = coor;\n\tmove(&coor_bk,i,mem);\n\tque.push(PP(coor_bk,P(mem,i)));\n      }\n    }\n    else {\n      dir = cmap[coor.S][coor.F] =='<'?Left:cmap[coor.S][coor.F] == '>'?Right:cmap[coor.S][coor.F] == '^'?Top:Bottom;\n      move(&coor,dir,mem);\n      que.push(PP(coor,P(mem,dir)));\n    } \n  }\n  cout << \"NO\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include <iterator>\n#include<queue>\n#include <functional>\n#include <string>\n#include <numeric>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) v.begin(),v.end()\nusing namespace std;\nconst int dx[4] = { -1, 1, 0, 0 };\nconst int dy[4] = { 0, 0, -1, 1 };\nstruct data\n{\n\tbool memo[20][20][16][4];\n\tdata(){\n\t\tREP(i, 20)\n\t\t\tREP(j, 20)\n\t\t\tREP(k, 16)\n\t\t\tREP(l, 4)\n\t\t\tmemo[i][j][k][l] = false;\n\t}\n};\nint R=0, C=0;\nbool a(int ax, int ay, vector<string> Fi,int Memory, int Muki,data aa){\n\tax=(ax+C)% C;ay=(ay+R) % R;\n\tif (aa.memo[ax][ay][Memory][Muki])return false;\n\taa.memo[ax][ay][Memory][Muki] = true;\n\tswitch (Fi[ay][ax]){\n\tcase '<':Muki = 0; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki,aa);\n\tcase '>':Muki = 1;; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '^':Muki = 2; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase 'v':Muki = 3; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '_':Muki = Memory ? 0 : 1; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '|':Muki = Memory ? 2 : 3; return a(ax + dx[Muki], ay + dy[Muki], Fi, Memory, Muki, aa);\n\tcase '?': return a(ax + dx[0], ay + dy[0], Fi, Memory, 0, aa) || a(ax + dx[1], ay + dy[1], Fi, Memory, 1, aa) || a(ax + dx[2], ay + dy[2], Fi, Memory, 2, aa) || a(ax + dx[3], ay + dy[3], Fi, Memory, 3, aa);\n\tcase '.':return a(ax + dx[Muki], ay + dy[Muki], Fi,Memory, Muki, aa);\n\tcase '@':return true;\n\tcase '+':return a(ax + dx[Muki], ay + dy[Muki], Fi, (Memory + 1) % 16, Muki, aa);\n\tcase '-':return a(ax + dx[Muki], ay + dy[Muki], Fi, (Memory+15) % 16, Muki, aa);\n\tdefault:return a(ax + dx[Muki], ay + dy[Muki], Fi, Fi[ay][ax]-48, Muki, aa);\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> R >> C;\n\tvector<string> Field(R);\n\tREP(i, R){\n\t\tstring st;\n\t\tcin >> Field[i];\n\t}\n\tdata adata;\n\tif (a(0, 0, Field, 0, 1,adata)){\n\t\tcout << \"YES\" << endl;\n\t}\n\telse{\n\t\tcout << \"NO\" << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass State{\npublic:\n  queue<int> mDir;\n  int mMemory;\n  int mX;\n  int mY;\n  State(int dir,int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n    mDir.push(dir);\n  }\n\n  State(int memory,int x,int y) : mMemory(memory),mX(x),mY(y) {\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ClearDir(){\n    while(!mDir.empty()){\n      mDir.pop();\n    }\n  }\n\n  void ReadCommand(char command){\n    switch(command){\n    case '<':// '<' … 実行の向きを左にする．\n      ClearDir();\n      mDir.push(3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '>':// '>' … 実行の向きを右にする．\n      ClearDir();\n      mDir.push(1);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '^':// '^' … 実行の向きを上にする\n      ClearDir();\n      mDir.push(0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case 'v':// 'v' … 実行の向きを下にする．\n      ClearDir();\n      mDir.push(2);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '_':// '_' … メモリの値が 0 ならば実行の向きを右に，そうでなければ左にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 1 : 3);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '|':// '|' … メモリの値が 0 ならば実行の向きを下に，そうでなければ上にする．\n      ClearDir();\n      mDir.push(mMemory == 0 ? 2 : 0);//U:=0,R:=1,D:=2,L:=3\n      break;\n    case '?':// '?' … 実行の向きが上下左右のいずれかにランダムに等確率で変更される\n      ClearDir();\n      mDir.push(0);\n      mDir.push(1);\n      mDir.push(2);\n      mDir.push(3);\n      break;\n    case '.':// '.' … 何もしない．\n      break;\n    case '@':// '@' … プログラムの実行を停止する．\n      break;\n    case '0':case '1':case '2':// '0' - '9' … メモリの値を指定の数値にする．\n    case '3':case '4':case '5':\n    case '6':case '7':case '8':case '9':\n      mMemory = command - '0';\n      break;\n    case '+':// '+' … メモリの値に 1 を加える，ただし値が 15 だった場合 0 にする．\n      mMemory = (mMemory == 15 ? 0 : mMemory + 1);\n      break;\n    case '-':// '-' … メモリの値から 1 を引く，ただし値が 0 だった場合 15 にする．\n      mMemory = (mMemory == 0 ? 15 : mMemory - 1);\n      break;\n    default:\n      break;\n    }\n  }\n};\n\nbool isClear(bool visited[21][21][16],int gx,int gy){\n  for(int i=0;i<=15;i++){\n    if(visited[gx][gy][i]) return true;\n  }\n  return false;\n}\n\n\nint main(){\n  int H,W;\n  int commands[21][21];\n\n  while(~scanf(\"%d %d\",&H,&W)){\n    int gx,gy;\n    bool visited[21][21][16];\n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<H;y++){\n      char buf[21];\n      scanf(\"%s\",buf);\n      for(int x=0;x<W;x++){\n\tcommands[y][x] = buf[x];\n\tif(buf[x] = '@'){\n\t  gx = x;\n\t  gy = y;\n\t}\n      }\n    }\n    \n    queue<State> que;\n    \n    //dir,memory,x,y\n    //U:=0,R:=1,D:=2,L:=3\n    que.push(State(1,0,0,0));\n    visited[0][0][0] = true;\n\n    while(!que.empty()){\n      State s = que.front();\n      que.pop();\n      int x = s.mX;\n      int y = s.mY;\n      char command = commands[y][x];\n      s.ReadCommand(command);\n      // printf(\"mem %d x:%d y:%d\\n\",s.mMemory,x,y);\n\n      while(!s.mDir.empty()){\n\tint dir = s.mDir.front();\n\ts.mDir.pop();\n\n\tint dx = tx[dir] + x;\n\tint dy = ty[dir] + y;\n\n\tif(dx < 0) dx = W-1;\n\tif(dx >= W) dx = 0;\n\tif(dy < 0) dy = H-1;\n\tif(dy >= H) dy = 0;\n\n\tif(visited[dx][dy][s.mMemory]) continue;\n\n\t//dir,memory,x,y\n\tState next(dir,s.mMemory,dx,dy);\n\n\t//[x][y][memory]\n\tvisited[dx][dy][s.mMemory] = true;\n\n\tque.push(next);\n      }\n    }\n    printf(\"%s\\n\",isClear(visited,gx,gy) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2262: Stopping Problem\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define E 0\n#define S 1\n#define W 2\n#define N 3\ntypedef struct { int r, c, mem, dir; } Q;\nQ q[1000]; int top, end;\n\nchar m[22][22];\nchar mk[22][22][16][4];\nint mv[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\n\nint main()  \n{  \n\tint h, w, i, ii, r, c, r2, c2, mem, dir, ans;\n\n\tscanf(\"%d%d\", &h, &w);\n\tfor (r = 0; r < h; r++) scanf(\"%s\", m[r]);\n\tmk[0][0][0][0] = 1;\n\tq[0].r = 0, q[0].c = 0, q[0].mem = 0, q[0].dir = E; top = 0, end = 1;\n\tans = 0;\n\twhile (top < end) {\n\t\tr = q[top].r, c = q[top].c, mem = q[top].mem, dir = q[top++].dir;\n\t\tii = 1;\n\t\tif      (m[r][c] == '<') dir = W;\n\t\telse if (m[r][c] == '>') dir = E;\n\t\telse if (m[r][c] == '^') dir = N;\n\t\telse if (m[r][c] == 'v') dir = S;\n\t\telse if (m[r][c] == '_') dir = mem ? W : E;\n\t\telse if (m[r][c] == '|') dir = mem ? N : S;\n\t\telse if (m[r][c] == '@') { ans = 1; break; }\n\t\telse if (isdigit(m[r][c])) mem = m[r][c] - '0';\n\t\telse if (m[r][c] == '+') { if (++mem > 15) mem = 0; }\n\t\telse if (m[r][c] == '-') { if (--mem < 0) mem = 15; }\n\t\telse if (m[r][c] == '?') ii = 4;\n\n\t\tfor (i = 0; i < ii; i++) {\n\t\t\tr2 = r + mv[(dir+i)&3][0];\n\t\t\tc2 = c + mv[(dir+i)&3][1];\n\t\t\tif      (r2 < 0) r2 = h-1;\n\t\t\telse if (r2 >= h) r2 = 0;\n\t\t\tif      (c2 < 0) c2 = w-1;\n\t\t\telse if (c2 >= w) c2 = 0;\n\t\t\tif (mk[r2][c2][mem][(dir+i)&3]) continue;\n\t\t\tmk[r2][c2][mem][(dir+i)&3] = 1;\n\t\t\tq[end].r = r2, q[end].c = c2, q[end].mem = mem, q[end++].dir = (dir+i)&3;\n\t\t}\n\t}\n\tputs(ans ? \"YES\" : \"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar P[21][21];\nint i,j,C,R,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0},f[20][20][16][4]={0};\n\nint s(int py,int px,int m,int d,int dp)\n{\n\tif(dp>1000000||f[py][px][m][d])\n\t\treturn 0;\n\tf[py][px][m][d]=1;\n\tswitch (P[py][px])\n\t{\n\tcase '<':return s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '>':return s(py,(px+1+C)%C,m,3,dp+1);\n\tcase '^':return s((py-1+R)%R,px,m,0,dp+1);\n\tcase 'v':return s((py+1+R)%R,px,m,1,dp+1);\n\tcase '_':return m==0?s(py,(px+1+C)%C,m,3,dp+1):s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '|':return m==0?s((py+1+R)%R,px,m,1,dp+1):s((py-1+R)%R,px,m,0,dp+1);\n\tcase '?':return s(py,(px+1+C)%C,m,3,dp+1)|s(py,(px-1+C)%C,m,2,dp+1)|s((py+1+R)%R,px,m,1,dp+1)|s((py-1+R)%R,px,m,0,dp+1);\n\tcase '.':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,m,d,dp+1);\n\tcase '@':return 1;\n\tcase '+':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m+1+16)%16,d,dp+1);\n\tcase '-':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m-1+16)%16,d,dp+1);\n\tdefault:return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,P[py][px]-'0',d,dp+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&R,&C);\n\tfor(i=0;i<R;gets(P[i++]));\n\tputs(s(0,0,0,3,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<utility>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int r,c;\n  string grid[30];\n  bool v[30][30][4][20];\n  int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n  bool f = false;\n\n  cin >> r >> c;\n  for(int i=0;i<r;i++){\n    cin >> grid[i];\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)\n\tfor(int l=0;l<16;l++)v[i][j][k][l] = false;\n  }\n\n  v[0][0][0][0] = true;\n  stack<P2> q;\n  q.push(P2(P(0,0),P(0,0)));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int y = p.first.first, x = p.first.second;\n    int d = p.second.first, m = p.second.second;\n\n    for(;;){\n      if(grid[y][x] == '?'){\n\tfor(int i=0;i<4;i++){\n\t  int ty = (y+dy[i])%r, tx = (x+dx[i])%c;\n\t  if(v[ty][tx][i][m])continue;\n\t  v[ty][tx][i][m] = true;\n\t  q.push(P2(P(ty,tx),P(i,m)));\n\t}\n\tbreak;\n      }else if(grid[y][x] == '@'){\n\tf = true;\n\tbreak;\n      }else{\n\tif(grid[y][x] == '>')d = 0;\n\telse if(grid[y][x] == 'v')d = 1;\n\telse if(grid[y][x] == '<')d = 2;\n\telse if(grid[y][x] == '^')d = 3;\n\telse if(grid[y][x] == '_'){\n\t  if(m)d = 2;\n\t  else d = 0;\n\t}\n\telse if(grid[y][x] == '|'){\n\t  if(m)d = 3;\n\t  else d = 1;\n\t}\n\telse if(grid[y][x] == '+')m = (m+1)%16;\n\telse if(grid[y][x] == '-')m = (m+15)%16;\n\telse if(grid[y][x] != '.')m = grid[y][x] - '0';\n\t\n\ty = (y+dy[d])%r; x = (x+dx[d])%c;\n\tif(v[y][x][d][m])break;\n\tv[y][x][d][m] = true;\n      }\n    }\n    if(f)break;\n  }\n\n  if(f)cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar P[21][21];\nint i,j,C,R,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0},f[20][20][16][4]={0};\n\nint s(int py,int px,int m,int d,int dp)\n{\n\tif(dp>10000||f[py][px][m][d])\n\t\treturn 0;\n\tf[py][px][m][d]=1;\n\tswitch (P[py][px])\n\t{\n\tcase '<':return s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '>':return s(py,(px+1+C)%C,m,3,dp+1);\n\tcase '^':return s((py-1+R)%R,px,m,0,dp+1);\n\tcase 'v':return s((py+1+R)%R,px,m,1,dp+1);\n\tcase '_':return m==0?s(py,(px+1+C)%C,m,3,dp+1):s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '|':return m==0?s((py+1+R)%R,px,m,1,dp+1):s((py-1+R)%R,px,m,0,dp+1);\n\tcase '?':return s(py,(px+1+C)%C,m,3,dp+1)|s(py,(px-1+C)%C,m,2,dp+1)|s((py+1+R)%R,px,m,1,dp+1)|s((py-1+R)%R,px,m,0,dp+1);\n\tcase '.':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,m,d,dp+1);\n\tcase '@':return 1;\n\tcase '+':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m+1+16)%16,d,dp+1);\n\tcase '-':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m-1+16)%16,d,dp+1);\n\tdefault:return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,P[py][px]-'0',d,dp+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&R,&C);\n\tfor(i=0;i<R;gets(P[i++]));\n\tputs(s(0,0,0,3,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar P[21][21];\nint i,j,C,R,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0},f[20][20][16]={0};\n\nint s(int py,int px,int m,int d,int dp)\n{\n\tif(dp>1000000||f[py][px][m])\n\t\treturn 0;\n\tf[py][px][m]=1;\n\tswitch (P[py][px])\n\t{\n\tcase '<':return s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '>':return s(py,(px+1+C)%C,m,3,dp+1);\n\tcase '^':return s((py-1+R)%R,px,m,0,dp+1);\n\tcase 'v':return s((py+1+R)%R,px,m,1,dp+1);\n\tcase '_':return m==0?s(py,(px+1+C)%C,m,3,dp+1):s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '|':return m==0?s((py+1+R)%R,px,m,1,dp+1):s((py-1+R)%R,px,m,0,dp+1);\n\tcase '?':return s(py,(px+1+C)%C,m,3,dp+1)|s(py,(px-1+C)%C,m,2,dp+1)|s((py+1+R)%R,px,m,1,dp+1)|s((py-1+R)%R,px,m,0,dp+1);\n\tcase '.':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,m,d,dp+1);\n\tcase '@':return 1;\n\tcase '+':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m+1+16)%16,d,dp+1);\n\tcase '-':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m-1+16)%16,d,dp+1);\n\tdefault:return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,P[py][px]-'0',d,dp+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&R,&C);\n\tfor(i=0;i<R;gets(P[i++]));\n\tputs(s(0,0,0,3,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar P[21][21];\nint i,j,C,R,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0},f[20][20][16]={0};\n\nint s(int py,int px,int m,int d,int dp)\n{\n\tif(dp>1000||f[py][px][m])\n\t\treturn 0;\n\tf[py][px][m]=1;\n\tswitch (P[py][px])\n\t{\n\tcase '<':return s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '>':return s(py,(px+1+C)%C,m,3,dp+1);\n\tcase '^':return s((py-1+R)%R,px,m,0,dp+1);\n\tcase 'v':return s((py+1+R)%R,px,m,1,dp+1);\n\tcase '_':return m==0?s(py,(px+1+C)%C,m,3,dp+1):s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '|':return m==0?s((py+1+R)%R,px,m,1,dp+1):s((py-1+R)%R,px,m,0,dp+1);\n\tcase '?':return s(py,(px+1+C)%C,m,3,dp+1)|s(py,(px-1+C)%C,m,2,dp+1)|s((py+1+R)%R,px,m,1,dp+1)|s((py-1+R)%R,px,m,0,dp+1);\n\tcase '.':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,m,d,dp+1);\n\tcase '@':return 1;\n\tcase '+':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m+1+16)%16,d,dp+1);\n\tcase '-':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m-1+16)%16,d,dp+1);\n\tdefault:return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,P[py][px]-'0',d,dp+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&R,&C);\n\tfor(i=0;i<R;gets(P[i++]));\n\tputs(s(0,0,0,3,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar P[21][21];\nint i,j,C,R,dx[4]={0,0,-1,1},dy[4]={-1,1,0,0},f[20][20][16]={0};\n\nint s(int py,int px,int m,int d,int dp)\n{\n\tif(dp>40||f[py][px][m])\n\t\treturn 0;\n\tf[py][px][m]=1;\n\tswitch (P[py][px])\n\t{\n\tcase '<':return s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '>':return s(py,(px+1+C)%C,m,3,dp+1);\n\tcase '^':return s((py-1+R)%R,px,m,0,dp+1);\n\tcase 'v':return s((py+1+R)%R,px,m,1,dp+1);\n\tcase '_':return m==0?s(py,(px+1+C)%C,m,3,dp+1):s(py,(px-1+C)%C,m,2,dp+1);\n\tcase '|':return m==0?s((py+1+R)%R,px,m,1,dp+1):s((py-1+R)%R,px,m,0,dp+1);\n\tcase '?':return s(py,(px+1+C)%C,m,3,dp+1)|s(py,(px-1+C)%C,m,2,dp+1)|s((py+1+R)%R,px,m,1,dp+1)|s((py-1+R)%R,px,m,0,dp+1);\n\tcase '.':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,m,d,dp+1);\n\tcase '@':return 1;\n\tcase '+':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m+1+16)%16,d,dp+1);\n\tcase '-':return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,(m-1+16)%16,d,dp+1);\n\tdefault:return s((py+dy[d]+R)%R,(px+dx[d]+C)%C,P[py][px]-'0',d,dp+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&R,&C);\n\tfor(i=0;i<R;gets(P[i++]));\n\tputs(s(0,0,0,3,0)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar program[20][24];\n\nchar visited[20][20][16][4];\n\n#define DIR_UP 0\n#define DIR_LEFT 1\n#define DIR_RIGHT 2\n#define DIR_DOWN 3\n\nconst int dxy[4][2]={\n\t{0,-1},{-1,0},{1,0},{0,1}\n};\n\nint runProgram(int x,int y,int mem,int dir) {\n\tint isStop=0;\n\tint i;\n\tif(x<0)x=width-1;\n\tif(x>=width)x=0;\n\tif(y<0)y=height-1;\n\tif(y>=height)y=0;\n\tif(visited[x][y][mem][dir])return visited[x][y][mem][dir]-1;\n\tvisited[x][y][mem][dir]=1;\n\tif(isdigit(program[y][x])) {\n\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],program[y][x]-'0',dir);\n\t} else {\n\t\tswitch(program[y][x]) {\n\t\t\tcase '<':\n\t\t\t\tisStop=runProgram(x-1,y,mem,DIR_LEFT);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tisStop=runProgram(x+1,y,mem,DIR_RIGHT);\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tisStop=runProgram(x,y-1,mem,DIR_UP);\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tisStop=runProgram(x,y+1,mem,DIR_DOWN);\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\tif(mem==0) {\n\t\t\t\t\tisStop=runProgram(x+1,y,mem,DIR_RIGHT);\n\t\t\t\t} else {\n\t\t\t\t\tisStop=runProgram(x-1,y,mem,DIR_LEFT);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '|':\n\t\t\t\tif(mem==0) {\n\t\t\t\t\tisStop=runProgram(x,y+1,mem,DIR_DOWN);\n\t\t\t\t} else {\n\t\t\t\t\tisStop=runProgram(x,y+1,mem,DIR_UP);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tisStop|=runProgram(x-1,y,mem,DIR_LEFT);\n\t\t\t\tisStop|=runProgram(x+1,y,mem,DIR_RIGHT);\n\t\t\t\tisStop|=runProgram(x,y-1,mem,DIR_UP);\n\t\t\t\tisStop|=runProgram(x,y+1,mem,DIR_DOWN);\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],mem,dir);\n\t\t\t\tbreak;\n\t\t\tcase '@':\n\t\t\t\tisStop=1;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],(mem==15)?0:(mem+1),dir);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],(mem==0)?15:(mem-1),dir);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvisited[x][y][mem][dir]+=isStop;\n\treturn isStop;\n}\n\nint main(void) {\n\tint i;\n\tscanf(\"%d%d\",&height,&width);\n\tfor(i=0;i<height;i++)scanf(\"%s\",program[i]);\n\tputs(runProgram(0,0,0,DIR_RIGHT)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar program[20][24];\n\nchar visited[20][20][16][4];\n\n#define DIR_UP 0\n#define DIR_LEFT 1\n#define DIR_RIGHT 2\n#define DIR_DOWN 3\n\nconst int dxy[4][2]={\n\t{0,-1},{-1,0},{1,0},{0,1}\n};\n\nint runProgram(int x,int y,int mem,int dir) {\n\tint isStop=0;\n\tint i;\n\tif(x<0)x=width-1;\n\tif(x>=width)x=0;\n\tif(y<0)y=height-1;\n\tif(y>=height)y=0;\n\tif(visited[x][y][mem][dir])return visited[x][y][mem][dir]-1;\n\tvisited[x][y][mem][dir]=1;\n\tif(isdigit(program[y][x])) {\n\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],program[y][x]-'0',dir);\n\t} else {\n\t\tswitch(program[y][x]) {\n\t\t\tcase '<':\n\t\t\t\tisStop=runProgram(x-1,y,mem,DIR_LEFT);\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tisStop=runProgram(x+1,y,mem,DIR_RIGHT);\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tisStop=runProgram(x,y-1,mem,DIR_UP);\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tisStop=runProgram(x,y+1,mem,DIR_DOWN);\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\tif(mem==0) {\n\t\t\t\t\tisStop=runProgram(x+1,y,mem,DIR_RIGHT);\n\t\t\t\t} else {\n\t\t\t\t\tisStop=runProgram(x-1,y,mem,DIR_LEFT);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '|':\n\t\t\t\tif(mem==0) {\n\t\t\t\t\tisStop=runProgram(x,y+1,mem,DIR_DOWN);\n\t\t\t\t} else {\n\t\t\t\t\tisStop=runProgram(x,y-1,mem,DIR_UP);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tisStop|=runProgram(x-1,y,mem,DIR_LEFT);\n\t\t\t\tisStop|=runProgram(x+1,y,mem,DIR_RIGHT);\n\t\t\t\tisStop|=runProgram(x,y-1,mem,DIR_UP);\n\t\t\t\tisStop|=runProgram(x,y+1,mem,DIR_DOWN);\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],mem,dir);\n\t\t\t\tbreak;\n\t\t\tcase '@':\n\t\t\t\tisStop=1;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],(mem==15)?0:(mem+1),dir);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tisStop=runProgram(x+dxy[dir][0],y+dxy[dir][1],(mem==0)?15:(mem-1),dir);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tvisited[x][y][mem][dir]+=isStop;\n\treturn isStop;\n}\n\nint main(void) {\n\tint i;\n\tscanf(\"%d%d\",&height,&width);\n\tfor(i=0;i<height;i++)scanf(\"%s\",program[i]);\n\tputs(runProgram(0,0,0,DIR_RIGHT)?\"YES\":\"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2262: Stopping Problem\n// 2017.11.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define E 0\n#define S 1\n#define W 2\n#define N 3\ntypedef struct { int r, c, mem, dir; } Q;\nQ q[35000]; int top, end;\n\nchar m[22][22];\nchar mk[22][22][16][4];\nint mv[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\n\nint main()  \n{  \n\tint h, w, i, ii, r, c, r2, c2, mem, dir, ans;\n\n\tscanf(\"%d%d\", &h, &w);\n\tfor (r = 0; r < h; r++) scanf(\"%s\", m[r]);\n\tmk[0][0][0][0] = 1;\n\tq[0].r = 0, q[0].c = 0, q[0].mem = 0, q[0].dir = E; top = 0, end = 1;\n\tans = 0;\n\twhile (top < end) {\n\t\tr = q[top].r, c = q[top].c, mem = q[top].mem, dir = q[top++].dir;\n\t\tii = 1;\n\t\tif      (m[r][c] == '<') dir = W;\n\t\telse if (m[r][c] == '>') dir = E;\n\t\telse if (m[r][c] == '^') dir = N;\n\t\telse if (m[r][c] == 'v') dir = S;\n\t\telse if (m[r][c] == '_') dir = mem ? W : E;\n\t\telse if (m[r][c] == '|') dir = mem ? N : S;\n\t\telse if (m[r][c] == '@') { ans = 1; break; }\n\t\telse if (isdigit(m[r][c])) mem = m[r][c] - '0';\n\t\telse if (m[r][c] == '+') { if (++mem > 15) mem = 0; }\n\t\telse if (m[r][c] == '-') { if (--mem < 0) mem = 15; }\n\t\telse if (m[r][c] == '?') ii = 4;\n\n\t\tfor (i = 0; i < ii; i++) {\n\t\t\tr2 = r + mv[(dir+i)&3][0];\n\t\t\tc2 = c + mv[(dir+i)&3][1];\n\t\t\tif      (r2 < 0) r2 = h-1;\n\t\t\telse if (r2 >= h) r2 = 0;\n\t\t\tif      (c2 < 0) c2 = w-1;\n\t\t\telse if (c2 >= w) c2 = 0;\n\t\t\tif (mk[r2][c2][mem][(dir+i)&3]) continue;\n\t\t\tmk[r2][c2][mem][(dir+i)&3] = 1;\n\t\t\tq[end].r = r2, q[end].c = c2, q[end].mem = mem, q[end++].dir = (dir+i)&3;\n\t\t}\n\t}\n\tputs(ans ? \"YES\" : \"NO\");\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Stopping Problem\npublic class Main{\n\n\tboolean[][][][] u;\n\tint r, c;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\n\tint ni(int i, int d){\n\t\treturn (i+move[d][0]+r)%r;\n\t}\n\tint nj(int j, int d){\n\t\treturn (j+move[d][1]+c)%c;\n\t}\n\t\n\t\n\tvoid add(int i, int j, int m, int d, List<int[]> l){\n\t\tif(!u[i][j][m][d]){\n\t\t\tu[i][j][m][d] = true;\n\t\t\tl.add(new int[]{i,j,m,d});\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tr = sc.nextInt();\n\t\tc = sc.nextInt();\n\t\tchar[][] m = new char[r][c];\n\t\tfor(int i=0;i<r;i++)m[i]=sc.next().toCharArray();\n\t\tu = new boolean[r][c][16][4];\n\t\tboolean g = false;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{0,0,0,1});\n\t\tu[0][0][0][1] = true;\n\t\twhile(!g&&!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int a[]:l){\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tint mem = a[2];\n\t\t\t\tint dir = a[3];\n\t\t\t\tchar ch = m[i][j];\n\t\t\t\tif(ch=='<'){\n\t\t\t\t\tadd(ni(i,3),nj(j,3),mem,3,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='>'){\n\t\t\t\t\tadd(ni(i,1),nj(j,1),mem,1,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='^'){\n\t\t\t\t\tadd(ni(i,0),nj(j,0),mem,0,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='v'){\n\t\t\t\t\tadd(ni(i,2),nj(j,2),mem,2,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='_'){\n\t\t\t\t\tif(mem==0)add(ni(i,1),nj(j,1),mem,1,next);\n\t\t\t\t\telse add(ni(i,3),nj(j,3),mem,3,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='|'){\n\t\t\t\t\tif(mem==0)add(ni(i,2),nj(j,2),mem,2,next);\n\t\t\t\t\telse add(ni(i,0),nj(j,0),mem,0,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='?'){\n\t\t\t\t\tadd(ni(i,3),nj(j,3),mem,3,next);\n\t\t\t\t\tadd(ni(i,1),nj(j,1),mem,1,next);\n\t\t\t\t\tadd(ni(i,0),nj(j,0),mem,0,next);\n\t\t\t\t\tadd(ni(i,2),nj(j,2),mem,2,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='@'){\n\t\t\t\t\tg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(ch=='+'){\n\t\t\t\t\tadd(ni(i,dir),nj(j,dir),(mem+1)%16,dir,next);\n\t\t\t\t}\n\t\t\t\telse if(ch=='-'){\n\t\t\t\t\tadd(ni(i,dir),nj(j,dir),(mem+15)%16,dir,next);\n\t\t\t\t}\n\t\t\t\telse if(Character.isDigit(ch)){\n\t\t\t\t\tadd(ni(i,dir),nj(j,dir),ch-'0',dir,next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tadd(ni(i,dir),nj(j,dir),mem,dir,next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t}\n\t\tSystem.out.println(g?\"YES\":\"NO\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\n\t//@2262  Stopping Problem\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = reader.readLine();\n\t\tString[] sp = s.split(\" \");\n\t\tint ymax = Integer.parseInt(sp[0]);\n\t\tint xmax = Integer.parseInt(sp[1]);\n\t\t\n\t\tString[] map = new String[ymax];\n\t\t\n\t\tfor(int y = 0; y < ymax; y++) {\n\t\t\tmap[y] = reader.readLine();\n\t\t}\n//\t\tmap[0] = \"6>--v.\";\n//\t\tmap[1] = \".^--_@\";\n\t\t\n\t\treader.close();\n\t\t\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint xx = 1;\n\t\tint yy = 0;\n\t\tint v = 0;\n\t\t\n\t\tfor(int step = 0;; step++) {\n\t\t\tif (step > 1000*1000*1000) {\n\t\t\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar c = map[y].charAt(x);\n//\t\t\tSystem.out.printf(\"%d %c\\n\", v, c);\n\t\t\t\n\t\t\tif (c == '@') {\n\t\t\t\tSystem.out.printf(\"YES\\n\"); // â~\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (\"0123456789\".indexOf(c) >= 0) {\n\t\t\t\tv = \"0123456789\".indexOf(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '?') {\n\t\t\t\t\t// _\n\t\t\t\t\tint r = (int)Math.floor(Math.random() * 4);\n\t\t\t\t\tc = \"<>^v\".charAt(r);\n\t\t\t\t}\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '<':\n\t\t\t\t\txx = -1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\txx = 1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = -1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tv = (v + 1) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tv = (v + 15) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = (x + xx + xmax) % xmax;\n\t\t\ty = (y + yy + ymax) % ymax;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tchar bord[][];\n\tint memo;\n\tint R,C;\n\tint step;\n\tboolean flag;\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tR=sc.nextInt();\n\t\t\tC=sc.nextInt();\n\t\t\tbord=new char[R][C];\n\t\t\tfor(int i=0;i<R;i++){\n\t\t\t\tbord[i]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tmemo=0;\n\t\t\tflag=false;\n\t\t\tstep=0;\n\t\t\tf(0,0,1);\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tvoid f(int y,int x,int move){\n\t\tstep++;\n\t\tif(5000<step) return;\n\t\t//System.err.println(y+\" \"+x+\" \"+bord[y][x]+\" \"+move+\" memo=\"+memo);\n\t\tif(bord[y][x]=='@'){\n\t\t\tflag=true;\n\t\t\treturn; //テァツオツづ、ツコツ?\n\t\t}\n\t\telse if(bord[y][x]=='^'){\n\t\t\tif(y-1 < 0){\n\t\t\t\tf(R-1,x,0);\n\t\t\t}\n\t\t\telse f(y-1,x,0);\n\t\t}\n\t\telse if(bord[y][x]=='>'){\n\t\t\tif(C <= x+1){\n\t\t\t\tf(y,0,1);\n\t\t\t}\n\t\t\telse f(y,x+1,1);\n\t\t}\n\t\telse if(bord[y][x]=='v'){\n\t\t\tif(R <= y+1){\n\t\t\t\tf(0,x,2);\n\t\t\t}\n\t\t\telse f(y+1,x,2);\n\t\t}\n\t\telse if(bord[y][x]=='<'){\n\t\t\tif(x-1 < 0){\n\t\t\t\tf(y,C-1,3);\n\t\t\t}\n\t\t\telse f(y,x-1,3);\n\t\t}\n\t\telse if(bord[y][x]=='_'){\n\t\t\tif(memo==0){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='|'){\n\t\t\tif(memo==0){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='?'){\n\t\t\tRandom rnd = new Random();\n\t\t\tint i=rnd.nextInt(4);\n\t\t\t//System.err.println(\"rnd=\"+i);\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(y-1 < 0){\n\t\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y-1,x,0);\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tif(C <= x+1){\n\t\t\t\t\t\tf(y,0,1);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x+1,1);\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tif(R <= y+1){\n\t\t\t\t\t\tf(0,x,2);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y+1,x,2);\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tif(x-1 < 0){\n\t\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x-1,3);\n\t\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='.'){\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='+'){\n\t\t\tif(memo==15){\n\t\t\t\tmemo=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo++;\n\t\t\t}\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='-'){\n\t\t\tif(memo==0){\n\t\t\t\tmemo=15;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo--;\n\t\t\t}\n\t\t\t\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tmemo=bord[y][x]-'0';\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int R;\n\tstatic int C;\n\tstatic char[][] f;\n\tstatic boolean[][][][] visited;\n\tstatic LinkedList<State> q = new LinkedList<State>();\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tR = sc.nextInt();\n\t\tC = sc.nextInt();\n\t\tf = new char[R][C];\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tString line = sc.next();\n\t\t\tf[i] = line.toCharArray();\n\t\t}\n\t\tvisited = new boolean[R][C][4][16];\n\t\tq.add(new State(0, 0, 0, 0));\n\t\tboolean stop = false;\n\t\twhile (!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n//\t\t\tSystem.out.println(cur.r + \",\" + cur.c + \",\" + cur.mem + \",\" + cur.dir);\n\t\t\tchar cc = f[cur.r][cur.c];\n\t\t\tif (cc == '<') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 2));\n\t\t\t} else if (cc == '>') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 0));\n\t\t\t} else if (cc == '^') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 3));\n\t\t\t} else if (cc == 'v') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 1));\n\t\t\t} else if (cc == '_') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, cur.mem == 0 ? 0 : 2));\n\t\t\t} else if (cc == '|') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, cur.mem == 0 ? 1 : 3));\n\t\t\t} else if (cc == '?') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 0));\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 1));\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 2));\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, 3));\n\t\t\t} else if (cc == '+') {\n\t\t\t\tupdate(new State(cur.r, cur.c, (cur.mem + 1) % 16, cur.dir));\n\t\t\t} else if (cc == '-') {\n\t\t\t\tupdate(new State(cur.r, cur.c, (cur.mem + 15) % 16, cur.dir));\n\t\t\t} else if (cc == '@') {\n\t\t\t\tstop = true;\n\t\t\t\tbreak;\n\t\t\t} else if ('0' <= cc && cc <= '9') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cc - '0', cur.dir));\n\t\t\t} else if (cc == '.') {\n\t\t\t\tupdate(new State(cur.r, cur.c, cur.mem, cur.dir));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(stop ? \"YES\" : \"NO\");\n\n\t}\n\n\tstatic void update(State next) {\n\t\tif (visited[next.r][next.c][next.dir][next.mem]) {\n\t\t\treturn;\n\t\t}\n\t\tvisited[next.r][next.c][next.dir][next.mem] = true;\n\t\tnext.r = (next.r + dy[next.dir] + R) % R;\n\t\tnext.c = (next.c + dx[next.dir] + C) % C;\n\t\tq.add(next);\n\t}\n\n\tstatic class State {\n\t\tint r;\n\t\tint c;\n\t\tint mem;\n\t\tint dir;\n\n\t\tState(int r, int c, int mem, int dir) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.mem = mem;\n\t\t\tthis.dir = dir;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\n\t//@2262  Stopping Problem\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = reader.readLine();\n\t\tString[] sp = s.split(\" \");\n\t\tint ymax = Integer.parseInt(sp[0]);\n\t\tint xmax = Integer.parseInt(sp[1]);\n\t\t\n\t\tString[] map = new String[ymax];\n\t\t\n\t\tfor(int y = 0; y < ymax; y++) {\n\t\t\tmap[y] = reader.readLine();\n\t\t}\n//\t\tmap[0] = \"6>--v.\";\n//\t\tmap[1] = \".^--_@\";\n\t\t\n\t\treader.close();\n\t\t\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint xx = 1;\n\t\tint yy = 0;\n\t\tint v = 0;\n\t\t\n\t\tfor(int step = 0;; step++) {\n\t\t\tif (step > 1000*1000) {\n\t\t\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar c = map[y].charAt(x);\n//\t\t\tSystem.out.printf(\"%d %c\\n\", v, c);\n\t\t\t\n\t\t\tif (c == '@') {\n\t\t\t\tSystem.out.printf(\"YES\\n\"); // â~\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (\"0123456789\".indexOf(c) >= 0) {\n\t\t\t\tv = \"0123456789\".indexOf(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '?') {\n\t\t\t\t\t// _\n\t\t\t\t\tint r = (int)Math.floor(Math.random() * 4);\n\t\t\t\t\tc = \"<>^v\".charAt(r);\n\t\t\t\t}\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '<':\n\t\t\t\t\txx = -1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\txx = 1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = -1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tv = (v + 1) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tv = (v + 15) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = (x + xx + xmax) % xmax;\n\t\t\ty = (y + yy + ymax) % ymax;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tchar bord[][];\n\tint memo;\n\tint R,C;\n\tint step;\n\tboolean flag;\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tR=sc.nextInt();\n\t\t\tC=sc.nextInt();\n\t\t\tbord=new char[R][C];\n\t\t\tfor(int i=0;i<R;i++){\n\t\t\t\tbord[i]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tmemo=0;\n\t\t\tflag=false;\n\t\t\tstep=0;\n\t\t\tf(0,0,1);\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tvoid f(int y,int x,int move){\n\t\tstep++;\n\t\tif(500000<step) return;\n\t\t//System.err.println(y+\" \"+x+\" \"+bord[y][x]+\" \"+move+\" memo=\"+memo);\n\t\tif(bord[y][x]=='@'){\n\t\t\tflag=true;\n\t\t\treturn; //終了\n\t\t}\n\t\telse if(bord[y][x]=='^'){\n\t\t\tif(y-1 < 0){\n\t\t\t\tf(R-1,x,0);\n\t\t\t}\n\t\t\telse f(y-1,x,0);\n\t\t}\n\t\telse if(bord[y][x]=='>'){\n\t\t\tif(C <= x+1){\n\t\t\t\tf(y,0,1);\n\t\t\t}\n\t\t\telse f(y,x+1,1);\n\t\t}\n\t\telse if(bord[y][x]=='v'){\n\t\t\tif(R <= y+1){\n\t\t\t\tf(0,x,2);\n\t\t\t}\n\t\t\telse f(y+1,x,2);\n\t\t}\n\t\telse if(bord[y][x]=='<'){\n\t\t\tif(x-1 < 0){\n\t\t\t\tf(y,C-1,3);\n\t\t\t}\n\t\t\telse f(y,x-1,3);\n\t\t}\n\t\telse if(bord[y][x]=='_'){\n\t\t\tif(memo==0){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='|'){\n\t\t\tif(memo==0){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='?'){\n\t\t\tRandom rnd = new Random();\n\t\t\tint i=rnd.nextInt(4);\n\t\t\t//System.err.println(\"rnd=\"+i);\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(y-1 < 0){\n\t\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y-1,x,0);\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tif(C <= x+1){\n\t\t\t\t\t\tf(y,0,1);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x+1,1);\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tif(R <= y+1){\n\t\t\t\t\t\tf(0,x,2);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y+1,x,2);\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tif(x-1 < 0){\n\t\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x-1,3);\n\t\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='.'){\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='+'){\n\t\t\tif(memo==15){\n\t\t\t\tmemo=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo++;\n\t\t\t}\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='-'){\n\t\t\tif(memo==0){\n\t\t\t\tmemo=15;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo--;\n\t\t\t}\n\t\t\t\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tmemo=bord[y][x]-'0';\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\t//@2262  Stopping Problem\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = reader.readLine();\n\t\tString[] sp = s.split(\" \");\n\t\tint ymax = Integer.parseInt(sp[0]);\n\t\tint xmax = Integer.parseInt(sp[1]);\n\t\t\n\t\tString[] map = new String[ymax];\n\t\t\n\t\tfor(int y = 0; y < ymax; y++) {\n\t\t\tmap[y] = reader.readLine();\n\t\t}\n//\t\tmap[0] = \"6>--v.\";\n//\t\tmap[1] = \".^--_@\";\n\t\t\n\t\treader.close();\n\t\t\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint xx = 1;\n\t\tint yy = 0;\n\t\tint v = 0;\n\t\t\n\t\tfor(int step = 0;; step++) {\n\t\t\tif (step > 1000*1000*40) { // 1000*1000*1000=19.98\n\t\t\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar c = map[y].charAt(x);\n//\t\t\tSystem.out.printf(\"%d %c\\n\", v, c);\n\t\t\t\n\t\t\tif (c == '@') {\n\t\t\t\tSystem.out.printf(\"YES\\n\"); // â~\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (\"0123456789\".indexOf(c) >= 0) {\n\t\t\t\tv = \"0123456789\".indexOf(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '?') {\n\t\t\t\t\t// _\n\t\t\t\t\tint r = (int)Math.floor(Math.random() * 4);\n\t\t\t\t\tc = \"<>^v\".charAt(r);\n\t\t\t\t}\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '<':\n\t\t\t\t\txx = -1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\txx = 1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = -1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tv = (v + 1) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tv = (v + 15) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = (x + xx + xmax) % xmax;\n\t\t\ty = (y + yy + ymax) % ymax;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tchar bord[][];\n\tint memo;\n\tint R,C;\n\tint step;\n\tboolean flag;\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tR=sc.nextInt();\n\t\t\tC=sc.nextInt();\n\t\t\tbord=new char[R][C];\n\t\t\tfor(int i=0;i<R;i++){\n\t\t\t\tbord[i]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tmemo=0;\n\t\t\tflag=false;\n\t\t\tstep=0;\n\t\t\tf(0,0,1);\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tvoid f(int y,int x,int move){\n\t\tstep++;\n\t\tif(5000<step) return;\n\t\t//System.err.println(y+\" \"+x+\" \"+bord[y][x]+\" \"+move+\" memo=\"+memo);\n\t\tif(bord[y][x]=='@'){\n\t\t\tflag=true;\n\t\t\treturn; //終了\n\t\t}\n\t\telse if(bord[y][x]=='^'){\n\t\t\tif(y-1 < 0){\n\t\t\t\tf(R-1,x,0);\n\t\t\t}\n\t\t\telse f(y-1,x,0);\n\t\t}\n\t\telse if(bord[y][x]=='>'){\n\t\t\tif(C <= x+1){\n\t\t\t\tf(y,0,1);\n\t\t\t}\n\t\t\telse f(y,x+1,1);\n\t\t}\n\t\telse if(bord[y][x]=='v'){\n\t\t\tif(R <= y+1){\n\t\t\t\tf(0,x,2);\n\t\t\t}\n\t\t\telse f(y+1,x,2);\n\t\t}\n\t\telse if(bord[y][x]=='<'){\n\t\t\tif(x-1 < 0){\n\t\t\t\tf(y,C-1,3);\n\t\t\t}\n\t\t\telse f(y,x-1,3);\n\t\t}\n\t\telse if(bord[y][x]=='_'){\n\t\t\tif(memo==0){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='|'){\n\t\t\tif(memo==0){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='?'){\n\t\t\tRandom rnd = new Random();\n\t\t\tint i=rnd.nextInt(4);\n\t\t\t//System.err.println(\"rnd=\"+i);\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(y-1 < 0){\n\t\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y-1,x,0);\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tif(C <= x+1){\n\t\t\t\t\t\tf(y,0,1);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x+1,1);\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tif(R <= y+1){\n\t\t\t\t\t\tf(0,x,2);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y+1,x,2);\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tif(x-1 < 0){\n\t\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x-1,3);\n\t\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='.'){\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='+'){\n\t\t\tif(memo==15){\n\t\t\t\tmemo=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo++;\n\t\t\t}\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='-'){\n\t\t\tif(memo==0){\n\t\t\t\tmemo=15;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo--;\n\t\t\t}\n\t\t\t\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tmemo=bord[y][x]-'0';\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic int w, h;\n\tstatic int ans = -1;\n\tstatic char[][] op;\n\tstatic boolean[][] check;\n\tstatic Set<String> set = new HashSet<String>();\n\n\tpublic static int[] getNext (int y, int x, int vector) {\n\t\tif (vector == 1) {\n\t\t\tx = x == 0 ? w - 1 : x - 1;\n\t\t} else if (vector == 2) {\n\t\t\tx = (x + 1) % w;\n\t\t} else if (vector == 3) {\n\t\t\ty = y == 0 ? h - 1 : y - 1;\n\t\t} else if (vector == 4) {\n\t\t\ty = (y + 1) % h;\n\t\t}\n\t\treturn new int[]{y,x};\n\t}\n\n\tpublic static void dfs (int y, int x, int memory, int vector) {\n\n\t\tif (op[y][x] == '<') {\n\t\t\tvector = 1;\n\t\t} else if (op[y][x] == '>') {\n\t\t\tvector = 2;\n\t\t} else if (op[y][x] == '^') {\n\t\t\tvector = 3;\n\t\t} else if (op[y][x] == 'v') {\n\t\t\tvector = 4;\n\t\t} else if (op[y][x] == '_') {\n\t\t\tvector = memory == 0 ? 2 : 1;\n\t\t} else if (op[y][x] == '|') {\n\t\t\tvector = memory == 0 ? 4 : 3;\n\t\t} else if (op[y][x] == '@') {\n\t\t\tans = 1;\n\t\t\treturn;\n\t\t} else if ('0' <= op[y][x] && op[y][x] <= '9') {\n\t\t\tmemory = op[y][x] - '0';\n\t\t} else if (op[y][x] == '+') {\n\t\t\tmemory = (memory + 1) % 16;\n\t\t} else if (op[y][x] == '-') {\n\t\t\tmemory = (memory - 1) % 16;\n\t\t}\n\n\t\tif (op[y][x] == '?') {\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint[] next = getNext(y,x,i);\n\t\t\t\tString str = next[0] + \" \" + next[1] + \" \" + memory + \" \" + i;\n\t\t\t\tif (!set.contains(str)) {\n\t\t\t\t\tset.add(str);\n\t\t\t\t} else if (check[next[0]][next[1]]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdfs(next[0],next[1],memory,i);\n\t\t\t}\n\t\t} else {\n\t\t\tint[] next = getNext(y,x,vector);\n\t\t\tString str = next[0] + \" \" + next[1] + \" \" + memory + \" \" + vector;\n\t\t\tif (!set.contains(str)) {\n\t\t\t\tset.add(str);\n\t\t\t\tdfs(next[0],next[1],memory,vector);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\th = sc.nextInt();\n\t\tw = sc.nextInt();\n\t\top = new char[h][w];\n\t\tcheck = new boolean[h][w];\n\n\t\tsc.nextLine();\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\top[i] = sc.nextLine().toCharArray();\n\t\t}\n\t\tdfs(0,0,0,2);\n\t\tSystem.out.println(ans == 1 ? \"YES\" : \"NO\");\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int x, y;\n\tstatic int px, py;\n\tstatic int mem;\n\tstatic int dir;\n\tstatic int loop[][][][];\n\tstatic String s[];\n\n\tstatic Queue<Q> queue = new LinkedList<Q>();\n\n\tstatic class Q {\n\t\tint px, py, mem, dir;\n\n\t\tQ(int px, int py, int mem, int dir) {\n\t\t\tthis.px = px;\n\t\t\tthis.py = py;\n\t\t\tthis.mem = mem;\n\t\t\tthis.dir = dir;\n\t\t}\n\t}\n\n\tpublic static boolean f(int px_, int py_, int mem_, int dir_) {\n\t\tif (loop[px_][py_][mem_][dir_] == 1) {\n\t\t\treturn false;\n\t\t}\n\t\tif (s[py_].charAt(px_) == '@') {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tboolean f = false;\n\t\twhile (true) {\n\t\t\tif (loop[px_][py_][mem_][dir_] == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s[py_].charAt(px_) == '@') {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tloop[px_][py_][mem_][dir_] = 1;\n\t\t\tpx = px_;\n\t\t\tpy = py_;\n\t\t\tmem = mem_;\n\t\t\tdir = dir_;\n\t\t\tmove();\n\t\t\tpx_ = px;\n\t\t\tpy_ = py;\n\t\t\tmem_ = mem;\n\t\t\tdir_ = dir;\n\t\t\tif (dir_ == 0) {\n\t\t\t\tpx_ = (px_ + 1) % x;\n\t\t\t} else if (dir_ == 1) {\n\t\t\t\tpy_ = (py_ + 1) % y;\n\t\t\t} else if (dir_ == 2) {\n\t\t\t\tpx_ = (px_ + x - 1) % x;\n\t\t\t} else if (dir_ == 3) {\n\t\t\t\tpy_ = (py_ + y - 1) % y;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\treturn true;\n\t\t}\n\t\twhile (!queue.isEmpty()) {\n\t\t\tQ q = queue.poll();\n\t\t\tif (f(q.px, q.py, q.mem, q.dir)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void move() {\n\t\tif (s[py].charAt(px) == '<') {\n\t\t\tdir = 2;\n\t\t} else if (s[py].charAt(px) == '>') {\n\t\t\tdir = 0;\n\t\t} else if (s[py].charAt(px) == '^') {\n\t\t\tdir = 3;\n\t\t} else if (s[py].charAt(px) == 'v') {\n\t\t\tdir = 1;\n\t\t} else if (s[py].charAt(px) == '_') {\n\t\t\tif (mem == 0) {\n\t\t\t\tdir = 0;\n\t\t\t} else {\n\t\t\t\tdir = 2;\n\t\t\t}\n\t\t} else if (s[py].charAt(px) == '|') {\n\t\t\tif (mem == 0) {\n\t\t\t\tdir = 1;\n\t\t\t} else {\n\t\t\t\tdir = 3;\n\t\t\t}\n\t\t} else if (s[py].charAt(px) == '?') {\n\t\t\tqueue.add(new Q((px + 1) % x, py, mem, 0));\n\t\t\tqueue.add(new Q((px + x - 1) % x, py, mem, 2));\n\t\t\tqueue.add(new Q(px, (py + 1) % y, mem, 1));\n\t\t\tqueue.add(new Q(px, (py + y - 1) % y, mem, 3));\n\t\t} else if ('0' <= s[py].charAt(px) && s[py].charAt(px) <= '9') {\n\t\t\tmem = s[py].charAt(px) - '0';\n\t\t} else if (s[py].charAt(px) == '+') {\n\t\t\tmem = (mem + 1) % 16;\n\t\t} else if (s[py].charAt(px) == '-') {\n\t\t\tmem = (mem + 15) % 16;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\ty = sc.nextInt();\n\t\tx = sc.nextInt();\n\t\ts = new String[y];\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\ts[i] = sc.next();\n\t\t}\n\t\tpx = py = 0;\n\t\tmem = 0;\n\t\tdir = 0;\n\t\tloop = new int[x + 1][y + 1][16][4];\n\n\t\tif (f(px, py, mem, dir)) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t} else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic byte H,W,memory,dir;\n\tstatic char[][] field;\n\tstatic byte[][][][] dp;\n\tstatic int[] v1={-1,0,1,0};\n\tstatic int[] v2={0,1,0,-1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tH=cin.nextByte();\n\t\tW=cin.nextByte();\n\t\tmemory=0;\n\t\tdir=1;\n\t\tfield=new char[H][];\n\n\t\t//memory, dir \n\t\tdp=new byte[H][W][16][4];\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfield[i]=cin.next().toCharArray();\n\t\t}\n\t\tboolean ans=false;\n\t\tStack<byte[]>stack=new Stack<byte[]>();\n\t\tstack.push(new byte[]{0,0,0,1});\n\t\twhile(!stack.isEmpty()){\n\t\t\tbyte[] a = stack.pop();\n\t\t\t\n\t\t\tbyte x=a[0];\n\t\t\tbyte y=a[1];\n\t\t\tbyte memory=a[2];\n\t\t\tbyte dir=a[3];\n//\t\t\tSystem.out.println(x+\" \"+y+\" \"+memory+\" \"+dir);\n\t\t\tif(dp[x][y][memory][dir]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[x][y][memory][dir]=1;\n\t\t\tif(field[x][y]=='@'){\n\t\t\t\tans=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(field[x][y]=='?'){\n\t\t\t\tbyte tmpdir=dir;\n\t\t\t\tbyte tmpmem=memory;\n\t\t\t\t\n\t\t\t\tfor(byte i=0;i<4;i++){\n\t\t\t\t\tdir=i;\n\t\t\t\t\tbyte[] next=step(x,y,dir);\n\t\t\t\t\tstack.add(new byte[]{next[0],next[1],memory,dir});\n\t\t\t\t}\n\t\t\t\tdir=tmpdir;\n\t\t\t\tmemory=tmpmem;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbyte tmpdir=dir;\n\t\t\t\tbyte tmpmem=memory;\n\t\t\t\tbyte[] b = command(field[x][y],memory,dir);\n\t\t\t\tmemory=b[0];\n\t\t\t\tdir=b[1];\n\t\t\t\tbyte[] next=step(x,y,dir);\n//\t\t\t\tSystem.out.println(memory+\" \"+dir+\" \"+x+\" \"+y);\n//\t\t\t\tSystem.out.println(next[0]+\" \"+next[1]);\n\t\t\t\tstack.add(new byte[]{next[0],next[1],memory,dir});\n\t\t\t\tdir=tmpdir;\n\t\t\t\tmemory=tmpmem;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif(dp(0,0)){\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\t\t\telse{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}*/\n\t\tif(ans){\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\t\t\telse{\n\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\n\t\t\n\t}\n\tstatic boolean dp(int x,int y){\n\t\tif(dp[x][y][memory][dir]==1){\n\t\t\treturn false;\n\t\t}\n\t\tdp[x][y][memory][dir]=1;\n\t\tif(field[x][y]=='@'){\n\t\t\treturn true;\n\t\t}\n\t\telse if(field[x][y]=='?'){\n\t\t\tbyte tmpdir=dir;\n\t\t\tbyte tmpmem=memory;\n\t\t\t\n\t\t\tfor(byte i=0;i<4;i++){\n\t\t\t\tdir=i;\n\t\t\t\tbyte[] next=step(x,y);\n\t\t\t\tif(dp(next[0],next[1])){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdir=tmpdir;\n\t\t\tmemory=tmpmem;\n\t\t}\n\t\telse{\n\t\t\tbyte tmpdir=dir;\n\t\t\tbyte tmpmem=memory;\n\t\t\tcommand(field[x][y]);\n\t\t\tbyte[] next=step(x,y);\n//\t\t\tSystem.out.println(memory+\" \"+dir+\" \"+x+\" \"+y);\n//\t\t\tSystem.out.println(next[0]+\" \"+next[1]);\n\t\t\tif(dp(next[0],next[1])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdir=tmpdir;\n\t\t\tmemory=tmpmem;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic byte[] step(int x,int y){\n\t\tbyte[] re=new byte[2];\n\t\tre[0]=(byte)((x+H+v1[dir])%H);\n\t\tre[1]=(byte)((y+W+v2[dir])%W);\n\t\treturn re;\n\t}\n\tstatic byte[] step(int x,int y,byte dir){\n\t\tbyte[] re=new byte[2];\n\t\tre[0]=(byte)((x+H+v1[dir])%H);\n\t\tre[1]=(byte)((y+W+v2[dir])%W);\n\t\treturn re;\n\t}\n\t// @,? テ」ツ?ッテ、ツセツ凝・ツ、ツ?\n\tstatic void command(char c){\n\t\tif(c=='<'){\n\t\t\tdir=3;\n\t\t}\n\t\telse if(c=='>'){\n\t\t\tdir=1;\n\t\t}\n\t\telse if(c=='^'){\n\t\t\tdir=0;\n\t\t}\n\t\telse if(c=='v'){\n\t\t\tdir=2;\n\t\t}\n\t\telse if(c=='_'){\n\t\t\tif(memory==0){\n\t\t\t\tdir=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=3;\n\t\t\t}\n\t\t}\n\t\telse if(c=='|'){\n\t\t\tif(memory==0){\n\t\t\t\tdir=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=0;\n\t\t\t}\n\t\t}\n\t\telse if(c>='0'&&c<='9'){\n\t\t\tmemory=(byte)(c-'0');\n\t\t}\n\t\telse if(c=='+'){\n\t\t\tmemory=(byte)((memory+1)%16);\n\t\t}\n\t\telse if(c=='-'){\n\t\t\tmemory=(byte)((memory+16-1)%16);\n\t\t}\n\t}\n\tstatic byte[] command(char c,byte memory,byte dir){\n\t\tbyte[] re={0,0};\n\t\tif(c=='<'){\n\t\t\tdir=3;\n\t\t}\n\t\telse if(c=='>'){\n\t\t\tdir=1;\n\t\t}\n\t\telse if(c=='^'){\n\t\t\tdir=0;\n\t\t}\n\t\telse if(c=='v'){\n\t\t\tdir=2;\n\t\t}\n\t\telse if(c=='_'){\n\t\t\tif(memory==0){\n\t\t\t\tdir=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=3;\n\t\t\t}\n\t\t}\n\t\telse if(c=='|'){\n\t\t\tif(memory==0){\n\t\t\t\tdir=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=0;\n\t\t\t}\n\t\t}\n\t\telse if(c>='0'&&c<='9'){\n\t\t\tmemory=(byte)(c-'0');\n\t\t}\n\t\telse if(c=='+'){\n\t\t\tmemory=(byte)((memory+1)%16);\n\t\t}\n\t\telse if(c=='-'){\n\t\t\tmemory=(byte)((memory+16-1)%16);\n\t\t}\n\t\tre[0]=memory;\n\t\tre[1]=dir;\n\t\treturn re;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int H,W,memory,dir;\n\tstatic char[][] field;\n\tstatic byte[][][][] dp;\n\tstatic int[] v1={-1,0,1,0};\n\tstatic int[] v2={0,1,0,-1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tH=cin.nextInt();\n\t\tW=cin.nextInt();\n\t\tmemory=0;\n\t\tdir=1;\n\t\tfield=new char[H][];\n\n\t\t//memory, dir \n\t\tdp=new byte[H][W][16][4];\n\t\t\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfield[i]=cin.next().toCharArray();\n\t\t}\n\t\tif(dp(0,0)){\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t\t\n\t}\n\tstatic boolean dp(int x,int y){\n\t\tif(dp[x][y][memory][dir]==1){\n\t\t\treturn false;\n\t\t}\n\t\tdp[x][y][memory][dir]=1;\n\t\tif(field[x][y]=='@'){\n\t\t\treturn true;\n\t\t}\n\t\telse if(field[x][y]=='?'){\n\t\t\tint tmpdir=dir;\n\t\t\tint tmpmem=memory;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tdir=i;\n\t\t\t\tint[] next=step(x,y);\n\t\t\t\tif(dp(next[0],next[1])){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdir=tmpdir;\n\t\t\tmemory=tmpmem;\n\t\t}\n\t\telse{\n\t\t\tint tmpdir=dir;\n\t\t\tint tmpmem=memory;\n\t\t\tcommand(field[x][y]);\n\t\t\tint[] next=step(x,y);\n//\t\t\tSystem.out.println(memory+\" \"+dir+\" \"+x+\" \"+y);\n//\t\t\tSystem.out.println(next[0]+\" \"+next[1]);\n\t\t\tif(dp(next[0],next[1])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdir=tmpdir;\n\t\t\tmemory=tmpmem;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic int[] step(int x,int y){\n\t\tint[] re=new int[2];\n\t\tre[0]=(x+H+v1[dir])%H;\n\t\tre[1]=(y+W+v2[dir])%W;\n\t\treturn re;\n\t}\n\t// @,? テ」ツ?ッテ、ツセツ凝・ツ、ツ?\n\tstatic void command(char c){\n\t\tif(c=='<'){\n\t\t\tdir=3;\n\t\t}\n\t\telse if(c=='>'){\n\t\t\tdir=1;\n\t\t}\n\t\telse if(c=='^'){\n\t\t\tdir=0;\n\t\t}\n\t\telse if(c=='v'){\n\t\t\tdir=2;\n\t\t}\n\t\telse if(c=='_'){\n\t\t\tif(memory==0){\n\t\t\t\tdir=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=3;\n\t\t\t}\n\t\t}\n\t\telse if(c=='|'){\n\t\t\tif(memory==0){\n\t\t\t\tdir=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=0;\n\t\t\t}\n\t\t}\n\t\telse if(c>='0'&&c<='9'){\n\t\t\tmemory=(c-'0');\n\t\t}\n\t\telse if(c=='+'){\n\t\t\tmemory=(memory+1)%16;\n\t\t}\n\t\telse if(c=='-'){\n\t\t\tmemory=(memory+16-1)%16;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    int H, W;\n\n    int[] dx = {1, 0, -1, 0};\n    int[] dy = {0, -1, 0, 1};\n\n    void run() {\n        H = readInt();\n        W = readInt();\n        char[][] M = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            M[i] = read().toCharArray();\n        }\n\n        Queue<State> que = new ArrayDeque<State>();\n        boolean[][][][] vis = new boolean[H][W][4][16];\n        vis[0][0][0][0] = true;\n        que.add(new State(0, 0, 0, 0));\n        boolean end = false;\n        while (!que.isEmpty()) {\n            State s = que.poll();\n            State next = null;\n\n            // sysout.println(s);\n\n            char c = M[s.y][s.x];\n\n            if (c == '?') {\n                for (int i = 0; i < 4; i++) {\n                    next = s.updateDir(i);\n                    next.move();\n                    if (!vis[next.y][next.x][next.dir][next.mem]) {\n                        vis[next.y][next.x][next.dir][next.mem] = true;\n                        que.add(next);\n                    }\n                }\n                continue;\n            }\n\n            if (c == '<') {\n                next = s.updateDir(2);\n            }\n            if (c == '>') {\n                next = s.updateDir(0);\n            }\n            if (c == '^') {\n                next = s.updateDir(1);\n            }\n            if (c == 'v') {\n                next = s.updateDir(3);\n            }\n            if (c == '_') {\n                if (s.mem == 0) {\n                    next = s.updateDir(0);\n                } else {\n                    next = s.updateDir(2);\n                }\n            }\n            if (c == '|') {\n                if (s.mem == 0) {\n                    next = s.updateDir(3);\n                } else {\n                    next = s.updateDir(1);\n                }\n            }\n            if (c == '@') {\n                end = true;\n                break;\n            }\n            if (Character.isDigit(c)) {\n                int num = c - '0';\n                next = s.updateMem(num);\n            }\n            if (c == '+') {\n                next = s.updateMem(s.mem + 1);\n            }\n            if (c == '-') {\n                next = s.updateMem(s.mem - 1);\n            }\n            if (c == '.') {\n                next = s.updateMem(s.mem);\n            }\n\n            next.move();\n            if (!vis[next.y][next.x][next.dir][next.mem]) {\n                vis[next.y][next.x][next.dir][next.mem] = true;\n                que.add(next);\n            }\n        }\n\n        sysout.println(end ? \"YES\" : \"NO\");\n    }\n\n    class State {\n        public int x, y, dir, mem;\n\n        public State(int x, int y, int dir, int mem) {\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n            this.mem = mem;\n        }\n\n        public State updateDir(int d) {\n            return new State(x, y, d, mem);\n        }\n\n        @Override\n        public String toString() {\n            return \"State{\" +\n                    \"x=\" + x +\n                    \", y=\" + y +\n                    \", dir=\" + dir +\n                    \", mem=\" + mem +\n                    '}';\n        }\n\n        public void move() {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx < 0) nx += W;\n            if (ny < 0) ny += H;\n            this.x = nx % W;\n            this.y = ny % H;\n        }\n\n        public State updateMem(int m) {\n            if (m < 0) m += 16;\n            m %= 16;\n            return new State(x, y, dir, m);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    // flush automatically iff you call `println` or `printf` or `format`.\n    PrintWriter sysout = new PrintWriter(System.out, true);\n\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer buffer = new StringTokenizer(\"\");\n\n    String read() {\n        if (!buffer.hasMoreTokens()) {\n            try {\n                buffer = new StringTokenizer(in.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return buffer.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(read());\n    }\n\n    long readLong() {\n        return Long.parseLong(read());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(read());\n    }\n\n    String readLine() {\n        buffer = new StringTokenizer(\"\");\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\n\t//@2262  Stopping Problem\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = reader.readLine();\n\t\tString[] sp = s.split(\" \");\n\t\tint ymax = Integer.parseInt(sp[0]);\n\t\tint xmax = Integer.parseInt(sp[1]);\n\t\t\n\t\tString[] map = new String[ymax];\n\t\t\n\t\tfor(int y = 0; y < ymax; y++) {\n\t\t\tmap[y] = reader.readLine();\n\t\t}\n//\t\tmap[0] = \"6>--v.\";\n//\t\tmap[1] = \".^--_@\";\n\t\t\n\t\treader.close();\n\t\t\n\t\tfor(int k = 0;k < 100; k++) { // Å©çJèÔµ\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tint xx = 1;\n\t\t\tint yy = 0;\n\t\t\tint v = 0;\n\t\t\n\t\tfor(int step = 0;; step++) {\n\t\t\tif (step > 1000 * 10 * 40) { // 1000*1000*1000=19.98\n//\t\t\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar c = map[y].charAt(x);\n//\t\t\tSystem.out.printf(\"%d %c\\n\", v, c);\n\t\t\t\n\t\t\tif (c == '@') {\n\t\t\t\tSystem.out.printf(\"YES\\n\"); // â~\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (\"0123456789\".indexOf(c) >= 0) {\n\t\t\t\tv = \"0123456789\".indexOf(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '?') {\n\t\t\t\t\t// _\n\t\t\t\t\tint r = (int)Math.floor(Math.random() * 4);\n\t\t\t\t\tc = \"<>^v\".charAt(r);\n\t\t\t\t}\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '<':\n\t\t\t\t\txx = -1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\txx = 1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = -1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tv = (v + 1) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tv = (v + 15) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = (x + xx + xmax) % xmax;\n\t\t\ty = (y + yy + ymax) % ymax;\n\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tchar bord[][];\n\tint memo;\n\tint R,C;\n\tint step;\n\tboolean flag;\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tR=sc.nextInt();\n\t\t\tC=sc.nextInt();\n\t\t\tbord=new char[R][C];\n\t\t\tfor(int i=0;i<R;i++){\n\t\t\t\tbord[i]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tmemo=0;\n\t\t\tflag=false;\n\t\t\tstep=0;\n\t\t\tf(0,0,1);\n\t\t\tif(flag){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\tvoid f(int y,int x,int move){\n\t\tstep++;\n\t\tif(7800<step) return;\n\t\t//System.err.println(y+\" \"+x+\" \"+bord[y][x]+\" \"+move+\" memo=\"+memo);\n\t\tif(bord[y][x]=='@'){\n\t\t\tflag=true;\n\t\t\treturn; //終了\n\t\t}\n\t\telse if(bord[y][x]=='^'){\n\t\t\tif(y-1 < 0){\n\t\t\t\tf(R-1,x,0);\n\t\t\t}\n\t\t\telse f(y-1,x,0);\n\t\t}\n\t\telse if(bord[y][x]=='>'){\n\t\t\tif(C <= x+1){\n\t\t\t\tf(y,0,1);\n\t\t\t}\n\t\t\telse f(y,x+1,1);\n\t\t}\n\t\telse if(bord[y][x]=='v'){\n\t\t\tif(R <= y+1){\n\t\t\t\tf(0,x,2);\n\t\t\t}\n\t\t\telse f(y+1,x,2);\n\t\t}\n\t\telse if(bord[y][x]=='<'){\n\t\t\tif(x-1 < 0){\n\t\t\t\tf(y,C-1,3);\n\t\t\t}\n\t\t\telse f(y,x-1,3);\n\t\t}\n\t\telse if(bord[y][x]=='_'){\n\t\t\tif(memo==0){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='|'){\n\t\t\tif(memo==0){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='?'){\n\t\t\tRandom rnd = new Random();\n\t\t\tint i=rnd.nextInt(4);\n\t\t\t//System.err.println(\"rnd=\"+i);\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(y-1 < 0){\n\t\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y-1,x,0);\n\t\t\t\t}\n\t\t\t\telse if(i==1){\n\t\t\t\t\tif(C <= x+1){\n\t\t\t\t\t\tf(y,0,1);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x+1,1);\n\t\t\t\t}\n\t\t\t\telse if(i==2){\n\t\t\t\t\tif(R <= y+1){\n\t\t\t\t\t\tf(0,x,2);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y+1,x,2);\n\t\t\t\t}\n\t\t\t\telse if(i==3){\n\t\t\t\t\tif(x-1 < 0){\n\t\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t\t}\n\t\t\t\t\telse f(y,x-1,3);\n\t\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='.'){\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='+'){\n\t\t\tif(memo==15){\n\t\t\t\tmemo=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo++;\n\t\t\t}\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse if(bord[y][x]=='-'){\n\t\t\tif(memo==0){\n\t\t\t\tmemo=15;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo--;\n\t\t\t}\n\t\t\t\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tmemo=bord[y][x]-'0';\n\t\t\tif(move==0){\n\t\t\t\tif(y-1 < 0){\n\t\t\t\t\tf(R-1,x,0);\n\t\t\t\t}\n\t\t\t\telse f(y-1,x,0);\n\t\t\t}\n\t\t\telse if(move==1){\n\t\t\t\tif(C <= x+1){\n\t\t\t\t\tf(y,0,1);\n\t\t\t\t}\n\t\t\t\telse f(y,x+1,1);\n\t\t\t}\n\t\t\telse if(move==2){\n\t\t\t\tif(R <= y+1){\n\t\t\t\t\tf(0,x,2);\n\t\t\t\t}\n\t\t\t\telse f(y+1,x,2);\n\t\t\t}\n\t\t\telse if(move==3){\n\t\t\t\tif(x-1 < 0){\n\t\t\t\t\tf(y,C-1,3);\n\t\t\t\t}\n\t\t\t\telse f(y,x-1,3);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 16;\n\t\n\tpublic static final int DIRS  = 4;\n\tpublic static final int LEFT  = 0;\n\tpublic static final int DOWN  = 1;\n\tpublic static final int UP    = 2;\n\tpublic static final int RIGHT = 3;\n\t\n\tpublic static final int[][] move_dir = new int[][]{{-1, 0}, {0, 1}, {0, -1}, {1, 0}};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int h = sc.nextInt();\n\t\tfinal int w = sc.nextInt();\n\t\t\n\t\tboolean[][][][] is_visited = new boolean[h][w][DIRS][MAX];\n\t\t\n\t\tchar[][] map = new char[h][];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\t\n\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> memory_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> dir_queue = new LinkedList<Integer>();\n\t\t\n\t\tis_visited[0][0][0][RIGHT] = true;\n\t\tx_queue.add(0);\n\t\ty_queue.add(0);\n\t\tmemory_queue.add(0);\n\t\tdir_queue.add(RIGHT);\n\t\t\n\t\tboolean flag = false;\n\t\twhile(!dir_queue.isEmpty()){\n\t\t\tint x = x_queue.poll();\n\t\t\tint y = y_queue.poll();\n\t\t\tint memory = memory_queue.poll();\n\t\t\tint dir = dir_queue.poll();\n\t\t\t\n\t\t\t//System.out.println(x + \" \" + y + \" \" + memory  +\"  \" + dir);\n\t\t\t\n\t\t\tif(map[y][x] == '@'){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[y][x] == '^'){\n\t\t\t\tdir = UP;\n\t\t\t}else if(map[y][x] == 'v'){\n\t\t\t\tdir = DOWN;\n\t\t\t}else if(map[y][x] == '<'){\n\t\t\t\tdir = LEFT;\n\t\t\t}else if(map[y][x] == '>'){\n\t\t\t\tdir = RIGHT;\n\t\t\t}else if(map[y][x] == '_'){\n\t\t\t\tdir = memory == 0 ? RIGHT : LEFT;\n\t\t\t}else if(map[y][x] == '|'){\n\t\t\t\tdir = memory == 0 ? DOWN : UP;\n\t\t\t}else if('0' <= map[y][x] && map[y][x] <= '9'){\n\t\t\t\tmemory = map[y][x] -  '0';\n\t\t\t}else if(map[y][x] == '+'){\n\t\t\t\tmemory = (memory + 1) % MAX;\n\t\t\t}else if(map[y][x] == '-'){\n\t\t\t\tmemory = (memory + MAX - 1) % MAX;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(map[y][x] == '?'){\n\t\t\t\tfor(int i = 0; i < DIRS; i++){\n\t\t\t\t\tfinal int nx = (x + move_dir[i][0] + w) % w;\n\t\t\t\t\tfinal int ny = (y + move_dir[i][1] + h) % h;\n\t\t\t\n\t\t\t\t\tif(!is_visited[ny][nx][i][memory]){\n\t\t\t\t\t\tis_visited[ny][nx][i][memory] = true;\n\t\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\t\tmemory_queue.add(memory);\n\t\t\t\t\t\tdir_queue.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfinal int nx = (x + move_dir[dir][0] + w) % w;\n\t\t\t\tfinal int ny = (y + move_dir[dir][1] + h) % h;\n\t\t\t\n\t\t\t\tif(!is_visited[ny][nx][dir][memory]){\n\t\t\t\t\tis_visited[ny][nx][dir][memory] = true;\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\tmemory_queue.add(memory);\n\t\t\t\t\tdir_queue.add(dir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(flag ? \"YES\" : \"NO\");\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\n\t//@2262  Stopping Problem\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = reader.readLine();\n\t\tString[] sp = s.split(\" \");\n\t\tint ymax = Integer.parseInt(sp[0]);\n\t\tint xmax = Integer.parseInt(sp[1]);\n\t\t\n\t\tString[] map = new String[ymax];\n\t\t\n\t\tfor(int y = 0; y < ymax; y++) {\n\t\t\tmap[y] = reader.readLine();\n\t\t}\n//\t\tmap[0] = \"6>--v.\";\n//\t\tmap[1] = \".^--_@\";\n\t\t\n\t\treader.close();\n\t\t\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint xx = 1;\n\t\tint yy = 0;\n\t\tint v = 0;\n\t\t\n\t\tfor(int step = 0;; step++) {\n\t\t\tif (step > 1000*1000*40) { // 1000*1000*1000=19.98\n\t\t\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar c = map[y].charAt(x);\n//\t\t\tSystem.out.printf(\"%d %c\\n\", v, c);\n\t\t\t\n\t\t\tif (c == '@') {\n\t\t\t\tSystem.out.printf(\"YES\\n\"); // â~\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (\"0123456789\".indexOf(c) >= 0) {\n\t\t\t\tv = \"0123456789\".indexOf(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '?') {\n\t\t\t\t\t// _\n\t\t\t\t\tint r = (int)Math.floor(Math.random() * 4);\n\t\t\t\t\tc = \"<>^v\".charAt(r);\n\t\t\t\t}\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '<':\n\t\t\t\t\txx = -1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\txx = 1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = -1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tv = (v + 1) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tv = (v + 15) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = (x + xx + xmax) % xmax;\n\t\t\ty = (y + yy + ymax) % ymax;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\n\t//@2262  Stopping Problem\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString s = reader.readLine();\n\t\tString[] sp = s.split(\" \");\n\t\tint ymax = Integer.parseInt(sp[0]);\n\t\tint xmax = Integer.parseInt(sp[1]);\n\t\t\n\t\tString[] map = new String[ymax];\n\t\t\n\t\tfor(int y = 0; y < ymax; y++) {\n\t\t\tmap[y] = reader.readLine();\n\t\t}\n//\t\tmap[0] = \"6>--v.\";\n//\t\tmap[1] = \".^--_@\";\n\t\t\n\t\treader.close();\n\t\t\n\t\tfor(int k = 0;k < 100; k++) { // Å©çJèÔµ\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tint xx = 1;\n\t\t\tint yy = 0;\n\t\t\tint v = 0;\n\t\t\n\t\tfor(int step = 0;; step++) {\n\t\t\tif (step > 1000 * 2 * 40) { // 1000*1000*1000=19.98\n//\t\t\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar c = map[y].charAt(x);\n//\t\t\tSystem.out.printf(\"%d %c\\n\", v, c);\n\t\t\t\n\t\t\tif (c == '@') {\n\t\t\t\tSystem.out.printf(\"YES\\n\"); // â~\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (\"0123456789\".indexOf(c) >= 0) {\n\t\t\t\tv = \"0123456789\".indexOf(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '?') {\n\t\t\t\t\t// _\n\t\t\t\t\tint r = (int)Math.floor(Math.random() * 4);\n\t\t\t\t\tc = \"<>^v\".charAt(r);\n\t\t\t\t}\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '<':\n\t\t\t\t\txx = -1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\txx = 1;\n\t\t\t\t\tyy = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\txx = 0;\n\t\t\t\t\tyy = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = -1;\n\t\t\t\t\t\tyy = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\tif (v == 0) {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txx = 0;\n\t\t\t\t\t\tyy = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tv = (v + 1) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tv = (v + 15) % 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = (x + xx + xmax) % xmax;\n\t\t\ty = (y + yy + ymax) % ymax;\n\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.printf(\"NO\\n\"); // â~µÈ¢\n\t}\n\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom random import random\nimport sys\n\n# 再帰の最大回数を設定\nLIMIT = 100000\nsys.setrecursionlimit(LIMIT)\n\nLEFT = (-1, 0)\nRIGHT = (1, 0)\nUP = (0, -1)\nDOWN = (0, 1)\nNONE = (0, 0)\n\ndef main():\n    # 入力\n    (R, C) = map(int, raw_input().split())\n    data = [raw_input() for x in xrange(R)]\n    print(defunga(data, R, C))\n\ndef defunga(data, R, C):\n    mem = [0]\n    memoize = set()\n\n    def nextState(operator, state):\n        if operator == '<':\n            return LEFT\n        elif operator == '>':\n            return RIGHT\n        elif operator == '^':\n            return UP\n        elif operator == 'v':\n            return DOWN\n        elif operator == '_':\n            if mem[0] == 0:\n                return RIGHT\n            else:\n                return LEFT\n        elif operator == '|':\n            if mem[0] == 0:\n                return DOWN\n            else:\n                return UP\n        elif operator == '.':\n            return state\n        elif operator == '+':\n            if mem[0] == 15:\n                mem[0] = 0\n            else:\n                mem[0] += 1\n            return state\n        elif operator == '-':\n            if mem[0] == 0:\n                mem[0] = 15\n            else:\n                mem[0] -= 1\n            return state\n        else:\n            mem[0] = int(operator)\n        return state\n    \n    @tail_recursive\n    def searchStop(xy, state):\n        operator = data[xy[1]][xy[0]]\n        if operator == '@':\n            return 'YES'\n\n        if operator == '?':\n            ret = [searchStop(moveXY(xy, x), x) for x in [RIGHT, LEFT, UP, DOWN]]\n            if 'YES' in ret:\n                return 'YES'\n            else:\n                return 'NO'\n\n        if (xy, state, mem[0]) in memoize:\n            return 'NO'\n        memoize.add((xy, state, mem[0]))\n\n        next_state = nextState(operator, state)\n        next_xy = moveXY(xy, next_state)\n        return searchStop(next_xy, next_state)\n\n    def moveXY(xy, next_state):\n        return xychech(*map(sum, zip(xy, next_state)))\n\n    def xychech(x, y):\n        x_ = x\n        y_ = y\n\n        if x < 0:\n            x_ = x + C\n        elif x >= C:\n            x_ = x - C\n\n        if y < 0:\n            y_ = y + R\n        elif y >= R:\n            y_ = y - R\n        return (x_, y_)\n\n    return searchStop((0, 0), RIGHT)\n\nclass tail_recursive(object):\n\n    def __init__(self, func):\n        self.func = func\n        self.firstcall = True\n        self.CONTINUE = object()\n\n    def __call__(self, *args, **kwd):\n        if self.firstcall:\n            func = self.func\n            CONTINUE = self.CONTINUE\n            self.firstcall = False\n            try:\n                while True:\n                    result = func(*args, **kwd)\n                    if result is CONTINUE: # update arguments\n                        args, kwd = self.argskwd\n                    else: # last call\n                        return result\n            finally:\n                self.firstcall = True\n        else: # return the arguments of the tail call\n            self.argskwd = args, kwd\n            return self.CONTINUE\n\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom random import random\nimport sys\n\n# 再帰の最大回数を設定\nLIMIT = 100000\nsys.setrecursionlimit(LIMIT)\n\nLEFT = (-1, 0)\nRIGHT = (1, 0)\nUP = (0, -1)\nDOWN = (0, 1)\nNONE = (0, 0)\n\ndef main():\n    # 入力\n    (R, C) = map(int, raw_input().split())\n    data = [raw_input() for x in xrange(R)]\n    print(defunga(data, R, C))\n\ndef defunga(data, R, C):\n    mem = [0]\n    memoize = set()\n\n    def nextState(operator, state):\n        if operator == '<':\n            return LEFT\n        elif operator == '>':\n            return RIGHT\n        elif operator == '^':\n            return UP\n        elif operator == 'v':\n            return DOWN\n        elif operator == '_':\n            if mem[0] == 0:\n                return RIGHT\n            else:\n                return LEFT\n        elif operator == '|':\n            if mem[0] == 0:\n                return DOWN\n            else:\n                return UP\n        elif operator == '.':\n            return state\n        elif operator == '+':\n            if mem[0] == 15:\n                mem[0] = 0\n            else:\n                mem[0] += 1\n            return state\n        elif operator == '-':\n            if mem[0] == 0:\n                mem[0] = 15\n            else:\n                mem[0] -= 1\n            return state\n        else:\n            mem[0] = int(operator)\n        return state\n\n    def searchStop(xy, state):\n        while(True):\n            operator = data[xy[1]][xy[0]]\n            if operator == '@':\n                return 'YES'\n\n            if operator == '?':\n                ret = [searchStop(moveXY(xy, x), x) for x in [RIGHT, LEFT, UP, DOWN]]\n                if 'YES' in ret:\n                    return 'YES'\n                else:\n                    return 'NO'\n\n            if (xy, state, mem[0]) in memoize:\n                return 'NO'\n            memoize.add((xy, state, mem[0]))\n\n            state = nextState(operator, state)\n            xy = moveXY(xy, state)\n\n    def moveXY(xy, next_state):\n        return xychech(*map(sum, zip(xy, next_state)))\n\n    def xychech(x, y):\n        x_ = x\n        y_ = y\n\n        if x < 0:\n            x_ = x + C\n        elif x >= C:\n            x_ = x - C\n\n        if y < 0:\n            y_ = y + R\n        elif y >= R:\n            y_ = y - R\n        return (x_, y_)\n\n    return searchStop((0, 0), RIGHT)\n\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import random\nh, w = map(int, input().split())\narea = [input() for _ in range(h)]\nxyds = [[0, 0, 1, 0, 0]]\nfor _ in range(1000000):\n    for xyd in xyds:\n        x = xyd[0]\n        y = xyd[1]\n        if area[y][x] == \"<\":xyd[2], xyd[3] = -1, 0\n        elif area[y][x] == \">\":xyd[2], xyd[3] = 1, 0\n        elif area[y][x] == \"^\":xyd[2], xyd[3] = 0, -1\n        elif area[y][x] == \"v\":xyd[2], xyd[3] = 0, 1\n        elif area[y][x] == \"_\":xyd[2], xyd[3] = 1, 0 if m == 0 else -1, 0\n        elif area[y][x] == \"|\":xyd[2], xyd[3] = 0, 1 if m == 0 else 0, -1\n        elif area[y][x] == \"?\":\n            xyds.append([(x + 1) % w, y, 1, 0, xyd[4]]) \n            xyds.append([(x - 1) % w, y, -1, 0, xyd[4]]) \n            xyds.append([x, (y + 1) % h, 0, 1, xyd[4]]) \n            xyds.append([x, (y - 1) % h, 0, -1, xyd[4]])\n            xyds.remove(xyd)\n        elif area[y][x] == \".\":pass\n        elif area[y][x] == \"@\":\n            print(\"YES\")\n            break\n        elif area[y][x] == \"+\":xyd[4] = (xyd[4] + 1) % 16\n        elif area[y][x] == \"-\":xyd[4] = (xyd[4] - 1) % 16\n        else:xyd[4] = int(area[y][x])\n        xyd[0] = (x + xyd[2]) % w\n        xyd[1] = (y + xyd[3]) % h\n    else:\n        continue\n    break\nelse:\n    print(\"NO\")\n        \n        \n"
  },
  {
    "language": "Python",
    "code": "import random\nh, w = map(int, input().split())\nd = (1, 0)\nx, y, m = 0, 0, 0\narea = [input() for _ in range(h)]\nfor _ in range(1000000):\n    if area[y][x] == \"<\":d = (-1, 0)\n    elif area[y][x] == \">\":d = (1, 0)\n    elif area[y][x] == \"^\":d = (0, -1)\n    elif area[y][x] == \"v\":d = (0, 1)\n    elif area[y][x] == \"_\":d = (1, 0) if m == 0 else (-1, 0)\n    elif area[y][x] == \"|\":d = (0, 1) if m == 0 else (0, -1)\n    elif area[y][x] == \"?\":d = ((0,1),(0,-1),(1,0),(-1,0))[random.randrange(4)]\n    elif area[y][x] == \".\":pass\n    elif area[y][x] == \"@\":\n        print(\"YES\")\n        break\n    elif area[y][x] == \"+\":m = (m + 1) % 16\n    elif area[y][x] == \"-\":m = (m - 1) % 16\n    else:m = int(area[y][x])\n    x = (x + d[0]) % w\n    y = (y + d[1]) % h\nelse:\n    print(\"NO\")\n        \n        \n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom random import random\nimport sys\n\n# 再帰の最大回数を設定\nLIMIT = 100000\nsys.setrecursionlimit(LIMIT)\n\nLEFT = (-1, 0)\nRIGHT = (1, 0)\nUP = (0, -1)\nDOWN = (0, 1)\nNONE = (0, 0)\n\ndef main():\n    # 入力\n    (R, C) = map(int, raw_input().split())\n    data = [raw_input() for x in xrange(R)]\n    print(defunga(data, R, C))\n\ndef defunga(data, R, C):\n    mem = [0]\n    memoize = set()\n\n    def nextState(operator, state):\n        if operator == '<':\n            return LEFT\n        elif operator == '>':\n            return RIGHT\n        elif operator == '^':\n            return UP\n        elif operator == 'v':\n            return DOWN\n        elif operator == '_':\n            if mem[0] == 0:\n                return RIGHT\n            else:\n                return LEFT\n        elif operator == '|':\n            if mem[0] == 0:\n                return DOWN\n            else:\n                return UP\n        elif operator == '.':\n            return state\n        elif operator == '+':\n            if mem[0] == 15:\n                mem[0] = 0\n            else:\n                mem[0] += 1\n            return state\n        elif operator == '-':\n            if mem[0] == 0:\n                mem[0] = 15\n            else:\n                mem[0] -= 1\n            return state\n        else:\n            mem[0] = int(operator)\n        return state\n\n    def searchStop(xy, state):\n        next_state = state\n        next_xy = xy\n        while(True):\n            operator = data[xy[1]][xy[0]]\n            if operator == '@':\n                return 'YES'\n\n            if operator == '?':\n                ret = [searchStop(moveXY(xy, x), x) for x in [RIGHT, LEFT, UP, DOWN]]\n                if 'YES' in ret:\n                    return 'YES'\n                else:\n                    return 'NO'\n\n            if (xy, state, mem[0]) in memoize:\n                return 'NO'\n            memoize.add((xy, state, mem[0]))\n\n            next_state = nextState(operator, state)\n            next_xy = moveXY(xy, next_state)\n\n    def moveXY(xy, next_state):\n        return xychech(*map(sum, zip(xy, next_state)))\n\n    def xychech(x, y):\n        x_ = x\n        y_ = y\n\n        if x < 0:\n            x_ = x + C\n        elif x >= C:\n            x_ = x - C\n\n        if y < 0:\n            y_ = y + R\n        elif y >= R:\n            y_ = y - R\n        return (x_, y_)\n\n    return searchStop((0, 0), RIGHT)\n\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import random\nh, w = map(int, input().split())\narea = [input() for _ in range(h)]\nxyds = [[0, 0, 1, 0, 0]]\nfor _ in range(1000000):\n    for xyd in xyds:\n        x = xyd[0]\n        y = xyd[1]\n        if area[y][x] == \"<\":xyd[2], xyd[3] = -1, 0\n        elif area[y][x] == \">\":xyd[2], xyd[3] = 1, 0\n        elif area[y][x] == \"^\":xyd[2], xyd[3] = 0, -1\n        elif area[y][x] == \"v\":xyd[2], xyd[3] = 0, 1\n        elif area[y][x] == \"_\":\n            if xyd[4] == 0:xyd[2], xyd[3] = 1, 0\n            else:xyd[2], xyd[3] = -1, 0\n        elif area[y][x] == \"|\":\n            if xyd[4] == 0:xyd[2], xyd[3] = 0, 1\n            else:xyd[2], xyd[3] = 0, -1\n        elif area[y][x] == \"?\":\n            xyds.append([(x + 1) % w, y, 1, 0, xyd[4]]) \n            xyds.append([(x - 1) % w, y, -1, 0, xyd[4]]) \n            xyds.append([x, (y + 1) % h, 0, 1, xyd[4]]) \n            xyds.append([x, (y - 1) % h, 0, -1, xyd[4]])\n            xyds.remove(xyd)\n        elif area[y][x] == \".\":pass\n        elif area[y][x] == \"@\":\n            print(\"YES\")\n            break\n        elif area[y][x] == \"+\":xyd[4] = (xyd[4] + 1) % 16\n        elif area[y][x] == \"-\":xyd[4] = (xyd[4] - 1) % 16\n        else:xyd[4] = int(area[y][x])\n        xyd[0] = (x + xyd[2]) % w\n        xyd[1] = (y + xyd[3]) % h\n    else:\n        continue\n    break\nelse:\n    print(\"NO\")\n        \n        \n"
  },
  {
    "language": "Python",
    "code": "import random\nh, w = map(int, input().split())\narea = [input() for _ in range(h)]\nxyds = [[0, 0, 1, 0, 0]]\nfor _ in range(1000000):\n    for xyd in xyds:\n        x = xyd[0]\n        y = xyd[1]\n        if area[y][x] == \"<\":xyd[2], xyd[3] = -1, 0\n        elif area[y][x] == \">\":xyd[2], xyd[3] = 1, 0\n        elif area[y][x] == \"^\":xyd[2], xyd[3] = 0, -1\n        elif area[y][x] == \"v\":xyd[2], xyd[3] = 0, 1\n        elif area[y][x] == \"_\":xyd[2], xyd[3] = 1, 0 if xyd[4] == 0 else -1, 0\n        elif area[y][x] == \"|\":xyd[2], xyd[3] = 0, 1 if xyd[4] == 0 else 0, -1\n        elif area[y][x] == \"?\":\n            xyds.append([(x + 1) % w, y, 1, 0, xyd[4]]) \n            xyds.append([(x - 1) % w, y, -1, 0, xyd[4]]) \n            xyds.append([x, (y + 1) % h, 0, 1, xyd[4]]) \n            xyds.append([x, (y - 1) % h, 0, -1, xyd[4]])\n            xyds.remove(xyd)\n        elif area[y][x] == \".\":pass\n        elif area[y][x] == \"@\":\n            print(\"YES\")\n            break\n        elif area[y][x] == \"+\":xyd[4] = (xyd[4] + 1) % 16\n        elif area[y][x] == \"-\":xyd[4] = (xyd[4] - 1) % 16\n        else:xyd[4] = int(area[y][x])\n        xyd[0] = (x + xyd[2]) % w\n        xyd[1] = (y + xyd[3]) % h\n    else:\n        continue\n    break\nelse:\n    print(\"NO\")\n        \n        \n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nr, c = map(int, input().split())\nmp = [input() for _ in range(r)]\nR, U, L, D = 0, 1, 2, 3\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\ndic = {}\ndic[(0, 0, R, 0)] = True\nque = deque()\nque.append((0, 0, R, 0))\n\nwhile que:\n  x, y, direct, mem = que.popleft()\n  com = mp[y][x]\n  if com == \"?\":\n    for d in (R, U, L, D):\n      dx, dy = vec[d]\n      nx, ny = (x + dx) % c, (y + dy) % r\n      if (nx, ny, d, mem) not in dic:\n        dic[(nx, ny, d, mem)] = True\n        que.append((nx, ny, d, mem))\n    continue\n  elif com == \"@\":\n    print(\"YES\")\n    break\n  elif com == \"<\":\n    direct = L\n  elif com == \">\":\n    direct = R\n  elif com == \"^\":\n    direct = U\n  elif com == \"v\":\n    direct = D\n  elif com == \"_\":\n    direct = R if mem == 0 else L\n  elif com == \"|\":\n    direct = D if mem == 0 else U\n  elif com == \".\":\n    pass\n  elif \"0\" <= com <= \"9\":\n    mem = int(com)\n  elif com == \"+\":\n    mem = (mem + 1) % 16\n  elif com == \"-\":\n    mem = (mem - 1) % 16\n  dx, dy = vec[direct]\n  nx, ny = (x + dx) % c, (y + dy) % r\n  if (nx, ny, direct, mem) not in dic:\n    dic[(nx, ny, direct, mem)] = True\n    que.append((nx, ny, direct, mem))\nelse:\n  print(\"NO\")\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom random import random\nimport sys\n\n# 再帰の最大回数を設定\nLIMIT = 100000\nsys.setrecursionlimit(LIMIT)\n\nLEFT = (-1, 0)\nRIGHT = (1, 0)\nUP = (0, -1)\nDOWN = (0, 1)\nNONE = (0, 0)\n\ndef main():\n    # 入力\n    (R, C) = map(int, raw_input().split())\n    data = [raw_input() for x in xrange(R)]\n    print(defunga(data, R, C))\n\ndef defunga(data, R, C):\n    mem = [0]\n    memoize = set()\n\n    def nextState(operator, state):\n        if operator == '<':\n            return LEFT\n        elif operator == '>':\n            return RIGHT\n        elif operator == '^':\n            return UP\n        elif operator == 'v':\n            return DOWN\n        elif operator == '_':\n            if mem[0] == 0:\n                return RIGHT\n            else:\n                return LEFT\n        elif operator == '|':\n            if mem[0] == 0:\n                return DOWN\n            else:\n                return UP\n        elif operator == '.':\n            return state\n        elif operator == '+':\n            if mem[0] == 15:\n                mem[0] = 0\n            else:\n                mem[0] += 1\n            return state\n        elif operator == '-':\n            if mem[0] == 0:\n                mem[0] = 15\n            else:\n                mem[0] -= 1\n            return state\n        else:\n            mem[0] = int(operator)\n        return state\n\n    def searchStop(xy, state):\n        operator = data[xy[1]][xy[0]]\n        if operator == '@':\n            return 'YES'\n\n        if operator == '?':\n            ret = [searchStop(moveXY(xy, x), x) for x in [RIGHT, LEFT, UP, DOWN]]\n            if 'YES' in ret:\n                return 'YES'\n            else:\n                return 'NO'\n\n        if (xy, state, mem[0]) in memoize:\n            return 'NO'\n        memoize.add((xy, state, mem[0]))\n\n        next_state = nextState(operator, state)\n        next_xy = moveXY(xy, next_state)\n        return searchStop(next_xy, next_state)\n\n    def moveXY(xy, next_state):\n        return xychech(*map(sum, zip(xy, next_state)))\n\n    def xychech(x, y):\n        x_ = x\n        y_ = y\n\n        if x < 0:\n            x_ = x + C\n        elif x >= C:\n            x_ = x - C\n\n        if y < 0:\n            y_ = y + R\n        elif y >= R:\n            y_ = y - R\n        return (x_, y_)\n\n    return searchStop((0, 0), RIGHT)\n\nif __name__=='__main__':\n    main()"
  }
]