[
  {
    "language": "Fortran",
    "code": "program modulo_matrix\n  implicit none\n  integer, parameter :: m = 7919, k = 500\n  integer :: n, u = 0, i, j\n  integer(8) :: a(k,k) = 1_8, p(2*k) = 0_8\n  logical :: b(m) = .false.\n  b(1) = .true.\n  do i = 1, m\n    if (b(i)) cycle\n    do j = i, m, i\n      b(j) = .true.\n    end do\n    b(i) = .false.\n  end do\n  do i = 1, m\n    if (b(i)) cycle\n    u = u+1\n    p(u) = i\n  end do\n  read(*,*) n\n  do i = 1, n\n    do j = 1, n\n      u = i+j\n      if (mod(u,2) == 0) a(i,j) = a(i,j)*p(u/2)\n      u = i-j+n-1\n      if (mod(u,2) /= mod(n,2)) a(i,j) = a(i,j)*p(n-(u+1)/2)\n    end do\n  end do\n  do i = 1, n\n    do j = 1, n\n      if (a(i,j) /= 1_8) cycle\n      if (i /= 1) a(i,j) = lcm(a(i,j),a(i-1,j))\n      if (i /= n) a(i,j) = lcm(a(i,j),a(i+1,j))\n      if (j /= 1) a(i,j) = lcm(a(i,j),a(i,j-1))\n      if (j /= n) a(i,j) = lcm(a(i,j),a(i,j+1))\n      a(i,j) = a(i,j)+1_8\n    end do\n  end do\n  do i = 1, n\n    write(*,'(i0)',advance='no') a(i,1)\n    do j = 2, n\n      write(*,'(x,i0)',advance='no') a(i,j)\n    end do\n    write(*,*)\n  end do\ncontains\n  integer(8) function lcm(a,b)\n    integer(8), intent(in) :: a, b\n    lcm = abs(a)/gcd(a,b)*abs(b)\n  end\n  integer(8) function gcd(a,b)\n    integer(8), intent(in) :: a, b\n    integer(8) :: x, y\n    x = max(abs(a),abs(b))\n    y = min(abs(a),abs(b))\n    do while (y > 0_8)\n      gcd = y\n      y = mod(x,y)\n      x = gcd\n    end do\n  end\nend program modulo_matrix"
  },
  {
    "language": "Fortran",
    "code": "program modulo_matrix\n  implicit none\n  integer, parameter :: m = 7919, k = 500\n  integer :: n, u = 0, i, j\n  integer(8) :: a(k,k) = 1_8, p(2*k) = 0_8\n  logical :: b(m) = .false.\n  read(*,*) n\n  if (n == 2) then\n    write(*,'(a)') \"2 9\"\n    write(*,'(a)') \"5 4\"\n    stop\n  end if\n  b(1) = .true.\n  do i = 1, m\n    if (b(i)) cycle\n    do j = i, m, i\n      b(j) = .true.\n    end do\n    b(i) = .false.\n  end do\n  do i = 1, m\n    if (b(i)) cycle\n    u = u+1\n    p(u) = i\n  end do\n  do i = 1, n\n    do j = 1, n\n      u = i+j\n      if (mod(u,2) == 0) a(i,j) = a(i,j)*p(u/2)\n      u = i-j+n-1\n      if (mod(u,2) /= mod(n,2)) a(i,j) = a(i,j)*p(2*n-(u+1)/2)\n    end do\n  end do\n  do i = 1, n\n    do j = 1, n\n      if (a(i,j) /= 1_8) cycle\n      if (i /= 1) a(i,j) = lcm(a(i,j),a(i-1,j))\n      if (i /= n) a(i,j) = lcm(a(i,j),a(i+1,j))\n      if (j /= 1) a(i,j) = lcm(a(i,j),a(i,j-1))\n      if (j /= n) a(i,j) = lcm(a(i,j),a(i,j+1))\n      a(i,j) = a(i,j)+1_8\n    end do\n  end do\n  do i = 1, n\n    write(*,'(i0)',advance='no') a(i,1)\n    do j = 2, n\n      write(*,'(x,i0)',advance='no') a(i,j)\n    end do\n    write(*,*)\n  end do\ncontains\n  integer(8) function lcm(a,b)\n    integer(8), intent(in) :: a, b\n    lcm = abs(a)/gcd(a,b)*abs(b)\n  end\n  integer(8) function gcd(a,b)\n    integer(8), intent(in) :: a, b\n    integer(8) :: x, y\n    x = max(abs(a),abs(b))\n    y = min(abs(a),abs(b))\n    do while (y > 0_8)\n      gcd = y\n      y = mod(x,y)\n      x = gcd\n    end do\n  end\nend program modulo_matrix"
  },
  {
    "language": "Fortran",
    "code": "program modulo_matrix\n  implicit none\n  integer, parameter :: m = 7919, k = 500\n  integer :: n, u = 0, i, j\n  integer(8) :: a(k,k) = 1_8, p(2*k) = 0_8\n  logical :: b(m) = .false.\n  b(1) = .true.\n  do i = 1, m\n    if (b(i)) cycle\n    do j = i, m, i\n      b(j) = .true.\n    end do\n    b(i) = .false.\n  end do\n  do i = 1, m\n    if (b(i)) cycle\n    u = u+1\n    p(u) = i\n  end do\n  read(*,*) n\n  do i = 1, n\n    do j = 1, n\n      u = i+j\n      if (mod(u,2) == 0) a(i,j) = a(i,j)*p(u/2)\n      u = i-j+n-1\n      if (mod(u,2) /= mod(n,2)) a(i,j) = a(i,j)*p(2*n-(u+1)/2)\n    end do\n  end do\n  do i = 1, n\n    do j = 1, n\n      if (a(i,j) /= 1_8) cycle\n      if (i /= 1) a(i,j) = lcm(a(i,j),a(i-1,j))\n      if (i /= n) a(i,j) = lcm(a(i,j),a(i+1,j))\n      if (j /= 1) a(i,j) = lcm(a(i,j),a(i,j-1))\n      if (j /= n) a(i,j) = lcm(a(i,j),a(i,j+1))\n      a(i,j) = a(i,j)+1_8\n    end do\n  end do\n  do i = 1, n\n    write(*,'(i0)',advance='no') a(i,1)\n    do j = 2, n\n      write(*,'(x,i0)',advance='no') a(i,j)\n    end do\n    write(*,*)\n  end do\ncontains\n  integer(8) function lcm(a,b)\n    integer(8), intent(in) :: a, b\n    lcm = abs(a)/gcd(a,b)*abs(b)\n  end\n  integer(8) function gcd(a,b)\n    integer(8), intent(in) :: a, b\n    integer(8) :: x, y\n    x = max(abs(a),abs(b))\n    y = min(abs(a),abs(b))\n    do while (y > 0_8)\n      gcd = y\n      y = mod(x,y)\n      x = gcd\n    end do\n  end\nend program modulo_matrix"
  },
  {
    "language": "Fortran",
    "code": "program modulo_matrix\n  implicit none\n  integer, parameter :: m = 7919, k = 500\n  integer :: n, u = 0, i, j\n  integer(8) :: a(k,k) = 1_8, p(2*k) = 0_8\n  logical :: b(m) = .false.\n  b(1) = .true.\n  do i = 1, m\n    if (b(i)) cycle\n    do j = i, m, i\n      b(j) = .true.\n    end do\n    b(i) = .false.\n  end do\n  do i = 1, m\n    if (b(i)) cycle\n    u = u+1\n    p(u) = i\n  end do\n  read(*,*) n\n  do i = 1, n\n    do j = 1, n\n      u = i+j\n      if (mod(u,2) == 0) a(i,j) = a(i,j)*p(u/2)\n      u = i-j+n+1\n      if (mod(u,2) /= mod(n,2)) a(i,j) = a(i,j)*p(u/2)\n    end do\n  end do\n  do i = 1, n\n    do j = 1, n\n      if (a(i,j) /= 1_8) cycle\n      if (i /= 1) a(i,j) = a(i,j)*a(i-1,j)\n      if (i /= n) a(i,j) = a(i,j)*a(i+1,j)\n      if (j /= 1) a(i,j) = a(i,j)*a(i,j-1)\n      if (j /= n) a(i,j) = a(i,j)*a(i,j+1)\n      a(i,j) = a(i,j)+1_8\n    end do\n  end do\n  do i = 1, n\n    write(*,'(i0)',advance='no') a(i,1)\n    do j = 2, n\n      write(*,'(x,i0)',advance='no') a(i,j)\n    end do\n    write(*,*)\n  end do\nend program modulo_matrix"
  },
  {
    "language": "Fortran",
    "code": "program modulo_matrix\n  implicit none\n  integer, parameter :: m = 7919, k = 500\n  integer :: n, u = 0, i, j\n  integer(8) :: a(k,k) = 1_8, p(2*k) = 0_8\n  logical :: b(m) = .false.\n  read(*,*) n\n  if (n == 2) then\n    write(*,'(a)') \"2 7\"\n    write(*,'(a)') \"13 3\"\n    stop\n  end if\n  b(1) = .true.\n  do i = 1, m\n    if (b(i)) cycle\n    do j = i, m, i\n      b(j) = .true.\n    end do\n    b(i) = .false.\n  end do\n  do i = 1, m\n    if (b(i)) cycle\n    u = u+1\n    p(u) = i\n  end do\n  do i = 1, n\n    do j = 1, n\n      u = i+j\n      if (mod(u,2) == 0) a(i,j) = a(i,j)*p(u/2)\n      u = i-j+n-1\n      if (mod(u,2) /= mod(n,2)) a(i,j) = a(i,j)*p(2*n-(u+1)/2)\n    end do\n  end do\n  do i = 1, n\n    do j = 1, n\n      if (a(i,j) /= 1_8) cycle\n      if (i /= 1) a(i,j) = lcm(a(i,j),a(i-1,j))\n      if (i /= n) a(i,j) = lcm(a(i,j),a(i+1,j))\n      if (j /= 1) a(i,j) = lcm(a(i,j),a(i,j-1))\n      if (j /= n) a(i,j) = lcm(a(i,j),a(i,j+1))\n      a(i,j) = a(i,j)+1_8\n    end do\n  end do\n  do i = 1, n\n    write(*,'(i0)',advance='no') a(i,1)\n    do j = 2, n\n      write(*,'(x,i0)',advance='no') a(i,j)\n    end do\n    write(*,*)\n  end do\ncontains\n  integer(8) function lcm(a,b)\n    integer(8), intent(in) :: a, b\n    lcm = abs(a)/gcd(a,b)*abs(b)\n  end\n  integer(8) function gcd(a,b)\n    integer(8), intent(in) :: a, b\n    integer(8) :: x, y\n    x = max(abs(a),abs(b))\n    y = min(abs(a),abs(b))\n    do while (y > 0_8)\n      gcd = y\n      y = mod(x,y)\n      x = gcd\n    end do\n  end\nend program modulo_matrix"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[1100],na,n;\nbool p(int x){for (int i=2;i<x;i++)if (x%i==0)return 0;return 1;}\nint main(){\n\tfor (int i=2;i<=8000;i++)if (p(i))a[++na]=i;\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)cout<<a[(i+j)/2]*a[(i-j+n)/2+n]<<' ';\n\t\t\telse cout<<a[(i+j)/2]*a[(i-j+n)/2+n]*a[(i+j+1)/2]*a[(i-j+n+1)/2+n]+1<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\nint p[500][500], q[500][500];\nll A[500][500];\n\nconst int MAXN = 1000;\nint prime[MAXN];\nbool primeNumber(int n){\n    if(n < 2) return false;\n    else{\n        for(int i = 2; i * i <= n; i++){\n            if(n % i == 0) return false;\n        }\n        return true;\n    }\n}\n\nint main() {\n   int N;\n   cin >> N;\n   int cnt = 0;\n   for (int i = 2;; ++i) {\n      if (primeNumber(i)) {\n         prime[cnt] = i; \n         cnt++;\n      }\n      if (cnt >= MAXN) break; \n   }\n   int Uid = 0;\n   int Did = MAXN - 1;\n   for (int r = 1; r <= 500; r++) {\n      for (int c = 1; c <= 500; c++) {\n         int tmp = r + c;\n         if (tmp % 2 == 0) {\n            if (tmp % 4 == 0) {\n               p[r - 1][c - 1] = prime[Uid + tmp / 4 - 1];\n            } else {\n               p[r - 1][c - 1] = prime[Did - tmp / 4];\n            }\n         }\n      }\n   }\n   Uid += 250;\n   Did -= 250;\n\n   for (int r = 1; r <= 500; r++) {\n      for (int c = 1; c <= 500; c++) {\n         int tmp = r - c + 500;\n         if (tmp % 2 == 0) {\n            if (tmp % 4 == 0) {\n               q[r - 1][c - 1] = prime[Uid + tmp / 4 - 1];\n            } else {\n               q[r - 1][c - 1] = prime[Did - tmp / 4];\n            }\n         }\n      }\n   }\n\n   for (int r = 1; r <= 500; r++) {\n      for (int c = 1; c <= 500; c++) {\n         int tmp = r + c;\n         if (tmp % 2 == 0) {\n            A[r - 1][c - 1] = p[r - 1][c - 1] * q[r - 1][c - 1];\n         } else {\n            A[r - 1][c - 1] = 1;\n            if (r - 2 >= 0) A[r - 1][c - 1] *= p[r - 2][c -1];\n            else if (c - 2 != -1) A[r - 1][c - 1] *= p[r - 1][c - 2];\n            if (r < 500) A[r - 1][c - 1] *= p[r][c -1];\n            else if (c != 500) A[r - 1][c - 1] *= p[r - 1][c];\n            if (c - 2 >= 0) A[r - 1][c - 1] *= q[r - 1][c -2];\n            else if (r != 500) A[r - 1][c - 1] *= q[r][c - 1];\n            if (c < 500) A[r - 1][c - 1] *= q[r - 1][c];\n            else if (r - 2 != -1) A[r - 1][c - 1] *= p[r - 2][c - 1];\n            A[r - 1][c - 1] += 1;  \n         }\n      } \n   }\n\n   for (int r = 0; r < N; r++) {\n      for (int c = 0; c < N; c++) {\n         cout << A[r][c];\n         if (c != N - 1) cout << \" \";\n      }\n      cout << endl;\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 100005;\n\nint di[] = { -1, 0, 0, 1 };\nint dj[] = { 0, -1, 1, 0 };\n\nint n;\nbool p[100005];\nvi primes;\n\nvoid sieve() {\n\tMMS(p, 1);\n\tp[0] = p[1] = 0;\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i]) {\n\t\t\tfor (int j = 2 * i; j < N; j += i)\n\t\t\t\tp[j] = 0;\n\t\t}\n\t}\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i])\n\t\t\tprimes.pb(i);\n\t}\n}\n\nll a[501][501];\n\nll setV(int i, int j) {\n\tint d0 = (i + j) >> 1;\n\tint d1 = n + ((i - j + n - 1) >> 1);\n\treturn primes[d0] + primes[d1];\n}\n\nll get(int i, int j) {\n\tif (i < 0 || i >= n || j < 0 || j >= n)\n\t\treturn -1;\n\treturn a[i][j];\n}\n\nll calc(int i, int j) {\n\tll res = 1;\n\tfor (int d = 0; d < 4; d++) {\n\t\tint ni = i + di[d];\n\t\tint nj = j + dj[d];\n\t\tll v = get(ni, nj);\n\t\tif (v != -1)\n\t\t\tres = (res * v) / __gcd(res, v);\n\t}\n\treturn res + 1;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tsieve();\n\tcin >> n;\n\tll mx = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1) == 0) {\n\t\t\t\ta[i][j] = setV(i, j);\n\t\t\t\tmx = max(mx, a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1)) {\n\t\t\t\ta[i][j] = calc(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\ta[1][0] *= 2;\n\t\ta[1][0]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j == n - 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v((i + j - 2) / 2)] * p[v((1500 + i - j) / 2)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v((i + j) / 2)] * p[v((1500 + i - j) / 2)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    cin >> N;\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)cout << a.at(i, j) << \" \";\n        cout << a.at(i, j) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Author: hotaruijika\n * Created: 2018.09.15 23:58:01\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n;\nint f[11111], a[500 * 500 + 10], color[500 * 500 + 10];\nmap <int, int> id;\nvector <int> prime;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 2; i <= 1e4 + 10; ++i) {\n\t\tif (!f[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tf[i] = i;\n\t\t}\n\t\tfor (int j = 0; j < (int) prime.size() && i * prime[j] <= 1e4 && prime[j] <= f[i]; ++j) \n\t\t\tf[i * prime[j]] = prime[j];\n\t}\n\tint cnt = 0; color[1] = 1;\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tint x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tfor (int k = 0; k < 4; ++k) if (x + dx[k] > 0 && x + dx[k] <= n && y + dy[k] > 0 && y + dy[k] <= n) {\n\t\t\tcolor[i] |= color[(x + dx[k] - 1) * n + y + dy[k]];\n\t\t\t//cerr << i << \" \" << (x + dx[i] - 1) * n + y + dy[i] << \"\\n\";\n\t\t}\n\t\tcolor[i] = 1 - color[i];\n\t\tif (color[i]) continue;\n\t\tif (!id.count(x + y)) id[x + y] = cnt++;\n\t\tif (!id.count(x - y)) id[x - y] = cnt++;\n\t\ta[i] = prime[id[x + y]] * prime[id[x - y]];\n\t}\n\t//for (int i = 1; i <= n * n; ++i) cerr << a[i] << (i % n == 0 ? \"\\n\" : \" \");\n\tfor (int i = 1; i <= n * n; ++i) if (color[i]) {\n\t\tint lcm = 1, x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tfor (int k = 0; k < 4; ++k) if (x + dx[k] > 0 && x + dx[k] <= n && y + dy[k] > 0 && y + dy[k] <= n) {\n\t\t\tlcm = lcm / __gcd(a[(x + dx[k] - 1) * n + y + dy[k]], lcm) * a[(x + dx[k] - 1) * n + y + dy[k]];\n\t\t}\n\t\ta[i] = lcm + 1;\n\t}\n\tfor (int i = 1; i <= n * n; ++i) cout << a[i] << (i % n == 0 ? \"\\n\" : \" \");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1))\n\t\t\t\tans[i][j] = pri[++cnt], used.insert(pri[cnt]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tif (ans[i - 1][j])\n\t\t\t\t\tans[i][j] *= ans[i - 1][j];\n\t\t\t\tif (ans[i][j - 1])\n\t\t\t\t\tans[i][j] *= ans[i][j - 1];\n\t\t\t\tif (ans[i + 1][j])\n\t\t\t\t\tans[i][j] *= ans[i + 1][j];\n\t\t\t\tif (ans[i][j + 1])\n\t\t\t\t\tans[i][j] *= ans[i][j + 1];\n\t\t\t\tll tmp = ans[i][j];\n\t\t\t\twhile (used.count(ans[i][j] + 1))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t++ans[i][j];\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll a[1010][1010],p[10010];\nint vis[10010],cnt;\ninline void init(int n=10000) {\n    vis[1]=1;\n    for (int i=2;i<=n;i++) {\n        if (!vis[i]) p[++cnt]=i;\n        for (int j=1;j<=cnt && i*p[j]<=n;j++) {\n            vis[i*p[j]]=1;\n            if (!(i % p[j])) break;\n        }\n    }\n}\ninline ll lcm(ll x,ll y) {\n    if (!x || !y) return x+y;\n    return x/__gcd(x,y)*y;\n}\nint main() {\n    int n;cin>>n,init();\n    if (n==2) return puts(\"4 7\\n23 10\\n\"),0;\n    for (int i=1;i<=n;i++)\n        for (int j=(i+1&1)+1;j<=n;j+=2)\n            a[i][j]=p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n    for (int i=1;i<=n;i++)\n        for (int j=(i&1)+1;j<=n;j+=2)\n            a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i][j+1],a[i+1][j]))+1;\n    for (int i=1;i<=n;i++,putchar('\\n'))\n        for (int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (250010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint p[N],cnt,n;\nLL a[511][511]; bool isp[N*40];\nint eular(int n){\n\tfor(int i=2;i<=n;i++){\n\t\tif(!isp[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tif(cnt==125000)return i;\n\t\t}\n\t\tfor(int j=1;j<=cnt;j++){\n\t\t\tint t=p[j]*i; if(t>n)break;\n\t\t\tisp[t]=1; if(i%p[j]==0)break;\n\t\t}\n\t}\n}\nLL gcd(LL a,LL b){\n\treturn b?gcd(b,a%b):a;\n}\nLL lcm(LL x,LL y){\n\tif(x==0||y==0)return x+y;\n\treturn x/gcd(x,y)*y;\n}\nint main(){\n\teular(2000000); read(n);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(((i+j)&1)==0)a[i][j]=1ll*p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n//\tputs(\"12345\"); \n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(!a[i][j])a[i][j]=lcm(lcm(a[i][j+1],a[i+1][j]),lcm(a[i][j-1],a[i-1][j]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\tprint(a[i][j]),spa; ent;\n\t}\n\treturn flush(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nusing std::__gcd;\nint n,prime[10100000],a[510][510],len;\nbool isPrime[10001000];\nint lcm(int a,int b){\n\treturn a/__gcd(a,b)*b;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t} \n\tfor(int i=2;i<=1000000;i++)\n\t\tisPrime[i]=true;\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!isPrime[i])continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i)\n\t\t\tisPrime[j]=false;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tif(isPrime[i])prime[++len]=i;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1)continue;\n\t\t\tint x=(i+j)/2,y=(i+n*3-j+1)/2;\n\t\t\ta[i][j]=prime[x]*prime[y];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)continue;\n\t\t\tif(i==1&&j==n)a[i][j]=lcm(a[i+1][j],a[i][j-1]);\n\t\t\telse if(i==n&&j==1)a[i][j]=lcm(a[i-1][j],a[i][j+1]);\n\t\t\telse if(i==1||i==n)a[i][j]=a[i][j-1]*a[i][j+1]; \n\t\t\telse a[i][j]=a[i-1][j]*a[i+1][j];\n\t\t\ta[i][j]++; \n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j==n)puts(\"\");\n\t\t\telse putchar(' ');\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 520\n#define maxm 20020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nint prime[maxm],cnt,tag[maxm];\nint n,tag1[maxn][maxn],tag2[maxn][maxn],tot;\nll a[maxn][maxn];\nmap <ll,int> num;\nvector <pr> vec;\nll tmp = 1e15;\n\nvoid init(){\n\trep(i,2,10000){\n\t\tif ( !tag[i] ) prime[++cnt] = i;\n\t\trep(j,1,cnt){\n\t\t\tif ( prime[j] * i > 10000 ) break;\n\t\t\ttag[prime[j] * i] = 1;\n\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\tif ( !b ) return a;\n\treturn gcd(b,a % b);\n}\ninline ll lcm(ll a,ll b){\n\tll d = gcd(a,b);\n\treturn a / d * b;\n}\nbool check(int x,int y){\n\tif ( x > 1 && max(a[x][y],a[x - 1][y]) % min(a[x][y],a[x - 1][y]) != 1 ) return 0;\n\n\tif ( y > 1 && max(a[x][y],a[x][y - 1]) % min(a[x][y],a[x][y - 1]) != 1 ) return 0;\n\treturn 1;\t\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\t\t\n\tif ( n == 2 ){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1 ) ){\n\t\t\t\tif ( i > 1 && j > 1 && tag1[i - 1][j - 1] ) tag1[i][j] = tag1[i - 1][j - 1];\n\t\t\t\tif ( i < n && j < n && tag1[i + 1][j + 1] ) tag1[i][j] = tag1[i + 1][j + 1];\n\t\t\t\tif ( !tag1[i][j] ) tag1[i][j] = ++tot; \n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1 ) ){\n\t\t\t\tif ( i > 1 && j < n && tag2[i - 1][j + 1] ) tag2[i][j] = tag2[i - 1][j + 1];\n\t\t\t\tif ( i < n && j > 1 && tag2[i + 1][j - 1] ) tag2[i][j] = tag2[i + 1][j - 1];\n\t\t\t\tif ( !tag2[i][j] ) tag2[i][j] = ++tot;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1) ){\n\t\t\t\ta[i][j] = prime[tag1[i][j]] * prime[tag2[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tll cur = 1;\n\t\t\t\tif ( i > 1 ) cur = lcm(cur,a[i - 1][j]);\n\t\t\t\tif ( i < n ) cur = lcm(cur,a[i + 1][j]);\n\t\t\t\tif ( j > 1 ) cur = lcm(cur,a[i][j - 1]);\n\t\t\t\tif ( j < n ) cur = lcm(cur,a[i][j + 1]);\n\t\t\t\ta[i][j] = cur + 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tcout<<a[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[505][505];\n\nlong long lcm(long long a,long long b) {\n\treturn a / __gcd(a, b) * b;\n}\nvoid build() {\n\tint ptr = 2;\n\tvector<int> primes;\n\twhile (primes.size() < 1007) {\n\t\tbool prime = 1;\n\t\tfor (int i = 2; i * i <= ptr; ++i) {\n\t\t\tif (ptr % i == 0) {\n\t\t\t\tprime = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (prime) primes.push_back(ptr);\n\t\tptr++;\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int j = 0; j < 500; ++j) {\n\t\t\tif (!(i + j & 1)) {\n\t\t\t\ta[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + 752];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int j = 0; j < 500; ++j) {\n\t\t\tif (i + j & 1) {\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tif (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n\t\t\t\tif (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n\t\t\t\tif (i < 499) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n\t\t\t\tif (j < 499) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tbuild();\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcout << a[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  int n = 500;\n  int val = n * n / 2;\n  vector<vector<ll>> ans(n + 2, vector<ll>(n + 2, 1));\n  int cnt = 0, l = 1, r = val;\n  for (int i = 3; i <= n * 2; i += 2)\n    for (int x = max(1, i - n), y = i - x; x + 1 <= n && y - 1 > 0; x += 2, y -= 2) {\n      ans[x][y] = l * 2;\n      ans[x + 1][y - 1] = l * 4;\n      ++l;\n    }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j) {\n      if (ans[i][j] == 1)\n        if (i != 1 && j != 1)\n          ans[i][j] += lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n        else {\n          ll l = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n          ll v = 1e15 / l;\n          if (l * v == (ll)1e15) --v;\n          ans[i][j] += l * v;\n        }\n    }\n  cin >> n;\n  for (int i = 1; i <= n; ++i)\n    cout << vector<ll>(ans[i].begin() + 1, ans[i].begin() + n + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  donttttttt use vector \n  run n = 1 and n = MAXN before submit\n  try to AC within one submission\n*/\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\n\n#define int long long\n\nconst int N = 555;\nconst int M = 5e6 + 233;\nbool np[M], ban[M]; int p[M / 10], p_cnt;\nint n, a[N][N], bad[N][N];\n\ninline void prepare(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (np[i]) continue;\n\t\tp[++p_cnt] = i;\n\t\tfor (int j = i + i; j <= n; j += i) {\n\t\t\tnp[j] = true;\n\t\t}\n\t}\n}\n\ninline int lcm(int x, int y) {\n\treturn x / __gcd(x, y) * y;\n}\n\nsigned main(void) {\n\tprepare(10000);\n\tread(n);\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\trep (i, n) rep (j, n) bad[i][j] = ~(i + j) & 1;\n\tint tot = 0;\n\trep (len, n + n) if (len % 2 == 0) {\n\t\t++tot;\n\t\trep (i, n) rep (j, n)\n\t\t\tif (i + j == len && bad[i][j])\n\t\t\t\ta[i][j] = p[tot];\n\t}\n\trep (len, n + n) {\n\t\tif (len % 2) continue;\n\t\tint cnt = 0;\n\t\trep (i, n) rep (j, n)\n\t\t\tif ((n - i + 1 + j) == len && bad[i][j])\n\t\t\t\t++cnt;\n\t\tif (cnt) {\n\t\t\t++tot;\n\t\t}\n\t\trep (i, n) rep (j, n)\n\t\t\tif ((n - i + 1 + j) == len && bad[i][j])\n\t\t\t\ta[i][j] *= p[tot];\n\t}\n\t// cerr << p[500] * p[1000] << \"\\n\";\n\t// rep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n\trep (i, n) rep (j, n) if ((i + j) & 1) {\n\t\ta[i][j] = 1;\n\t\tauto add = [&](int x, int y) {\n\t\t\tif (x < 1 || x > n || y < 1 || y > n) return ;\n\t\t\tint t = lcm(a[i][j], a[x][y]), base = t;\n\t\t\ta[i][j] = t;\n\t\t\treturn ;\n\t\t};\n\t\tadd(i - 1, j);\n\t\tadd(i + 1, j);\n\t\tadd(i, j - 1);\n\t\tadd(i, j + 1);\n\t\t++a[i][j];\n\t}\n\trep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > >\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=505,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\ninline int getp(){\n\tstatic int now=500;\n\twhile(1){\n\t\tnow++;\n\t\tbool isok=1;\n\t\tfor(int i=2;i*i<=now;i++)\n\t\t\tif(now%i==0){isok=0;break;}\n\t\tif(isok) return now;\n\t}\n\tassert(0);\n}\n\nint n,b[N];\nll a[N][N];\ninline ll lcm(ll x,ll y){\n\tif(!x||!y) return x|y;\n\treturn x/__gcd(x,y)*y;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d\",&n);\n\tint l=1,r=n;\n\tfor(int i=(n+1)/2,j=1;i;i--,j+=2)\n\t\tb[i]=j;\n\tfor(int i=(n+1)/2+1,j=2;i<=n;i++,j+=2)\n\t\tb[i]=j;\n\tmap<ll,bool> vis;\n\tfor(int i=0;i<=n;i+=2,l++,r--){\n\t\tint p=getp();\n\t\tfor(int x=1,j=l;x<=n;x++){\n\t\t\tint y=x+i;\n\t\t\tif(y<1||y>n) continue;\n\t\t\ta[x][y]=p*b[j];j++;\n\t\t\tvis[a[x][y]]=1;\n\t\t}\n\t\tif(!i) continue;\n\t\tp=getp();\n\t\tfor(int x=1,j=l;x<=n;x++){\n\t\t\tint y=x-i;\n\t\t\tif(y<1||y>n) continue;\n\t\t\ta[x][y]=p*b[j];j++;\n\t\t\tvis[a[x][y]]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!a[i][j]){\n\t\t\t\tll k=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])));\n\t\t\t\ta[i][j]=k+1;\n\t\t\t\twhile(vis[a[i][j]]) a[i][j]+=k;\n\t\t\t\tvis[a[i][j]]=1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<n;j++)\n\t\t\tassert(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1])==1);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tassert(max(a[i+1][j],a[i][j])%min(a[i+1][j],a[i][j])==1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+5;\n\nll s[505];\nll a[505][505], t = 1000000000000000, n;\nmap<ll, ll> m;\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\n\nbool isp(int x) {\n\tfor (int i = 2; i < x; ++i)\n\t\tif (x%i == 0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tint ct = 0;\n\tfor (int i = 500; i <= 5000; ++i) {\n\t\tif (isp(i)) {\n\t\t\ts[ct] = i;\n\t\t\tct++;\n\t\t}\n\t\tif (ct == 250)\n\t\t\tbreak;\n\t}\n\n\tfor (int i = 0; i < 500; ++i)\n\t\tfor (int k = i%2; k < 500; k += 2) {\n\t\t\ta[i][k] = (i+1)*s[k/2];\n\t\t}\n\n\tfor (int i = 0; i < 500; ++i)\n\t\tfor (int j = 0; j < 500; ++j) {\n\t\t\tif (a[i][j] > 0)\n\t\t\t\tcontinue;\n\t\t\tll x = 1, g;\n\t\t\tif (i != 0) {\n\t\t\t\tg = gcd(x, a[i-1][j]);\n\t\t\t\tx = x/g*a[i-1][j];\n\t\t\t} if (i != 499) {\n\t\t\t\tg = gcd(x, a[i+1][j]);\n\t\t\t\tx = x/g*a[i+1][j];\n\t\t\t} if (j != 0) {\n\t\t\t\tg = gcd(x, a[i][j-1]);\n\t\t\t\tx = x/g*a[i][j-1];\n\t\t\t} if (j != 499) {\n\t\t\t\tg = gcd(x, a[i][j+1]);\n\t\t\t\tx = x/g*a[i][j+1];\n\t\t\t}\n\t\t\t// assert(x <= 1LL*10*10*10*1000000*1000000);\n\t\t\tll y = t/x;\n\t\t\tll h = y*x+1;\n\t\t\twhile (m[h] == 1)\n\t\t\t\th -= x;\n\t\t\tm[h] = 1;\n\t\t\ta[i][j] = h;\n\t\t}\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\n\tm.clear();\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (m[a[i][j]] == 1) {\n\t\t\t\tcout << a[i][j] << endl;\n\t\t\t\tcout << i << ' ' << j << \" BAD\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tm[a[i][j]] = 1;\n\t\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n-1; ++j) {\n\t\t\tll e = a[i][j], f = a[i][j+1];\n\t\t\tll m1 = max(e, f);\n\t\t\tll m2 = min(e, f);\n\t\t\tif (m1%m2 != 1)\n\t\t\t\tcout << i << ' ' << j << ' ' << a[i][j] << ' ' << a[i][j+1] << endl;\n\t\t\tassert(m1%m2 == 1);\n\t\t}\n\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tll e = a[i][j], f = a[i+1][j];\n\t\t\tll m1 = max(e, f);\n\t\t\tll m2 = min(e, f);\n\t\t\tif (m1%m2 != 1)\n\t\t\t\tcout << i << ' ' << j << ' ' << a[i][j] << ' ' << a[i+1][j] << endl;\n\t\t\tassert(m1%m2 == 1);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat;\nint n,p[10005],vis[10005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint nex(int x){\n\tif (!mat[x])mat[x]=p[p[0]--];\n\treturn mat[x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=p[0]/2;i++)swap(p[i],p[p[0]-i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=nex(i+j);\n\tmat.clear();\n\tfor(int i=n;i;i--)\n\t\tfor(int j=n;j;j--)\n\t\t\tif ((i+j)%2==0)a[i][j]*=nex(i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint N;\nint A[550][550];\nqueue<int> prime;\nunordered_map<int, int> mpA, mpB;\nsigned main() {\n    cin >> N;\n    for (int i = 2; i <= 55000; i++) {\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0)goto nene;\n        }\n        prime.push(i);\nnene:;\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n\n            if (mpA[i + j] == 0) {mpA[i + j] = prime.front(); prime.pop();}\n        }\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n\n            if (mpB[i - j] == 0) {mpB[i - j] = prime.front(); prime.pop();}\n\n            A[i][j] = mpA[i + j] * mpB[i - j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if ((i + j) % 2 == 0) {cout << A[i][j] << \" \"; continue;}\n            int cur = 1;\n            for (int k = 0; k < 4; k++) {\n                cur = cur * A[i + dy[k]][j + dx[k]] / gcd(cur, A[i + dy[k]][j + dx[k]]);\n            }\n            cout << cur + 1 << \" \";\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 5e2 + 10,Lim = 1e4 + 10;\n\nint dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\nint prime[Lim],vis[Lim],cnt = 0;\nll res[N][N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline ll Lcm(ll a,ll b) {\n\treturn a * b / __gcd(a,b);\n}\n\ninline void init(int n) {\n\tFor(i,2,n) {\n\t\tif(!vis[i]) prime[++cnt] = i;\n\t\tfor(int j = 1;j <= cnt && i * prime[j] <= n;j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main() {\n\n\tint n = read();\n\tif(n == 2) { puts(\"4 7\\n23 10\");return 0; }\n\tinit(1e4);\n\tFor(i,1,n) For(j,1,n) if((i + j) % 2 == 0)\n\t\tres[i][j] = prime[(i + j) / 2];\n\tFor(i,1,n) For(j,1,n) if((i + j) % 2 == 0)\n\t\tres[i][j] *= prime[n + (n - i + 1 + j) / 2];\n\tFor(i,1,n) For(j,1,n) if(!res[i][j]) {\n\t\tll Prod = 1;\n\t\tFor(k,0,3) {\n\t\t\tint x = i + dir[k][0],y = j + dir[k][1];\n\t\t\tif(x <= 0 || y <= 0 || x > n || y > n) continue;\n\t\t\tProd = Lcm(Prod,res[i + dir[k][0]][j + dir[k][1]]);\n\t\t}\n\t\tres[i][j] = Prod + 1;\n\t}\n\tFor(i,1,n) For(j,1,n) printf(\"%lld%c\",res[i][j],j == n ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1005;\n\nint bz[10005];\nint n, p[N], p0;\n\nint main() {\n\tfo(i, 2, 1e4) {\n\t\tif(p0 >= 1000) break;\n\t\tif(!bz[i]) p[++ p0] = i;\n\t\tfor(int j = i; j <= 1e4; j += i) bz[j] = 1;\n\t}\n\tp[0] = 1;\n\tscanf(\"%d\", &n);\n\tfo(i, 1, n) {\n\t\tfo(j, 1, n) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\tint x = (i + j) / 2, y = (i - j + n) / 2 + n;\n\t\t\t\tpp(\"%d \", p[x] * p[y]);\n\t\t\t} else {\n\t\t\t\tint x = i + j, y = i - j + n + 2 * n; \n\t\t\t\tpp(\"%lld \", (ll) p[x + 1 >> 1] * p[x - 1 >> 1] * p[y + 1 >> 1] * p[y - 1 >> 1] + 1);\n\t\t\t}\n\t\t}\n\t\thh;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n//ARC055D\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n/*int gcd(int a,int b){\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tint s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\treturn a<<s;\n\t\n}*/\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nconst int B=500;\n\nvi snuke(int n){\n\tconst int Vmax=1000;\n\tvi u(B+1);\n\tvi res{B};\n\tu[B]=1;\n\twhile(int(res.size())<n){\n\t\tint a=res.back();\n\t\tbool z=0;\n\t\tgnr(b,1,B+1)if(!u[b]&&lcm(a,b)<=Vmax){\n\t\t\tres.pb(b);\n\t\t\tu[b]=1;\n\t\t\tz=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(!z){\n\t\t\tcout<<u.size()<<endl;\n\t\t}\n\t\tassert(z);\n\t}\n\treturn res;\n}\n\nbool isprime(int p){\n\tfor(int i=2;i*i<=p;i++)\n\t\tif(p%i==0)return false;\n\treturn true;\n}\n\nvi pris(int n){\n\tvi res;\n\tint cur=B+1;\n\twhile(int(res.size())<n){\n\t\tif(isprime(cur))res.pb(cur);\n\t\tcur++;\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int n;cin>>n;\n\t//cout<<snuke((n+1)/2)<<endl;\n\t//cout<<pris(n/2*2).back()<<endl;\n\t\n\tint n;cin>>n;\n\tvvc<int> a(n,vi(n,-1));\n\tset<int> s;\n\tauto waf=[&](int v,int off){\n\t\tint d=v+off;\n\t\twhile(s.count(d))d+=v;\n\t\ts.insert(d);\n\t\treturn d;\n\t};\n\tvi c=snuke((n+1)/2);\n\tvi ps=pris(n);\n\trep(i,n){\n\t\tfor(int j=(i+1)%2;j<n;j+=2){\n\t\t\ta[i][j]=ps[i]*c[j/2];\n\t\t}\n\t}\n\tint mx=0;\n\trep(i,n)rep(j,n)chmax(mx,a[i][j]);\n\tcerr<<mx<<endl;\n\tusing T=tuple<int,int,int>;\n\tvc<T> z;\n\trep(i,n)rep(j,n){\n\t\tif((i+j)%2==0){\n\t\t\tint w=1;\n\t\t\tconst int dyx[]{-1,0,1,0,-1};\n\t\t\trep(k,4){\n\t\t\t\tint y=i+dyx[k],x=j+dyx[k+1];\n\t\t\t\tif(0<=y&&y<n&&0<=x&&x<n)\n\t\t\t\t\tw=lcm(w,a[y][x]);\n\t\t\t}\n\t\t\tchmax(mx,w);\n\t\t\tz.eb(w,i,j);\n\t\t}\n\t}\n\tcerr<<mx<<endl;\n\tsort(all(z),greater<T>());\n\tfor(auto p:z){\n\t\tint v,i,j;tie(v,i,j)=p;\n\t\tint d=waf(v,0);\n\t\ta[i][j]=d;\n\t\tchmax(mx,d);\n\t}\n\tcerr<<mx<<endl;\n\tassert(mx<=1000000000000000LL);\n\trep(i,n)\n\t\trep(j,n){\n\t\t\tcout<<a[i][j];\n\t\t\tif(j<n-1)cout<<\" \";\n\t\t\telse cout<<endl;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    vi prime;\n    ll Max=1e6;\n    vector<bool> flag(Max,1);\n    rep(i,2,Max){\n        if(flag[i]){\n            prime.pb(i);\n            prime.pb(i*2);\n            for(int j=i;j<Max;j+=i) flag[j]=0;\n        }\n    }\n    ll N; cin>>N;\n    vii ans(N,vi(N));\n    ll cnt=0;\n    rep(i,0,2*N){\n        if(i%2) continue;\n        rep(j,0,N){\n            ll k=i-j;\n            if(0<=k&&k<N) ans[j][k]=prime[cnt++];\n        }\n    }\n    vi P={0,1,0,-1},Q={1,0,-1,0};\n    rep(i,0,N){\n        rep(j,0,N){\n            if((i+j)%2){\n                ll sum=1;\n                rep(k,0,4){\n                    ll X=i+P[k],Y=j+Q[k];\n                    if(0<=X&&X<N&&0<=Y&&Y<N){\n                        ll Z=std::__gcd(ans[X][Y],sum);\n                        sum=sum*ans[X][Y]/Z;\n                    }\n                }\n                ans[i][j]=sum*4;\n            }\n        }\n    }\n    std::set<ll> memo;\n    rep(i,0,N){\n        rep(j,0,N){\n            if(memo.count(ans[i][j])){\n                ans[i][j]*=3;\n            }\n            memo.insert(ans[i][j]);\n        }\n    }\n    rep(i,0,N){\n        rep(j,0,N) cout<<ans[i][j]<<\" \";\n        cout<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\t/*random_shuffle(vec1.begin(), vec1.end());\n\trandom_shuffle(vec2.begin(), vec2.end());*/\n\n\tqueue<pair<ll, ll>> q;\n\tq.push({ 0, 0 });\n\n\tused[0][0] = 1;\n\tvector<pair<ll, ll>> dir1 = { {2, 0}, {0, 2} };\n\twhile (!q.empty()) {\n\t\tpair<ll, ll> v = q.front();\n\t\tq.pop();\n\n\t\tans[v.first][v.second] = vec1.front();\n\t\tvec1.pop_front();\n\n\t\tfor (auto cur : dir1) {\n\t\t\tif (!used[v.first + cur.first][v.second + cur.second] && v.first + cur.first < n && v.second + cur.second < n) {\n\t\t\t\tq.push({v.first + cur.first, v.second + cur.second});\n\t\t\t\tused[v.first + cur.first][v.second + cur.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 2 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = (ml * ans[i][j - 1]) / gcd(ml, ans[i][j - 1]);\n\t\t\t\tif (i < n - 1) ml = (ml * ans[i + 1][j]) / gcd(ml, ans[i + 1][j]);\n\t\t\t\tif (j < n - 1) ml = (ml * ans[i][j + 1]) / gcd(ml, ans[i][j + 1]);\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint v_size = v.size();\n\t\t\tREP(i,v_size){\n\t\t\t\t*this>>v[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\nconst int M = 260;\n\nvector<int> pdiv, primes;\n\n//{{{ eratosthenes\nvoid sieve_of_eratosthenes(int n) {\n\tpdiv.assign(n,0);\n\tfor (int i = 2; i < n; ++i)\n\t\tpdiv[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (pdiv[i]==i)\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tpdiv[j] = i;\n\tfor(int p=2;p<n;p++)if(pdiv[p]==p)primes.push_back(p);\n}\n\nbool is_prime(int n){\n\treturn n!=1 and pdiv[n]==n;\n}\n//}}}\n\nInt N;\n\nInt type0(int i,int j){\n\tint a = (i-j)/2;\n\ta = (a%M+M)%M;\n\treturn primes[a];\n}\n\nInt type1(int i,int j){\n\tint a = (i+j)/2;\n\ta = (a%M+M)%M;\n\treturn primes[a+M];\n}\n\nInt calc(int i,int j){\n\tif((i+j)%2==0){\n\t\treturn type0(i,j)*type1(i,j);\n\t}else{\n\t\treturn type0(i-1,j)*type0(i+1,j)*type1(i-1,j)*type1(i+1,j)+1;\n\t}\n}\n\nvoid solve(){\n\tsieve_of_eratosthenes(5200);\n\tvector<vector<Int> > a(N,vector<Int>(N));\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\ta[i][j] = calc(i,j);\n\t\t}\n\t}\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\tfout<<a[i][j]<<\" \";\n\t\t}\n\t\tfout<<endl;\n\t}\n\treturn;\n}\n\n//{{{ main function\nint main(){\t\n\t\n\tfin >> N;\n\tsolve();\n\treturn 0;\n}\n//}}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nconst Int MAX = 510;\nconst Int MAX_A = 1e15;\nInt A[MAX][MAX];\nvoid check(Int n){\n  set<Int> ss;\n  for(Int i=1;i<=n;i++){\n    for(Int j=1;j<=n;j++){\n      ss.emplace(A[i][j]);\n      assert(1<=A[i][j]);\n      \n      //if(!(A[i][j]<=MAX_A)) cout<<A[i][j]<<endl;\n      assert(A[i][j]<=MAX_A);\n      if(i>1) assert(max(A[i][j],A[i-1][j])%min(A[i][j],A[i-1][j])==1);\n      if(j>1) assert(max(A[i][j],A[i][j-1])%min(A[i][j],A[i][j-1])==1);\n    }\n  }\n  assert((Int)ss.size()==n*n);\n}\n\nInt lcm(Int a,Int b){\n  return a/__gcd(a,b)*b;\n}\n\nconst Int MAX_N=1e5;\nInt th[MAX_N];\n\nsigned main(){\n  Int n;\n  cin>>n;\n\n  for(Int i=0;i<MAX;i++)\n    for(Int j=0;j<MAX;j++)\n      A[i][j]=1;\n\n  memset(th,0,sizeof(th));\n  for(Int i=2;i<MAX_N;i++)\n    if(!th[i]) for(Int j=i+i;j<MAX_N;j+=i) th[j]=1;\n  \n  vector<Int> vs;\n  for(Int i=3;i<MAX_N;i++)\n    if(!th[i]) vs.emplace_back(i);\n  \n  Int cnt=0;\n  auto nxt=[&](){return vs[cnt++];};\n  \n  for(Int i=2;i<=n;i+=2){\n    Int k=nxt();\n    for(Int j=0;i+j<=n;j++) A[i+j][j+1]*=k;\n    k=nxt();\n    for(Int j=0;i+j<=n;j++) A[j+1][i+j]*=k;\n  }\n  \n  for(Int i=2;i<=n;i+=2){\n    Int k=nxt();\n    for(Int j=0;(~n&1)+i+j<=n;j++) A[(~n&1)+i+j][n-j]*=k;\n    k=nxt();\n    for(Int j=0;i-j>=1;j++) A[j+1][i-j]*=k;\n  }\n  \n  Int di[]={0,0,1,-1};\n  Int dj[]={1,-1,0,0};\n  \n  for(Int i=1;i<=n;i++){\n    for(Int j=1;j<=n;j++){\n      if((i+j)&1) continue;\n      for(Int k=0;k<4;k++)\n\tA[i][j]=lcm(A[i][j],A[i+di[k]][j+dj[k]]);\n      A[i][j]++;\n    }\n  }\n  \n  \n  cout<<n<<endl;\n  for(Int i=1;i<=n;i++){\n    for(Int j=1;j<=n;j++){\n      if(j>1) cout<<\" \";\n      cout<<A[i][j];\n    }\n    cout<<endl;\n  }\n  \n  check(n);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int P = 9000, Q = P + 7, N = 2000 + 7;\n\nint n, k;\nint isp[Q], pri[Q];\nint a[N], b[N];\ni64 v[N][N];\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 2; i <= P; ++i) {\n\t\tif (!isp[i]) pri[++k] = i;\n\t\tfor (int j = 1; j <= k & i * pri[j] <= P; ++j) {\n\t\t\tisp[i * pri[j]] = 1;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n\tint l = 1, r = n * 2 + 10, z = 1;\n\tfor (int i = -n; i <= n; ++i)\n\t\tif (i % 2 == 0) a[i + n] = z ? pri[l++] : pri[r--], z ^= 1;\n\tfor (int i = 2; i <= n * 2; ++i)\n\t\tif (i % 2 == 0) b[i] = z ? pri[l++] : pri[r--], z ^= 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i + j) % 2 == 0) v[i][j] = a[i - j + n] * b[i + j];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i + j) % 2 == 1)\n\t\t\t\tv[i][j] = 1ll * a[i - j - 1 + n] * a[i - j + 1 + n] * b[i + j - 1] * b[i + j + 1] + 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld \", v[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pir pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define pb push_back\nusing namespace std;\n\nconst int N=510,M=100010;\nint n,prime[M],cnt;\nll res[N][N];\nbool vis[M];\nvector<pir> v;\n\nvoid pre(int m) {\n    for(int i=2;i<=m;i++) {\n        if(!vis[i]) prime[++cnt]=i;\n        for(int j=1;j<=cnt;j++) {\n            int tmp=prime[j]*i;\n            if(tmp>m) break;\n            vis[tmp]=1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nbool cmp1(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi+a.se<b.fi+b.se;\n    return a<b;\n}\n\nbool cmp2(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi-a.se<b.fi-b.se;\n    return a<b;\n}\n\nll lcm(ll a,ll b) {\n    return a/__gcd(a,b)*b;\n}\n\nint main() {\n    pre(100000);\n    scanf(\"%d\",&n);\n    if(n==2) return printf(\"2 3\\n5 4\\n\"),0;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2==0) v.pb({i,j});\n            res[i][j]=1;\n        }\n    }\n    sort(v.begin(),v.end(),cmp1);\n    pir pre={0,0};\n    int* ptr=prime;\n    for(auto p:v) {\n        if(p.fi+p.se!=pre.fi+pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    sort(v.begin(),v.end(),cmp2);\n    pre={0,0};\n    for(auto p:v) {\n        if(p.fi-p.se!=pre.fi-pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                if(i>1) res[i][j]=lcm(res[i][j],res[i-1][j]);\n                if(j>1) res[i][j]=lcm(res[i][j],res[i][j-1]);\n                if(i<n) res[i][j]=lcm(res[i][j],res[i+1][j]);\n                if(j<n) res[i][j]=lcm(res[i][j],res[i][j+1]);\n            }\n            printf(\"%lld \",res[i][j]);\n        }\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc(int x){\n\tint c=0;\n\tfor(int i=2;i<=x;++i)if(x%i==0)for(++c;x%i==0;x/=i);\n\treturn c;\n}\nconst int N=505;\ntypedef long long ll;\nint a[N*2],aa[N*2],xb,i,j,n;ll b[N][N];\ninline ll lcm(ll a,ll b){\n\treturn a/std::__gcd(a,b)*b;\n}\ninline void spj(){\n\tunordered_set<ll>s;\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)s.insert(b[i][j]),\n\t\tassert(b[i][j]<=1e15);\n\tassert(s.size()==n*n);\n\tfor(i=1;i<=n;++i)for(j=1;j<n;++j)assert(max(b[i][j],b[i][j+1])%min(b[i][j],b[i][j+1])==1); \n\tfor(i=1;i<n;++i)for(j=1;j<=n;++j)assert(max(b[i+1][j],b[i][j])%min(b[i+1][j],b[i][j])==1); \n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tint l=0,r=n*2+1;\n\tfor(i=2;xb<n*2;++i)if(calc(i)<2)a[++xb]=i;\n\t\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j){\n\t\tint x=i+j,y=i-j+n;\n\t\tif(x&1)b[i][j]=a[x/2]*a[n+(y+1)/2];\n\t\tif(x%2==1 && abs(i-2)+abs(j-222)==1){\n\t\t\t++i,--i;\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)if((i+j)%2==0){\n\t\tll ans=1;\n\t\tif(i>1)ans=lcm(ans,b[i-1][j]);\n\t\tif(i<n)ans=lcm(ans,b[i+1][j]);\n\t\tif(j>1)ans=lcm(ans,b[i][j-1]);\n\t\tif(j<n)ans=lcm(ans,b[i][j+1]);\n\t\tif(ans>1ll*a[n*2]*a[n*2-1]*a[n]*a[n-1]) {\n\t\t\t++i,--i;\n\t\t}\n\t\tb[i][j]=ans+1;\n\t}\n\tspj();\n\tfor(i=1;i<=n;++i,puts(\"\"))for(j=1;j<=n;++j)printf(\"%lld \",b[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef unsigned long long ll;\nusing namespace std;\nconst int MN=80000;\nint n,pri[10001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+(abs(i-j)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tprintf(\"%llu \",a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 203050\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],n,b[505][505],mx,c,o,r;\nint p[maxn];\nvector<ll> h[maxn];\nbool vis[maxn];\nll lcm(ll x,ll y){\n    return x/__gcd(x,y)*y;\n}\nmap<ll,int> f;\n\nint main(){\n    cin >> n;\n    //for (int i=0;i<n*n/2;i++) a[c++]=i+1;\n    //for (int i=0;i<c;i++)cout<<a[i]<<' ';cout<<endl;\n    //random_shuffle(a,a+c);\n    o=1;\n    for (int i=1;i<=n;i+=4)\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n            o+=2;\n        }\n    int pos=3; while (pos+4<=n) pos+=4;\n    for (int i=pos;i>0;i-=4){\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o; o+=2;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n        }\n    }\n\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) if ((i+j)%2==1){\n            r=1;\n            if (i>1) r=lcm(r,b[i-1][j]);\n            if (i<n) r=lcm(r,b[i+1][j]);\n            if (j>1) r=lcm(r,b[i][j-1]);\n            if (j<n) r=lcm(r,b[i][j+1]);\n            long long s=1;\n            while (f[r*s]) s++;\n            b[i][j]=r*s+1; f[r*s]=1;\n        }\n\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)cout<<b[i][j]<<' ';cout<<endl;\n    }\n\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) mx=max(mx,b[i][j]);\n    //cout<<mx<<endl;\n\n    //cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 2e4 + 5;\nint sito[N];\nint nww(int a, int b) {\n  if (a == 0) { return b; }\n  if (b == 0) { return a; }\n  int g = __gcd(a, b);\n  return a / g * b;\n}\nint Good(int a, int b) {\n  if (a > b) { swap(a, b); }\n  return (b % a == 1);\n}\nint a[505][505];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n\n  int n;\n  cin>>n;\n  vector<int> lp;\n  for (int i = 2; i < N; i++) {\n    if (sito[i] == 0) {\n      lp.PB(i);\n      for (int j = 1; i * j < N; j++) {\n        sito[i * j] = 1;\n      }\n    }\n  }\n  debug(SZ(lp));\n  debug(lp[499]);\n  RE (i, n) {\n    RE (j, n) {\n      if (i % 2 == j % 2) {\n        a[i][j] = lp[(i - j) / 2 + 750] * lp[(i + j) / 2];\n      }\n    }\n  }\n  RE (i, n) {\n    RE (j, n) {\n      if (i % 2 != j % 2) {\n        a[i][j] = nww(a[i + 1][j], nww(a[i - 1][j], nww(a[i][j + 1], a[i][j - 1]))) + 1;\n      }\n      cout<<a[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  set<int> lols;\n  int ma = 0;\n  RE (i, n) {\n    RE (j, n) {\n      lols.insert(a[i][j]);\n      assert(a[i][j] <= 1e15);\n      maxi(ma, a[i][j]);\n    }\n  }\n  debug(ma);\n  debug(n * n, SZ(lols));\n  assert(SZ(lols) == n * n);\n  RE (i, n) {\n    RE (j, n - 1) {\n      assert(Good(a[i][j], a[i][j + 1]));\n    }\n  }\n  RE (i, n - 1) {\n    RE (j, n) {\n      assert(Good(a[i][j], a[i + 1][j]));\n    }\n  }\n//   RE (i, n) {\n//     RE (j, m) {\n//       if (i % 2 == j % 2) {\n//         a[i][j] = \n//     }\n//   }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cassert>\nusing namespace std;\nlong long gcd(long long a,long long b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint n;\nmap<long long,bool>mp;\nlong long a[510][510];\nbool used[250050];\nint p[250050],cnt;\nlong long calc(int i,int j)\n{\n\tlong long res=1,s;\n\tif(i>1)res=res*a[i-1][j]/gcd(res,a[i-1][j]);\n\tif(i<500)res=res*a[i+1][j]/gcd(res,a[i+1][j]);\n\tif(j>1)res=res*a[i][j-1]/gcd(res,a[i][j-1]);\n\tif(j<500)res=res*a[i][j+1]/gcd(res,a[i][j+1]);\n\ts=res;\n\twhile(mp[s+1])s+=res;\n\tmp[s+1]=1;\n\tif(s+1>1e15)assert(0);\n\treturn s+1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=62500;++i)\n\t{\n\t\tp[++cnt]=2*i+1;\n\t\tp[++cnt]=4*i+2;\n\t\tmp[2*i+1]=1,mp[4*i+2]=1;\n\t}\n\tint st=1,ed=125000;\n\tfor(int i=1;i<=499;i+=2)\n\t\tfor(int j=1;j<=499;j+=2)\n\t\t{\n\t\t\tif((i+j)&3)a[i][j+1]=p[st++],a[i+1][j]=p[st++];\n\t\t\telse a[i][j+1]=p[ed--],a[i+1][j]=p[ed--];\n\t\t}\n\tfor(int i=1;i<=500;++i)\n\t\tfor(int j=2-(i&1);j<=500;j+=2)a[i][j]=calc(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (250010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint p[N],cnt,n;\nLL a[511][511]; bool isp[N*40];\nint eular(int n){\n\tfor(int i=2;i<=n;i++){\n\t\tif(!isp[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tif(cnt==125000)return i;\n\t\t}\n\t\tfor(int j=1;j<=cnt;j++){\n\t\t\tint t=p[j]*i; if(t>n)break;\n\t\t\tisp[t]=1; if(i%p[j]==0)break;\n\t\t}\n\t}\n}\nLL gcd(LL a,LL b){\n\treturn b?gcd(b,a%b):a;\n}\nLL lcm(LL x,LL y){\n\tif(x==0||y==0)return x+y;\n\treturn x/gcd(x,y)*y;\n}\nint main(){\n\teular(2000000); read(n);\n\tif(n==2){\n\t\tputs(\"2 3\\n5 16\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(((i+j)&1)==0)a[i][j]=1ll*p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n//\tputs(\"12345\"); \n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(!a[i][j])a[i][j]=lcm(lcm(a[i][j+1],a[i+1][j]),lcm(a[i][j-1],a[i-1][j]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\tprint(a[i][j]),spa; ent;\n\t}\n\treturn flush(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\ntypedef  long long ll;\nll gcd(ll f , ll s){if(s==0)return f;else return gcd(s,f%s);}\nint const N = 1000006;\nll const M = 998244353;\nlong double const ep = .000000000000000001;\nint p[N];\nqueue<int>q;\nll Farray[1032][1032] , Sarray[1032][1023] , arr[1002][1003];\nint main() {\n\t\n\tint n;cin >> n;\n\tif(n==2){\n\t\tcout << 4 << \" \" << 7 << endl << 23 << \" \" << 10 ;\n\t\treturn 0;\n\t}\n\tfor(int i = 2 ; i <= 1000 ; i++){\n\t\tif(!p[i]){\n\t\t\tfor(int x = i + i; x <= 100000 ; x+=i)p[x] = 1;\n\t\t}\n\t}\t\n\tfor(int i = 2 ; i <= 100000 ; i++)if(!p[i])q.push(i);\n\tpair<int,int>start = mp(0,0);\n\tfor(pair<int,int> i = start ; i.first < n ; i.first += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second < n ; x.first++ , x.second++){\n\t\t\tFarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\tfor(pair<int,int> i = mp(0,2) ; i.second < n ; i.second += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second < n ; x.first++ , x.second++){\n\t\t\tFarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\t\n\tfor(pair<int,int> i = start ; i.second < n ; i.second += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second >= 0 ; x.first++ , x.second--){\n\t\t\tSarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\n\tfor(pair<int,int> i = mp(1+(n%2),n-1) ; i.first < n ; i.first += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second >= 0 ; x.first++ , x.second--){\n\t\t\tSarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\n\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int x = 0 ; x < n ; x++)\n\t\t\tarr[i][x] = Farray[i][x] * Sarray[i][x];\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 1){\n\t\t\t\tset<ll>s;\n\t\t\t\tif(i != 0){\n\t\t\t\t\ts.insert(Farray[i-1][j]);\n\t\t\t\t\ts.insert(Sarray[i-1][j]);\n\t\t\t\t}\n\t\t\t\tif(i != n-1){\n\t\t\t\t\ts.insert(Farray[i+1][j]);\n\t\t\t\t\ts.insert(Sarray[i+1][j]);\n\t\t\t\t}\n\t\t\t\tif(j != 0){\n\t\t\t\t\ts.insert(Farray[i][j-1]);\n\t\t\t\t\ts.insert(Sarray[i][j-1]);\n\t\t\t\t}\n\t\t\t\tif(j != n-1){\n\t\t\t\t\ts.insert(Farray[i][j+1]);\n\t\t\t\t\ts.insert(Sarray[i][j+1]);\n\t\t\t\t}\n\t\t\t\tarr[i][j] = 1;\n\t\t\t\tset<ll>::iterator it = s.begin();\n\t\t\t\tfor(;it!=s.end() ; it++)arr[i][j]*= *(it);\n\t\t\t\tarr[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tcout << arr[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 503;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[750+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X((i+j)/2)*Y((i-j)/2);\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2)+1;\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 500;\nconst int MAX2 = 10000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 4 << \" \" << 7 << endl << 23 << \" \" << 10; // サンプルケースですね\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX2];\n\tfor (int i = 0;i < MAX2;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX2 - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tstatic int64_t a[MAX][MAX];\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\ta[i][j] = prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積\n\t\t\t\tif (i == 0 && j == N - 1) a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t\telse if (i == N - 1 && j == 0) a[i][j] = (int64_t)prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t\telse a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0;i < N;++ i) { // 要らないけど、整合性チェック\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tint d[] = {0, 1, 0, -1, 0};\n\t\t\tint check[] = {-1, -1, -1, -1};\n\t\t\tfor (int k = 0;k < 4;++ k) {\n\t\t\t\tif (i + d[k] >= 0 && i + d[k] < N && j + d[k + 1] >= 0 && j + d[k + 1] < N) {\n\t\t\t\t\tcheck[k] = max(a[i][j], a[i + d[k]][j + d[k + 1]]) % min(a[i][j], a[i + d[k]][j + d[k + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(check, check+4);\n\t\t\tfor (int i = 0;i < 3;i ++) {\n\t\t\t\tif (check[i] >= 0 && check[i] != check[i + 1]) {\n\t\t\t\t\tcerr << \"err\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i][j] >= 1000000000000000) cerr << \"err\" << endl;\n\t\t}\n\t}\n\t\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは0だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ll MOD = 1e9 + 7, INF = 1e18 + 1;\n \nusing namespace std;\n\nll er[1000001], p[1000000], ptr, n, d[1000][1000];\n\nll gcd (ll a, ll b)\n{\n\tif (!b) return a;\n\telse return gcd (b, a % b);\n}\n\nint main ()\n{\n\tfor (ll i = 2; i <= 1000000; i++)\n\t\tif (!er[i])\n\t\t{\n\t\t\tp[ptr++] = i;\n\t\t\tfor (ll j = i * i; j <= 1000000; j += i)\n\t\t\t\ter[j] = 1;\n\t\t}\n\n\tcin >> n;\n\n\tfor (int i = 0; i < 2 * n; i += 2)\n\t\tfor (int j = 0; i + j < 2 * n; j++)\n\t\t\td[j][i + j] = p[i / 2];\n\n\n\tfor (int i = 2; i < 2 * n; i += 2)\n\t\tfor (int j = 0; i + j < 2 * n; j++)\n\t\t\td[i + j][j] = p[i / 2 + (n + 1) / 2 - 1];\n\n\n\tfor (int i = 0; i < 2 * n; i += 2)\n\t\tfor (int j = 0; i >= j; j++)\n\t\t\td[i - j][j] *= p[i / 2 + n];\n\n\tll mx = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (!d[i][j])\n\t\t\t{\n\t\t\t\tll lcm = 1;\n\t\t\t\tif (j) lcm = lcm / gcd (lcm, d[i][j-1]) * d[i][j-1];\n\t\t\t\tif (j < n - 1) lcm = lcm / gcd (lcm, d[i][j+1]) * d[i][j+1];\n\t\t\t\tif (i) lcm = lcm / gcd (lcm, d[i-1][j]) * d[i-1][j];\n\t\t\t\tif (i < n - 1) lcm = lcm / gcd (lcm, d[i+1][j]) * d[i+1][j];\n\n\t\t\t\td[i][j] = lcm + 1;\n\t\t\t}\n\n\t\t\tprintf (\"%lld \", d[i][j]);\n\t\t}\n\t\tputchar ('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int) (x).size()\n\nconst int maxn = 505;\nll a[maxn][maxn];\nint n;\n\nconst int maxm = 1e4 + 5;\nbool vis[maxm];\n\nmap<int, int> zhu, fu;\n\nll gcd(ll x, ll y){\n    return y == 0 ? x : gcd(y, x % y);\n}\n\nll lcm(ll x, ll y){\n    return x / gcd(x, y) * y;\n}\n\nvoid solve(){\n    memset(vis, 0, sizeof(vis));\n    vector<int> prime;\n    vis[1] = 1;\n    for(int i = 2;i < maxm;i++){\n        if(!vis[i]){\n            prime.push_back(i);\n            for(int j = 2 * i;j < maxm;j += i){\n                vis[j] = 1;\n            }\n        }\n    }\n    int front = 0, rear = n - 1;\n    for(int i = 2;i <= 2 * n;i += 2){\n        int k = i / 2;\n        if(k & 1){\n            zhu[i] = prime[front++];\n        }else{\n            zhu[i] = prime[rear--];\n        }\n    }\n    int k;\n    if(n & 1)\n        k = n;\n    else\n        k = n - 1;\n    front = n, rear = n + k - 1;\n    for(int i = 1 - k, odd = 1;i <= k - 1;i += 2, odd++){\n        if(odd & 1){\n            fu[i] = prime[front++];\n        }else{\n            fu[i] = prime[rear--];\n        }\n    }\n    for(int i = 1;i <= n;i++){\n        int st;\n        if(i & 1){\n            st = 1;\n        }else{\n            st = 2;\n        }\n        for(int j = st;j <= n;j += 2){\n            int id1 = zhu[i + j];\n            int id2 = fu[i - j]; \n            a[i][j] = 1LL * id1 * id2;\n        }\n    }\n    for(int i = 1;i <= n;i++){\n        int st;\n        if(i & 1){\n            st = 2;\n        }else{\n            st = 1;\n        }\n        for(int j = st;j <= n;j += 2){\n            a[i][j] = 1;\n            if(j > 1){\n                a[i][j] = lcm(a[i][j], a[i][j - 1]);\n            }\n            if(j < n){\n                a[i][j] = lcm(a[i][j], a[i][j + 1]);\n            }\n            if(i > 1){\n                a[i][j] = lcm(a[i][j], a[i - 1][j]);\n            }\n            if(i < n){\n                a[i][j] = lcm(a[i][j], a[i + 1][j]);\n            }\n            a[i][j]++;\n        }\n    }\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            cout << a[i][j] << ((j == n) ? '\\n' : ' ');\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    if(n == 2){\n        cout << 4 << \" \" << 7 << endl;\n        cout << 23 << \" \" << 10 << endl;\n        return 0;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n;\nll ans[N][N];\nset<ll> used;\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tint num = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1))\n\t\t\t\tans[i][j] = ++num, used.insert(num);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tll now = 1;\n\t\t\t\twhile (used.count(now))\n\t\t\t\t\tnow += tmp;\n\t\t\t\tused.insert(now);\n\t\t\t\tans[i][j] = now;\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < (int)(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nint lcm(int a, int b) {\n    return a / __gcd(a, b) * b;\n}\n\nint lcm(vi vec) {\n    if (vec.empty())\n        return 1;\n    int ret = vec[0];\n    for (int i = 1; i < SZ(vec); ++i)\n        ret = lcm(ret, vec[i]);\n    return ret;\n}\n\nvi di = {0, 0, -1, 1};\nvi dj = {-1, 1, 0, 0};\n\nvoid smain() {\n    int n;\n    cin >> n;\n    vvl a(n, vl(n, 0));\n    int cur = 1;\n    fori (i, n) {\n        fori (j, n) {\n            if ((i ^ j) & 1) {\n                a[i][j] = cur++;\n            }\n        }\n    }\n\n    fori (i, n) {\n        fori (j, n) if (a[i][j] == 0) {\n            vi vec;\n\n            fori (dir, SZ(di)) {\n                int ii = i + di[dir];\n                int jj = j + dj[dir];\n                if (ii >= 0 && ii < n && jj >= 0 && jj < n) {\n                    vec.push_back(a[ii][jj] + 1);\n                }\n            }\n            a[i][j] = lcm(vec);\n        }\n    }\n\n    fori (i, n) {\n        fori (j, n) {\n            cerr << a[i][j] * 2 + 2 << ' ';\n        }\n        cerr << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = 1ll * pri[min(min(n - i + 1, n - j + 1), min(i, j))] * i;\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = min(min(n - i + 1, n - j + 1), min(i, j));\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#include <cassert>\n#define SIZE 505\n#define MX 100005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll A[SIZE][SIZE];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nbool pr[MX];\nvector <int> all;\n\nvoid make()\n{\n\tfor(int i=2;i<MX;i++)\n\t{\n\t\tif(!pr[i])\n\t\t{\n\t\t\tall.push_back(i);\n\t\t\tfor(int j=2*i;j<MX;j+=i)\n\t\t\t{\n\t\t\t\tpr[j]=true;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tmake();\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tA[i][j]=1;\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int t=0;t<n;t++)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(abs(i+j-2*t)<=1)\n\t\t\t\t{\n\t\t\t\t\tA[i][j]*=all[sz];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsz++;\n\t}\n\tint L=0,R=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)%2==0)\n\t\t\t{\n\t\t\t\tL=min(L,(i-j)/2);\n\t\t\t\tR=max(R,(i-j)/2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int t=L;t<=R;t++)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(abs((i-j)-2*t)<=1)\n\t\t\t\t{\n\t\t\t\t\tA[i][j]*=all[sz];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsz++;\n\t}\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(j!=0) printf(\" \");\n\t\t\tprintf(\"%lld\",A[i][j]);\n\t\t\tassert(A[i][j]<=1000000000000000LL);\n\t\t}puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 100005;\n\nint di[] = { -1, 0, 0, 1 };\nint dj[] = { 0, -1, 1, 0 };\n\nint n;\nbool p[100005];\nvi primes;\n\nvoid sieve() {\n\tMMS(p, 1);\n\tp[0] = p[1] = 0;\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i]) {\n\t\t\tfor (int j = 2 * i; j < N; j += i)\n\t\t\t\tp[j] = 0;\n\t\t}\n\t}\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i])\n\t\t\tprimes.pb(i);\n\t}\n}\n\nll a[501][501];\n\nll setV(int i, int j) {\n\tint d0 = (i + j) >> 1;\n\tint d1 = n + ((i - j + n - 1) >> 1);\n\treturn primes[d0] * 1LL * primes[d1];\n}\n\nll get(int i, int j) {\n\tif (i < 0 || i >= n || j < 0 || j >= n)\n\t\treturn 1;\n\treturn a[i][j];\n}\n\nll calc(int i, int j) {\n\tll res = 1;\n\tfor (int d = 0; d < 4; d++) {\n\t\tint ni = i + di[d];\n\t\tint nj = j + dj[d];\n\t\tll v = get(ni, nj);\n\t\tres = (res * v) / __gcd(res, v);\n\t}\n\treturn res + 1;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tsieve();\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1) == 0) {\n\t\t\t\ta[i][j] = setV(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1)) {\n\t\t\t\ta[i][j] = calc(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\ta[1][0] *= 2;\n\t\ta[1][0]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j == n - 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#undef NDEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\nusing ld = long double;\n\nvoid solve(bool);\n\n//#define YA\n\nint main() {\n#ifdef YA\n    auto s = clock();\n    assert(freopen(\"input.txt\", \"r\", stdin));\n#else\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    cout << fixed << setprecision(20);\n\n    solve(true);\n\n#ifdef YA1\n    while (true) solve(false);\n#endif\n\n#ifdef YA\n    cerr << endl << endl << \"time = \" << (clock() - s) / (double)CLOCKS_PER_SEC << endl;\n#endif\n\n    return 0;\n}\n\nconst int MX = (int)1e7;\n\nint p[MX + 5];\nvector <li> pr;\nint cnt = 10;\nint last = 0;\nli a[555][555];\n\nvoid solve(bool __attribute__((unused)) read) {\n    for (int i = 2; i <= MX; ++i) {\n        if (p[i])\n            continue;\n        if (i != 2)\n            pr.push_back(i);\n        for (li j = (li)i * i; j <= MX; j += i)\n            p[j] = 1;\n    }\n    int n;\n    cin >> n;\n    int u = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 0) {\n                if (last == cnt) {\n                    ++u;\n                    last = 0;\n                }\n                a[i][j] = (1ll << last) * pr[u];\n                ++last;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                vector <li> vc;\n                li z = 1;\n                for (int x = -1; x <= 1; ++x) {\n                    for (int y = -1; y <= 1; ++y) {\n                        if (abs(x) + abs(y) != 1 || i + x < 0 || i + x >= n || j + y < 0 || j + y >= n)\n                            continue;\n                        vc.push_back(a[i + x][j + y]);\n                        z = z * a[i + x][j + y] / __gcd(z, a[i + x][j + y]);\n                    }\n                }\n                a[i][j] = z;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=505;\nint n;\nvector <int> vp;\nLL g[N][N];\nLL gcd(LL x,LL y){\n\treturn y?gcd(y,x%y):x;\n}\nLL lcm(LL x,LL y){\n\tif (!x||!y)\n\t\treturn x+y;\n\treturn x/gcd(x,y)*y;\n}\nint check(int n){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nmap <int,int> mp1,mp2;\nint g1(int x){\n\tif (!mp1[x])\n\t\tmp1[x]=vp.back(),vp.pop_back();\n\treturn mp1[x];\n}\nint g2(int x){\n\tif (!mp2[x])\n\t\tmp2[x]=vp.back(),vp.pop_back();\n\treturn mp2[x];\n}\nint main(){\n\tn=read();\n\tif (n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;vp.size()<n*2;i++)\n\t\tif (check(i))\n\t\t\tvp.push_back(i);\n\treverse(vp.begin(),vp.end());\n\tmp1.clear(),mp2.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]=g1(i+j)*g2(i-j);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1)\n\t\t\t\tg[i][j]=lcm(g[i-1][j],lcm(g[i+1][j],lcm(g[i][j-1],g[i][j+1])))+1;\n\tfor (int i=1;i<=n;i++,puts(\"\"))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",g[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll __int128\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=500+10,MAXM=1000000+10;\nint n,vis[MAXM],prime[MAXM],cnt,p;\nll G[MAXN][MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void init()\n{\n\tmemset(vis,1,sizeof(vis));\n\tvis[0]=vis[1]=0;\n\tREP(i,2,MAXM-1)\n\t{\n\t\tif(vis[i])prime[++cnt]=i;\n\t\tfor(register int j=1;j<=cnt&&i*prime[j]<MAXM;++j)\n\t\t{\n\t\t\tvis[i*prime[j]]=0;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\ninline bool check(int x,int y)\n{\n\tif(G[x][y]%G[x-1][y]!=1)return false;\n\tif(G[x][y]%G[x+1][y]!=1)return false;\n\tif(G[x][y]%G[x][y-1]!=1)return false;\n\tif(G[x][y]%G[x][y+1]!=1)return false;\n\treturn true;\n}\nint main()\n{\n\tread(n);init();int x,y;\n\tREP(i,0,n+1)REP(j,0,n+1)G[i][j]=1;\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y>=0)G[x][y]*=prime[p],x++,y--;\n\t}\n\tREP(i,n+1,0)if(i%2==0)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y<=n+1)G[x][y]*=prime[p],x--,y++;\n\t}\n\tREP(i,0,n+1)if(i%2==0)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y>=0)G[x][y]*=prime[p],x--,y--;\n\t}\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y<=n+1)G[x][y]*=prime[p],x++,y++;\n\t}\n\tREP(i,1,n)REP(j,1,n)if((i+j)%2==0)\n\t{\n\t\tG[i][j]=G[i-1][j]*G[i+1][j]+1,assert(check(i,j));\n\t}\n\tREP(i,1,n)\n\t{\n\t\tREP(j,1,n)assert(G[i][j]<=1e15),write(G[i][j],' ');puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\nusing namespace std;\n\n#define NMAX 502\n#define DIM 7920\n\nint d[DIM], p[DIM];\nlong long sol[NMAX][NMAX];\n\nvoid ciur(int n) {\n    for (int i = 2; i <= n; i++) {\n        if (d[i] == 0) {\n            p[++p[0]] = i;\n            for (int j = i + i; j <= n; j += i) {\n                d[j] = 1;\n            }\n        }\n    }\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nlong long lcm(vector <long long>& v) {\n    long long l = 1;\n    for (const long long x : v) {\n        if (x == 0)\n            continue;\n        long long d = gcd(l, x);\n        l = l * x / d;\n\n    }\n    return l;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << \"4 7\\n23 10\\n\";\n        return 0;\n    }\n    ciur(DIM - 1);\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            sol[i][j] = 1;\n        }\n    }\n\n    int cnt = 1;\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col > n)\n                break;\n            sol[i][col] *= p[cnt];\n            col++;\n        }\n        cnt++;\n    }\n\n    for (int i = 3; i <= n; i += 2) {\n        int lin = i;\n        for (int j = 1; j <= n; j++) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col <= 0)\n                break;\n            sol[i][col] *= p[cnt];\n            col--;\n        }\n        cnt++;\n    }\n\n    for (int i = n; i > 1; i -= 2) {\n        int lin = i;\n        for (int j = n; j >= 1; j--) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) % 2 == 0)\n                continue;\n            vector <long long> v = {sol[i - 1][j], sol[i + 1][j], sol[i][j - 1], sol[i][j + 1]};\n            sol[i][j] = lcm(v);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << sol[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n \nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/__gcd(a,b);\n}\n \nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif (ans[i][j]==0)\n\t\t\t{\n\t\t\t\tlong long op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= 100000; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x / gcd(x, y) * y); }\n//这个地方需要先除 gcd，在乘 y，否则 x * y会爆 long long \nint PA[N], PB[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tSieve();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tPA[i] = pri[i];\n\t\tPB[i] = pri[i + n];\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = 1ll * PA[(i + j) / 2] * PB[(i - j) / 2 + (n + 1) / 2];\n\t\t\t\tans[i][j] = tmp;\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nstruct XorShift{\n    constexpr XorShift(){}\n    constexpr uint_fast64_t next(size_t value) const {\n        value ^= value << 7;\n        return value ^ value >> 9;\n    }\n};\n\nconstexpr XorShift rdn = XorShift();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    size_t v[1000];\n    constexpr Ans() : ans(), v(){\n        for(size_t i = 0; i < 1000; ++i)v[i] = i;\n        for(size_t i = 999, j = 259, t = 0; i > 0; --i){\n            j = rdn.next(j) % i;\n            t = v[j];\n            v[j] = v[i];\n            v[i] = t;\n        }\n        for(int i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(int i = 1; i <= 500; i += 2)\n            for(int j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v[(i + j) / 2]] * p[v[(1500 + i - j) / 2]];\n                ans[i + 1][j + 1] = p[v[(i + j + 2) / 2]] * p[v[(1500 + i - j) / 2]];\n            }\n        for(int i = 1; i <= 500; i += 2)\n            for(int j = 1; j <= 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i][j];\n    }\n};\n\nconstexpr Ans a = Ans();\nint_fast64_t N;\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N; ++j)printf(\"%lld \", a.at(i + 1, j + 1));\n        puts(\"\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pir pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define pb push_back\nusing namespace std;\n\nconst int N=510,M=10010;\nint n,prime[M],cnt;\nll res[N][N];\nbool vis[M];\nvector<pir> v;\n\nvoid pre(int m) {\n    for(int i=2;i<=m;i++) {\n        if(!vis[i]) prime[++cnt]=i;\n        for(int j=1;j<=cnt;j++) {\n            int tmp=prime[j]*i;\n            if(tmp>m) break;\n            vis[tmp]=1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nbool cmp1(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi+a.se<b.fi+b.se;\n    return a<b;\n}\n\nbool cmp2(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi-a.se<b.fi-b.se;\n    return a<b;\n}\n\nll lcm(ll a,ll b) {\n    return a/__gcd(a,b)*b;\n}\n\nint main() {\n    pre(10000);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2==0) v.pb({i,j});\n            res[i][j]=1;\n        }\n    }\n    sort(v.begin(),v.end(),cmp1);\n    pir pre={0,0};\n    int* ptr=prime;\n    for(auto p:v) {\n        if(p.fi+p.se!=pre.fi+pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    sort(v.begin(),v.end(),cmp2);\n    pre={0,0};\n    for(auto p:v) {\n        if(p.fi-p.se!=pre.fi-pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                if(i>1) res[i][j]=lcm(res[i][j],res[i-1][j]);\n                if(j>1) res[i][j]=lcm(res[i][j],res[i][j-1]);\n                if(i<n) res[i][j]=lcm(res[i][j],res[i+1][j]);\n                if(j<n) res[i][j]=lcm(res[i][j],res[i][j+1]);\n            }\n            printf(\"%lld \",res[i][j]);\n        }\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(MAX_N);\n    for (int i = 0; i < MAX_N; i++) {\n        ans[i].resize(MAX_N);\n    }\n\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = (i % 2); j < MAX_N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + MAX_N) / 2;\n            ans[i][j] =\n                primes[(p % 2 == 0) ? (p / 2) : (MAX_N - 1 - p / 2)] *\n                primes[(q % 2 == 0) ? (q / 2) : (MAX_N - 1 - q / 2) + MAX_N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = 1 - (i % 2); j < MAX_N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < MAX_N && 0 <= j + dj[k] &&\n                    j + dj[k] < MAX_N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                }\n            }\n            ans[i][j]++;\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nvoid Fill(int i, int j) {\n\tll tmp = min(min(n - i + 1, n - j + 1), min(i, j)) + 1;\n\tans[i][j] = tmp;\n\twhile (used.count(ans[i][j]))\n\t\tans[i][j] += tmp;\n\tused.insert(ans[i][j]);\n}\nstruct Node {\n\tint r, c;\n\tint Cal() const { return min(min(n - r + 1, n - c + 1), min(r, c)); }\n\tbool operator < (const Node &d) const { return Cal() > d.Cal(); }\n} todo[N * N];\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\ttodo[++tail] = (Node){i, j};\n\t\t\t}\n\tsort(todo + 1, todo + tail + 1);\n\tfor (int i = 1; i <= tail; ++i)\n\t\tFill(todo[i].r, todo[i].c);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 510, M = 1e4, K = 1024;\nint n, m, is[M], c, p[K];\nvoid pre_work() {\n    for (int i = 2; i < M; ++i) {\n        if (!is[i]) p[++c] = i; if (c >= m) break;\n        for (int j = 1; j <= c && p[j] * i < M; ++j) {\n            is[p[j] * i] = 1; if (i % p[j] == 0) break;\n        }\n    }\n}\nint x[K], y[K], res[N][N];\nint sx[4] = {1, 0, -1, 0}, sy[4] = {0, 1, 0, -1};\nint gcd (int x, int y) {\n    return y ? gcd (y, x % y) : x;\n}\nsigned main() {\n    scanf (\"%lld\", &n);\n    m = n << 1; pre_work();\n    int a = 1, b = c, k = 1;\n    // for (int i = 1; i <= c; ++i) printf (\"%lld \", p[i]); puts (\"\");\n    for (int i = 1; i <= n; ++i) {\n        if (k) x[i * 2] = p[a], ++a;\n        else x[i * 2] = p[b], --b; k ^= 1;\n    }\n    for (int i = 1; i <= n; i += 2) {\n        y[1 - i + n] = p[a], ++a;\n        if (k) y[1 - i + n] = p[a], ++a;\n        else y[1 - i + n] = p[b], --b; k ^= 1;\n    }\n    for (int i = 3; i <= n; i += 2) {\n        y[i - 1 + n] = p[a], ++a;\n        if (k) y[i - 1 + n] = p[a], ++a;\n        else y[i - 1 + n] = p[b], --b; k ^= 1;\n    }\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) % 2 == 0) res[i][j] = x[i + j] * y[i - j + n];\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) % 2) {\n            for (int k = 0; k < 4; ++k) {\n                int ii = i + sx[k], jj = j + sy[k];\n                if (ii < 1 || jj < 1 || ii > n || jj > n) continue;\n                if (res[i][j]) res[i][j] = res[i][j] * res[ii][jj] / gcd (res[i][j], res[ii][jj]);\n                else res[i][j] = res[ii][jj];\n            }\n            }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j)\n            printf (\"%lld \", res[i][j]); puts (\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long int LL;\nconst int Max_N(505);\nconst int Max_S(10000000);\nconst int dx[] = {+1, -1, +0, +0};\nconst int dy[] = {+0, +0, +1, -1};\n\nconstexpr LL gcd(LL a, LL b)\n{\n\treturn b == 0LL ? a : gcd(b, a % b);\n}\n\nconstexpr LL lcm(LL a, LL b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nint N, ps, P[Max_S];\nLL A[Max_N][Max_N];\nbool Prime[Max_S];\n\nint main()\n{\n\tmemset(Prime, true, sizeof(Prime)), Prime[0] = Prime[1] = false;\n\tfor (int i = 2;i < Max_S;++i)\n\t{\n\t\tif (Prime[i])\n\t\t\tP[++ps] = i;\n\t\tfor (int j = 1, x;j <= ps && (x = i * P[j]) < Max_S;++j)\n\t\t{\n\t\t\tPrime[x] = false;\n\t\t\tif (x % P[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tprintf(\"%d %d\\n\", 4, 7);\n\t\tprintf(\"%d %d\\n\", 23, 10);\n\t\treturn 0;\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tA[i][j] = P[(i + j) >> 1] * 1LL * P[N + (i - j) / 2 + (N + 1) / 2];\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tA[i][j] = 1LL;\n\t\t\t\tfor (int k = 0, x, y;k < 4;++k)\n\t\t\t\t\tif (1 <= (x = i + dx[k]) && x <= N && 1 <= (y = j + dy[k]) && y <= N)\n\t\t\t\t\t\tA[i][j] = lcm(A[i][j], A[x][y]);\n\t\t\t\t++A[i][j];\n\t\t\t}\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nint_fast64_t N, ans[502][502];\nvector<size_t> v(730), w(730);\n\nint_fast64_t lcm(int_fast64_t a, int_fast64_t b) {\n    return a / __gcd(a, b) * b;\n}\n\nint_fast64_t lcm(initializer_list<int_fast64_t> a){\n    int_fast64_t ret = 1;\n    for(auto i : a)\n        ret = lcm(ret, i);\n    return ret;\n}\n\nint main(){\n    for(int i = 0; i < 501; ++i){\n        ans[i][0] = 1;\n        ans[501][i] = 1;\n        ans[i + 1][501] = 1;\n        ans[0][i + 1] = 1;\n    }\n    iota(v.begin(), v.end(), 1);\n    iota(w.begin(), w.end(), 1);\n    random_device rdv;\n    mt19937 mt(rdv());\n    shuffle(v.begin(), v.end(), mt);\n    shuffle(w.begin(), w.end(), mt);\n    for(int i = 1; i <= 500; i += 2)\n        for(int j = 1; j <= 500; j += 2){\n            ans[i][j] = p[v[(i + j) / 2]] * p[w[(500 + i - j) / 2]];\n            ans[i + 1][j + 1] = p[v[(i + j + 2) / 2]] * p[w[(500 + i - j) / 2]];\n        }\n    for(int i = 1; i <= 500; i += 2)\n        for(int j = 1; j <= 500; j += 2){\n            ans[i + 1][j] = lcm({ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]}) + 1;\n            ans[i][j + 1] = lcm({ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]}) + 1;\n        }\n    scanf(\"%lld\", &N);\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j)printf(\"%lld \", ans[i + 1][j + 1]);\n        puts(\"\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nll a[MAXN][MAXN],prime[MAXN];\nbool check(int x)\n{\n\tfor (int i=2;1ll*i*i<=x;i++)\n\t\tif (x%i==0) return 0;\n\treturn 1;\n}\nll gcd(ll x,ll y) { return y==0?x:gcd(y,x%y); }\nint main()\n{\n\tint n=read(),num=0;\n\tif (n==2) { printf(\"4 7\\n23 10\\n\"); return 0; }\n\tfor (int i=2;i<=100000;i++)\n\t\tif (check(i))\n\t\t{\n\t\t\tprime[++num]=i;\n\t\t\tif (num==n<<1) break;\n\t\t}\n\tfor (int i=0;i<=n+1;i++)\n\t\tfor (int j=0;j<=n+1;j++) a[i][j]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i&1)^(j&1)) continue;\n\t\t\ta[i][j]=prime[(i+j)>>1]*prime[n+((i-j+n+1)>>1)];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i&1)^(j&1)) a[i][j]=max(a[i-1][j]*a[i+1][j],a[i][j-1]*a[i][j+1])+1;\n\tif ((n-1)&1)\n\t{\n\t\ta[1][1]=a[2][1]*a[1][2]/gcd(a[2][1],a[1][2])+1;\n\t\ta[n][1]=a[n-1][1]*a[n][2]/gcd(a[n-1][1],a[n][2])+1;\n\t\ta[1][n]=a[2][n]*a[1][n-1]/gcd(a[2][n],a[1][n-1])+1;\n\t\ta[n][n]=a[n-1][n]*a[n][n-1]/gcd(a[n-1][n],a[n][n-1])+1;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    vector<vector<ll>> a(500,vector<ll>(500,0));\n    vector<int> isPrime(5000,true);\n    vector<ll> primes;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            primes.push_back(i);\n            for(int j=2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n    set<ll> vs;\n    swap(primes[0],primes[213]);\n    swap(primes[1],primes[224]);\n    swap(primes[2],primes[171]);\n    for(int i=499;i>=0;i--){\n        for(int j=i%2;j<500;j+=2){\n            a[i][j]=primes[i/2]*primes[j/2];\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    auto isRange=[](int x,int y){\n        return 0<=x && x<500 && 0<=y && y<500;\n    };\n    auto lcm=[](ll x,ll y){\n        return x/__gcd(x,y)*y;\n    };\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n\n    for(int i=0;i<500;i++){\n        for(int j=(i+1)%2;j<500;j+=2){\n            ll v=1;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dx[k],j+dy[k])){\n                    v=lcm(v,a[i+dx[k]][j+dy[k]]);\n                }\n            }\n            a[i][j]=v;\n            int tmp=2;\n            while(vs.count(a[i][j]+1)){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            a[i][j]++;\n            if(a[i][j]<=1e15) vs.insert(a[i][j]);\n        }\n    }\n    ios_base::sync_with_stdio(false);\n    \n    int n;\n    cin>>n;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j+1<n;j++){\n            if(a[i][j]>1e15){\n                cnt++;\n                cerr<<i<<\" \"<<j<<endl;\n                vs.insert(a[i][j]);\n            }\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<a[i][n-1]<<\"\\n\";\n    }\n    cerr<<cnt<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 5555555\n#define M 2020\nusing namespace std;\n\nint vis[N];\nvector<int> pri;\n\nvoid sieve(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (!vis[i]) pri.push_back(i);\n        for (int j : pri) {\n            if (1ll * i * j > n) break;\n            vis[i * j] = 1;\n            if (i % j == 0) break;\n        }\n    }\n}\n\nlong long a[M][M];\nint n, top, p[2][M << 2];\n\nlong long lcm(long long x, long long y) {\n    return x / __gcd(x, y) * y;\n}\n\nint get(int op, int x) {\n    if (op) x += n;\n    if (!p[op][x]) p[op][x] = pri[top++];\n    return p[op][x];\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    if (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\n    sieve(10000);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (!((i + j) & 1))\n                a[i][j] = 1ll * pri[(i + j) / 2 - 1] * pri[n + (i - j) / 2 + (n + 1) / 2];\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (((i + j) & 1)) {\n                a[i][j] = 1;\n                if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n                if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n                if (i < n) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n                if (j < n) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n                ++a[i][j];\n            }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            printf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nll ans[1005][1005],prime[10005],num;\nbool flag[10005];\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tflag[1]=1;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(!flag[i])prime[++num]=i;\n\t\tfor(int j=1;j<=num&&prime[j]*i<=10000;j++)\n\t\t{\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif(!((i+j)&1))\n\t\t{\n\t\t\tint p1=(i+j+1)/2;\n\t\t\tint p2=(i-j+n+1)/2+n;\n\t\t\tans[i][j]=prime[p1]*prime[p2];\n\t\t}\n\t}\n\tll v=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif((i+j)&1)\n\t\t{\n\t\t\tans[i][j]=1;\n\t\t\tif(i!=1)ans[i][j]*=ans[i-1][j]/__gcd(ans[i][j],ans[i-1][j]);\n\t\t\tif(j!=1)ans[i][j]*=ans[i][j-1]/__gcd(ans[i][j],ans[i][j-1]);\n\t\t\tif(i!=n)ans[i][j]*=ans[i+1][j]/__gcd(ans[i][j],ans[i+1][j]);\n\t\t\tif(j!=n)ans[i][j]*=ans[i][j+1]/__gcd(ans[i][j],ans[i][j+1]);\n\t\t}\n\t\tv=max(v,ans[i][j]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t  printf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<random>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll gcd(ll a, ll b) {\t\t// ユークリッドの互除法\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll N;\nvector<vector<ll>> ans;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>N;\n\tans.resize(N,vector<ll>(N));\n\tvector<bool> used(10000000,false);\n\tvector<ll> tmp;\n\tfor(ll i=1;i<=10000000;i++) {\n\t\tif(!used[i]) {\n\t\t\tfor(ll j=i;j<=10000000; j*=2) {\n\t\t\t\tif(used[j]) break;\n\t\t\t\tused[j]=true;\n\t\t\t\ttmp.pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tll pos=0;\n\tREP(i,N) REP(j,N) {\n\t\tif((i+j)%2==0) {\n\t\t\tans[i][j]=tmp[pos];\n\t\t\tpos++;\n\t\t}\n\t}\n\tREP(i,N) REP(j,N) {\n\t\tif((i+j)%2==1) {\n\t\t\tvector<ll> maw;\n\t\t\tif(i>0) maw.pb(ans[i-1][j]);\n\t\t\tif(i<N-1) maw.pb(ans[i+1][j]);\n\t\t\tif(j>0) maw.pb(ans[i][j-1]);\n\t\t\tif(j<N-1) maw.pb(ans[i][j+1]);\n\t\t\tll g=maw[0];\n\t\t\tFOR(k,1,maw.size()) g=gcd(g,maw[k]);\n\t\t\tll hoge=g;\n\t\t\tREP(k,maw.size()) hoge*=maw[k]/g;\n\t\t\tans[i][j]=hoge;\n\t\t}\n\t}\n\tREP(i,N) DUMP(ans[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint pri[101000], tot = 0;\nbool is[101000];\n\nvoid init()\n{\n\tfor(int i = 2; i <= 100000; i++)\n\t{\n\t\tif(!is[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= 100000; j++)\n\t\t{\n\t\t\tis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nlong long m[1010][1010];\n\nlong long gcd(long long a, long long b) {return b == 0 ? a : gcd(b, a % b);} \nvoid lcm(long long &a, long long b)\n{\n\ta = a / gcd(a, b) * b; \n}\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tif(n == 2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tinit();\n\tint j = 2;\n\tfor(int i = 2; i <= 2 * n; i += 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i - k >= 1 && i - k <= n) m[k + 1][i - k] = pri[j];\n\t\t}\n\t\tj++;\n\t}\n\t\n\tfor(int i = (n / 2 * 2); i >= - n; i -= 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i + k >= 1 && i + k <= n) m[k + 1][i + k] *= pri[j];\n\t\t}\n\t\tj++;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(!m[i][j])\n\t\t\t{\n\t\t\t\tm[i][j] = 1;\n\t\t\t\tif(i != 1) lcm(m[i][j], m[i - 1][j]);\n\t\t\t\tif(j != 1) lcm(m[i][j], m[i][j - 1]);\n\t\t\t\tif(i != n) lcm(m[i][j], m[i + 1][j]);\n\t\t\t\tif(j != n) lcm(m[i][j], m[i][j + 1]);\n\t\t\t\tm[i][j]++;\n\t\t\t}\n\t\t}\n\tfor(int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \",m[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define int long long\nint n,prime[10100000],a[5100][5100],len;\nbool isPrime[10001000];\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(int a,int b){\n\treturn a*b/gcd(a,b);\n}\nint LCM(int a,int b,int c,int d){\n\tb=lcm(a,b);\n\tc=lcm(b,c);\n\td=lcm(c,d);\n\treturn d;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t} \n\tfor(int i=2;i<=1000000;i++)\n\t\tisPrime[i]=true;\n\tfor(int i=2;i<=1000;i++){\n\t\tif(!isPrime[i])continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i)\n\t\t\tisPrime[j]=false;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tif(isPrime[i])prime[++len]=i;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1)continue;\n\t\t\tint x=(i+j)/2,y=(i-j)/2+n+(n-1)/2+1;\n\t\t\ta[i][j]=prime[x]*prime[y];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)continue;\n\t\t\ta[i][j]=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j==n)puts(\"\");\n\t\t\telse putchar(' ');\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Pow2(a) (1<<(a))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a, ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a, ll b){return a/gcd(a,b)*b;}\n\nll salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    FOR(i,FactM.sz,n){\n        FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n   llin(n);\n   vll a(n);\n   FOR(i,0,n-1){\n       sal(2+i);\n       a[i]=2+i;\n   }\n   FOR(j,1,n-1){\n       a[0]=(n/2+1)*2+j;\n       sal(a[0]);\n   FOR(i,1,n-1){\n       a[i]=1+lcm(a[i-1],a[i]);\n       sal(a[i]);\n   }\n   }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define ll long long\nusing namespace std;\nconst int N=510,MX=1e7;\nint p[250010];\nint vis[MX];\nll rec[N][N];\nint n,m,cnt;\nvoid prework(int n){\n\tvis[1]=false;\n\tint cnt=0;\n\tfor (int i=2;cnt<n;++i){\n\t\tif (!vis[i])\n\t\t\tp[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<MX;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){\n\tif (!x||!y) return x+y;\n\treturn x/gcd(x,y)*y;\n}\nvoid solve(){\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\trec[i][j]=1LL*p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif (!rec[i][j])\n\t\t\t\trec[i][j]=lcm(lcm(rec[i-1][j],rec[i][j+1]),lcm(rec[i+1][j],rec[i][j-1]))+1;\n}\n \nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tll tmp;\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"%d %d\\n%d %d\\n\",4,7,23,10);\n\t\treturn 0;\n\t}\n\tprework(n*n);\n\tsolve();\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",rec[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing LL = long long;\nconst int N = 50000;\nint n, sie[N], pr[N], pt, now;\nLL a[505][505];\nvoid sieve() {\n\tfor (int i = 2; i < N; i++) {\n\t\tif (!sie[i]) pr[++pt] = i;\n\t\tfor (int j = 1, t; j <= pt && (t = i * pr[j]) < N; j++) {\n\t\t\tsie[t] = 1;\n\t\t\tif (i % pr[j] == 0) break; \n\t\t}\n\t}\n}\nLL lcm(LL x, LL y) { if (x == 0) return y; if (y == 0) return x; return x / std::__gcd(x, y) * y; }\n#define P(number) namespace map##number {\\\nint vis[N];\\\nint map(int x) {\\\n\tstatic int *vis = map##number::vis + N / 2;\\\n\tif (vis[x]) return vis[x];\\\n\telse return vis[x] = pr[now++];\\\n}\\ \n}\nP(0) P(1)\nint main() {\n\tstd::scanf(\"%d\", &n);\n\tif (n == 2) { std::puts(\"2 3\\n5 4\\n\"); return 0; }\n\tsieve(); now = 2;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if (i + j & 1) {\n\t\t\ta[i][j] = map0::map(i + j >> 1);\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if (i + j & 1) {\n\t\t\ta[i][j] *= map1::map(i - j >> 1);\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if (!a[i][j]) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j + 1], a[i][j - 1])) + 1;\n\t\t}\n//\tfor (int i = 1; i <= n; i++)\n//\t\tfor (int j = 1; j <= n; j++) if (a[i][j] > 1e15) std::puts(\"!!!!\"), std::exit(0);\n\tfor (int i = 1; i <= n; i++, std::puts(\"\"))\n\t\tfor (int j = 1; j <= n; j++) std::printf(\"%lld \", a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) ((int) x.size())\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAX = 2e6;\nconst int MAXN = 505;\n\nbool bio[MAX];\nvector <int> prime;\nint n;\nll a[MAXN][MAXN];\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n        prime.pb(i);\n        for(int j = i; j < MAX; j += i)\n            bio[j] = true;\n    }\n}\n\nll d1[2 * MAXN], d2[2 * MAXN];\n\nint main(){\n    sito();\n\n    int idx = 0;\n\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    int X = 2 * n - 1;\n    //cout << (ll)prime[1000] * prime[999] * prime[998] * prime[997];\n\n    REP(i, n)\n        REP(j, n){\n            if(i % 2 == 0 && j % 2 == 0){\n                a[i][j] = prime[i + j] * prime[i - j + 2 * n];\n            }\n            else if(i % 2 && j % 2){\n                a[i][j] = prime[i + j] * prime[i - j + 2 * n];\n            }\n        }\n\n    set<ll> S;\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j] == 0){\n                ll sol = 0;\n                if(i > 0) sol = a[i - 1][j];\n                if(j > 0) sol = sol == 0 ? a[i][j - 1] : sol * a[i][j - 1];\n                if(i != n - 1) sol = sol == 0 ? a[i + 1][j] : sol * a[i + 1][j];\n                if(j != n - 1) sol = sol == 0 ? a[i][j + 1] : sol * a[i][j + 1];\n                a[i][j] = sol + 1;\n            }\n        }\n\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n            //S.insert(a[i][j]);\n        }\n        cout << \"\\n\";\n    }\n    //cout << sz(S) _ n * n << \"\\n\";\n    //assert(sz(S) == n * n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat[2];\nint n,p[10005],vis[10005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint nex(int t,int x){\n\tif (!mat[t][x])mat[t][x]=p[p[0]--];\n\treturn mat[t][x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=p[0]/2;i++)swap(p[i],p[p[0]-i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=nex(0,i+j)*nex(1,i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    set<int> used;\n    ll cur = 2;\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            a[i][j] = cur++;\n            used.insert(a[i][j]);\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            ll val = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    val = LCM(val, a[ni][nj]);\n                }\n            }\n            a[i][j] = val + 1;\n            while(used.count(a[i][j])) a[i][j] += val;\n            used.insert(a[i][j]):\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define ULL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\n\n\n\nint prime[100002]={};\nint Er_N=100001;\nvoid Er(){//Eratosthenes  1:PRIME  0:NOT PRIME\n\tfor(int i = 2; i < Er_N; i++){\n\t\tprime[i] = 1;\n\t}\n\tint limit_Er_roop=sqrt(Er_N);\n\tfor(int i = 2; i < limit_Er_roop; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = 0; i * (j + 2) < Er_N; j++){\n\t\t\t\tprime[i *(j + 2)] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long gcd(long long a,long long b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b){\n\tlong long g=gcd(a,b);\n\treturn a/g*b;\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tif(n==2){\n\t\tcout<<\"4 7\"<<endl;\n\t\tcout<<\"23 10\"<<endl;\n\t\treturn 0;\n\t}\n\tEr();\n\tvector<int> prm;\n\tFOR(i,2,Er_N){\n\t\tif(prime[i])prm.PB(i);\n\t}\n\tint t=prm.size();\n\tcerr<<t<<endl;\n\tLL b[505][505]={};\n\tFORQ(i,0,n+1){\n\t\tFORQ(j,0,n+1){\n\t\t\tb[i][j]=1LL;\n\t\t}\n\t}\n\tFORQ(i,1,n){\n\t\tFORQ(j,1,n){\n\t\t\tif((i+j)%2==0){\n\t\t\t\tint id1=(i+j-2)/2;\n\t\t\t\tint id2=2*n-1-(n+(n&1)-i+j-2)/2;\n\t\t\t\tb[i][j]=1LL*prm[id1]*prm[id2];\n\t\t\t}\n\t\t}\n\t}\n\tFORQ(i,0,n){\n\t\tFORQ(j,0,n){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tb[i][j]+=1LL*lcm(lcm(b[i-1][j],b[i][j-1]),lcm(b[i+1][j],b[i][j+1]));\n\t\t\t}\n\t\t}\n\t}\n\tLL mx=0;\n\tFORQ(i,1,n){\n\t\tFOR(j,1,n){\n\t\t\tcout<<b[i][j]<<\" \";\n\t\t\tmx=max(mx,b[i][j]);\n\t\t}\n\t\tcout<<b[i][n]<<endl;\n\t}\n\tcerr<<mx<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n;\nll ans[555][555];\n\ndeque<int>pri;\nbool np[1001000];\n\nll lcm(ll x,ll y){\n    if (!x||!y) return x+y;\n    return x/__gcd(x,y)*y;\n}\n\nvoid prepri(int n){\n    for (int i=2;i<=n;++i){\n        if (np[i]) continue;\n        if (i!=2) pri.push_back(i);\n        for (int j=i+i;j<=n;j+=i)\n            np[j]=1;\n    }\n}\n\nmap<int,ll>ad, su;\n\nint main(){\n    prepri(8000);\n    cin>>n;\n    for (int i=0;i<=n+1;++i)\n        for (int j=0;j<=n+1;++j)\n            if ((i+j)%2==0){\n                if (!ad[i+j]){\n                    if ((i+j)/2&1){\n                        ad[i+j]=pri.front();\n                        pri.pop_front();\n                    }else{\n                        ad[i+j]=pri.back();\n                        pri.pop_back();\n                    }\n                }\n                if (!su[i-j]){\n                    if ((i-j)/2&1){\n                        su[i-j]=pri.front();\n                        pri.pop_front();\n                    }else{\n                        su[i-j]=pri.back();\n                        pri.pop_back();\n                    }\n                }\n                ans[i][j]=ad[i+j]*su[i-j];\n            }\n    int dx[4]={0,0,1,-1};\n    int dy[4]={1,-1,0,0};\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            if ((i+j)%2==1){\n                ll l=1;\n                for (int d=0;d<4;++d)\n                    l=lcm(l,ans[i+dx[d]][j+dy[d]]);\n                ans[i][j]=l+1;\n            }\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j){\n            printf(\"%lld \",ans[i][j]);\n        }\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100001\nusing namespace std;\nint n, prime[maxn], d[maxn], a[maxn], f[2001][2001], ans, cnt;\nint val1[maxn], val2[maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t \n\tfor(int i = 2; i <= 10000; i++){\n\t\tif(!d[i] && i != 2) prime[++cnt] = i;\n\t\tfor(int j = i; j <= 10000; j += i) d[j] = 1;\n\t}\n\tcin >> n; \n\tif (n==2) {\n  \t\tputs(\"4 7\");\n  \t\tputs(\"23 10\");\n  \t\treturn 0;\n  \t}\n\t  cnt = 0;\n\t for(int i = 1; i <= n ; i++)\n    for(int j = 1; j <= n; j++)\n      if (i + j & 1) {\n      \tif (!val1[i - j + n]) val1[i-j+n]=prime[++cnt];\n      \tf[i][j]=val1[i - j + n];\n\t  }\n  for(int i = 1; i <= n; i++)\n    for(int j = 1; j <= n ; j++)\n      if (i + j & 1) {\n      \tif (!val2[i + j]) val2[i + j]=prime[++cnt];\n      \tf[i][j]*=val2[i + j];\n\t  }\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(i + j & 1) continue; ans = 1;\n\t\t\tif(f[i - 1][j]) ans = ans / __gcd(f[i - 1][j], ans) * f[i - 1][j];\n\t\t\tif(f[i + 1][j]) ans = ans / __gcd(f[i + 1][j], ans) * f[i + 1][j];\n\t\t\tif(f[i][j + 1]) ans = ans / __gcd(f[i][j + 1], ans) * f[i][j + 1];\n\t\t\tif(f[i][j - 1]) ans = ans / __gcd(f[i][j - 1], ans) * f[i][j - 1];\n\t\t\tf[i][j] = ans + 1;\n\t\t}\n\tfor(int i  = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \", f[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N;\nbool prime[1000005];\nvector<llint> pvec;\nllint ans[505][505];\nconst llint di[] = {1, 0, -1, 0}, dj[] = {0, -1, 0, 1};\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tfor(int i = 2; i < 1005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j += i) prime[j] = true;\n\t}\n\t/*for(int i = 3; i < 500005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\tvector<llint> vec;\n\tfor(int i = 0; i < pvec.size(); i++){\n\t\tfor(int j = 0; j < 8; j++) vec.push_back(pvec[i] << j);\n\t}\n\tsort(vec.begin(), vec.end());\n\tpvec = vec;*/\n\t\n\tfor(int i = 3; i < 1000005; i++) pvec.push_back(i);\n\t\n\tllint pos = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(ans[i][j]) continue;\n\t\t\tllint tmp = 1;\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif(ni > N || nj < 1 || nj > N) continue;\n\t\t\t\tif(ni < 1) tmp *= 2;\n\t\t\t\telse tmp *= ans[ni][nj];\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 505;\nint prime[maxn << 1], pp;\nll a[maxn][maxn];\n\nll gcd(ll x, ll y) {\n\tif(!y) return x;\n\treturn gcd(y, x % y);\n}\n\nll lcm(ll x, ll y) {\n\tif(!x or !y) return x + y;\n\treturn x / gcd(x, y) * y;\n}\n\nint main() {\n\tint n = read;\n\tbool mark = !(n & 1);\n\tif(mark) ++ n;\n\n\tfor(int x = 2; pp < n * 2; x ++) {\n\t\tbool ok = 1;\n\t\tfor(int d = 2; d * d <= x; d ++)\n\t\t\t// XXX: 震惊！这里不强制转 bool 竟然会出错？！\n\t\t\tok &= bool(x % d);\n\t\tif(ok)\n\t\t\tprime[++ pp] = x;\n\t}\n\n\tsrand(19260817);\n\tstd::random_shuffle(prime + 1, prime + pp + 1);\n\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i][i] = prime[i];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i][n - i + 1] = prime[n + i];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) ? 1 : 2; j <= n; j += 2)\n\t\t\tif(!a[i][j])\n\t\t\t\ta[i][j] = a[(i + j) >> 1][(i + j) >> 1] *\n\t\t\t\t\ta[(n + 1 + i - j) >> 1][(n + 1 + j - i) >> 1];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) ? 2 : 1; j <= n; j += 2)\n\t\t\ta[i][j] = lcm(a[i - 1][j], lcm(a[i][j - 1],\n\t\t\t\t\t\tlcm(a[i + 1][j], a[i][j + 1]))) + 1;\n\n\tif(mark) -- n;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nvector<int> makePrimeLst(int N)\n{\n    if (N < 2) return vector<int>();\n    if (N == 2) return vector<int>{2};\n    vector<int> ans;\n    vector<int> alive(N+1, 1);\n    for (int i=2; (long long)i*i<=(long long)N; i++)\n    {\n        if (alive[i]) ans.push_back(i);\n        for (int t = i; t<=N; t += i) alive[t] = 0;\n    }\n    for (int i=ans.back()+1; i<=N; i++) if (alive[i]) ans.push_back(i);\n    return ans;\n}\n\nconstexpr int Nmax = 503;\nlint ans[Nmax][Nmax];\n\nint main()\n{\n    vector<int> info = makePrimeLst(100000);\n    vector<lint> p, q;\n    int now = 1;\n    while (p.size() < Nmax + 1)\n    {\n        p.insert(p.begin(), info[now++]);\n        q.insert(q.begin(), info[now++]);\n        p.push_back(info[now++]);\n        q.push_back(info[now++]);\n    }\n\n    REP(i, Nmax) REP(j, Nmax)\n    {\n        int u = (i + j) / 2, v = (i + (Nmax - 1 - j)) / 2;\n        if ((i + j) & 1)\n        {\n            ans[i][j] = p[u + 1] * q[v + 1];\n        }\n        else\n        {\n            ans[i][j] = p[u] * p[u + 1] * q[v] * q[v + 1] + 2;\n        }\n        if (ans[i][j] > 1000000000000000LL) exit(1);\n    }\n\n    int N;\n    cin >> N;\n    REP(i, N) REP(j, N)\n    {\n        lint min_ = min(ans[i][j], ans[i + 1][j]);\n        lint max_ = max(ans[i][j], ans[i + 1][j]);\n        if (max_ % min_ != 2) exit(1);\n    }\n    REP(i, N) REP(j, N)\n    {\n        lint min_ = min(ans[i][j], ans[i][j + 1]);\n        lint max_ = max(ans[i][j], ans[i][j + 1]);\n        if (max_ % min_ != 2) exit(1);\n    }\n\n    REP(i, N)\n    {\n        REP(j, N) cout << ans[i][j] << (j == N - 1 ? \"\\n\" : \" \");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\nusing ll = long long;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\ntemplate <typename T> T gcd(T a, T b) { while (a) { b %= a; swap(a, b); } return b; }\ntemplate <typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// $ seq 10000 | factor | grep '^\\(\\w\\+\\): \\1*$' | head -n 1000 | sed 's/:.*/,/' | tr -d '\\n'\nconst array<ll, 1000> primes = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919 };\n\nvector<vector<ll> > solve(int n) {\n    vector<ll> b(n);\n    vector<ll> c(n);\n    REP (z, n) {\n        b[z] = primes[z % 2 == 0 ? z     : primes.size() - z - 1];\n        c[z] = primes[z % 2 == 0 ? z + 1 : primes.size() - z - 2];\n    }\n\n    constexpr ll m = 1;\n    auto a = vectors(n, n, ll());\n    REP (y, n) REP (x, n) if ((y + x) % 2 == 0) {\n        a[y][x] = b[(y + x) / 2] * c[(y + (n - x - 1)) / 2];\n    }\n    REP (y, n) REP (x, n) if ((y + x) % 2 == 1) {\n        ll b = 1;\n        if (y - 1 >= 0) b = lcm(b, a[y - 1][x]);\n        if (x - 1 >= 0) b = lcm(b, a[y][x - 1]);\n        if (y + 1 <  n) b = lcm(b, a[y + 1][x]);\n        if (x + 1 <  n) b = lcm(b, a[y][x + 1]);\n        a[y][x] = b + m;\n    }\n\n    return a;\n}\n\nint main() {\n    int n; cin >> n;\n    auto a = solve(n);\n    REP (y, n) {\n        cout << a[y] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\nll a[1005][1005];\nint n;\nint pri[10005],tot;\nbool mk[10005];\nll lcm(ll a,ll b) {\n\tif((!a)||(!b)) return a+b;\n\treturn 1ll*a/__gcd(a,b)*b;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tif(n==2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=10000;i++) {\n\t\tif(!mk[i]) { pri[++tot]=i; }\n\t\tif(tot==1000) break;\n\t\tfor(int j=1;j<=tot&&1ll*pri[j]*i<=10000;j++) {\n\t\t\tint k = pri[j] * i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==0) a[i][j] = pri[(i + j) / 2] * pri[n+((i-j)/2+(n+1)/2)];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==1) a[i][j] = lcm( lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]) ) + 1;\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 505;\nll a[maxN][maxN];\nvector < int > primes;\nint n;\nbool used[maxN * maxN * 10];\nll gcd(ll a, ll b) {\n    while (a > 0 && b > 0) {\n        if (a < b) swap(a, b);\n        a %= b;\n    }\n    return a + b;\n}\nll lcm(ll a, ll b) {\n    return (a * (b / gcd(a, b)));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int max_n = 500;\n    for (int i = 2; ; i++) {\n        if (used[i]) continue;\n        primes.push_back(i);\n        if (primes.size() > 2 * max_n + 10) {\n            break;\n        }\n        for (int j = i; j < maxN * maxN * 10; j += i) used[j] = true;\n    }\n    set < ll > all;\n    for (int i = 1; i <= max_n; i++) {\n        for (int j = 1; j <= max_n; j++) {\n            if (((i + j) % 2) == 0) {\n                a[i][j] = 1LL * primes[(i + j) / 2] * primes[(i - j) / 2 + max_n + 2 + (max_n / 2)];\n                all.insert(a[i][j]);\n            }\n        }\n    }\n    cout << all.size() << endl;\n    ll mx = 1;\n    for (int i = 1; i <= max_n; i++) {\n        for (int j = 1; j <= max_n; j++) {\n            if (((i + j) % 2) == 0) continue;\n            a[i][j] = 1;\n            if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n            if (i < max_n) a[i][j] = lcm(a[i + 1][j], a[i][j]);\n            if (j < max_n) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n            if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n            a[i][j]++;\n            mx = max(mx, a[i][j]);\n            all.insert(a[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#undef NDEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\nusing ld = long double;\n\nvoid solve(bool);\n\n//#define YA\n\nint main() {\n#ifdef YA\n    auto s = clock();\n    assert(freopen(\"input.txt\", \"r\", stdin));\n#else\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    cout << fixed << setprecision(20);\n\n    solve(true);\n\n#ifdef YA1\n    while (true) solve(false);\n#endif\n\n#ifdef YA\n    cerr << endl << endl << \"time = \" << (clock() - s) / (double)CLOCKS_PER_SEC << endl;\n#endif\n\n    return 0;\n}\n\nconst int MX = (int)1e7;\n\nint p[MX + 5];\nvector <li> pr;\nint cnt = 5;\nint last = 0;\nli a[555][555];\n\nvoid solve(bool __attribute__((unused)) read) {\n    for (int i = 2; i <= MX; ++i) {\n        if (p[i])\n            continue;\n        if (i != 2)\n            pr.push_back(i);\n        for (li j = (li)i * i; j <= MX; j += i)\n            p[j] = 1;\n    }\n    int n;\n    cin >> n;\n    int u = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 0) {\n                if (last == cnt) {\n                    ++u;\n                    last = 0;\n                }\n                a[i][j] = (1ll << last) * pr[u];\n                ++last;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                vector <li> vc;\n                li z = 1;\n                for (int x = -1; x <= 1; ++x) {\n                    for (int y = -1; y <= 1; ++y) {\n                        if (abs(x) + abs(y) != 1 || i + x < 0 || i + x >= n || j + y < 0 || j + y >= n)\n                            continue;\n                        vc.push_back(a[i + x][j + y]);\n                        z = z * a[i + x][j + y] / __gcd(z, a[i + x][j + y]);\n                    }\n                }\n                a[i][j] = z;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[250+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X((i+j)/2)*Y((i-j)/2);\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2)+1;\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1010\n#define ll long long\n\nint n,cnt;\nint mark[N*10];\nll pri[N],a[N][N];\n\nvoid getpri() {\n\tfor (int i=2;i<=10000;i++) {\n\t\tif (!mark[i]) pri[++cnt]=i;\n\t\tif (cnt==1000) break;\n\t\tfor (int j=1;j<=cnt && i*pri[j]<=10000;j++) {\n\t\t\tmark[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nll lcm(ll x,ll y) {\n\tif (!x || !y) return x+y;\n\treturn x/__gcd(x,y)*y;\n}\n\nint main()\n{\n\tgetpri();\n\tscanf(\"%d\",&n);\n\tif (n==2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\ta[i][j]=pri[(i+j)/2]*pri[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (!a[i][j])\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nvector<ll> primes;\nll factor[505];\nll field[505][505];\nset<ll> used;\n\nint main() {\n    //cout.precision(10);\n    int N;\n    cin >> N;\n    for(ll i = 2; i <= 20000; i++) {\n        bool ok = true;\n        for(ll j = 2; j * j <= i; j++) {\n            if(i % j == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if(ok) primes.push_back(i);\n    }\n    int index = 1;\n    for(int i = 2; i <= 2 * N; i += 2) {\n        factor[i] = primes[index];\n        index++;\n    }\n    for(int i = 1; i <= N + 1; i += 2) {\n        field[i][1] = primes[index];\n        index++;\n        ll now1 = field[i][1];\n        field[1][i] = primes[index];\n        index++;\n        ll now2 = field[1][i];\n        //cerr << i << \" \" << index << endl;\n        for(int j = 1; j + i - 1 <= N + 1; j++) {\n            field[j][i+j-1] = now1 * factor[i + 2 * j - 1];\n            field[i+j-1][j] = now2 * factor[i + 2 * j - 1];\n            //cerr << i << \" \" << j << endl;\n        }\n    }\n    vector<ll> val;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= N; j++) {\n            if(field[i][j] == 0) {\n                if(i > 1) field[i][j] = field[i+1][j] * field[i-1][j] + 1;\n                else field[i][j] = field[i][j+1] * field[i][j-1] + 1;\n            }\n            cout << field[i][j] << \" \";\n            //if(field[i][j] > 1e15) val.push_back(field[i][j]);\n            //if(used.find(field[i][j]) != used.end()) val.push_back(field[i][j]);\n            used.insert(field[i][j]);\n            if(i > 1) {\n                if(max(field[i-1][j], field[i][j]) % min(field[i][j], field[i-1][j]) != 1) val.push_back(field[i][j]);\n                //cerr << i << \" \" << j << \" \" << field[i][j] << \" \"<< field[i-1][j] << endl;\n            }\n        }\n        cout << endl;\n    }\n    //cout << \"out\" << endl;\n    //for(int i = 0; i < val.size(); i++) cout << val[i] << endl;\n    //cout << primes.size() << \" \" << primes[2] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( ;i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\nlong long cmmdc ( long long a , long long b ){\n\n    while ( b ){\n        long long t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\nlong long calcLCM ( long long a , long long b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int crLin = 0 ; crLin < noLin ; crLin +=2 ){\n        int i = crLin ;\n        for ( int j = 0 ; j < noLin && i < noLin ; i++ , j++  ){\n            mat [ i ][ j ] = *it ;\n        }\n        it++;\n    }\n\n    for ( int crCol = 2 ; crCol < noLin ; crCol+=2 ){\n        int j = crCol ;\n        for ( int i = 0 ; j < noLin ; i++,j++ ){\n            mat [ i ][ j ] = *it ;\n        }\n        it ++;\n    }\n\n    for ( int crCol = 0 ; crCol < noLin ; crCol+=2 ){\n        int i = crCol ;\n        for ( int j = 0 ; i >= 0 && j < noLin ; i-- , j++  ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it++;\n    }\n\n    for ( int crLin = noLin - 1 ; crLin >= 0 ; crLin-=2 ){\n        int i = crLin ;\n        for ( int j = noLin - 1 ; i < noLin ; i++ ,j-- ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it ++;\n    }\n\n\n\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n\n            long long  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n      //      cout << mat [ i ][ j ] << \" \" ;\n            printf(\"%lld \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=1e5+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n;\nll a[510][510];\nll lcm(ll a,ll b) {\n    return a/__gcd(a,b)*b;\n}\nint pri[N],tot=0;\nbool vis[N];\nvoid init() {\n    const int n=1e5;\n    for(int i=2;i<=n;i++) {\n        if(!vis[i]) pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=n;j++) {\n            vis[i*pri[j]]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\nint main() {\n    n=gi();\n    if(n==2) return puts(\"4 7\"),puts(\"23 10\"),0;\n    for(int i=0;i<=n+1;i++)\n        for(int j=0;j<=n+1;j++) a[i][j]=1;\n    init();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j-1)&1) a[i][j]=1ll*pri[(i+j)/2]*pri[(i+n-j+1)/2+n];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1) a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n    for(int i=1;i<=n;i++,puts(\"\"))\n        for(int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 510\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 998244353\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nll a[maxn][maxn];\nconst int S = 10050;\nbool bpr[S];\nmap<int, int> r[2];\nll gcd(ll a, ll b) {\n\tif (!b) return a;\n\treturn gcd(b, a % b);\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\nint main() {\n\tvi pr;\n\tfor (int i = 0; i < S; i++)\n\t\tbpr[i] = 1;\n\tfor (int i = 2; i < S; i++) {\n\t\tif (!bpr[i]) continue;\n\t\tpr.pb(i);\n\t\tfor (int j = 2; j * i < S; j++)\n\t\t\tbpr[i * j] = 0;\n\t}\n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 4 << ' ' << 7 << endl << 23 << ' ' << 10 << endl;\n\t\treturn 0;\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!r[0][i + j]) r[0][i + j] = pr[cnt++];\n\t\t\tif (!r[1][i - j]) r[1][i - j] = pr[cnt++];\n\t\t\ta[i][j] = r[0][i + j] * r[1][i - j];\n\t\t//\tcout << \"???\" << a[i][j] << endl;\n \t\t}\n \tfor (int i = 1; i <= n; i++) {\n \t\tfor (int j = 1; j <= n; j++) {\n \t\t\tif ((i + j) % 2 == 0) {\n\t \t\t\tll ns = 1;\n\t \t\t\tif (i >= 2) ns = lcm(ns, a[i - 1][j]);\n\t \t\t\tif (j >= 2) ns = lcm(ns, a[i][j - 1]);\n\t \t\t\tif (i != n) ns = lcm(ns, a[i + 1][j]);\n\t \t\t\tif (j != n) ns = lcm(ns, a[i][j + 1]);\n\t \t\t\ta[i][j] = ns + 1;\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15);\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 10000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef unsigned int uint;\n\nmt19937 rnd(random_device{}());\n\nconst int MAXN = 555;\nll a[MAXN][MAXN];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll gcd(ll a, ll b) {\n    return (b == 0 ? a : gcd(b, a % b));\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    int n;\n    cin >> n;\n    vector<ll> u, v;\n    for (int k = 3; sz(v) < n; ++k) {\n        bool ok = true;\n        for (int i = 2; i * i <= k; ++i) {\n            if (k % i == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            if (sz(u) < n) {\n                u.push_back(k);\n                u.push_back(k);\n            } else {\n                v.push_back(k);\n                v.push_back(k);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 0) {\n                a[i][j] = u[i] * v[j];\n                if (i % 2 == 1 && j % 2 == 1) {\n                    a[i][j] *= 2;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                ll cur = 1;\n\n                for (int k = 0; k < 4; ++k) {\n                    int x = i + dx[k], y = j + dy[k];\n                    if (x < 0 || x >= n || y < 0 || y >= n) {\n                        continue;\n                    }\n                    cur = cur / gcd(cur, a[x][y]) * a[x][y];\n                }\n                ++cur;\n                assert(cur < 1e15);\n                a[i][j] = cur;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j]  << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    // for (int i = 0; i < n; ++i) {\n    //     for (int j = 0; j < n; ++j) {\n    //         if ((i + j) % 2 == 0) {\n    //             a[i][j] = ++cur;\n    //             used.insert(cur);\n    //         }\n    //     }\n    // }\n\n    // for (int i = 0; i < n; ++i) {\n    //     for (int j = 0; j < n; ++j) {\n    //         if ((i + j) % 2 == 1) {\n    //             ll x = 0;\n    //             for ()\n    //         }\n    //     }\n    // }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst int MAX = 10000000;\nint min_factor[MAX+1];\nvector<int>prime;\nvoid make_prime() {\n    for (int i=2; i<=MAX; i+=2) min_factor[i] = 2;\n    for (int i=3; i<=MAX; i+=3) if (!min_factor[i]) min_factor[i] = 3;\n    for (int i=5, d=2; i*i<=MAX; ) {\n\tif (!min_factor[i]) {\n\t    min_factor[i] = i;\n\t    for (int j=i*i; j<=MAX; j+=i)\n\t\tif (!min_factor[j]) min_factor[j] = i;\n\t}\n\ti += d; d = 6 - d;\n    }\n    for (int i=2; i<=MAX; i++) {\n\tif (min_factor[i]==0) min_factor[i] = i;\n\tif (min_factor[i]==i) prime.push_back(i);\n    }\n}\ntypedef unsigned long long ULL;\nULL gcd(ULL x, ULL y) {\n    while (1) {\n\tif (x) y %= x; else return y;\n\tif (y) x %= y; else return x;\n    }\n}\nULL lcm(ULL x, ULL y) {\n    return x / gcd(x, y) * y;\n}\n\nint N;\nconst int SIZE = 500;\nULL A[511][511];\n\nvoid MAIN() {\n    make_prime();\n\n    scanf(\"%d\", &N);\n\n    REP (i, SIZE) REP (j, SIZE) if ((i+j)%2 == 0) {\n\tint p = (i+j)/2, q = (i-j)/2;\n\tA[i][j] = (LL)prime[p%SIZE] * prime[(q+SIZE)%SIZE+SIZE];\n    }\n    REP (i, SIZE) REP (j, SIZE) if ((i+j)%2 == 1) {\n\tULL x = 1;\n\tif (i) x = lcm(x, A[i-1][j]);\n\tif (j) x = lcm(x, A[i][j-1]);\n\tif (i+1<SIZE) x = lcm(x, A[i+1][j]);\n\tif (j+1<SIZE) x = lcm(x, A[i][j+1]);\n\tA[i][j] = x + 1;\n    }\n\n    REP (i, N) rprintf(\"%llu\", A[i], A[i]+N);\n}\n\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> pll;\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _overload2(_1,_2,name,...) name\n#define _re(n) _rep(i,n)\n#define _rep(i,n) _repi(i,0,n)\n#define _repi(i,a,b) for(ll i=a;i<b;++i)\n#define _repc(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_repc,_repi,_rep,_re)(__VA_ARGS__)\n#define _rre(n) _rrep(i,n)\n#define _rrep(i,n) _rrepi(i,0,n)\n#define _rrepi(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrepc(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrepc,_rrepi,_rrep,_rre)(__VA_ARGS__)\n#define rbr(i,a) for(auto&& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0)\n#define _range(i) (i).begin(),(i).end()\n#define _rangek(i,k) (i).begin(),(i).begin()+k\n#define range(...) _overload2(__VA_ARGS__,_rangek,_range)(__VA_ARGS__)\n#define LINF 0x3999999999999999LL\n#define MOD ll(1000000007)\n#define MODD ll(998244353)\n#define INF 0x39999999\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n#define elif else if\n//#define START auto start=system_clock::now()\n//#define END auto end=system_clock::now();cerr<<duration_cast<milliseconds>(end-start).count()<<\" ms\\n\"\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,size) vector<type> name(size);\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vi(name,size,value) vector<ll>name(size,value)\n#define vv(type,name,h,w,value) vector<vector<type>>name(h,vector<type>(w,value))\nstruct aaa{aaa(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};}aaaaaaa;\ntemplate<typename T>\ninline constexpr T gcd (T a,T b) {if(a==b)return a;else return gcd(b,(a-1)%b+1);}\ninline void in() {}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<typename T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<typename T,typename L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<typename T,typename L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<typename T,typename L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<typename T,typename L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <typename T>\ninline void out(T t){cout<<t<<'\\n';}\ninline void out(){cout<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);}\n\n\n\nvv(ll,a,500,500,0);\nint main(){\n    INT(n);\n    int i=2;\n    for(int j=0;j<500;j+=2)for(int k=0;k<500;k+=2,i++)a[j][k]=i;\n    for(int j=1;j<500;j+=2)for(int k=1;k<500;k+=2,i++)a[j][k]=i;\n    for(int j=0;j<500;j+=2)for(int k=1;k<500;k+=2,i++){\n        ll cnt=1;\n        if(0<j)cnt*=a[j-1][k];\n        if(499>j)cnt*=a[j+1][k];\n        if(0<k)cnt*=a[j][k-1];\n        if(499>k)cnt*=a[j][k+1];\n        a[j][k]=cnt+1;\n    }\n    for(int j=1;j<500;j+=2)for(int k=0;k<500;k+=2,i++){\n        ll cnt=1;\n        if(0<j)cnt*=a[j-1][k];\n        if(499>j)cnt*=a[j+1][k];\n        if(0<k)cnt*=a[j][k-1];\n        if(499>k)cnt*=a[j][k+1];\n        a[j][k]=cnt+1;\n    }\n    for(int i=0;i<n;i++){\n        cout<<a[i][0];\n        rep(j,n)cout<<' '<<a[i][j];\n        cout<<endl;\n    }\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for (register int i = l; i <= r; i++)\n#define ford(i, r, l) for (register int i = r; i >= l; i--)\n\ntypedef long long ll;\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\nll N, prime[20003], p_cnt, Need, a[505][505];\n\nint main() {\n  srand(time(0));\n  for (int i = 2; i <= 20000; i++) {\n    bool flag = true;\n    for (int j = 2; j * j <= i && flag; j++)\n      if (i % j == 0) flag = false;\n    if (flag) prime[++p_cnt] = i;\n  }\n  scanf(\"%lld\", &N), Need = N + N - 2;\n  random_shuffle(prime + 1, prime + Need + 1);\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if (!((i + j) & 1)) continue;\n      int x = (i + j) >> 1;\n      int y = ((N - (N & 1)) - (j - i) + 1) >> 1;\n      a[i][j] = prime[x] * prime[N - 1 + y];\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if ((i + j) & 1) continue;\n      a[i][j] = 1;\n      if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n      if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n      if (i < N) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n      if (j < N) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n      a[i][j]++;\n    }\n  }\n  for (int i = 1; i <= N; i++)\n    for (int j = 1; j <= N; j++) printf(\"%lld%c\", a[i][j], \" \\n\"[j == N]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tcout << 2 << ' ';\n\t\t\t} else {\n\t\t\t\tcout << 3 << ' ';\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define MOD 1000000007\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\ntypedef unsigned long long int ull;\ntypedef long long lint;\n\nlint LCM(lint a,lint b){\n  if(a==0 || b==0) return 0;\n  lint tmp,r,x;\n  x=a*b;\n  if(a<b) tmp=a,a=b,b=tmp;\n  r=a%b;\n  while(r!=0) a=b,b=r,r=a%b;\n  x=x/b;\n  return x;\n}\n\nlint GCD(lint a,lint b){\n  if(a==0 || b==0) return max(a,b);\n  else return (a*b)/LCM(a,b);\n}\n\nvector<bool> prime;\nvoid primeinit(int N){\n    if(N+1>prime.size()){\n        prime.resize(N+1,true);\n    } \n    prime[0] = false;\n    prime[1] = false;\n    for(int i=2; i*i<=N;i++) if(prime[i]) for(int j=2; i*j<=N;j++) prime[i*j]=false;\n}\n\n\nint main(void){\n    primeinit(1000000);\n    int N;\n    cin >> N;\n    lint primeno[1000];\n    lint ans[N][N];\n    rep(i,N) rep(j,N) ans[i][j]=1;\n    lint now=0;\n    rep(i,1000){\n        while(!prime[now]) now++;\n        primeno[i]=now;\n        now++;\n    }\n    int no=0;\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n        x=i,y=0;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    for(int i=2;i<N;i++){\n        int x=0,y=i;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n    }\n    for(int i=1;i<N;i++){\n        int x=N-1,y=i;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    rep(i,N) rep(j,N){\n        if(ans[i][j]==1){\n            lint in=1;\n            if(i!=0) in=LCM(in,ans[i-1][j]);\n            if(i!=N-1) in=LCM(in,ans[i+1][j]);\n            if(j!=0) in=LCM(in,ans[i][j-1]);\n            if(j!=N-1) in=LCM(in,ans[i][j+1]);\n            ans[i][j]=in+1;\n        }\n    }\n    rep(i,N){\n        rep(j,N) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned long;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    vector<ULL> P;\n\n    void Primes() {\n        bool Table[10000] = {};\n        Table[0] = Table[1] = true;\n        for (UL i = 2; i <= 100; i++) {\n            if (Table[i]) continue;\n            for (UL j = i * i; j < 10000; j += i) Table[j] = true;\n        }\n        Table[2] = true;\n        for (UL i = 1; P.size() < 1000; i++) if (!Table[i]) P.push_back(i);\n    }\n\n    ULL ans[502][502];\n\n    void Solve() {\n        Primes();\n        rep(i, 502) rep(j, 502) ans[i][j] = 1;\n        rep(i, 500) rep(j, 500) {\n            if ((i ^ j) & 1) continue;\n            ULL tmp = P[(i + j) >> 1] * P[((i + 499 - j) >> 1) + 500];\n            ans[i + 1][j + 1] = tmp;\n            ans[i + 1][j + 2] *= tmp;\n            ans[i + 1][j] *= tmp;\n        }\n        rep(i, 500) rep(j, 500) if ((i ^ j) & 1) ans[i + 1][j + 1]++;\n\n        UL N; cin >> N;\n        rep(i, N) {\n            rep(j, N) {\n                if (j) cout << \" \";\n                cout << ans[i + 1][j + 1];\n            } cout << endl;\n        }\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint prime[maxn],ptot,mark[maxn];\n\ninline void prepare()\n{\n\tREP(i,2,1e5)\n\t{\n\t\tif(!mark[i])prime[++ptot]=i;\n\t\tfor(int j=1,k;j<=ptot && i*prime[j]<=1e5;j++)\n\t\t{\n\t\t\tk=i*prime[j]; mark[k]=1;\n\t\t\tif(!(i%prime[j]))break;\n\t\t}\n\t}\n}\n\nint n;\nll a[520][520];\nint mpa[maxn],mpb[maxn];\n\ninline void init()\n{\n\tint now=6;\n\tn=read();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");exit(0);\n\t}\n\tREP(i,1,n)REP(j,1,n)if(i+j&1)\n\t{\n\t\tif(!mpa[i+j])\n\t\t\tmpa[i+j]=prime[++now];\n\t\tif(!mpb[i-j+n])\n\t\t\tmpb[i-j+n]=prime[++now];\n\t\ta[i][j]=1ll*mpa[i+j]*mpb[i-j+n];\n\t}\n\tREP(i,0,1e4)chkmax(mpa[i],1),chkmax(mpb[i],1);\n\tREP(i,1,n)REP(j,1,n)if(~i+j&1)\n\t{\n\t\ta[i][j]=1ll*mpa[i+j-1]*mpa[i+j+1]*mpb[i-j-1+n]*mpb[i-j+1+n]+1;\n\t}\n\tREP(i,1,n)REP(j,1,n)printf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n}\n\ninline void doing()\n{\n\t\n}\n\nint main()\n{\n\tprepare();\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505;\nconst int dx[4]={0,0,-1,1};\nconst int dy[4]={-1,1,0,0};\nint n;\nll a[N][N],v1[N*2],v2[N*2];\nvector<int>pri;\nint vis[100005];\n\nvoid Init() {\n  for(int i=2;i<=100000;i++) {\n    if(vis[i]) continue;\n    vis[i]=1;\n    pri.push_back(i);\n    for(int j=i*2;j<=100000;j+=i) vis[j]=1;\n  }\n}\n\nll Lcm(ll a,ll b) {\n  ll G=__gcd(a,b);\n  return a/G*b;\n}\n\nint Judge(int x,int y) {\n  if(x<1||x>n||y<1||y>n) return 0;\n  return 1;\n}\n\nint main() {\n  Init();\n  scanf(\"%d\",&n);\n  if(n==2) {\n    puts(\"2 7 \\n13 3\");\n    return 0;\n  }\n  int nw=0;\n  for(int i=1;i<=n;i++) v1[i]=pri[nw],nw++;\n  for(int i=1;i<=n;i++) v2[i]=pri[nw],nw++;\n  for(int i=1;i<=n;i++) {\n    int st=i&1?1:2;\n    for(int j=st;j<=n;j+=2) {\n      int A=(i+j)/2,B=(j-i+n+1)/2;\n      //printf(\"%d %d %d %d\\n\",i,j,A,B);\n      a[i][j]=v1[A]*v2[B];\n    }\n  }\n  //cerr<<\"GG\"<<endl;\n  /*\n  for(int i=1;i<=n;i++) {\n    for(int j=1;j<=n;j++) {\n      printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n    }\n  }\n  */\n  for(int i=1;i<=n;i++) {\n    int st=i&1?2:1;\n    for(int j=st;j<=n;j+=2) {\n      ll V=1;\n      for(int k=0;k<4;k++) {\n\tint nx=i+dx[k],ny=j+dy[k];\n\tif(Judge(nx,ny)) {\n\t  V=Lcm(V,a[nx][ny]);\n\t}\n      }\n      a[i][j]=V+1;\n    }\n  }\n  for(int i=1;i<=n;i++) {\n    for(int j=1;j<=n;j++) {\n      printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e4 + 5;\ntypedef long long ll;\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint tot, prime[MAXN], f[MAXN];\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (f[i] == 0) prime[++tot] = f[i] = i;\n\t\tfor (int j = 1; j <= tot && prime[j] <= f[i]; j++) {\n\t\t\tint tmp = prime[j] * i;\n\t\t\tif (tmp > n) break;\n\t\t\tf[tmp] = prime[j];\n\t\t}\n\t}\n}\nint a[MAXN], b[MAXN];\nint main() {\n\tint n; read(n), sieve(1e4);\n\tint now = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i & 1) a[i] = prime[now];\n\t\telse a[i] = prime[now] * prime[now + 1], now++;\n\t}\n\tnow++;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i & 1) b[i] = prime[now];\n\t\telse b[i] = prime[now] * prime[now + 1], now++;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tprintf(\"%lld \", 1ll * a[i] * b[j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 510\n#define MAXM 10000\nusing namespace std;\ntypedef long long ll;\nint n,cnt;\nll primes[MAXM];\nll a[MAXN][MAXN];\nbool isprime[MAXM+10];\nvoid prepare(){\n\tfor(int i=2;i<=MAXM;i++){\n\t\tif(isprime[i]==0)\n\t\t\tprimes[++cnt]=i;\t\n\t\tfor(int j=1;i*primes[j]<=MAXM;j++){\n\t\t\tisprime[i*primes[j]]=1;\n\t\t\tif(i%primes[j]==0)\n\t\t\t\tbreak;\t\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\t\n}\nll lcm(ll x,ll y){\n\tif(x==0)\n\t\treturn y;\n\tif(y==0)\n\t\treturn x;\n\tll g=gcd(x,y);\n\treturn x/g*y;\n}\nint main(){\n\tprepare();\n\tSF(\"%d\",&n);\n\tint now=1;\n\tif(n==2){\n\t\tPF(\"4 7\\n23 10\\n\");\n\t\treturn 0;\t\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i%2==j%2){\n\t\t\t\tint nowx=(i+j)/2;\n\t\t\t\tint nowy=(i-j+n)/2+n+1;\n\t\t\t\ta[i][j]=primes[nowx]*primes[nowy];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i%2!=j%2){\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1ll;\t\n\t\t\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tPF(\"%d \",a[i][j]);\n\t\tPF(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll a[510][510];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nint main(){\n   int n; cin>>n;\n   bitset<101010> isp;\n   rep(i,2,100000)isp[i]=1;\n   queue<int> ps;\n   rep(i,2,100000)if(isp[i]){\n      for(int j=i*i;j<100000;j+=i)isp[j]=0;\n   }\n   rep(i,2,100000)if(isp[i])ps.push(i);\n   rep(i,0,n)rep(j,0,n)if((i+j)&1){\n      a[i][j]=ps.front(); ps.pop();\n   }\n   rep(i,0,n)rep(j,0,n)if(((i+j)&1)==0){\n      a[i][j]=1;\n      rep(k,0,4){\n         int tx=i+dx[k],ty=j+dy[k];\n         if(tx<0 or tx>=n or ty<0 or ty>=n)continue;\n         a[i][j]*=a[tx][ty];\n      }\n      a[i][j]++;\n   }\n   rep(i,0,n){\n      rep(j,0,n)printf(\"%lld \",a[i][j]);\n      putchar('\\n');\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 1000) t++;\n    rep(i, n) p.eb(P[t++]);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    vll even, odd;\n    rep(i, 125) {\n        even.eb(i * 2 + 2);\n        even.eb(500 - i * 2);\n        odd.eb(i * 2 + 3);\n        odd.eb(501 - i * 2);\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * even[i / 2] / (i / 2 ? even[i / 2 - 1] : 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * even[i / 2 - 1];\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * odd[i / 2] / (i / 2 ? odd[i / 2 - 1] : 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * odd[i / 2 - 1];\n        }\n    }\n    INT(N);\n    map<ll, pii> s;\n    rep(i, N) {\n        // rep(j, N) { cout << a[i][j] << \" \"; }\n        rep(j, N) { s[a[i][j]] = {i, j}; }\n        // cout << endl;\n    }\n    cout << (--s.end())->first << endl;\n    cout << s.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 505\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,num;\nvector<ll> v;\nll mat[MAXN][MAXN];\nint prime[10005],now;\nbool is_prime[10005];\nint sieve(int n)\n{\n    int p=0;\n    memset(is_prime,true,sizeof(is_prime));\n    is_prime[0]=is_prime[1]=false;\n    for(int i=2;i<=n;i++)\n    {\n        if(is_prime[i]) prime[p++]=i;\n        for(int j=0;j<p;j++)\n        {\n            if(prime[j]*i>n) break;\n            is_prime[prime[j]*i]=false;\n            if(i%prime[j]==0) break;\n        }\n    }\n    return p;\n}\nll lcm(ll a,ll b)\n{\n    return a/__gcd(a,b)*b; \n}\nvoid fill_diag_left(int x,int y)\n{\n    while(x<=n&&y<=n)\n    {\n        mat[x][y]*=prime[now];\n        x++;y++;\n    }\n    now++;\n}\nvoid fill_diag_right(int x,int y)\n{\n    while(x<=n&&y>=1)\n    {\n        mat[x][y]*=prime[now];\n        x++;y--;\n    }\n    now++;\n}\nvoid fill()\n{\n    for(ll i=1;i<=n;i++)\n        for(ll j=2-(i&1);j<=n;j+=2)\n            mat[i][j]=1;\n    now=0;\n    for(int i=1;i<=n;i+=2) fill_diag_left(1,i);\n    for(int i=3;i<=n;i+=2) fill_diag_left(i,1);\n    for(int i=1;i<=n;i+=2) fill_diag_right(1,i);\n    for(int i=n;i>=2;i-=2) fill_diag_right(i,n);\n}\nbool check()\n{\n    for(ll i=1;i<=n;i++)\n    {\n        for(ll j=1;j<=n;j++)\n        {\n            if(!mat[i][j])\n            {\n                ll g=1;\n                if(i>1) g=lcm(g,mat[i-1][j]);\n                if(j>1) g=lcm(g,mat[i][j-1]);\n                if(i<n) g=lcm(g,mat[i+1][j]);\n                if(j<n) g=lcm(g,mat[i][j+1]);\n                mat[i][j]=g+1;\n            }\n        }\n    }\n    return true;\n}\nvoid print()\n{\n    for(ll i=1;i<=n;i++)\n    {\n        for(ll j=1;j<=n;j++)\n            printf(\"%lld \",mat[i][j]);\n        puts(\"\");\n    }\n}\nint main()\n{\n    sieve(10000);\n    scanf(\"%lld\",&n);\n    if(n==2)\n    {\n        puts(\"4 7\\n23 10\");\n        return 0;\n    }\n    fill();\n    assert(check());\n    print();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    cout<<\"10 \";\n    ll left, tem, down;\n    for(int i = 1; i < n-1; i++)\n    {\n        tem = 10 + i*10;\n        cout<<tem<<\" \";\n    }\n    left = 10*n+1;\n    cout<<left<<endl;\n    for(int i = 1; i < n-1; i++)\n    {\n        for(int j = 0; j < n-1; j++)\n        {\n            tem = left + 10*i + j;\n            cout<<tem<<\" \";\n        }\n        tem = left * (left + 10*i) + 1;\n        cout<<tem<<endl;\n    }\n    down = left + 10*(n-1);\n    cout<<down<<\" \";\n    for(int i = 1; i < n-1; i++)\n    {\n        tem = down * (10*(i+1)) + 1;\n        cout<<tem<<\" \";\n    }\n    tem = down * left + 1;\n    cout<<tem<<endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MX = 500;\n\nll ans[MX][MX];\n\nll gcd(ll x, ll y) {\n    if (y == 0) {\n        return x;\n    }\n    return gcd(y, x % y);\n}\n\nll lcm(ll x, ll y) {\n    return x / gcd(x, y) * y;\n}\n\nint x[2 * MX];\n\nint y[2 * MX];\n\nbool pr(int x) {\n    for (int i = 2; i < x; i++) {\n        if (x % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    cin >> n;\n    int nx = 2;\n    int cnt = 0;\n\n    for (int i = 0; i < 2 * MX; i++) {\n        if (i % 2 == 1) {\n            x[i] = x[i - 1];\n            continue;\n        }\n        while (!pr(nx)) {\n            nx++;\n        }\n        x[i] = nx++;\n    }\n    for (int i = 0; i < 2 * MX; i++) {\n        while (!pr(nx)) {\n            nx++;\n        }\n        y[i] = nx++;\n    }\n    for (int i = 0; i < MX; i++) {\n        for (int j = 0; j < MX; j++) {\n            if ((i + j) % 2 == 1) {\n                ans[i][j] = x[(i + j)] * y[(MX + i - j)];\n            }\n        }\n    }\n\n    set<ll> was;\n\n    for (int i = 0; i < MX; i++) {\n        for (int j = 0; j < MX; j++) {\n            if ((i + j) % 2 == 0) {\n                ll l = 1;\n                set<ll> xx;\n                auto ad = [&](int r, int c) {\n                    xx.insert(x[r + c]);\n                    xx.insert(y[MX + r - c]);\n                };\n                if (i) {\n                   ad(i - 1, j);\n                }\n                if (j) {\n                    ad(i, j - 1);\n                }\n                if (i + 1 < MX) {\n                    ad(i + 1, j);\n                }\n                if (j + 1 < MX) {\n                    ad(i, j + 1);\n                }\n                for (ll x : xx) {\n                    l *= x;\n                }\n                l++;\n                if (l > 1e15) {\n                    cout << l << endl;\n                }\n                assert(l < 1e15);\n                ans[i][j] = l;\n                if (i) {\n                    assert(ans[i][j] % ans[i - 1][j] == 1);\n                }\n                if (j) {\n                    assert(ans[i][j] % ans[i][j - 1] == 1);\n                }\n                if (i + 1 < MX) {\n                    assert(ans[i][j] % ans[i + 1][j] == 1);\n                }\n                if (j + 1 < MX) {\n                    assert(ans[i][j] % ans[i][j + 1] == 1);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < MX; i++) {\n        for (int j = 0; j < MX; j++) {\n            if (was.count(ans[i][j])) {\n                cout << i << \" \" << j << endl;\n            }\n            was.insert(ans[i][j]);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    cout << \"\\n\";\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n//#define int long long\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long long ll;\n#define X first\n#define Y second\n#define all(o) o.begin(), o.end()\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\nconst int maxn = 2e5 + 10;\nll a[maxn][maxn];\nint dx[] = {-1, +1, 0, 0};\nint dy[] = {0, 0, +1, -1};\nint n;\nset<ll> st;\nbool isin(int x,int y){\n\treturn (x >= 0 && x < n && y >= 0 && y < n);\n}\nvoid doo(int x,int y){\n\tif(a[x][y]) return;\n\tset<ll> s;\n\tfor(int i=0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(isin(nx, ny) && a[nx][ny] != 0)\n\t\t\ts.insert(a[nx][ny]);\n\t}\n\tint ans = 1;\n\tfor(auto x : s)\n\t\tans *= x;\n\tint cur = ans + 1;\n\twhile(1){\n\t\tif(st.find(cur) == st.end()){\n\t\t\ta[x][y] = cur;\n\t\t\tst.insert(cur);\n\t\t\tbreak;\n\t\t}\n\t\tcur += ans;\n\n\t}\n}\nint32_t main(){\n\tIOS;\n\t\n\t//int n;\n\tcin >> n;\n\tint cur = 2;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(i % 2 == j % 2){\n\t\t\t\ta[i][j] = cur;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<n; j++)\n\t\t\tdoo(i, j);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++)\n\t\t\tcout << a[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll ans[1010][1010],n;\nbool vis[10101];\nint tot,p[10101];\ninline void init(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!vis[i]) p[++tot]=i;\n\t\tfor (int j=1;j<=tot;j++){\n\t\t\tif (1ll*i*p[j]>n) break;\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\ninline ll lcm(ll a,ll b){\n\tif (a*b==0) return a+b;\n\treturn a/__gcd(a,b)*b;\n}\nsigned main(){\n\tn=read();\n\tinit(10000);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tans[i][j]=1ll*p[(i+j)/2+n]*p[(i-j)/2+n];\n\t\t\t}\t\t\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2){\n\t\t\t\tans[i][j]=1+lcm(ans[i-1][j],lcm(ans[i][j-1],lcm(ans[i+1][j],ans[i][j+1])));\n\t\t\t}\t\t\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll a[505][505];\nbool chk[23333333];\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint nxtPrime(int&x){\n    auto chk=[&](int x){\n        if(x<2)return false;\n        for(int i=2;i*i<=x;i++)\n            if(x%i==0)\n                return false;\n        return true;\n    };\n    do x++;while(!chk(x));\n    ::chk[x]=true;\n    return x;\n}\nvoid CCC(int n){\n    map<int,pair<int,int>>s;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++){\n            if(s.count(a[i][j])){\n                cout<<s[a[i][j]].first<<\" \"<<s[a[i][j]].second<<\" \"<<i<<\" \"<<j<<\"\\n\";\n                break;\n            }\n            s[a[i][j]]=make_pair(i,j);\n        }\n}\nvoid solve(int n){\n    int p=0;\n    for(int i=1,j=n-(~n&1);i<=n;i++,j--)\n        if(!a[i][j]&&1<=j&&j<=n)\n            a[i][j]=nxtPrime(p);\n    for(int i=n,j=n;i>=1;i--,j--)\n        if(!a[i][j])\n            a[i][j]=nxtPrime(p);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)%2==0){\n                if(a[i][j])continue;\n                auto get=[&](int dx,int dy)->ll{\n                    int x=i,y=j;\n                    while(1<=x&&x<=n&&1<=y&&y<=n){\n                        if(chk[a[x][y]])return a[x][y];\n                        x+=dx,y+=dy;\n                    }\n                    return 1;\n                };\n                a[i][j]=get(+1,+1)*get(+1,-1)*get(-1,+1)*get(-1,-1);\n            }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)%2==1){\n                auto upd=[&](int dx,int dy){\n                    if(a[i+dx][j+dy])\n                        a[i][j]=lcm(a[i][j],a[i+dx][j+dy]);\n                };\n                a[i][j]=1;\n                upd(+1,0);\n                upd(-1,0);\n                upd(0,+1);\n                upd(0,-1);\n                a[i][j]++;\n            }\n}\nint main(){\n    solve(500);\n    int n;cin>>n;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cout<<a[i][j]<<\" \\n\"[j==n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\n#define int long long\n\nint gcd(int x, int y) {\n\treturn (!y) ? x : gcd(y, x % y);\n}\n\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint n, A[N][N], pr[N], cnt;\nbitset <100005> isp;\n\nvoid prework(int tot) {\n\tfor(int i = 1; i < 100005; ++ i) isp[i] = 1;\n\tisp[1] = 0;\n\tfor(int i = 1; cnt < tot; ++ i) {\n\t\tif(isp[i]) pr[++ cnt] = i;\n\t\tfor(int j = 1; j <= cnt && pr[j] * i <= 100000; ++ j) {\n\t\t\tisp[i * pr[j]] = 0;\n\t\t\tif(i % pr[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain() {\n\tisp = 0;\n\tcin >> n;\n\tn += 2;\n\tprework(n * 2 + 2);\n\t//for(int i =1; i <= cnt; ++ i) cerr << pr[i] << \" \";\n\t//puts(\"\");\n\tfor(int i = 0; i <= n + 1; ++ i) {\n\t\tfor(int j = 0; j <= n + 1; ++ j) {\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i = 1; i <= n; i += 2) {\n\t\tint nx = i, ny = 1;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 3; i <= n; i += 2) {\n\t\tint nx = 1, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n; i >= 1; i -= 2) {\n\t\tint nx = n, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n - ((n & 1) ^ 1); i >= 1; i -= 2) {\n\t\tint nx = i, ny = 1;\n\t\tif(i == n) continue;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\t//cerr << i <<\" \" << j << endl;\n\t\t\t\t//cerr << A[i][j - 1] <<\" \" << A[i - 1][j] <<\" \" << A[i + 1][j] <<\" \" << A[i][j + 1] << endl;\n\t\t\t\tA[i][j] = lcm(lcm(A[i][j - 1], A[i - 1][j]), lcm(A[i + 1][j], A[i][j + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2; i <= n - 1; ++ i) {\n\t\tfor(int j = 2; j <= n - 1; ++ j) {\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t\tassert(max(A[i][j], A[i - 1][j]) % min(A[i][j], A[i - 1][j]) == 0);\n\t\t\tassert(max(A[i][j], A[i][j - 1]) % min(A[i][j], A[i][j - 1]) == 0);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 550) t++;\n    rep(i, n) p.eb(P[t++]);\n    shuffle(p);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    vll even, odd;\n    rep(i, 125) {\n        even.eb(i * 2 + 2);\n        even.eb(250 - i * 2);\n        odd.eb(i * 2 + 3);\n        odd.eb(251 - i * 2);\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * even[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * even[i / 2 - 1];\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * odd[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * odd[i / 2 - 1];\n        }\n    }\n    INT(N);\n    map<ll, pii> s;\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        rep(j, N) { s[a[i][j]] = {i, j}; }\n        cout << endl;\n    }\n    // cout << (--s.end())->first << endl;\n    // cout << s.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint n,a[1100][1100];\nint tot,p[110000]; bool vis[110000];\nvoid init(){\n\tvis[1]=true;\n\tfor (int i=2;i<=10000;i++){\n\t\tif (!vis[i]) p[++tot]=i;\n\t\tif (tot==1000) break;\n\t\tfor (int j=1;j<=tot&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=true;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\ninline int lcm(int x,int y){\n\tif (!x||!y) return x|y;\n\treturn x/__gcd(x, y)*y;\n}\nsigned main(){\n\tinit();\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) \n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (((i+j)&1)==0)\n\t\t\t\ta[i][j]=p[(i+j)/2]*p[(i-j+n+1)/2+n];\n\t\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (!a[i][j]) \n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i][j+1],a[i+1][j]))+1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<n;j++) printf(\"%lld \",a[i][j]);\n\t\tprintf(\"%lld\\n\",a[i][n]);\n\t}\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define forn(i, a, n) for(ll i = a; i < n; i++)\n\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\nll a[597][507];\nset<ll> was;\nll n;\n\nll gcd(ll a, ll b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b%a, a);\n}\nint main()\n{\n\t/*\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen (\"output.txt\", \"w\", stdout);\n\t*/\n\tcin >> n;\n\tll co = 1;\n\tforn(i, 0, n)\n\t{\n\t\tforn(j, 0, n)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t\ta[i][j] = co++*2;\n\t\t\twas.insert(a[i][j]);\n\t\t}\n\t}\n\tforn(i, 0, n)\n\t{\n\t\tforn(j, 0, n)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tll le, ri, up, down;\n\t\t\t\tle = j > 0 ? a[i][j - 1] : 1;\n\t\t\t\tri = j < n - 1 ? a[i][j + 1] : 1;\n\t\t\t\tup = i > 0 ? a[i - 1][j] : 1;\n\t\t\t\tdown = i < n - 1 ? a[i + 1][j] : 1;\n\t\t\t\tll mid = le;\n\t\t\t\tmid = mid*ri / gcd(mid, ri);\n\t\t\t\tmid = mid*up / gcd(mid, up);\n\t\t\t\tmid = mid*down / gcd(mid, down);\n\t\t\t\twhile (was.find(mid) != was.end())\n\t\t\t\t{\n\t\t\t\t\tmid <<= 1;\n\t\t\t\t}\n\t\t\t\ta[i][j] = mid;\n\t\t\t}\n\t\t}\n\t}\n\tforn(i, 0, n)\n\t{\n\t\tforn(j, 0, n)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\n#define M 1010\nusing namespace std;\nint a[M][M],vis[N],p[N],ptot;\nvoid init(){\n\tvis[1]=1;\n\tint i=2;\n\twhile (true){\n\t\tif (!vis[i]) p[++ptot]=i;\n\t\tif (ptot==1000) break;\n\t\tfor (int j=1;j<=ptot && (i*p[j]<=10000);++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (!(i%p[j])) break;\n\t\t}\n\t\ti++;\n\t}\n}\nint lcm(int x,int y){\n\tif (x==0 || y==0) return x+y;\n\treturn x/__gcd(x,y)*y;\n}\nsigned main(){\n\tinit();\n\tint n;cin>>n;\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");return 0;\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (!((i+j)&1)) a[i][j]=p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (!a[i][j]) a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i][j+1],a[i+1][j]))+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tprintf(\"%d \",a[i][j]);\n\t\t} \n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=505;\n\nint n,p[N<<1],len;\nLL a[N][N];\nbool b[100005];\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t}\n\tfor(int i=0;i<=n+1;i++)\n\tfor(int j=0;j<=n+1;j++)\n\t\ta[i][j]=1LL;\n\tfor(int i=2;len<2*n;i++){\n\t\tif(!b[i])p[++len]=i;\n\t\tfor(int j=1;j<=len&&p[j]*i<=100000;j++){\n\t\t\tb[p[j]*i]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)a[i][j]*=p[(i+j)>>1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)a[i][j]*=p[((i-j+n+1)>>1)+n];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2){\n\t\t\t\tLL u=a[i+1][j]/__gcd(a[i+1][j],a[i][j+1])*a[i][j+1];\n\t\t\t\tLL v=a[i-1][j]/__gcd(a[i-1][j],a[i][j-1])*a[i][j-1];\n\t\t\t\ta[i][j]=u/__gcd(u,v)*v+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint n;\nlong long f[200001],nw,ans1,ans2,a[200001],x;\n\nint main()\n{\n\tscanf(\"%d%lld\",&n,&x); a[0]=0;\n\tfor (int i=1; i<=n; i++) scanf(\"%lld\",&a[i]);\n\tsort(a+1,a+1+n);\n\tf[n]=0;\n\tfor (int i=0; i<n; i++) f[i]=1000000000000000000ll;\n\tfor (int i=n; i; i--)\n\t\tif (f[i]!=1000000000000000000ll)\n\t\t{\n\t\t\tnw=f[i]+a[i];\n\t\t\tfor (int j=i; j; j--)\n\t\t\t{\n\t\t\t\tans2=nw+1ll*(i-j+2)*(i-j+2)*a[j]+x;\n\t\t\t\tif (ans2<f[j-1]) f[j-1]=ans2;\n\t\t\t\tif (j>1) nw+=1ll*(i-j+2)*(i-j+2)*(a[j]-a[j-1]);\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\\n\",f[0]+1ll*x*n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <stdio.h>\n    #include <string>\n    #include <math.h>\n    #include<algorithm>\n    #include <numeric>\n    using namespace std;\n \n    int main(){\n      long long N;\n      cin >> N;\n      long long a[N+1][N+1]={};\n      a[1][1]=N;\n      for(int i=1;i<N;i++){\n       a[i+1][1]=4*i-1;\n        a[1][i+1]=4*i+1;\n      }\n      for(int i=2;i<=N;i++){\n       for(int j=2;j<=N;j++){\n        a[i][j]=(a[i-1][j])*(a[i][j-1])+1; \n       }\n      }\n      for(int i=1;i<=N;i++){\n       for(int j=1;j<=N;j++){\n        cout << a[i][j];\n         if(j==N){\n          cout << endl; \n         }else{\n          cout << ' '; \n         }\n       }\n      }\n      return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define INF (1ll<<60)\n\n\n\nlong long gcd(long long x, long long y){\n    if(y==0)return x;\n    return gcd(y,x%y);\n}\n\nint main(int argc, char const *argv[]) {\n    int n;cin>>n;\n    set<long long> used;\n    long long M = 3;\n    n+=2*M;\n    vector<vector<long long>> res(n,vector<long long>(n,-1));\n    long long s = 2;\n    for(int i=1;i<n-1;++i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            // if((tmpi==0&tmpk==0)||(tmpi==0&tmpk==4)||(tmpi==4&tmpk==2)||(tmpi==4&tmpk==6)){\n            if((tmpi==0&tmpk==0)||(tmpi==4&tmpk==2)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                while(used.find(s)!=used.end())s+=1;\n            }\n        }\n    }\n    for(int i=n-2;i>0;--i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            if((tmpi==0&tmpk==4)||(tmpi==4&tmpk==6)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i-1][k] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i+1][k] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i][k-1] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i][k+1] = ss;\n                // used.insert(ss);\n                while(used.find(s)!=used.end())s+=1;\n            }\n        }\n    }\n    for(int i=M;i<n-M;++i){\n        for(int k=M;k<n-M;++k){\n            if((i+k)%2==0){\n                long long tmp = 1,tt;\n                tt = res[i+1][k];\n                if(tt!=-1)tmp=(tmp/gcd(tmp,tt))*tt;\n                tt = res[i-1][k];\n                if(tt!=-1)tmp=(tmp/gcd(tmp,tt))*tt;\n                tt = res[i][k+1];\n                if(tt!=-1)tmp=(tmp/gcd(tmp,tt))*tt;\n                tt = res[i][k-1];\n                if(tt!=-1)tmp=(tmp/gcd(tmp,tt))*tt;\n                tt = 1;\n                while(used.find(tt*tmp+1)!=used.end())tt++;\n                res[i][k] = tt*tmp+1;\n                used.insert(tt*tmp+1);\n            }\n        }\n    }\n    for(int i=M;i<n-M;++i){\n        for(int k=M;k<n-M;++k){\n            cout<<res[i][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    // auto itr = used.end();\n    // itr--;\n    // cout<<*itr<<endl;\n    // cout<<*used.begin()<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint p[131072],minp[131072],cnt=0;\nlong long ans[505][505];\nint main()\n{\n\tfor(int i=2;i<=100000;i++)\n\t{\n\t\tif(!minp[i])\n\t\t{\n\t\t\tp[cnt]=i;\n\t\t\tminp[i]=i;\n\t\t\tcnt++;\n\t\t}\n\t\tfor(int j=0;j<cnt&&p[j]<=minp[i]&&(long long)i*p[j]<=100000;j++)\n\t\t{\n\t\t\tminp[i*p[j]]=p[j];\n\t\t}\n\t}\n\tfor(int i=0;i<500;i++)\n\t{\n\t\tfor(int j=0;j<500;j++)\n\t\t{\n\t\t\tint left=i+j;\n\t\t\tint right=i-j+500;\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tans[i][j]=(long long)p[left>>1]*p[(left+1)>>1]*p[(right>>1)+500]*p[((right+1)>>1)+500]+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i][j]=(long long)p[left>>1]*p[(right>>1)+500];\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",ans[i][j]);\n\t\t\tif(j==n-1)\n\t\t\t{\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputchar(' ');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\n\nint x[500];\nint y[500];\nint so[100000]={0};\nvector<int> ve1,ve2,ve;\nint ans[501][501]={0};\nint ban[1010][1010]={0};\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nrandom_device seed_gen;\n  \t\n mt19937 engine(seed_gen());\n  \tfor(int i=2;i<100000;i++)if(so[i]==0){\n  \t\tif(ve1.size()<500)ve1.pb(i);\n  \t\telse ve2.pb(i);\n  \t\tif(ve2.size()==500) break;\n  \t\tfor(int j=i;j<100000;j+=i)so[j]=1;\n  \t}\n  //\tcout<<ve2.back()<<endl;\n  \tint cnt=0;\n  \twhile(1){\n  \t\tshuffle(ve1.begin(), ve1.end(),engine);\n  \t\tshuffle(ve2.begin(), ve2.end(),engine);\n  \t\tcnt++;\n  //\t\tcout<<cnt<<endl;\n  \t\tve.clear();\n  \t\tfor(int i=0;i<500;i++){\n  \t\t\tve.pb(ve1[i]);\n  \t\t\tve.pb(ve2[i]);\n  \t\t}\n  \t\tfor(int i=0;i<=498;i++)for(int j=500;j<=998;j++){\n  \t\t\tif(ve[i]*ve[i+1]*ve[j]*ve[j+1]>1000000000000000ll){\n  \t\t//\tcout<<i<<\" \"<<j-500<<endl;\n  \t\t\t\tgoto lll;\n  \t\t\t}\n  \t\t\t}\n  \t\t\n  \t\tbreak;\n  \t\tlll:;\n  \t}\n  //\tfor(auto v:ve)cout<<v<<endl;\n  \t\n  \tfor(int i=0;i<=500;i++){\n  \t\tif(i==0) x[i]=ve[i];\n  \t\telse if(i==500) x[i]=ve[i-1];\n  \t\telse{\n  \t\t\tx[i]=ve[i]*ve[i-1];\n  \t\t}\n  \t}\n  \t\n  \tfor(int j=0;j<=500;j++){\n  \t\tif(j==0) y[j]=ve[500+j];\n  \t\telse if(j==500)y[j]=ve[j-1+500];\n  \t\telse{\n  \t\t\ty[j]=ve[j+500]*ve[j-1+500];\n  \t\t}\n  \t}\n  \tint n;\n  \tcin>>n;\t\n  \tfor(int i=0;i<=500;i++)for(int j=0;j<=500;j++){\n  \t\tban[2*i][2*j]=x[i]*y[j];\n  \t\tassert(x[2*i]*y[2*j]<=1000000000000000ll);\n  \t}\n  \t\n  \t\n  \t\n  \tfor(int i=0;i<=499;i++)for(int j=0;j<=499;j++){\n  \t\tint g=ban[2*i][2*j];\n  \t\tg=gcd(g,ban[2*i+2][2*j]);\n  \t\tg=gcd(g,ban[2*i][2*j+2]);\n // \t\tg=gcd(g,ban[i+1][j]);\n  \t\tg=gcd(g,ban[2*i+2][2*j+2]);\n  \t\tban[2*i+1][2*j+1]=g;\n  //\t\tcout<<g<<\" \"<<se.size()<<endl;\n  \t//\tassert(se.count(g)==0);\n  //\t\tse.insert(g);\n  \t}\n  \t\n  \tset<int> se;\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++){\n  \t\t\n  \t\tint s=(i+j);\n  \t\tint t=(i-j)+500;\n  \t\tif(ban[s][t]<=0){\n  \t\t\tcout<<i<<\" \"<<j<<endl;\n  \t\t}\n  \t\tassert(ban[s][t]>0);\n  \t\tassert(se.count(ban[s][t])==0);\n  \t\tse.insert(ban[s][t]);\n  \t\t\n  \t\tans[i][j]=ban[s][t];\n  \t}\n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++)if((i+j)%2){\n  \t\t\n  \t\tint g;\n  \t\tif(i==0) g=ban[i+1][j];\n  \t\telse g=ban[i-1][j];\n  \t\t\n  \t\tif(i!=499)g=gcd(g,ban[i+1][j]);\n  \t\tif(i>0)g=gcd(g,ban[i-1][j]);\n  \t\tif(j!=499)g=gcd(g,ban[i][j+1]);\n  \t\tif(j)g=gcd(g,ban[i][j-1]);\n  \t\tans[i][j]=g;\n  \t}\n  \n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef unsigned int uint;\n\nmt19937 rnd(random_device{}());\n\nconst int MAXN = 555;\nll a[MAXN][MAXN];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll gcd(ll a, ll b) {\n    return (b == 0 ? a : gcd(b, a % b));\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    int n;\n    cin >> n;\n    vector<ll> u, v;\n\n\n    for (int k = 3; sz(v) < n; ++k) {\n        bool ok = true;\n        for (int i = 2; i * i <= k; ++i) {\n            if (k % i == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            if (sz(u) < n) {\n                u.push_back(k);\n                u.push_back(k);\n            } else {\n                v.push_back(k);\n                v.push_back(k);\n            }\n        }\n    }\n\n    set<ll> used;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 0) {\n                a[i][j] = u[i] * v[j];\n                if (i % 2 == 1 && j % 2 == 1) {\n                    a[i][j] *= 2;\n                }\n                used.insert(a[i][j]);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                ll cur = 1;\n                for (int k = 0; k < 4; ++k) {\n                    int x = i + dx[k], y = j + dy[k];\n                    if (x < 0 || x >= n || y < 0 || y >= n) {\n                        continue;\n                    }\n                    cur = cur / gcd(cur, a[x][y]) * a[x][y];\n                }\n\n                ll add = cur;\n                ++cur;\n                while (used.count(cur)) {\n                    cur += add;\n                }\n                assert(cur < 1e15);\n                a[i][j] = cur;\n                used.insert(cur);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j]  << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <set>\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void Max(T &x, T y) {\n  if (y > x) x = y;\n}\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\nconst int maxn = 500;\nconst int maxp = 50000;\n\nint n;\nint prime[maxp], cntp;\nbool is[maxp + 1];\n\nli a[maxn][maxn], b[maxn][maxn];\nli ans[maxn][maxn];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  FILLA(is, 1);\n  cntp = 0;\n  for (int i = 2; i <= maxp; ++i) {\n    if (is[i]) {\n      prime[cntp++] = i;\n      for (int j = 2 * i; j <= maxp; j += i) {\n        is[j] = false;\n      }\n    }\n  }\n\n  int next = 1;\n  a[0][0] = prime[next++];\n  if (n & 1) {\n    b[0][n - 1] = prime[next++];\n  } else {\n    b[0][n - 2] = prime[next++];\n    b[1][n - 1] = prime[next++];\n  }\n  for (int i = 2; i < n; i += 2) {\n    a[0][i] = prime[next++];\n    a[i][0] = prime[next++];\n    if (n & 1) {\n      b[0][n - i - 1] = prime[next++];\n      b[i][n - 1] = prime[next++];\n    } else {\n      b[0][n - i - 2] = prime[next++];\n      b[i + 1][n - 1] = prime[next++];\n    }\n  }\n\n  for (int i = 1; i < n; ++i) {\n    for (int j = 1; j < n; ++j) {\n      if (~(i + j) & 1) {\n        a[i][j] = a[i - 1][j - 1];\n      }\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j = n - 2; j >= 0; --j) {\n      if (~(i + j) & 1) {\n        b[i][j] = b[i - 1][j + 1];\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (~(i + j) & 1) {\n        ans[i][j] = a[i][j] * b[i][j];\n      }\n      // printf(\"a(%d, %d) = %d, b = %d, ans = %lld\\n\", i, j, (int)a[i][j], (int)\n      //        b[i][j], ans[i][j]);\n    }\n  }\n\n  const int dx[] = {-1, 0, 1, 0};\n  const int dy[] = {0, 1, 0, -1};\n\n  set<li> S;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if ((i + j) & 1) {\n        ans[i][j] = 1;\n        for (int d = 0; d < 4; ++d) {\n          int i2 = i + dx[d];\n          int j2 = j + dy[d];\n          // printf(\"(%d, %d)\\n\", i2, j2);\n          if (i2 >= 0 && i2 < n && j2 >= 0 && j2 < n) {\n            ans[i][j] = ans[i][j] / __gcd(ans[i][j], ans[i2][j2]) * ans[i2][j2];\n          }\n        }\n      } else {\n        S.insert(ans[i][j]);\n      }\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if ((i + j) & 1) {\n        for (int k = 1; ; ++k) {\n          li t = ans[i][j] * k + 1;\n          if (!S.count(t)) {\n            S.insert(t);\n            ans[i][j] = t;\n            break;\n          }\n        }\n      }\n      printf(\"%lld%c\", ans[i][j], \" \\n\"[j == n - 1]);\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N;\nll A[505][505];\n\nconst int prime_max = 1000000;\nint NP,prime[100000],divp[prime_max];\nmap<int,int> M;\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime[NP++]=i;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll LCM(ll a,ll b) {\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/__gcd(a,b)*b;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\t\n\tcprime();\n\t\n\tvector<int> P[2];\n\tFOR(i,500) {\n\t\tP[0].push_back(prime[i]);\n\t\tP[1].push_back(prime[999-i]);\n\t}\n\t\n\tFOR(y,500) FOR(x,500) if((x+y)%2==0) {\n\t\ti=(x+y)/2;\n\t\tj=(x-y)/2+249;\n\t\tA[y][x]=1LL*P[0][i]*P[1][j];\n\t}\n\tFOR(y,500) FOR(x,500) if((x+y)%2==1) {\n\t\tif(y) A[y][x]=LCM(A[y-1][x],A[y][x]);\n\t\tif(x) A[y][x]=LCM(A[y][x-1],A[y][x]);\n\t\tif(y<499) A[y][x]=LCM(A[y+1][x],A[y][x]);\n\t\tif(x<499) A[y][x]=LCM(A[y][x+1],A[y][x]);\n\t\tA[y][x]++;\n\t}\n\t\n\t\n\tFOR(y,N) {\n\t\tFOR(x,N) cout<<A[y][x]<<\" \";\n\t\tcout<<endl;\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin>>n;\n\tlong long d[1010];\n\td[0]=1;\n\tfor(int i=0;i<(2*n-2);i++){\n\t\td[i+1]=d[i]*2+1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout<<d[i+j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    LL n;\n    cin >> n;\n    vector<vector<LL> > a(n,vector<LL>(n));\n    LL m = 1;\n    set<LL> f;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if((i + j) % 2) {\n                a[i][j] = 5 + i * n + j;\n                f.insert(a[i][j]);\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if((i + j) % 2 == 0){\n                vector<int> dx = {0, 1, 0, -1};\n                vector<int> dy = {1, 0, -1, 0};\n                LL mult = 1;\n                for(int r = 0; r < 4; r++){\n                    LL ni = i + dx[r];\n                    LL nj = j + dy[r];\n                    if(ni < 0 || nj < 0 || ni >= n || nj >= n) continue;\n                    LL g = __gcd(mult, a[ni][nj]);\n                    mult = mult * a[ni][nj] / g;\n                }\n                for(LL q = 1; ; q++){\n                    if(f.find(mult * q + 1) == f.end()){\n                        a[i][j] = mult * q + 1;\n                        f.insert(a[i][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << x << std::endl\nusing ll = long long;\nconstexpr int N = 500;\nconstexpr int MAX = 16 * N;\nconstexpr int NUM = 2 * N - 1;\nbool isprime[16 * N];\nll p1[N][N], p2[N][N], ans[N][N];\nstd::mt19937 mt{std::random_device{}()};\nbool check(const int N)\n{\n    std::set<ll> st;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            st.insert(ans[i][j]);\n            if (ans[i][j] < 1 and ans[i][j] > 1000000000000000LL) { return false; }\n        }\n    }\n    return st.size() == N * N;\n}\n\nint main()\n{\n    std::fill(isprime, isprime + MAX, true);\n    std::vector<ll> prime;\n    for (int i = 2; i < MAX; i++) {\n        if (not isprime[i]) { continue; }\n        prime.push_back(i);\n        if (prime.size() == NUM) { break; }\n        for (int j = 2; i * j < MAX; j++) { isprime[i * j] = false; }\n    }\n    for (int i = 0; i < 2 * N; i += 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = i - y;\n            if (x < 0 or N <= x) { continue; }\n            p1[y][x] = prime[i / 2];\n        }\n    }\n    for (int i = N - 2; i >= -N + 2; i -= 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = y + i;\n            if (x < 0 or N <= x) { continue; }\n            p2[y][x] = prime[(i + N - 2) / 2 + N];\n        }\n    }\n\n    auto get = [&](const int y, const int x) { return y >= 0 and y < N and x >= 0 and x < N ? std::pair<ll, ll>{p1[y][x], p2[y][x]} : std::pair<ll, ll>{1LL, 1LL}; };\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i % 2 == j % 2) {\n                ans[i][j] = p1[i][j] * p2[i][j];\n            } else {\n                std::set<ll> p;\n                p.insert({get(i - 1, j).first,\n                          get(i - 1, j).second,\n                          get(i + 1, j).first,\n                          get(i + 1, j).second,\n                          get(i, j - 1).first,\n                          get(i, j - 1).second,\n                          get(i, j + 1).first,\n                          get(i, j + 1).second});\n                ans[i][j] = 1;\n                for (const ll P : p) { ans[i][j] *= P; }\n                ans[i][j]++;\n            }\n        }\n    }\n    assert(check(N));\n    int N;\n    std::cin >> N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            std::cout << ans[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define ll long long\nusing namespace std;\nconst int N=50005;\nint n,p[N],vis[N],cnt,now; ll a[505][505],v1[N],v2[N];\nll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nvoid init(int n){\n\trep (i,2,n){\n\t\tif (!vis[i]) p[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n); init(10000);\n\trep (i,1,n) a[i][0]=a[i][n+1]=a[0][i]=a[n+1][i]=1;\n\tnow=1;\n\tfor (int i=1+1;i<=n+n;i+=2) v1[i]=p[now++];\n\tfor (int i=(n&1)?1-n:2-n;i<=n-1;i+=2) v2[i+n]=p[now++];\n\trep (i,1,n) rep (j,1,n) if (!((i+j)&1)) a[i][j]=v1[i+j]*v2[i-j+n];\n\trep (i,1,n) rep (j,1,n) if ((i+j)&1) a[i][j]=lcm(lcm(a[i][j-1],a[i][j+1]),lcm(a[i-1][j],a[i+1][j]))+1;\n\trep (i,1,n){rep (j,1,n) printf(\"%lld \",a[i][j]); puts(\"\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 101000;\nint g[N],pri[N],tot;\nll f[1010][1010],p1[1010],p2[1010];\nvoid init(){\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!g[i]){pri[++tot]=i;g[i]=i;}\n\t\tfor(int j=1;pri[j]*i<=10000;j++){\n\t\t\tg[pri[j]*i]=pri[j];\n\t\t\tif(pri[j]==g[i]) break; \n\t\t}\n\t}\n\tint k1=0,k2=0;\n\tfor(int i=1;i<=1100;i++)\n\t\tif(i&1) p1[++k1]=pri[i];\n\t\telse p2[++k2]=pri[i];\n\tsrand(3284792);\n\trandom_shuffle(p1+1,p1+k1+1);\n\trandom_shuffle(p2+1,p2+k2+1);\n}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i+j&1){\n\t\t\t\tint k=i+j>>1;\n\t\t\t\tf[i][j]=p1[k];\n\t\t\t\tk=i+(n-j+1)>>1;\n\t\t\t\tf[i][j]*=p2[k];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(~(i+j)&1){\n\t\t\t\tf[i][j]=lcm(f[i][j-1],lcm(f[i][j+1],lcm(f[i-1][j],f[i+1][j])));\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<f[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MaxN = 5e2 + 17;\nlong long arr[MaxN][MaxN];\nlong long prime[4 * MaxN];\nlong long second_matrix[MaxN][MaxN];\nint x[] = {-1, 1, 0, 0};\nint y[] = {0, 0, -1, 1};\nint n = 505;\nmap<long long, bool> mp;\n\nlong long lcm(long long a, long long b)\n{\n    return (a * b) / __gcd(a, b);\n}\n\nvoid erich()\n{\n    const int MaxS = 2e4 + 17;\n    bool isPrime[MaxS];\n\n    for(int i = 1; i < MaxS; ++i)\n        isPrime[i] = 1;\n\n    int next = 1;\n\n    for(int i = 2; i < MaxS; ++i)\n    {\n        if(isPrime[i])\n        {\n            prime[next++] = i;\n\n            for(int j = i + i; j < MaxS; j += i)\n                isPrime[j] = 0;\n\n        }\n    }\n}\n\nvoid fill_sec()\n{\n    for(int i = n - !(n % 2), j = 1; i >= 1; i -= 2, ++j)\n    {\n        int x = i;\n        int y = 1;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + j];\n            ++x;\n            ++y;\n        }\n    }\n\n    for(int i = 3, j = 1; i <= n; i += 2, ++j)\n    {\n        int x = 1;\n        int y = i;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + n / 2 +  n % 2 + j];\n            ++x;\n            ++y;\n        }\n    }\n}\n\nvoid fill_matrix()\n{\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if(!((i + j) & 1))\n                arr[i][j] = prime[(i + j) / 2] * second_matrix[i][j];\n\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if((i + j) & 1)\n            {\n                arr[i][j] = 1;\n\n                for(int k = 0; k < 4; ++k)\n                {\n                    int xx = i + x[k];\n                    int yy = j + y[k];\n\n                    if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                        arr[i][j] = lcm(arr[i][j], arr[xx][yy]);\n                }\n            }\n\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    erich();\n    fill_sec();\n    fill_matrix();\n\n    int m;\n    cin >> m;\n\n    for(int i = 1; i <= m; ++i)\n    {\n        for(int j = 1; j <= m; ++j)\n            cout << arr[i][j] << ' ';\n        cout << '\\n';\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 3000; \nconst long long INF = 0x3f3f3f3f; \n\nint cnt, idx, n; \nlong long ans[550][550], elm[Maxv], max = -INF; \nlong long x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void pre_Opt() {\n    int num; \n    for (int i = 2;; i++) {\n        for (num = 2; num * num <= i; num++) {\n            if (i % num == 0) break; \n        }\n\n        if (num * num > i) elm[++cnt] = i; \n        if (cnt >= Maxv) break; \n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    pre_Opt(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", elm[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = elm[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= elm[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  auto lcm = [](lint x, lint y) { return x * y / __gcd(x, y); };\n  VV<lint> a; assign(a, n, n, 1LL);\n  for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (i + j & 1) a[i][j] = (i * n + j + 4) / 2;\n  const V<> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n  for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (~(i + j) & 1) {\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 or ni >= n or nj < 0 or nj >= n) continue;\n      a[i][j] = lcm(a[i][j], a[ni][nj]);\n    }\n  }\n  for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (~(i + j) & 1) a[i][j]++;\n  for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) cout << a[i][j] << (j != n - 1 ? ' ' : '\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cstdio>\n#include<cassert>\n#include<iostream>\nusing namespace std;\nint n;\nconst int N = 60000;\nbool f[N];\nvector<int> p;\n#define i64 long long int\ni64 a[1002][1002];\nvoid init(){\n\tfor(int i=2; i<N; i++){\n\t\tif(!f[i])p.push_back(i);\n\t\tfor(auto y : p){\n\t\t\tint x = y * i;\n\t\t\tif(x>=N)break;\n\t\t\tf[x] = true;\n\t\t\tif(i%y==0)break;\n\t\t}\n\t}\n\treverse(p.begin(), p.end());\n\tp.resize(5002);\n}\ni64 gen(i64 ff,int t){\n\tif(ff > 0)\n\t\treturn ff * p[t];\n\telse{\n\t\tff = -ff;\n\t\treturn ff * (ff+1) * p[t] * p[t+1] + 1;\n\t}\n}\nbool chk(i64 x,i64 y){\n\tif(x>y)swap(x,y);\n\treturn y%x==1;\n}\nset<i64> s;\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\tfor (int i = 2, ff = 1; i <= 2 * n; i++) {\n\t\tint mid = labs(ff) + 2501;\n\t\tfor (int x = 1; x < i; x++) {\n\t\t\ta[x][i - x] = gen(ff, mid);\n\t\t\tmid--;\n\t\t}\n\t\tif (ff > 0) ff = -ff;else\n\t\t\tff = -ff + 1;\n\t}\n\tios::sync_with_stdio(false);\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++){\n\t\ts.insert(a[i][j]);\n\t\tif(i<n)assert(chk(a[i][j], a[i+1][j]));\n\t\tif(j<n)assert(chk(a[i][j],a[i][j+1]));\n\t\tcout << a[i][j] << (j < n ? ' ' : '\\n');\n\t}\n\tassert(s.size() == n*n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\nusing namespace std;\ntypedef long long ll;\nint pr[101010];\nll ans[555][555];\nll gcd(ll a, ll b)\n{\n\tfor (;;)\n\t{\n\t\tif (a < b)swap(a, b);\n\t\ta %= b;\n\t\tif (a == 0)return b;\n\t}\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0 || b == 0)return max(a, b);\n\treturn a*b / gcd(a, b);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tdeque<ll>v;\n\tfor (int i = 2; i <= 10000; i++)\n\t{\n\t\tif (pr[i] == 0)\n\t\t{\n\t\t\tfor (int j = i + i; j <= 10000; j += i)pr[j] = -1;\n\t\t\tif (i >= 30 && v.size() < num * 2 + 100)v.push_back(i);\n\t\t}\n\t}\n\tdeque<ll>x, y;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i % 4 == 0)x.push_back(v[i]);\n\t\tif (i % 4 == 1)x.push_front(v[i]);\n\t\tif (i % 4 == 2)y.push_back(v[i]);\n\t\tif (i % 4 == 3)y.push_front(v[i]);\n\t}\n\tfor (int i = 0; i < num + 5; i++)\n\t{\n\t\tfor (int j = 0; j < num + 5; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tans[i][j] = x[(i + j) / 2] * y[(i - j + num + 5) / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tfor (int j = 1; j <= num; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 != 0)\n\t\t\t{\n\t\t\t\tll t = x[(i + j - 1) / 2] * y[(i - j + num + 5 - 1) / 2] * x[(i + j + 1) / 2] * y[(i - j + num + 5 + 1) / 2];\n\t\t\t\tans[i][j] = t + 1;\n\t\t\t}\n\t\t\tif (ans[i][j]>1000000000000000LL)abort();\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<list>\n#include<deque>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1000)\nvector<int>prim;\n\nvoid prim_make(int k){\n\tif (k >= 2)prim.push_back(2);\n\tif (k >= 3)prim.push_back(3);\n\tif (k >= 5)prim.push_back(5);\n\tint x = 7;\n\tbool v;\n\twhile (x <= k){\n\t\tv = true;\n\t\tfor (int i = 2; prim[i] * prim[i] <= x; i++){\n\t\t\tif (x%prim[i] == 0){\n\t\t\t\tv = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v)prim.push_back(x);\n\t\tif (x % 6 == 1)x += 4;\n\t\telse x += 2;\n\t}\n\treturn;\n}\n\n\n\n\n\n\nint main(){\n\tlong long a[N][N];\n\tset<long long>s;\n\tint n;\n\tlong long k, x, y, z;\n\tlong long ans;\n\tbool v = true;\n\tprim_make(100000);\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tk = 2;\n\tf(i, n){\n\t\tf(j, n)a[i][j] = -1;\n\t}\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif ((i + j) % 2 == 0){\n\t\t\t\ta[i][j] = k;\n\t\t\t\ts.insert(k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif (a[i][j] == -1){\n\t\t\t\tans = 1;\n\t\t\t\tif (i > 0)ans = ans*a[i - 1][j];\n\t\t\t\tif (i<(n-1))ans = ans*a[i + 1][j];\n\t\t\t\tif (j > 0)ans = ans*a[i][j-1];\n\t\t\t\tif (j<(n - 1))ans = ans*a[i][j+1];\n\t\t\t\tx = 0;\n\t\t\t\twhile (s.count((ans + 1)) == 1){\n\t\t\t\t\tif (x > 0)ans = ans / prim[x];\n\t\t\t\t\tans = ans*prim[x];\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\ta[i][j] = ans + 1;\n\t\t\t\ts.insert((ans + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < (n - 1))printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 5e5 + 50;\n\nint n;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tif (n & n - 1)\n\t{\n\t\tprintf(\"Yes\\n1 2\\n2 3\\n3 %d\\n%d %d\\n%d %d\\n\", n + 1, n + 1, n + 2, n + 2, n + 3);\n\t\tfor (int k = 4; k < n; k += 2) printf(\"%d %d\\n%d %d\\n%d %d\\n%d %d\\n\", n + 1, k, n + 1, k + 1, k, k + n + 1, k + n, k + 1);\n\t\tif ((n & 1) == 0)\n\t\t{\n\t\t\tint c = n + 1, j = 2;\n\t\t\tstd::function<bool(int)> valid = [&](int u) { return 2 <= u && u <= n; };\n\t\t\twhile (!valid(c ^ j)) ++j;\n\t\t\tif (j == 2) j += n;\n\t\t\tprintf(\"%d %d\\n%d %d\\n\", j, n, c ^ j, n << 1);\n\t\t}\n\t}\n\telse puts(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 1000) t++;\n    rep(i, n) p.eb(P[t++]);\n    shuffle(p);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    vll even, odd;\n    rep(i, 125) {\n        even.eb(i * 2 + 2);\n        even.eb(500 - i * 2);\n        odd.eb(i * 2 + 3);\n        odd.eb(501 - i * 2);\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * even[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * even[i / 2 - 1];\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * odd[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * odd[i / 2 - 1];\n        }\n    }\n    INT(N);\n    map<ll, pii> s;\n    rep(i, N) {\n        // rep(j, N) { cout << a[i][j] << \" \"; }\n        rep(j, N) { s[a[i][j]] = {i, j}; }\n        // cout << endl;\n    }\n    cout << (--s.end())->first << endl;\n    cout << s.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair < int, int > PII;\ntypedef pair < LL, LL > PLL;\ntypedef pair < LD, LD > PDD;\n\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntemplate < typename _T > inline void _DBG(const char *s, _T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate < typename _T, typename... args > void _DBG(const char *s, _T x, args... a) { while(*s != ',') cerr << *s++; cerr << \" = \" << x << ','; _DBG(s + 1, a...); }\n\n#ifdef LOCAL\n#define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0) cout\n#endif\n\n// ********************** CODE ********************** //\n\nconst int N = 500;\n\nLL pri[] = {1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901};\n\nLL T[N][N];\nunordered_set < LL > S;\n\nLL nwd(LL a, LL b)\n{\n    if(b == 0) return a;\n    return nwd(b, a % b);\n}\n\nLL nww(LL a, LL b)\n{\n    return a / nwd(a, b) * b;\n}\n\nint main()\n{\n    _upgrade\n    int l = 0, r = 505; \n    for(int i = 0; i <= 2 * N; i += 2)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if(0 <= k && k < N)\n            {\n                T[j][k] = pri[((i / 2) & 1 ? r : l)];\n            }\n        }\n        if((i / 2) & 1)\n            l++;\n        else\n            r--;\n    }\n    LL st = N / 2;\n    for (int i = 0; i <= 2 * N; i += 2)\n    {\n        LL p = st;\n        for (int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if (0 <= k && k < N)\n            {\n                T[j][k] *= p;\n                S.insert(T[j][k]);\n                p++;\n            }\n        }\n        if(i + 2 < N)\n            st--;\n        else if(i + 2 > N)\n            st++;\n    }\n    LL lim = 1e15;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(T[i][j] != 0) continue;\n            vector < LL > v;\n            if(i > 0)\n                v.push_back(T[i - 1][j]);\n            if(j > 0)\n                v.push_back(T[i][j - 1]);\n            if(i + 1 < N)\n                v.push_back(T[i + 1][j]);\n            if(j + 1 < N)\n                v.push_back(T[i][j + 1]);\n            LL can = 0;\n            if(sz(v) == 1)\n            {\n                can = v[0];\n            }\n            else if(sz(v) == 2)\n            {\n                can = nww(v[0], v[1]);\n            }\n            else if(sz(v) == 3)\n            {\n                can = nww(v[0], nww(v[1], v[2]));\n            }\n            else\n            {\n                can = nww(v[0], nww(v[1], nww(v[2], v[3])));\n            }\n            LL cp = can;\n            while(can + 1 <= lim && S.find(can + 1) != S.end())\n            {\n                can += cp;\n            }\n            S.insert(can + 1);\n            T[i][j] = can + 1;\n        }\n    }\n    int n; cin >> n;\n    for(int  i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\ngod taekyu\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n;\nll A[505][505];\nint cieve[10000005];\nint p[1500000], pcnt;\nint B[505][505];\npii ord1[250005], ord2[250005];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin>>n;\n    for(int i=2;i<=1700004;i++) {\n        if(cieve[i] == 0) {\n            p[pcnt++] = i;\n            for(int j=i*2;j<1700005;j+=i) {\n                cieve[j] = 1;\n            }\n        }\n    }\n    int cnt = 0;\n    int dx[4] = {0,1,0,-1};\n    int dy[4] = {1,0,-1,0};\n    int ni = 1, nj = 1, idx = 0;\n    while(1) {\n        if(B[ni][nj] != 0) break;\n        B[ni][nj] = ++cnt;\n        int lcnt = 0;\n        while(1) {\n            lcnt++;\n            int nni = ni + dx[idx];\n            int nnj = nj + dy[idx];\n            if(1<=nni && nni <= n && 1<=nnj && nnj<=n && B[nni][nnj] == 0 || lcnt >=6) {\n                ni = nni;\n                nj = nnj;\n                break;\n            }\n            idx++; idx %= 4;\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if(( max(abs((n+1)/2-i) , abs((n+1)/2-j)) ) % 2) ord1[B[i][j]] = pii(i,j);\n            else ord2[B[i][j]] = pii(i,j);\n        }\n    }\n    for(int i=0;i<=n+1;i++) {\n        A[0][i] = A[i][0] = A[n+1][i] = A[i][n+1] = 1;\n    }\n    cnt = 0;\n    for(int x=n*n;x>=1;x--) {\n        int i = ord2[x].first;\n        int j = ord2[x].second;\n        if(i==0) continue;\n        if((i+j)%2 == 0) {\n            A[i][j] = (ll)p[cnt++];\n        }\n    }\n    for(int x=n*n;x>=1;x--) {\n        int i = ord1[x].first;\n        int j = ord1[x].second;\n        if(i==0) continue;\n        if((i+j)%2 == 0) {\n            A[i][j] = (ll)p[cnt++];\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2 == 1) {\n                A[i][j] = (A[i-1][j]) * A[i+1][j] * A[i][j-1] * A[i][j+1] + 1;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            cout<<A[i][j]<<' ';\n        }\n        cout<<'\\n';\n    }\n    return 0;\n}\n\n/*\ngod taekyu\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int MAX = 10010;      // 素数判定する最大の数\nbool IsPrime[MAX];\nvector<int> Era(int n = MAX) {\n    vector<int> res;\n    IsPrime[0] = false; IsPrime[1] = false;\n    for (int i = 2; i < n; ++i) IsPrime[i] = true;\n    for (int i = 2; i < n; ++i) {\n        if (IsPrime[i]) {\n            res.push_back(i);\n            for (int j = i*2; j < n; j += i) IsPrime[j] = false;\n        }\n    }\n    return res;\n}\n\nlong long GCD(long long a, long long b) {\n    if (b == 0) return a;\n    else return GCD(b, a % b);\n}\n\nlong long LCM(long long a, long long b) {\n    long long g = GCD(a, b);\n    return a / g * b;\n}\n\nint main() {\n    int N; cin >> N;\n    vector<vector<long long> > res(N, vector<long long>(N, 0));\n    vector<int> primes = Era();\n    for (int wa = 0; wa <= N*2; wa += 2) {\n        for (int sa = -N/2*2; sa <= N/2*2; sa += 2) {\n            if ((wa + sa) & 1) continue;\n            int i = (wa + sa) / 2;\n            int j = (wa - sa) / 2;\n            if (i < 0 || i >= N || j < 0 || j >= N) continue;\n            if ((i + j) & 1) continue;\n            res[i][j] = primes[wa/2] * primes[(sa + N/2*2)/2 + N];\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if ((i + j) % 2 == 0) continue;\n            long long L = 1;\n            for (int k = 0; k < 4; ++k) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni < 0 || ni >= N || nj < 0 || nj >= N) continue;\n                L = LCM(L, res[ni][nj]);\n            }\n            res[i][j] = L + 1;\n        }\n    }\n    if (N == 2) res[0][1] = res[1][0]*2-1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cout << res[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long int LL;\nconst int Max_N(505);\nconst int Max_S(10000000);\nconst int dx[] = {+1, -1, +0, +0};\nconst int dy[] = {+0, +0, +1, -1};\n\nconstexpr LL gcd(LL a, LL b)\n{\n\treturn b == 0LL ? a : gcd(b, a % b);\n}\n\nconstexpr LL lcm(LL a, LL b)\n{\n\treturn a == 0LL ? b : a / gcd(a, b) * b;\n}\n\nint N, ps, P[Max_S];\nLL A[Max_N][Max_N];\nbool Prime[Max_S];\n\nint main()\n{\n\tmemset(Prime, true, sizeof(Prime)), Prime[0] = Prime[1] = false;\n\tfor (int i = 2;i < Max_S;++i)\n\t{\n\t\tif (Prime[i])\n\t\t\tP[++ps] = i;\n\t\tfor (int j = 1, x;j <= ps && (x = i * P[j]) < Max_S;++j)\n\t\t{\n\t\t\tPrime[x] = false;\n\t\t\tif (x % P[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tprintf(\"%d %d\\n\", 4, 7);\n\t\tprintf(\"%d %d\\n\", 23, 10);\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tA[i][j] = P[(i + j) >> 1] * 1LL * P[N + (i - j) / 2 + (N + 1) / 2];\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tfor (int k = 0, x, y;k < 4;++k)\n\t\t\t\t\tif (1 <= (x = i + dx[k]) && x <= N && 1 <= (y = j + dy[k]) && y <= N)\n\t\t\t\t\t\tA[i][j] = lcm(A[i][j], A[x][y]);\n\t\t\t\t++A[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=505;\nconst int M=4*N;\nconst int S=10000;\nint pr[M],psz;\nbool sieve[S];\nll val[N][N];\nvector<pair<int,int> > id;\nint Find(pair<int,int> x){ return lower_bound(id.begin(),id.end(),x)-id.begin()+1;}\nint main()\n{\n\tint i,j;\n\tfor(i=2;i<S;i++) if(!sieve[i]){ pr[++psz]=i;for(j=i;j<S;j+=i) sieve[j]=1;}\n\tint n;\n\tscanf(\"%i\",&n);\n\tif(n==2) return 0*printf(\"4 7\\n23 10\\n\");\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n\t\tint a=i+j,b=i-j;\n\t\tid.pb(mp(1,a));\n\t\tid.pb(mp(2,b));\n\t}\n\tsort(id.begin(),id.end());\n\tid.erase(unique(id.begin(),id.end()),id.end());\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n        int a=Find(mp(1,i+j));\n        int b=Find(mp(2,i-j));\n        val[i][j]=(ll)pr[a]*pr[b];\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if(!((i+j)&1))\n\t{\n\t\tval[i][j]=1;\n\t\tif(i-1>0 || j+1<=n) val[i][j]*=pr[Find(mp(2,i-j-1))];\n\t\tif(i+1<=n || j-1>0) val[i][j]*=pr[Find(mp(2,i-j+1))];\n\t\tif(i-1>0 || j-1>0) val[i][j]*=pr[Find(mp(1,i+j-1))];\n\t\tif(i+1<=n || j+1<=n) val[i][j]*=pr[Find(mp(1,i+j+1))];\n\t\tval[i][j]++;\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) printf(\"%lld%c\",val[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << '\\n';\n#else\n\t#define DBG(X)\n#endif\n \nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline void goodbye(const T& val) { cout << val << endl; exit(0); }\n\nconst int MAXN     = 543;\n\nll GCD(ll x, ll y) {\n\treturn (x == 0 ? y : GCD(y % x, x));\n}\n\nll LCM(ll x, ll y) {\n\treturn (x / GCD(x, y)) * y;\n}\n\nll answ[MAXN][MAXN];\nint n;\n\nconst int NDIRS = 4;\nconst int di[] = {0, 0, -1, 1};\nconst int dj[] = {-1, 1, 0, 0};\n\nint valid(int i, int j) {\n\treturn (i >= 0 && j >= 0 && i < n && j < n);\n}\n\nvoid solve() {\n\tcin >> n;\n\tset<ll> setik;\n\n\tconst ll m = 1;\n\tll last = m + 1;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tint t = (i + j) & 1;\n\n\t\t\tif(t == 0) {\n\t\t\t\tansw[i][j] = last++;\n\t\t\t\tsetik.insert(answ[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tint t = (i + j) & 1;\n\n\t\t\tif(t == 1) {\n\t\t\t\tvector<ll> neighbors;\n\n\t\t\t\tfor(int dir = 0; dir < NDIRS; ++dir) {\n\t\t\t\t\tint i2 = i + di[dir], j2 = j + dj[dir];\n\n\t\t\t\t\tif(valid(i2, j2)) {\n\t\t\t\t\t\tneighbors.push_back(answ[i2][j2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tll l = neighbors.front();\n\n\t\t\t\tfor(auto& elem: neighbors) {\n\t\t\t\t\tl = LCM(l, elem);\n\t\t\t\t}\n\n\t\t\t\tll cur = l + m;\n\n\t\t\t\twhile(setik.count(cur)) {\n\t\t\t\t\tcur += l;\n\t\t\t\t}\n\n\t\t\t\tansw[i][j] = cur;\n\t\t\t\tsetik.insert(answ[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tcout << answ[i][j] << ' ';\n\t\t}\n\n\t\tcout << '\\n';\n\t}\n\n#ifdef __LOCAL\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tfor(int dir = 0; dir < NDIRS; ++dir) {\n\t\t\t\tint i2 = i + di[dir], j2 = j + dj[dir];\n\n\t\t\t\tif(valid(i2, j2)) {\n\t\t\t\t\tll mx = answ[i][j];\n\t\t\t\t\tll mn = answ[i2][j2];\n\n\t\t\t\t\tif(mx < mn) {\n\t\t\t\t\t\tswap(mx, mn);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(mx % mn != m) {\n\t\t\t\t\t\tcout << \"BAD: \" << i << ' ' << j << ' ' << i2 << ' ' << j2 << '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(answ[i][j] > (ll)1e15) {\n\t\t\t\tcout << \"BAD2: \" << i << ' ' << j << '\\n';\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define I64d_OJ\n\n//#ifdef I64d_OJ\n//#define LL __int64\n//#endif // I64d_OJ\n#ifdef I64d_OJ\n#define LL long long\n#endif // I64d_OJ\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vi;\n\ninline LL read(){\n    LL x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define ls rt<<1\n#define rs rt<<1|1\n#define MID(a,b) (((LL)(a)+(LL)(b))>>1)\n#define absx(a) ((a)<0?-(a):(a))\n#define MK(a,b) make_pair(a,b)\n#define PB(a) push_back(a)\n#define lowbit(x) ((x)&-(x))\n\ntemplate< typename T >\ninline void Max(T &a,T &b){if(a<b) a=b;}\ntemplate< typename T>\ninline void Min(T &a,T &b){if(a>b) a=b;}\n\nconst double pi=(double)acos(-1.0);\nconst double eps=(double)1e-10;\nconst int INF = (int) 0x3f3f3f3f;\nconst int MOD = (int) 1e9+7;\nconst int MAXN =(int) 5e2+10;\nconst int MAXM = (int) 2e5+10;\nconst int sigma_size = (int) 26;\n\n///--------------------START-------------------------\nLL a[MAXN][MAXN];\nconst int N = (int) 2e5 +10;\nint prime[N],phi[N],cnt;// prime:记录质数，phi记录欧拉函数\nint Min_factor[N];// i的最小素因子\nbool vis[N];\nvoid Init()\n{\n    cnt=0;\n    phi[1]=1;\n    int x;\n    for(int i=2;i<N;i++)\n    {\n        if(!vis[i])\n        {\n            prime[++cnt]=i;\n            phi[i]=i-1;\n            Min_factor[i]=i;\n        }\n        for(int k=1;k<=cnt&&prime[k]*i<N;k++)\n        {\n            x=prime[k]*i;\n            vis[x]=true;\n            Min_factor[x]=prime[k];\n            if(i%prime[k]==0)\n            {\n                phi[x]=phi[i]*prime[k];\n                break;\n            }\n            else phi[x]=phi[i]*(prime[k]-1);\n        }\n    }\n}\n\nLL gcd(LL x,LL y){\n    return x==0 ? y : gcd(y%x,x);\n}\n\nvoid work(){\n    int n=500;\n    for(int i=0;i<=n+1;i++){\n        for(int j=0;j<=n+1;j++){\n            a[i][j]=1;\n        }\n    }\n    Init();\n    int p=1;\n    for(int i=2;i<=500;i+=2) a[1][i]=++p;\n    for(int i=1;i<=500;i+=2) a[2][i]=++p;\n    for(int i=3;i<=n;i++){\n        int x=(i+1)/2;\n        for(int j=1;j<=n;j++)if(a[i-2][j]>1){\n            a[i][j]=a[i-2][j]/(x-1)*x;\n        }\n    }\n    int mi=0;\n    LL mx=0;\n//    for(int i=1;i<=5;i++){\n//        for(int j=1;j<=5;j++){\n//            printf(\"%lld \",a[i][j]);\n//        }\n//        printf(\"\\n\");\n//    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++)if(a[i][j]==1){\n            LL g1=gcd(a[i-1][j],a[i][j-1]);\n            LL g2=gcd(a[i+1][j],a[i][j+1]);\n            LL t1=a[i-1][j]*a[i][j-1]/g1;\n            LL t2=a[i+1][j]*a[i][j+1]/g2;\n            LL g3=gcd(t1,t2);\n            a[i][j]=t1*t2/g3+1;\n            mx=max(mx,a[i][j]);\n        }\n    }\n//    printf(\"mi = %d\\n\",mi);\n//    printf(\"mx = %lld\\n\",mx);\n//    for(int i=499;i<=n;i++){\n//        for(int j=499;j<=n;j++){\n//            printf(\"%lld \",a[i][j]);\n//        }\n//        printf(\"\\n\");\n//    }\n    int N; scanf(\"%d\",&N);\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            printf(\"%lld\",a[i][j]);\n            if(j<N) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n}\n\n///--------------------END-------------------------\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i; j < i + n; j++)\n      cout << j << (j == i + n - 1 ? \"\\n\" : \" \");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) ((int) x.size())\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAX = 2e6;\nconst int MAXN = 505;\n\nbool bio[MAX];\nvector <int> prime;\nint n;\nll a[MAXN][MAXN];\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n        prime.pb(i);\n        for(int j = i; j < MAX; j += i)\n            bio[j] = true;\n    }\n}\n\nint main(){\n    sito();\n\n    int idx1 = 0;\n    int idx2 = 126000;\n\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    REP(i, n)\n        REP(j, n){\n            if(i % 2 == 0 && j % 2 == 0){\n                a[i][j] = prime[idx1 ++];\n            }\n            else if(i % 2 && j % 2){\n                a[i][j] = prime[idx2 --];\n            }\n        }\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j] == 0){\n                ll sol = 0;\n                if(i > 0) sol = a[i - 1][j];\n                if(j > 0) sol = sol == 0 ? a[i][j - 1] : sol * a[i][j - 1];\n                if(i != n - 1) sol = sol == 0 ? a[i + 1][j] : sol * a[i + 1][j];\n                if(j != n - 1) sol = sol == 0 ? a[i][j + 1] : sol * a[i][j + 1];\n                a[i][j] = sol + 1;\n            }\n        }\n\n    REP(i, n){\n        REP(j, n)\n            cout << a[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i,a,b) for (int i = a; i <= b; i++)\n#define rep1(i, a, b) for(int i =a; i >=b; i--)\n#define f first\n#define ss second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\n\n\nint n,ans[2000][2000], ans1[2000][2000], ans2[2000][2000],mx;\nset<int> primes;\nbool siv[100005];\nvector<int> v;\nint lc (){\n       int res = v[0];\n       for(int i=1;i<v.size();i++){\n              res = (res)/(__gcd(res,v[i]))*v[i];\n       }\n       //cout << res << endl;\n       assert(res<=1000000000000000&&res>=2);\n       if(res>=1000000000000000){\n              cout << endl;\n              for(auto t:v){\n                     cout << t << \" \";\n              }\n              cout << endl;\n              //cout << x << \" \" << y << \" \" << z << \" \" << w << endl;\n              exit(0);\n       }\n       v.clear();\n       return res;\n\n}\nbool check(){\n       set<int> s;\n       for(int i=1;i<n+1;i++){\n              for(int j=1;j<n+1;j++){\n                     int mx = max(ans[i+1][j],ans[i][j]);\n                     int mn = min(ans[i+1][j],ans[i][j]);\n                     if(i+1<=n)s.insert(mx%mn);\n                     mx = max(ans[i][j+1],ans[i][j]);\n                     mn = min(ans[i][j+1],ans[i][j]);\n                     if(j+1<=n)s.insert(mx%mn);\n              }\n       }\n       //cout << s.size() << endl;\n       return s.size()==1;\n}\nvoid show(){\n       for(int i=1;i<=n;i++){\n              for(int j=1;j<=n;j++){\n                     cout << ans[i][j] << \" \";\n                     mx = max(mx,ans[i][j]);\n              }\n              cout << endl;\n       }\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n//freopen(\"input.txt\",\"r\",stdin);\n//freopen(\"output.txt\",\"w\",stdout);\n\ncin >> n;\nif(n==2){\n       cout << \"4 7 \\n23 10 \\n\";\n       return 0;\n}\nfor(int i=1;i<=n;i++){\n       for(int j=1;j<=n;j++)ans[i][j]=ans1[i][j]=ans2[i][j]=1;\n}\nfor(int i=2;i<100000;i++){\n       if(siv[i])continue;\n       for(int j=i+i;j<100000;j+=i){\n              siv[j]=true;\n       }\n}\nfor(int i=2;i<100000;i++){\n       if(!siv[i])primes.insert(i);\n}\n\n\nint t=n;\nif(n%2==0)t--;\nfor(int i=1;i<=n;i+=2){\n       auto it=primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       it = primes.begin();\n       int cur1 = *it;\n       primes.erase(it);\n       for(int k=0;i+k<=n;k++){\n              ans[1+k][i+k]*=cur;\n              if(i!=1){\n                     ans[i+k][1+k]*=cur1;\n              }\n       }\n}\n/*\nfor(int i=t;i>=1;i=-2){\n       auto it=primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       ans[i][n-i+1]*=cur;\n       if(ans[n][i]==1)\n       for(int k=0;i-k>0;k++){\n              ans[n-k][i-k]*=cur;\n              ans[n-k][i-k]*=cur;\n       }\n}\n*/\n//show();\nfor(int i=1;i<=n;i++){\n       auto it = primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       ans[i][i]*=cur;\n       for(int k=1;i-k>0;k++){\n              ans[i-k][i+k]*=cur;\n              ans[i+k][i-k]*=cur;\n       }\n}\n//show();\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nfor(int i=1;i<=n;i++){\n       for(int j=1;j<=n;j++){\n              if(ans[i][j]==1){\n                     int res=1;\n                     v.clear();\n                     for(int k=0;k<4;k++){\n                                   int x = ans[i+dx[k]][j+dy[k]];\n                                   if(x>0){\n                                          //cout << x << endl;\n                                          v.pb(x);\n                                   }\n                     }\n                     res = lc();\n                     ans[i][j] = res + 1;\n              }\n              assert(ans[i][j]<=10000000000000000);\n              //cout << ans[i][j] << \" \";\n       }\n       //cout << endl;\n}\nassert(check()==true);\n\nfor(int i=1;i<n+1;i++){\n       for(int j=1;j<n+1;j++){\n              cout << ans[i][j] << \" \";\n              mx = max(ans[i][j],mx);\n       }\n       cout << endl;\n}\n\n//cout << mx << endl;\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\nll f(int x,int y){\n    return 10+x+y*666;\n}\nint main(){\n    int n;cin>>n;\n    lol(i,n){\n\tlol(j,n){\n\t    if(j>0)cout<<\" \";\n\t    if((i+j)%2==0){\n\t\tint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\t\tll cur=1;\n\t\tlol(r,4){\n\t\t    int xx=i+dx[r],yy=j+dy[r];\n\t\t    if(xx<0||xx==n||yy<0||yy==n)continue;\n\t\t    cur*=f(xx,yy);\n\t\t}\n\t\tcout<<cur+1;\n\t    }\n\t    else{\n\t\tcout<<f(i,j);\n\t    }\n\t}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n\n    for ( int i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n\n}\n\n\n__int128 cmmdc ( __int128 a , __int128 b ){\n\n    while ( b ){\n        __int128 t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\n__int128 calcLCM ( __int128 a , __int128 b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int i = 0 ; i < 2 * noLin ; i+=1 ){\n        diagPrin [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < 2 * noLin ; i+=2 ){\n        diagSec [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < noLin ; i+=1 ){\n        for ( int j = 0 ; j < noLin ; j+=1 ){\n            int crPrin = j - i + noLin - 1 ;\n            int crSec = 2*noLin - i - j - 1 ;\n\n            mat [ i ][ j ] = diagPrin [ crPrin ] * diagSec [ crSec ];\n        }\n    }\n\n    int jj = 0 ;\n    if ( noLin == 2 ){\n        int jj= 1 ;\n    }\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = jj ; j < noLin ; j++ ){\n\n            __int128  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            cout << mat [ i ][ j ] << \" \" ;\n//            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 500\nll a[MN+5][MN+5];\nmap<ll,int> mp;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nint main()\n{\n\tint n,i,j,k;\n\tfor(i=2;i<=MN;i+=2)for(j=1;j<=MN;++j)\n\t{\n\t\tfor(k=1;mp[i*j*k];++k);\n\t\ta[i-(j&1)][j]=i*j*k;\n\t}\n\tfor(i=1;i<=MN;++i)for(j=1;j<=MN;++j)if(!a[i][j])\n\t{\n\t\tll x=1;\n\t\tif(i>1)x=x/gcd(x,a[i-1][j])*a[i-1][j];\n\t\tif(i<MN)x=x/gcd(x,a[i+1][j])*a[i+1][j];\n\t\tif(j>1)x=x/gcd(x,a[i][j-1])*a[i][j-1];\n\t\tif(j<MN)x=x/gcd(x,a[i][j+1])*a[i][j+1];\n\t\tfor(k=1;mp[x*k+1];++k);\n\t\ta[i][j]=x*k+1;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i,puts(\"\"))for(j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nLL A[500][500];\n\nLL GCD(LL a, LL b) {\n\tif (b == 0) return a;\n\treturn GCD(b, a % b);\n}\nLL LCM(LL a, LL b) {\n\treturn a / GCD(a, b) * b;\n}\n\nconst int di[] = { 1, 0, -1, 0 };\nconst int dj[] = { 0, 1, 0, -1 };\n\nvector<int> primes;\nvector<int> primes1;\nvector<int> primes2;\n\nvoid pre() {\n\tconst int MAX = 300000;\n\t\n\tREP(i, 2, MAX) {\n\t\tbool pr = true;\n\t\tfor (int div = 2; div * div <= i; ++div) {\n\t\t\tif (i % div == 0) {\n\t\t\t\tpr = false;\n\t\t\t}\n\t\t}\n\t\tif (pr) primes.push_back(i);\n\t}\n\n\tfor (int i = 0; i < primes.size(); ++i) {\n\t\t(i % 2 == 0 ? primes1 : primes2).push_back(primes[i]);\n\t}\n}\n\nvoid sub() {\n\tpre();\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn;\n\t}\n\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tint k = N - j - 1;\n\t\t\tA[i][j] = primes1[(N + (i - j)) / 2] * primes2[(N + (i - k)) / 2];\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tif (i % 2 == j % 2) continue;\n\t\t\tvector<LL> v;\n\t\t\tREP(k, 0, 4) {\n\t\t\t\tint ni = i + di[k];\n\t\t\t\tint nj = j + dj[k];\n\t\t\t\tif (Inside(ni, nj, N, N)) {\n\t\t\t\t\tv.push_back(A[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLL lcm = 1;\n\t\t\tfor (LL p : v) {\n\t\t\t\tlcm = LCM(lcm, p);\n\t\t\t}\n\t\t\tA[i][j] = lcm + 1;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tcout << A[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t}\n\t}\n}\n\nint main() {\n\tsub();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define MOD 1000000007\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\ntypedef unsigned long long int ull;\ntypedef long long lint;\nnamespace mp = boost::multiprecision;\n\nmp::cpp_int LCM(mp::cpp_int a,mp::cpp_int b){\n  if(a==0 || b==0) return 0;\n  mp::cpp_int tmp,r,x;\n  x=a*b;\n  if(a<b) tmp=a,a=b,b=tmp;\n  r=a%b;\n  while(r!=0) a=b,b=r,r=a%b;\n  x=x/b;\n  return x;\n}\n\nmp::cpp_int GCD(lint a,lint b){\n  if(a==0 || b==0) return max(a,b);\n  else return (a*b)/LCM(a,b);\n}\n\nvector<bool> prime;\nvoid primeinit(int N){\n    if(N+1>prime.size()){\n        prime.resize(N+1,true);\n    } \n    prime[0] = false;\n    prime[1] = false;\n    for(int i=2; i*i<=N;i++) if(prime[i]) for(int j=2; i*j<=N;j++) prime[i*j]=false;\n}\n\n\nint main(void){\n    primeinit(1000000);\n    int N;\n    cin >> N;\n    int put=N;\n    N=500;\n    lint primeno[2000];\n    mp::cpp_int ans[N][N];\n    rep(i,N) rep(j,N) ans[i][j]=1;\n    lint now=0;\n    rep(i,2000){\n        while(!prime[now]) now++;\n        primeno[i]=now;\n        now++;\n    }\n    for(int i=1;i<=500;i+=2) swap(primeno[i],primeno[999-i]);\n    int no=0;\n    for(int i=N-2;i>=2;i-=2){\n        int x=0,y=i;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n    }\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n    }\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    for(int i=1;i<N;i+=2){\n        int x=N-1,y=i;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    rep(i,N) rep(j,N){\n        if(ans[i][j]==1){\n            mp::cpp_int in=1;\n            if(i!=0) in=LCM(in,ans[i-1][j]);\n            if(i!=N-1) in=LCM(in,ans[i+1][j]);\n            if(j!=0) in=LCM(in,ans[i][j-1]);\n            if(j!=N-1) in=LCM(in,ans[i][j+1]);\n            ans[i][j]=in+1;\n        }\n    }\n    rep(i,put){\n        rep(j,put) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<class Z> Z gcd(Z a, Z b) {\n  while (b) swap(a %= b, b);\n  return a;\n}\ntemplate<class Z> Z lcm(Z a, Z b) { return a / gcd(a, b) * b; }\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  constexpr int n = 500;\n  VV<lint> a(n, V<lint>(n));\n  set<lint> se;\n  lint x = 10;\n  for (int k = 1; k < 2 * n - 1; k += 4) {\n    for (int i = 0; i < n; ++i) {\n      int j = k - i;\n      if (j < 0 or j >= n) continue;\n      if (~i & 1) {\n        a[i][j] = x;\n        se.insert(x);\n      } else {\n        a[i][j] = 2 * x;\n        se.insert(2 * x);\n        while (se.count(x)) ++x;\n      }\n    }\n  }\n  for (int k = 2 * n - 5; k >= 0; k -= 4) {\n    for (int i = 0; i < n; ++i) {\n      int j = k - i;\n      if (j < 0 or j >= n) continue;\n      if (~i & 1) {\n        a[i][j] = x;\n        se.insert(x);\n      } else {\n        a[i][j] = 2 * x;\n        se.insert(2 * x);\n        while (se.count(x)) ++x;\n      }\n    }\n  }\n  V<> di{1, -1, 0, 0};\n  V<> dj{0, 0, 1, -1};\n  for (int k = 0; k < 2 * n - 1; k += 2) {\n    for (int i = 0; i < n; ++i) {\n      int j = k - i;\n      if (j < 0 or j >= n) continue;\n      x = 1;\n      for (int d = 0; d < 4; ++d) {\n        int ni = i + di[d];\n        int nj = j + dj[d];\n        if (ni < 0 or ni >= n) continue;\n        if (nj < 0 or nj >= n) continue;\n        x = lcm(x, a[ni][nj]);\n      }\n      // while (x < 1e5) x *= 2;\n      while (se.count(x + 1)) x *= 2;\n      a[i][j] = x + 1;\n      se.insert(x + 1);\n    }\n  }\n\n  set<lint> s;\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    assert(a[i][j] <= 1e15);\n    if (a[i][j] > 1e15) {\n      cerr << i << ' ' << j << '\\n';\n      cerr << a[i][j] << '\\n';\n      for (int d = 0; d < 4; ++d) {\n        int ni = i + di[d];\n        int nj = j + dj[d];\n        if (ni < 0 or ni >= n) continue;\n        if (nj < 0 or nj >= n) continue;\n        cerr << a[ni][nj] << '\\n';\n      }\n      return 0;\n    }\n    if (s.count(a[i][j])) {\n      cerr << i << ' ' << j << '\\n';\n      cerr << a[i][j] << '\\n';\n    }\n    s.insert(a[i][j]);\n  }\n  assert(s.size() == n * n);\n\n  int N; cin >> N;\n  for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) {\n    cout << a[i][j] << \" \\n\"[j == N - 1];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            cout << i+j+2 << ' ';\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pw(x) (1LL << (x))\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\nconst int INF = 1.01e9;\n\nvector<vector<ll>> solve(int n) {\n    int need = n;\n    n = 500;\n    int cit = 6;\n    while (true) {\n        srand(cit++);\n\n        int N = 1e6;\n        vector<vector<int>> e(N);\n        for (int i = 2; i < N; i++) {\n            for (int j = i + i; j < N; j += i) {\n                e[i].push_back(j);\n                e[j].push_back(i);\n            }\n        }\n\n        vector<int> used(N, 0);\n\n        auto bad = [&](int v) {\n            int cnt = 0;\n            for (int to : e[v]) {\n                cnt += used[to] == 0;\n                if (cnt > 1) return 0;\n            }\n            return 1;\n        };\n\n        int iter = 0;\n        vector<vector<int>> res;\n        for (int ii = 0; ii < 2; ii++) {\n            vector<int> vct;\n            int v = 2;\n            while (used[v] != 0) v++;\n\n            vct.push_back(v);\n            while (vct.size() < n) {\n                if (iter++ % 1000 == 0) cerr << ii << \", \" << iter << \": \" << vct.size() << endl;\n                if (iter > 1e5) break;\n                //db(iter);\n\n                int v = vct.back();\n\n                random_shuffle(e[v].begin(), e[v].end());\n                int found = -1;\n                for (int to : e[v]) {\n                    if (used[to] == 0 && !bad(to)) {\n                        found = to;\n                        break;\n                    }\n                }\n                if (found != -1 && vct.size() > 1 && (found > v) == (v > vct[vct.size() - 2])) {\n                    found = -1;\n                }\n                if (found != -1) {\n                    used[found] = 1;\n                    vct.push_back(found);\n                    continue;\n                }\n                for (int to : e[v]) {\n                    if (used[to] != -1 && !bad(to)) {\n                        found = to;\n                        break;\n                    }\n                }\n                assert(found != -1);\n                int pos = 0;\n                while (pos < (int)vct.size() && vct[pos] != found) pos++;\n                if (pos == vct.size()) continue;\n                if (pos > 0 && (vct[pos] > vct[pos - 1]) == (v > vct[pos])) continue;\n                reverse(vct.begin() + pos + 1, vct.end());\n            }\n            if (vct.size() != n) {\n                db(vct.size());\n                break;\n            }\n            res.push_back(vct);\n            for (int x : vct) used[x] = 1;\n        }\n        if (res.size() != 2) continue;\n\n        n = need;\n        vector<vector<ll>> ans(n, vector<ll>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                ans[i][j] = 1LL * res[0][i] * res[1][j];\n                if ((i + j) % 2 == 0) ans[i][j]++;\n            }\n        }\n        return ans;\n    }\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n\n    int n;\n    while (cin >> n) {\n        auto a = solve(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cout << a[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n#ifdef HOME\n    cerr << \"time = \" << (clock() * 1. / CLOCKS_PER_SEC) << \"\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 503;\nint n,pr[1500],v[10003],tot,cnt;\nll ans[N][N];\nmap<PII,ll> ch;\n\nvoid init(){\n    for(int i = 2; i <= 10000; i++){\n        if(!v[i]){\n            pr[++tot]=i;\n            v[i]=i;\n        }\n        for(int j = 1; j <= tot && i*pr[j] <= 10000; j++){\n            v[pr[j]*i]=pr[j];\n            if(v[i]==pr[j]) break;\n        }\n    }\n}\nll getval(int x,int y){\n    ll ret=1;\n    int stx[4]={1,-1,0,0},sty[4]={0,0,1,-1};\n    auto valid=[&](int x,int y){\n        return 1<=x&&x<=n&&1<=y&&y<=n;\n    };\n    for(int i = 0; i < 4; i ++){\n        int nx=x+stx[i],ny=y+sty[i];\n        if(!valid(nx,ny)) continue;\n        ret=ret*ans[nx][ny]/__gcd(ret,ans[nx][ny]);\n    }\n    return ret+1;\n}\nint main(){\n    scanf(\"%d\",&n);\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n    init();\n    for(int i = 2; i <= n+n; i+=2) ch[Mp(i,0)]=pr[++cnt];\n    for(int i = 0,j = 0; i < n; i+=2,j-=2) ch[Mp(i,1)]=pr[++cnt],ch[Mp(j,1)]=pr[++cnt];\n    //puts(\"1\");\n    //for(auto it:ch) printf(\"%d %d %d\\n\",it.fi.fi,it.fi.se,it.se);\n    rep(i,1,n) rep(j,1,n) if((i+j)%2==0){\n        ans[i][j]=ch[Mp(i+j,0)]*ch[Mp(i-j,1)];\n    }\n    //rep(i,1,n) rep(j,1,n) printf(\"%lld%c\",ans[i][j],j==n?'\\n':' ');\n    rep(i,1,n) rep(j,1,n) if((i+j)%2==1){\n        ans[i][j]=getval(i,j);\n    }\n    rep(i,1,n) rep(j,1,n) printf(\"%lld%c\",ans[i][j],j==n?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nint n;\nbool pr[101010];\nint ps[101010], k;\nlong long ans[500][500];\n\nlong long gcd(long long x, long long y) {\n  while (y != 0) {\n    long long tmp = x;\n    x = y;\n    y = tmp % x;\n  }\n  return x;\n}\n\nlong long lcm(long long x, long long y) {\n  return x / gcd(x, y) * y;\n}\n\nint main() {\n  for (int i = 2; i < 101010; i++) {\n    if (!pr[i]) {\n      ps[k++] = i;\n      for (int j = i * 2; j < 101010; j += i) {\n        pr[j] = true;\n      }\n    }\n  }\n\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      ans[i][j] = 1;\n    }\n  }\n\n  int l = 0;\n  for (int i = 0; i < n * 2; i += 2) {\n    for (int j = 0; j <= i; j++) {\n      if (i - j < n && j < n) {\n        ans[i - j][j] *= ps[l];\n      }\n    }\n    l++;\n  }\n  for (int i = 0; i < n; i += 2) {\n    for (int j = 0; i + j < n; j++) {\n      ans[i + j][j] *= ps[l];\n    }\n    l++;\n  }\n  for (int j = 2; j < n; j += 2) {\n    for (int i = 0; i + j < n; i++) {\n      ans[i][i + j] *= ps[l];\n    }\n    l++;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) {\n        if (i - 1 >= 0) ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n        if (i + 1 < n) ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n        if (j - 1 >= 0) ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n        if (j + 1 < n) ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n        ans[i][j]++;\n      }\n      printf(\"%lld \", ans[i][j]);\n    }\n    putchar('\\n');\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include<map>\ntypedef long long ll;\nusing namespace std;\nvoid read(int &x){int f=1;x=0;char s=getchar();while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}x*=f;}\nvoid write(int x){if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);putchar(x%10+'0');}\nll a[505][505];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\ta[1][1]=4;\n\tfor(int i=2;i<=n;i++){\n\t\ta[1][i]=a[1][i-1]+3;\n\t}\n\ta[2][1]=7;\n\tfor(int i=2;i<=n;i++){\n\t\ta[2][i]=a[2][i-1]+3;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%2){\n\t\t\tprintf(\"%lld\",a[1][1]);\n\t\t\tfor(int j=2;j<=n;j++)\n\t\t\tprintf(\" %lld\",a[1][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%lld\",a[2][1]);\n\t\t\tfor(int j=2;j<=n;j++)\n\t\t\tprintf(\" %lld\",a[2][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//const int N = 5e5+5;\n//bool prime[N];\n//void alternate(vi &arr){\n//    vi ans;\n//    for(int i = 0; i < 250; ++i){\n//        ans.pb(arr[i]);\n//        ans.pb(arr[499-i]);\n//    }\n//    arr = ans;\n//}\n//void _(){\n//    fill(prime+2,prime+N,true);\n//    vector<int> primes;\n//    for(int i = 2; i < N; ++i)\n//        if(prime[i]){\n//            for(int j = 2*i; j < N; j += i)\n//                prime[j] = false;\n//            primes.push_back(i);\n//        }\n//    primes.resize(1000);\n//    vi p1;\n//    vi p2;\n//    for(int i = 0; i < 1000; ++i)\n//        if(i%2) \n//            p1.pb(primes[i]);\n//        else\n//            p2.pb(primes[i]);\n//    alternate(p1);\n//    alternate(p2);\n//    //print(p1);\n//    //print(p2);\n//    int n;\n//    cin >> n;\n//    vector<ll> arr;\n//    vvl grid(n,vl(n));\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 == j % 2){\n//                int d1 = (i+j)/2;\n//                int d2 = (i-j+n-1)/2;\n//                ll a = p1[d1];\n//                ll b = p2[d2];\n//                grid[i][j] = a*b;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 != j % 2){\n//                vl neigh;\n//                if(i > 0) neigh.pb(grid[i-1][j]);\n//                if(i+1 < n) neigh.pb(grid[i+1][j]);\n//                if(j > 0) neigh.pb(grid[i][j-1]);\n//                if(j+1 < n) neigh.pb(grid[i][j+1]);\n//                ll ans = 1;\n//                for(ll x : neigh){\n//                    ans = ans*(x/gcd(ans,x));\n//                }\n//                grid[i][j] = ans;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            arr.push_back(grid[i][j]);\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            cout << grid[i][j]  << \" \\n\"[j==n-1];\n//    sort(all(arr));\n//    arr.erase(unique(all(arr)),arr.end());\n//    //assert(arr.size() == n*n);\n//    //cout << n*n << ' ' << arr.size() << '\\n';\n//}\n//\n// ================================================ \n// ^^^\tABOVE is what I wrote in my editor\t^^^\n// ------------------------------------------------ \n// vvv\tBELOW is automatically generated \tvvv\n// ================================================ \n#include <numeric>\n#include <set>\n#include <iomanip>\n#include <algorithm> \n#include <cassert>\n#include <vector>\n#include <iostream>\n#define pb push_back \n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<int> vi;\ntemplate<typename IT>\nostream &print(IT b, IT e, string sep = \" \", ostream &stream = cout){\n\tfor(IT it = b; it != e; ++it){\n\t\tstream << *it;\n\t\tif(it+1 != e) stream << sep;\n\t} \n\treturn stream;\n}\ntemplate<typename IT> istream &read(IT b, IT e, istream &stream = cin){\n\tfor(IT it = b; it != e; ++it) stream >> *it; return stream;\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &&t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> istream &operator>>(istream &stream, vector<T> &t){\n\treturn read(all(t),stream);\n}\ntemplate <typename T> \nvoid print(T x){\n\tcout << x << '\\n';\n}\ntemplate <typename t> \nvoid print(vector<t> arr,string sep=\" \"){\n    if(arr.empty())\n        return;\n\tprint(arr.begin(),arr.end(),sep);\n\tcout << '\\n';\n}\ntemplate <typename T> \nvoid print(vector<vector<T> > arr){\n\tfor(int i = 0; i < arr.size(); ++i){\n\t\tcout << \"[\" << arr[i] << \"]\";\n\t\tif(i+1 < arr.size())\n\t\t\tcout << \", \";\n\t}\n\tcout << '\\n';\n}\ntemplate<typename T>\nT _();\nconst ll INF = ll(2e18)+666;\nconst ll MOD = 1e9+7;\ntemplate<typename T>\nvector<T> operator+(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(lhs);\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] += rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator+=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs+rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nvector<T> operator-(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(all(lhs));\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] -= rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator-=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs-rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nT max(const vector<T> arr){\n\tassert(!arr.empty());\n\tT ans = arr[0];\n\tfor(auto &cur : arr)\n\t\tans = max(ans,cur);\n\treturn ans;\n}\ntemplate<typename T>\nT max(const set<T> s){\n\tassert(!s.empty());\n\treturn *--s.end();\n}\ntemplate<typename T, typename G>\nvector<T> set_max(vector<T> &base, const vector<G> &comp){\n\tassert(base.size() == comp.size());\n\tfor(int i = 0; i < (int)comp.size(); ++i)\n\t\tbase[i] = max(base[i],comp[i]);\n\treturn base;\n}\ntemplate <typename T>\nvector<T> unique(vector<T> &arr){\n    sort(all(arr));\n\tarr.erase(unique(all(arr)),arr.end());\n\treturn arr;\n}\nconst int N = 5e5+5;\nbool prime[N];\nvoid alternate(vi &arr){\n    vi ans;\n    for(int i = 0; i < 250; ++i){\n        ans.pb(arr[i]);\n        ans.pb(arr[499-i]);\n    }\n    arr = ans;\n}\nvoid _(){\n    fill(prime+2,prime+N,true);\n    vector<int> primes;\n    for(int i = 2; i < N; ++i)\n        if(prime[i]){\n            for(int j = 2*i; j < N; j += i)\n                prime[j] = false;\n            primes.push_back(i);\n        }\n    primes.resize(1000);\n    vi p1;\n    vi p2;\n    for(int i = 0; i < 1000; ++i)\n        if(i%2) \n            p1.pb(primes[i]);\n        else\n            p2.pb(primes[i]);\n    alternate(p1);\n    alternate(p2);\n    //print(p1);\n    //print(p2);\n    int n;\n    cin >> n;\n    vector<ll> arr;\n    vvl grid(n,vl(n));\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 == j % 2){\n                int d1 = (i+j)/2;\n                int d2 = (i-j+n-1)/2;\n                ll a = p1[d1];\n                ll b = p2[d2];\n                grid[i][j] = a*b;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 != j % 2){\n                vl neigh;\n                if(i > 0) neigh.pb(grid[i-1][j]);\n                if(i+1 < n) neigh.pb(grid[i+1][j]);\n                if(j > 0) neigh.pb(grid[i][j-1]);\n                if(j+1 < n) neigh.pb(grid[i][j+1]);\n                ll ans = 1;\n                for(ll x : neigh){\n                    ans = ans*(x/gcd(ans,x));\n                }\n                grid[i][j] = ans;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            arr.push_back(grid[i][j]);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            cout << grid[i][j]  << \" \\n\"[j==n-1];\n    sort(all(arr));\n    arr.erase(unique(all(arr)),arr.end());\n    //assert(arr.size() == n*n);\n    //cout << n*n << ' ' << arr.size() << '\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(12);\n\t_();\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvvi out(500,vi(500,1));\nint gcd(int a,int b){\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(int a,int b){\n\treturn a/gcd(a,b)*b;\n}\nsigned main(){\n\tconst int M=10000;\n\tint sosu[M]={1,1,0};\n\tfor(int i=2;i*i<M;i++)if(sosu[i]==0)\n\tfor(int j=i*2;j<M;j+=i)sosu[j]=1;\n\tvi sos;\n\trep(i,M)if(sosu[i]==0)sos.pb(i);\n\t\n\tint n;\n\tcin>>n;\n\tint t=0;\n\trep(i,500){\n\t\tint x=0,y=i*2;\n\t\twhile(y>=0){\n\t\t\tif(x<500&&y<500)out[x][y]*=sos[t];\n\t\t\tx++;y--;\n\t\t}\n\t\tt++;\n\t}\n\trep(i,500){\n\t\tint x=0,y=500-2*i;\n\t\twhile(x<500){\n\t\t\tif(0<=y&&y<500)out[x][y]*=sos[t];\n\t\t\tx++;y++;\n\t\t}\n\t\tt++;\n\t}\n\trep(x,500)rep(y,500)if(out[x][y]==1){\n\t\tt=1;\n\t\tif(x<499)t=lcm(t,out[x+1][y]);\n\t\tif(x)t=lcm(t,out[x-1][y]);\n\t\tif(y<499)t=lcm(t,out[x][y+1]);\n\t\tif(y)t=lcm(t,out[x][y-1]);\n\t\tout[x][y]=t;\n\t}\n\tint ma=0;\n\trep(i,500)rep(j,500)cmax(ma,out[i][j]);\n\trep(i,n){rep(j,n)cout<<out[i][j]<<\" \";cout<<endl;}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10010;\n\ntypedef long long LL;\n\nint flag[N], prime[N], pcnt;\n\ninline void sieve() {\n\tfor (int i = 2; i <= N - 10; i++) {\n\t\tif (!flag[i]) prime[++pcnt] = i;\n\t\tfor (int j = 1; j <= pcnt && i * prime[j] <= N - 10; j++) {\n\t\t\tflag[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nLL G[510][510];\n\nLL gcd(LL a, LL b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\ninline LL lcm(LL a, LL b) {\n\treturn a / gcd(a, b) * b;\n}\n\ntemplate<typename... T>\ninline LL lcm(LL a, T... b) {\n\tLL t = lcm(b...);\n\treturn a / gcd(a, t) * t;\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n), sieve();\n\tif (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\tfor (int j = 0; j <= n + 1; j++) G[i][j] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if ((i + j) & 1) {\n\t\t\tint a = i + j, b = i - j; a = (a - 1) / 2, b = (b + n + 1) / 2;\n\t\t\tG[i][j] = (LL)prime[a] * prime[b + n - 1];\n\t\t}\n\tfor (int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (!((i + j) & 1)) G[i][j] = (LL)lcm(G[i - 1][j], G[i][j - 1], G[i + 1][j], G[i][j + 1]) + 1;\n\t\t\tprintf(\"%lld \", G[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\tscanf(\"%d\", &n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1)){\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\t\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\t}\n\t\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) a[i][j] *= b[i][j];\n\t\n\t\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tfor (int d=0 ; d<4; ++d){\n\t\t\tint x= i+dx[d], y=j+dy[d];\n\t\t\tif ( x<0 || x>=n || y<0 || y>=n ) continue;\n\t\t\ts =(__int128)s*a[x][y]/__gcd(s, a[x][y]);\n\t\t}\n\t\ta[i][j] = s+1;\n\t}\n\t\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\n//~ #warning bigger nax\nconst int nax = 1e6 + 5;\nbool is_prime[nax];\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nint main() {\n\tfor(int i = 2; i < nax; ++i) {\n\t\tis_prime[i] = true;\n\t}\n\tfor(int i = 2; i < nax; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tfor(int j = 2 * i; j < nax; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> primes;\n\tfor(int i = 2; i < nax; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<ll>> grid(n, vector<ll>(n));\n\tint nxt = 5;\n\tvector<int> odd;\n\tfor(int i = 5; i <= 62751 + 20; i += 2) {\n\t\todd.push_back(i);\n\t}\n\t//~ random_shuffle(odd.begin(), odd.end());\n\tint z = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif((i + j) % 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst int M = 4;\n\t\t\tif(i % M == 0 || j == 0) {\n\t\t\t\tassert(!odd.empty());\n\t\t\t\tif(i % (2 * M) == 0) {\n\t\t\t\t\tgrid[i][j] = odd.back();\n\t\t\t\t\todd.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = odd[z++];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\tgrid[i][j] = nxt; //primes[nxt++];\n\t\t\t\tnxt += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[i][j] = grid[i-1][j-1] * 2;\n\t\t\t\t//~ int dist = min(j, i - i / M * M);\n\t\t\t\t//~ grid[i][j] = grid[i-dist][j-dist] * (dist + 1);\n\t\t\t}\n\t\t}\n\t}\n\tauto inside = [&] (int a, int b) {\n\t\treturn 0 <= a && 0 <= b && a < n && b < n;\n\t};\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(grid[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgrid[i][j] = 1;\n\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\t\tint i2 = i + dx[dir];\n\t\t\t\tint j2 = j + dy[dir];\n\t\t\t\tif(inside(i2, j2)) {\n\t\t\t\t\tgrid[i][j] = grid[i][j] / __gcd(grid[i][j], grid[i2][j2]) * grid[i2][j2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0)for(int rep = 0; rep < 4; ++rep) {\n\t\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint i2 = i + dx[dir];\n\t\t\t\t\tint j2 = j + dy[dir];\n\t\t\t\t\tif(inside(i2, j2) && grid[i][j] == grid[i2][j2]) {\n\t\t\t\t\t\tgrid[i][j] *= 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset<ll> secik;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\tassert(!secik.count(grid[i][j]));\n\t\t\t\tsecik.insert(grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\twhile((i + j) % 2 == 1 && secik.count(grid[i][j] + 1)) {\n\t\t\t\tgrid[i][j] *= 2;\n\t\t\t}\n\t\t\tprintf(\"%lld \", grid[i][j] + (i + j) % 2);\n\t\t\t//~ fflush(stdout);\n\t\t\tif((i + j) % 2 == 1) {\n\t\t\t\tassert(!secik.count(grid[i][j] + 1));\n\t\t\t\tsecik.insert(grid[i][j] + 1);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t\t//~ debug() << grid[i];\n\t}\n\tassert((int) secik.size() == n * n);\n\tll big = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tbig = max(big, grid[i][j]);\n\t\t}\n\t}\n\tcerr << \"big = \" << big << endl;\n\tdebug() << imie(big) imie(big / (ll) 1e12) imie(nxt) imie(primes.size());\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(j != n - 1) {\n\t\t\t\tassert(max(grid[i][j], grid[i][j+1]) % min(grid[i][j], grid[i][j+1]) == 0);\n\t\t\t}\n\t\t\tif(i != n - 1) {\n\t\t\t\tassert(max(grid[i][j], grid[i+1][j]) % min(grid[i][j], grid[i+1][j]) == 0);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    vll son;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,1,(N*N)/2){\n            prime.pb(aa*2);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==1){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==0){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n//                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n                    a[i][j]=lcm(a[i-1][j],a[i+1][j]);\n                    a[i][j]=lcm(a[i][j],a[i][j-1]);\n                    a[i][j]=lcm(a[i][j],a[i][j+1]);\n                    if(BINS(son,a[i][j])==0){\n                        son.pb(a[i][j]);\n                        SORT(son);\n                    }else{\n                        a[i][j]*=2;\n                        son.pb(a[i][j]);\n                        SORT(son);\n                    }\n                    a[i][j]++;\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\n#define ll long long\n//#define file\nusing namespace std;\n\nint d[250001],n,i,j,k,l,l1,l2,x,y,t;\nll a[501][501],mx,s;\nmap<ll,bool> mp;\nbool bz[1000001];\n\nll gcd(ll x,ll y) {ll r=x%y; while (r) x=y,y=r,r=x%y; return y;}\nll lcm(ll x,ll y) {ll s=gcd(x,y);return (x/s)*(y/s)*s;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc027d.in\",\"r\",stdin);\n\tfreopen(\"agc027d.out\",\"w\",stdout);\n\t#endif\n\t\n\tscanf(\"%d\",&n),s=((n+1)/2)*((n+1)/2);\n\ti=2;\n\twhile (t<s)\n\t{\n\t\tif (!bz[i] && !bz[i*2]) d[++t]=i,bz[i]=bz[i*2]=1;\n\t\t++i;\n\t}\n\tl1=0,l2=t+1;\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tif ((i&1) && (j&1))\n\t\t{\n\t\t\tif (((i+j)/2)&1)\n\t\t\t{\n\t\t\t\t++l1;\n\t\t\t\ta[i][j]=d[l1];\n\t\t\t\tif (i<n && j<n)\n\t\t\t\ta[i+1][j+1]=d[l1]*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--l2;\n\t\t\t\ta[i][j]=d[l2];\n\t\t\t\tif (i<n && j<n)\n\t\t\t\ta[i+1][j+1]=d[l2]*2;\n\t\t\t}\n\t\t}\n\t}\n\tfo(i,1,n) fo(j,1,n) if (a[i][j]) mp[a[i][j]]=1;\n\t\n\tmx=0;\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tif (!a[i][j])\n\t\t{\n\t\t\ta[i][j]=1;\n\t\t\tif (i>1) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\tif (i<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\tif (j>1) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\tif (j<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\n\t\t\ts=a[i][j],++a[i][j];\n\t\t\twhile (mp[a[i][j]]) a[i][j]+=s;\n\t\t\tmp[a[i][j]]=1;\n\t\t\tmx=max(mx,a[i][j]);\n\t\t}\n\t}\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tprintf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<long long> pr;\n    for (int i=2; pr.size()<=1000; i++){\n        bool bre = false;\n        for (int j=0; j<pr.size(); j++){\n            if (i%pr[j]==0){\n                bre = true;\n                break;\n            }\n        }\n        if (bre) continue;\n        pr.push_back(i);\n    }\n    vector<long long> helper(n);\n    vector<vector<long long> > A(n, helper);\n    A[0][0] = 2;\n    for (int i=0; i<n; i++){\n        A[i][0] = pr[i];\n    }\n\n    for (int i=1; i<n; i++){\n        A[0][i] = pr[n+i-1];\n    }\n\n    for (int i=0; i<n; i++){\n        for (int j=0; j<n; j++){\n            if (i!=0 && j!=0)\n                cout << A[i][0]*A[0][j]+1 << \" \";\n            else\n                cout << A[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nll seq[1005], arr[505][505], row[505], col[505];\ninline bool chk(int n)\n{\n\tfor (int i = 2; i * i <= n; i++)\n\t{\n\t\tif (!(n % i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline ll gcd(ll x, ll y)\n{\n\twhile (y)\n\t{\n\t\tauto r = x % y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn x;\n}\ninline ll lcm(ll x, ll y)\n{\n\tif (!x || !y)\n\t\treturn x + y;\n\treturn (__int128)x * y / gcd(x, y);\n}\nint main()\n{\n\t// freopen(\"AGC027-D.in\", \"r\", stdin);\n\tint n, cnt = 0, cur = 2;\n\tbool flg = false;\n\tscanf(\"%d\", &n);\n\tif (n & 1 ^ 1)\n\t{\n\t\tflg = true;\n\t\tn++;\n\t}\n\twhile (cnt <= n * 2)\n\t{\n\t\tif (chk(cur))\n\t\t\tseq[cnt++] = cur;\n\t\tcur++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tarr[i][j] = 1;\n\t}\n\tcur = 0;\n\tfor (int i = 0; i < n; i += 2)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= seq[cur];\n\t\tcur++;\n\t}\n\tfor (int i = 2; i < n; i += 2)\n\t{\n\t\tint x = 0, y = i;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= seq[cur];\n\t\tcur++;\n\t}\n\tcur = cnt - 1;\n\tfor (int i = 0; i < n; i += 2)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= seq[cur];\n\t\tcur--;\n\t}\n\tfor (int i = 2; i < n; i += 2)\n\t{\n\t\tint x = n - 1, y = i;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= seq[cur];\n\t\tcur--;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i & 1 ^ 1; j < n; j += 2)\n\t\t\tarr[i][j] = lcm(lcm(i ? arr[i - 1][j] : 0, j ? arr[i][j - 1] : 0),\n\t\t\t\t\t\t\tlcm(arr[i + 1][j], arr[i][j + 1])) + 1;\n\t}\n\tif (flg)\n\t\tn--;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tprintf(\"%lld%c\", arr[i][j], \" \\n\"[j + 1 == n]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint N;\nint A[550][550];\nqueue<int> prime;\nunordered_map<int, int> mpA, mpB;\nsigned main() {\n    cin >> N;\n    for (int i = 2; i <= 55000; i++) {\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0)goto nene;\n        }\n        prime.push(i);\nnene:;\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n\n            if (mpA[i + j] == 0) {mpA[i + j] = prime.front(); prime.pop();}\n            if (mpB[i - j] == 0) {mpB[i - j] = prime.front(); prime.pop();}\n\n            A[i][j] = mpA[i + j] * mpB[i - j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if ((i + j) % 2 == 0) {cout << A[i][j] << \" \"; continue;}\n            int cur = 1;\n            for (int k = 0; k < 4; k++) {\n                cur = cur * A[i + dy[k]][j + dx[k]] / gcd(cur, A[i + dy[k]][j + dx[k]]);\n            }\n            cout << cur * 2 + 1 << \" \";\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,nw[510],pn,N,p[510],cnt;\nlong long ans[510][510],h[510],l[510];\nmap<long long,int> ma;\n\nlong long gcd(long long a,long long b) {return (!b)?a:gcd(b,a%b);}\nlong long lcm(long long a,long long b) {return a/gcd(a,b)*b;}\n\nbool bo[10010];\n\nint main()\n{\n\tfor (int i=2,cnt=0; i<=10000; i++) if (!bo[i])\n\t{\n\t\tif (i>=250) p[++pn]=i; \n\t\tif (pn==251) break;\n\t\tfor (int j=i; j<=10000; j+=i) bo[j]=1;\n\t}\n\tsrand(12019687),scanf(\"%d\",&N),cnt=0,n=501;\n\tfor (int i=1; i<=n; i+=2) cnt++;\n\tfor (int i=1; i<=cnt; i++) nw[i]=(i+1==251?254:i+1);\n\trandom_shuffle(nw+1,nw+1+cnt);\n\twhile (1)\n\t{\n\t\tma.clear(); bool bo=0;\n\t\tfor (int i=1; i<=cnt; i++) h[2*i-1]=nw[i],ma[nw[i]]=1;\n\t\tfor (int i=2; i<=n; i+=2) \n\t\t{\n\t\t\th[i]=h[i-1]*h[i+1];\n\t\t\tif (ma[h[i]]) {bo=1; break;}\n\t\t\tma[h[i]]=1;\n\t\t}\n\t\tif (!bo) break;\n\t\trandom_shuffle(nw+1,nw+1+cnt);\n\t}\n\tfor (int i=1; i<=cnt; i++) if (i&1) l[2*i-1]=p[i+1>>1]; else l[2*i-1]=p[pn-(i>>1)+1];\n\tfor (int i=2; i<=n; i+=2) l[i]=l[i-1]*l[i+1];\n\tfor (int i=0; i<=n+1; i++) ans[i][0]=ans[i][n+1]=ans[0][i]=ans[n+1][i]=1;\n\tma.clear();\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=2-(i&1); j<=n; j+=2) \n\t\t\tans[i][j]=h[i]*l[j],ma[ans[i][j]]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=(i&1)+1; j<=n; j+=2) \n\t\t{\n\t\t\tlong long nw=lcm(lcm(lcm(ans[i-1][j],ans[i+1][j]),ans[i][j-1]),ans[i][j+1]);\n\t\t\tans[i][j]=nw+1;\n\t\t\twhile (ma[ans[i][j]]) ans[i][j]+=nw;\n\t\t\tma[ans[i][j]]=1;\n\t\t}\n\tfor (int i=1; i<=N; i++,puts(\"\"))\n\t\tfor (int j=1; j<=N; j++) printf(\"%lld \",ans[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i = a; i<n; i++)\n#define per(i,a,n) for (int i = n-1; i>=a; i--)\n#define pb push_back\n#define mp make_pair\n#define all(now) (now).begin(),(now).end()\n#define fi first\n#define se second\n#define SZ(now) ((int)(now).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod = 1000000007;\ninline int read(int &n){char c=getchar();int x=0,f=1;while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}return n = x*f;}\nll powmod(ll a,ll b,ll mod) {ll res = 1; a%=mod; assert(b>=0); for(;b; b>>=1){if(b&1)res = res*a%mod; a = a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\n// head\nconst int N = 5e2+7;\nconst int M = 1e4 + 7;\n\nint T,n,m,cnt;\n\nbool vis[M];\nint prime[M];\n\nvoid getPrime()\n{\n    cnt = 0;\n    rep(i,2,M-5){\n        if(!vis[i])\n            prime[++cnt] = i;\n        for (int j = 1; i * prime[j] < M - 5;j++){\n            vis[i * prime[j]] = 1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nll ans[M][M];\n\nint main()\n{\n    //ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    getPrime();\n    scanf(\"%d\", &n);\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n    rep(i, 0, n + 2) rep(j, 0, n + 2) ans[i][j] = 1;\n    rep(i,1,n+1){\n        rep(j,1,n+1){\n            if((i&1)==(j&1)){\n                ans[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n];\n                ans[i + 1][j] = lcm(ans[i + 1][j], ans[i][j]);\n                ans[i - 1][j] = lcm(ans[i - 1][j], ans[i][j]);\n                ans[i][j + 1] = lcm(ans[i][j + 1], ans[i][j]);\n                ans[i][j - 1] = lcm(ans[i][j - 1], ans[i][j]);\n            }\n        }\n    }\n    rep(i,1,n+1)rep(j,1,n+1){\n        if((i&1)!=(j&1)){\n            printf(\"%lld\", ans[i][j] + 1);\n        }\n        else{\n            printf(\"%lld\", ans[i][j]);\n        }\n        printf(j == n ? \"\\n\" : \" \");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\nconst int INF = 1e9 ;\nconst int maxN = 1010; \nconst int MOD = 1e9 + 7;\nint tot,n;\nint prime[maxN]; //记录质数\nint b[maxN * 10]; //标记i 是否为质数 \nll a[maxN][maxN];\nvoid check()\n{\n\tfor(int i=2;i<= maxN*10;i++)\n\t{\n\t\tif(b[i] == 0)\n\t\t{\n\t\t\tprime[++tot] = i;\n\t\t\tfor(int j=2;i*j<=maxN * 10;j++)\n\t\t\t{\n\t\t\t\tb[i*j] = 1;\t\n\t\t\t}\t\n\t\t}\t\n\t} \n} \nvector<pii> l[maxN];\nll lc[maxN];\nint lcnt;\nvector<pii> r[maxN];\nll rc[maxN]; \nint rcnt;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tcheck();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(i,1)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = 1+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int j=2;j<=n;j++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(n,j)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tlcnt = cnt;\n\tcnt = 0;\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint k=1;\n\t\tr[++cnt].push_back(pii(n,j));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint k = 1;\n\t\tr[++cnt].push_back(pii(i,n));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = n-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\t\n\t\t} \n\t}\n\trcnt = cnt;\n\tcnt = 0;\n\tfor(int i=1;i<=lcnt;i+=2)\n\t{\n\t\tlc[i] = prime[++cnt]; \n\t}\n\tfor(int j=2;j<=lcnt;j+=2)\n\t{\n\t\tlc[j] = lc[j-1]*lc[j+1];\n\t}\n\tif(n%2 == 1)\n\t{\n\t\tfor(int i=1;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\tfor(int j=2;j<=rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\t\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\trc[1] = rc[2];\n\t\trc[rcnt] = rc[rcnt-1];\n\t\tfor(int j=3;j<rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][j] = 1ll; \n\t} \n\tfor(int i=1;i<=lcnt;i++)\n\t{\n\t\tfor(int j=0;j<l[i].size();j++)\n\t\t{\n\t\t\tint tx = l[i][j].first;\n\t\t\tint ty = l[i][j].second;\n\t\t\ta[tx][ty] *= lc[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=rcnt;i++)\n\t{\n\t\tfor(int j=0;j<r[i].size();j++)\n\t\t{\n\t\t\tint tx = r[i][j].first;\n\t\t\tint ty = r[i][j].second;\n\t\t\ta[tx][ty] *= rc[i];\n\t\t\tif((tx+ty)%2==1)\n\t\t\t\ta[tx][ty] += 1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j<n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep3(i,m,n) for(int (i)=m;(i)<=(n);(i)++)\n#define rep3rev(i,m,n) for(int (i)=m;(i)>=(n);(i)--)\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing P = pair<int, int>;\n\nconst int mx = 10000;\nconst int sz = 500;\nvector<bool> isprime(mx+1, true); \nvll prime;\nll ans[sz][sz];\nint di[] = {0, 1, 0, -1};\nint dj[] = {-1, 0, 1, 0};\n\nvoid Eratosthenes(int n){\n    isprime[0] = false;\n    isprime[1] = false;\n    for(int i = 2; i * i <= n; i++){\n        for(int j = 2 * i; j <= n; j += i){\n            isprime[j] = false;\n        }\n    }\n}\n\nvoid Solve(){\n    rep(i, sz){\n        rep(j, sz){\n            if((i + j) % 2 == 0) continue;\n            int wa = j + i; // 1, 3, 5, 7, 9, ..., 999\n            int sa = j - i; // -499, -497, ..., 497, 499\n            ans[i][j] = prime[wa/2] * prime[(sa+sz)/2 + sz];\n        }\n    }\n    rep(i, sz){\n        rep(j, sz){\n            if((i + j) % 2) continue;\n            ans[i][j] = 1;\n            int wa1 = j + i + 1;\n            int wa2 = j + i - 1;\n            int sa1 = j - i + 1;\n            int sa2 = j - i - 1;\n\n            if(0 < wa1 || wa1 < 2 * sz){\n                ans[i][j] *= prime[wa1/2];\n            } \n            if(0 < wa2 || wa2 < 2 * sz){\n                ans[i][j] *= prime[wa2/2];\n            } \n            if(-sz < sa1 || sa1 < sz){\n                ans[i][j] *= prime[(sa1+sz)/2 + sz];                \n            }\n            if(-sz < sa2 || sa2 < sz){\n                ans[i][j] *= prime[(sa2+sz)/2 + sz];\n            }\n        }        \n    }\n}\n\nvoid Main(){\n    Eratosthenes(mx);\n    rep(i, mx) if(isprime[i]) prime.pb(i);\n    Solve();\n    int n; cin >> n;\n    rep(i, n) {\n        rep(j, n) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n    return;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned long;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    vector<UL> P;\n\n    void Primes() {\n        bool Table[10000] = {};\n        Table[0] = Table[1] = true;\n        Table[3] = Table[3] = Table[5] = Table[7] = Table[11] = true;\n        for (UL i = 2; i <= 100; i++) {\n            if (Table[i]) continue;\n            for (UL j = i * i; j < 10000; j += i) Table[j] = true;\n        }\n        for (UL i = 1; P.size() < 500; i++) if (!Table[i]) P.push_back(i);\n    }\n\n    ULL ans[502][502];\n\n    void Solve() {\n        Primes();\n        rep(i, 501) rep(j, 501) ans[i][j] = 1;\n        rep(i, 500) rep(j, 500) {\n            if ((i ^ j) & 1) continue;\n            ULL tmp = 1;\n            if ((i + j) & 2)\n                tmp = ((i + j) & 4) ? 3 : 5;\n            else\n                tmp = P[(i + j) >> 2];\n            UL jx = 500 - j;\n            if((i + jx) & 2)\n                tmp *= ((i + jx) & 4) ? 7 : 11;\n            else\n                tmp *= P[((i + j) >> 2) + 250];\n            ans[i + 1][j + 2] = ans[i + 2][j + 1] = ans[i + 1][j + 1] = tmp;\n            ans[i][j + 1] *= tmp; ans[i + 1][j] *= tmp;\n        }\n        rep(i, 500) rep(j, 500) if ((i ^ j) & 1) ans[i + 1][j + 1]++;\n\n        UL N; cin >> N;\n        rep(i, N) {\n            rep(j, N) {\n                if (j) cout << \" \";\n                cout << ans[i + 1][j + 1];\n            } cout << endl;\n        }\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll ans[1010][1010],n;\nbool vis[10101];\nint tot,p[10101];\ninline void init(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!vis[i]) p[++tot]=i;\n\t\tfor (int j=1;j<=tot;j++){\n\t\t\tif (1ll*i*p[j]>n) break;\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\ninline ll lcm(ll a,ll b){\n\tif (a*b==0) return a+b;\n\treturn a/__gcd(a,b)*b;\n}\nsigned main(){\n\tn=read();\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit(10000);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tans[i][j]=1ll*p[(i+j)/2]*p[1+(i-j)/2+n];\n\t\t\t}\t\t\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2){\n\t\t\t\tans[i][j]=1+lcm(ans[i-1][j],lcm(ans[i][j-1],lcm(ans[i+1][j],ans[i][j+1])));\n\t\t\t}\t\t\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> pll;\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _overload2(_1,_2,name,...) name\n#define _re(n) _rep(i,n)\n#define _rep(i,n) _repi(i,0,n)\n#define _repi(i,a,b) for(ll i=a;i<b;++i)\n#define _repc(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_repc,_repi,_rep,_re)(__VA_ARGS__)\n#define _rre(n) _rrep(i,n)\n#define _rrep(i,n) _rrepi(i,0,n)\n#define _rrepi(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrepc(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrepc,_rrepi,_rrep,_rre)(__VA_ARGS__)\n#define rbr(i,a) for(auto&& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0)\n#define _range(i) (i).begin(),(i).end()\n#define _rangek(i,k) (i).begin(),(i).begin()+k\n#define range(...) _overload2(__VA_ARGS__,_rangek,_range)(__VA_ARGS__)\n#define LINF 0x3999999999999999LL\n#define MOD ll(1000000007)\n#define MODD ll(998244353)\n#define INF 0x39999999\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n#define elif else if\n//#define START auto start=system_clock::now()\n//#define END auto end=system_clock::now();cerr<<duration_cast<milliseconds>(end-start).count()<<\" ms\\n\"\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,size) vector<type> name(size);\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vi(name,size,value) vector<ll>name(size,value)\n#define vv(type,name,h,w,value) vector<vector<type>>name(h,vector<type>(w,value))\nstruct aaa{aaa(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};}aaaaaaa;\ntemplate<typename T>\ninline constexpr T gcd (T a,T b) {if(a==b)return a;else return gcd(b,(a-1)%b+1);}\ninline void in() {}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<typename T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<typename T,typename L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<typename T,typename L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<typename T,typename L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<typename T,typename L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <typename T>\ninline void out(T t){cout<<t<<'\\n';}\ninline void out(){cout<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);}\n\n\n\nvv(ll,a,500,500,0);\nint main(){\n    INT(n);\n    int i=2;\n    for(int j=0;j<500;j+=2)for(int k=0;k<500;k+=2,i++)a[j][k]=i;\n    for(int j=1;j<500;j+=2)for(int k=1;k<500;k+=2,i++)a[j][k]=i;\n    for(int j=0;j<500;j+=2)for(int k=1;k<500;k+=2,i++){\n        ll cnt=1;\n        if(0<j)cnt*=a[j-1][k];\n        if(499>j)cnt*=a[j+1][k];\n        if(0<k)cnt*=a[j][k-1];\n        if(499>k)cnt*=a[j][k+1];\n        a[j][k]=cnt+1;\n    }\n    for(int j=1;j<500;j+=2)for(int k=0;k<500;k+=2,i++){\n        ll cnt=1;\n        if(0<j)cnt*=a[j-1][k];\n        if(499>j)cnt*=a[j+1][k];\n        if(0<k)cnt*=a[j][k-1];\n        if(499>k)cnt*=a[j][k+1];\n        a[j][k]=cnt+1;\n    }\n    for(int i=0;i<n;i++){\n        cout<<a[i][0];\n        rep(j,1,n)cout<<' '<<a[i][j];\n        cout<<endl;\n    }\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << x << std::endl\nusing ll = long long;\nconstexpr int N = 500;\nconstexpr int MAX = 16 * N;\nconstexpr int NUM = 2 * N - 1;\nbool isprime[16 * N];\nll p1[N][N], p2[N][N], ans[N][N];\nint main()\n{\n    std::fill(isprime, isprime + MAX, true);\n    std::vector<ll> prime;\n    for (int i = 2; i < MAX; i++) {\n        if (not isprime[i]) { continue; }\n        prime.push_back(i);\n        if (prime.size() == NUM) { break; }\n        for (int j = 2; i * j < MAX; j++) { isprime[i * j] = false; }\n    }\n    for (int i = 0; i < 2 * N; i += 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = i - y;\n            if (x < 0 or N <= x) { continue; }\n            p1[y][x] = prime[i / 2];\n        }\n    }\n    for (int i = N - 2; i >= -N + 2; i -= 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = y + i;\n            if (x < 0 or N <= x) { continue; }\n            p2[y][x] = prime[(i + N - 2) / 2 + N];\n        }\n    }\n\n    auto get = [&](const int y, const int x) { return y >= 0 and y < N and x >= 0 and x < N ? std::pair<ll, ll>{p1[y][x], p2[y][x]} : std::pair<ll, ll>{1LL, 1LL}; };\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i % 2 == j % 2) {\n                ans[i][j] = p1[i][j] * p2[i][j];\n            } else {\n                std::set<ll> p;\n                p.insert({get(i - 1, j).first,\n                          get(i - 1, j).second,\n                          get(i + 1, j).first,\n                          get(i + 1, j).second,\n                          get(i, j - 1).first,\n                          get(i, j - 1).second,\n                          get(i, j + 1).first,\n                          get(i, j + 1).second});\n                ans[i][j] = 1;\n                for (const ll P : p) { ans[i][j] *= P; }\n                ans[i][j]++;\n            }\n        }\n    }\n    int N;\n    std::cin >> N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            std::cout << ans[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  int add = n & 1 ? 0 : 1;\n  n += add;\n  vector<int> pri;\n  for (int i = 2; pri.size() <= n * 2; i++) {\n    auto is_prime = [&] (int p) {\n      for (int x = 2; x * x <= p; x++) {\n        if (!(p % x)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    if (is_prime(i)) {\n      pri.push_back(i);\n    }\n  }\n  vector<vector<ll> > ans(n, vector<ll>(n, 1));\n  for (int i = 0; i <= n * 2; i += 2) {\n    for (int j = -n / 2 * 2; j <= n / 2 * 2; j += 2) {\n      int x = (i + j) / 2, y = (i - j) / 2;\n      if ((i + j & 1) || x < 0 || x >= n || y < 0 || y >= n || (x + y & 1)) {\n        continue;\n      }\n      ans[x][y] = pri[i / 2] * pri[(j + n / 2 * 2) / 2 + n];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i + j & 1) {\n        std::vector<int> dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          if (x < 0 || x >= n || y < 0 || y >= n) {\n            continue;\n          }\n          ans[i][j] = ans[i][j] / __gcd(ans[i][j], ans[x][y]) * ans[x][y];\n        }\n        ans[i][j]++;\n      }\n    }\n  }\n  n -= add;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 505;\nconst int P = 8005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, pr[P], pcnt, vis[P];\nLL a[N][N], mx;\n//set<LL> S;\n\nLL gcd(LL x, LL y) {\n\treturn (!y)? x : gcd(y, x % y);\n}\n\ninline LL lcm(LL x, LL y) {\n\tif (!x || !y) return x + y;\n\treturn x / gcd(x, y) * y;\n}\n\nvoid init() {\n\tread(n);\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 2; i <= 8000; ++i) {\n\t\tif (!vis[i]) {\n\t\t\tpr[++pcnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= pcnt && i * pr[j] <= 8000; ++j) {\n\t\t\tvis[i * pr[j]] = 1;\n\t\t\tif (i % pr[j]) continue;\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i + j) & 1) {\n\t\t\t\ta[i][j] = pr[(i + j) / 2] * pr[(n - i + 1 + j) / 2 + n / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (!((i + j) & 1)) {\n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1])) + 1;\n\t\t\t}\n\t\t\tprintf(\"%lld \", a[i][j]);\n/*mx = max(mx, a[i][j]);\nif (S.find(a[i][j]) != S.end()) {\n\tprintf(\"error\\n\");\n}\nS.insert(a[i][j]);*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//printf(\"%lld\\n\", mx);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int lim = 4e4, Nmax = 505;\ntypedef long long ll;\n\nint i, j;\nll a[Nmax][Nmax];\nvector<int> primes;\nbool used[lim+2];\n\nvoid run_primes()\n{\n    int i;\n    for(i=2; i<=lim; ++i)\n        if(!used[i])\n        {\n            primes.push_back(i);\n            for(j=i*i; j<=lim; j+=i) used[j] = 1;\n        }\n}\n\nint main()\n{\n   // freopen(\"input\", \"r\", stdin);\n\n    run_primes();\n\n    int n, N;\n    cin >> N;\n    n = N + ((N&1)^1);\n\n    for(i=0; i<n; ++i)\n        for(j=0; j<n; ++j)\n            if(!((i+j)&1)) a[i][j] = (ll) primes[(i+j)/2] * primes[(i-j)/2 + n + 1];\n\n    for(i=0; i<n; ++i)\n        for(j=0; j<n; ++j)\n            if((i+j)&1)\n            {\n                if(j && j<n-1) a[i][j] = a[i][j-1] * a[i][j+1] + 1;\n                    else a[i][j] = a[i-1][j] * a[i+1][j] + 1;\n            }\n\n    for(i=0; i<N; ++i)\n        for(j=0; j<N; ++j)\n            cout << a[i][j] << \" \\n\"[j==N-1];\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nint m,rm;\nbool np[10001];\nint pr[1011],pn;\nint arr[1011],an;\nint a2[1011],a2n;\nll a[511][511];\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\nint main()\n{\n\tfor(int i=2;i<=6000;i++)\n\t{\n\t\tif(!np[i])pr[pn++]=i;\n\t\tfor(int j=i+i;j<=6000;j+=i)np[j]=1;\n\t}\n\tint it=0;\n\twhile(pr[it]<=500)it++;\n\tfor(int i=0;i<=255;i++)arr[an++]=pr[it+i];\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i<n-i)a2[++a2n]=i,a2[++a2n]=n-i+1;\n\t\telse if(i==n-i)a2[++a2n]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((i+j-1)&1)\n\t\t\t{\n\t\t\t\ta[i][j]=1ll*a2[i]*arr[(j-1)/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tfor(int d=0;d<4;d++)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni>=1&&ni<=n&&nj>=1&&nj<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i][j]==0)a[i][j]=a[ni][nj];\n\t\t\t\t\t\telse a[i][j]=a[i][j]/__gcd(a[i][j],a[ni][nj])*a[ni][nj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j]>5e14)cerr<<i<<\",\"<<j<<\" \"<<a[i][j]<<endl;\n\t\t\t\tassert(a[i][j]<=5e14);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tputi(a[i][j]<<1|((i+j)&1));\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cstdio>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nconst int N = 60000;\nbool f[N];\nvector<int> p;\n#define i64 long long int\ni64 a[1002][1002];\nvoid init(){\n\tfor(int i=2; i<N; i++){\n\t\tif(!f[i])p.push_back(i);\n\t\tfor(auto y : p){\n\t\t\tint x = y * i;\n\t\t\tif(x>=N)break;\n\t\t\tf[x] = true;\n\t\t\tif(i%y==0)break;\n\t\t}\n\t}\n\treverse(p.begin(), p.end());\n\tp.resize(5002);\n}\ni64 gen(i64 ff,int t){\n\tif(ff > 0)\n\t\treturn ff * p[t];\n\telse{\n\t\tff = -ff;\n\t\treturn ff * (ff+1) * p[t] * p[t+1] + 1;\n\t}\n}\nbool chk(i64 x,i64 y){\n\tif(x>y)swap(x,y);\n\treturn y%x==1;\n}\nset<i64> s;\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\tfor (int i = 2, ff = 1; i <= 2 * n; i++) {\n\t\tint mid = labs(ff) + 2501;\n\t\tfor (int x = 1; x < i; x++) {\n\t\t\ta[x][i - x] = gen(ff, mid);\n\t\t\tmid--;\n\t\t}\n\t\tif (ff > 0) ff = -ff;else\n\t\t\tff = -ff + 1;\n\t}\n\tios::sync_with_stdio(false);\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++){\n\t\ts.insert(a[i][j]);\n\t\tif(i<n)assert(chk(a[i][j], a[i+1][j]));\n\t\tif(j<n)assert(chk(a[i][j],a[i][j+1]));\n\t\tcout << a[i][j] << (j < n ? ' ' : '\\n');\n\t}\n\tassert(s.size() == n*n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tvector<vector<int>> ans(500, vector<int>(500, 1));\n\tvector<int> pr;\n\tfor (int i = 2; i <= 20000; i++) {\n\t\tbool flag = true;\n\t\tfor (int j = 2; j*j <= i; j++) {\n\t\t\tif (i%j == 0) flag = false;\n\t\t}\n\t\tif (flag) pr.pb(i);\n\t}\n\tint idx = 0;\n\tfor (int i = 0; i < 1000; i += 2) {\n\t\tfor (int j = 0; j < 500; j++) {\n\t\t\tint k = i - j;\n\t\t\tif (0 <= k && k < 500) ans[j][k] *= pr[idx];\n\t\t}\n\t\tidx++;\n\t}\n\tfor (int i = 0; i < 1000; i += 2) {\n\t\tfor (int j = 0; j < 500; j++) {\n\t\t\tint k = -i + j + 500;\n\t\t\tif (0 <= k && k < 500) ans[j][k] *= pr[idx];\n\t\t}\n\t\tidx++;\n\t}\n\trep(i, 500) {\n\t\trep(j, 500) {\n\t\t\tif (i % 2 != j % 2) {\n\t\t\t\tif (i != 0) ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n\t\t\t\tif (i != 499) ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n\t\t\t\tif (j != 0) ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n\t\t\t\tif (j != 499) ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcout << ans[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll gcd(ll a, ll b){\n  if(b == 0){\n    return a;\n  }\n  else{\n    return gcd(b,(a%b));\n  }\n}\nll lcm(ll a,ll b){\n  return a/gcd(a,b)*b;\n}\n\nint main() {\n  vector<ll> prime;\n  prime={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\n197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\n311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\n431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,\n563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,\n673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\n809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\n937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039,\n1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153,\n1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279,\n1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409,\n1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499,\n1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613,\n1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741,\n1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873,\n1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999,\n2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113,\n2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251,\n2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371,\n2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477,\n2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647,\n2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731,\n2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857,\n2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001,\n3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163,\n3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299,\n3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407,\n3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539,\n3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659,\n3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793,\n3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919,\n3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051,\n4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201,\n4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327,\n4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463,\n4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603,\n4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733,\n4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903,\n4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009,\n5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153,\n5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303,\n5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441,\n5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569,\n5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701,\n5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843,\n5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987,\n6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131,\n6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269,\n6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373,\n6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553,\n6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691,\n6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829,\n6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967,\n6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109,\n7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247,\n7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451,\n7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559,\n7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687,\n7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841,\n7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993,\n8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147,\n8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287,\n8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431,\n8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599,\n8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719,\n8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849,\n8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007,\n9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157,\n9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293,\n9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431,\n9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551,\n9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721,\n9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851,\n9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973};\n////////////////////////////////////////////\n  ll ans[500][500];\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      ans[i][j]=1;\n    }\n  }\n  int a=1,b=1000;\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      if(i==j){\n        if(i%2==0){\n          ans[i][j]=prime.at(a);\n          a++;\n        }\n        else{\n          ans[i][j]=prime.at(b);\n          b--;\n        }\n      }\n    }\n  }\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      if((i+j)%2==0){\n        ans[i][j]=ans[(i+j)/2][(i+j)/2];\n      }\n    }\n  }\n  int x;\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      if((i+j)%2==0){\n        x=499-i+j;\n        x=x/2+1;\n        ans[i][j]*=prime.at(250+x);\n      }\n    }\n  }\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      if((i+j)%2==1){\n        if(i>0){\n          ans[i][j]=lcm(ans[i][j],ans[i-1][j]);\n        }\n        if(i<499){\n          ans[i][j]=lcm(ans[i][j],ans[i+1][j]);\n        }\n        if(j>0){\n          ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n        }\n        if(j<499){\n          ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n        }\n        ans[i][j]+=1;\n      }\n    }\n  }\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      cout<<ans[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < (int)(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nint lcm(int a, int b) {\n    return a / __gcd(a, b) * b;\n}\n\nint lcm(vi vec) {\n    if (vec.empty())\n        return 1;\n    int ret = vec[0];\n    for (int i = 1; i < SZ(vec); ++i)\n        ret = lcm(ret, vec[i]);\n    return ret;\n}\n\nvi di = {0, 0, -1, 1};\nvi dj = {-1, 1, 0, 0};\n\nvoid smain() {\n    int n;\n    cin >> n;\n    vvl a(n, vl(n, 0));\n    int cur = 1;\n    set<int> used;\n    fori (i, n) {\n        fori (j, n) {\n            if ((i ^ j) & 1) {\n                a[i][j] = cur++;\n                used.insert(a[i][j]);\n            }\n        }\n    }\n\n    fori (i, n) {\n        fori (j, n) if (a[i][j] == 0) {\n            vi vec;\n\n            fori (dir, SZ(di)) {\n                int ii = i + di[dir];\n                int jj = j + dj[dir];\n                if (ii >= 0 && ii < n && jj >= 0 && jj < n) {\n                    vec.push_back(a[ii][jj] + 1);\n                }\n            }\n            int x = lcm(vec);\n            int cur = x;\n            while (used.count(cur))\n                cur += x;\n            a[i][j] = cur;\n            used.insert(a[i][j]);\n        }\n    }\n\n    fori (i, n) {\n        fori (j, n) {\n            cerr << a[i][j] * 2 + 2 << ' ';\n        }\n        cerr << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(MAX_N);\n    for (int i = 0; i < MAX_N; i++) {\n        ans[i].resize(MAX_N);\n    }\n\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = (i % 2); j < MAX_N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + MAX_N) / 2;\n            ans[i][j] =\n                primes[((p % 2 == 0) ? (p / 2) : (MAX_N - 1 - p / 2))] *\n                primes[((q % 2 == 0) ? (q / 2) : (MAX_N - 1 - q / 2)) + MAX_N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = 1 - (i % 2); j < MAX_N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < MAX_N && 0 <= j + dj[k] &&\n                    j + dj[k] < MAX_N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                }\n            }\n            ans[i][j]++;\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long grid[1000][1000];\nint main() {\n#define int long long\n\tvector<int> sosuu;\n\tfor (int i = 2; i <= 10000; ++i) {\n\t\tint ok = 1;\n\t\tfor (int q = 2; q <= sqrt(i); ++q) {\n\t\t\tif (i % q == 0) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok == 1) continue;\n\t\tsosuu.push_back(i);\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tgrid[i][q] = 1;\n\t\t}\n\t}\n\tint now_itr = 0;\n\tfor (int i = 0; i < 1000; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i - q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tfor (int i = -1000; i < 500; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i + q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tint xe[4] = { 1,-1,0,0 };\n\tint ye[4] = { 0,0,-1,1 };\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tif ((i + q) % 2 == 0) continue;\n\t\t\tint now_lcm = 1;\n\t\t\tREP(j, 4) {\n\t\t\t\tint x = xe[j] + i;\n\t\t\t\tint y = ye[j] + q;\n\t\t\t\tif (x >= 0 && x < 500 && y >= 0 && y < 500) {\n\t\t\t\t\tint hoge = gcd(now_lcm, grid[x][y]);\n\t\t\t\t\tnow_lcm /= hoge;\n\t\t\t\t\tnow_lcm *= grid[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid[i][q] = now_lcm + 1LL;\n\t\t}\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tREP(j, 4) {\n\t\t\t\tint x = xe[j] + i;\n\t\t\t\tint y = ye[j] + q;\n\t\t\t\tif (x >= 0 && x < 500 && y >= 0 && y < 500) {\n\t\t\t\t\tassert(max(grid[x][y], grid[i][q]) % min(grid[x][y], grid[i][q]) == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tREP(q, n) {\n\t\t\tif (q != 0) cout << \" \";\n\t\t\tcout << grid[i][q];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvvi out(500,vi(500,1));\nint gcd(int a,int b){\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(int a,int b){\n\treturn a/gcd(a,b)*b;\n}\nsigned main(){\n\tconst int M=10000;\n\tint sosu[M]={1,1,0};\n\tfor(int i=2;i*i<M;i++)if(sosu[i]==0)\n\tfor(int j=i*2;j<M;j+=i)sosu[j]=1;\n\tvi sos;\n\trep(i,M)if(sosu[i]==0)sos.pb(i);\n\t\n\tint n;\n\tcin>>n;\n\tint t=0;\n\trep(i,500){\n\t\tint x=0,y=i*2;\n\t\twhile(y>=0){\n\t\t\tif(x<500&&y<500)out[x][y]*=sos[t];\n\t\t\tx++;y--;\n\t\t}\n\t\tt++;\n\t}\n\trep(i,500){\n\t\tint x=0,y=500-2*i;\n\t\twhile(x<500){\n\t\t\tif(0<=y&&y<500)out[x][y]*=sos[t];\n\t\t\tx++;y++;\n\t\t}\n\t\tt++;\n\t}\n\trep(x,500)rep(y,500)if(out[x][y]==1){\n\t\tt=1;\n\t\tif(x<499)t=lcm(t,out[x+1][y]);\n\t\tif(x)t=lcm(t,out[x-1][y]);\n\t\tif(y<499)t=lcm(t,out[x][y+1]);\n\t\tif(y)t=lcm(t,out[x][y-1]);\n\t\tout[x][y]=t+1;\n\t}\n\tint ma=0;\n\trep(i,500)rep(j,500)cmax(ma,out[i][j]);\n\trep(i,n){rep(j,n)cout<<out[i][j]<<\" \";cout<<endl;}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MN 505\nusing namespace std;\ntypedef long long ll;\nint n,pr[MN<<2],tt;bool p[MN*MN];\nll a[MN][MN];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=1e5;i++){\n\t\tif(!p[i]){\n\t\t\tpr[++tt]=i;\n\t\t\tif(tt>=4*n)break;\n\t\t}\n\t\tfor(int j=1;j<=tt;j++){\n\t\t\tif(i*pr[j]>1e5)break;\n\t\t\tp[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==0){\n\t\t\t\ta[i][j]=1ll*pr[i+j>>1]*pr[(i-j)/2+n];\n\t\t\t}else {\n\t\t\t\ta[i][j]=1ll*pr[i+j>>1]*pr[(i+j+1)>>1]*pr[(i-j)/2+n]*pr[(i-j+1)/2+n];a[i][j]++;\n\t\t\t}\n\tfor(int i=1;i<=n;i++){for(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);puts(\"\");}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MaxN = 5e2 + 17;\nlong long arr[MaxN][MaxN];\nlong long prime[4 * MaxN];\nlong long second_matrix[MaxN][MaxN];\nint x[] = {-1, 1, 0, 0};\nint y[] = {0, 0, -1, 1};\nint n = 505;\nmap<long long, bool> mp;\n\nlong long lcm(long long a, long long b)\n{\n    return (a * b) / __gcd(a, b);\n}\n\nvoid erich()\n{\n    const int MaxS = 2e4 + 17;\n    bool isPrime[MaxS];\n\n    for(int i = 2; i < MaxS; ++i)\n        isPrime[i] = 1;\n\n    int next = 1;\n\n    for(int i = 2; i < MaxS; ++i)\n    {\n        if(isPrime[i])\n        {\n            prime[next++] = i;\n\n            for(int j = i + i; j < MaxS; j += i)\n                isPrime[j] = 0;\n\n        }\n    }\n}\n\nvoid fill_sec()\n{\n    for(int i = n - !(n % 2), j = 1; i >= 1; i -= 2, ++j)\n    {\n        int x = i;\n        int y = 1;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + j];\n            ++x;\n            ++y;\n        }\n    }\n\n    for(int i = 3, j = 1; i <= n; i += 2, ++j)\n    {\n        int x = 1;\n        int y = i;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + n / 2 +  n % 2 + j];\n            ++x;\n            ++y;\n        }\n    }\n}\n\nvoid fill_matrix()\n{\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if(!((i + j) & 1))\n                arr[i][j] = prime[(i + j) / 2] * second_matrix[i][j];\n\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if((i + j) & 1)\n            {\n                arr[i][j] = 1;\n\n                for(int k = 0; k < 4; ++k)\n                {\n                    int xx = i + x[k];\n                    int yy = j + y[k];\n\n                    if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                        arr[i][j] = lcm(arr[i][j], arr[xx][yy]);\n                }\n\n                ++arr[i][j];\n            }\n\n}\nbool check(long long a, long long b)\n{\n    return max(a, b) % min(a, b) == 1;\n}\nbool check()\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            for(int k = 0; k < 4; ++k)\n            {\n                int xx = i + x[k];\n                int yy = j + y[k];\n\n                //if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n            }\n        }\n    }\n\n    return true;\n}\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    erich();\n    fill_sec();\n    fill_matrix();\n\n    int m;\n    cin >> m;\n\n    for(int i = 1; i <= m; ++i)\n    {\n        for(int j = 1; j <= m; ++j)\n            cout << arr[i][j] << ' ';\n        cout << '\\n';\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 507;\nconst int MAXS = 2000007;\n\nint n;\nLL a[MAXN][MAXN];\nint p[MAXS];\nset < LL > s;\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nLL gcd ( LL x, LL y )\n{\n\treturn y ? gcd ( y, x%y ) : x;\n}\n\nLL lcm ( LL x, LL y )\n{\n\treturn ( ( ~x ) && ( ~y ) ) ? ( x / gcd ( x, y ) * y ) : ( ~x ) ? x : y;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d\", &n );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( ( i & 1 ) == ( j & 1 ) ){\n\t\t\t\ta[i][j] = ( i + j + 2 * n + 1 ) * ( i - j + n );\n\t\t\t\ts.insert ( a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tLL g = -1;\n\t\t\t\tif ( i > 1 ) g = lcm ( g, a[i-1][j] );\n\t\t\t\tif ( i < n ) g = lcm ( g, a[i+1][j] );\n\t\t\t\tif ( j > 1 ) g = lcm ( g, a[i][j-1] );\n\t\t\t\tif ( j < n ) g = lcm ( g, a[i][j+1] );\n\t\t\t\tLL cg = g + 1;\n\t\t\t\twhile ( s.find ( cg ) != s.end () ) cg += g;\n\t\t\t\ta[i][j] = cg;\n\t\t\t\ts.insert ( a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ) printf ( \"%lld \", a[i][j] );\n\t\tputchar ( '\\n' );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 510;\nint n;\n\nll ans[N][N];\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\n\tll cur=2;\n\n\tint i=0;\n\tfor(i=0; i<=n; i+=4) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\tcur++;\n\t\t}\n\t}\n\ti-=2; if(i>n) i-=4;\n\twhile(i>0) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\tcur++;\n\t\t}\n\t\ti-=4;\n\t}\n\n\n\tfor(int i=1; i<n; i+=2) {\n\t\tfor(int j=0; j<=n; j+=2) {\n\t\t\tans[i][j] = ans[i-1][j]*ans[i+1][j]+1;\n\t\t}\n\n\t\tfor(int j=1; j<n; j+=2) {\n\t\t\tans[i][j] = ans[i-1][j]*ans[i+1][j]*ans[i][j-1]*ans[i][j+1] +1;\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=0; j<n; j++) printf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nlong long n, x, mod, nr, i, j, a[505][505], d;\nlong long cmmmc(long long a, long long b) {\n    long long x = a, y = b;\n    long long c;\n    while(b) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n    long long rez = a;\n    rez = x * y / a;\n    return rez;\n}\nint main()\n{\n    cin >> n;\n    mod = 2;\n    a[1][1] = 2;\n    for (i = 2; i <= n; i++)\n        a[1][i] = a[1][i - 1] + 1;\n    for (i = 2; i <= n; i++)\n    {\n        if (i % 2 == 1)\n        {\n            a[i][1] = a[i - 1][1];\n            for (j = 2; j <= n; j++)\n            {\n                a[i][j] = cmmmc(a[i][j - 1], a[i - 1][j]) + 1;\n            }\n        }\n        else\n        {\n            a[i][n] = a[i - 1][n] + 2;\n            for(j = n - 1; j >= 1; j--)\n            {\n                a[i][j] = cmmmc(a[i][j + 1], a[i - 1][j]) + 1;\n            }\n        }\n    }\n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n            cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 250010\n#define N 1010\nusing namespace std;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint prime[maxn], tot_prime;\nll res[N][N];\nset<ll> S;\nll gcd(ll a, ll b)\n{\n\tll y = a % b;\n\twhile (y)\n\t{\n\t\ta = b;\n\t\tb = y;\n\t\ty = a % b;\n\t}\n\treturn b;\n}\nbool check(int x)\n{\n\tfor (int i = 2; i <= x - 1; i++)\n\t\tif (x % i == 0) return true;\n\treturn false;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tll T = 1e15;\n\tfor (int i = 1; i <= 10000; i++)\n\t\tif (check(i)) prime[++tot_prime] = i;\n\tint cur = 0;\n\tfor (int i = 2; i <= n + n; i += 2)\n\t{\n\t\tcur++;\n\t\tfor (int j = 1; j <= i && j <= n; j++)\n\t\t{\n\t\t\tint x = j, y = i - j;\n\t\t\tif (y <= n) res[x][y] *= prime[cur];\n\t\t}\n\t}\n\tint st = 1 - n;\n\tif (st % 2) st++;\n\tcur = 0;\n\tfor (int i = st; i <= n - 1; i += 2)\n\t{\n\t\tcur++;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tint x = j, y = x - i;\n\t\t\tif (x > 0 && y > 0 && x <= n && y <= n) res[x][y] *= prime[cur];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) % 2)\n\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t{\n\t\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\t\tif (tx && ty && tx <= n && ty <= n) res[i][j] = res[i][j] / gcd(res[i][j], res[tx][ty]) * res[tx][ty];\n\t\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tll pre = res[i][j];\n\t\t\twhile (S.find(res[i][j]) != S.end()) res[i][j] += pre;\n\t\t\tS.insert(res[i][j]);\n\t\t\tprintf(\"%lld \", res[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "  #include <bits/stdc++.h>\n  template <size_t N>\n  class sieve_of_eratosthenes {\n    std::bitset<N> is_prime_;\n\n  public:\n    constexpr sieve_of_eratosthenes(){\n      is_prime_ = ~is_prime_;\n      is_prime_.reset(0), is_prime_.reset(1);\n      for (size_t p = 2; p < N; p++) {\n        if (!is_prime_.test(p)) continue;\n        for (size_t j = 2; j * p < N; j++) {\n          is_prime_.reset(p * j);\n        }\n      }\n    }\n\n    // Return the bitset testing if a number is prime.\n    constexpr const auto& is_prime() const {return is_prime_;}\n\n    // Returns the vector of prime numbers.\n    template <typename T>\n    auto primes() const {\n      std::vector<T> primes{}; \n      for (size_t i = 0; i < N; i++) {\n        if (is_prime_.test(i)) primes.push_back(i);\n      }\n      return primes;\n    }\n  };\n  int main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  auto primes = sieve_of_eratosthenes<10000000>{}.primes<long long>();\n  auto make = [&] (int n) {\n    auto ans = std::vector<std::vector<long long>>(n, std::vector<long long>(n, 0));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        auto anti_diag = (i + j) / 2;\n        auto diag = (i - j) >> 1;\n        if ((i + j) % 2 == 0) {\n          ans.at(i).at(j) =\n            primes.at(anti_diag) *\n            primes.at(n +  diag);\n        } else {\n          ans.at(i).at(j) =\n            primes.at(anti_diag    ) *\n            primes.at(anti_diag + 1) *\n            primes.at(n +  diag    ) *\n            primes.at(n +  diag + 1) + 1;\n        }\n      }\n    }\n    return ans;\n  };\n  int n; std::cin >> n;\n  auto large = make(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      std::cout << (j > 0 ? \" \" : \"\") << large.at(i).at(j);\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 507;\nconst int MAXS = 2000007;\n\nint n;\nLL a[MAXN][MAXN];\nbool isp[MAXS];\nint prm[MAXS], kp;\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nLL gcd ( LL x, LL y )\n{\n\treturn y ? gcd ( y, x%y ) : x;\n}\n\nLL lcm ( LL x, LL y )\n{\n\treturn ( ( ~x ) && ( ~y ) ) ? ( x / gcd ( x, y ) * y ) : ( ~x ) ? x : y;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n\t\n\tINIT ( isp, true );\n\tisp[0] = isp[1] = false;\n\tlp ( i, 2, MAXS ){\n\t\tif ( isp[i] ) prm[++kp] = i;\n\t\tfor ( int j = 1; j <= kp && prm[j] * i < MAXS; ++j ){\n\t\t\tisp[prm[j]*i] = false;\n\t\t\tif ( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d\", &n );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tif ( n == 2 ){\n\t\tprintf ( \"2 3\\n5 16\\n\" );\n\t\treturn;\n\t}\n\t\n\tint pi = 0;\n\tfor ( int i = 1; i <= n; i += 2 ){\n\t\tfor ( int j = 1; j <= n; j += 2 ){\n\t\t\ta[i][j] = prm[++pi];\n\t\t\tif ( i < n && j < n ) a[i+1][j+1] = 2 * a[i][j];\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tLL g = -1;\n\t\t\t\tif ( i > 1 ) g = lcm ( g, a[i-1][j] );\n\t\t\t\tif ( i < n ) g = lcm ( g, a[i+1][j] );\n\t\t\t\tif ( j > 1 ) g = lcm ( g, a[i][j-1] );\n\t\t\t\tif ( j < n ) g = lcm ( g, a[i][j+1] );\n\t\t\t\ta[i][j] = g + 1; \n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ) printf ( \"%lld \", a[i][j] );\n\t\tputchar ( '\\n' );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 500;\nconst int MAX2 = 10000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 2 << \" \" << 9 << endl << 4 << \" \" << 17;\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX2];\n\tfor (int i = 0;i < MAX2;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX2 - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tstatic int64_t a[MAX][MAX];\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\ta[i][j] = prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積+1\n\t\t\t\tif (i == 0 && j == N - 1) a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t\telse if (i == N - 1 && j == 0) a[i][j] = (int64_t)prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t\telse a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tvector<int64_t> chk;\n\tfor (int i = 0;i < N;++ i) { // 要らないけど、整合性チェック\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tint d[] = {0, 1, 0, -1, 0};\n\t\t\tint check[] = {-1, -1, -1, -1};\n\t\t\tfor (int k = 0;k < 4;++ k) {\n\t\t\t\tif (i + d[k] >= 0 && i + d[k] < N && j + d[k + 1] >= 0 && j + d[k + 1] < N) {\n\t\t\t\t\tcheck[k] = max(a[i][j], a[i + d[k]][j + d[k + 1]]) % min(a[i][j], a[i + d[k]][j + d[k + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(check, check+4);\n\t\t\tfor (int i = 0;i < 3;i ++) {\n\t\t\t\tif (check[i] >= 0 && check[i] != check[i + 1]) {\n\t\t\t\t\tcerr << \"err\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i][j] >= 1000000000000000) cerr << \"err\" << endl;\n\t\t\tchk.push_back(a[i][j]);\n\t\t}\n\t}\n\tsort(chk.begin(), chk.end());\n\tfor (int i = 1;i < chk.size();++ i) {\n\t\tif (chk[i] == chk[i - 1]) cerr << \"err\" << endl;\n\t}\n\tcerr << chk[chk.size() - 1] << endl;\n\t*/\n\t\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数+1にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは1だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5, M = 1005;\nint n, a[M][M], prime[N], vis[N], tot;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid init(int n)\n{\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tif(!vis[i]) prime[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= n; j ++)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\nint gcd(int a, int b) {return !b ? a : gcd(b, a % b);}\nint lcm(int a, int b)\n{\n\tif(!a || !b) return a + b;\n\treturn a / gcd(a, b) * b;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tinit(10000); n = read();\n\tif(n == 2) {puts(\"4 7\\n23 10\\n\"); return 0;}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\tfor(int i = 1; i <= n; i ++, printf(\"\\n\"))\n\t\tfor(int j = 1; j <= n; j ++, printf(\" \"))\n\t\t\tprintf(\"%lld\", a[i][j]);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100001\nusing namespace std;\nint n, prime[maxn], d[maxn], a[maxn], f[2001][2001], ans, cnt;\nint val1[maxn], val2[maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t \n\tfor(int i = 2; i <= 10000; i++){\n\t\tif(!d[i] && i != 2) prime[++cnt] = i;\n\t\tfor(int j = i; j <= 10000; j += i) d[j] = 1;\n\t}\n\tcin >> n; \n\tif (n==2) {\n  \t\tputs(\"4 7\");\n  \t\tputs(\"23 10\");\n  \t\treturn 0;\n  \t}\n\t  cnt = 0;\n\t for(int i = 1; i <= n ; i++)\n    for(int j = 1; j <= n; j++)\n      if (i + j & 1) {\n      \tif (!val1[i - j + n]) val1[i-j+n]=prime[++cnt];\n      \tf[i][j]=val1[i - j + n];\n\t  }\n  for(int i = 1; i <= n; i++)\n    for(int j = 1; j <= n ; j++)\n      if (i + j & 1) {\n      \tif (!val2[i + j]) val2[i + j]=prime[++cnt];\n      \tf[i][j]*=val2[i + j];\n\t  }\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(i + j & 1) continue; ans = 1;\n\t\t\tif(f[i - 1][j]) ans = ans / __gcd(f[i - 1][j], ans) * f[i - 1][j];\n\t\t\tif(f[i + 1][j]) ans = ans / __gcd(f[i + 1][j], ans) * f[i + 1][j];\n\t\t\tif(f[i][j + 1]) ans = ans / __gcd(f[i][j + 1], ans) * f[i][j + 1];\n\t\t\tif(f[i][j - 1]) ans = ans / __gcd(f[i][j - 1], ans) * f[i][j - 1];\n\t\t\tf[i][j] = ans + 1;\n\t\t}\n\tfor(int i  = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \", f[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nint main(){\n\tint n=read();\n\tREP(i,1,n) REP(j,1,n) printf(\"%d%c\",i+j,j==jend?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 1010;\ntypedef long long LL;\nint pri[MAXN], bak, n;\nint ispri(int x) {\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\nLL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }\nLL lcm(LL a, LL b) { return a / gcd(a, b) * b; }\nLL get(int x, int y) {\n\tif (x < 1 || y < 1 || x > n || y > n) return 1;\n\tif ((x & 1) == (y & 1))\n\t\treturn pri[x + y >> 1] * pri[x + n * 3 - y + 1 >> 1];\n\treturn lcm(lcm(get(x - 1, y), get(x, y - 1)), lcm(get(x + 1, y), get(x, y + 1))) + 1;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n; n += 2;\n\tint now = 2;\n\twhile (bak < n * 2) {\n\t\tif (ispri(now)) pri[++bak] = now;\n\t\t++now;\n\t}\n\tfor (int i = 2; i < n; ++i, std::cout << '\\n')\n\t\tfor (int j = 2; j < n; ++j)\n\t\t\tstd::cout << get(i, j) << ' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 200010;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst int INF = 1000000010;\n\nint n;\nint b[MAXN], tot, p[MAXN];\nll a[555][555];\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a%b) : a;\n}\n\nll lcm(ll a)\n{\n\treturn a;\n}\n\ntemplate<class A, class... B>\nll lcm(A a, B... b)\n{\n\tauto c = lcm(b...);\n\treturn c ? (a ? a/gcd(a, c)*c : c) : a;\n}\n\nint main()\n{\n\t\n\tfor (int i = 2; i <= 200000; ++ i)\n\t\tif (!b[i])\n\t\t{\n\t\t\tp[++ tot] = i;\n\t\t\tfor (int j = i+i; j <= 200000; j += i)\n\t\t\t\tb[j] = 1;\n\t\t}\n\tfor (int i = 1; i <= 500; ++ i)\n\t\tfor (int j = 1; j <= 500; ++ j)\n\t\t{\n\t\t\tif ((i+j)%2 == 1) continue;\n\t\t\ta[i][j] = (ll)p[(i+j)/2]*p[(i-j)/2+750];\n\t\t}\n\t\n\tfor (int i = 1; i <= 500; ++ i)\n\t\tfor (int j = 1; j <= 500; ++ j)\n\t\t{\n\t\t\tif ((i+j)%2 == 0) continue;\n\t\t\ta[i][j] = lcm(a[i-1][j], a[i][j-1], a[i][j+1], a[i+1][j])+1;\n\t\t}\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nconst int maxp = 8000 + 10;\ntypedef long long ll;\n\nbool notprime[maxp];\nint prime[maxp] , prime_cnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxp;i++){\n\t\tif(!notprime[i]) prime[prime_cnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxp && j < prime_cnt;j++){\n\t\t\tll t = i * prime[j]; notprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nll gcd(ll a,ll b){ return b ? gcd(b,a % b) : a;}\nll lcm(ll a,ll b) { return a / gcd(a,b) * b;}\n\nconst int maxn = 500 + 10;\nll a[maxn][maxn];\nint cnt,n;\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&n);\n\tif(n == 2) return !printf(\"4 7\\n23 10\");\n\tfor(int i = 0;i <= n + 1;i++){\n\t\tfor(int j = 0;j <= n + 1;j++){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 ==  0){\n\t\t\t\ta[i][j] = prime[(i + j >> 1) - 1] * prime[(i - j) / 2 + n * 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) & 1){\n\t\t\t\ta[i][j] = lcm(a[i][j - 1] , lcm(a[i][j + 1],lcm(a[i - 1][j],a[i + 1][j])));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%I64d%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1005;\nint Notprime[MAXN * 100], Prime[MAXN * 100], tot;\nLL a[MAXN][MAXN];\n\nvoid Euler(int Max) {\n  for (RI i = 2; i <= Max; ++i) {\n    if (!Notprime[i]) Prime[++tot] = i;\n    for (RI j = 1; j <= tot && i * Prime[j] <= Max; ++j) {\n      Notprime[i * Prime[j]] = 1;\n      if (i % Prime[j] == 0) break;\n    }\n  }\n}\ninline LL lcm(LL x, LL y) {\n  if (!x || !y) return x | y;\n  return x / __gcd(x, y) * y;\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n; read(n);\n  Euler(100000);\n  if (n == 2) return puts(\"4 7\\n23 10\"), 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 1; j <= n; ++j)\n      if ((i + j) & 1)\n        a[i][j] = 1ll * Prime[(i + j) >> 1] * Prime[(i - j + n + 1) / 2 + n - 1];\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 1; j <= n; ++j)\n      if (!((i + j) & 1))\n        a[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1])) + 1;\n  for (RI i = 1; i <= n; ++i, puts(\"\"))\n    for (RI j = 1; j <= n; ++j)\n      printf(\"%lld \", a[i][j]);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint prim[100100],ilem;\nbool vis[100100];\nvoid get_prim(){\n\tfor(int i=2;i<=100000;i++){\n\t\tif(!vis[i])\n\t\t\tprim[++ilem]=i;\n\t\tfor(int j=1;j<=ilem;j++){\n\t\t\tif(i*(long long)prim[j]>100000) break;\n\t\t\tvis[i*prim[j]]=1;\n\t\t\tif(i%prim[j]==0) continue;\n\t\t}\n\t}\n}\nlong long a[510][510];\nmap<long long,int> mp;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tget_prim();\n\tint mxc=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint cnt=0;\n\t\tfor(int j=1+(i&1);j<=n;j+=2){\n\t\t\tcnt++;\n\t\t\ta[i][j]=cnt+1;\n\t\t}\n\t}\n\twhile(prim[mxc]<=260) mxc++;\n\tfor(int i=1;i<=n;i+=2){\n\t\t\n\t\tmxc++;\n\t\tfor(int j=1+(i&1);j<=n;j+=2)\n\t\t\ta[i][j]=a[i][j]*prim[mxc];\n\t}\n\tfor(int i=(n&1)?n-1:n;i>0;i-=2){\n\t\tmxc++;\n\t\tfor(int j=1+(i&1);j<=n;j+=2)\n\t\t\ta[i][j]=a[i][j]*prim[mxc];\n\t}\n\tlong long x,y;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1+(!(i&1));j<=n;j+=2){\n\t\t\tif(i==1) x=a[i+1][j];\n\t\t\telse if(i==n) x=a[i-1][j];\n\t\t\telse x=a[i+1][j]*a[i-1][j]/__gcd(a[i+1][j],a[i-1][j]);\n\t\t\tif(j==1) y=a[i][j+1];\n\t\t\telse if(j==n) y=a[i][j-1];\n\t\t\telse y=a[i][j+1]*a[i][j-1]/__gcd(a[i][j+1],a[i][j-1]);\n\t\t\ta[i][j]=x/__gcd(x,y)*y+1;\n//\t\t\tif(i==n-1&&j==n-1)\n//\t\t\t\tcerr<<x<<\" \"<<y<<\" \"<<__gcd(a[i][j+1],a[i][j-1])<<endl;\n//\t\t\tif(a[i][j]>1e15) cerr<<\"fuck\"<<endl;\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n//\t\t\tif(mp[a[i][j]]) cerr<<i<<\" \"<<j<<endl;\n//\t\t\tmp[a[i][j]]=1;\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define REP1(i,a) for(int i=1;i<=(a);i++)\n#define rREP(i,a) for(int i=(a-1);i>=0;i--)\n#define rREP1(i,a) for(int i=(a);i>0;i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a, ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a, ll b){return a/gcd(a,b)*b;}\n\nll sgn(ll n){\n    if(n==0) return 0;\n    else return n/abs(n);\n}\n\nll salv(vll v){\n  say(\"{\");\n  FOR(i,0,v.sz-1){\n    say(v[i]);\n    if(i!=v.sz-1) say(\",\");\n  }\n  sal(\"}\")\n}\n\nll DigS10(ll n){\n  ll m=0;\n  FOR(i,0,DigN10(n)-1){\n    m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n  }\n  return m;\n}\n\nll isP(ll n){\n  if(n<=1) return 0;\n  FOR(i,2,(ll)sqrt(n)){\n    if(n%i==0) return 0;\n  }\n  return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n  ll ans=1,x=(a%MOD);\n  FOR(i,0,DigN2(b)-1){\n    if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n    if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n  }\n  return ans;\n}\n\nvoid CFactM(ll n){\n  FOR(i,FactM.sz,n){\n    FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n  }\n  return;\n}\n\nvoid CFactMI(ll n){\n  CFactM(n);\n  if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n  if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n  rFOR(i,1,n-1){\n    if(FactMI[i]!=-1) break;\n    FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n  }\n  return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n  ll n,m,a[500];\n  cin >> n;\n  REP(i,n){\n    cout << i+2 << \" \";\n    a[i]=i+2;\n  }\n  cout << endl;\n  m=n+1;\n  REP(i,n-1){\n    a[0]=(m+1)/2*2+1;\n    cout << a[0] << \" \";\n    REP1(i,n-1){\n      a[i]=lcm(a[i-1],a[i])+1;\n      cout << a[i] << \" \";\n    }\n    m=a[n-1];\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nLL a[500][500];\nvector<int> v[500][500];\nconst unsigned long long MX = LL(19e18);\n\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; ++i) {\n        if (x % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nset<LL> se;\n\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nLL lcm(unsigned long long a, unsigned long long b) {\n    assert(MX / a > b);\n    return a * b / gcd(a, b);\n}\n\nvoid ap(vector<int> &a, vector<int> &b) {\n    for (int x : b) {\n        a.pb(x);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    if (n == 2) {\n        cout << \"4 7\" << endl;\n        cout << \"23 10\" << endl;\n        return 0;\n    }\n    forn(i, n) forn(j, n) {\n        a[i][j] = 1;\n    }\n    int pr = 2;\n    for (int st = 0; st < 2 * n + 5; st += 2) {\n        bool firstTime = true;\n        for (int i = 0; i < n; ++i) {\n            int j = st - i;\n            if (j >= 0 && j < n) {\n                if (firstTime) {\n                    firstTime = false;\n                    while (!isPrime(pr)) {\n                        ++pr;\n                    }\n                }\n                a[i][j] *= pr;\n                v[i][j].pb(pr);\n            }\n        }\n        if (!firstTime) {\n            ++pr;\n        }\n    }\n    for (int st = 0; st < n; st += 2) {\n        bool firstTime = true;\n        for (int i = 0; i < n; ++i) {\n            int j = i + st;\n            if (j >= 0 && j < n) {\n                if (firstTime) {\n                    firstTime = false;\n                    while (!isPrime(pr)) {\n                        ++pr;\n                    }\n                }\n                a[i][j] *= pr;\n                v[i][j].pb(pr);\n            }\n        }\n        if (!firstTime) {\n            ++pr;\n        }\n    }\n    for (int st = 2; st < n; st += 2) {\n        bool firstTime = true;\n        for (int j = 0; j < n; ++j) {\n            int i = j + st;\n            if (i >= 0 && i < n) {\n                if (firstTime) {\n                    firstTime = false;\n                    while (!isPrime(pr)) {\n                        ++pr;\n                    }\n                }\n                a[i][j] *= pr;\n                v[i][j].pb(pr);\n            }\n        }\n        if (!firstTime) {\n            ++pr;\n        }\n    }\n\n//    forn(i, n) {\n//        forn(j, n) printf(\"%7d\", (int)a[i][j]);\n//        puts(\"\");\n//    }\n\n    LL mx = 0;\n    forn(i, n) forn(j, n) {\n        if ((i + j) % 2 == 1) {\n            LL res = 1;\n            vector<int> vv;\n            if (i > 0) ap(vv, v[i - 1][j]);\n            if (i < n - 1) ap(vv, v[i + 1][j]);\n            if (j > 0) ap(vv, v[i][j - 1]);\n            if (j < n - 1) ap(vv, v[i][j + 1]);\n            sort(vv.begin(), vv.end());\n            res = vv[0];\n            for (int i = 1; i < (int)vv.size(); ++i) {\n                if (vv[i] != vv[i - 1]) {\n                    res *= vv[i];\n                }\n            }\n            res += 1;\n            a[i][j] = res;\n        }\n    }\n\n    forn(i, n) forn(j, n) {\n        mx = max(mx, a[i][j]);\n        assert(!se.count(a[i][j]));\n        se.insert(a[i][j]);\n    }\n\n    forn(i, n) {\n        forn(j, n) printf(\"%I64d \", a[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconstexpr int maxn = 10010;\ntypedef long long ll;\nint mnp[maxn], p[maxn], cnt;\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (!mnp[i]) mnp[i] = i, p[cnt++] = i;\n\t\tfor (int j = 0; j < cnt && p[j] * i <= n; ++j) {\n\t\t\tmnp[p[j] * i] = p[j];\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n; ll a[600][600];\ninline int get1(int x, int y) {\n\tif (x + y < 0 || (x + y) >> 1 >= n) return 1;\n\treturn p[(x + y) >> 1];\n}\ninline int get2(int x, int y) {\n\tif ((y + n - x) >> 1 < 0 || (y + n - x) >> 1 >= n) return 1;\n\treturn p[((y + n - x) >> 1) + n];\n}\nint main() {\n\tsieve(10000);\n\tstd::cin >> n;\n\tstd::cout << n << std::endl;\n\tif (n == 2) {\n\t\tstd::cout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tstd::cout << ((i + j) % 2 == 0 ? 1ll * get1(i, j) * get2(i, j) : 1ll * get1(i, j - 1) * get1(i, j + 1) * get2(i, j - 1) * get2(i, j + 1) + 1) << \"\\n \"[j != n - 1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << \"[\";\n    for (auto p: v) cout << p << \", \";\n    cout << \"]\";\n    return os;\n}\n\nstruct Prime {\n    int n;\n    vector<bool> used;\n    vector<int> pr;\n    vector<ull> bpr;\n    Prime(int n) : n(n) {\n        used = vector<bool>(n+1, false);\n        for (int i = 2; i <= n; i++) {\n            if (used[i]) continue;\n            pr.push_back(i);\n            bpr.push_back(((__int128(1)<<64)+i-1) / i);\n            for (int j = 2*i; j <= n; j += i) {\n                used[j] = true;\n            }\n        }\n    }\n    map<ll, int> fact(ll x) {\n        assert(x <= (ll)n*n);\n        int pc = (int)pr.size();\n        map<ll, int> mp;\n        for (int i = 0; i < pc; i++) {\n            ll d = pr[i]; ull rd = bpr[i];\n            if (x < d*d) break;\n            while (true) {\n                ll xd = __int128(x)*rd >> 64;\n                if (xd * d != x) break;\n                x = xd;\n                mp[d]++;\n            }\n        }\n        if (x > 1) mp[x]++;\n        return mp;\n    }\n};\n\nconst int MN = 500;\n//const int MN = 10;\n\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    Prime pr(100000);\n//    cout << pr.pr[499] * pr.pr[500] << endl;\n//    cout << pr.pr[999] * pr.pr[1000] << endl;\n    VV<ll> mat(MN, V<ll>(MN, 1));\n    int cnt = 0;\n//    set<ll> st;\n    for (int y = 0; y < MN; y++) {\n        for (int x = 0; x < MN; x++) {\n            if ((x + y) % 2) continue;\n//            assert(mat[y][x] == 1);\n            mat[y][x] = pr.pr[(x+y)/2] * pr.pr[MN + (MN/2+(x-y)/2)];\n//            assert(st.count(mat[y][x]) == 0);\n//            st.insert(mat[y][x]);\n        }\n    }\n/*    for (int y = 0; y < MN; y++) {\n        cout << mat[y] << endl;\n    }*/\n    ll ans = 0;\n    for (int y = 0; y < MN; y++) {\n        for (int x = 0; x < MN; x++) {\n            if (mat[y][x] > 1) continue;\n            ll z = 1;\n            if (y) z = lcm(z, mat[y-1][x]);\n            if (x) z = lcm(z, mat[y][x-1]);\n            if (y < MN-1) z = lcm(z, mat[y+1][x]);\n            if (x < MN-1) z = lcm(z, mat[y][x+1]);\n            z++;\n            mat[y][x] = z;\n//            assert(st.count(z) == 0);\n//            st.insert(z);\n//            ans = max(ans, z);\n        }\n    }\n//    cout << ans << endl;\n\n    int n;\n    cin >> n;\n    for (int y = 0; y < n; y++) {\n        for (int x = 0; x < n; x++) {\n            cout << mat[y][x] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\n#define n_size 500\n\nvector<bool> prime_list(int MAX_N){\n\n    vector<bool> is_prime(MAX_N + 1, true);\n\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    FOR(i, 2, MAX_N + 1){\n        if(is_prime[i]){\n            int tmp = i * 2;\n            while(tmp <= MAX_N){\n                is_prime[tmp] = false;\n                tmp += i;\n            }\n        }\n    }\n\n    return is_prime;\n}\n\nint extgcd(int a, int b, int &x, int &y){\n    int d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nint lcm(int a, int b){\n    int x, y;\n    int g = extgcd(a, b, x, y);\n    a /= g;\n    return a * b;\n}\n\nint lcm_multi(vec a){\n    int p = a[0];\n    FOR(i, 1, a.size()) p = lcm(p, a[i]);\n    return p;\n}\n\nsigned main(){\n\n    vector<bool> is_prime = prime_list(100000);\n    vec primes(0);\n    FOR(i, n_size, is_prime.size()){\n        if(is_prime[i]){\n            primes.push_back(i);\n        }\n    }\n    //cout << primes.size() << endl; 9497\n\n    int ans[n_size][n_size];\n    set<int> s;\n\n    REP(i, n_size){\n        REP(j, n_size){\n            if((i - j) % 2 != 0) continue;\n            ans[i][j] = (j + 1) * primes[(j - i + n_size) / 2];\n            s.insert(ans[i][j]);\n        }\n    }\n\n    //int maxv = 0;\n\n    IREP(j, n_size){\n        IREP(i, n_size){\n            if((i - j) % 2 == 0) continue;\n            vec a(0);\n            if(i > 0) a.push_back(ans[i - 1][j]);\n            if(j > 0) a.push_back(ans[i][j - 1]);\n            if(i < n_size - 1) a.push_back(ans[i + 1][j]);\n            if(j < n_size - 1) a.push_back(ans[i][j + 1]);\n            int p = lcm_multi(a);\n            int n = 1;\n            while(s.count(n * p + 1)) n++;\n            ans[i][j] = n * p + 1;\n            s.insert(ans[i][j]);\n            //maxv = max(maxv, ans[i][j]);\n        }\n    }\n\n    //cout << maxv << endl;\n\n    /*\n    set<int> s2;\n    REP(i, n_size){\n        REP(j, n_size){\n            if(s2.count(ans[i][j]) > 0) cout << ans[i][j] << endl;\n            s2.insert(ans[i][j]);\n        }\n    }\n    */\n\n   int N; cin >> N;\n   REP(i, N){\n       REP(j, N){\n           cout << ans[i][j] << \" \";\n           //if(ans[i][j] < 1 || ans[i][j] > 1000000000000000) cout << ans[i][j] << endl;;\n       }\n       cout << endl;\n   }\n\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=0;i<=n;i++){\ntot=n-i;\nfor(int j=i;j<=tot;j++)ans[i+j][j-i]*=prime[i+n+(n>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <stdio.h>\n    #include <string>\n    #include <math.h>\n    #include<algorithm>\n    #include <numeric>\n    using namespace std;\n \n    int main(){\n      long long N;\n      cin >> N;\n      long long a[N+1][N+1]={};\n      a[1][1]=2;\n      for(int i=1;i<N;i++){\n       a[i+1][1]=2*(a[i][1])+1;\n        a[1][i+1]=2*(a[1][i])+1;\n      }\n      for(int i=2;i<=N;i++){\n       for(int j=2;j<=N;j++){\n        a[i][j]=(a[i-1][j])*(a[i][j-1])+1; \n       }\n      }\n      for(int i=1;i<=N;i++){\n       for(int j=1;j<=N;j++){\n        cout << a[i][j];\n         if(j==N){\n          cout << endl; \n         }else{\n          cout << ' '; \n         }\n       }\n      }\n      return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nll A[500][500];\nll gcd (ll a, ll b){\n    if (b==0) return a;\n    return gcd(b, a%b);\n}\nll lcm(ll a, ll b){\n    return a/gcd(a,b)*b;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N;\n    cin>>N;\n    ll cnt=2;\n    rep(i,0,50){\n        rep(j,0,50){\n            if((i+j)%2){\n                A[i][j]=cnt;\n                cnt++;\n            }\n        }\n    }\n    set<ll> S;\n    rep(i,0,50){\n        rep(j,0,50){\n            if((i+j)%2==0){\n                ll a,b,c,d;\n                if(i==0) b=1;\n                else b=A[i-1][j];\n                if(i==49) d=1;\n                else d=A[i+1][j];\n                if(j==0) a=1;\n                else a=A[i][j-1];\n                if(j==49) c=1;\n                else c=A[i][j+1];\n                ll t=lcm(lcm(a,b),lcm(c,d));\n                ll s=(25000/t+1)*t+1;\n                while(S.find(s)!=S.end()){\n                    s+=t;\n                }\n                A[i][j]=s;\n                S.insert(s);\n            }\n        }\n    }\n    rep(i,0,N){\n        rep(j,0,N){\n            if(j==N-1) cout<<A[i][j]<<\"\\n\";\n            else cout<<A[i][j]<<\" \";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nll A[500][500];\nll gcd (ll a, ll b){\n    if (b==0) return a;\n    return gcd(b, a%b);\n}\nll lcm(ll a, ll b){\n    return a/gcd(a,b)*b;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N;\n    cin>>N;\n    ll cnt=2;\n    rep(i,0,50){\n        rep(j,0,50){\n            if((i+j)%2){\n                A[i][j]=cnt;\n                cnt++;\n            }\n        }\n    }\n    set<ll> S;\n    rep(i,0,50){\n        rep(j,0,50){\n            if((i+j)%2==0){\n                ll a,b,c,d;\n                if(i==0) b=1;\n                else b=A[i-1][j];\n                if(i==49) d=1;\n                else d=A[i+1][j];\n                if(j==0) a=1;\n                else a=A[i][j-1];\n                if(j==49) c=1;\n                else c=A[i][j+1];\n                ll t=lcm(lcm(a,b),lcm(c,d));\n                ll s=(25000/t+1)*t+1;\n                while(S.find(s)!=S.end()){\n                    s+=t;\n                }\n                A[i][j]=s;\n            }\n        }\n    }\n    rep(i,0,N){\n        rep(j,0,N){\n            if(j==N-1) cout<<A[i][j]<<\"\\n\";\n            else cout<<A[i][j]<<\" \";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#include<tr1/unordered_set>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[505][505],x[505],y[505];\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){\n\tif(!a)return b;\n\tif(!b)return a;\n\treturn a/gcd(a,b)*b;\n}\ntr1::unordered_set<int> st;\nint las=1;\nint next_p(){\n\twhile(++las){\n\t\tbool ok=1;\n\t\tfor(int i=2;i*i<=las;++i)if(!(las%i))ok=0;\n\t\tif(ok)return las;\n\t}\n\treturn 114514;\n}\nint I(int x){\n\tint bas=1;\n\twhile(st.count(bas*x))++bas;\n\tst.insert(bas*x);\n\treturn bas*x;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(n);\n\tfor(int i=1;i<=n;++i){\n\t\tx[i]=next_p();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ty[i]=next_p();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(!((i+j)&1)){\n\t\t\ta[i][j]=x[(i+j)>>1]*y[(i-j+n+1)>>1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i+j)&1)a[i][j]=I(lcm(a[i-1][j],lcm(a[i][j-1],lcm(a[i+1][j],a[i][j+1]))))+1;\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)write(a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n\n  const int MAX = 3613;\n\n  vb vec(MAX + 1, true);\n  deque<int> prime;\n\n  for (int i=3; i<=MAX; i+=2) {\n    if (vec[i]) {\n      prime.emplace_back(i);\n      for (int j=i*i; j<=MAX; j+=2*i) {\n        vec[j] = false;\n      }\n    }\n  }\n\n  vl xs, ys;\n  rep(_,126) {\n    xs.emplace_back(prime.front());\n    prime.pop_front();\n    xs.emplace_back(prime.back());\n    prime.pop_back();\n  }\n  rep(_,126) {\n    ys.emplace_back(prime.front());\n    prime.pop_front();\n    ys.emplace_back(prime.back());\n    prime.pop_back();\n  }\n\n  Graph<ll> ans(n, vl(n, 0));\n\n  rep(i,n/2) {\n    rep(j,n/2) {\n      ans[i*2+1][j*2+1] = 2 * (ans[i*2][j*2] = 2 * xs[i+1] * ys[j+1]);\n      ans[i*2][j*2+1] = 4 * xs[i+1] * xs[i] * ys[j+1] * ys[j+2] + 1;\n      ans[i*2+1][j*2] = 8 * xs[i+1] * xs[i+2] * ys[j+1] * ys[j] + 1;\n    }\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[510][510],c[510][501],ans[510][510],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long LL;\nconst int MX = 10005, MP = 2005;\nconst int MN = 505;\n\nbool ip[MX];\nint p[MP], pc;\ninline void Sieve(int N) {\n\tfor (int i = 2; i <= N; ++i) {\n\t\tif (!ip[i]) p[++pc] = i;\n\t\tfor (int j = 1, k; j <= pc; ++j) {\n\t\t\tif ((k = p[j] * i) > N) break;\n\t\t\tip[k] = 1;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint N, A[MN], B[MN];\n\nint main() {\n\tSieve(10000);\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) A[i] = p[i & 1 ? i / 2 + 1 : N + N - i / 2 + 1];\n\tfor (int i = 1; i <= N; ++i) B[i] = p[(i & 1 ? N - i / 2 : N + i / 2) + (N & 1)];\n\tA[0] = A[N + 1] = B[0] = B[N + 1] = 1;\n\tfor (int i = 1; i <= N; ++i, puts(\"\"))\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tif ((i + j) % 2) printf(\"%lld \", (LL)A[(i + j) / 2] * A[(i + j) / 2 + 1] * B[(N + i - j + (N & 1)) / 2] * B[(N + i - j + (N & 1)) / 2 + 1] + 1);\n\t\t\telse printf(\"%d \", A[(i + j) / 2] * B[(N + i - j + (N & 1)) / 2]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\ntemplate <size_t N>\nclass sieve_of_eratosthenes {\n    std::bitset<N> is_prime_;\n\n  public:\n    constexpr sieve_of_eratosthenes(){\n      is_prime_ = ~is_prime_;\n      is_prime_.reset(0), is_prime_.reset(1);\n      for (size_t p = 2; p < N; p++) {\n        if (!is_prime_.test(p)) continue;\n        for (size_t j = 2; j * p < N; j++) {\n          is_prime_.reset(p * j);\n        }\n      }\n    }\n\n    // Return the bitset testing if a number is prime.\n    constexpr const auto& is_prime() const {return is_prime_;}\n\n    // Returns the vector of prime numbers.\n    template <typename T>\n    auto primes() const {\n      std::vector<T> primes{}; \n      for (size_t i = 0; i < N; i++) {\n        if (is_prime_.test(i)) primes.push_back(i);\n      }\n      return primes;\n    }\n};\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  auto primes = sieve_of_eratosthenes<10000000>{}.primes<int>();\n  int n; std::cin >> n;\n  auto ans = std::vector<std::vector<long long>>(n, std::vector<long long>(n, 0));\n  auto put = [&] (int i, int j){\n    static int k = 0;\n    ans.at(i).at(j) = primes.at(k++);\n  };\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 0) put(i, j);\n    }\n  }\n  auto cal = [&] (int i, int j) {\n    constexpr std::array<int, 4> di = {-1, +1, 0, 0};\n    constexpr std::array<int, 4> dj = {0, 0, -1, +1};\n    auto& here = ans.at(i).at(j) = 1;\n    for (int k = 0; k < 4; k++) {\n      auto nxi = i + di.at(k);\n      auto nxj = j + dj.at(k);\n      if (nxi < 0 || n <= nxi || nxj < 0 || n <= nxj) continue;\n      auto x = ans.at(nxi).at(nxj);\n      assert(x > 1);\n      here *= x;\n    }\n    here++;\n  };\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) cal(i, j);\n    }\n  }\n  for (auto&& v : ans) {\n    for (int i = 0; i < n; i++) {\n      std::cout << (i > 0 ? \" \" : \"\") << v.at(i);\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 500\n#define NN 8000\n#define INF 1LL << 60\n\nint n;\nlong long a[N][N];\nint prime[2*N];\nchar tbl[NN];\n\nlong long gcd(long long x, long long y)\n{\n\tlong long r;\n\n\tif( x < y ) {\n\t\tswap( x, y );\n\t}\n\twhile((r = x % y) != 0) {\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn y;\n}\n\nlong long lcm(long long x, long long y)\n{\n\treturn (x * (y / gcd(x, y) ) );\n}\n\nint main()\n{\n\tcin >> n;\n\n\t// create prime table\n\ttbl[0] = tbl[1] = 1;\n\tfor( int i = 0; i < NN; i++ ) {\n\t\tif( !tbl[i] ) {\n\t\t\tfor( int j = i + i; j < NN; j += i ) {\n\t\t\t\ttbl[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint idx = 0;\n\tfor( int i = 0; i < NN; i++ ) {\n\t\tif( !tbl[i] ) {\n\t\t\tprime[idx] = i;\n\t\t\tidx++;\n\t\t\tif( idx >= 2*N ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tif( ( (i + j) % 2) == 0 ) {\n\t\t\t\tint idx1 = (i - j + n - 1) / 2;\n\t\t\t\tint idx2 = (i + j) / 2;\n\t\t\t\ta[i][j] = (long long)prime[idx1] * prime[idx2 + n];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tif(  ( (i + j) % 2) != 0 ) {\n\t\t\t\tlong long aa[4] = {0};\n\t\t\t\tint li = i - 1;\n\t\t\t\tint ri = i + 1;\n\t\t\t\tint uj = j - 1;\n\t\t\t\tint dj = j + 1;\n\t\t\t\tif( li >= 0 ) {\n\t\t\t\t\taa[0] = a[li][j];\n\t\t\t\t}\n\t\t\t\tif( ri < n ) {\n\t\t\t\t\taa[1] = a[ri][j];\n\t\t\t\t}\n\t\t\t\tif( uj >= 0 ) {\n\t\t\t\t\taa[2] = a[i][uj];\n\t\t\t\t}\n\t\t\t\tif( dj < n ) {\n\t\t\t\t\taa[3] = a[i][dj];\n\t\t\t\t}\n\t\t\t\tlong long l = 0;\n\t\t\t\tfor( int k = 0; k < 4; k++ ) {\n\t\t\t\t\tif( aa[k] ) {\n\t\t\t\t\t\tif( l == 0 ) {\n\t\t\t\t\t\t\tl = aa[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tl = lcm( l, aa[k] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j] = l + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tcout << a[i][j];\n\t\t\tif( j == n - 1 ) {\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 510;\nbool flag[maxn * maxn] = {0};\nlong long p[maxn * maxn];\nint cnt = 0;\nvoid init(int n)\n{\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tif(!flag[i])\n\t\t{\n\t\t\tflag[i] = 1;\n\t\t\tp[++ cnt] = i;\n\t\t}\n\t\tfor(int j = 1; j <= cnt && p[j] * i <= n; j ++)\n\t\t{\n\t\t\tflag[p[j] * i] = 1;\n\t\t\tif(i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n;\nlong long v[maxn][maxn];\nlong long gcd(long long a, long long b)\n{\n\tif(b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nint dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\nbool in(int x, int y)\n{\n\treturn x > 0 && x <= n && y > 0 && y <= n;\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n;\n\tif(n == 2)\n\t{\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\tinit(500 * 500);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif((i + j) % 2 == 0)\n\t\t\t\tv[i][j] = p[i + j];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif((i + j) % 2 == 0)\n\t\t\t\tv[i][j] *= p[n - i + j + n * 2];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif((i + j) % 2 == 1)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < 4; k ++)\n\t\t\t\t{\n\t\t\t\t\tint x = i + dir[k][0], y = j + dir[k][1];\n\t\t\t\t\tif(in(x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[i][j] != 0)\n\t\t\t\t\t\t\tv[i][j] = v[i][j] * v[x][y] / gcd(v[i][j], v[x][y]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tv[i][j] = v[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[i][j] ++;\n\t\t\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tcout << v[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[1100],na,n;\nbool ch(int x){for (int i=2;i<=x;i++){if (x%i==0){while (x%i==0)x/=i;return (x==1);}}}\nint main(){\n\tfor (int i=2;i<=8000;i++)if (ch(i))a[++na]=i;\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)cout<<a[(i+j)/2]*a[(i-j+n)/2+n]<<' ';\n\t\t\telse cout<<a[(i+j)/2]*a[(i-j+n)/2+n]*a[(i+j+1)/2]*a[(i-j+n+1)/2+n]<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nconst int N = 10000;\ntypedef long long ll;\n\nint prime[N] , tot;\nvoid Init() {\n//\tvis[0] = vis[1] = true;\n\tstatic bool vis[N];\n\tfor(int i = 2 ; i < N ; ++i) {\n\t\tif(!vis[i]) prime[tot++] = i;\n\t\tfor(int j = 0 ; j < tot && prime[j] * i < N ; ++j) {\n\t\t\tvis[prime[j] * i] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n ;\nll ans[505][505];\n\ntemplate<typename T> T __lcm(T x , T y) {return x * y / __gcd(x , y);}\nbool valid(int x , int y) {return x > 0 && y > 0 && x <= n && y <= n;}\n\nint main() {\n\tInit();\n\tcin >> n;\n\tif(n == 2) {\n\t\tputs(\"2 3\");\n\t\tputs(\"5 4\");\n\t\treturn 0;\n\t}\n\tint l = 0 , r = 2 * n - 1 - ((n ^ 1) & 1), cur = 1;\n\tfor(int d = 2 ; d <= 2 * n ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , d - n) ; i <= min(n , d - 1) ; ++i)\n\t\t\tans[i][d - i] = cur ? prime[l] : prime[r];\n\t\n\tfor(int lim = (n & 1) ? (n - 1) : (n - 2) , d = -lim ; d <= lim ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , 1 + d) ; i <= min(n , n + d) ; ++i)\n\t\t\tans[i][i - d] *= cur ? prime[l] : prime[r];\n\t\n\tfor(int i = 1 ; i <= n ; ++i , putchar('\\n'))\n\t\tfor(int j = 1 ; j <= n ; ++j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tif(valid(i - 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i - 1][j]);\n\t\t\t\tif(valid(i + 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i + 1][j]);\t\n\t\t\t\tif(valid(i , j - 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j - 1]);\n\t\t\t\tif(valid(i , j + 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j + 1]);\n\t\t\t\tans[i][j]++;\t\n\t\t\t}\n\t\t\tprintf(\"%lld \" , ans[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(MAX_N);\n    for (int i = 0; i < MAX_N; i++) {\n        ans[i].resize(MAX_N);\n    }\n\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = (i % 2); j < MAX_N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + MAX_N) / 2;\n            assert(0 <= p && p < MAX_N);\n            assert(0 <= q && q < MAX_N);\n            ans[i][j] =\n                primes[(p % 2 == 0) ? (p / 2) : (MAX_N - 1 - p / 2)] *\n                primes[(q % 2 == 0) ? (q / 2) : (MAX_N - 1 - q / 2) + MAX_N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = 1 - (i % 2); j < MAX_N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < MAX_N && 0 <= j + dj[k] &&\n                    j + dj[k] < MAX_N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                }\n            }\n            ans[i][j]++;\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=510;\nint n,prm[N*2];\nll a[N][N];\n\nstruct node\n{\n\tint dat,prm;\n}b[N*2];\n\nbool cmp(node x,node y)\n{\n\treturn x.dat<y.dat;\n}\n\nvoid findprm(int k)\n{\n\tfor (int i=2,m=0;m<k;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor (int j=2;j*j<=i;j++)\n\t\t\tif (i%j==0) flag=0;\n\t\tif (flag) prm[++m]=i;\n\t}\n}\n\nll query(int x,int y,int opt)\n{\n\tif (opt==1) return b[(x+y)/2].prm;\n\t\telse return b[(n+x-y+1)/2+n].prm;\n}\n\nint main()\n{\n\tfreopen(\"ans.txt\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tif (n==2) return !printf(\"4 7\\n23 10\");\n\tsrand(n);\n\tfindprm(2*n);\n\tfor (int i=1;i<=2*n;i++)\n\t{\n\t\t//b[i].dat=rand()*rand();\n\t\tif (i<=n) b[i].dat=i*2-1;\n\t\t\telse b[i].dat=(2*n-i)*2;\n\t\tb[i].prm=prm[i];\n\t}\n\tsort(b+1,b+1+2*n,cmp);\n\tfor (int i=1;i<=n;i++,putchar(10))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)&1)\n\t\t\t\tprintf(\"%lld \",query(i,j,1)*query(i,j,2));\n\t\t\telse \t\n\t\t\t{\n\t\t\t\tif (1<i && i<n)\n\t\t\t\t\tprintf(\"%lld \",query(i-1,j,1)*query(i-1,j,2)*query(i+1,j,1)*query(i+1,j,2)+1);\n\t\t\t\telse if (1<j && j<n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i,j+1,1)*query(i,j+1,2)+1);\n\t\t\t\telse if (i==1 && j==1)\n\t\t\t\t\tprintf(\"%lld \",query(i,j+1,1)*query(i,j+1,2)*query(i+1,j,2)+1);\n\t\t\t\telse if (i==1 && j==n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i+1,j,1)+1);\n\t\t\t\telse if (i==n && j==1)\n\t\t\t\t\tprintf(\"%lld \",query(i,j+1,1)*query(i,j+1,2)*query(i-1,j,1)+1);\n\t\t\t\telse if (i==n && j==n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i-1,j,2)+1);\n\t\t\t\telse puts(\"WYC AK IOI!!!!!\");\n\t\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<9, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define lcm(x, y) (((x)/__gcd(x, y))*(y))\n\nbool prime(int a) {\n\tfor(int d = 2; d*d <= a; d++) if(a%d == 0) return 0;\n\treturn 1;\n}\n\nint n;\nll mat[maxn][maxn];\nvoid check() {\n\tll m = max(mat[0][0], mat[0][1]) % min(mat[0][0], mat[0][1]);\n\tfor(int i = 0; i + 1 < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(max(mat[i][j], mat[i + 1][j]) % min(mat[i][j], mat[i + 1][j]) != m) cerr << i << \" \" << j << \" \" << \"d\\n\";\n\tfor(int j = 0; j + 1 < n; j++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(max(mat[i][j], mat[i][j + 1]) % min(mat[i][j], mat[i][j + 1]) != m) cerr << i << \" \" << j << \" \" << \"f\\n\";\n\tll mcnt = 0;\n\tmap<ll, ll> cnt;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tmcnt = max(mcnt, ++cnt[mat[i][j]]);\n\tif(mcnt > 1)cerr << \"BAD\\n\";\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tn+=2;\n\tvi a, b;\n\tfor(int i = 2; b.size() < n; i++) {\n\t\tif(!prime(i)) continue;\n\t\tif(a.size() < n/2) {\n\t\t\tif(a.size()) {\n\t\t\t\ta.pb(a.back()*i);\n\t\t\t}\n\t\t\ta.pb(i);\n\t\t} else {\n\t\t\tif(b.size()) {\n\t\t\t\tb.pb(b.back()*i);\n\t\t\t}\n\t\t\tb.pb(i);\n\t\t}\n\t}\n\tset<ll> pf;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = (i&1)^1; j < n; j+=2) {\n\t\t\tmat[i][j] = a[i/2] * b[j/2];\n\t\t\twhile(pf.count(mat[i][j])) mat[i][j] *= 2;\n\t\t\tpf.insert(mat[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = 1;\n\t\t\tif(i) g = lcm(g, mat[i-1][j]);\n\t\t\tif(i+1 < n) g = lcm(g, mat[i+1][j]);\n\t\t\tif(j) g = lcm(g, mat[i][j-1]);\n\t\t\tif(j+1 < n) g = lcm(g, mat[i][j+1]);\n\t\t\tmat[i][j] = g + 1;\n\t\t}\n\tset<ll> found = pf;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = mat[i][j]-1;\n\t\t\twhile(found.count(mat[i][j])) mat[i][j] += g;\n\t\t\tfound.insert(mat[i][j]);\n\t\t}\n\tn-=2;\n\tll mx = 0;\n\tfor(int i = 0; i < n; i++, cout << '\\n')\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\tcheck();\n\t//if(mx > 1e15) exit(-1);\n}\n//\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[1100],na,n;\nbool p(int x){for (int i=2;i<x;i++)if (x%i==0)return 0;return 1;}\nint main(){\n\tfor (int i=2;i<=8000;i++)if (p(i))a[++na]=i;\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)cout<<a[(i+j)/2]*a[(i-j+n)/2+n+1]<<' ';\n\t\t\telse cout<<a[(i+j)/2]*a[(i-j+n+1)/2+n+1]*a[(i+j+1)/2]*a[(i-j+n-1)/2+n+1]+1<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<list>\n#include<deque>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1000)\nvector<int>prim;\n\nvoid prim_make(int k){\n\tif (k >= 2)prim.push_back(2);\n\tif (k >= 3)prim.push_back(3);\n\tif (k >= 5)prim.push_back(5);\n\tint x = 7;\n\tbool v;\n\twhile (x <= k){\n\t\tv = true;\n\t\tfor (int i = 2; prim[i] * prim[i] <= x; i++){\n\t\t\tif (x%prim[i] == 0){\n\t\t\t\tv = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v)prim.push_back(x);\n\t\tif (x % 6 == 1)x += 4;\n\t\telse x += 2;\n\t}\n\treturn;\n}\n\n\n\n\n\n\nint main(){\n\tlong long a[N][N];\n\tset<long long>s;\n\tvector<int>ve1,ve2;\n\tint n;\n\tlong long k, x, y, z;\n\tlong long ans;\n\tbool v1, v2;\n\tprim_make(100000);\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tx = 9000;\n\twhile(x>0){\n\t\tve1.push_back(x);\n\t\tx -= 2;\n\t}\n\tx = 9002;\n\twhile (x<18002){\n\t\tve2.push_back(x);\n\t\tx += 2;\n\t}\n\tx = 3;\n\twhile (x<12000){\n\t\tve1.push_back(x);\n\t\tx += 6;\n\t}\n\tx = 23997;\n\twhile (x > 12000){\n\t\tve2.push_back(x);\n\t\tx -= 6;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tf(i, n){\n\t\tf(j, n)a[i][j] = -1;\n\t}\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif ((i + j) % 4 == 0){\n\t\t\t\ta[i][j] = ve1[x];\n\t\t\t\ts.insert(ve1[x]);\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ((i + j) % 4 == 2){\n\t\t\t\ta[i][j] = ve2[y];\n\t\t\t\ts.insert(ve2[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=n-1;j>=0;j--){\n\t\t\tif (a[i][j] == -1){\n\t\t\t\tans = 1;\n\t\t\t\tv1 = true;\n\t\t\t\tv2 = true;\n\t\t\t\tx = 0;\n\t\t\t\tif (i > 0){\n\t\t\t\t\tans = ans*a[i - 1][j];\n\t\t\t\t\tif (a[i - 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i - 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (i < (n - 1)){\n\t\t\t\t\tans = ans*a[i + 1][j];\n\t\t\t\t\tif (a[i + 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i + 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j > 0){\n\t\t\t\t\tans = ans*a[i][j - 1];\n\t\t\t\t\tif (a[i][j-1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j-1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j < (n - 1)){\n\t\t\t\t\tans = ans*a[i][j + 1];\n\t\t\t\t\tif (a[i][j + 1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j + 1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (v1){\n\t\t\t\t\tf(ii, x-1)ans = ans / 2;\n\t\t\t\t}\n\t\t\t\tif (v2){\n\t\t\t\t\tf(ii, x-1)ans = ans / 3;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\twhile (s.count((ans + 1)) == 1){\n\t\t\t\t\tif (x > 0)ans = ans / prim[x - 1];\n\t\t\t\t\tans = ans*prim[x];\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\ta[i][j] = ans + 1;\n\t\t\t\ts.insert((ans + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < (n - 1))printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nint m,rm;\nbool np[10001];\nint pr[1011],pn;\nint arr[1011],an;\nint a2[1011],a2n;\nll a[511][511];\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\nunordered_map<ll,bool> mp;\nint main()\n{\n\tfor(int i=2;i<=6000;i++)\n\t{\n\t\tif(!np[i])pr[pn++]=i;\n\t\tfor(int j=i+i;j<=6000;j+=i)np[j]=1;\n\t}\n\tint it=0;\n\twhile(pr[it]<=500)it++;\n\tfor(int i=0;i<=255;i++)arr[an++]=pr[it+i];\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i<n-i+1)a2[++a2n]=i,a2[++a2n]=n-i+1;\n\t\telse if(i==n-i+1)a2[++a2n]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((i+j-1)&1)\n\t\t\t{\n\t\t\t\ta[i][j]=1ll*a2[i]*arr[(j-1)/2];\n\t\t\t\tassert(!mp[a[i][j]]);\n\t\t\t\tmp[a[i][j]]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tfor(int d=0;d<4;d++)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni>=1&&ni<=n&&nj>=1&&nj<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i][j]==0)a[i][j]=a[ni][nj];\n\t\t\t\t\t\telse a[i][j]=a[i][j]/__gcd(a[i][j],a[ni][nj])*a[ni][nj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll k=1;\n\t\t\t\twhile(mp[k*a[i][j]])\n\t\t\t\t{\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\ta[i][j]*=k;\n\t\t\t\tmp[a[i][j]]=1;\n\t\t\t\tif(a[i][j]>5e14)cerr<<i<<\",\"<<j<<\" \"<<a[i][j]<<endl;\n\t\t\t\tassert(a[i][j]<=5e14);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tputi(a[i][j]<<1|((i+j)&1));\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=505,M=100005,x[4]={1,-1,0,0},y[4]={0,0,1,-1};\nll ans[N][N],tot;\nint n,p[M],vis[M],q[M];\n#define ld long double\nll lcm(ll x,ll y){\n\tif(x==0)return y; if(y==0)return x;//cout<<x<<\" \"<<y<<endl;\n\t//if((ld)x/__gcd(x,y)*y>(1e15))while(1);\n\treturn x/__gcd(x,y)*y;\n}\nsigned main(){\n\tn=500;\n\tfor(int i=2;i<M;i++)if(!vis[i]){\n\t\tq[++tot]=i; for(int j=i;j<M;j+=i)vis[j]=1;\n\t}\n\tfor(int i=1;i<=1000;i++)if(i&1)p[i]=q[(i+1)/2]; else p[i]=q[1001-i/2];\n\tint tx=248,ty=249;\n\tfor(int i=1;i<=n*2;i+=2){\n\t\tif(i<=n){tx+=2; ty+=1;} else {tx+=2; if(i!=n+1)ty--;}\n\t\tint x=i<=n?1:i-n+1,y=i<=n?n-i+1:1;\n\t\tint t=min(n-x+1,n-y+1);\n\t\tfor(int j=0;j<t;j++){\n\t\t\tans[x+j][y+j]=p[tx]*p[ty-j];\n\t\t\t//if(abs(x+j-2)+abs(y+j-2)==1)cout<<tx<<\" \"<<ty-j<<endl;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if((i+j)%2==0){\n\t//cout<<i<<\" \"<<j<<endl;\n\t\tfor(int k=0;k<4;k++)ans[i][j]=lcm(ans[i][j],ans[i+x[k]][j+y[k]]);\n\t}\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\twrite(ans[i][j]); putchar(' ');\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n/*\n\n \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 203050\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],n,b[505][505],mx,c,o,r;\nint p[maxn];\nvector<ll> h[maxn];\nbool vis[maxn];\nll lcm(ll x,ll y){\n    return x/__gcd(x,y)*y;\n}\nmap<ll,int> f;\n\nint main(){\n    cin >> n;\n    //for (int i=0;i<n*n/2;i++) a[c++]=i+1;\n    //for (int i=0;i<c;i++)cout<<a[i]<<' ';cout<<endl;\n    //random_shuffle(a,a+c);\n    o=3;\n    for (int i=1;i<=n;i+=4)\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n            o+=2;\n        }\n    int pos=3; while (pos+4<=n) pos+=4;\n    for (int i=pos;i>0;i-=4){\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o; o+=2;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n        }\n    }\n\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) if ((i+j)%2==1){\n            r=1;\n            if (i>1) r=lcm(r,b[i-1][j]);\n            if (i<n) r=lcm(r,b[i+1][j]);\n            if (j>1) r=lcm(r,b[i][j-1]);\n            if (j<n) r=lcm(r,b[i][j+1]);\n            long long s=1;\n            while (f[r*s]) s++;\n            b[i][j]=r*s+1; f[r*s]=1;\n        }\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<n;j++){\n        ll x,y;\n        x=max(b[i][j],b[i][j+1]);\n        y=min(b[i][j],b[i][j+1]);\n        assert(x%y==1);\n    }\n    for (int i=1;i<n;i++)\n    for (int j=1;j<=n;j++){\n        ll x,y;\n        x=max(b[i][j],b[i+1][j]);\n        y=min(b[i][j],b[i+1][j]);\n        assert(x%y==1);\n    }\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) mx=max(mx,b[i][j]);\n    //cout<<mx<<endl;\n    assert(mx<=1000000000000000ll);\n\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)cout<<b[i][j]<<' ';cout<<endl;\n    }\n    //cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,tot;\nconst int N=1005;\nLL a[N][N],zhi[N<<1],vis[10010];\nLL GCD(LL a,LL b){return b?GCD(b,a%b):a;}\nLL LCM(LL a,LL b){return a&b?a/GCD(a,b)*b:a+b;}\nvoid YYCH()\n{\n\tvis[1]=1;\n\tfor(int i=2;i<=10000;++i)\n\t{\n\t\tif(!vis[i])zhi[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*zhi[j]<=10000;++j)\n\t\t{\n\t\t\tvis[i*zhi[j]]=1;\n\t\t\tif(!(i%zhi[j]))break;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;YYCH();\n    for(int i=1;i<=n;++i)\n    \tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n    \t\ta[i][j]=zhi[(i+j)/2]*zhi[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n    \tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t\ta[i][j]=LCM(LCM(a[i-1][j],a[i][j-1]),LCM(a[i+1][j],a[i][j+1]))+1;\n    for(int i=1;i<=n;++i,puts(\"\"))\n    \tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong a[500][500];\n\nint main(void){\n    long n;\n    cin >> n;\n    for(long j=0; j<n; j++){\n        a[0][j] = 2+j;\n    }\n    for(long i=1; i<n; i++){\n        a[i][0] = 2+n%2==1 ? 2+n : 3+n;\n        for(long j=1; j<n; j++){\n            a[i][j] = a[i-1][j]*a[i][j-1]+1;\n        }\n    }\n    for(long i=0; i<n; i++){\n        for(long j=0; j<n-1; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << a[i][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nbool isp(int x){\n\tint c=0;\n\tfor(int i=2;i<x;++i)if(x%i==0)for(++c;x%i==0;x/=i);\n\treturn c<2;\n}\nconst int N=505;\ntypedef long long ll;\nint a[N*2],xb,i,j,n,b[N][N];\ninline ll lcm(ll a,ll b){\n\treturn a*b/std::__gcd(a,b);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(i=2;xb<n*2;++i)if(isp(i))a[++xb]=i;\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j){\n\t\tint x=i+j,y=i-j+n;\n\t\tif(x&1)b[i][j]=a[x/2]*a[n+(y+1)/2];\n\t}\n\tfor(i=1;i<=n;++i,puts(\"\"))for(j=1;j<=n;++j)if((i+j)&1)printf(\"%d \",b[i][j]);else{\n\t\tll ans=1;\n\t\tif(i>1)ans=lcm(ans,b[i-1][j]);\n\t\tif(i<n)ans=lcm(ans,b[i+1][j]);\n\t\tif(j>1)ans=lcm(ans,b[i][j-1]);\n\t\tif(j<n)ans=lcm(ans,b[i][j+1]);\n\t\tassert(ans+1<1e15);\n\t\tprintf(\"%lld \",ans+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 510, MAX = 5000;\nint isp[MAX + 10], pri[MAX], pcnt;\nvoid prework() {\n  rep (i, 2, MAX) {\n    if (!isp[i]) pri[++pcnt] = i;\n    for (int j = 1; pri[j] * i <= MAX; ++ j) {\n      isp[pri[j] * i] = 1;\n      if (i % pri[j] == 0) break;\n    }\n  }\n}\nll mat[N][N];\nint n, arr[2][N];\nset<ll> st;\nint main() {\n  prework();\n  read(n);\n  int p = 0;\n  rep (a, 0, 1) {\n    for (int i = 1; i <= n; i += 2)\n      arr[a][i] = pri[++ p];\n    for (int i = 2; i < n; i += 2)\n      arr[a][i] = arr[a][i-1] * arr[a][i+1];\n    if (n % 2 == 0) arr[a][n] = arr[a][n-1] * pri[++ p];\n  }\n  rep (i, 1, n) rep (j, 1, n) mat[i][j] = 1ll * arr[0][i] * arr[1][j];\n  // rep (i, 1, n) rep (j, 1, n) {\n  //   assert(!st.count(mat[i][j]));\n  //   assert(mat[i][j] <= (ll)1e15);\n  //   st.insert(mat[i][j]);\n  // }\n  rep (i, 1, n) {\n    rep (j, 1, n) printf(\"%lld \", mat[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) FOR(i,0,n)\n#define ROF(i,a,b) for(ll i=a;i>=b;i--)\n#define per(i,a) ROF(i,a,0)\n#define pb push_back\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ch=char;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vP;\ntypedef vector<ch> vc;\ntypedef vector<vc> vvc;\nconst ll MOD=1000000007;\nconst ll MOD2=998244353;\nconst ld PI=acos(-1);\nconst ll INF=1e18;\nstruct edge{ll to,cost;};\nstruct edge2{ll from,to,cost;};\n\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N;\n    cin >> N;\n    int MXN=500;\n    ll ans[MXN][MXN];\n    vector<bool> is_prime(10000,true);\n    is_prime[0]=is_prime[1]=false;\n    vl p;\n    FOR(i,2,10000){\n        if(is_prime[i]){\n            if(i>=500){\n                p.pb(i);\n            }\n            ll j=2*i;\n            while(j<10000){\n                is_prime[j]=false;\n                j+=i;\n            }\n        }\n    }\n    rep(i,MXN){\n        rep(j,MXN){\n            if(i%2==j%2){\n                ans[i][j]=p[i]*(j+1);\n            }\n            else{\n                ans[i][j]=1;\n            }\n        }\n    }\n    rep(i,MXN){\n        rep(j,MXN){\n            if((i+j)%2==1){\n                if(i!=0)ans[i][j]=lcm(ans[i][j],ans[i-1][j]);\n                if(j!=0)ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n                if(i!=N-1)ans[i][j]=lcm(ans[i][j],ans[i+1][j]);\n                if(j!=N-1)ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n                ans[i][j]++;\n            }\n        }\n    }\n    rep(i,N){\n        rep(j,N){\n            cout << ans[i][j] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nlong long ans[501][501];\nlong long prime[501];\nvoid initprime() {\n\tint pn=0;\n\tlong long base=2;\n\tfor (int i=0; i<500;) {\n\t\tauto isprime = [&](long long a) {\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tif (a%prime[k] == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\t\t// cout<<i<<\" \"<<base<<endl;\n\t\tif (isprime(base))\n\t\t\tprime[i++] = base++;\n\t\telse\n\t\t\tbase++;\n\t}\n}\nint main() {\n\tinitprime();\n\tint n; cin>>n;\n\tif (n==2) {\n\t\tcout<<\"4 7\\n23 10\"<<endl;\n\t\treturn 0;\n\t}\n\tauto idx = [&] (int x, int y) -> int {\n\t\tint t = (x+y)/2; // t=0,1,2,3,4,5 when n==6;\n\t\treturn t%2?(n-1-t/2):t/2; };\n\n\t//prime[k] for (i,j) with k=(i+j)/2;\n\tint pcnt[500]; memset(pcnt, 0, sizeof(pcnt));\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=i%2; j<n; j+=2)\n\t\t\tans[i][j] = prime[idx(i,j)]*(i+1);\n\t\n\t// for (int i=0; i<500; i++)\n\t// \tcout<<pcnt[i]<<\" \";\n\t// cout<<endl;\n\tauto w = [&] (int x, int y) -> long long{\n\t\tif (x<0 || x>=n || y<0 || y>=n)\n\t\t\treturn 1;\n\t\treturn ans[x][y] / prime[idx(x,y)];\n\t};\n\tlong long tmax=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=(i+1)%2; j<n; j+=2) {\n\t\t\tans[i][j] = w(i,j+1) * w(i-1,j) * w(i+1,j) * prime[idx(i,j-1)] * prime[idx(i,j+1)];\n\t\t\ttmax = max(tmax, ans[i][j]);\n\t\t}\n\t// cout<<tmax<<endl;\n\tfor (int i=0; i<n; i++, cout<<endl)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tcout<<ans[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=502;\nconst int inf=1e15;\nvector<int> lis,lis1;\nint ar[N][N];\nint LCM(int x,int y){\n  return (x/__gcd(x,y))* y;\n}\nint dx[]={0,0,-1,1},dy[]={-1,1,0,0};\nsigned main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n,m,i,j,k,l,num=0,now;\n  cin>>n;\n  for(i=1;i<=n;i++){\n    ar[0][i]=1;\n    ar[i][0]=1;\n    ar[i][n+1]=1;\n    ar[n+1][i]=1;\n    for(j=1;j<=n;j++){\n      if(((i+j)&1)){\n        num++;\n      }\n    }\n  }\n  //cout<<num<<endl;\n  for(i=2;i<=num+1;i++){\n    lis.push_back(i);\n  }\n  if(n==2){\n    cout<<\"4 7\\n23 10\";\n    return 0;\n  }\n  //cout<<LCM(1,3)<<endl;\n  for(i=1;i<=100;i++){\n   \tlis1.clear();\n    random_shuffle(lis.begin(),lis.end());\n    l=0;\n    for(j=1;j<=n;j++){\n      for(k=1;k<=n;k++){\n        if(((j+k)&1)){\n          ar[j][k]=lis[l];\n          //cout<<lis[l]<<endl;\n          l++;\n        }\n      }\n    }\n    for(j=1;j<=n;j++){\n      for(k=1;k<=n;k++){\n        if(((j+k)&1)){\n          continue;\n        }\n        now=1;\n        for(l=0;l<4;l++){\n          if(now/__gcd(now,ar[j+dx[l]][k+dy[l]])>inf/ar[j+dx[l]][k+dy[l]]){\n            now=inf+1;\n          }\n          else{\n          \tnow=LCM(now,ar[j+dx[l]][k+dy[l]]);\n          }\n        }\n        ar[j][k]=now+1;\n        lis1.push_back(now+1);\n        //cout<<now+1<<' '<<\"wtf\"<\n      }\n    }\n    sort(lis1.begin(),lis1.end());\n    //cout<<lis1.size()<<endl;\n    lis1.erase(unique(lis1.begin(),lis1.end()),lis1.end());\n    //cout<<lis1.size()<<' '<<lis.size()<<endl;\n    if(lis1.size()+lis.size()==n*n&&lis1[lis1.size()-1]<=inf){\n      for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n          cout<<ar[i][j]<<' ';\n        }\n        cout<<'\\n';\n      }\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint p[100010],pr[20100],t;\nll ad[101000],mi[101000],num[555][555];\nll mx;\nvector<pair<int,PII>> pp;\nint main() {\n\trep(i,2,20000) if (p[i]==0) {\n\t\tpr[t++]=i;\n\t\tfor (int j=i;j<=20000;j+=i) p[j]=1;\n\t}\n//\tprintf(\"%d\\n\",t);\n\tfor (int c=0;c<=998;c++) if (c%2==0) {\n\t\tpp.pb(mp(abs(c-499),mp(c,0)));\n\t}\n\n\tfor (int c=-499;c<=499;c++) if (c%2==0) {\n\t\tpp.pb(mp(abs(c),mp(c,1)));\n\t}\n\tsort(all(pp));\n\trep(i,0,SZ(pp)) {\n\t\tif (pp[i].se.se==0) ad[pp[i].se.fi]=pr[i];\n\t\telse mi[pp[i].se.fi+1000]=pr[i];\n\t}\n\trep(i,0,500) rep(j,0,500) {\n\t\tif ((i+j)%2==0) {\n\t\t\tll p1=ad[i+j];\n\t\t\tll p2=mi[i-j+1000];\n\t\t\tnum[i][j]=p1*p2;\n\t\t}\n\t}\n\tll mx=0;\n\trep(i,0,500) rep(j,0,500) {\n\t\tif ((i+j)%2==1) {\n\t\t\tnum[i][j]=1;\n\t\t\trep(k,0,4) {\n\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\tif (nx>=0&&nx<500&&ny>=0&&ny<500) {\n\t\t\t\t\tnum[i][j]=num[i][j]/gcd(num[i][j],num[nx][ny])*num[nx][ny];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx=max(mx,num[i][j]);\n\t\t}\n\t}\n\trep(i,0,500) rep(j,0,500) {\n\t\trep(k,0,4) {\n\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\tif (nx>=0&&nx<500&&ny>=0&&ny<500) {\n\t\t\t\tll c1=max(num[i][j],num[nx][ny]);\n\t\t\t\tll c2=min(num[i][j],num[nx][ny]);\n\t\t\t\tassert(c1%c2==0);\n\t\t\t}\n\t\t}\n\t}\n\tint x;\n\tscanf(\"%d\",&x);\n\trep(i,0,x) {\n\t\trep(j,0,x) printf(\"%lld \",num[i][j]);\n\t\tputs(\"\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//{\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<ll,ll> ii;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#ifdef brian\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#endif // brian\n//}\n\n\nconst ll MAXn=5e2+5,MAXlg=__lg(MAXn)+2;\nconst ll MOD=1000000007;\nconst ll INF=ll(1e15);\n\nll ispm[10000];\nvector<ll> pm;\nll d[MAXn][MAXn];\n\n\nll lcm(vector<ll> v)\n{\n  ll res = 1;\n  for(ll x:v)\n  {\n    ll g = __gcd(x,res);\n    res = (res / g) * x;\n  }\n  return res;\n}\n\nint main()\n{\n    IOS();\n    for(int i = 2;SZ(pm) < 1010;i++)\n    {\n      if(!ispm[i])pm.pb(i);\n      for(int j = 0;pm[j] * i < 10000;j++)\n      {\n        ispm[pm[j] * i] = 1;\n        if(i % pm[j] == 0)break;\n      }\n    }\n    debug(pm.back());\n    ll n;\n    cin>>n;\n    REP(i,n + 2)REP(j,n + 2)\n    {\n      if((i + j) % 2 != 0)continue;\n      ll a = (i + j) / 2 ,b = (i + n + 1 - j) / 2 + n + 2 + 1;\n      d[i][j] = pm[a] * pm[b];\n      debug(i,j,a,b);\n    }\n    REP1(i,n)REP1(j,n)\n    {\n      if((i + j) % 2 == 0)continue;\n      vector<ll> tmp;\n      tmp.pb(d[i-1][j]);\n      tmp.pb(d[i][j - 1]);\n      tmp.pb(d[i+1][j]);\n      tmp.pb(d[i][j + 1]);\n      d[i][j] = lcm(tmp) + 1;\n    }\n\n    REP1(i,n)\n    {\n      REP1(j,n)cout<<d[i][j]<<\" \\n\"[j==n];\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT cerr\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<__debug_tap<<\"\\n\";}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T, class = typename iterator_traits< typename T::iterator >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = a.begin(); ite != a.end(); ++ite) o << (ite == a.begin() ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\ntemplate < class T, class = typename iterator_traits< typename T::iterator >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = a.begin(); ite != a.end(); ++ite) o << (ite == a.begin() ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n/// --- primes {{{ ///\nvector< ll > primes(ll n) {\n  vector< ll > res;\n  for(ll i = 2; i * i <= n; i++) {\n    int isp = 1;\n    for(ll p : res) {\n      if(p * p > i) break;\n      if(i % p == 0) isp = 0;\n    }\n    if(isp) res.emplace_back(i);\n  }\n  return res;\n}\n/// }}}--- ///\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n;\n  cin >> n;\n  auto ps = primes(1e9);\n  vector<vector<ll>> ans(n, vector<ll>(n, 1));\n  dump(ps.size());\n  for(int i = 0; i < n + 10; i+=2) {\n    for(int j = 0; j < n; j++) {\n      for(int d = -1; d <= 1; d++) {\n        if(i+d >= 0 && i+d < n) {\n          ans[i+d][j] *= ps[i/2];\n          ans[j][i+d] *= ps[500+i/2];\n        }\n      }\n    }\n  }\n  dump(ans[n-1][n-1]);\n  dump(ans[n-1][n-1] <= 1e15);\n  for(int i = 0; i < n; i++) {\n    cout << ans[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nvoid _main(istream &inp){\n\tint n;\n\tinp >> n;\n\tconst int M = 1000;\n\tvvl ret(n, vl(n));\n\tdebug(n);\n\tdebug(ret);\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==0){\n\t\t\tret[x][y]=M+rnd.get()%M;\n\t\t}\n\t}\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==1){\n\t\t\tll z = 1;\n\t\t\tif(x>0)z*=ret[x-1][y];\n\t\t\telse z*=2;\n\t\t\tif(y>0)z*=ret[x][y-1];\n\t\t\telse z*=3;\n\t\t\tif(x+1<n)z*=ret[x+1][y];\n\t\t\telse z*=4;\n\t\t\tif(y+1<n)z*=ret[x][y+1];\n\t\t\telse z*=5;\n\t\t\tret[x][y]=z+1;\n\t\t}\n\t}\n\tdebug(n);\n\tdebug(ret);\n\trep(x,n){\n\t\trep(y,n){\n\t\t\tcout << ret[x][y];\n\t\t\tif(y!=n-1)cout << \" \";\n\t\t\telse cout << endl;\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 505\n#define maxm 4010\n#define inf 1000000007\n#define mod 998244353\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nint prime[100010],primesize;\nbool notprime[100010];\nvoid get_prime()\n{\n    for(int i=2;i<=100000;i++)\n    {\n        if(!notprime[i])   prime[++primesize]=i;\n        for(int j=1;j<=primesize&&i*prime[j]<=100000;j++)\n        {\n            notprime[i*prime[j]]=true;\n            if(i%prime[j]==0)  break;\n        }\n    }\n}\nll ans[maxn][maxn];\nint xx[4]={0,0,1,-1};\nint yy[4]={1,-1,0,0};\nbool check(int x,int y)\n{\n    return (x>=1&&x<=n&&y>=1&&y<=n);\n}\nll gcd(ll x,ll y)\n{\n    if(!y)  return x;\n    return gcd(y,x%y);\n}\nll lcm(ll x,ll y)\n{\n    return x*(y/gcd(x,y));\n}\nint main()\n{\n    get_prime();\n    n=read();\n    int l=1,r=(n<<1)+(!(n&1));\n    for(int i=2;i<=(n<<1);i+=2)\n    {\n        int val;\n        if(i%4==0)  val=prime[l++];\n        else        val=prime[r--];\n        for(int x=1;x<=n;x++)\n        {\n            int y=(i-x);\n            if(y<=0||y>n)  continue;\n            ans[x][y]=val;\n        }\n    }\n    for(int i=-(n-1)/2*2;i<=(n-1)/2*2;i+=2)\n    {\n        int val;\n        if(i%4==0)  val=prime[l++];\n        else        val=prime[r--];\n        for(int x=1;x<=n;x++)\n        {\n            int y=(i+x);\n            if(y<=0||y>n)  continue;\n            ans[x][y]*=val;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if((i+j)&1)\n            {\n                for(int k=0;k<4;k++)\n                {\n                    int tx=i+xx[k],ty=j+yy[k];\n                    if(check(tx,ty))\n                    {\n                        if(!ans[i][j])  ans[i][j]=ans[tx][ty];\n                        else          ans[i][j]=lcm(ans[i][j],ans[tx][ty]);\n                    }\n                }\n                ans[i][j]++;\n            }\n        }\n    }\n    ll mx=0;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)  mx=max(mx,ans[i][j]),printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    cout<<mx<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=20005;\nint fl[N],pri[N];\nint v1[N],v2[N],n;\nvoid init(){\n\tFor(i,2,N-1) For(j,2,(N-1)/i) fl[i*j]=1;\n\tFor(i,2,N-1) if (!fl[i]&&*pri<=1005) pri[++*pri]=i;\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\tFor(i,0,n+n+2) v1[i]=v2[i]=1;\n\tFor(i,0,n+n+2){\n\t\tif (i%2==0) v1[i]=pri[(*pri)--];\n\t\tif ((i+n+1)%2==0) v2[i]=pri[(*pri)--];\n\t}\n\tFor(i,1,n) For(j,1,n)\n\t\tif ((i+j)%2==0) printf(\"%lld%c\",1ll*v1[i+j]*v2[i+n-j+1],j==n?'\\n':' ');\n\t\telse printf(\"%lld%c\",1ll*v1[i+j-1]*v1[i+j+1]*v2[i+n-j]*v2[i+n-j+2]+1,j==n?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL K = 750;\nconst LL MP = 20000;\n\nLL pri[20005],pc = 0;\nLL npr[20005] = {0};\nLL w[505][505];\n\nvoid sieve(LL x){\n\tfor(LL i = 2;i <= x;i ++){\n\t\tif(npr[i]) continue;\n\t\tpri[++ pc] = i;\n\t\tfor(LL j = i * i;j <= x;j += i){\n\t\t\tnpr[j] = 1;\n\t\t}\n\t} \n}\n\nLL gcd(LL x,LL y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nLL lcm(LL x,LL y){\n\treturn x / gcd(x,y) * y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL n,m; cin >> n >> m;\n\tsieve(MP);\n\tfor(LL i = 0;i <= n + 1;i ++){\n\t\tfor(LL j = 0;j <= m + 1;j ++){\n\t\t\tw[i][j] = 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= m;j ++){\n\t\t\tif((i + j) & 1) w[i][j] = pri[(i + j) >> 1] * pri[((i - j) >> 1) + K];\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= m;j ++){\n\t\t\tif(w[i][j] == 1) w[i][j] = lcm(lcm(w[i - 1][j],w[i][j - 1]),lcm(w[i + 1][j],w[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= m;j ++){\n\t\t\tcout << w[i][j] << (j == m ? '\\n' : ' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i,a,b) for (int i = a; i <= b; i++)\n#define rep1(i, a, b) for(int i =a; i >=b; i--)\n#define f first\n#define ss second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\n\n\nint n,ans[2000][2000], ans1[2000][2000], ans2[2000][2000];\nset<int> primes;\nbool siv[100005];\nvector<int> v;\nint lc (){\n       int res = v[0];\n       for(int i=1;i<v.size();i++){\n              res = res*v[i]/__gcd(res,v[i]);\n       }\n       //cout << res << endl;\n       if(res>=1000000000000000){\n              cout << endl;\n              for(auto t:v){\n                     cout << t << \" \";\n              }\n              cout << endl;\n              //cout << x << \" \" << y << \" \" << z << \" \" << w << endl;\n              exit(0);\n       }\n       v.clear();\n       return res;\n\n}\n\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n//freopen(\"input.txt\",\"r\",stdin);\n//freopen(\"output.txt\",\"w\",stdout);\n\ncin >> n;\nif(n==2){\n       cout << \"4 7 \\n23 10 \\n\";\n       return 0;\n}\nfor(int i=1;i<=n;i++){\n       for(int j=1;j<=n;j++)ans[i][j]=ans1[i][j]=ans2[i][j]=1;\n}\nfor(int i=2;i<100000;i++){\n       if(siv[i])continue;\n       for(int j=i+i;j<100000;j+=i){\n              siv[j]=true;\n       }\n}\nfor(int i=2;i<100000;i++){\n       if(!siv[i])primes.insert(i);\n}\n\n\nint t=n;\nif(n%2==0)t--;\nfor(int i=1;i<=n;i+=2){\n       auto it=primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       it = primes.begin();\n       int cur1 = *it;\n       primes.erase(it);\n       for(int k=0;i+k<=n;k++){\n              ans[1+k][i+k]*=cur;\n              if(i!=1){\n                     ans[i+k][1+k]*=cur1;\n              }\n       }\n}\n/*\nfor(int i=t;i>=1;i=-2){\n       auto it=primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       ans[i][n-i+1]*=cur;\n       if(ans[n][i]==1)\n       for(int k=0;i-k>0;k++){\n              ans[n-k][i-k]*=cur;\n              ans[n-k][i-k]*=cur;\n       }\n}\n*/\n\nfor(int i=1;i<=n;i++){\n       auto it = primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       ans[i][i]*=cur;\n       for(int k=1;i-k>0;k++){\n              ans[i-k][i+k]*=cur;\n              ans[i+k][i-k]*=cur;\n       }\n}\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nfor(int i=1;i<=n;i++){\n       for(int j=1;j<=n;j++){\n              if(ans[i][j]==1){\n                     int res=1;\n                     for(int k=0;k<4;k++){\n                                   int x = ans[i+dx[k]][j+dy[k]];\n                                   if(x>0){\n                                          //cout << x << endl;\n                                          v.pb(x);\n                                   }\n                     }\n                     res = lc();\n                     ans[i][j] = res + 1;\n              }\n              assert(ans[i][j]<=10000000000000000);\n              cout << ans[i][j] << \" \";\n       }\n       cout << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ios\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(nullptr);\n#define VEC(type, name, size)\\\n    V<type> name(size);\\\n    IN(name)\n#define VVEC(type, name, h, w)\\\n    VV<type> name(h, V<type>(w));\\\n    IN(name)\n#define INT(...)\\\n    int __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LL(...)\\\n    ll __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define STR(...)\\\n    string __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define CHAR(...)\\\n    char __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define DOUBLE(...)\\\n    DOUBLE __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LD(...)\\\n    LD __VA_ARGS__;\\\n    IN(__VA_ARGS__)\ntemplate <class T> void scan(T &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((ll)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T Roundup_div(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nconst ll INF = 1e18;\n#pragma endregion\n\nint N = 500;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ninline bool inside(int x, int y) {return x >= 0 and x < N and y >= 0 and y < N;}\n\nV<> pv;\nvector<bool> ip(10010, true);\nvoid er(){\n    ip[0] = ip[1] = 0;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) for(int j = 2 * i; j <= 10000; j += i) ip[j] = false;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) pv.pb(i);\n}\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;};\n\nint main(){\n    ios;\n    er();\n    INT(n);\n    VV<> res(N, V<>(N, 1));\n    REP(i, N) REP(j, N) if(!((i + j) % 2)) res[i][j] = pv[(i + j) / 2 + 1];\n    map<ll,ll> memo;\n    REP(i, N / 2){\n        int x = 0, y = i * 2;\n        while(x < N and y < N){\n            res[x][y] *= pv[i];\n            memo[res[x][y]]++;\n            x++; y++;\n        }\n    }\n    REP(i, N / 2 - 1){\n        int x = i * 2 + 2, y = 0;\n        while(x < N and y < N){\n            res[x][y] *= pv[N - i - 1];\n            memo[res[x][y]]++;\n            x++; y++;\n        } \n    }\n    REP(i, N) REP(j, N){\n        if(((i + j) % 2)){\n            REP(k, 4){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(inside(nx, ny)) res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n        }\n    }\n    REP(i, N) REP(j, N) if(((i + j) % 2)){\n        ll t = res[i][j];\n        res[i][j]++;\n        while(memo[res[i][j]]) res[i][j] += t;\n        memo[res[i][j]]++;\n    }\n    map<ll,ll> mp;\n    ll cnt = 0, MA = 0;\n    REP(i, N) REP(j, N){\n        if(!mp[res[i][j]]) mp[res[i][j]] = 1;\n        else{\n            cnt++;\n            cout << \"bad=\";print(res[i][j]);\n        }\n        if((i + j) % 2)chmax(MA, res[i][j]);\n    }\n    /*cout << \"cnt=\";print(cnt);\n    cout << \"MAX=\";print(MA);*/\n    REP(i, n){  \n        REP(j, n) cout << res[i][j] << \" \"; cout << endl;\n    }\n}                           "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\n#include <cassert>\n#pragma warning (disable: 4996)\nusing namespace std;\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    if (n < 0)return 0;\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvector<int> tpsort(vector<vector<int>>& G) {\n    int V = G.size();\n    vector<int> sorted_vertices;\n    queue<int> que;\n    vector<int> indegree(V);\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < G[i].size(); j++) {\n            indegree[G[i][j]]++;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n    while (que.empty() == false) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        sorted_vertices.push_back(v);\n    }\n    return sorted_vertices;\n}\n\nstruct Point\n{\n    double x;\n    double y;\n};\n\nstruct LineSegment\n{\n    Point start;\n    Point end;\n};\n\ndouble tenkyori(const LineSegment& line, const Point& point)\n{\n    double x0 = point.x, y0 = point.y;\n    double x1 = line.start.x, y1 = line.start.y;\n    double x2 = line.end.x, y2 = line.end.y;\n\n    double a = x2 - x1;\n    double b = y2 - y1;\n    double a2 = a * a;\n    double b2 = b * b;\n    double r2 = a2 + b2;\n    double tt = -(a * (x1 - x0) + b * (y1 - y0));\n\n    if (tt < 0)\n        return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n    else if (tt > r2)\n        return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));\n\n    double f1 = a * (y1 - y0) - b * (x1 - x0);\n    return sqrt((f1 * f1) / r2);\n}\nvoid dfs1(vector<vector<ll>>& z, ll k, ll oya, ll& ans, vector<ll>& b) {\n    for (auto m : z[k]) {\n        if (m != oya)dfs1(z, m, k, ans, b);\n    }\n    vector<ll> s;\n    for (auto m : z[k]) {\n        if (m != oya)s.push_back(b[m]);\n    }\n    ll m = b.size() - 1;\n    for (auto d : s) {\n        m -= d;\n    }\n    b[k] = b.size() - m;\n    if (m != 0)s.push_back(m);\n    ll a = modinv(2, 1000000007);\n    for (auto d : s) {\n        a += 1000000007 - modinv(modpow(2, b.size() - d, 1000000007), 1000000007);\n    }\n    a += modinv(modpow(2, b.size(), 1000000007), 1000000007) * (z[k].size() - 1);\n    ans += a;\n    ans %= 1000000007;\n    return;\n}\n\nll merge_cnt(vector<int>& a) {\n    int n = a.size();\n    if (n <= 1) { return 0; }\n\n    ll cnt = 0;\n    vector<int> b(a.begin(), a.begin() + n / 2);\n    vector<int> c(a.begin() + n / 2, a.end());\n\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    vector<vector<ll>> z(500,vector<ll>(500));\n    vector<ll> x(500,1);\n    for (int i = 0; i < 500; i++) {\n        ll k = i;\n        x[i] *= modpow(2, k % 7, 1000000007);\n        k /= 7;\n        x[i] *= modpow(3, k % 3, 1000000007);\n        k /= 3;\n        x[i] *= modpow(5, k % 3, 1000000007);\n        k /= 3;\n        x[i] *= modpow(7, k % 2, 1000000007);\n        k /= 2;\n        x[i] *= modpow(11, k % 2, 1000000007);\n        k /= 2;\n        x[i] *= modpow(13, k % 2, 1000000007);\n        k /= 2;\n    }\n    vector<ll> t(250);\n    ll c = 0;\n    for (int i = 160; i < 1000000; i++) {\n        if (i % 2 != 0 && i % 3 != 0 && i % 5 != 0 && i % 7 != 0 && i % 11 != 0 && i % 13 != 0) {\n            t[c] = i;\n            c++;\n        }\n        if (c == 250) {break; }\n    }\n    t[249] = 151;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 1) {\n                if(i<j)z[i][j] = x[(i + j) / 2];\n                else z[i][j] = x[((i + j) / 2+250)%500];\n                z[i][j] *= t[(i - j + 500) / 2 % 250];\n            }\n        }\n    }\n    ll u = 0;\n    set<ll> s;\n    ll us = 0;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 0)continue;\n            s.insert(z[i][j]);\n        }\n    }\n    ll ui = 0;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 0) {\n                ll a = 1;\n                ll b = 1;\n                ll c = 1;\n                ll d = 1;\n                if (i != 0)a = z[i - 1][j];\n                if (j != 0)b = z[i][j - 1];\n                if (i != 499)c = z[i + 1][j];\n                if (j != 499)d = z[i][j + 1];\n                ll p = a / ll_gcd(a, b) * b;\n                p *= c / ll_gcd(p, c);\n                p *= d / ll_gcd(p, d);\n                z[i][j] = p + 1;\n                while (s.count(z[i][j])) {\n                    z[i][j] += p;\n                }\n                s.insert(z[i][j]);\n            }\n            ui = max(ui, z[i][j]);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << z[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nbool Isprime[233333];\nll prime[233333];\nvoid init(int T){\n\tmem(Isprime,true);*prime = 0;\n\tfor(int i=2;i<=T;i++){\n\t\tif(Isprime[i]){\n\t\t\tprime[++*prime] = i;\n//\t\t\tprintf(\"[%d]\\n\",i);\n//\t\t\tif(i==47) return ;\n\t\t}\n\t\tfor(int j=1;j<=*prime && i * prime[j] <= T;++j){\n\t\t\tIsprime[i*prime[j]] = false;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nmap<ll,ll> mp1,mp2;\nll ans[505][505],n;\nint main(){\n\tinit(8000);\n\tn = rd();\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n//4\tmp3.clear();\n\tll wzp = 1;\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp1[i+j]) mp1[i+j] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp2[i-j]) mp2[i-j] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n){\n\t\tif((i+j)&1){\n\t\t\tans[i][j] = (ll)mp1[i+j]*mp2[i-j];\n//\t\t\twhile(mp3[ans[i][j]]) ans[i][j]+=(ll)mp1[i+j]*mp2[i-j];\n//\t\t\tmp3[ans[i][j]]++;\n\t\t}\n\t}\n//\tRep(i,1,n){\n//\t\tRep(j,1,n){\n//\t\t\tprintf(\"%lld \",(ll)mp1[i+j]*mp2[i-j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\tll mx = 0;\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tll tmp = 1;\n\t\tif(1<=i-1) tmp = tmp / __gcd(tmp,ans[i-1][j]) * ans[i-1][j];\n\t\tif(1<=j-1) tmp = tmp / __gcd(tmp,ans[i][j-1]) * ans[i][j-1];\n\t\tif(i+1<=n) tmp = tmp / __gcd(tmp,ans[i+1][j]) * ans[i+1][j];\n\t\tif(j+1<=n) tmp = tmp / __gcd(tmp,ans[i][j+1]) * ans[i][j+1];\n\t\tans[i][j] = tmp+1;\n//\t\twhile(mp3[ans[i][j]]) ans[i][j]+=tmp;\n//\t\tmp3[ans[i][j]]++;\n//\t\tmx = max(mx,ans[i][j]);\n\t}\n//\twriteln(mx-1e15);\n\tRep(i,1,n){\n\t\tRep(j,1,n)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint n,a[1100][1100];\nint tot,p[110000]; bool vis[110000];\nvoid init(){\n\tvis[1]=true;\n\tfor (int i=2;i<=10000;i++){\n\t\tif (!vis[i]) p[++tot]=i;\n\t\tif (tot==1000) break;\n\t\tfor (int j=1;j<=tot&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=true;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\ninline int lcm(int x,int y){\n\tif (!x||!y) return x|y;\n\treturn x/__gcd(x, y)*y;\n}\nsigned main(){\n\tinit();\n\tscanf(\"%lld\",&n);\n\tif (n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++) \n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (((i+j)&1)==0)\n\t\t\t\ta[i][j]=p[(i+j)/2]*p[(i-j+n+1)/2+n];\n\t\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (!a[i][j]) \n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i][j+1],a[i+1][j]))+1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<n;j++) printf(\"%lld \",a[i][j]);\n\t\tprintf(\"%lld\\n\",a[i][n]);\n\t}\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define MAX 505\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,prime[MAX<<1],vst[10005];\nvoid pre(int up)\n{\n\tfor(int i=2;;i++)\n\t{\n\t\tif(!vst[i])\n\t\t{\n\t\t\tprime[++prime[0]]=i;\n\t\t\tif(prime[0]==up) break;\n\t\t}\n\t\tfor(int j=1;j<=prime[0];j++)\n\t\t{\n\t\t\tif(i*prime[j]>10000) break;\n\t\t\tvst[i*prime[j]]=1;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n}\nlong long gcd(long long a,long long b)\n{\n\tif(a<b) swap(a,b);\n\twhile(b)\n\t{\n\t\ta%=b;\n\t\tswap(a,b);\n\t}\n\treturn a;\n}\nlong long lcm(long long a,long long b)\n{\n\tif(!a||!b) return a|b;\n\treturn a/gcd(a,b)*b;\n}\nlong long a[MAX][MAX];\nint main()\n{\n\tn=read();\n\tif(n==2) return printf(\"4 7\\n32 10\"),0;\n\tpre((n&1)?n*2:n*2-1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!((i+j)&1))\n\t\t\t\ta[i][j]=1ll*prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint N;\nvector<vector<int64>> a;\nmap<int64, bool> used;\n\nvoid show(){\n\tREP(i, N){\n\t\tREP(j, N){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint64 gcd(int64 a, int64 b){\n\tif(b==0)return a;\n\treturn gcd(b, a%b);\n}\n\nint64 lcm(int64 a, int64 b){\n\treturn a/gcd(a, b)*b;\n}\n\nint64 divisor(int64 x){\n\tfor(int32 i = 2;i <= sqrt(x);i++){\n\t\tif(x%i == 0){\n\t\t\tif(!used[i]) return i;\n\t\t\tif(!used[x/i]) return x/i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tcin >> N;\n\ta = vector<vector<int64>>(N, vector<int64>(N, -1));\n\tint32 y = 0, x = 0;\n\twhile(y < N || x < N){\n\t\ta[y][x] = 2*(y+x)+1;\n\t\tused[2*(y+x)+1] = 1;\n\t\tif((y+x)%2){\n\t\t\ty++;\n\t\t}else{\n\t\t\tx++;\n\t\t}\n\t}\n\tFOR(i, 1, N){\n\t\tfor(y = i, x = 0;y < N && x < N;y++, x++){\n\t\t\tint64 s = a[y-1][x], t = a[y][x+1];\n\t\t\tif(gcd(s-1, t-1) == 1){\n\t\t\t\tint64 k = lcm(s, t);\n\t\t\t\tint64 w = k+1;\n\t\t\t\twhile(used[w]) w += k;\n\t\t\t\ta[y][x] = w;\n\t\t\t\tused[w] = 1;\n\t\t\t}else{\n\t\t\t\tint w = divisor(gcd(s-1, t-1));\n\t\t\t\tif(w == -1){\n\t\t\t\t\tint64 k = lcm(s, t);\n\t\t\t\t\tint64 w = k+1;\n\t\t\t\t\twhile(used[w]) w += k;\n\t\t\t\t\ta[y][x] = w;\n\t\t\t\t\tused[w] = 1;\n\t\t\t\t}else{\n\t\t\t\t\ta[y][x] = w;\n\t\t\t\t\tused[w] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(y = 0, x = i+1;y < N && x < N;y++, x++){\n\t\t\tint64 s = a[y+1][x], t = a[y][x-1];\n\t\t\tif(gcd(s-1, t-1) == 1){\n\t\t\t\tint64 k = lcm(s, t);\n\t\t\t\tint64 w = k+1;\n\t\t\t\twhile(used[w]) w += k;\n\t\t\t\ta[y][x] = w;\n\t\t\t\tused[w] = 1;\n\t\t\t}else{\n\t\t\t\tint w = divisor(gcd(s-1, t-1));\n\t\t\t\tif(w == -1){\n\t\t\t\t\tint64 k = lcm(s, t);\n\t\t\t\t\tint64 w = k+1;\n\t\t\t\t\twhile(used[w]) w += k;\n\t\t\t\t\ta[y][x] = w;\n\t\t\t\t\tused[w] = 1;\n\t\t\t\t}else{\n\t\t\t\t\ta[y][x] = w;\n\t\t\t\t\tused[w] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tshow();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL K = 750;\nconst LL MP = 20000;\n\nLL pri[20005],pc = 0;\nLL npr[20005] = {0};\nLL w[505][505];\n\nvoid sieve(LL x){\n\tfor(LL i = 2;i <= x;i ++){\n\t\tif(npr[i]) continue;\n\t\tpri[++ pc] = i;\n\t\tfor(LL j = i * i;j <= x;j += i){\n\t\t\tnpr[j] = 1;\n\t\t}\n\t} \n}\n\nLL gcd(LL x,LL y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nLL lcm(LL x,LL y){\n\treturn x / gcd(x,y) * y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL n; cin >> n;\n\tif(n == 2){\n\t\tcout << 4 << ' ' << 7 << endl;\n\t\tcout << 23 << ' ' << 10 << endl;\n\t\treturn 0;\n\t}\n\tsieve(MP);\n\tfor(LL i = 0;i <= n + 1;i ++){\n\t\tfor(LL j = 0;j <= n + 1;j ++){\n\t\t\tw[i][j] = 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tif((i + j) & 1) w[i][j] = pri[(i + j) >> 1] * pri[((i - j) >> 1) + K];\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tif(w[i][j] == 1) w[i][j] = lcm(lcm(w[i - 1][j],w[i][j - 1]),lcm(w[i + 1][j],w[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tcout << w[i][j] << (j == n ? '\\n' : ' ');\n\t\t}\n\t}\n\treturn 0;\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nll gcd(ll a,ll b){\n    if(a%b==0){return b;}\n    return gcd(b,a%b);\n}\n\nll lcm(vector<ll> &A){\n    ll ret=1;\n    for(int i=0;i<A.size();i++){\n        ret/=gcd(ret,A[i]);\n        ret*=A[i];\n    }\n    return ret;\n}\n\n\n\n\nint main(){\n    ll mx=100000;\n    vector<bool> A(mx,1);\n    vector<ll> P;\n    for(ll i=2;i<mx;i++){\n        if(A[i]){\n            for(ll t=1;i*t<mx;t*=i){\n                P.push_back(i*t);\n            }\n            for(ll t=2;i*t<mx;t++){\n                A[i*t]=0;\n            }\n        }\n    }\n    sort(P.begin(),P.end());\n    vector<vector<ll>> a(500,vector<ll>(500,1));\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if((i+t)&1){\n                a[i][t]*=P[(i+t)/2];\n            }\n            if((i-t)&1){\n                a[i][t]*=P[750+(i-t)/2];\n            }\n        }\n    }\n    vector<ll> dx={0,1,0,-1};\n    vector<ll> dy={1,0,-1,0};\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if(a[i][t]==1){\n                vector<ll> A;\n                for(int h=0;h<4;h++){\n                    ll x=i+dx[h];\n                    ll y=t+dy[h];\n                    if(x<0 || y<0 || x>=500 || y>=500){continue;}\n                    A.push_back(a[x][y]);\n                }\n                a[i][t]=lcm(A)+1;\n            }\n        }\n    }\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<a[i][t];\n            if(t+1!=n){cout<<\" \";}\n        }\n        cout<<endl;\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=510;\nint n,prm[N*2];\nll a[N][N];\n\nstruct node\n{\n\tint dat,prm;\n}b[N*2];\n\nbool cmp(node x,node y)\n{\n\treturn x.dat<y.dat;\n}\n\nvoid findprm(int k)\n{\n\tfor (int i=2,m=0;m<k;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor (int j=2;j*j<=i;j++)\n\t\t\tif (i%j==0) flag=0;\n\t\tif (flag) prm[++m]=i;\n\t}\n}\n\nll query(int x,int y,int opt)\n{\n\tif (opt==1) return b[(x+y)/2].prm;\n\t\telse return b[(n+x-y+1)/2+n].prm;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif (n==2) return !printf(\"4 7\\n23 10\");\n\tsrand(n*233+114514);\n\tfindprm(2*n);\n\tfor (int i=1;i<=2*n;i++)\n\t{\n\t\tb[i].dat=rand()*rand();\n\t\tb[i].prm=prm[i];\n\t}\n\tsort(b+1,b+1+2*n,cmp);\n\tfor (int i=1;i<=n;i++,putchar(10))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)&1)\n\t\t\t\tprintf(\"%lld \",query(i,j,1)*query(i,j,2));\n\t\t\telse \t\n\t\t\t{\n\t\t\t\tif (1<i && i<n)\n\t\t\t\t\tprintf(\"%lld \",query(i-1,j,1)*query(i-1,j,2)*query(i+1,j,1)*query(i+1,j,2)+1);\n\t\t\t\telse if (1<j && j<n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i,j+1,1)*query(i,j+1,2)+1);\n\t\t\t\telse if (i==1 && j==1)\n\t\t\t\t\tprintf(\"%lld \",query(i,j+1,1)*query(i,j+1,2)*query(i+1,j,2)+1);\n\t\t\t\telse if (i==1 && j==n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i+1,j,1)+1);\n\t\t\t\telse if (i==n && j==1)\n\t\t\t\t\tprintf(\"%lld \",query(i,j+1,1)*query(i,j+1,2)*query(i-1,j,1)+1);\n\t\t\t\telse if (i==n && j==n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i-1,j,2)+1);\n\t\t\t\telse puts(\"WYC AK IOI!!!!!\");\n\t\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\nint n, prn, pr[2000], p[1000], q[1000];\ns64 a[502][502];\nbool vis[100000];\ns64 gcd(s64 x, s64 y) {return y?gcd(y, x%y):x;}\ns64 lcm(s64 x, s64 y) {return x/gcd(x, y)*y;}\nint main() {\n\tstd::cin>>n;\n\tif(n==2) {\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i=2; prn<2*n; ++i) {\n\t\tif(!vis[i]) pr[prn++]=i;\n\t\tfor(int j=0; j<prn&&i*pr[j]<100000; ++j) {\n\t\t\tvis[i*pr[j]]=true;\n\t\t\tif(i%pr[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1; i<=2*n-2; i+=2) p[i]=pr[--prn];\n\tfor(int i=n&1; i<=2*n-2; i+=2) q[i]=pr[--prn];\n\tfor(int i=0; i<=n; ++i) a[i][0]=a[0][i]=a[i][n+1]=a[n+1][i]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=(i&1)+1; j<=n; j+=2)\n\t\t\ta[i][j]=(s64)p[i+j-2]*q[i-j+n-1];\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=(~i&1)+1; j<=n; j+=2)\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j], a[i+1][j]), lcm(a[i][j-1], a[i][j+1]))+1;\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=1; j<=n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b){ return a%b ? gcd(b, a%b) : b; }\nlong long lcm(long long a, long long b){ return a/gcd(a, b)*b; }\n\nint main(){\n    deque<int> p;\n    p.push_back(2);\n    p.push_back(3);\n    for(int i=5;p.size()<1000;i+=2){\n        bool ok = true;\n        for(auto& t : p) if(i%t == 0) ok = false;\n        if(ok) p.push_back(i);\n    }\n    vector<int> prime;\n    for(int i=0;i<500;i++){\n        prime.push_back(p.front());\n        p.pop_front();\n        prime.push_back(p.back());\n        p.pop_back();\n    }\n    vector<vector<long long>> m(500, vector<long long>(500, 1));\n    for(int i=0;i<500;i++){\n        for(int j=0;j<500;j++){\n            if((i+j)%2) continue;\n            m[i][j] = prime[(i+j)/2] * prime[(j-i+498)/2];\n        }\n    }\n    for(int i=0;i<500;i++){\n        for(int j=0;j<500;j++){\n            if((i+j)%2 == 0) continue;\n            int dx[] = {-1, 0, 1, 0};\n            int dy[] = {0, -1, 0, 1};\n            for(int d=0;d<4;d++){\n                int nx = i+dx[d];\n                int ny = j+dy[d];\n                if(nx < 0 || 500 <= nx || ny < 0 || 500 <= ny) continue;\n                m[i][j] = lcm(m[i][j], m[nx][ny]);\n            }\n            ++m[i][j];\n        }\n    }\n    int N; cin >> N;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++) cout << m[i][j] << \" \";\n        cout << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+5;\n\nll s[505];\nll a[505][505], t = 1000000000000000, n;\nmap<ll, ll> m;\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\n\nbool isp(int x) {\n\tfor (int i = 2; i < x; ++i)\n\t\tif (x%i == 0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tint ct = 0;\n\tfor (int i = 500; i <= 5000; ++i) {\n\t\tif (isp(i)) {\n\t\t\ts[ct] = i;\n\t\t\tct++;\n\t\t}\n\t\tif (ct == 250)\n\t\t\tbreak;\n\t}\n\n\tfor (int i = 0; i < 500; ++i)\n\t\tfor (int k = i%2; k < 500; k += 2) {\n\t\t\ta[i][k] = (i+1)*s[k/2];\n\t\t}\n\n\tfor (int i = 0; i < 500; ++i)\n\t\tfor (int j = 0; j < 500; ++j) {\n\t\t\tif (a[i][j] > 0)\n\t\t\t\tcontinue;\n\t\t\tll x = 1, g;\n\t\t\tif (i != 0) {\n\t\t\t\tg = gcd(x, a[i-1][j]);\n\t\t\t\tx = x/g*a[i-1][j];\n\t\t\t} if (i != 499) {\n\t\t\t\tg = gcd(x, a[i+1][j]);\n\t\t\t\tx = x/g*a[i+1][j];\n\t\t\t} if (j != 0) {\n\t\t\t\tg = gcd(x, a[i][j-1]);\n\t\t\t\tx = x/g*a[i][j-1];\n\t\t\t} if (j != 499) {\n\t\t\t\tg = gcd(x, a[i][j+1]);\n\t\t\t\tx = x/g*a[i][j+1];\n\t\t\t}\n\t\t\t// assert(x <= 1LL*10*10*10*1000000*1000000);\n\t\t\tll y = t/x;\n\t\t\tx = y*x+1;\n\t\t\ta[i][j] = x;\n\t\t}\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (m[a[i][j]] == 1) {\n\t\t\t\tcout << \"BAD\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tm[a[i][j]] = 0;\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1005,lim=N*10;\nint flag[lim],p[N],n,cnt;\n\nint main(){\n\tread(n),p[++cnt]=1;\n\tfor(int i=2;cnt<=n*2;i++)\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tfor(int j=i*i;j<lim;j+=i)\n\t\t\t\tflag[j]=1;\n\t\t}\n\trep(i,1,n){\n\t\trep(j,1,n)\n\t\t\tif((i+j)&1){\n\t\t\t\tll res=(ll)p[(i+j-1)/2]*p[(i+j+1)/2];\n\t\t\t\tres*=(ll)p[(i+3*n-j-1)/2]*p[(i+3*n-j+1)/2];\n\t\t\t\tprintf(\"%lld \",res+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll res=(ll)p[(i+j)/2]*p[(i-j+3*n)/2];\n\t\t\t\tprintf(\"%lld \",res);\n\t\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=3583;\nint i,j,M,n,m,cnt,c[505];bool bz[N+5];\nll a[505][505],p;\nint main(){\n\tc[0]=1;\n\tfo(i,2,N)if (!bz[i]) {\n\t\tc[++cnt]=i;\n\t\tfor(j=i<<1;j<=N;j+=i) bz[j]=1;\n\t}\n\tscanf(\"%d\",&n);\n\tM=n/2+1;\n\tfo(i,1,n){\n\t\tp=i&1?c[i/2+1]:c[i/2]*2;\n\t\tfor(j=2-(i&1),m=M+1;j<=n;j+=2,m++) a[i][j]=p*c[m];\n\t}\n\tfo(i,1,n){\n\t\tp=(i&1?2:4)*c[i/2]*c[i/2+1];\n\t\tif (!(i&1)) a[i][j=1]=p*c[M+1]+1,m=M+1;else\n\t\ta[i][j=2]=p*c[M+1]*c[M+2]+1,m=M+2;\n\t\tfor(j+=2;j<=n;j+=2,m++) a[i][j]=p*c[m]*c[m+1]+1;\n\t}\n\tfo(i,1,n)\n\tfo(j,1,n) printf(\"%lld%c\",a[i][j],j<n?' ':'\\n') ;\t\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint n;\nvector<ll> pr;\nmt19937 rnd(123);\nll a[1200][1200];\nusing lll = __int128_t;\n\n\nlll lcm(lll a, lll b) {\n\treturn a * b / __gcd(a, b);\n}\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tn = 500;\n\tfor (int i = 2; i < 8000; ++i) {\n\t\tint fl = 0;\n\t\tfor (int j = 2; j * j <= i; ++j)\n\t\t\tif (i % j == 0) {\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!fl)\n\t\t\tpr.push_back(i);\n\t}\n\tvector<int> xx, yy;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i % 2 == j % 2) {\n\t\t\t\txx.push_back((i + j) / 2);\n\t\t\t\tyy.push_back((i - j) / 2);\n\t\t\t}\n\t\t}\n\tsort(xx.begin(), xx.end());\n\txx.resize(unique(ALL(xx)) - xx.begin());\n\tsort(yy.begin(), yy.end());\n\tyy.resize(unique(ALL(yy)) - yy.begin());\n\tpr.resize(xx.size() + yy.size());\n\tvector<ll> tmp;\n\tint l = 0;\n\tint r = pr.size() - 1;\n\twhile (l <= r) {\n\t\ttmp.push_back(pr[l]);\n\t\t++l;\n\t\tif (l <= r) {\n\t\t\ttmp.push_back(pr[r]);\n\t\t\t--r;\n\t\t}\n\t}\n\tpr = tmp;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i % 2 == j % 2) {\n\t\t\t\tint x = (i + j) / 2 - xx[0];\n\t\t\t\tint y = (i - j) / 2 - yy[0];\n\t\t\t\ta[i][j] = pr[x] * pr[xx.size() + y];\n\t\t\t\tassert(a[i][j] <= ll(1e15));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i % 2 != j % 2) {\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor (int g = 0; g < 4; ++g) {\n\t\t\t\t\tint nx = i + dx[g];\n\t\t\t\t\tint ny = j + dy[g];\n\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= n || ny >= n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ta[i][j] = lcm(a[i][j], a[nx][ny]);\n\t\t\t\t}\n\t\t\t\ta[i][j] += 1;\n\t\t\t\tassert(a[i][j] <= ll(1e15));\n\t\t\t}\n\t\t}\n\t}\n\tcin >> n;\n\tset<ll> ss;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcout << a[i][j] << \" \", ss.insert(a[i][j]);\n\t\tcout << \"\\n\";\n\t}\n\tassert(ss.size() == n * n);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Author: hotaruijika\n * Created: 2018.09.15 23:58:01\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n;\nlong long f[11111], a[500 * 500 + 10], color[500 * 500 + 10];\nmap <int, int> id;\nvector <long long> prime;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 2; i <= 1e4 + 10; ++i) {\n\t\tif (!f[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tf[i] = i;\n\t\t}\n\t\tfor (int j = 0; j < (int) prime.size() && i * prime[j] <= 1e4 && prime[j] <= f[i]; ++j) \n\t\t\tf[i * prime[j]] = prime[j];\n\t}\n\tfor (int i = 1; i <= n * n; ++i) {\n\t\tint x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tif ((x + y) % 2) {\n\t\t\ta[i] = prime[(x + y) / 2 - 1] * prime[2 * n - x + y - 1];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n * n; ++i) {\n\t\tint x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tif ((x + y) % 2 == 0) {\n\t\t\tlong long lcm = 1;\n\t\t\tfor (int k = 0; k < 4; ++k) if (x + dx[k] > 0 && x + dx[k] <= n && y + dy[k] > 0 && y + dy[k] <= n) {\n\t\t\t\tlcm = a[(x + dx[k] - 1) * n + y + dy[k]] / __gcd(a[(x + dx[k] - 1) * n + y + dy[k]], lcm) * lcm;\n\t\t\t}\n\t\t\ta[i] = lcm + 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n * n; ++i) cout << a[i] << (i % n ? \" \" : \"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<ll>> a(N, vector<ll>(N));\n\tint tmp = 3;\n\tunordered_set<ll> st;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 0) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\ta[i][j] = tmp += 2;\n\t\t\t\tst.insert(a[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[i][j] = a[i - 1][j - 1] * 2;\n\t\t\t}\n\t\t\tst.insert(a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 1) {\n\t\t\tll g = 0;\n\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\tint ti = i + dx[d], tj = j + dy[d];\n\t\t\t\tif (0 <= ti && ti < N && 0 <= tj && tj < N) {\n\t\t\t\t\tll aa = g == 0 ? a[ti][tj] : a[ti][tj] / __gcd(a[ti][tj], g) * g;\n\t\t\t\t\tg = aa;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll t = g + 1;\n\t\t\twhile (st.count(t)) {\n\t\t\t\tt += g;\n\t\t\t}\n\t\t\ta[i][j] = t;\n\t\t\tst.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j + 1 == N];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nll mat[501][501];\nint np[1000001],pr[1000001],p=0,pp=0;\nint n;\nll gcd(ll a,ll b){\n\tif(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tnp[1]=1;\n\tfor(int i=0;i<=500;i++){\n\t\tfor(int j=0;j<=500;j++){\n\t\t\tmat[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=1000000;i++){\n\t\tfor(int j=i*2;j<=1000000;j+=i){\n\t\t\tnp[j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(!np[i]) pr[++p]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)==(j&1)) mat[i][j]=pr[++pp];\n\t\t\t//printf(\"%d %d %d\\n\",i,j,pr[pp]);\n\t\t\tif((i&1)==(j&1)){\n\t\t\t\tmat[i][j-1]=lcm(mat[i][j],mat[i][j-1]);\n\t\t\t\tmat[i][j+1]=lcm(mat[i][j],mat[i][j+1]);\n\t\t\t\tmat[i-1][j]=lcm(mat[i][j],mat[i-1][j]);\n\t\t\t\tmat[i+1][j]=lcm(mat[i][j],mat[i+1][j]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)!=(j&1)) mat[i][j]++;\n\t\t\tprintf(\"%lld \",mat[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n//最大公約数\nlint gcd( lint m, lint n )\n{\n\tlint a=max(m,n),b=min(m,n);\n\tif(m==0) return n;if(n==0) return m;\n\tif(a%b==0) return b;\n\treturn gcd(b,a-b*(a/b));\n}\n\n//最小公倍数\n//（超えそうだったらlong longにすること！）\nlint lcm( lint m, lint n )\n{\n\tif (( 0 == m ) || ( 0 == n )) return 0;\n\treturn ((m / gcd(m, n)) * n);\n}\nvector<lint> so;\nbool sos[10010];\nlint out[510][510];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nmap<lint,int> me;\nset<lint> se;\nint main()\n{\n\tlint inf=1000000000000000LL;\n\tmemset(sos,false,sizeof(sos));\n\tREP(i,2,10010){\n\t\tif(sos[i]) continue;\n\t\tfor(int j=i+i;j<10010;j+=i) sos[j]=true;\n\t\tif(i>501 && so.size()<510) so.pb(i);\n\t}\n\trep(i,500) rep(j,500){\n\t\tif((i+j)%2==0) continue;\n\t\tout[i][j]=so[i/2]*(j+2);\n\t\tse.insert(out[i][j]-1);\n\t}\n\trep(i,500) rep(j,500){\n\t\tif((i+j)%2==1) continue;\n\t\tout[i][j]=1;\n\t\tif(i>0) out[i][j]*=so[(i-1)/2];\n\t\tif(i<499) out[i][j]*=so[(i+1)/2];\n\t\tfor(int k=max(0,j-1);k<min(500,j+2);k++) out[i][j]*=(k+2);\n\t\tlint t=1;\n\t\twhile(se.find(out[i][j]*t)!=se.end()) t++;\n\t\tout[i][j]*=t;\n\t\tse.insert(out[i][j]);\n\t\tout[i][j]++;\n\t}\n\trep(i,500) rep(j,500){\n\t\tassert(out[i][j]<=inf);\n\t\tif(out[i][j]>=inf){\n\t\t\tcout<<out[i][j]<<endl;\n\t\t}\n\t\t//assert(!me[out[i][j]]);\n\t\tif(me[out[i][j]]>0){\n\t\t\tcout<<out[i][j]<<' '<<i<<' '<<j<<' '<<me[out[i][j]]<<endl;\n\t\t}\n\t\tme[out[i][j]]++;\n\t\trep(k,4){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x<0 || y<0 || x>499 || y>499) continue;\n\t\t\tlint a=max(out[i][j],out[x][y]),b=min(out[i][j],out[x][y]);\n\t\t\tif(a%b!=1LL){\n\t\t\t\tcout<<i<<' '<<j<<' '<<x<<' '<<y<<' '<<a<<' '<<b<<' '<<a%b<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tint n;cin>>n;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcout<<out[i][j];\n\t\t\tif(j<n-1) cout<<' ';else cout<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nvector<bool> isp;\nvector<ll> prime;\n\nvoid sieve(int x=pow(10,6)+10) {\n  isp.resize(x,true); \n  isp[0] = false;\n  isp[1] = false;\n  for (int i=2; pow(i,2)<=x; i++) {\n    if (isp[i]) for(int j=2; i*j<=x; j++) isp[i*j] = false;\n  }\n  rep(i,x+1) if (isp[i]) prime.push_back(i);\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nint main() {\n  sieve();\n  int N; cin >> N;\n  int tn = N%2==0 ? N+1 : N;\n  ll result[tn][tn] = {}; rep(i,tn) fill_n(result[i],tn,1);\n  rep(i,tn) rep(j,tn) if ((i+j)%2==0) result[i][j] = prime[(i+j)/2] * prime[tn+((tn-1-i)+j)/2];\n  rep(i,tn) rep(j,tn) {\n    if ((i+j)%2==1) {\n      if (i!=0)    result[i][j] = lcm(result[i][j], result[i-1][j]);\n      if (i!=tn-1) result[i][j] = lcm(result[i][j], result[i+1][j]);\n      if (j!=0)    result[i][j] = lcm(result[i][j], result[i][j-1]);\n      if (j!=tn-1) result[i][j] = lcm(result[i][j], result[i][j+1]);\n      result[i][j]++;\n    }\n  }\n  // ll r = 0; rep(i,N) rep(j,N) r = max(r, result[i][j]);\n  // cout << r << endl;\n  rep(i,N) debug(result[i],result[i]+N);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long int LL;\nconst int Max_N(505);\nconst int Max_S(10000000);\nconst int dx[] = {+1, -1, +0, +0};\nconst int dy[] = {+0, +0, +1, -1};\n\nconstexpr LL gcd(LL a, LL b)\n{\n\treturn b == 0LL ? a : gcd(b, a % b);\n}\n\nconstexpr LL lcm(LL a, LL b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nint N, ps, P[Max_S];\nLL A[Max_N][Max_N];\nbool Prime[Max_S];\n\nint main()\n{\n\tmemset(Prime, true, sizeof(Prime)), Prime[0] = Prime[1] = false;\n\tfor (int i = 2;i < Max_S;++i)\n\t{\n\t\tif (Prime[i])\n\t\t\tP[++ps] = i;\n\t\tfor (int j = 1, x;j <= ps && (x = i * P[j]) < Max_S;++j)\n\t\t{\n\t\t\tPrime[x] = false;\n\t\t\tif (x % P[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tprintf(\"%d %d\\n\", 4, 7);\n\t\tprintf(\"%d %d\\n\", 23, 10);\n\t\treturn 0;\n\t}\n\tfor (int i = 0;i <= N + 1;++i)\n\t\tfor (int j = 0;j <= N + 1;++j)\n\t\t\tA[i][j] = 1LL;\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tA[i][j] = P[(i + j) >> 1] * 1LL * P[N + (i - j) / 2 + (N + 1) / 2];\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tfor (int k = 0, x, y;k < 4;++k)\n\t\t\t\t\tif (1 <= (x = i + dx[k]) && x <= N && 1 <= (y = j + dy[k]) && y <= N)\n\t\t\t\t\t\tA[i][j] = lcm(A[i][j], A[x][y]);\n\t\t\t\t++A[i][j];\n\t\t\t}\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define set0(x) memset(x,0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();ll f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nll gcd(ll a,ll b){\n\tif(b == 0)return a;\n\treturn gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n\tif(a == 0)return b;\n\tif(b == 0)return a;\n\treturn 1ll*a/gcd(a,b)*b;\n}\nll isnp[10010],n;\nvector<int> V,tv;\nset<int> S;\nll ans[505][505];\nint main() {\n\tread(n);\n\tint m = n;\n\tif(m%2 == 0)m+=1;\n\tfor(int i=1;i<=m/2;i++){\n\t\ttv.push_back(i);\n\t\ttv.push_back(m-i);\n\t}\n\tfor(int i=2;i<10010;i++){\n\t\tif(isnp[i])continue;\n\t\tif(i>=m && V.size()<(n+1)/2)V.push_back(i);\n\t\tfor(int j = i+i;j<10010;j+=i)isnp[j] = 1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2 ==0){\n\t\t\t\tans[i][j] = tv[j-1]*V[(i-1)/2];\n\t\t\t\tassert(S.count(ans[i][j]) == 0);\n\t\t\t\tS.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2 ==1){\n\t\t\t\tll cl = lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]));\n\t\t\t\tans[i][j] = cl+1;\n\t\t\t\twhile(S.count(ans[i][j]))ans[i][j]+=cl;\n\t\t\t\tassert(ans[i][j]<1e15);\n\t\t\t\tS.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcout<<ans[i][j]<<\"\\t\";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i < 500 ? 998 - 2 * i : 2 * i - 999;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 1;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[250+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X(i+j)*Y(i-j);\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2)+1;\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N;\nll A[505][505];\n\nconst int prime_max = 1000000;\nint NP,prime[100000],divp[prime_max];\nmap<int,int> M;\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime[NP++]=i;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll LCM(ll a,ll b) {\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/__gcd(a,b)*b;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\t\n\tcprime();\n\t\n\tvector<int> P[2];\n\tFOR(i,500) {\n\t\tP[0].push_back(prime[i]);\n\t\tP[1].push_back(prime[999-1]);\n\t}\n\t\n\tFOR(y,500) FOR(x,500) if((x+y)%2==0) {\n\t\ti=(x+y)/2;\n\t\tj=(x-y)/2+249;\n\t\tA[y][x]=1LL*P[0][i]*P[1][j];\n\t}\n\tFOR(y,500) FOR(x,500) if((x+y)%2==1) {\n\t\tif(y) A[y][x]=LCM(A[y-1][x],A[y][x]);\n\t\tif(x) A[y][x]=LCM(A[y][x-1],A[y][x]);\n\t\tif(y<499) A[y][x]=LCM(A[y+1][x],A[y][x]);\n\t\tif(x<499) A[y][x]=LCM(A[y][x+1],A[y][x]);\n\t\tA[y][x]++;\n\t}\n\t\n\t\n\tFOR(y,N) {\n\t\tFOR(x,N) cout<<A[y][x]<<\" \";\n\t\tcout<<endl;\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\nnamespace MATH\n{\n\tconst int n = (int) 1e7;\n\n\tint p[n + 5], pri[n + 5], pri_cnt = 0;\n\n\tinline void init()\n\t{\n\t\tp[1] = 1;\n\t\tfor(int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif(!p[i]) p[i] = i, pri[++pri_cnt] = i;\n\t\t\tfor(int j = 1; j <= pri_cnt && i * pri[j] <= n; ++j)\n\t\t\t{\n\t\t\t\tp[i * pri[j]] = pri[j];\n\t\t\t\tif(i % pri[j] == 0) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAXN = 500;\n\nint n;\n\ninline void input()\n{\n\tn = read<int>();\n}\n\ninline void solve()\n{\n\tif(n == 2) { puts(\"4 7\\n23 10\"); return; }\n\n\tstatic int col[MAXN + 5][MAXN + 5];\n\tstatic LL a[MAXN + 5][MAXN + 5];\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) col[i][j] = (i + j) & 1;\n\tfor(int i = 0; i <= n + 1; ++i) for(int j = 0; j <= n + 1; ++j) a[i][j] = 1;\n\n\tstatic unordered_map<int, int> id0, id1;\n\tint cnt = 0;\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 0)\n\t{\n\t\tif(!id0.count(i + j)) id0[i + j] = ++cnt;\n\t\ta[i][j] *= MATH::pri[id0[i + j]];\n\t}\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 0)\n\t{\n\t\tif(!id1.count(i - j)) id1[i - j] = ++cnt;\n\t\ta[i][j] *= MATH::pri[id1[i - j]];\n\t}\n\n\tauto lcm = [] (LL x, LL y) { return x / __gcd(x, y) * y; };\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 1)\n\t{\n\t\ta[i][j] = lcm(a[i][j], a[i - 1][j]);\n\t\ta[i][j] = lcm(a[i][j], a[i + 1][j]);\n\t\ta[i][j] = lcm(a[i][j], a[i][j - 1]);\n\t\ta[i][j] = lcm(a[i][j], a[i][j + 1]);\n\t\t++a[i][j];\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld%c\", a[i][j], j == n ? '\\n' : ' ');\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <unordered_map>\n#include <algorithm>\n#include <queue>\n#include <math.h>\n#include <iomanip>\n \nusing namespace std;\n  \n/********** TEMPLATE STARTS HERE ***********/\n    \n#define IOS ios::sync_with_stdio(false), cin.tie(0);\n#define all(v) v.begin(), v.end()\n#define F first\n#define S second\n#define pb push_back\n#define test int t; cin >> t; while(t--)\n#define skip continue\n#define stop break\n#define sz(v) (int)v.size()\n#define endl '\\n'\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n#define gcd __gcd \n#define FO(i, a) for(auto & i : a)\n#define debug(a) cout << #a << \": \" << a << endl\n#define debug1(a, l, r) FR(i, l, r) cout << a[i] << \" \"; cout << endl\n#define SET(a, b) memset(a, b, sizeof(a));\n#define refresh fflush(stdout);\n#define digits(n) (int)(log10(n) + 1)\n  \ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <int> vi;\ntypedef vector <long long> vl;\ntypedef vector <pii> vii;\ntypedef vector <pll> vll;\n    \nconst int INF = 0x3f3f3f3f;\nconst int LINF = 0x3f3f3f3f3f3f3f3f;\n    \ntemplate <typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate <typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n   \n/*********** TEMPLATE ENDS HERE *************/\n\nmain()\n{\n\tIOS\n\tint n;\n\tcin >> n;\n\t\n\tint k = 0;\n\t\n\tfor(int i = 1; i <= n; i++, cout << endl)\n\t{\n\t\tif(n % 2 == 0)\n\t\t\tk ^= 1;\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tcout << k + 2 << ' ', k ^= 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\tscanf(\"%d\", &n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1)){\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\t\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\t}\n\t\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) a[i][j] *= b[i][j];\n\t\n\t\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tfor (int d=0 ; d<4; ++d){\n\t\t\tint x= i+dx[d], y=j+dy[d];\n\t\t\tif ( x<0 || x>=n || y<0 || y>=n ) continue;\n\t\t\ts =(__int128)s*a[x][y]/__gcd(s, a[x][y]);\n\t\t}\n\t\ta[i][j] = s+1;\n\t}\n\t\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nll ans[1005][1005],prime[10005],num;\nbool flag[10005];\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tflag[1]=1;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(!flag[i])prime[++num]=i;\n\t\tfor(int j=1;j<=num&&prime[j]*i<=10000;j++)\n\t\t{\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif(!((i+j)&1))\n\t\t{\n\t\t\tint p1=(i+j+1)/2;\n\t\t\tint p2=(i-j+n+1)/2+n;\n\t\t\tans[i][j]=prime[p1]*prime[p2];\n\t\t}\n\t}\n\tll v=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif((i+j)&1)\n\t\t{\n\t\t\tans[i][j]=1;\n\t\t\tif(i!=1)ans[i][j]*=ans[i-1][j]/__gcd(ans[i][j],ans[i-1][j]);\n\t\t\tif(j!=1)ans[i][j]*=ans[i][j-1]/__gcd(ans[i][j],ans[i][j-1]);\n\t\t\tif(i!=n)ans[i][j]*=ans[i+1][j]/__gcd(ans[i][j],ans[i+1][j]);\n\t\t\tif(j!=n)ans[i][j]*=ans[i][j+1]/__gcd(ans[i][j],ans[i][j+1]);\n\t\t\tans[i][j]++;\n\t\t}\n\t\tv=max(v,ans[i][j]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t  printf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cmath>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst long long lim = 1000000000000000;\nconst int sublim = (int)sqrt(lim) / 3;\nconst vector<int> dx = { 1, 0, -1, 0 };\nconst vector<int> dy = { 0, 1, 0, -1 };\nbool valid(vector<int> v1, vector<int> v2) {\n\treturn (v1[0] >= v2[0] && v1[1] >= v2[1] && v1[2] >= v2[2] && v1[3] >= v2[3]) || (v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2] && v1[3] <= v2[3]);\n}\nvector<int> solve(int a, int b, int c, int d) {\n\tvector<vector<int> > v;\n\tint basemul = 1;\n\tint ret = 0;\n\tfor (int i = 0; basemul <= sublim; ++i) {\n\t\tint bmul = basemul;\n\t\tfor (int j = 0; bmul <= sublim; ++j) {\n\t\t\tint mul = bmul;\n\t\t\tfor (int k = 0; mul <= sublim; ++k) {\n\t\t\t\tint smul = mul;\n\t\t\t\tfor (int l = 0; smul <= sublim; ++l) {\n\t\t\t\t\t++ret;\n\t\t\t\t\tsmul *= d;\n\t\t\t\t\tv.push_back({ i, j, k, l });\n\t\t\t\t}\n\t\t\t\tmul *= c;\n\t\t\t}\n\t\t\tbmul *= b;\n\t\t}\n\t\tbasemul *= a;\n\t}\n\tsort(v.begin(), v.end());\n\tvector<bool> used(v.size());\n\tint cur = v.size() - 1;\n\tvector<vector<int> > seq;\n\twhile (true) {\n\t\tused[cur] = true;\n\t\tseq.push_back(v[cur]);\n\t\tint ncur = -1;\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tif (!used[i] && valid(v[cur], v[i])) {\n\t\t\t\tncur = i;\n\t\t\t}\n\t\t}\n\t\tif (ncur == -1) break;\n\t\tcur = ncur;\n\t}\n\tvector<int> ans;\n\tfor (vector<int> i : seq) {\n\t\tint mul = 1;\n\t\tfor (int j = 0; j < i[0]; ++j) mul *= a;\n\t\tfor (int j = 0; j < i[1]; ++j) mul *= b;\n\t\tfor (int j = 0; j < i[2]; ++j) mul *= c;\n\t\tfor (int j = 0; j < i[3]; ++j) mul *= d;\n\t\tans.push_back(mul);\n\t}\n\treturn ans;\n}\nlong long gcd(long long x, long long y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nlong long lcm(long long x, long long y) {\n\treturn x / gcd(x, y) * y;\n}\nint main() {\n\tvector<int> c1 = solve(2, 7, 17, 19);\n\tvector<int> c2 = solve(3, 5, 11, 13);\n\tint n;\n\tcin >> n;\n\tset<long long> s;\n\tvector<vector<long long> > v(n, vector<long long>(n));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tint a = i + j, b = i - j + ((n - 1) / 2) * 2;\n\t\t\tif (a % 2 == 0) {\n\t\t\t\tv[i][j] = 1LL * c1[a / 2] * c2[b / 2];\n\t\t\t\ts.insert(v[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tlong long delta = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\t\tif (0 <= tx && tx < n && 0 <= ty && ty < n) {\n\t\t\t\t\t\tdelta = lcm(delta, v[tx][ty]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[i][j] = delta + 1;\n\t\t\t\twhile (s.count(v[i][j])) v[i][j] += delta;\n\t\t\t\ts.insert(v[i][j]);\n\t\t\t\tassert(v[i][j] <= lim);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j) cout << ' ';\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main (){int n;\ncin>>n;\nfor(int i = 0; i < n; i++) {\n  \tfor(int j = 0; j < n; j++){\n\t\tcout<<10000000-i-j;\n\t\tcout<<(j==n-1 ? \"\\n\": \" \" );\n    }\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=10000;\nint prime[10010],tot;\nbool vis[10010];\nlong long a[510][510];\nlong long gcd(long long a,long long b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nlong long lcm(long long a,long long b)\n{\n\treturn a/gcd(a,b)*b;\n}\nvoid init()\n{\n\tvis[1]=true;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tvis[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\treturn ;\n}\nint main()\n{\n\tinit();\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\ta[i][j]*=prime[1+(i+j)/2];\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tif((i-j)%2==0)\n\t\t\t\ta[i][j]*=prime[2*n+10-(i-j+n+1)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==1)\n\t\t\t{\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint p[131072],minp[131072],cnt=0;\nlong long ans[505][505];\nint main()\n{\n\tfor(int i=2;i<=100000;i++)\n\t{\n\t\tif(!minp[i])\n\t\t{\n\t\t\tp[cnt]=i;\n\t\t\tminp[i]=i;\n\t\t\tcnt++;\n\t\t}\n\t\tfor(int j=0;j<cnt&&p[j]<=minp[i]&&(long long)i*p[j]<=100000;j++)\n\t\t{\n\t\t\tminp[i*p[j]]=p[j];\n\t\t}\n\t}\n\tfor(int i=0;i<500;i++)\n\t{\n\t\tfor(int j=0;j<500;j++)\n\t\t{\n\t\t\tint left=i+j;\n\t\t\tint right=i-j+500;\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tans[i][j]=(long long)p[left>>1]*p[(left+1)>>1]*p[(right>>1)+500]*p[((right+1)>>1)+500]+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans[i][j]=(long long)p[left>>1]*p[(right>>1)+500];\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==500)\n\t{\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",ans[i][j]);\n\t\t\tif(j==n-1)\n\t\t\t{\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputchar(' ');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 505\n#define maxm 4010\n#define inf 1000000007\n#define mod 998244353\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nint prime[100010],primesize;\nbool notprime[100010];\nvoid get_prime()\n{\n    for(int i=2;i<=100000;i++)\n    {\n        if(!notprime[i])   prime[++primesize]=i;\n        for(int j=1;j<=primesize&&i*prime[j]<=100000;j++)\n        {\n            notprime[i*prime[j]]=true;\n            if(i%prime[j]==0)  break;\n        }\n    }\n}\nll ans[maxn][maxn];\nint xx[4]={0,0,1,-1};\nint yy[4]={1,-1,0,0};\nbool check(int x,int y)\n{\n    return (x>=1&&x<=n&&y>=1&&y<=n);\n}\nll gcd(ll x,ll y)\n{\n    if(!y)  return x;\n    return gcd(y,x%y);\n}\nll lcm(ll x,ll y)\n{\n    return x*(y/gcd(x,y));\n}\nint main()\n{\n    get_prime();\n    n=read();\n    int l=1,r=(n<<1)+(!(n&1));\n    for(int i=2;i<=(n<<1);i+=2)\n    {\n        int val;\n        if(i%4==0)  val=prime[l++];\n        else        val=prime[r--];\n        for(int x=1;x<=n;x++)\n        {\n            int y=(i-x);\n            if(y<=0||y>n)  continue;\n            ans[x][y]=val;\n        }\n    }\n    for(int i=-(n-1)/2*2;i<=(n-1)/2*2;i+=2)\n    {\n        int val;\n        if(i%4==0)  val=prime[l++];\n        else        val=prime[r--];\n        for(int x=1;x<=n;x++)\n        {\n            int y=(i+x);\n            if(y<=0||y>n)  continue;\n            ans[x][y]*=val;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if((i+j)&1)\n            {\n                for(int k=0;k<4;k++)\n                {\n                    int tx=i+xx[k],ty=j+yy[k];\n                    if(check(tx,ty))\n                    {\n                        if(!ans[i][j])  ans[i][j]=ans[tx][ty];\n                        else          ans[i][j]=lcm(ans[i][j],ans[tx][ty]);\n                    }\n                }\n                ans[i][j]++;\n            }\n        }\n    }\n    if(n==2)  ans[1][2]=ans[1][2]*2-1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)  printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nint ip(int x)\n{\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return 0;\n    return x>1;\n}\nconst int Q=1<<16,P=1<<9;\nint pn[Q];\nll als[P][P];\nll Lcm(ll a,ll b)\n{return (a==0||b==0)?a|b:a/__gcd(a,b)*b;}\nll h[Q],z[Q];\nint main()\n{\n    int tp=0,n;\n    for(int i=2;tp<1000;i++)\n        if(ip(i))pn[++tp]=i;\n    scanf(\"%d\",&n);\n    if(n<200)return -1;\n    tp=0;\n    for(int i=1-n;i<=n-1;i++)\n        if(i&1^1)h[i+n]=pn[++tp];\n    for(int i=2;i<=(n<<1);i++)\n        if(i&1^1)z[i]=pn[++tp];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1^1)als[i][j]=h[j-i+n]*z[i+j];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1)als[i][j]=Lcm(Lcm(als[i+1][j],als[i-1][j]),Lcm(als[i][j+1],als[i][j-1]));\n    for(int i=1;i<=n;i++,puts(\"\"))\n        for(int j=1;j<=n;j++)\n            printf(\"%lld \",als[i][j]);\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x << \" = \" << x << endl\n#define fori(i, ini, lim) for(int i = int(ini); i < int(lim); i++)\n#define ford(i, ini, lim) for(int i = int(ini); i >= int(lim); i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\n\nconst int MAX = 1000 + 5;\nll mat[MAX][MAX];\nvector<int> primes;\nint n;\n\nvoid sieve() {\n    for(int i = 2; (int) primes.size() < MAX; i++) {\n        bool is_prime = true;\n        fori(j, 2, i) {\n            if(i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime) {\n            primes.push_back(i);\n        }\n    }\n}\n\nll gcd(ll a, ll b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n    return (a * (b / (gcd(a, b))));\n}\n\nbool construct() {\n    //random_shuffle(primes.begin(), primes.end()); \n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            mat[i][j] = 1;\n        }\n    }\n    int k = 0;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == 1) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj <= n; ni++, nj++) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == n) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj >= 1; ni++, nj--) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    const vector<ii> dir {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i + j) % 2 == 0) {\n                ll l = 1;\n                for(auto &each : dir) {\n                    int ni = i + each.first;\n                    int nj = j + each.second;\n                    if(ni >= 1 && ni <= n && nj >= 1 && nj <= n) {\n                        l = lcm(l, mat[ni][nj]);\n                    }\n                }\n                mat[i][j] = l + 1;\n            }\n        }\n    }\n    set<ll> all;\n    bool ok = true;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            all.insert(mat[i][j]);\n            assert(mat[i][j] > 0);\n            if(mat[i][j] > (ll) 1e15) {\n                ok = false;\n            }\n            for(auto &each : dir) {\n                int ni = i + each.first;\n                int nj = j + each.second;\n                if(ni >= 1 && ni <= n && nj >= 1 && nj <= n) {\n                    assert(max(mat[i][j], mat[ni][nj]) % min(mat[i][j], mat[ni][nj]) == 1);\n                }\n            }\n        }\n    }\n    return ok && (int) all.size() == n * n;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    srand(time(nullptr));\n    cin >> n;\n    if(n == 2) {\n        cout << \"4 7\" << '\\n';\n        cout << \"23 10\" << '\\n';\n        return 0;\n    }\n    sieve();\n    while(!construct());\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if(j > 1) {\n                cout << \" \";\n            }\n            cout << mat[i][j];\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define set0(x) memset(x,0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();ll f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nll gcd(ll a,ll b){\n\tif(b == 0)return a;\n\treturn gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n\tif(a == 0)return b;\n\tif(b == 0)return a;\n\treturn 1ll*a/gcd(a,b)*b;\n}\nll isnp[10010],n;\nvector<int> V,tv;\nset<int> S;\nll ans[505][505];\nint main() {\n\tread(n);\n\tint sub = 0;\n\tif(n%2 == 1){\n\t\tn+=1;\n\t\tsub+=1;\n\t}\n\tint m = n;\n\tif(m%2 == 0)m+=1;\n\tfor(int i=1;i<=m/2;i++){\n\t\ttv.push_back(i);\n\t\ttv.push_back(m-i);\n\t}\n\tfor(int i=2;i<10010;i++){\n\t\tif(isnp[i])continue;\n\t\tif(i>=m && V.size()<(n+1)/2)V.push_back(i);\n\t\tfor(int j = i+i;j<10010;j+=i)isnp[j] = 1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2 ==0){\n\t\t\t\tans[i][j] = tv[j-1]*V[(i-1)/2];\n\t\t\t\tassert(S.count(ans[i][j]) == 0);\n\t\t\t\tS.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2 ==1){\n\t\t\t\tll cl = lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]));\n\t\t\t\tans[i][j] = cl+1;\n\t\t\t\twhile(S.count(ans[i][j]))ans[i][j]+=cl;\n\t\t\t\tassert(ans[i][j]<1e15);\n\t\t\t\tS.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tn-=sub;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcout<<ans[i][j]<<\"\\t\";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n#include <regex>\n#include <numeric>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 998244353\n#define SQ(x) ((x)*(x))\n\nbool prime[10000];\nint primes[2000];\nLL mat[501][501];\n\nint main() {\n\tmemset(prime, 1, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tint cnt = 0;\n\tREP(i, 10000) {\n\t\tif (!prime[i])continue;\n\t\tprimes[cnt++] = i;\n\t\tfor (int j = 2 * i; j < 10000; j += i)prime[j] = false;\n\t}\n\tREP(i, 501)REP(j, 501)mat[i][j] = 1LL;\n\tREP(t, 501) {\n\t\tint d = 2 * ((t + 1) / 2)*((t & 1) ? -1 : 1);\n\t\tREP(i, 501) {\n\t\t\tFOR(j, i+d-1 , i+d+2) {\n\t\t\t\tif (0 <= j && j <= 500)mat[i][j] *= primes[2*t + 1];\n\t\t\t\tif (0 <= j && j <= 500)mat[500-i][j] *= primes[2*t + 2];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 501) {\n\t\tREP(j, 501) {\n\t\t\tif ((j^i) & 1)mat[i][j]++;\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tprintf(\"%lld \", mat[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int dx[] {0, 0, -1, 1}, dy[] {-1, 1, 0, 0};\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0)\n            return false;\n    return true;\n}\nLL lcm(LL x, LL y) {return x / __gcd(x, y) * y;}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> primes;\n    int now = 2;\n    while (primes.size() < 2 * n) {\n        if (isPrime(now))\n            primes.push_back(now);\n        ++now;\n    }\n    vector<vector<LL>> a(n);\n    for (int i = 0; i < n; ++i)\n        a[i].resize(n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            if ((i + j) % 2 == 0)\n                a[i][j] = primes[(i + j) / 2] * primes[(i - j + n - 1) / 2 + n];\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                a[i][j] = 1;\n                for (int k = 0; k < 4; ++k) {\n                    int x = i + dx[k];\n                    int y = j + dy[k];\n                    if (x >= 0 && x < n && y >= 0 && y < n)\n                        a[i][j] = lcm(a[i][j], a[x][y]);\n                }\n                ++a[i][j];\n            }\n        }\n    }\n    if (n == 2)\n        a[1][0] = 2 * a[1][0] - 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cout << a[i][j] << \" \\n\"[j == n - 1];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    vi prime;\n    ll Max=1e6;\n    vector<bool> flag(Max,1);\n    rep(i,2,Max){\n        if(flag[i]){\n            prime.pb(i);\n            prime.pb(i*2);\n            for(int j=i;j<Max;j+=i) flag[j]=0;\n        }\n    }\n    ll N; cin>>N;\n    vii ans(N,vi(N));\n    ll cnt=0;\n    rep(i,0,2*N){\n        if(i%2) continue;\n        rep(j,0,N){\n            ll k=i-j;\n            if(0<=k&&k<N) ans[j][k]=prime[cnt++];\n        }\n    }\n    vi P={0,1,0,-1},Q={1,0,-1,0};\n    rep(i,0,N){\n        rep(j,0,N){\n            if((i+j)%2){\n                ll sum=1;\n                rep(k,0,4){\n                    ll X=i+P[k],Y=j+Q[k];\n                    if(0<=X&&X<N&&0<=Y&&Y<N){\n                        ll Z=std::__gcd(ans[X][Y],sum);\n                        sum=sum*ans[X][Y]/Z;\n                    }\n                }\n                ans[i][j]=sum*4;\n            }\n        }\n    }\n    std::set<ll> memo;\n    rep(i,0,N){\n        rep(j,0,N){\n            if(memo.count(ans[i][j])){\n                ans[i][j]*=3;\n            }\n            memo.insert(ans[i][j]);\n        }\n    }\n    rep(i,0,N){\n        rep(j,0,N){\n            if((i+j)%2) ans[i][j]++;\n        }\n    }\n    rep(i,0,N){\n        rep(j,0,N) cout<<ans[i][j]<<\" \";\n        cout<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=400 +117;\nconst int MM=10000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL ans[NN][NN]={};\nLL lcm(LL a,LL b){\n\treturn a/__gcd(a,b)*b;\n}\nint pr[MM]={},psiz=0;\nint np[MM]={};\nvoid getprime(int n){\n\tnp[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(!np[i]){\n\t\t\tpr[psiz++]=i;\n\t\t}\n\t\tfor(int j=0;pr[j]*i<=n;++j){\n\t\t\tnp[pr[j]*i]=1;\n\t\t\tif(!(i%pr[j]))break;\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tgetprime(10000);\n\tint mn=(1-n)/2,mx=(n-1)/2;\n\tmx-=mn;\n\tfor(int i=0;i<=n+1;++i){\n\t\tfor(int j=0;j<=n+1;++j){\n\t\t\tans[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif((i+j)&1)continue;\n\t\t\tint c=(i-j)/2;\n\t\t\tint d=(i+j)/2;\n\t\t\tLL res=pr[c-mn]*pr[mx+d];\n\t\t\tans[i][j]=res;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif((i+j)&1){\n\t\t\t\tLL now=1;\n\t\t\t\tnow=lcm(now,ans[i][j-1]);\n\t\t\t\tnow=lcm(now,ans[i][j+1]);\n\t\t\t\tnow=lcm(now,ans[i-1][j]);\n\t\t\t\tnow=lcm(now,ans[i+1][j]);\n\t\t\t\tans[i][j]=now+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define int long long\nint n,prime[101000],a[510][510],len;\nbool isPrime[10001000];\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(int a,int b){\n\treturn a*b/gcd(a,b);\n}\nint LCM(int a,int b,int c,int d){\n\tb=lcm(a,b);\n\tc=lcm(b,c);\n\td=lcm(c,d);\n\treturn d;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t} \n\tfor(int i=2;i<=1000000;i++)\n\t\tisPrime[i]=true;\n\tfor(int i=2;i<=1000;i++){\n\t\tif(!isPrime[i])continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i)\n\t\t\tisPrime[j]=false;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tif(isPrime[i])prime[++len]=i;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1)continue;\n\t\t\tint x=(i+j)/2,y=(i-j)/2+n+(n-1)/2+1;\n\t\t\ta[i][j]=prime[x]*prime[y];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)continue;\n\t\t\ta[i][j]=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j==n)puts(\"\");\n\t\t\telse putchar(' ');\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool isp(int x) {\n\tif (x == 1) return false;\n\tfor (int i = 2; i * i <= x; i++) if (x % i == 0) return false;\n\treturn true;\n}\nint n, p1[1005], p2[1005];\nint main() {\n\tscanf(\"%d\", &n);\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tint x = 2;\n\tfor (int i = 1; i <= 2 * n - 1; i += 2) {\n\t\twhile (!isp(x)) x++;\n\t\tp1[i] = x++;\n\t}\n\tp2[0] = p2[n * 2] = 1;\n\tfor (int i = ((n & 1) ? 1 : 2); i <= 2 * n - 1; i += 2) {\n\t\twhile (!isp(x)) x++;\n\t\tp2[i] = x++;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) & 1) {\n\t\t\t\tprintf(\"%lld\", 1ll * p1[i + j - 2] * p1[i + j] * p2[i - j + n - 1] * p2[i - j + n + 1] + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%lld\", 1ll * p1[i + j - 1] * p2[i - j + n]);\n\t\t\t}\n\t\t\tprintf(\"%c\", \" \\n\"[j == n]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int int\n#define ii pair<int, int>\n#define vi vector<int>\n#define pb emplace_back\n#define sz(x) (int)x.size()\n#define all(v) v.begin(), v.end()\n#define x first\n#define y second\n#define rep(i, j, k) for(i=j; i<k; i++)\n#define sep(i, j, k) for(i=j; i>k; i--)\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nconst int inf = 1e9+7;\nconst int N = 2e3+5;\nint n, k, id=0;\nint A[N], dp[N][N];\n\nbool solve()\n{\n\tint i, j, a=0, b=0, ans = 1, x;\n\tcin>>n;\n\trep(i, 1, n+1){\n\t\trep(j, 1, n+1){\n\t\t\tif((i+j)&1) cout<<4<<\" \";\n\t\t\telse cout<<7<<\" \";\n\t\t}\n\t\tcout<<\"\\n\";\n\t}\n}\n\nsigned main()\n{\n\tios\n\tint i, t=1, j, x;\n\t// cin>>t;\n\twhile(t--) \n\t\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n#include <stack>\nusing namespace std;\n \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define ktya(x) sort(all(x))\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 1e18\n#define INFLL 1000000000000000007LL\n#define SIZE 200105\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define PI (acos(-1))\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n//ll MOD = 1000000007;\nll MOD=998244353;\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\nint H,W,N;\nll ans[505][505];\nvector<ll> primes;\nll lgcd(ll p, ll q){\n\tif(p<q)swap(p,q);\n\tif(q==0)return p;\n\treturn lgcd(q,p%q);\n\t\n}\nll llcm(ll a, ll b){\n\tll g=lgcd(a,b);\n\treturn a/g * b;\n\t\n}\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,505)rep(j,505)ans[i][j]=1;\n\tfor(int i=2;i<=100000;i++){\n\t\tbool flag=true;\n\t\tfor(int j=0;j<primes.size()&&primes[j]*primes[j]<=i;j++){\n\t\t\tif(i%primes[j]==0)flag=false;\n\t\t}\n\t\tif(flag)primes.pb(i);\n\t}\n\t\n\trep(i,N)rep(j,N){\n\t\t\n\t\tif((i+j)%2==0){\n\t\t\tans[i+1][j+1]=primes[(i+j)/2]*primes[(i-j)/2+N+(N-1)/2];\n\t\t\t\n\t\t}\n\t\t\n\t}\n\trep(i,N)rep(j,N){\n\t\tif((i+j)%2==1){\n\t\t\tll g1=llcm(ans[i][j+1],ans[i+2][j+1]);\n\t\t\tll g2=llcm(ans[i+1][j],ans[i+1][j+2]);\n\t\t\t\n\t\t\tans[i+1][j+1]=llcm(g1,g2)+1;\n\t\t}\n\t}\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tcout<<ans[i+1][j+1]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define ll long long\nusing namespace std;\nbool mx[1003][1003], flag[10004];\nll a[1003], b[1003], ans[1003][1003];\nll prime[10004];\nll gcd(ll x, ll y){\n\tif (y == 0)\n\t\treturn x;\n\treturn gcd(y, x % y);\n}\nll lcm(ll x, ll y){\n\tif (x == 0 || y == 0)\n\t\treturn x + y;\n\treturn x / gcd(x, y) * y;\n}\nint main(){\n\tint prime_cnt = 0;\n\tfor (int i = 2; i <= 10000; ++ i){\n\t\tif (! flag[i])\n\t\t\tprime[++ prime_cnt] = i;\n\t\tfor (int j = 2; i * j <= 10000; ++ j){\n\t\t\tflag[i * j] = true;\n\t\t\tif (i % j == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tif (n == 2){\n\t\tcout << \"4 7\" << endl << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tif (i % 2 == j % 2)\n\t\t\t\tmx[i][j] = true;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tif (! mx[i][j]){\n\t\t\t\t//if (! a[i + j])\n\t\t\t\t\t//a[i + j] = prime[++ cnt];\n\t\t\t\t//if (! b[i - j + n])\n\t\t\t\t\t//b[i - j + n] = prime[++ cnt];\n\t\t\t\t//ans[i][j] = a[i + j] * b[i - j + n];\n\t\t\t\tans[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tif (mx[i][j])\n\t\t\t\tans[i][j] = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1])) + 1;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tcout << ans[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma optimize(\"no-stack-protector\")\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define ALL(a) a.begin(), a.end()\n#define lowbit(x) ((x) & -(x))\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long u64;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\n\nnamespace io {\n\tconst int L = (1 << 21) + 1;\n\tchar ibuf[L], *iS, *iT, obuf[L], *oS = obuf, *oT = obuf + L - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, L, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush () { fwrite (obuf, 1, oS - obuf, stdout); oS = obuf; }\n\tinline void putc (char x) { *oS ++ = x; if (oS == oT) flush (); }\n\ttemplate <class I> inline void gi (I & x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\ttemplate <class I> inline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0', x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline char read () {\n\t\tfor (c = gc(); c < 'a' || c > 'z'; c = gc());\n\t\treturn c;\n\t}\n\tinline void gs (char *s) {\n\t\tint l;\n\t\tfor (c = gc(); c < 'a' || c > 'z'; c = gc());\n\t\tfor (l = 0; c <= 'z' && c >= 'a'; c = gc()) s[l] = c, ++l;\n\t\ts[l] = 0;\n\t}\n\tinline void ps (const char *s) {\n\t\tint l = strlen(s), i;\n\t\tfor (i = 0; i < l; i ++) putc(s[i]);\n\t}\n\tstruct IOC { ~ IOC () { flush (); } } _ioc_;\n\tinline double readld(){\n\t\tdouble x = 0, y = 1;\n\t\tfor (c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') y = -1;\n\t\tassert(c != '.');\n\t\tfor (c = gc(); c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15);\n\t\tx *= y;\n\t\tassert(c != 'e');\n\t\tif (c == '.') for (c = gc(); c <= '9' && c >= '0'; c = gc()) y *= 0.1, x += y * (c & 15);\n\t\treturn x;\n\t}\n\tinline void printld(double x, int digit){\n\t\tif (x < 0) putc('-'), x = -x;\n\t\tx += 0.5 * pow(0.1, digit);\n\t\tprint((ll)x), putc('.');\n\t\tfor (x -= (ll)x; digit; --digit) x = x * 10, putc((int)x + '0'), x -= (int)x;\n\t}\n} ;\nusing io::gi;\nusing io::gs;\nusing io::ps;\nusing io::putc;\nusing io::read;\nusing io::print;\nusing io::readld;\nusing io::printld;\n\ninline int ctz(int a){ return __builtin_ctz(a); }\ninline int ctz(uint a){ return __builtin_ctz(a); }\ninline int ctz(ll a){ return __builtin_ctzll(a); }\ntemplate <class T> inline T gcd(T a, T b){\n\tint shift = ctz(a | b);\n\tfor (b >>= ctz(b), a >>= ctz(a); a; a -= b, a >>= ctz(a)) if (a < b) swap(a, b);\n\treturn b << shift;\n}\ntemplate <class T> void exgcd(T a, T b, T &x, T &y){\n\tif (!b) return (void)(x = 1, y = 0);\n\texgcd(b, a % b, y, x), y -= a / b * x;\n}\ntemplate<class T> T inv(T a, T p){\n\tT x, y;\n\texgcd(a, p, x, y);\n\treturn (x % p + p) % p;\n}\nint fpow(int a, int t, int p){\n\tstatic int r;\n\tfor (r = 1; t; a = (ll)a * a % p, t >>= 1) if (t & 1) r = (ll)r * a % p;\n\treturn r;\n}\n\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate<class A, class B> string to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate<class A> string to_string(A v) {\n\tbool first = true; string res = \"{\";\n\tfor (const auto &x : v) {\n\t\tif (!first) res += \", \";\n\t\tfirst = false, res += to_string(x);\n\t}\n\tres += \"}\";\n\treturn res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate<class A, class...B> void debug_out(A H, B... T) { cerr << \" \" << to_string(H), debug_out(T...); }\nvoid scan(){}\ntemplate<class A, class...B> void scan(A &a, B &... b) { gi(a), scan(b...); }\n\ntemplate <class T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\ntemplate <class T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\n\nconst int N=505;\n\nu64 a[N][N];\nint n;\nbool chk(int p){\n\tint x;\n\tfor(x=2;x*x<=p;x++)if(p%x==0)return false;\n\treturn true;\n}\n\nint main(){\n\tint p,i,j,k;\n\tcin>>n;\n\tif(n==2)puts(\"4 7\\n23 10\"),exit(0);\n\tp=1;\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)a[i][j]=1;\n\tfor(k=1;k<=2*n;k+=2){\n\t\tfor(p++;!chk(p);p++);\n\t\tfor(i=1;i<k;i++)if(i<=n&&k-i<=n)a[i][k-i]*=p;\n\t}\n\tfor(k=1;k<=n;k+=2){\n\t\tfor(p++;!chk(p);p++);\n\t\tfor(i=k;i<=n;i++)a[i][i-k]*=p;\n\t\tfor(p++;!chk(p);p++);\n\t\tfor(i=k;i<=n;i++)a[i-k][i]*=p;\n\t}\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)if(a[i][j]==1){\n\t\tu64 g=1;\n\t\tif(i>1)g=g/__gcd(g,a[i-1][j])*a[i-1][j];\n\t\tif(j>1)g=g/__gcd(g,a[i][j-1])*a[i][j-1];\n\t\tif(i<n)g=g/__gcd(g,a[i+1][j])*a[i+1][j];\n\t\tif(j<n)g=g/__gcd(g,a[i][j+1])*a[i][j+1];\n\t\tg++;\n\t\ta[i][j]=g;\n\t}\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)print(a[i][j]),putc(\" \\n\"[j==n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = sieve[2] = false;\n        int_fast64_t prime_bef[prime_size][8] = {0}, cnt[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n        for(int_fast64_t i = 3; i < max_N; i += 2){\n            if(sieve[i]){\n                int_fast64_t j = i, pc = 0;\n                while(j < max_N) {\n                    prime_bef[cnt[pc]][pc] = j;\n                    ++cnt[pc];\n                    ++pc;\n                    j *= i;\n                }\n                //if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n        cnt[0] = cnt[1] = cnt[2] = cnt[3] = cnt[4] = cnt[5] = cnt[6] = cnt[7] = 0;\n        for(int_fast64_t i = 0; i < prime_size; ++i){\n            int_fast64_t j = numeric_limits<int_fast64_t>::max(), l = -1;\n            for(int_fast64_t k = 0; k < 8; ++k){\n                if(j > prime_bef[cnt[k]][k] && prime_bef[cnt[k]][k] > 0){\n                    j = prime_bef[cnt[k]][k];\n                    l = k;\n                }\n            }\n            ++cnt[l];\n            ++counter;\n            prime[i] = j;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<7592, 1000> p = Prime<7592, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i < 499 ? 997 - 2 * i : 2 * i - 996;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 1;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nint a[505][505];\nint main() {\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) {\n        int nw = i+1;\n        for(int j=1;j<=n;j++) {\n            printf(\"%d \",nw);\n            nw++;\n        }\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 505;\nint n, dx[4] = {1, 0, -1, 0}, dy[4] = {0, -1, 0, 1};\nlong long mat[N][N], pri[N << 2];\n\nbool check_prime (int p) {\n\tfor (int i = 2; i * i <= p; i++) {\n\t\tif (p % i == 0) return false;\n\t}\n\n\treturn true;\n}\n\nlong long gcd (long long x, long long y) {\n\tif (x < y) swap(x, y);\n\twhile (x % y) {\n\t\tlong long r = x % y;\n\t\tx = y, y = r;\n\t}\n\treturn y;\n}\n\nlong long lcm (long long x, long long y) {\n\treturn (x / gcd(x, y)) * y;\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 2, j = 0; j < (n << 2); i++) {\n\t\tif (check_prime(i)) pri[++j] = i;\n\t}\n\n\tset<long long> s;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tmat[i][j] = pri[i + j >> 1] * pri[(j - i) / 2 + (n + 1) / 2 + n];\n\t\t\t\ts.insert(mat[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tlong long div = mat[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\t\tif (1 <= x && x <= n && 1 <= y && y <= n) div = lcm(div, mat[x][y]);\n\t\t\t\t}\n\t\t\t\tmat[i][j] += div;\n\t\t\t\twhile (s.count(mat[i][j])) mat[i][j] += div;\n\t\t\t\ts.insert(mat[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) printf(\"%lld \", mat[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n\nvoid solve(){\n    int N;\n    cin >> N;\n\n    ll m = 2;\n    vector<vector<ll>> a(N, vector<ll>(N, 0));\n    for (int i = 0; i < N; i++) {\n        a[0][i] = 3 + m*i;\n    }\n\n    for (int i = 1; i < N; i++) {\n        if (i & 1) {\n            for (int j = N-1; j >= 0; j--) {\n                if (j == N-1) {\n                    a[i][j] = a[i-1][j] + m;\n                }else{\n                    a[i][j] = a[i][j+1] * a[i-1][j] + m;\n                }\n            }\n        }else{\n            for (int j = 0; j < N; j++) {\n                if (j == 0) {\n                    a[i][j] = a[i-1][j] + m;\n                }else{\n                    a[i][j] = a[i-1][j] * a[i][j-1] + m;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (j == 0) \n                cout << a[i][j];\n            else \n                cout << \" \" << a[i][j];\n        }\n        cout << endl;\n    }\n    return;\n}\n\nint main(int argc, char const* argv[])\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*FBI WARNING\nFederal law provides severe civil and criminal penalties for\nthe unauthorzed reproduction, distribution, or exhibition of\ncopyrighted motion pictures (Title 17 united states code\nsections 501 and 508). The federal bureau of investigation\ninvestigates allegations of criminal copyright infringement\n(Title 17, united states code sections 506).*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 510\n#define ll long long\n\ntemplate < typename tp > void read ( tp & dig ){\n    char ch=getchar();dig=0;int flag=0;\n    while(!isdigit(ch)){ if(ch=='-')flag=1;ch=getchar(); }\n    while(isdigit(ch))dig=dig*10+ch-'0',ch=getchar();\n    if(flag)dig=-dig;\n}\n\nint n,a[maxn][maxn];\nmap <ll ,ll > mp;\n\ninline int gcd(int a,int b){\n    return b?gcd(b,a%b):a;\n}\n\ninline bool check(int x){\n    a[1][1]=x;mp.clear();mp[x]=1;\n    for(int i=2;i<=n;++i)a[1][i]=a[1][i-1]+1;\n    a[2][1]=a[1][n]+a[1][n]%2+1;\n    for(int i=3;i<=n;++i)a[i][1]=a[i-1][1]+1;\n    for(int i=2;i<=n;++i)\n\tfor(int j=2;j<=n;++j){\n\t    int flag=1,x=a[i-1][j],y=a[i][j-1];\n\t    if(x>y)swap(x,y);int res=y%x;--res;\n\t    for(int k=1;k<=y/x&&flag;++k)\n\t\tif(k*res*x+res+1==y)\n\t\t    if(!mp[k*x+1])a[i][j]=k*x+1,flag=0;\n\t    if(flag){\n\t\tint tmp=a[i-1][j]/gcd(a[i-1][j],a[i][j-1])*a[i][j-1];\n\t\ta[i][j]=tmp;while(mp[a[i][j]+1])a[i][j]+=tmp;\n\t\t++a[i][j];\n\t    }mp[a[i][j]]=1;if(a[i][j]>1e15)return false;\n\t}\n    return true;\n}\n\ninline void output(){\n    for(int i=1;i<=n;++i){\n\tfor(int j=1;j<=n;++j)\n\t    printf(\"%d \",a[i][j]);\n\tprintf(\"\\n\");\n    }return ;\n}\n\nint main()\n{\n\n    read(n);\n    for(int i=2;;++i)\n\tif(check(i)){\n\t    output();\n\t    break;\n\t}\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=500;\nconst int DX[]={-1,0,+1,0},DY[]={0,+1,0,-1};\n\nint n;\nll ans[MAXN][MAXN];\n\nset<ll> have;\nint d1[2*MAXN-1],d2[2*MAXN-1];\n\nvoid solve() {\n\thave.clear();\n\tmemset(d1,-1,sizeof(d1)); memset(d2,-1,sizeof(d2));\n\tfor(int i=0;i<2*n-1;i+=2) d1[i]=400+i/2;\n\tfor(int i=(n-1)%2;i<2*n-1;i+=2) d2[i]=500+i/2;\n\n\tREP(i,n) REP(j,n) if((i+j)%2==0) {\n\t\tint a=i+j,b=j+n-i-1,t=1; ll cur=(ll)d1[a]*d2[b]; assert(d1[a]!=-1&&d2[b]!=-1);\n\t\twhile(have.count(cur*t)) ++t;\n\t\thave.insert(cur*t);\n\t\tans[i][j]=cur*t;\n\t}\n\tREP(i,n) REP(j,n) if((i+j)%2==1) {\n\t\tll cur=1; int t=1;\n\t\tREP(k,4) {\n\t\t\tint ni=i+DX[k],nj=j+DY[k]; if(ni<0||ni>=n||nj<0||nj>=n) continue;\n\t\t\tll g=gcd(cur,ans[ni][nj]); cur*=ans[ni][nj]/g;\n\t\t}\n\t\twhile(have.count(cur*t+1)) ++t;\n\t\thave.insert(cur*t+1);\n\t\tans[i][j]=cur*t+1;\n\t}\n}\n\nbool verify() {\n\tbool ok=true;\n\thave.clear();\n\tREP(x,n) REP(y,n) {\n\t\tassert(!have.count(ans[x][y])); have.insert(ans[x][y]); assert(ans[x][y]>=1&&ans[x][y]<=1000000000000000LL);\n\t\tREP(k,4) {\n\t\t\tint nx=x+DX[k],ny=y+DY[k];\n\t\t\tif(nx<0||nx>=n||ny<0||ny>=n||ans[nx][ny]>=ans[x][y]) continue;\n\t\t\tif(ans[x][y]%ans[nx][ny]!=1) {\n\t\t\t\tprintf(\"(%d,%d)->(%d,%d) %lld vs %lld (%lld)\\n\",x,y,nx,ny,ans[x][y],ans[nx][ny],ans[x][y]%ans[nx][ny]);\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn ok;\n}\n\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tsolve();\n\tREP(i,n) { REP(j,n) { if(j!=0) printf(\" \"); printf(\"%lld\",ans[i][j]); } puts(\"\"); }\n\t//if(!verify()) printf(\"err\\n\");\n}\n\nvoid stress() {\n\tfor(n=MAXN;n>=1;--n) {\n\t\tsolve();\n\t\tbool ok=verify();\n\t\tprintf(\"%d: %s\\n\",n,ok?\"ok\":\"err\");\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pii PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst int M = 500;\n\nLL A[M][M];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nvoid Check() {\n  set<LL> used;\n  rep(i, M) {\n    rep(j, M) {\n      assert(!used.count(A[i][j]));\n      used.insert(A[i][j]);\n      rep(k, 4) {\n        int ni = i + dy[k];\n        int nj = j + dx[k];\n        if (ni < 0 || M <= ni) continue;\n        if (nj < 0 || M <= nj) continue;\n        LL x = A[i][j];\n        LL y = A[ni][nj];\n        assert(max(x, y)%min(x, y) == 0);\n      }\n    }\n  }\n}\n\nusing Fact = vector<pii>;\nconst LL INF = 1e16;\nbool queued[M][M];\nFact F[M][M];\n\nLL DeFact(Fact &fs) {\n  LL ret = 1;\n  for (pii &p : fs) {\n    rep(i, p.YY) {\n      if (INF/p.XX <= ret) return INF;\n      ret *= p.XX;\n    }\n  }\n  return ret;\n}\n\nFact GcdFact(Fact a, Fact b) {\n  Fact ret;\n  while (a.size() && b.size()) {\n    int x = a.back().XX;\n    int y = b.back().XX;\n    if (x > y) a.pop_back();\n    else if (x < y) b.pop_back();\n    else {\n      assert(x == y);\n      ret.eb(pii(x, min(a.back().YY, b.back().YY)));\n      a.pop_back();\n      b.pop_back();\n    }\n  }\n  reverse(all(ret));\n  return ret;\n}\n\nset<Fact> qued;\nvector<Fact> as = {{pii(2, 6), pii(3, 4), pii(5, 2), pii(7, 1), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(29, 1), pii(31, 1)},\n  {pii(2, 8), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(29, 1)},\n  {pii(2, 8), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(31, 1)},\n  {pii(2, 8), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(37, 1)},\n  {pii(2, 6), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 2), pii(13, 2), pii(17, 1), pii(19, 1), pii(23, 1)},\n  {pii(2, 3), pii(3, 4), pii(5, 2), pii(7, 3), pii(11, 2), pii(13, 2), pii(17, 1), pii(19, 1), pii(23, 1)},\n  {pii(2, 0), pii(3, 6), pii(5, 2), pii(7, 3), pii(11, 2), pii(13, 2), pii(17, 1), pii(19, 1), pii(23, 1)},\n};\n\nFact FindUnused(Fact v) {\n  if (!qued.count(v)) return v;\n\n  set<Fact> watched;\n  queue<Fact> que;\n  que.push(v);\n  watched.insert(v);\n  while (!que.empty()) {\n    Fact fs = que.front(); que.pop();\n    int n = fs.size();\n    rrep(i, n) {\n      if (fs[i].YY == 0) continue;\n      fs[i].YY--;\n      if (!watched.count(fs)) {\n        if (!qued.count(fs)) return fs;\n        que.push(fs);\n        watched.insert(fs);\n      }\n      fs[i].YY++;\n    }\n  }\n  return Fact();\n}\n\nint cnt = 0;\nvoid FillByLeast(int i, int j) {\n  LL l = 1;\n  //cout << i << \", \" << j << \" - \" << \": \";\n  //rep(k, 4) {\n  //  int ni = i + dy[k];\n  //  int nj = j + dx[k];\n  //  if (ni < 0 || M <= ni) continue;\n  //  if (nj < 0 || M <= nj) continue;\n  //  cout << A[ni][nj] << \" \";\n  //}cout << endl;\n  rep(k, 4) {\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if (ni < 0 || M <= ni) continue;\n    if (nj < 0 || M <= nj) continue;\n    assert(A[ni][nj] > 0);\n    LL g = __gcd(A[ni][nj], l);\n    l /= g;\n    assert(INF/l > A[ni][nj]);\n    l *= A[ni][nj];\n  }\n  A[i][j] = l;\n  //cout << l << endl;\n  //cout << LL(1e15) << endl;\n  cnt += l <= LL(1e15);\n}\n\nbool is_composite[114514];\nvector<LL> primes;\n\nvoid Fill() {\n  reps(i, 2, 114514) {\n    if (is_composite[i]) continue;\n    primes.eb(i);\n    for (LL j=LL(i)*i; j<114514; j+=i) {\n      is_composite[j] = 1;\n    }\n  }\n\n  vector<int> xs, ys;\n  rep(i, M) {\n    rep(j, M) {\n      if (i%2 != j%2) continue;\n      xs.eb(i+j);\n      ys.eb(i-j);\n    }\n  }\n  sort(all(xs));\n  xs.erase(unique(all(xs)), xs.end());\n  sort(all(ys));\n  ys.erase(unique(all(ys)), ys.end());\n\n  primes.resize(xs.size() + ys.size());\n  deque<LL> X, Y;\n  \n  int k = 0;\n  while (k < primes.size()) {\n    if (X.size() < xs.size()) X.eb(primes[k++]);\n    if (Y.size() < ys.size()) Y.eb(primes[k++]);\n  }\n  deque<LL> nX, nY;\n  while (X.size()) {\n    LL t;\n    if (X.size()%2) t = X.back(), X.pop_back();\n    else t = X.front(), X.pop_front();\n    nX.eb(t);\n  }\n  while (Y.size()) {\n    LL t;\n    if (Y.size()%2) t = Y.back(), Y.pop_back();\n    else t = Y.front(), Y.pop_front();\n    nY.eb(t);\n  }\n  nX.swap(X);\n  nY.swap(Y);\n  //random_shuffle(all(X));\n  //random_shuffle(all(Y));\n  rep(i, M) {\n    rep(j, M) {\n      if (i%2 != j%2) continue;\n      int xidx = lower_bound(all(xs), i+j) - xs.begin();\n      assert(xidx < X.size());\n      int yidx = lower_bound(all(ys), i-j) - ys.begin();\n      assert(yidx < Y.size());\n      A[i][j] = X[xidx] * Y[yidx];\n    }\n  }\n  rep(i, M) {\n    rep(j, M) {\n      if (i%2 == j%2) continue;\n      FillByLeast(i, j);\n    }\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  Fill();\n  //cout << cnt << endl;\n  Check();\n  int N;\n  cin >> N;\n  rep(i, N) {\n    rep(j, N) {\n      if (j) cout << \" \";\n      cout << A[i][j];\n    }\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: ylx\n * Lang: c++\n * Prog: agc027D\n */\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x, int y)\n{\n\tif (x < y)\n\t\tx = y;\n}\nvoid qmin(int &x, int y)\n{\n\tif (x > y)\n\t\tx = y;\n}\ninline int read()\n{\n\tchar s;\n\tint k = 0, base = 1;\n\twhile ((s = getchar()) != '-' && s != EOF && !(isdigit(s)))\n\t\t;\n\tif (s == EOF)\n\t\texit(0);\n\tif (s == '-')\n\t\tbase = -1, s = getchar();\n\twhile (isdigit(s))\n\t\tk = k * 10 + (s ^ '0'), s = getchar();\n\treturn k * base;\n}\ninline void write(ll x)\n{\n\tstatic char cnt, num[20];\n\tcnt = 0;\n\tif (!x)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tfor (; x; x /= 10)\n\t\tnum[++cnt] = x % 10;\n\tfor (; cnt; putchar(num[cnt--] + 48))\n\t\t;\n}\nconst int maxm = 1e5 + 100;\nconst int maxn = 2000 + 10;\nint n, m;\nint p[maxm], cnt;\nll pr[maxn];\nll a[510][510];\nint main()\n{\n#ifdef ylx\n\tfreopen(\"agc027D.in\", \"r\", stdin);\n\tfreopen(\"agc027D.out\", \"w\", stdout);\n#endif\n\tn = read();\n\tm = 1e5;\n\tfor (int i = 2; i <= m; i++)\n\t\tif (!p[i])\n\t\t{\n\t\t\tpr[++cnt] = i;\n\t\t\tif (cnt == 2 * n + 1)\n\t\t\t\tbreak;\n\t\t\tfor (int j = i + i; j <= m; j += i)\n\t\t\t{\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\ta[i][j] = 1;\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = (i & 1) ? 1 : 2; j <= n; j += 2)\n\t\t{\n\t\t\ta[i][j] = pr[(i + j) / 2] * pr[(i - j + n + 1) / 2 + n];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = (i & 1) ? 2 : 1; j <= n; j += 2)\n\t\t{\n\t\t\ta[i][j] = a[i - 1][j] * a[i + 1][j];\n\t\t\tif (i == 1 || i == n)\n\t\t\t\ta[i][j] = a[i][j - 1] * a[i][j + 1];\n\t\t\tif (!a[i][j])\n\t\t\t\ta[i][j] = max(a[i - 1][j], 1ll) * max(a[i + 1][j], 1ll) * max(a[i][j - 1], 1ll) * max(a[i][j + 1], 1ll);\n\t\t\ta[i][j]++;\n\t\t}\n\t}\n\tif (n == 2)\n\t\ta[2][1] += 150;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\twrite(a[i][j]);\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n//2019年 02月 24日 星期日 18:28:29 CST"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nmap<long long,int> mp;\nlong long lcm(long long x,long long y){\n\tif (!(x&&y)) return x^y;\n\treturn x*y/__gcd(x,y);\n}\nconst int N=600;\nint z[N][N],n,a[N*N];\nint main(){\n\tscanf(\"%d\",&n);\n\tint tot=((n*n)+1)/2;\n\tfor (int i=1; i<=tot; ++i) a[i]=i*2;\n\trandom_shuffle(a+1,a+tot+1);\n\tint d=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=a[++d];\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n\t\tcerr<<\"tot\"<<tot<<endl;*/\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?2:1); j<=n; j+=2){\n\t\t\tlong long k=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\tlong long zz=k;\n\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\tz[i][j]=zz+C;\n\t\t\tmp[zz+C]=1;\n\t\t}\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nvoid Fill(int i, int j) {\n\tll tmp = min(min(n - i + 1, n - j + 1), min(i, j)) + 1;\n\tans[i][j] = tmp;\n\twhile (used.count(ans[i][j]))\n\t\tans[i][j] += tmp;\n\tused.insert(ans[i][j]);\n}\nstruct Node {\n\tint r, c;\n\tint Cal() const { return min(min(n - r + 1, n - c + 1), min(r, c)); }\n\tbool operator < (const Node &d) const { return Cal() < d.Cal(); }\n} todo[N * N];\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\ttodo[++tail] = (Node){i, j};\n\t\t\t}\n\tsort(todo + 1, todo + tail + 1);\n\tfor (int i = 1; i <= tail; ++i)\n\t\tFill(todo[i].r, todo[i].c);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n    return y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n    return x / GCD(x, y) * y;\n}\nvoid sieve() {\n    for(int i=2;i<=MAXM;i++) {\n        if( !vis[i] ) prm[++pcnt] = i;\n        for(int j=1;i*prm[j]<=MAXM;j++) {\n            vis[i*prm[j]] = true;\n            if( i % prm[j] == 0 ) break;\n        }\n    }\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n    sieve(); int N;\n    scanf(\"%d\", &N);\n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++)\n            Mat[i][j] = 1;\n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++)\n            if( (i & 1) == (j & 1) ) {\n                Mat[i][j] = prm[(i + j) / 2] * prm[(i+N+1-j)/2 + N];\n                Mat[i+1][j] = LCM(Mat[i+1][j], Mat[i][j]);\n                Mat[i-1][j] = LCM(Mat[i-1][j], Mat[i][j]);\n                Mat[i][j+1] = LCM(Mat[i][j+1], Mat[i][j]);\n                Mat[i][j-1] = LCM(Mat[i][j-1], Mat[i][j]);\n            }\n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++)\n            if( (i & 1) != (j & 1) )\n                Mat[i][j]++;\n    for(int i=1;i<=N;i++) {\n        for(int j=1;j<N;j++)\n            printf(\"%lld \", Mat[i][j]);\n        printf(\"%lld\\n\", Mat[i][N]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=505;\nint n;\nvector <int> vp;\nLL g[N][N];\nLL gcd(LL x,LL y){\n\treturn y?gcd(y,x%y):x;\n}\nLL lcm(LL x,LL y){\n\tif (!x||!y)\n\t\treturn x+y;\n\treturn x/gcd(x,y)*y;\n}\nint check(int n){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nmap <int,int> mp1,mp2;\nint g1(int x){\n\tif (!mp1[x])\n\t\tmp1[x]=vp.back(),vp.pop_back();\n\treturn mp1[x];\n}\nint g2(int x){\n\tif (!mp2[x])\n\t\tmp2[x]=vp.back(),vp.pop_back();\n\treturn mp2[x];\n}\nint main(){\n\tn=read();\n\tif (n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;vp.size()<n*2;i++)\n\t\tif (check(i))\n\t\t\tvp.push_back(i);\n\treverse(vp.begin(),vp.end());\n\tmp1.clear(),mp2.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]=g1(i+j);\n\tfor (int i=n;i>=1;i--)\n\t\tfor (int j=n;j>=1;j--)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]*=g2(i-j);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1){\n\t\t\t\tg[i][j]=lcm(g[i-1][j],lcm(g[i+1][j],lcm(g[i][j-1],g[i][j+1])))+1;\n\t\t\t\tassert(g[i][j]<=1000000000000000LL);\n\t\t\t}\n\tfor (int i=1;i<=n;i++,puts(\"\"))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",g[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define FOR(i,n) for (int i = 0; i < n; i++)\n#define FORR(i,a,b) for (int i = a; i <= b; i++)\n#define ALL(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ii> vii;\n\nconst int MX = 505;\nint n, m = 0;\nll res[MX][MX], p[MX*2], mx = 0;\n\nvoid pre () {\n\tfor (int i = 2; m < 1000; i++) {\n\t\tbool f = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tf |= i % p[j] == 0;\n\t\tif (!f) p[m++] = i;\n\t}\n\n\tfor (int i = 0; i < MX; i++)\n\t\tfor (int j = 0; j < MX; j++)\n\t\t\tres[i][j] = 1;\n}\n\nint mv[] = {1, 0, -1, 0, 0, 1, 0, -1};\n\n__int128 gcd (__int128 a, __int128 b) { return b ? gcd(b, a%b) : a; }\n\nll lcm (int i, int j) {\n\t__int128 a = 1;\n\n\tfor (int l = 0; l < 4; l++) {\n\t\tint x = i + mv[l*2];\n\t\tint y = j + mv[l*2+1];\n\n\t\tif (x >= 0 && y >= 0 && x < n && y < n)\n\t\t\ta = a * res[x][y] / gcd(a, res[x][y]);\n\t}\n\n\tassert(0 < a && a <= 1e15);\n\treturn a+1;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tpre();\n\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\" << endl;\n\t\treturn 0;\n\t}\n\n\tint k = 0;\n\tfor (int i = 0; i < n; i++, k++) \n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (0 <= i*2-j && i*2-j < n)\n\t\t\t\tres[i*2-j][j] *= p[k];\n\n\tfor (int i = 0; 2 * i < n; i++, k++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (0 <= i*2+j && i*2+j < n)\n\t\t\t\tres[i*2+j][j] *= p[k];\n\n\tfor (int i = 1; -2 * i + n - 1 >= 0; i++, k++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (0 <= -i*2+j && -i*2+j < n)\n\t\t\t\tres[-i*2+j][j] *= p[k];\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (res[i][j] == 1)\n\t\t\t\tres[i][j] = lcm(i, j);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << res[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 3e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcout << \"2\";\n\treturn 0;\n\n\tfor (int i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll a[502][502];\nvector<ll> p;\nbool used[100000];\nvoid init() {\n\tfill(used, used + 100000, false);\n\tfor (int i = 2; i < 100000; i++) {\n\t\tif (used[i])continue;\n\t\tp.push_back(i);\n\t\tfor (int j = i * 2; j < 100000; j+=i) {\n\t\t\tused[j] = true;\n\t\t}\n\t}\n\trep(i, 502) {\n\t\trep(j, 502) {\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n}\nvoid makemap() {\n\tint now = 0;\n\tfor (int i = 1; i <= 1007; i += 2) {\n\t\tfor (int j = 0; j < 502; j++) {\n\t\t\tint t = i - j;\n\t\t\tif (0<=t&&t<502) {\n\t\t\t\ta[j][t] *= p[now];\n\t\t\t\tif (0 <= t - 1 && t - 1 < 502)a[j][t - 1] *= p[now];\n\t\t\t\tif (0 <= t + 1 && t + 1 < 502)a[j][t + 1] *= p[now];\n\t\t\t}\n\t\t}\n\t\tnow++;\n\t}\n\tfor (int i = 501; i >= -503; i -= 2) {\n\t\tfor (int j = 0; j < 502; j++) {\n\t\t\tint t = j - i;\n\t\t\tif (0 <= t && t < 502) {\n\t\t\t\ta[j][t] *= p[now];\n\t\t\t\tif (0 <= t - 1 && t - 1 < 502)a[j][t - 1] *= p[now];\n\t\t\t\tif (0 <= t + 1 && t + 1 < 502)a[j][t + 1] *= p[now];\n\t\t\t}\n\t\t}\n\t\tnow++;\n\t}\n\trep(i, 502) {\n\t\trep(j, 502) {\n\t\t\tif ((i + j) % 2 == 0)a[i][j]++;\n\t\t}\n\t}\n}\nint main() {\n\tinit(); makemap();\n\tint n; cin >> n;\n\trep1(i, n) {\n\t\trep1(j, n) {\n\t\t\tif (j > 1)cout << \" \";\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nusing std::__gcd;\nint n,prime[10100000],a[510][510],len;\nbool isPrime[10001000];\nint lcm(int a,int b){\n\treturn a/__gcd(a,b)*b;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t} \n\tfor(int i=2;i<=1000000;i++)\n\t\tisPrime[i]=true;\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!isPrime[i])continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i)\n\t\t\tisPrime[j]=false;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tif(isPrime[i])prime[++len]=i;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1)continue;\n\t\t\tint x=(i+j)/2,y=(i+n*3-j+1)/2;\n\t\t\ta[i][j]=prime[x]*prime[y];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)continue;\n\t\t\tif(i==1&&j==n)a[i][j]=lcm(a[i+1][j],a[i][j-1]);\n\t\t\telse if(i==n&&j==1)a[i][j]=lcm(a[i-1][j],a[i][j+1]);\n\t\t\telse if(i==1||i==n)a[i][j]=a[i][j-1]*a[i][j+1]; \n\t\t\telse a[i][j]=a[i-1][j]*a[i+1][j];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j==n)puts(\"\");\n\t\t\telse putchar(' ');\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=0;i<n;i++){\ntot=n-i;\nfor(int j=i;j<=tot;j++)ans[i+j][j-i]*=prime[i+n+(n>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(it,st,en) for(int it=(st);it<(int)(en);++it)\n#define all(c) (c).begin(), (c).end()\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define eb emplace_back\n#define X first\n#define Y second\ntypedef long long int ll; \ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MAX_PR = 5000000;\nbitset<MAX_PR> isprime;\nvi eratosthenes_sieve(int lim) {\n  isprime.set(); isprime[0] = isprime[1] = 0;\n  for (int i = 4; i < lim; i += 2) isprime[i] = 0;\n  for (int i = 3; i*i < lim; i += 2) if (isprime[i])\n    for (int j = i*i; j < lim; j += i*2) isprime[j] = 0;\n  vi pr;\n  rep(i,2,lim) if (isprime[i]) pr.push_back(i);\n  return pr;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n = 100;\n    vector<vector<ll> > v(n, vector<ll>(n));\n    int cnt = 0;\n    vi pr = eratosthenes_sieve(5000000);\n    pr.resize(100*50);\n    rep(i,0,n) rep(j,0,n/2) {\n      if(cnt % 2 == 0) v[i][2*j+(i&1)] = pr[cnt/2];\n      else             v[i][2*j+(i&1)] = pr[pr.size()-cnt/2-1];\n      ++cnt;\n    }\n    rep(i,0,n) rep(j,0,n/2) {\n      int x = i, y = 2*j + ((~i)&1);\n      ll p = 1;\n      if(x != 0)   p *= v[x-1][y];\n      if(x != n-1) p *= v[x+1][y];\n      if(y != 0)   p *= v[x][y-1];\n      if(y != n-1) p *= v[x][y+1];\n      v[x][y] = p+1;\n    }\n    cin>>n;\n    rep(i,0,n) rep(j,0,n) {\n      cout << v[i][j] << \" \\n\"[j == n-1];\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long int LL;\nconst int Max_N(505);\nconst int Max_S(10000000);\nconst int dx[] = {+1, -1, +0, +0};\nconst int dy[] = {+0, +0, +1, -1};\n\nconstexpr LL gcd(LL a, LL b)\n{\n\treturn b == 0LL ? a : gcd(b, a % b);\n}\n\nconstexpr LL lcm(LL a, LL b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nint N, ps, P[Max_S];\nLL A[Max_N][Max_N];\nbool Prime[Max_S];\n\nint main()\n{\n\tmemset(Prime, true, sizeof(Prime)), Prime[0] = Prime[1] = false;\n\tfor (int i = 2;i < Max_S;++i)\n\t{\n\t\tif (Prime[i])\n\t\t\tP[++ps] = i;\n\t\tfor (int j = 1, x;j <= ps && (x = i * P[j]) < Max_S;++j)\n\t\t{\n\t\t\tPrime[x] = false;\n\t\t\tif (i % P[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tprintf(\"%d %d\\n\", 4, 7);\n\t\tprintf(\"%d %d\\n\", 23, 10);\n\t\treturn 0;\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tA[i][j] = P[(i + j) >> 1] * 1LL * P[N + (i - j) / 2 + (N + 1) / 2];\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tA[i][j] = 1LL;\n\t\t\t\tfor (int k = 0, x, y;k < 4;++k)\n\t\t\t\t\tif (1 <= (x = i + dx[k]) && x <= N && 1 <= (y = j + dy[k]) && y <= N)\n\t\t\t\t\t\tA[i][j] = lcm(A[i][j], A[x][y]);\n\t\t\t\t++A[i][j];\n\t\t\t}\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n    long n;\n    cin >> n;\n    for(long i=0; i<n; i++){\n        for(long j=0; j<n; j++){\n            cout << (2+i+j) << (j==n-1 ? \"\\n\" : \" \");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=-((n-1)>>1);i<((n+1)>>1);i++){\ntot=min(n-i-1,n+i-1);\nfor(int j=max(i,-i);j<=tot;j++)ans[i+j][j-i]*=prime[i+n+((n-1)>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 101000;\nint g[N],pri[N],tot;\nll f[1010][1010],p1[1010],p2[1010];\nvoid init(){\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!g[i]){pri[++tot]=i;g[i]=i;}\n\t\tfor(int j=1;pri[j]*i<=10000;j++){\n\t\t\tg[pri[j]*i]=pri[j];\n\t\t\tif(pri[j]==g[i]) break; \n\t\t}\n\t}\n\tint k1=0,k2=0;\n\tfor(int i=1;i<=1004;i++)\n\t\tif(i&1) p1[++k1]=pri[i];\n\t\telse p2[++k2]=pri[i];\n\tll p[1010],now=0;\n\tmemcpy(p,p1,sizeof(p1));\n\tfor(int i=1;i<=k1;i+=2)\n\t\tp1[i]=p[k1-now],p1[i+1]=p[++now];\n\tmemcpy(p,p2,sizeof(p));now=0;\n\tfor(int i=1;i<=k2;i+=2)\n\t\tp2[i]=p[k2-now],p2[i+1]=p[++now];\n}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i+j&1){\n\t\t\t\tint k=i+j>>1;\n\t\t\t\tf[i][j]=p1[k];\n\t\t\t\tk=i+(n-j+1)>>1;\n\t\t\t\tf[i][j]*=p2[k];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(~(i+j)&1){\n\t\t\t\tf[i][j]=lcm(f[i][j-1],lcm(f[i][j+1],lcm(f[i-1][j],f[i+1][j])))+1;\n\t\t \t}\n\t/*set<ll> S;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j<n&&max(f[i][j],f[i][j+1])%min(f[i][j],f[i][j+1])!=1) cerr<<\"!!\\n\";\n\t\t\tif(i<n&&max(f[i][j],f[i+1][j])%min(f[i][j],f[i+1][j])!=1) cerr<<\"!!\\n\";\n\t\t\tif(S.count(f[i][j])) cerr<<i<<' '<<j<<'\\n';\n\t\t\telse S.insert(f[i][j]);\n\t\t}*/\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<f[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nint N;\nint p[MAXN], pn;\nbool np[MAXN];\n\ninline void init(int n) {\n\tregister int i, j;\n\tnp[1] = 1;\n\tfor(i = 2; i <= n; ++i) {\n\t\tif(!np[i])\n\t\t\tp[++pn] = i;\n\t\tfor(j = 1; j <= pn && i * p[j] <= n; ++j) {\n\t\t\tnp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tregister int i, j; init(1e4);\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; ++i) {\n\t\tfor(j = 0; j < N; ++j) {\n\t\t\tint s = (i + j) >> 1, d = (i - j) >> 1;\n\t\t\tif((i ^ j) & 1) printf(\"%lld \", 1ll * p[s + 1] * p[d + N + (N >> 1) + 1]);\n\t\t\telse printf(\"%lld \", 1ll * p[s + 1] * p[s] * p[d + N + (N >> 1) + 1] * p[d + N + (N >> 1) + 1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 2005;\nconst int M = 1e5 + 50;\n\nint n, pri[M], isnt_pri[M], cnt;\nll a[N], b[N], c[N][N];\n\ninline ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\ninline ll lcm(ll x, ll y) { return (x && y) ? (x / gcd(x, y) * y) : (x | y); }\n\ninline void init()\n{\n\tfor (int i = 2; i < M; ++i)\n\t{\n\t\tif (!isnt_pri[i]) pri[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * pri[j] < M; ++j)\n\t\t{\n\t\t\tisnt_pri[i * pri[j]] = true;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tinit();\n\tif (n == 2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++i) a[i] = pri[i];\n\tfor (int i = 1; i <= n; ++i) b[i] = pri[2 * n - i + 1];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i ^ j) & 1) c[i][j] = a[(i + j) / 2] * b[(i - j + n + 1) / 2];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!((i ^ j) & 1)) c[i][j] = lcm(lcm(c[i - 1][j], c[i][j - 1]), lcm(c[i + 1][j], c[i][j + 1])) + 1;\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) \n\t{\n\t\tassert(c[i][j] > 0 && c[i][j] <= 1e15);\n\t\tprintf(\"%lld%c\", c[i][j], j == n ? '\\n' : ' ');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=510;\nll rec[N][N];\nint n,m;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\nint main(){\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\tll tmp;\n\tscanf(\"%d\",&n);\n\tm=n+1;\n\tfor (int i=1;i<=n;++i) rec[1][i]=m*i+1;\n\tfor (int i=2;i<=n;++i){\n\t\tif (i&1){//decrease\n\t\t\trec[i][1]=rec[i-1][1]+m;\n\t\t\tfor (int j=2;j<=n;++j){\n\t\t\t\ttmp=gcd(rec[i-1][j],rec[i][j-1]);\n\t\t\t\trec[i][j]=rec[i-1][j]/tmp*rec[i][j-1]+m;\n\t\t\t\twhile (rec[i][j]<=rec[i][j-1]) rec[i][j]+=tmp;\n\t\t\t}\n\t\t}\n\t\telse{//increase\n\t\t\trec[i][n]=rec[i-1][n]+m;\n\t\t\tfor (int j=n-1;j>=1;--j){\n\t\t\t\ttmp=gcd(rec[i-1][j],rec[i][j+1]);\n\t\t\t\trec[i][j]=rec[i-1][j]/tmp*rec[i][j+1]+m;\n\t\t\t\twhile (rec[i][j]<=rec[i][j+1]) rec[i][j]+=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%d \",rec[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e6 + 10;\nint N;\nint a[1001][1001], vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= 10000); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> N;\n\tif(N == 2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= N; i++) \n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!((i + j) & 1)) a[i][j] = prime[(i + j) / 2] * prime[N + (i - j) / 2 + (N + 1) / 2];\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!a[i][j]) \n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[610][610],c[610][610],ans[610][610],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n//\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\n__int128 mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( ;i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\n__int128 cmmdc ( __int128 a , __int128 b ){\n\n    while ( b ){\n        __int128 t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\n__int128 calcLCM ( __int128 a , __int128 b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int crLin = 0 ; crLin < noLin ; crLin +=2 ){\n        int i = crLin ;\n        for ( int j = 0 ; j < noLin && i < noLin ; i++ , j++  ){\n            mat [ i ][ j ] = *it ;\n        }\n        it++;\n    }\n\n    for ( int crCol = 2 ; crCol < noLin ; crCol+=2 ){\n        int j = crCol ;\n        for ( int i = 0 ; j < noLin ; i++,j++ ){\n            mat [ i ][ j ] = *it ;\n        }\n        it ++;\n    }\n\n    for ( int crCol = 0 ; crCol < noLin ; crCol+=2 ){\n        int i = crCol ;\n        for ( int j = 0 ; i >= 0 && j < noLin ; i-- , j++  ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it++;\n    }\n\n    for ( int crLin = noLin - 1 ; crLin >= 0 ; crLin-=2 ){\n        int i = crLin ;\n        for ( int j = noLin - 1 ; i < noLin ; i++ ,j-- ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it ++;\n    }\n\n\n\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n\n            __int128  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            cout << mat [ i ][ j ] << \" \" ;\n            \n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nint a[501][501],b[501][501],n,yu=0,prime[1000001],p0=0;\nbool check[1000001];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n==2)\n\t{\n\t\tcout<<4<<' '<<7<<endl<<23<<' '<<10<<endl;\n\t\treturn 0;\n\t}\n\tmemset(check,0,sizeof(check));\n\tmemset(a,1,sizeof(a));\n\tmemset(b,1,sizeof(b));\n\tfor(int i=2;i<=100000;i++)\n\t{\n\t\tif(!check[i]) prime[++p0]=i;\n\t\tfor(int j=1;(j<=p0)&&((prime[j]*i)<=100000);j++)\n\t\t{\n\t\t\tcheck[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=((n%2==0)?2:1);i<=n;i+=2)\n\t{\n\t\tint r=1,c=i;yu++;\n\t\twhile((r>0)&&(r<=n)&&(c>0)&&(c<=n)) \n\t\t{\n\t\t\ta[r][c]=prime[yu];\n\t\t\tr++;c--;\n\t\t}\n\t}\n\tfor(int i=3;i<=n;i+=2)\n\t{\n\t\tint r=i,c=n;yu++;\n\t\twhile((r>0)&&(r<=n)&&(c>0)&&(c<=n)) \n\t\t{\n\t\t\ta[r][c]=prime[yu];\n\t\t\tr++;c--;\n\t\t}\n\t}\n\tfor(int i=((n%2==0)?2:1);i<=n;i+=2)\n\t{\n\t\tint r=1,c=i;yu++;\n\t\twhile((r>0)&&(r<=n)&&(c>0)&&(c<=n)) \n\t\t{\n\t\t\tb[r][c]=prime[yu];\n\t\t\tr++;c++;\n\t\t}\n\t}\n\tfor(int i=n;i>1;i-=2)\n\t{\n\t\tint r=i,c=1;yu++;\n\t\twhile((r>0)&&(r<=n)&&(c>0)&&(c<=n)) \n\t\t{\n\t\t\tb[r][c]=prime[yu];\n\t\t\tr++;c++;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t    for(int j=1;j<=n;j++)\n\t    {\n\t    \tif(n%2==0)\n\t    \t{\n\t    \t\tif((i%2)!=(j%2)) cout<<(1ll*a[i][j]*b[i][j])<<' ';else\n\t\t\t\t{\n\t\t\t\t\tif((i==1)&&(j==1)) \n\t\t    \t\t{\n\t\t\t\t\t\tcout<<(1ll*a[i][j+1]*b[i][j+1]*b[i+1][j]+1)<<' ';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif((i==n)&&(j==n))\n\t\t\t\t\t{\n\t\t\t\t\t    cout<<(1ll*a[i][j-1]*b[i-1][j]*b[i][j-1]+1)<<' ';\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t\tif((i==n)||(i==1))\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<(1ll*a[i][j-1]*a[i][j+1]*b[i][j-1]*b[i][j+1]+1)<<' ';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcout<<(1ll*a[i-1][j]*a[i+1][j]*b[i+1][j]*b[i-1][j]+1)<<' ';\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t    \t\tif((i%2)==(j%2)) cout<<(1ll*a[i][j]*b[i][j])<<' ';else\n\t\t\t\t{\n\t\t\t\t\tif((i==n)||(i==1))\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<(1ll*a[i][j-1]*a[i][j+1]*b[i][j-1]*b[i][j+1]+1)<<' ';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcout<<(1ll*a[i-1][j]*a[i+1][j]*b[i+1][j]*b[i-1][j]+1)<<' ';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 1000) t++;\n    rep(i, n) p.eb(P[t++]);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    vll even, odd;\n    rep(i, 125) {\n        even.eb(i * 2 + 2);\n        even.eb(500 - i * 2);\n        odd.eb(i * 2 + 3);\n        odd.eb(501 - i * 2);\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * even[i / 2] / (i / 2 ? even[i / 2 - 1] : 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * even[i / 2 - 1];\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * odd[i / 2] / (i / 2 ? odd[i / 2 - 1] : 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * odd[i / 2 - 1];\n        }\n    }\n    INT(N);\n    map<ll, pii> s;\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        // rep(j, N) { s[a[i][j]] = {i, j}; }\n        cout << endl;\n    }\n    // cout << (--s.end())->first << endl;\n    // cout << s.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nunsigned long long gcd(unsigned long long a, unsigned long long b){\n    return b ? gcd(b, a % b): a;\n}\n\nunsigned long long lcm(unsigned long long a, unsigned long long b){\n    return a * b / gcd(a, b);\n}\n\nint main(){\n    int N;\n    cin >> N;\n\n    unsigned long long a[500][500];\n\n    for(int j = 0; j < N; j++){\n        a[0][j] = j + 2;\n    }\n\n    for(int i = 1; i < N; i++){\n        if(i % 2 == 0){\n            a[i][0] = a[i - 1][0] + 1;\n            for(int j = 1; j < N; j++){\n                a[i][j] = lcm(a[i][j - 1], a[i - 1][j]) + 1;\n            }\n        } else {\n            a[i][N - 1] = a[i - 1][N - 1] + 1;\n            for(int j = N - 2; j >= 0; j--){\n                a[i][j] = lcm(a[i][j + 1], a[i - 1][j]) + 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[N][N];\nint main(){Accel\n\tcin>>n;m=n;\n\tREP(i,n)\n\t\tREP(j,m)\n\t\t\tif((i+j)&1)p[i][j]=5;\n\t\t\telse p[i][j]=4;\n\tREP(i,n){\n\t\tREP(j,m)\t\n\t\t\tcout<<p[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 505\n#define maxm 4010\n#define inf 1000000007\n#define mod 998244353\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nint prime[100010],primesize;\nbool notprime[100010];\nvoid get_prime()\n{\n    for(int i=2;i<=100000;i++)\n    {\n        if(!notprime[i])   prime[++primesize]=i;\n        for(int j=1;j<=primesize&&i*prime[j]<=100000;j++)\n        {\n            notprime[i*prime[j]]=true;\n            if(i%prime[j]==0)  break;\n        }\n    }\n}\nll ans[maxn][maxn];\nint xx[4]={0,0,1,-1};\nint yy[4]={1,-1,0,0};\nbool check(int x,int y)\n{\n    return (x>=1&&x<=n&&y>=1&&y<=n);\n}\nll gcd(ll x,ll y)\n{\n    if(!y)  return x;\n    return gcd(y,x%y);\n}\nll lcm(ll x,ll y)\n{\n    return x*(y/gcd(x,y));\n}\nint main()\n{\n    get_prime();\n    n=read();\n    int l=1,r=(n<<1)+(!(n&1));\n    for(int i=2;i<=(n<<1);i+=2)\n    {\n        int val;\n        if(i%4==0)  val=prime[l++];\n        else        val=prime[r--];\n        for(int x=1;x<=n;x++)\n        {\n            int y=(i-x);\n            if(y<=0||y>n)  continue;\n            ans[x][y]=val;\n        }\n    }\n    for(int i=-(n-1)/2*2;i<=(n-1)/2*2;i+=2)\n    {\n        int val;\n        if(i%4==0)  val=prime[l++];\n        else        val=prime[r--];\n        for(int x=1;x<=n;x++)\n        {\n            int y=(i+x);\n            if(y<=0||y>n)  continue;\n            ans[x][y]*=val;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if((i+j)&1)\n            {\n                for(int k=0;k<4;k++)\n                {\n                    int tx=i+xx[k],ty=j+yy[k];\n                    if(check(tx,ty))\n                    {\n                        if(!ans[i][j])  ans[i][j]=ans[tx][ty];\n                        else          ans[i][j]=lcm(ans[i][j],ans[tx][ty]);\n                    }\n                }\n                ans[i][j]++;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)  printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// エラトステネスの篩でn以下の素数リスト作成\nvector<int> makePrimeLst(int N)\n{\n    if (N < 2) return vector<int>(0);\n    vector<int> ans{2};\n    vector<int> alive(N+1, 1);\n    for (int i=2; (long long)i*i<=(long long)N; i++)\n    {\n        if (alive[i]) ans.push_back(i);\n        for (int t = i; t<=N; t += i) alive[t] = 0;\n    }\n    for (int i=ans.back()+1; i<=N; i++) if (alive[i]) ans.push_back(i);\n    return ans;\n}\n\n// 素因数分解\nmap<int, int> primeFactorize(int N, vector<int> &primeLst)\n{\n    map<int, int> ans;\n    for (auto v : primeLst)\n    {\n        while (!(N % v))\n        {\n            N /= v;\n            ans[v]++;\n        }\n        if (N == 1) return ans;\n    }\n    exit(1);\n}\n\nint main()\n{\n    vector<int> lst = makePrimeLst(100000);\n    // for (auto v : lst) cout << v << \" \";\n    map<int, int> info = primeFactorize(97124, lst);\n    for (auto v : info) cout << v.first << \" \" << v.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll mp[555][555];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nvector<ll> v;\n\nll gcd(ll a,ll b){\n\tif(a < b)swap(a,b);\n\treturn b == 0 ? a : gcd(b,a%b);\n}\n\nvoid prime(){\n\tvector<bool> pri(100000);\n\tvector<ll> tmp;\n\tint cou = 0;\n\tfor(int i = 2;;i++){\n\t\tif(!pri[i]){\n\t\t\ttmp.PB(i);\n\t\t\tfor(int j = i;j < 100000;j+=i)pri[j] = true;\n\t\t\tcou++;\n\t\t}\n\t\tif(cou == 1010)break;\n\t}\n\tfor(int i = 0,j = tmp.size() - 1;i < j;i++,j--){\n\t\tv.PB(tmp[i]);\n\t\tv.PB(tmp[j]);\n\t}\n}\n\nvoid seica(){\n\tREP(i,555)REP(j,555)mp[i][j] = 1;\n\tREP(i,500){\n\t\tREP(j,500){\n\t\t\tif((i+j) % 2 == 0){\n\t\t\t\tmp[i][j] *= v[(i+j)/2];\n\t\t\t}\n\t\t\tif((i+499-j) % 2 == 1){\n\t\t\t\tmp[i][j] *= v[501+(i+499-j)/2];\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i,500){\n\t\tREP(j,500){\n\t\t\tif((i + j) % 2){\n\t\t\t\tll now = 1;\n\t\t\t\tREP(k,4){\n\t\t\t\t\tif(i+dy[k] >= 0 && i+dy[k] < 500 && j+dx[k] >= 0 && j+dx[k] < 500){\n\t\t\t\t\t\tll hoge = gcd(now, mp[i+dy[k]][j+dx[k]]);\n\t\t\t\t\t\tnow *= mp[i+dy[k]][j+dx[k]] / hoge;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmp[i][j] = now + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;cin >> n;\n\n\tprime();\n\t//cout << v.size() << endl;\n\tseica();\n\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tcout << mp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x << \" = \" << x << endl\n#define fori(i, ini, lim) for(int i = int(ini); i < int(lim); i++)\n#define ford(i, ini, lim) for(int i = int(ini); i >= int(lim); i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\n\nconst int MAX = 1000 + 5;\nll mat[MAX][MAX];\nvector<int> primes;\nint n;\n\nvoid sieve() {\n    for(int i = 2; (int) primes.size() < MAX; i++) {\n        bool is_prime = true;\n        fori(j, 2, i) {\n            if(i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime) {\n            primes.push_back(i);\n        }\n    }\n}\n\nll gcd(ll a, ll b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n    return (a * (b / (gcd(a, b))));\n}\n\nbool construct() {\n    random_shuffle(primes.begin(), primes.end()); \n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            mat[i][j] = 1;\n        }\n    }\n    int k = 0;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == 1) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj <= n; ni++, nj++) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == n) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj >= 1; ni++, nj--) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    const vector<ii> dir {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i + j) % 2 == 0) {\n                ll l = 1;\n                for(auto &each : dir) {\n                    int ni = i + each.first;\n                    int nj = j + each.second;\n                    if(ni >= 1 && ni <= n && nj >= 1 && nj <= n) {\n                        l = lcm(l, mat[ni][nj]);\n                    }\n                }\n                mat[i][j] = l + 1;\n            }\n        }\n    }\n    return true;\n    set<ll> all;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            all.insert(mat[i][j]);\n        }\n    }\n    return (int) all.size() == n * n;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    srand(time(nullptr));\n    cin >> n;\n    if(n == 2) {\n        cout << \"4 7\" << '\\n';\n        cout << \"23 10\" << '\\n';\n        return 0;\n    }\n    sieve();\n    while(!construct());\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if(j > 1) {\n                cout << \" \";\n            }\n            cout << mat[i][j];\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 100000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( ;i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\nlong long cmmdc ( long long a , long long b ){\n\n    while ( b ){\n        long long t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\nlong long calcLCM ( long long a , long long b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n\n\n\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int crLin = 0 ; crLin < noLin ; crLin +=2 ){\n        int i = crLin ;\n        for ( int j = 0 ; j < noLin && i < noLin ; i++ , j++  ){\n            mat [ i ][ j ] = *it ;\n        }\n        it++;\n    }\n\n    for ( int crCol = 2 ; crCol < noLin ; crCol+=2 ){\n        int j = crCol ;\n        for ( int i = 0 ; j < noLin ; i++,j++ ){\n            mat [ i ][ j ] = *it ;\n        }\n        it ++;\n    }\n\n    for ( int crCol = 0 ; crCol < noLin ; crCol+=2 ){\n        int i = crCol ;\n        for ( int j = 0 ; i >= 0 && j < noLin ; i-- , j++  ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it++;\n    }\n\n    for ( int crLin = noLin - 1 ; crLin >= 0 ; crLin-=2 ){\n        int i = crLin ;\n        for ( int j = noLin - 1 ; i < noLin ; i++ ,j-- ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it ++;\n    }\n\n\n\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n\n            long long  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n      //      cout << mat [ i ][ j ] << \" \" ;\n            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nint p[1024];\nbool mrk[8096];\n\nint main() {\n\tint n; scanf(\"%d\",&n);\n\tint *q = p+1 + (n<<1);\n\t*p = *q = 1;\n\tfor (int x = 2, *t = p+1; t < q; x++) {\n\t\tif (!mrk[x]) *t++ = x;\n\t\tfor (int *i = p+1; i < t && x**i < 8096; i++) {\n\t\t\tmrk[x**i] = true;\n\t\t\tif (!(x % *i)) break;\n\t\t}\n\t}\n\tq = p+1 + n + (n>>1);\n\tfor (int x = 0; x < n; x++, putchar(10))\n\t\tfor (int y = 0; y < n; y++) {\n\t\t\tint s = x+y >> 1, d = x-y >> 1;\n\t\t\tif ((x ^ y) & 1) printf(\"%d \", p[s+1] * q[d]);\n\t\t\telse printf(\"%lld \", ll(p[s+1] * p[s]) * ll(q[d] * q[d-1]) + 1);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 101000;\nint g[N],pri[N],tot;\nll f[1010][1010],p1[1010],p2[1010];\nvoid init(){\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!g[i]){pri[++tot]=i;g[i]=i;}\n\t\tfor(int j=1;pri[j]*i<=10000;j++){\n\t\t\tg[pri[j]*i]=pri[j];\n\t\t\tif(pri[j]==g[i]) break; \n\t\t}\n\t}\n\tint k1=0,k2=0;\n\tfor(int i=1;i<=1004;i++)\n\t\tif(i&1) p1[++k1]=pri[i];\n\t\telse p2[++k2]=pri[i];\n\tint p[1010],now=0;\n\tmemcpy(p,p1,sizeof(p));\n\tfor(int i=1;i<=k1;i+=2)\n\t\tp1[k1-now]=p[i],p1[++now]=p[i+1];\n\tmemcpy(p,p2,sizeof(p));now=0;\n\tfor(int i=1;i<=k2;i+=2)\n\t\tp2[k2-now]=p[i],p2[++now]=p[i+1];\n}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i+j&1){\n\t\t\t\tint k=i+j>>1;\n\t\t\t\tf[i][j]=p1[k];\n\t\t\t\tk=i+(n-j+1)>>1;\n\t\t\t\tf[i][j]*=p2[k];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(~(i+j)&1){\n\t\t\t\tf[i][j]=lcm(f[i][j-1],lcm(f[i][j+1],lcm(f[i-1][j],f[i+1][j])))+1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<f[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 4000;\ntypedef long long ll;\ntypedef std::vector<ll> vec;\nvec x[2],a,b;\nint ok[maxn],n;\nint main() {\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tfor(int i = 2,c=0;i < maxn;++i)if(!ok[i]){\n\t\tx[c^=1].push_back(i);\n\t\tfor(int j = i;j < maxn;j += i)ok[j] = 1;\n\t}\n\tfor(int i = 0;i + 1 < x[0].size();++i) a.push_back(x[0][i]),a.push_back(x[0][i] * x[0][i + 1]);\n\tfor(int i = 0;i + 1 < x[1].size();++i) b.push_back(x[1][i]),b.push_back(x[1][i] * x[1][i + 1]);\n\tstd::cin >> n;\n\tfor(int i = 0;i < n;++i) for(int j = 0;j < n;++j)\n\t\tstd::cout << a[i] * b[j] << \" \\n\"[j == n - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nLL A[1010][1010];\nint n,Color[1010][1010];\nint N,P[101010],T1[1010*1010],T2[1010*1010],n1,n2;\nbool f[101010],vis[1010][1010];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvoid Pre(){\n\tfor (int i=2;i<=100000;i++){\n\t\tif (!f[i]) P[++N]=i;\n\t\tfor (int j=i+i;j<=100000;j+=i) f[j]=1;\n\t}\n}\nvoid Dfs(int x,int y,int c){\n\tColor[x][y]=c; vis[x][y]=1;\n\tfor (int k=0;k<4;k++){\n\t\tint x1=x+dx[k],y1=y+dy[k];\n\t\tif (x1>=1&&x1<=n&&y1>=1&&y1<=n&&!vis[x1][y1])\n\t\t\tDfs(x1,y1,1-c);\n\t}\n}\nvoid _Num(){\n\tfor (int i=1;i<=n;i++) for (int j=1;j<=n;j++)\n\t\tif (Color[i][j])\n\t\t\tT1[++n1]=i+j,T2[++n2]=i-j;\n\tsort(T1+1,T1+n1+1); sort(T2+1,T2+n2+1);\n\tn1=unique(T1+1,T1+n1+1)-T1-1;\n\tn2=unique(T2+1,T2+n2+1)-T2-1;\n\t\n\tfor (int i=1;i<=n;i++) for (int j=1;j<=n;j++)\n\t\tif (Color[i][j]){\n\t\t\tint p1=lower_bound(T1+1,T1+n1+1,i+j)-T1;\n\t\t\tint p2=lower_bound(T2+1,T2+n2+1,i-j)-T2;\n\t\t\tA[i][j]=(LL)P[p1]*(LL)P[n1+p2];\n\t\t}\n}\nLL gcd(LL a,LL b){\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nLL Lcm(LL a,LL b){\n\tLL g=gcd(a,b);\n\treturn (a/g)*b;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\"); return 0;\n\t}\n\tPre(); Dfs(1,1,1); _Num();\n\tfor (int i=1;i<=n;i++) for (int j=1;j<=n;j++) if (!Color[i][j]){\n\t\tLL g=1;\n\t\tfor (int k=0;k<4;k++){\n\t\t\tint x1=i+dx[k],y1=j+dy[k];\n\t\t\tif (x1>=1&&x1<=n&&y1>=1&&y1<=n)\n\t\t\t\tg=Lcm(g,A[x1][y1]);\n\t\t}\n\t\tA[i][j]=g+1;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",A[i][j]);\n\t\tprintf(\"\\n\");\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 100000\n#define N 505\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> T lcm(T x, T y) { return x / gcd(x, y) * y; }\n\nint n;\nll a[N][N];\nll p[20005], totp;\nbool nop[MAX];\n\nvoid prework() {\n\tfor (int i = 2; i < MAX; ++i) {\n\t\tif (!nop[i]) p[++totp] = i;\n\t\tfor (int j = 1; j <= totp && p[j] * i < MAX; ++j) {\n\t\t\tnop[i * p[j]] = true;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tif (n == 2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tprework();\n\tfor (int i = 0; i <= n + 1; ++i)\n\t\tfor (int j = 0; j <= n + 1; ++j)\n\t\t\ta[i][j] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i + j) & 1) {\n\t\t\t\ta[i][j] = p[(i + j) >> 1] * p[(n + 1 + i - j) / 2 + n];\n\t\t\t\ta[i + 1][j] = lcm(a[i][j], a[i + 1][j]);\n\t\t\t\ta[i - 1][j] = lcm(a[i][j], a[i - 1][j]);\n\t\t\t\ta[i][j + 1] = lcm(a[i][j], a[i][j + 1]);\n\t\t\t\ta[i][j - 1] = lcm(a[i][j], a[i][j - 1]);\n\t\t\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (!((i + j) & 1)) ++a[i][j];\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e3 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, tot, vis[1000005], pri[1000005], a[N][N];\nvoid init(int n) {\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(vis[i] == 0) pri[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= n; ++ j) {\n\t\t\tvis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nint gcd(int x, int y) {return y == 0 ? x : gcd(y, x % y);}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x * y / gcd(x, y);\n}\nsigned main() {\n\tn = read(); init(1e4);\n\tif(n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = pri[(i + j) / 2] * pri[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i, puts(\"\")) for(int j = 1; j <= n; ++ j) printf(\"%lld \", a[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 15.09.2018 15:11:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long lcm(long long a, long long b) {\n  return a / __gcd(a, b) * b;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int real_n;\n  cin >> real_n;\n  int n = 500;\n  vector<int> primes;\n  int x = 2;\n  while ((int) primes.size() < 2 * n + 5) {\n    int prime = 1;\n    for (int i = 2; i * i <= x; i++) {\n      if (x % i == 0) {\n        prime = 0;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push_back(x);\n    }\n    x++;\n  }\n  vector<vector<long long>> a(n, vector<long long>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 0) {\n        a[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + n + n / 2 + 2];\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) {\n        a[i][j] = 1;\n        if (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n        if (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n        if (i < n - 1) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n        if (j < n - 1) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n        a[i][j]++;\n        assert(a[i][j] <= (long long) 1e15);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n - 1; j++) {\n      assert(max(a[i][j], a[i][j + 1]) % min(a[i][j], a[i][j + 1]) == 1);\n      assert(max(a[j][i], a[j + 1][i]) % min(a[j][i], a[j + 1][i]) == 1);\n    }\n  }\n  set<long long> all;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      all.insert(a[i][j]);\n    }\n  }\n  assert((int) all.size() == n * n);\n  for (int i = 0; i < real_n; i++) {\n    for (int j = 0; j < real_n; j++) {\n      if (j > 0) {\n        cout << \" \";\n      }\n      cout << a[i][j];\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\ninline int read(){char ch=gc;int w=1,s=0;while(!isdigit(ch)){if(ch=='-') w=-1;ch=gc;};while(isdigit(ch)){s=s*10+ch-'0';ch=gc;} return w*s;}\nll ANS[550][550];\nll lcm(ll a,ll b){return a*b/__gcd(a,b);}\nint N,np[101010],prime[100010],cnt;\nint Hang[100010],Lie[100001];\ninline void Init(int n)\n{\n\tnp[1]=1;\n\tfor(rint i=2;i<=n;++i){\n\t\tif(!np[i]) prime[++cnt]=i;\n\t\tfor(rint j=1;j<=cnt&&i*prime[j]<=n;++j){\n\t\t\tnp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}int dx[]={0,1,0,-1,0},dy[]={0,0,1,0,-1};\nint main()\n{\n\tN=read();\n\tInit(100100);\n\tfor(rint i=1;i<=N;++i) Hang[i]=prime[i],Lie[i]=prime[2*N-i+1];\n\tfor(rint i=1;i<=N;++i)\n\t{\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))\n\t\t\tANS[i][j]=1ll*Hang[i]*Lie[j];\n\t\t}\n\t}\n\tfor(rint i=1;i<=N;++i){\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!ANS[i][j])\n\t\t\t{\n\t\t\t\tll res=1;\n\t\t\t\tfor(rint d=1;d<=4;++d)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni<1||nj<1||ni>N||nj>N) continue;\n\t\t\t\t\tres=lcm(ANS[ni][nj],res);\n\t\t\t\t}\n\t\t\t\tANS[i][j]=res+1;\n\t\t\t}\n\t\t\tcout<<ANS[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(ll i= (ll) k;i< (ll) n;i++)\n#define all(v) (v).begin(), (v).end()\n#define SZ(v) (int)((v).size())\n#define pb push_back\n#define ft first\n#define sd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst long long INF = 1e18L + 1;\nconst int IINF = 1e9 + 1;\n\nusing namespace std;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define DBG(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int N = 500;\n\nll mat[N + 2][N + 2];\nint n;\n\nint main()\n{\n#ifndef LOCAL\n\tios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n\tcin >> n;\n\tif(n == 2){\n\t\tcout << 4 << \" \" << 7 << \"\\n\" << 23 << \" \" << 10 << \"\\n\";\n\t\treturn 0;\n\t}\n\tll cnt = 523;\n\trep(i, 0, n + 2){\n\t\trep(j, 0, n + 2){\n\t\t\tmat[i][j] = 1;\n\t\t}\n\t}\n\trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tif((i ^ j) & 1){\n\t\t\t\tmat[i][j] = cnt++;\t\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tif(!((i ^ j) & 1)){\n\t\t\t\tfor(auto x : {mat[i - 1][j], mat[i + 1][j], mat[i][j - 1], mat[i][j + 1]}){\n\t\t\t\t\tmat[i][j] = (mat[i][j] * x) / __gcd(mat[i][j], x);\n\t\t\t\t}\n\t\t\t\tmat[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n  \trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tcout << mat[i][j] << \" \\n\"[j == n];\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  int N;\n  cin >> N;\n\n  long long x[N][N];\n  long long tmp = 2;\n  x[0][0] = tmp;\n  for(int i=1;i<N;i++){\n    tmp++;\n    x[0][i] = tmp;\n  }\n  tmp++;\n  if(tmp % 2 == 0){\n    tmp++;\n  }\n  x[1][0] = tmp;\n  for(int i=2;i<N;i++){\n    tmp++;\n    x[i][0] = tmp;\n  }\n  for(int i=1;i<N;i++){\n    for(int j=1;j<N;j++){\n      // 最大公約数\n      long long a = x[i-1][j];\n      long long b = x[i][j-1];\n      long long r = a % b;\n      while(r > 0){\n        a = b;\n        b = r;\n        r = a % b;\n      }\n      long long lcm = x[i-1][j] * x[i][j-1] / b;\n\n      x[i][j] = lcm + 1;\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      cout << x[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\treturn a * b / gcd(a, b);\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p > MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = primes[(i - j + N + 2)] * primes[i + j + 2 * N + 4];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 501;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=20005;\nint n,i,j,k,p[N],l,w1[N],w2[N];\nbool v[N];\nll a[505][505];\nll gcd(ll a,ll b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nll LCM(ll a,ll b,ll c,ll d)\n{\n\tll rtn=a/gcd(a,b)*b;\n\trtn=rtn/gcd(rtn,c)*c;\n\trtn=rtn/gcd(rtn,d)*d;\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=2;i<=20000;++i)\n\t{\n\t\tif(!v[i])\n\t\t\tp[++l]=i;\n\t\tfor(j=1;j<=l&&p[j]*i<=20000;++j)\n\t\t{\n\t\t\tv[p[j]*i]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tw1[i]=p[i];\n\tfor(i=1;i<=n;++i)\n\t\tw2[i]=p[n+i];\n\trandom_shuffle(w1+1,w1+1+n);\n\trandom_shuffle(w2+1,w2+1+n);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif((i+j)%2==0)\n\t\t\t\ta[i][j]=w1[(i+j)/2]*w2[(i-j+n)/2];\n\tfor(i=0;i<=n+1;++i)\n\t\ta[0][i]=a[n+1][i]=a[i][0]=a[i][n+1]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define MOD 1000000007\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\ntypedef unsigned long long int ull;\ntypedef long long lint;\n\nlint LCM(lint a,lint b){\n  if(a==0 || b==0) return 0;\n  lint tmp,r,x;\n  x=a*b;\n  if(a<b) tmp=a,a=b,b=tmp;\n  r=a%b;\n  while(r!=0) a=b,b=r,r=a%b;\n  x=x/b;\n  return x;\n}\n\nlint GCD(lint a,lint b){\n  if(a==0 || b==0) return max(a,b);\n  else return (a*b)/LCM(a,b);\n}\n\nvector<bool> prime;\nvoid primeinit(int N){\n    if(N+1>prime.size()){\n        prime.resize(N+1,true);\n    } \n    prime[0] = false;\n    prime[1] = false;\n    for(int i=2; i*i<=N;i++) if(prime[i]) for(int j=2; i*j<=N;j++) prime[i*j]=false;\n}\n\n\nint main(void){\n    primeinit(1000000);\n    int N;\n    cin >> N;\n    int put=N;\n    N=500;\n    lint primeno[2000];\n    lint ans[N][N];\n    rep(i,N) rep(j,N) ans[i][j]=1;\n    lint now=0;\n    rep(i,2000){\n        while(!prime[now]) now++;\n        primeno[i]=now;\n        now++;\n    }\n    int no=0;\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n        x=i,y=0;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    for(int i=2;i<N;i++){\n        int x=0,y=i;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n    }\n    for(int i=1;i<N;i++){\n        int x=N-1,y=i;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    rep(i,N) rep(j,N){\n        if(ans[i][j]==1){\n            lint in=1;\n            if(i!=0) in=LCM(in,ans[i-1][j]);\n            if(i!=N-1) in=LCM(in,ans[i+1][j]);\n            if(j!=0) in=LCM(in,ans[i][j-1]);\n            if(j!=N-1) in=LCM(in,ans[i][j+1]);\n            ans[i][j]=in+1;\n        }\n    }\n    rep(i,put){\n        rep(j,put) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 505\nint vl[N*3],n,ct,d[4][2]={-1,0,1,0,0,1,0,-1};\nlong long gcd(long long a,long long b){return b?gcd(b,a%b):a;}\nlong long as[N][N],mx;\nint main()\n{\n\tfor(int i=1001;i<=10000;i++)\n\t{\n\t\tint fg=0;\n\t\tfor(int j=2;j<=100;j++)if(i%j==0)fg=1;\n\t\tif(!fg)vl[++ct]=i;\n\t}\n\tfor(int i=1;i<=500;i++)as[i][i]=vl[1]*i;\n\tint st=2;\n\tfor(int i=2;i<=500;i+=2){for(int j=1;i+j<=500;j++)as[i+j][j]=vl[st]*j,as[j][i+j]=vl[st+1]*j;st+=2;}\n\tfor(int i=1;i<=500;i++)\n\tfor(int j=1;j<=500;j++)\n\tif((i+j)&1)\n\t{\n\t\tlong long st=1;\n\t\tfor(int s=0;s<4;s++)\n\t\t{\n\t\t\tint vl=as[i+d[s][0]][j+d[s][1]];\n\t\t\tif(vl)st=st/gcd(st,vl)*vl;\n\t\t}\n\t\tas[i][j]=st+1;\n\t\tif(mx<st)\n\t\tmx=st;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++,printf(\"\\n\"))\n\tfor(int j=1;j<=n;j++)\n\tprintf(\"%lld \",as[i][j]);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=1005;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=0;i<=n+1;i++)for(ll j=0;j<=n+1;j++)a[i][j]=1;\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\tfor(ll j=1;j<=n;j++)\n\tif((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nconst int maxn=1e7+10;\nll a[505][505];\nint prime[maxn],isprime[maxn],tmp;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvoid init(int n){\n\tREP(i,2,n){\n\t\tif(!isprime[i]) prime[++tmp]=i;\n\t\tREP(j,1,tmp){\n\t\t\tif((ll)i*prime[j]>n) break;\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll lcm(ll x,ll y){\n\treturn (x/__gcd(x,y))*y;\n}\nint main(){\n\tint n=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit(1e7);\n\tint l=1,r=n;\n\tfor(int i=2;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=i-j;\n\t\t\tif(k>=1 && k<=n) a[j][k]=u;\n\t\t}\n\t}\n\tl=n+1,r=n*2;\n\tfor(int i=(n&1)?2:3;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=n+1+j-i;\n\t\t\tif(k>=1 && k<=n) a[j][k]*=u;\n\t\t}\n\t}\n\tREP(i,1,n) REP(j,1,n) if((i+j)&1){\n\t\ta[i][j]=1;\n\t\tREP(k,0,3){\n\t\t\tint u=i+dir[k][0],v=j+dir[k][1];\n\t\t\tif(u>=1 && u<=n && v>=1 && v<=n) a[i][j]=lcm(a[i][j],a[u][v]);\n\t\t}\n\t\ta[i][j]++;\n\t}\n\tREP(i,1,n) REP(j,1,n) printf(\"%lld%c\",a[i][j],j==jend?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn primes[x];\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn primes[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tif (N == 2)\n\t{\n\t\tcout << \"1156 35\\n77 5006\\n\";\n\t\treturn 0;\n\t}\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p > MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = mind(i - j) * plud(i + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nlong long n, x, mod, nr, i, j, a[505][505], d;\nlong long cmmmc(long long a, long long b) {\n    long long x = a, y = b;\n    long long c;\n    while(b) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n    long long rez = a;\n    rez = x * y / a;\n    return rez;\n}\nint main()\n{\n    cin >> n;\n    mod = 2;\n    a[1][1] = 2;\n    for (i = 2; i <= n; i++)\n        a[1][i] = a[1][i - 1] + 1;\n    for (i = 2; i <= n; i++)\n    {\n        if (i % 2 == 1)\n        {\n            a[i][1] = a[i - 1][1];\n            for (j = 2; j <= n; j++)\n            {\n                a[i][j] = cmmmc(a[i][j - 1], a[i - 1][j]) + 1;\n            }\n        }\n        else\n        {\n            a[i][n] = a[i - 1][n] + 2;\n            for(j = n - 1; j >= 1; j--)\n            {\n                a[i][j] = cmmmc(a[i][j + 1], a[i - 1][j]) + 1;\n            }\n        }\n    }\n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n            cout << a[i][j] << \" \";\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld Pi = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nll const MAXN = (ll) 2e4 + 10;\n\n\nint main(){\n\tll n;\n\tcin >> n;\n\tfor(int i = 0;i<n;i++){\n\t\tfor(int j =0;j<n;j++){\n\t\t\tcout << (i+j)*3 + 1 << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\t\n    return 0;\n}\n\n\n\n/*\n\n           _____           ______              ______        _______________           _______________\n          /     \\         |      \\            /      |      /               \\         /               \\\n         /       \\        |       \\          /       |     /                 \\       /                 \\\n        /   ___   \\       |   |\\   \\        /   /|   |    /    ___________    \\     /    ___________    \\\n       /   /   \\   \\      |   | \\   \\      /   / |   |   |    /           \\    |   |    /           \\    |\n      /   /_____\\   \\     |   |  \\   \\    /   /  |   |   |   |            |    |   |   |            |    |\n     /               \\    |   |   \\   \\  /   /   |   |   |    \\___________/    |   |    \\___________/    |\n    /    _________    \\   |   |    \\   \\/   /    |   |    \\                   /     \\                   /\n   /    /         \\    \\  |   |     \\      /     |   |     \\                 /       \\                 /\n  /____/           \\____\\ |___|      \\____/      |___|      \\_______________/         \\_______________/\n\n*/"
  },
  {
    "language": "C++",
    "code": "//problem:\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=505;\nint n,p[MAXN*MAXN],cnt;\nbool v[MAXN*MAXN];\nvoid sieve(int n=500*500){\n\tfor(int i=2;i<=n;++i){\n\t\tif(!v[i])p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;++j){\n\t\t\tv[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll a[MAXN][MAXN];\nll lcm(ll x,ll y){return x/__gcd(x,y)*y;}\nint main() {\n\tn=read();if(n==2)return puts(\"4 7\\n23 10\\n\"),0;\n\tsieve();\n\tint t=0;\n\tfor(int s=2;s<=n+n;s+=2){\n\t\t++t;\n\t\tfor(int i=1;i<=n;++i)if(s-i>=1&&s-i<=n&&(!((i+s-i)&1)))a[i][s-i]=p[t];\n\t}\n\tfor(int d=((n&1)?1-n:2-n);d<=n;d+=2){\n\t\t++t;\n\t\tfor(int i=1;i<=n;++i)if(i-d>=1&&i-d<=n&&(!((i+i-d)&1)))a[i][i-d]*=p[t];\n\t}\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i+j)&1){\n\t\tll l=1;\n\t\tfor(int k=0;k<4;++k){\n\t\t\tint ii=i+dx[k],jj=j+dy[k];\n\t\t\tif(ii<1||ii>n||jj<1||jj>n)continue;\n\t\t\tassert(a[ii][jj]);\n\t\t\tl=lcm(l,a[ii][jj]);\n\t\t}\n\t\ta[i][j]=l+1;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)cout<<a[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 5555555\n#define M 555\nusing namespace std;\n\nint vis[N];\nvector<int> pri;\n\nvoid sieve(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (!vis[i]) pri.push_back(i);\n        for (int j : pri) {\n            if (1ll * i * j > n) break;\n            vis[i * j] = 1;\n            if (i % j == 0) break;\n        }\n    }\n}\n\nlong long a[M][M];\nint n, top, p[2][M << 2];\n\nlong long lcm(long long x, long long y) {\n    return x / __gcd(x, y) * y;\n}\n\nint get(int op, int x) {\n    if (op) x += n;\n    if (!p[op][x]) p[op][x] = pri[top++];\n    return p[op][x];\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    if (n == 1) return cout << 1 << endl, 0;\n\n    if (n == 2) return puts(\"1 4\\n16 2\"), 0;\n\n    sieve(n << 2);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) & 1) a[i][j] = get(0, i + j) * get(1, i - j);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (!((i + j) & 1)) {\n                a[i][j] = 1;\n                if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n                if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n                if (i < n) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n                if (j < n) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n            }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            printf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nlong long a[550][550], c[550][550];\nusing namespace std;\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0; i <= n+2; i++){for(int j = 0; j <= n+2; j++){a[i][j] = c[i][j] = 1;}}\n    \n    vector<int> primes;\n    vector<bool> visited(100000, 0);\n    for(int i = 2; i < 10000; i++){\n        if(!visited[i]){\n            primes.push_back(i);\n            for(int j = i; j < 100000; j+= i){\n                visited[j] = 1;\n            }\n        }\n    }\n    for(int i = 0 ; i <= n; i+=2){\n        a[0][i] = primes.back();\n        primes.pop_back();\n    }\n    for(int i = 0; i <= n; i+=2){\n        a[i][0] = primes.back();\n        primes.pop_back();\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            a[i][j] = a[i-1][j-1];\n        }\n    }\n    \n    for(int i = n+1; i > 0; i-=2){\n        c[0][i] = primes.back();\n        primes.pop_back();\n    }\n    for(int i = n+1; i > 0; i-=2){\n        c[i][n+1] = primes.back();\n        primes.pop_back();\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            c[i][j] = c[i-1][j+1];\n            a[i][j] *= c[i][j];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            if((i+j)%2){\n                a[i][j] *= a[i-1][j] * a[i+1][j];\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=1e5+5;\nint p[N],vis[M];ll a[N][N];\nint n,m;\nvoid init(int n=1e5){\n\tfor(R int i=2;i<=n;++i){\n\t\tif(!vis[i])p[++m]=i;\n\t\tif(m==1000)return;\n\t\tfor(R int j=1;j<=m&&i*p[j]<=n;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\ninline ll lcm(R ll x,R ll y){return x&&y?x/__gcd(x,y)*y:x+y;}\ninline ll calc(R int i,R int j){\n\treturn lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tinit();\n\tscanf(\"%d\",&n);\n\tif(n==2)return puts(\"4 7\\n23 10\\n\"),0;\n\tfp(i,1,n)fp(j,1,n)if((i+j)&1^1)a[i][j]=1ll*p[(i+j)>>1]*p[n+((i-j)>>1)+((n+1)>>1)];\n\tfp(i,1,n)fp(j,1,n)if(!a[i][j])a[i][j]=calc(i,j);\n\tfp(i,1,n)fp(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm> \n#include<set>\ntypedef long long ll;\nconst int N=500,vx[4]={-1,0,0,1},vy[4]={0,-1,1,0};\nint X=14414400;//245044800;\nll a[510][510];\nstd::set<ll>S;\nint d[510],dc,p[510];\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nint main(){\n\tfor(int i=1;dc<500;i++)if(X%i==0)d[dc++]=i;\n\tint pl=0,pr=249;\n\tfor(int i=17,ty=0,cnt=0;cnt<250;i+=2){\n\t\tif(i%2!=0&&i%3!=0&&i%5!=0&&i%7!=0&&i%11!=0&&i%13!=0&&i%17!=0)cnt++%2?p[pr]=i,pr-=2:(p[pl]=i,pl+=2);\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i+j)%2==0)S.insert(a[i][j]=1ll*d[j]*p[i/2]);\n\t\t}\n\t\tll mx=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tll L=1;\n\t\t\t\tfor(int d=0,dx,dy;d<4;d++)if((dx=i+vx[d])>=0&&dx<N&&(dy=j+vy[d])>=0&&dy<N)L=lcm(L,a[dx][dy]);\n\t\t\t\tfor(a[i][j]=L+1;S.find(a[i][j])!=S.end();a[i][j]+=L);\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t\tif(a[i][j]>mx)mx=a[i][j];\n\t\t\t}\n\t\t}\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 3000, M = 100010;\nLL a[N][N], prime[M], tot;\nbool vis[M];\n\nvoid init(int n) {\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (int j = 1; j <= tot && prime[j] * i <= n; ++ j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nLL lcm(LL x, LL y) {\n\tif (!x || !y) return x | y;\n\tLL o = std::__gcd(x, y);\n\treturn x / o * y;\n}\n\nint main() {\n\tinit(M - 1);\n\tint n = read();\n\tif (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i - 1][j - 1]), lcm(a[i + 1][j], a[i + 1][j + 1]));\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 101000;\nint g[N],pri[N],tot;\nll f[1010][1010],p1[1010],p2[1010];\nvoid init(){\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!g[i]){pri[++tot]=i;g[i]=i;}\n\t\tfor(int j=1;pri[j]*i<=10000;j++){\n\t\t\tg[pri[j]*i]=pri[j];\n\t\t\tif(pri[j]==g[i]) break; \n\t\t}\n\t}\n\tint k1=0,k2=0;\n\tfor(int i=1;i<=1004;i++)\n\t\tif(i&1) p1[++k1]=pri[i];\n\t\telse p2[++k2]=pri[i];\n\tint p[1010],now=0;\n\tmemcpy(p,p1,sizeof(p));\n\tfor(int i=1;i<=k1;i+=2)\n\t\tp1[k1-now]=p[i],p1[++now]=p[i+1];\n\tmemcpy(p,p2,sizeof(p));now=0;\n\tfor(int i=1;i<=k2;i+=2)\n\t\tp1[k2-now]=p[i],p1[++now]=p[i+1];\n}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i+j&1){\n\t\t\t\tint k=i+j>>1;\n\t\t\t\tf[i][j]=p1[k];\n\t\t\t\tk=i+(n-j+1)>>1;\n\t\t\t\tf[i][j]*=p2[k];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(~(i+j)&1){\n\t\t\t\tf[i][j]=lcm(f[i][j-1],lcm(f[i][j+1],lcm(f[i-1][j],f[i+1][j])))+1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<f[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat gcd(cat x, cat y) {\n\tif(x > y) swap(x, y);\n\treturn (x == 0) ? y : gcd(y%x, x);\n}\n\ncat lcm(cat x, cat y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< vector<cat> > A(N, vector<cat>(N, 1));\n\tvector<int> P;\n\tfor(int p = 3; ; p++) {\n\t\tbool is_prime = true;\n\t\tfor(int i = 2; i*i <= p; i++) is_prime &= (p%i != 0);\n\t\tif(!is_prime) continue;\n\t\tP.push_back(p);\n\t\tif((int)P.size() == N+10) break;\n\t}\n\tfor(int i = 0; i < N; i += 2) for(int j = 0; j < N; j += 2) A[i][j] = P[i/2] * P[N/2+1+j/2];\n\tfor(int i = 1; i < N; i += 2) for(int j = 1; j < N; j += 2) A[i][j] = 2 * A[i-1][j-1];\n\tfor(int i = 0; i < N; i++) for(int j = 1-(i&1); j < N; j += 2) {\n\t\tif(i > 0) A[i][j] = lcm(A[i][j], A[i-1][j]);\n\t\tif(j > 0) A[i][j] = lcm(A[i][j], A[i][j-1]);\n\t\tif(i+1 < N) A[i][j] = lcm(A[i][j], A[i+1][j]);\n\t\tif(j+1 < N) A[i][j] = lcm(A[i][j], A[i][j+1]);\n\t\tA[i][j]++;\n\t}\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N; j++) cout << A[i][j] << ((j == N-1) ? \"\\n\" : \" \");\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=505,M=100005,x[4]={1,-1,0,0},y[4]={0,0,1,-1};\nll ans[N][N],tot;\nint n,p[M],vis[M],q[M];\n#define ld long double\nll lcm(ll x,ll y){\n\tif(x==0)return y; if(y==0)return x;//cout<<x<<\" \"<<y<<endl;\n\t//if((ld)x/__gcd(x,y)*y>(1e15))while(1);\n\treturn x/__gcd(x,y)*y;\n}\nsigned main(){\n\tn=500;\n\tfor(int i=2;i<M;i++)if(!vis[i]){\n\t\tq[++tot]=i; for(int j=i;j<M;j+=i)vis[j]=1;\n\t}\n\tfor(int i=1;i<=1000;i++)if(i&1)p[i]=q[(i+1)/2]; else p[i]=q[1001-i/2];\n\tint tx=248,ty=249;\n\tfor(int i=1;i<=n*2;i+=2){\n\t\tif(i<=n){tx+=2; ty+=1;} else {tx++; if(i!=n+1)ty--;}\n\t\tint x=i<=n?1:i-n+1,y=i<=n?n-i+1:1;\n\t\tint t=min(n-x+1,n-y+1); \n\t\tfor(int j=0;j<t;j++){\n\t\t\tans[x+j][y+j]=p[tx]*p[ty-j]; //if(x+j==500)cout<<y+j<<\" \"<<tx<<\" \"<<ty-j<<endl;\n\t\t\t//if(abs(x+j-2)+abs(y+j-2)==1)cout<<tx<<\" \"<<ty-j<<endl;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if((i+j)%2==0){\n\t//cout<<i<<\" \"<<j<<endl;\n\t\tfor(int k=0;k<4;k++)ans[i][j]=lcm(ans[i][j],ans[i+x[k]][j+y[k]]);\n\t\tans[i][j]++;\n\t}\n\t//set<ll> s;\n\t//for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){ s.insert(ans[i][j]);}\n\t//cout<<s.size()<<endl;\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\twrite(ans[i][j]); putchar(' ');\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n/*\n\n \n*/"
  },
  {
    "language": "C++",
    "code": "//const int N = 5e5+5;\n//bool prime[N];\n//ll gcd(ll x, ll y){\n//    if(y == 0)\n//        return x;\n//    return gcd(y,x%y);\n//}\n//void alternate(vi &arr){\n//    vi ans;\n//    for(int i = 0; i < 250; ++i){\n//        ans.pb(arr[i]);\n//        ans.pb(arr[499-i]);\n//    }\n//    arr = ans;\n//}\n//void _(){\n//    fill(prime+2,prime+N,true);\n//    vector<int> primes;\n//    for(int i = 2; i < N; ++i)\n//        if(prime[i]){\n//            for(int j = 2*i; j < N; j += i)\n//                prime[j] = false;\n//            primes.push_back(i);\n//        }\n//    primes.resize(1000);\n//    vi p1;\n//    vi p2;\n//    for(int i = 0; i < 1000; ++i)\n//        if(i%2) \n//            p1.pb(primes[i]);\n//        else\n//            p2.pb(primes[i]);\n//    alternate(p1);\n//    alternate(p2);\n//    //print(p1);\n//    //print(p2);\n//    int n;\n//    cin >> n;\n//    vector<ll> arr;\n//    vvl grid(n,vl(n));\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 == j % 2){\n//                int d1 = (i+j)/2;\n//                int d2 = (i-j+n-1)/2;\n//                ll a = p1[d1];\n//                ll b = p2[d2];\n//                grid[i][j] = a*b;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 != j % 2){\n//                vl neigh;\n//                if(i > 0) neigh.pb(grid[i-1][j]);\n//                if(i+1 < n) neigh.pb(grid[i+1][j]);\n//                if(j > 0) neigh.pb(grid[i][j-1]);\n//                if(j+1 < n) neigh.pb(grid[i][j+1]);\n//                ll ans = 1;\n//                for(ll x : neigh){\n//                    ans = ans*(x/gcd(ans,x));\n//                }\n//                grid[i][j] = ans;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            arr.push_back(grid[i][j]);\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            cout << grid[i][j]  << \" \\n\"[j==n-1];\n//    sort(all(arr));\n//    arr.erase(unique(all(arr)),arr.end());\n//    //assert(arr.size() == n*n);\n//    //cout << n*n << ' ' << arr.size() << '\\n';\n//}\n//\n// ================================================ \n// ^^^\tABOVE is what I wrote in my editor\t^^^\n// ------------------------------------------------ \n// vvv\tBELOW is automatically generated \tvvv\n// ================================================ \n#include <numeric>\n#include <set>\n#include <iomanip>\n#include <algorithm> \n#include <cassert>\n#include <vector>\n#include <iostream>\n#define pb push_back \n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<int> vi;\ntemplate<typename IT>\nostream &print(IT b, IT e, string sep = \" \", ostream &stream = cout){\n\tfor(IT it = b; it != e; ++it){\n\t\tstream << *it;\n\t\tif(it+1 != e) stream << sep;\n\t} \n\treturn stream;\n}\ntemplate<typename IT> istream &read(IT b, IT e, istream &stream = cin){\n\tfor(IT it = b; it != e; ++it) stream >> *it; return stream;\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &&t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> istream &operator>>(istream &stream, vector<T> &t){\n\treturn read(all(t),stream);\n}\ntemplate <typename T> \nvoid print(T x){\n\tcout << x << '\\n';\n}\ntemplate <typename t> \nvoid print(vector<t> arr,string sep=\" \"){\n    if(arr.empty())\n        return;\n\tprint(arr.begin(),arr.end(),sep);\n\tcout << '\\n';\n}\ntemplate <typename T> \nvoid print(vector<vector<T> > arr){\n\tfor(int i = 0; i < arr.size(); ++i){\n\t\tcout << \"[\" << arr[i] << \"]\";\n\t\tif(i+1 < arr.size())\n\t\t\tcout << \", \";\n\t}\n\tcout << '\\n';\n}\ntemplate<typename T>\nT _();\nconst ll INF = ll(2e18)+666;\nconst ll MOD = 1e9+7;\ntemplate<typename T>\nvector<T> operator+(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(lhs);\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] += rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator+=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs+rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nvector<T> operator-(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(all(lhs));\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] -= rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator-=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs-rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nT max(const vector<T> arr){\n\tassert(!arr.empty());\n\tT ans = arr[0];\n\tfor(auto &cur : arr)\n\t\tans = max(ans,cur);\n\treturn ans;\n}\ntemplate<typename T>\nT max(const set<T> s){\n\tassert(!s.empty());\n\treturn *--s.end();\n}\ntemplate<typename T, typename G>\nvector<T> set_max(vector<T> &base, const vector<G> &comp){\n\tassert(base.size() == comp.size());\n\tfor(int i = 0; i < (int)comp.size(); ++i)\n\t\tbase[i] = max(base[i],comp[i]);\n\treturn base;\n}\ntemplate <typename T>\nvector<T> unique(vector<T> &arr){\n    sort(all(arr));\n\tarr.erase(unique(all(arr)),arr.end());\n\treturn arr;\n}\nconst int N = 5e5+5;\nbool prime[N];\nll gcd(ll x, ll y){\n    if(y == 0)\n        return x;\n    return gcd(y,x%y);\n}\nvoid alternate(vi &arr){\n    vi ans;\n    for(int i = 0; i < 250; ++i){\n        ans.pb(arr[i]);\n        ans.pb(arr[499-i]);\n    }\n    arr = ans;\n}\nvoid _(){\n    fill(prime+2,prime+N,true);\n    vector<int> primes;\n    for(int i = 2; i < N; ++i)\n        if(prime[i]){\n            for(int j = 2*i; j < N; j += i)\n                prime[j] = false;\n            primes.push_back(i);\n        }\n    primes.resize(1000);\n    vi p1;\n    vi p2;\n    for(int i = 0; i < 1000; ++i)\n        if(i%2) \n            p1.pb(primes[i]);\n        else\n            p2.pb(primes[i]);\n    alternate(p1);\n    alternate(p2);\n    //print(p1);\n    //print(p2);\n    int n;\n    cin >> n;\n    vector<ll> arr;\n    vvl grid(n,vl(n));\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 == j % 2){\n                int d1 = (i+j)/2;\n                int d2 = (i-j+n-1)/2;\n                ll a = p1[d1];\n                ll b = p2[d2];\n                grid[i][j] = a*b;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 != j % 2){\n                vl neigh;\n                if(i > 0) neigh.pb(grid[i-1][j]);\n                if(i+1 < n) neigh.pb(grid[i+1][j]);\n                if(j > 0) neigh.pb(grid[i][j-1]);\n                if(j+1 < n) neigh.pb(grid[i][j+1]);\n                ll ans = 1;\n                for(ll x : neigh){\n                    ans = ans*(x/gcd(ans,x));\n                }\n                grid[i][j] = ans;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            arr.push_back(grid[i][j]);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            cout << grid[i][j]  << \" \\n\"[j==n-1];\n    sort(all(arr));\n    arr.erase(unique(all(arr)),arr.end());\n    //assert(arr.size() == n*n);\n    //cout << n*n << ' ' << arr.size() << '\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(12);\n\t_();\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 2 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = (ml * ans[i][j - 1]) / gcd(ml, ans[i][j - 1]);\n\t\t\t\tif (i < n - 1) ml = (ml * ans[i + 1][j]) / gcd(ml, ans[i + 1][j]);\n\t\t\t\tif (j < n - 1) ml = (ml * ans[i][j + 1]) / gcd(ml, ans[i][j + 1]);\n\n\t\t\t\tll k = 1, k2 = 1, k3 = 1, k4 = 1;\n\t\t\t\tif (j > 0 && i > 0) k = gcd(ans[i][j - 1], ans[i - 1][j]);\n\t\t\t\tif (i > 0 && j < n - 1) k2 = gcd(ans[i - 1][j], ans[i][j + 1]);\n\t\t\t\tif (j < n - 1 && i < n - 1) k3 = gcd(ans[i][j + 1], ans[i + 1][j]);\n\t\t\t\tif (j > 0 && i < n - 1) k4 = gcd(ans[i + 1][j], ans[i][j - 1]);\n\t\t\t\t\n\t\t\t\tml = (k * k2 * k3 * k4);\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nlong long ans[501][501];\nlong long prime[1001];\nvoid initprime() {\n\tint pn=0;\n\tlong long base=2;\n\tfor (int i=0; i<1000;) {\n\t\tauto isprime = [&](long long a) {\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tif (a%prime[k] == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\t\t// cout<<i<<\" \"<<base<<endl;\n\t\tif (isprime(base))\n\t\t\tprime[i++] = base++;\n\t\telse\n\t\t\tbase++;\n\t}\n}\nint main() {\n\tinitprime();\n\tint tn; cin>>tn;\n\tint n=500;\n\t// diagonal from (0,0) to (n-1,n-1);\n\tauto idxA = [&] (int x, int y) -> int { return x<y?(y-x-1):(x-y); };\n\t// diagonal from (0,n-1) to (n-1,0);\n\tauto idxB = [&] (int x, int y) -> int { return 300 + ( (x+y<n)?(x+y):((n-(x+y)/2)*2-1) ); };\n\n\tauto isVaild = [&](int x, int y) {\n\t\tif (x<0 || x>=n || y<0 || y>=n)\n\t\t\treturn false;\n\t\treturn true;\n\t};\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=i%2; j<n; j+=2)\n\t\t\tans[i][j] = prime[idxA(i,j)]*prime[idxB(i,j)];\n\t\tfor (int j=(i+1)%2; j<n; j+=2) {\n\t\t\tans[i][j] = 1;\n\t\t\tif (isVaild(i,j+1) || isVaild(i+1,j)) // if ((i+j+1)/2 < n)\n\t\t\t\tans[i][j] *= prime[idxB(i,j+1)];\n\t\t\tif (isVaild(i-1,j) || isVaild(i,j-1)) // if (0 <= (i+j-1)/2)\n\t\t\t\tans[i][j] *= prime[idxB(i,j-1)];\n\t\t\tif (isVaild(i-1,j) || isVaild(i,j+1)) // if (-n+1 < x-y)\n\t\t\t\tans[i][j] *= prime[idxA(i-1,j)];\n\t\t\tif (isVaild(i,j-1) || isVaild(i+1,j)) // if (x-y < n-1)\n\t\t\t\tans[i][j] *= prime[idxA(i+1,j)];\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tlong long tmax=0;\n\tunordered_map<long long, pair<int,int> > hit;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<n; j++) {\n\t\t\ttmax = max(tmax, ans[i][j]);\n\t\t\tif (hit.find(ans[i][j]) != hit.end()) {\n\t\t\t\tcout<<\">>hit \"<<i<<\",\"<<j<<\" == \"<<ans[i][j]<<endl;\n\t\t\t\tcout<<\"\\t Collide : \"<<hit[ans[i][j]].first<<\", \"<<hit[ans[i][j]].second<<endl;\n\t\t\t\t// return 0;\n\t\t\t}else\n\t\t\t\thit[ans[i][j]] = make_pair(i,j);\n\t\t}\n\t// cout<<tmax<<endl;\n\tn=tn;\n\tfor (int i=0; i<n; i++, cout<<endl)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tcout<<ans[i][j]<<\"\\t\";\n\t// cout<<\"debug \"<<ans[258][147]<<\" \"<<ans[72][397]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=5e2+5;\nconst int L=3e7;\nint n,pr[L+1], npr[L+1];\nLL a[N][N],b[N][N];\nmap <LL,bool> S;\ninline bool is_pr(int t) {\n\tfor(int i=2;(LL)i*i<=t;++i) if(!(t%i)) return false;\n\treturn true;\n}\ninline int nxt_prime() {\n\tstatic int hd=2;\n\twhile(!is_pr(hd)) ++hd;\n\treturn hd++;\n}\ninline LL lcm(LL x,LL y) {\n\treturn (!x || !y) ? (x+y) : (x*y/__gcd(x,y));\n}\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) \n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==((n+1)&1)) {\n\t\t\t\tif(i==1 || j==1) a[i][j]=nxt_prime();\n\t\t\t\telse a[i][j]=a[i-1][j-1];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=n;j>=1;j--)\n\t\t\tif(((i+j)&1)==((n+1)&1)) {\n\t\t\t\tif(i==1 || j==n) b[i][j]=nxt_prime();\n\t\t\t\telse b[i][j]=b[i-1][j+1];\n\t\t\t\ta[i][j]*=b[i][j];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) if(!a[i][j]) {\n\t\t\tLL v=lcm(lcm(lcm(a[i-1][j],a[i+1][j]),a[i][j-1]),a[i][j+1]);\n\t\t\tLL nowval=v;\n\t\t\twhile(S[nowval]) nowval+=v;\n\t\t\ta[i][j]=nowval+1;  S[nowval]=1;\n\t\t}\n\tfor(int i=1;i<=n;cout<<'\\n',i++)\n\t\tfor(int j=1;j<=n;cout<<a[i][j++]<<' ');\n} "
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nnamespace shai {\n\tconst int n = 1e6 + 7;\n\tint p[n], v[n], phi[n], miu[n];\n\n\tinline void init(int n) {\n\t\tv[1] = phi[1] = miu[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tif (!v[i]) p[++p[0]] = v[i] = i, phi[i] = i - 1, miu[i] = -1;\n\t\t\tfor (int j = 1; j <= p[0] && i * p[j] <= n && p[j] <= v[i]; j++)\n\t\t\t\tv[i*p[j]] = p[j],\n\t\t\t\tphi[i*p[j]] = phi[i] * (p[j] - 1 + (p[j] == v[i])),\n\t\t\t\tmiu[i*p[j]] = p[j] == v[i] ? 0 : -miu[i];\n\t\t}\n\t}\n}\nusing shai::p;\n\nconst int N = 507;\nint n, a[N], b[N];\n\nint main() {\n\tshai::init(1e4);\n\trd(n);\n\tfor (int i = 1; i <= n; i++) a[i] = p[i&1?i/2+1:n*2-i/2+1];\n\tfor (int i = 1; i <= n; i++) b[i] = p[(i&1?n-i/2:n+i/2)+(n&1)];\n\ta[0] = a[n+1] = b[0] = b[n+1] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tprint((i ^ j) & 1 ? 1ll * a[(i+j)/2] * a[(i+j)/2+1] * b[(n+i-j+(n&1))/2] * b[(n+i-j+(n&1))/2+1] + 1 : 1ll * a[(i+j)/2] * b[(n+i-j+(n&1))/2], \" \\n\"[j==n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n\treturn y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n\tif( x == 0 ) return y;\n\telse if( y == 0 ) return x;\n\telse return x / GCD(x, y) * y;\n}\nvoid sieve() {\n\tfor(int i=2;i<=MAXM;i++) {\n\t\tif( !vis[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;i*prm[j]<=MAXM;j++) {\n\t\t\tvis[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n\tsieve(); int N;\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) == (j & 1) )\n\t\t\t\tMat[i][j] = prm[(i + j) / 2] * prm[(i - j)/2 + (N-1)/2 + N + 1];\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) != (j & 1) )\n\t\t\t\tMat[i][j] = LCM(Mat[i-1][j], LCM(Mat[i+1][j], LCM(Mat[i][j-1], Mat[i][j+1]))) + 1;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<N;j++)\n\t\t\tprintf(\"%lld \", Mat[i][j]);\n\t\tprintf(\"%lld\\n\", Mat[i][N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n//\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int M=500,N=8000;\nll num[M+5][M+5],prm[N+5];\nbool avoid[N+5];\nint n;\nvoid Prepare_Prime(){\n\tfor(int i=2;i<=N;i++){\n\t\tif(!avoid[i]) prm[++prm[0]]=i;\n\t\tfor(int j=1;j<=prm[0];j++){\n\t\t\tif(i*prm[j]>N) break;\n\t\t\tavoid[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\nll GCD(ll a,ll b){return b? GCD(b,a%b):a;}\nll LCM(ll a,ll b){return a/GCD(a,b)*b;}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tPrepare_Prime();\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tnum[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\tnum[i][j]=prm[(i+j)/2]*prm[1000-(i-j)/2-(n+1)/2+1];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2)\n\t\t\t\tnum[i][j]=LCM(LCM(num[i-1][j],num[i][j-1]),LCM(num[i+1][j],num[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<n;j++)\n\t\t\tprintf(\"%lld \",num[i][j]);\n\t\tprintf(\"%lld\\n\",num[i][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n//#include <cassert>\nusing namespace std;\n\nconst int N = 10000;\ntypedef long long ll;\n\nint prime[N] , tot;\nvoid Init() {\n//\tvis[0] = vis[1] = true;\n\tstatic bool vis[N];\n\tfor(int i = 2 ; i < N ; ++i) {\n\t\tif(!vis[i]) prime[tot++] = i;\n\t\tfor(int j = 0 ; j < tot && prime[j] * i < N ; ++j) {\n\t\t\tvis[prime[j] * i] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n ;\nll ans[505][505];\n\ntemplate<typename T> T __lcm(T x , T y) {return x / __gcd(x , y) * y ;}\nbool valid(int x , int y) {return x > 0 && y > 0 && x <= n && y <= n;}\n\nint main() {\n\tfreopen(\"atcoder.txt\" , \"w\" , stdout);\n\tInit();\n\tcin >> n;\n\tif(n == 2) {\n\t\tputs(\"2 3\");\n\t\tputs(\"5 4\");\n\t\treturn 0;\n\t}\n\tint l = 0 , r = 2 * n - 1 - ((n ^ 1) & 1), cur = 0;\n\t\n\tfor(int lim = (n & 1) ? (n - 1) : (n - 2) , d = -lim ; d <= lim ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , 1 + d) ; i <= min(n , n + d) ; ++i)\n\t\t\tans[i][i - d] = cur ? prime[l] : prime[r];\t\n\tfor(int d = 2 ; d <= 2 * n ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , d - n) ; i <= min(n , d - 1) ; ++i)\n\t\t\tans[i][d - i] *= cur ? prime[l] : prime[r];\n\t\n//\tassert(l == r + 1);\n//\tll max_val = 0;\n\tfor(int i = 1 ; i <= n ; ++i , putchar('\\n'))\n\t\tfor(int j = 1 ; j <= n ; ++j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tif(valid(i - 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i - 1][j]);\n\t\t\t\tif(valid(i + 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i + 1][j]);\t\n\t\t\t\tif(valid(i , j - 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j - 1]);\n\t\t\t\tif(valid(i , j + 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j + 1]);\n\t\t\t\tans[i][j]++;\t\n\t\t\t}\n\t\t\tprintf(\"%lld \" , ans[i][j]);\n//\t\t\tmax_val = max(max_val , ans[i][j]);\n\t\t}\n//\tfprintf(stderr , \"max_val = %lld\\n\" , max_val);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n2\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=505;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll g[maxn][maxn];\n\nvector<int> a,b;\n\nll lcm(ll a,ll b){\n\tif(a==0||b==0) return a+b;\n\treturn a*b/__gcd(a,b);\n}\nbool isp[300000]={0};\nvector<int> p;\n\nint main()\n{\n\tIOS;\n\n\n\tfor(int i=2;i<300000;i++){\n\t\tif(!isp[i]) p.pb(i);\n\t\tfor(int j=0;i*p[j]<300000;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tREP(i,500) a.pb(p[i]);\n\tREP(i,500) b.pb(p[i+500]);\n\n\tREP(i,500) REP(j,500) if((i+j)%2==0){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j)/2];\n\t\tg[i][j]*=b[(i-j+499)/2];\n\t}\n\n\tREP(i,500) REP(j,500) if((i+j)%2){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j-1)/2];\n\t\tg[i][j]*=a[(i+j+1)/2];\n\t\tif(i-j+499+1<1000)g[i][j]*=b[(i-j+499+1)/2];\n\t\tif(i-j+499-1>=0) g[i][j]*=b[(i-j+499-1)/2];\n\t\tg[i][j]++;\n\t\t//assert(g[i][j]<1e15);\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<g[i][j]<<\" \\n\"[j==n-1];\n\n\tREP(i,n) REP(j,n-1) assert(max(g[i][j],g[i][j+1])%min(g[i][j],g[i][j+1])==1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nint m,rm;\nbool np[10001];\nint pr[1011],pn;\nint arr[1011],an;\nint a2[1011],a2n;\nll a[511][511];\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\nint main()\n{\n\tfor(int i=2;i<=6000;i++)\n\t{\n\t\tif(!np[i])pr[pn++]=i;\n\t\tfor(int j=i+i;j<=6000;j+=i)np[j]=1;\n\t}\n\tint it=0;\n\twhile(pr[it]<=500)it++;\n\tfor(int i=0;i<=255;i++)arr[an++]=pr[it+i];\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i<n-i+1)a2[++a2n]=i,a2[++a2n]=n-i+1;\n\t\telse if(i==n-i+1)a2[++a2n]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((i+j-1)&1)\n\t\t\t{\n\t\t\t\ta[i][j]=1ll*a2[i]*arr[(j-1)/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tfor(int d=0;d<4;d++)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni>=1&&ni<=n&&nj>=1&&nj<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i][j]==0)a[i][j]=a[ni][nj];\n\t\t\t\t\t\telse a[i][j]=a[i][j]/__gcd(a[i][j],a[ni][nj])*a[ni][nj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i][j]>5e14)cerr<<i<<\",\"<<j<<\" \"<<a[i][j]<<endl;\n\t\t\t\tassert(a[i][j]<=5e14);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tputi(a[i][j]<<1|((i+j)&1));\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nint N;\nint p[MAXN], pn;\nbool np[MAXN];\n\ninline void init(int n) {\n\tregister int i, j;\n\tnp[1] = 1; p[0] = p[n] = 1;\n\tfor(i = 2; i <= n; ++i) {\n\t\tif(!np[i])\n\t\t\tp[++pn] = i;\n\t\tfor(j = 1; j <= pn && i * p[j] <= n; ++j) {\n\t\t\tnp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tregister int i, j; init(1e4);\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; ++i) {\n\t\tfor(j = 0; j < N; ++j) {\n\t\t\tint s = (i + j) >> 1, d = (i - j) >> 1;\n\t\t\tif((i ^ j) & 1) printf(\"%lld \", 1ll * p[s + 1] * p[d + N + (N >> 1) + 1]);\n\t\t\telse printf(\"%lld \", 1ll * p[s + 1] * p[s] * p[d + N + (N >> 1) + 1] * p[d + N + (N >> 1)] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 100000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( ;i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\nlong long cmmdc ( long long a , long long b ){\n\n    while ( b ){\n        long long t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\nlong long calcLCM ( long long a , long long b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n\n\n\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int crLin = 0 ; crLin < noLin ; crLin +=2 ){\n        int i = crLin ;\n        for ( int j = 0 ; j < noLin && i < noLin ; i++ , j++  ){\n            mat [ i ][ j ] = *it ;\n        }\n        it++;\n    }\n\n    for ( int crCol = 2 ; crCol < noLin ; crCol+=2 ){\n        int j = crCol ;\n        for ( int i = 0 ; j < noLin ; i++,j++ ){\n            mat [ i ][ j ] = *it ;\n        }\n        it ++;\n    }\n    for ( int crLin = 0 ; crLin < noLin ; crLin +=2 ){\n        int i = crLin ;\n        for ( int j = 0 ; j < noLin && i < noLin ; i++ , j--  ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it++;\n    }\n\n    for ( int crCol = 2 ; crCol < noLin ; crCol+=2 ){\n        int j = crCol ;\n        for ( int i = 0 ; j < noLin ; i++ ,j-- ){\n            mat [ i ][ j ] *= *it ;\n        }\n        it ++;\n    }\n\n\n\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n\n            long long  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n      //      cout << mat [ i ][ j ] << \" \" ;\n            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <cmath>\n\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nmap <ll, bool> hsh;\n\nll X[555][555];\n\nbool vis[55555555];\n\nint gcd(int a, int b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n    return a / gcd(a, b) * b;\n}\n\nbool v[5555555];\n\nint Pr[5555555], cnt = 0;\n\nsigned main() {\n    int n;\n    scanf(\"%lld\", &n);\n    for(int i = 2; i < 555555; i++) {\n        if(!v[i]) {\n            Pr[++cnt] = i;\n            for(int j = 1; i * j < 555555; j++) v[i * j] = 1;\n        }\n    }\n    for(int i = 0; i <= n + 1; i++)\n        for(int j = 0; j <= n + 1; j++)\n            X[i][j] = 1;\n    int c = 0;\n    for(int i = 1; i <= n; i += 2) {\n        int s = Pr[++c];\n        for(int j = 1; i + j - 1 <= n; j++) {\n            X[j][i + j - 1] *= s;\n        }\n    }\n    for(int j = 3; j <= n; j += 2) {\n        int s = Pr[++c];\n        for(int i = 1; i + j - 1 <= n; i++) {\n            X[i + j - 1][i] *= s;\n        }\n    }\n    for(int i = 2; i <= n + n; i += 2) {\n        int s = Pr[++c];\n        for(int j = 1; j <= n; j++) if(i - j <= n && i - j > 0) {\n            X[j][i - j] *= s;\n        }\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            if((i + j) % 2) {\n                X[i][j] = lcm(lcm(X[i + 1][j], X[i][j + 1]), lcm(X[i - 1][j], X[i][j - 1]));\n                for(int k = 1; ; k++) if(!hsh[X[i][j] * k]) {\n                    X[i][j] *= k;\n                    hsh[X[i][j]] = 1;\n                    X[i][j]++;\n                    break;\n                }\n            }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            printf(\"%lld \", X[i][j]);\n            if(X[i][j] > 1e15) {\n                puts(\"----------------\");\n                printf(\"%lld %lld\\n\", i, j);\n                exit(0);\n            }\n        }\n        putchar('\\n');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 504;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,pri[10010],tot=0;\nbool nopri[10010];\nll ans[510][510];\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;}\n\nvoid sieve(int n)\n{\n    rep(i,2,n)\n    {\n        if (!nopri[i]) pri[++tot]=i;\n        for (int j=1;j<=tot && i*pri[j]<=n;j++)\n        {\n            nopri[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\n\nint main()\n{\n    sieve(10000);\n    n=read();\n    if (n==2)\n    {\n        puts(\"4 7\\n23 10\");return 0;\n    }\n    //rep(i,1,20) cout << pri[i] << \" \";cout << endl;\n    rep(i,0,n+1) ans[0][i]=ans[n+1][i]=ans[i][0]=ans[i][n+1]=1;\n    int now=0;\n    rep(i,1,n)\n    {\n        int st;\n        if (i&1) st=1;else st=2;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=pri[(i+j)>>1]*pri[(i-j+n+1)/2+n];\n        }\n    }\n    rep(i,1,n) \n    {\n        int st;\n        if (i&1) st=2;else st=1;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]))+1;\n        }\n    }\n    rep(i,1,n)\n    {\n        rep(j,1,n) printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nll gcd(ll a,ll b){\n    if(a%b==0){return b;}\n    return gcd(b,a%b);\n}\n\nll lcm(vector<ll> &A){\n    ll ret=1;\n    for(int i=0;i<A.size();i++){\n        ret/=gcd(ret,A[i]);\n        ret*=A[i];\n    }\n    return ret;\n}\n\n\n\n\nint main(){\n    ll mx=100000;\n    vector<bool> A(mx,1);\n    vector<ll> P;\n    for(ll i=2;i<mx;i++){\n        if(A[i]){\n            for(ll t=1;i*t<mx;t*=i){\n                P.push_back(i*t);\n            }\n            for(ll t=2;i*t<mx;t++){\n                A[i*t]=0;\n            }\n        }\n    }\n    sort(P.begin(),P.end());\n    vector<vector<ll>> a(500,vector<ll>(500,1));\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if((i+t)&1){\n                a[i][t]*=P[(i+t)/2];\n            }\n            if((i-t)&1){\n                a[i][t]*=P[(750+i-t)/2];\n            }\n        }\n    }\n    vector<ll> dx={0,1,0,-1};\n    vector<ll> dy={1,0,-1,0};\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if(a[i][t]==1){\n                vector<ll> A;\n                for(int h=0;h<4;h++){\n                    ll x=i+dx[h];\n                    ll y=t+dy[h];\n                    if(x<0 || y<0 || x>=500 || y>=500){continue;}\n                    A.push_back(a[x][y]);\n                }\n                a[i][t]=lcm(A)+1;\n            }\n        }\n    }\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<a[i][t];\n            if(t+1!=n){cout<<\" \";}\n        }\n        cout<<endl;\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 2999; \nconst long long INF = 0x3f3f3f3f; \n\nint cnt, idx, n; \nlong long ans[550][550], prime[Maxv], max = -INF; \nlong long x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \nbool notPrime[Maxv]; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void Sieve() {\n    for (int i = 2; i <= Maxv; i++) {\n        if (!notPrime[i]) {\n            prime[++cnt] = i; \n        }\n\n        for (int j = 1; j <= cnt && i * prime[j] <= Maxv; j++) {\n            long long num = i * prime[j]; \n            notPrime[num] = true; \n\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    Sieve(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", prime[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = prime[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= prime[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>//\tTはintかll\nT gcd(T a, T b) {//\t最大公約数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tif (a < b) {\n\t\treturn gcd(a, b % a);\n\t}\n\treturn gcd(b, a % b);\n}\ntemplate <typename T>//\tTはintかll\nT gcd(int size, T* a) {//\t配列の最大公約数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tT c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = gcd(c, a[i]);\n\t\tif (c == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate <typename T>//\tTはintかll\nll lcm(T a, T b) {//\t最小公倍数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tll x = a;\n\tx /= gcd(a, b);\n\tx *= b;\n\treturn x;\n}\ntemplate <typename T>//\tTはintかll\nll lcm(int size, T* a) {//\t配列の最小公倍数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tll c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = lcm(c, (ll)a[i]);\n\t}\n\treturn c;\n}\n\nbool f[20000] = {};\n\nint main() {\n\tf[0] = false;\n\tf[1] = false;\n\tf[2] = true;\n\tfor (int i = 3; i < 20000; i++) {\n\t\tf[i] = (i % 2 == 1);\n\t}\n\tfor (int i = 3; i < 20000; i++) {\n\t\tif (f[i] == false) { continue; }\n\t\tfor (int j = i * 2; j < 20000; j += i) {\n\t\t\tf[j] = false;\n\t\t}\n\t}\n\tvector<ll> v;\n\tfor (int i = 0; i < 20000; i++) {\n\t\tif (f[i] == true) {\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\n\tint N = 500;\n\tll** ans = new ll * [N];\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = new ll[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tans[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = v[i + j] * v[i - j + N + 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tll c = 1;\n\t\t\t\tif (i > 0) { c = lcm(c, ans[i - 1][j]); }\n\t\t\t\tif (j > 0) { c = lcm(c, ans[i][j - 1]); }\n\t\t\t\tif (i < N - 1) { c = lcm(c, ans[i + 1][j]); }\n\t\t\t\tif (j < N - 1) { c = lcm(c, ans[i][j + 1]); }\n\t\t\t\tans[i][j] += c;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) FOR(i,0,n)\n#define ROF(i,a,b) for(ll i=a;i>=b;i--)\n#define per(i,a) ROF(i,a,0)\n#define pb push_back\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ch=char;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vP;\ntypedef vector<ch> vc;\ntypedef vector<vc> vvc;\nconst ll MOD=1000000007;\nconst ll MOD2=998244353;\nconst ld PI=acos(-1);\nconst ll INF=1e18;\nstruct edge{ll to,cost;};\nstruct edge2{ll from,to,cost;};\n\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N;\n    cin >> N;\n    int MXN=500;\n    ll ans[MXN][MXN];\n    vector<bool> is_prime(10000,true);\n    is_prime[0]=is_prime[1]=false;\n    vl p;\n    FOR(i,2,10000){\n        if(is_prime[i]){\n            if(i>=500){\n                p.pb(i);\n            }\n            ll j=2*i;\n            while(j<10000){\n                is_prime[j]=false;\n                j+=i;\n            }\n        }\n    }\n    rep(i,MXN){\n        rep(j,MXN){\n            if(i%2==j%2){\n                ans[i][j]=p[i]*(j+1);\n            }\n            else{\n                ans[i][j]=1;\n            }\n        }\n    }\n    rep(i,MXN){\n        rep(j,MXN){\n            if((i+j)%2==1){\n                if(i!=0)ans[i][j]=lcm(ans[i][j],ans[i-1][j]);\n                if(j!=0)ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n                if(i!=MXN-1)ans[i][j]=lcm(ans[i][j],ans[i+1][j]);\n                if(j!=MXN-1)ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n                ans[i][j]++;\n            }\n        }\n    }\n    rep(i,N){\n        rep(j,N){\n            cout << ans[i][j] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define foreach(c,it) for (__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\nusing namespace std;\nint n,i,j,p[100005],pc,np[100005],a[515][515];\nint main(){\n\tfor(i=2;i<=100000;i++){\n\t\tif(!np[i]){p[++pc]=i;}\n\t\trep(j,pc){if(i*p[j]>100000) break;\n\t\t\tnp[i*p[j]]=1;if(i%p[j]==0) break;\n\t\t}\n\t}\n\tcin>>n;;\n\trep(i,n+2)rep(j,n+2)if(!((i+j)&1)){\n\t\tint t1=(i+j)/2,t2=(i-j+n+2)/2+n+2;\n\t\ta[i][j]=p[t1]*p[t2];\n\t}\n\trep(i,n+2)rep(j,n+2)if((i+j)&1){\n\t\ta[i][j]=a[i][j-1]*a[i][j+1]+1;\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcout<<a[i+1][j+1]<<' ';\n\t\t}cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 510;\nint n;\n\nll ans[N][N];\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\n\tll cur=2;\n\tfor(int i=0; i<=n; i+=2) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\tcur++;\n\t\t}\n\t}\n\n\tfor(int i=1; i<n; i+=2) {\n\t\tfor(int j=0; j<=n; j+=2) {\n\t\t\tans[i][j] = ans[i-1][j]*ans[i+1][j]+1;\n\t\t}\n\n\t\tfor(int j=1; j<n; j+=2) {\n\t\t\tans[i][j] = ans[i-1][j]*ans[i+1][j]*ans[i][j-1]*ans[i][j+1] +1;\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=0; j<n; j++) printf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 203050\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],n,b[505][505],mx,c,o,r;\nint p[maxn];\nvector<ll> h[maxn];\nbool vis[maxn];\nll lcm(ll x,ll y){\n    return x/__gcd(x,y)*y;\n}\nmap<ll,int> f;\n\nint main(){\n    cin >> n;\n    //for (int i=0;i<n*n/2;i++) a[c++]=i+1;\n    //for (int i=0;i<c;i++)cout<<a[i]<<' ';cout<<endl;\n    //random_shuffle(a,a+c);\n    o=1;\n    for (int i=1;i<=n;i+=4)\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n            o+=2;\n        }\n    int pos=3; while (pos+4<=n) pos+=4;\n    for (int i=pos;i>0;i-=4){\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o; o+=2;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n        }\n    }\n\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) if ((i+j)%2==1){\n            r=1;\n            if (i>1) r=lcm(r,b[i-1][j]);\n            if (i<n) r=lcm(r,b[i+1][j]);\n            if (j>1) r=lcm(r,b[i][j-1]);\n            if (j<n) r=lcm(r,b[i][j+1]);\n            long long s=1;\n            while (f[r*s]) s++;\n            b[i][j]=r*s+1; f[r*s]=1;\n        }\n\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)cout<<b[i][j]<<' ';cout<<endl;\n    }\n\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) mx=max(mx,b[i][j]);\n    //cout<<mx<<endl;\n    assert(mx<=1000000000000000ll);\n    //cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair < int, int > PII;\ntypedef pair < LL, LL > PLL;\ntypedef pair < LD, LD > PDD;\n\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntemplate < typename _T > inline void _DBG(const char *s, _T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate < typename _T, typename... args > void _DBG(const char *s, _T x, args... a) { while(*s != ',') cerr << *s++; cerr << \" = \" << x << ','; _DBG(s + 1, a...); }\n\n#ifdef LOCAL\n#define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0) cout\n#endif\n\n// ********************** CODE ********************** //\n\nconst int N = 500;\n\nLL pri[] = {1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901};\n\nLL T[N][N];\nunordered_set < LL > S;\n\nLL nwd(LL a, LL b)\n{\n    if(b == 0) return a;\n    return nwd(b, a % b);\n}\n\nLL nww(LL a, LL b)\n{\n    return a / nwd(a, b) * b;\n}\n\nint main()\n{\n    _upgrade\n    srand(time(NULL) + getpid()); \n    // random_shuffle(pri, pri + 1000);\n    int l = 0, r = 505; \n    for(int i = 0; i <= 2 * N; i += 2)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if(0 <= k && k < N)\n            {\n                T[j][k] = pri[((i / 2) & 1 ? r : l)];\n            }\n        }\n        if(i & 1)\n            l++;\n        else\n            r--;\n    }\n    LL st = 251;\n    for (int i = 0; i <= 2 * N; i += 2)\n    {\n        LL p = st;\n        for (int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if (0 <= k && k < N)\n            {\n                T[j][k] *= p;\n                if(p > 1300)\n                {\n                    DBG(j, k);\n                }\n                S.insert(T[j][k]);\n                p++;\n            }\n        }\n        if(i + 1 < N)\n            st--;\n        else\n            st++;\n    }\n    LL lim = 1e15;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(T[i][j] != 0) continue;\n            vector < LL > v;\n            if(i > 0)\n                v.push_back(T[i - 1][j]);\n            if(j > 0)\n                v.push_back(T[i][j - 1]);\n            if(i + 1 < N)\n                v.push_back(T[i + 1][j]);\n            if(j + 1 < N)\n                v.push_back(T[i][j + 1]);\n            LL can = 0;\n            if(sz(v) == 1)\n            {\n                can = v[0];\n            }\n            else if(sz(v) == 2)\n            {\n                can = nww(v[0], v[1]);\n            }\n            else if(sz(v) == 3)\n            {\n                can = nww(v[0], nww(v[1], v[2]));\n            }\n            else\n            {\n                can = nww(v[0], nww(v[1], nww(v[2], v[3])));\n            }\n            //DBG(can, sz(v));\n            LL cp = can;\n            while(can + 1 <= lim && S.find(can + 1) != S.end())\n            {\n                //DBG(can + 1);\n                can += cp;\n            }\n            //DBG(i, j, T[i][j]);\n            if(can + 1 > lim)\n            {\n                DBG(i, j, can + 1);\n                //for (auto u : v)\n                //    DBG(u);\n                //cout << \"KUPA\\n\";\n                return 0;\n            }\n            S.insert(can + 1);\n            T[i][j] = can + 1;\n        }\n    }\n    DBG(\"ok\");\n    /*\n    cout << \"{ \";\n    for(int i = 0; i < N; i++)\n    {\n        cout << \"{ \";\n        for(int j = 0; j < N; j++)\n        {\n            cout << T[i][j] << (j + 1 < N ? \", \" : \"\");\n        }\n        cout << \" }\" << (i + 1 < N ? \", \" : \"\");\n    }\n    cout << \" }\";\n    */\n    int n; cin >> n;\n    for(int  i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\ntypedef  long long ll;\nint gcd(int f , int s){if(s==0)return f;else return gcd(s,f%s);}\nint const N = 1000006;\nll const M = 998244353;\nlong double const ep = .000000000000000001;\nll arr[521][512];\nint main() {\n\t\n\tint n;\n\tcin >> n;\n\tint counter = 2 ;\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 0)arr[i][j]=counter++;\n\t\t}\n\t}\t\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 1){\n\t\t\t\tll num = 1 , g = -1;\n\t\t\t\tif(i != 0){\n\t\t\t\t\tg = arr[i-1][j];\n\t\t\t\t\tnum = arr[i-1][j];\n\t\t\t\t}\n\t\t\t\tif(i != n-1){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i+1][j]);\n\t\t\t\t\telse g = arr[i+1][j];\n\t\t\t\t\tnum *= arr[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(j != 0){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i][j-1]);\n\t\t\t\t\telse g = arr[i][j-1];\n\t\t\t\t\tnum *= arr[i][j-1];\n\t\t\t\t}\n\t\t\t\tif(j != n-1){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i][j+1]);\n\t\t\t\t\telse g = arr[i][j+1];\n\t\t\t\t\tnum *= arr[i][j+1];\n\t\t\t\t}\n\t\t\t\tarr[i][j] = num / g;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tcout << arr[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[514][514];\nint b[514][514];\nint ans[514][514];\nvector<int> p;\nsigned main(){\n\tic(n)\n\trep(2,i,3572)if(prime(i))p.pb(i);\n\trep(0,i,501)rep(0,j,501){\n\t\tif((i+j)%2==0){\n\t\t\ta[i][j]=p[(i+j)/2];\n\t\t\tb[i][j]=p[(i+500-j)/2];\n\t\t\tans[i][j]=a[i][j]*b[i][j];\n\t\t}\n\t}\n\trep(0,i,501)rep(0,j,501){\n\t\tif((i+j)%2==1){\n\t\t\tif(i==0||i==500){\n\t\t\t\tans[i][j]=a[i][j-1]*b[i][j-1]*a[i][j+1]*b[i][j+1]+1;\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tans[i][j]=a[i-1][j]*b[i-1][j]*a[i+1][j]*b[i+1][j]+1;\n\t\t\t}\t\n\t\t}\n\t}\n\trep(0,i,n){\n\t\trep(0,j,n)cout<<ans[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\nconst int INF = 1e9 ;\nconst int maxN = 1010; \nconst int MOD = 1e9 + 7;\nint tot,n;\nint prime[maxN]; //记录质数\nint b[maxN * 10]; //标记i 是否为质数 \nll a[maxN][maxN];\nvoid check()\n{\n\tfor(int i=2;i< maxN*10;i++)\n\t{\n\t\tif(b[i] == 0)\n\t\t{\n\t\t\tprime[++tot] = i;\n\t\t\tfor(int j=2;i*j<maxN * 10;j++)\n\t\t\t{\n\t\t\t\tb[i*j] = 1;\t\n\t\t\t}\t\n\t\t}\t\n\t} \n} \nvector<pii> l[maxN];\nll lc[maxN];\nint lcnt;\nvector<pii> r[maxN];\nll rc[maxN]; \nint rcnt;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tcheck();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(i,1)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = 1+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int j=2;j<=n;j++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(n,j)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tlcnt = cnt;\n\tcnt = 0;\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint k=1;\n\t\tr[++cnt].push_back(pii(n,j));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint k = 1;\n\t\tr[++cnt].push_back(pii(i,n));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = n-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\t\n\t\t} \n\t}\n\trcnt = cnt;\n\tcnt = 0;\n\tfor(int i=1;i<=lcnt;i+=2)\n\t{\n\t\tlc[i] = prime[++cnt]; \n\t}\n\tfor(int j=2;j<=lcnt;j+=2)\n\t{\n\t\tlc[j] = lc[j-1]*lc[j+1];\n\t}\n\tif(n%2 == 1)\n\t{\n\t\tfor(int i=1;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\tfor(int j=2;j<=rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\t\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\trc[1] = rc[2];\n\t\trc[rcnt] = rc[rcnt-1];\n\t\tfor(int j=3;j<rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][j] = 1ll; \n\t} \n\tfor(int i=1;i<=lcnt;i++)\n\t{\n\t\tfor(int j=0;j<l[i].size();j++)\n\t\t{\n\t\t\tint tx = l[i][j].first;\n\t\t\tint ty = l[i][j].second;\n\t\t\ta[tx][ty] *= lc[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=rcnt;i++)\n\t{\n\t\tfor(int j=0;j<r[i].size();j++)\n\t\t{\n\t\t\tint tx = r[i][j].first;\n\t\t\tint ty = r[i][j].second;\n\t\t\ta[tx][ty] *= rc[i];\n\t\t\tif((tx+ty)%2==1)\n\t\t\t\ta[tx][ty] += 1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j<n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=502;\nint n,ar[N][N],lis[1006],dx[]={0,0,-1,1},dy[]={-1,1,0,0},ar1[N][N];\nbool check(int x,int y){\n  if(x>0&&x<=n){\n    if(y>0&&y<=n){\n      return true;\n    }\n  }\n  return false;\n}\nbool check1(int x){\n    int i;\n    for(i=2;i*i<=x;i++){\n     if(x%i==0){\n         return false;\n     }\n    }\n    return true;\n}\nint LCM(int x,int y){\n  return (x/__gcd(x,y)) * y;\n}\nsigned main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int i,j,k,l,num=0,hichic=0;\n  cin>>n;\n  if(n==2){\n    cout<<\"4 7\\n23 10\";\n    return 0;\n  }\n  for(i=2;i<=10000;i++){\n    //cout<<i<<endl;\n        if(check1(i)){\n        num++;\n         lis[num]=i;\n      //cout<<num<<' '<<i<<endl;\n          if(num==1002){\n        //cout<<num<<' '<<\"cac\"<<endl;\n                break;\n            }\n        }\n    }\n    //cout<<num<<endl;\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n        if(!((i+j)&1)){\n          continue;\n        }\n        if(i-1&&j-1){\n          ar[i][j]=ar[i-1][j-1];\n        }\n        else{\n          hichic++;\n          ar[i][j]=lis[hichic];\n        }\n      }\n    }\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n        if(!((i+j)&1)){\n          continue;\n        }\n        if(i-1&&j+1<=n){\n    \t\tar1[i][j]=ar1[i-1][j+1];\n          \tar[i][j]*=ar1[i][j];\n        }\n        else{\n          hichic++;\n          ar[i][j]*=lis[hichic];\n          ar1[i][j]=lis[hichic];\n        }\n      }\n    }\n    //cout<<\"cac\"<<endl;\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n        if(!((i+j)&1)){\n          ar[i][j]=1;\n          for(l=0;l<4;l++){\n            if(check(i+dx[l],j+dy[l])){\n              ar[i][j]=LCM(ar[i][j],ar[i+dx[l]][j+dy[l]]);\n            }\n          }\n          cout<<ar[i][j]+1<<' ';\n        }\n        else{\n            cout<<ar[i][j]<<' ';\n        }\n      }\n      cout<<'\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 505\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,num;\nvector<ll> v;\nll mat[MAXN][MAXN];\nint prime[10005],now;\nbool is_prime[10005];\nint sieve(int n)\n{\n    int p=0;\n    memset(is_prime,true,sizeof(is_prime));\n    is_prime[0]=is_prime[1]=false;\n    for(int i=2;i<=n;i++)\n    {\n        if(is_prime[i]) prime[p++]=i;\n        for(int j=0;j<p;j++)\n        {\n            if(prime[j]*i>n) break;\n            is_prime[prime[j]*i]=false;\n            if(i%prime[j]==0) break;\n        }\n    }\n    return p;\n}\nll lcm(ll a,ll b)\n{\n    return a/__gcd(a,b)*b; \n}\nvoid fill_diag_left(int x,int y)\n{\n    while(x<=n&&y<=n)\n    {\n        mat[x][y]*=prime[now];\n        x++;y++;\n    }\n    now++;\n}\nvoid fill_diag_right(int x,int y)\n{\n    while(x<=n&&y>=1)\n    {\n        mat[x][y]*=prime[now];\n        x++;y--;\n    }\n    now++;\n}\nvoid fill()\n{\n    for(ll i=1;i<=n;i++)\n        for(ll j=2-(i&1);j<=n;j+=2)\n            mat[i][j]=1;\n    now=0;\n    for(int i=1;i<=n;i+=2) fill_diag_left(1,i);\n    for(int i=3;i<=n;i+=2) fill_diag_left(i,1);\n    for(int i=1;i<=n;i+=2) fill_diag_right(1,i);\n    for(int i=n;i>=2;i-=2) fill_diag_right(i,n);\n}\nbool check()\n{\n    for(ll i=1;i<=n;i++)\n    {\n        for(ll j=1;j<=n;j++)\n        {\n            if(!mat[i][j])\n            {\n                ll g=1;\n                if(i>1) g=lcm(g,mat[i-1][j]);\n                if(j>1) g=lcm(g,mat[i][j-1]);\n                if(i<n) g=lcm(g,mat[i+1][j]);\n                if(j<n) g=lcm(g,mat[i][j+1]);\n                mat[i][j]=g;\n            }\n        }\n    }\n    return true;\n}\nvoid print()\n{\n    for(ll i=1;i<=n;i++)\n    {\n        for(ll j=1;j<=n;j++)\n            printf(\"%lld \",mat[i][j]);\n        puts(\"\");\n    }\n}\nint main()\n{\n    sieve(10000);\n    scanf(\"%lld\",&n);\n    if(n==2)\n    {\n        puts(\"4 7\\n23 10\");\n        return 0;\n    }\n    fill();\n    assert(check());\n    print();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nbool Isprime[233333];\nll prime[233333];\nvoid init(int T){\n\tmem(Isprime,true);*prime = 0;\n\tfor(int i=2;i<=T;i++){\n\t\tif(Isprime[i]){\n\t\t\tprime[++*prime] = i;\n\t\t}\n\t\tfor(int j=1;j<=*prime && i * prime[j] <= T;++j){\n\t\t\tIsprime[i*prime[j]] = false;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nll mp1[233333],mp2[233333];\nmap<ll,ll> mp3;\nll ans[505][505],n;\nint main(){\n\tinit(8000);\n\tn = rd();\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tmp3.clear();\n\tll wzp = 0;\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp1[i+j]) mp1[i+j] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp2[i-j+n]) mp2[i-j+n] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n){\n\t\tif((i+j)&1){\n\t\t\tans[i][j] = (ll)mp1[i+j]*mp2[i-j+n];\n\t\t\twhile(mp3[ans[i][j]]) ans[i][j]+=(ll)mp1[i+j]*mp2[i-j+n];\n\t\t\tmp3[ans[i][j]]++;\n\t\t}\n\t}\n//\tll mx = 0;\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tll tmp = 1;\n\t\tif(1<=i-1) tmp = tmp * ans[i-1][j] / __gcd(tmp,ans[i-1][j]);\n\t\tif(1<=j-1) tmp = tmp * ans[i][j-1] / __gcd(tmp,ans[i][j-1]);\n\t\tif(i+1<=n) tmp = tmp * ans[i+1][j] / __gcd(tmp,ans[i+1][j]);\n\t\tif(j+1<=n) tmp = tmp * ans[i][j+1] / __gcd(tmp,ans[i][j+1]);\n\t\tans[i][j] = tmp+1;\n\t\twhile(mp3[ans[i][j]]) ans[i][j]+=tmp;\n\t\tmp3[ans[i][j]]++;\n//\t\tmx = max(mx,ans[i][j]);\n\t}\n//\twriteln(mx-1e15);\n\tRep(i,1,n){\n\t\tRep(j,1,n)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e4,maxm=6e2;\nint n,cnt=0,cur=0,prime[maxn];\nlong long Mat[maxm][maxm];\nbool vis[maxn];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!vis[i]){prime[++cnt]=i;}\n\t\tfor(int j=1;j<=cnt;j++){\n\t\t\tif(prime[j]*i>10000) continue;\n\t\t\tvis[prime[j]*i]=true;\n\t\t\tif(i%prime[j]==0) continue;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tMat[i][j]=1;\n\t\t}\n\t}\n\tcur++;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i%2==0) cur++;\n\t\tlong long ss=(i%2==0)?(prime[cur]*prime[cur-1]):prime[cur];\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tMat[i][j]*=ss;\n\t\t}\n\t}\n\tcur++;\n\tfor(int j=1;j<=n;j++){\n\t\tif(j%2==0) cur++;\n\t\tlong long ss=(j%2==0)?(prime[cur]*prime[cur-1]):prime[cur];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tMat[i][j]*=ss;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",Mat[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1005;\nint a[N][N],flag[N*10],P[N*10],tot,n; \nint check1(int x,int y){\n\treturn (x+y)/2;\n}\nint check2(int x,int y){\n\treturn (x-y+n+1)/2;\n}\nint Lcm(int x,int y){\n\tif (!x||!y)return x+y;\n\treturn x/__gcd(x,y)*y;\n} \nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])for (int j=2*i;j<=10000;j+=i)flag[j]=1;\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])P[++tot]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1)a[i][j]=P[check1(i,j)]*P[check2(i,j)+n+1];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=Lcm(Lcm(a[i+1][j],a[i-1][j]),Lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 2 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = (ml * ans[i][j - 1]) / gcd(ml, ans[i][j - 1]);\n\t\t\t\tif (i < n - 1) ml = (ml * ans[i + 1][j]) / gcd(ml, ans[i + 1][j]);\n\t\t\t\tif (j < n - 1) ml = (ml * ans[i][j + 1]) / gcd(ml, ans[i][j + 1]);\n\n\t\t\t\t\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 10010;\n\ninline ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint tot;\nint pri[MAXN];\nint chk[MAXN];\nll a[1010][1010];\n\ninline void Sieve(int n) {\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nunordered_map<int, int>id1, id2, cnt;\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tSieve(10000);\n\tint n = ri + 1, N = 0;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\ta[i][j] = 1;\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) {\n\t\t\t\tif(!id1[i + j]) id1[i + j] = ++N;\n\t\t\t\tif(!id2[i - j]) id2[i - j] = ++N;\n\t\t\t\ta[i][j] = pri[id1[i + j]] * pri[id2[i - j]];\n\t\t\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) printf(\"%lld \", a[i][j]);\n\t\t\telse {\n\t\t\t\tll x = lcm(lcm(a[i + 1][j], a[i - 1][j]), lcm(a[i][j + 1], a[i][j - 1]));\n\t\t\t\t++cnt[x];\n\t\t\t\tprintf(\"%lld \", x * cnt[x] + 1);\n\t\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// AT027D: Modular Matrix\n\nint main(){\n    int n; cin >> n;\n    int N = 500;\n    int M = 100*N;\n\n    bool prime[M];\n    for(int i = 1; i < M; i++) prime[i] = true;\n    for(int i = 2; i < M; i++) if(prime[i])\n        for(int j = i + i; j < M; j += i) \n            prime[j] = false;\n\n    vector<int> p;\n    for(int i = 2; i < M; i++) if(prime[i]) p.push_back(i);\n\n\n    vector<long long> a(N+1);\n    for(int i = 0; i <= N; i += 4) a[i] = p[i/4];       \n    for(int i = 2; i <= N; i += 4) a[i] = p[N/2-i/4];\n    for(int i = 1; i < N; i += 2) a[i] = a[i-1] * a[i+1];\n\n    for(int i = 0; i < n; i++) {\n    \tfor(int j = 0; j < n; j++) cout << a[n-1-i] * a[j] * a[j] << \" \";\n    \tcout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL gcd(LL a,LL b){\n\treturn b?gcd(b,a%b):a;\n}\nLL lcm(LL a,LL b){\n\tLL g=gcd(a,b);\n\treturn a/g*b;\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;P.PB(0);\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=7919;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t\t//cout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int M=500,N=8000;\nll num[M+5][M+5],prm[N+5];\nbool avoid[N+5];\nint n;\nvoid Prepare_Prime(){\n\tfor(int i=2;i<=N;i++){\n\t\tif(!avoid[i]) prm[++prm[0]]=i;\n\t\tfor(int j=1;j<=prm[0];j++){\n\t\t\tif(i*prm[j]>N) break;\n\t\t\tavoid[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\nll GCD(ll a,ll b){return b? GCD(b,a%b):a;}\nll LCM(ll a,ll b){return a/GCD(a,b)*b;}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tPrepare_Prime();\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tnum[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\tnum[i][j]=prm[(i+j)/2]*prm[1000-(i-j)/2-(n+1)/2+1];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2)\n\t\t\t\tnum[i][j]=LCM(LCM(num[i-1][j],num[i][j-1]),LCM(num[i+1][j],num[i][j+1]));\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<n;j++)\n\t\t\tprintf(\"%lld \",num[i][j]);\n\t\tprintf(\"%lld\\n\",num[i][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint N;\nint A[550][550];\ndeque<int> prime;\nunordered_map<int, int> mpA, mpB;\nunordered_map<int, bool> ex;\nsigned main() {\n    cin >> N\n    for (int i = 2; i <= 1100; i++) {\n        prime.push_back(i);\nnene:;\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        if (i % 2 == 0) {mpA[2 * i] = prime.front(); prime.pop_front();}\n        else {mpA[2 * i] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 10; i++) {\n        if (i % 2 == 0) {mpB[2 * i - (N + 4) - N % 2] = prime.front(); prime.pop_front();}\n        else {mpB[2 * i - (N + 4) - N % 2] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n            A[i][j] = mpA[i + j] * mpB[i - j];\n            ex[A[i][j]] = true;\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if ((i + j) % 2 == 0) {cout << A[i][j] << \" \"; continue;}\n            int cur = 1;\n            for (int k = 0; k < 4; k++) {\n                cur = cur / gcd(cur, A[i + dy[k]][j + dx[k]]) * A[i + dy[k]][j + dx[k]];\n            }\n            int c = 1;\n            while (ex[cur * c + 1])c++;\n            cout << cur * c + 1 << \" \";\n            ex[cur * c + 1] = true;\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nconst int N=1000010;\nint p[N],pnum;\nbool b[N];\nlong long lcm(long long x,long long y){\n\tif (!(x&&y)) return x^y;\n\treturn (__int128)x*y/__gcd(x,y);\n}\nconst int P=510;\nint a[P][P],c[P][P];\nlong long re[P][P];\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tfor (int i=2; pnum<2000; ++i){\n\t\tif (!b[i]) p[pnum++]=i;\n\t\tfor (int j=0; j<pnum&&i*p[j]<=1000000; ++j){\n\t\t\tb[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\n\tint d=0;\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; ++j)\n\t\t\tif ((i+j)&1) a[i][j]=p[(i+j)/2];\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t  for (int j=1; j<=n; ++j) printf(\"%d \",a[i][j]);*/\n\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif ((i+j)&1) c[i][j]=p[(i-j+n)/2+600];\n\n\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t  for (int j=1; j<=n; ++j) printf(\"%d \",c[i][j]);*/\n\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tre[i][j]=a[i][j]*c[i][j];\n\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t  for (int j=1; j<=n; ++j) printf(\"%lld \",re[i][j]);*/\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tre[i][j]=lcm(re[i-1][j],lcm(re[i][j-1],lcm(re[i][j+1],re[i+1][j])))+C;\n\t\t}\n\tif (re[1][1]==re[2][2]) re[2][2]+=re[1][1]-1;\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%lld \",re[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>//\tTはintかll\nT gcd(T a, T b) {//\t最大公約数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tif (a < b) {\n\t\treturn gcd(a, b % a);\n\t}\n\treturn gcd(b, a % b);\n}\ntemplate <typename T>//\tTはintかll\nT gcd(int size, T* a) {//\t配列の最大公約数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tT c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = gcd(c, a[i]);\n\t\tif (c == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate <typename T>//\tTはintかll\nll lcm(T a, T b) {//\t最小公倍数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tll x = a;\n\tx /= gcd(a, b);\n\tx *= b;\n\treturn x;\n}\ntemplate <typename T>//\tTはintかll\nll lcm(int size, T* a) {//\t配列の最小公倍数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tll c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = lcm(c, (ll)a[i]);\n\t}\n\treturn c;\n}\n\nll l_sqrt(ll n) {\n\tif (n <= 0) { return 0; }\n\n\tif (n > 256) {\n\t\tll k = l_sqrt(n / 4) * 2;\n\t\twhile ((k + 1) * (k + 1) <= n) { k++; }\n\t\treturn k;\n\t}\n\telse {\n\t\tfor (int i = 16; i >= 1; i--) {\n\t\t\tif (i * i <= n) { return i; }\n\t\t}\n\t}\n\treturn 0;\n}\nclass primeFactorClass {// 素因数分解をする\npublic:\n\tprimeFactorClass() {\n\t\tfactorNum = 0;\n\t}\n\t~primeFactorClass() {\n\t\treset();\n\t}\n\n\tint factorNum;// 素因数の個数\n\tvector<ll> prime;// 素因数\n\tvector<int> degree;// 次数\n\n\tvoid factorize(ll n) {// 素因数分解\n\t\treset();\n\t\tif (n < 0) { n = -n; }\n\t\tif (n <= 1) { return; }\n\n\t\tif (n % 2 == 0) {\n\t\t\tfactorNum++;\n\t\t\tprime.push_back(2);\n\t\t\tint count = 0;\n\t\t\twhile (n % 2 == 0) { count++; n /= 2; }\n\t\t\tdegree.push_back(count);\n\t\t}\n\n\t\tll M = l_sqrt(n) + 1;\n\t\tfor (ll i = 3; i < M; i += 2) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tfactorNum++;\n\t\t\t\tprime.push_back(i);\n\t\t\t\tint count = 0;\n\t\t\t\twhile (n % i == 0) { count++; n /= i; }\n\t\t\t\tdegree.push_back(count);\n\t\t\t\tM = l_sqrt(n) + 1;\n\t\t\t\tif (n == 1) { break; }\n\t\t\t}\n\t\t}\n\n\t\tif (n != 1) {\n\t\t\tfactorNum++;\n\t\t\tprime.push_back(n);\n\t\t\tdegree.push_back(1);\n\t\t}\n\t}\n\nprivate:\n\tvoid reset() {\n\t\tfactorNum = 0;\n\t\tprime.clear();\n\t\tdegree.clear();\n\t}\n};\n\nvector<ll> v;\nvoid func(primeFactorClass& p, ll x, int depth) {\n\tif (depth == p.prime.size()) {\n\t\tif (x == 1) { return; }\n\t\tv.push_back(x);\n\t}\n\telse {\n\t\tfor (int i = 0; i <= p.degree[depth]; i++) {\n\t\t\tfunc(p, x, depth + 1);\n\t\t\tx *= p.prime[depth];\n\t\t}\n\t}\n}\n\nint main() {\n\tll bignum = 128LL * 243LL * 125LL * 49LL * 11LL * 13LL * 17LL * 19LL * 23LL;\n\tprimeFactorClass p; p.factorize(bignum);\n\tfunc(p, 1, 0);\n\n\tint N; cin >> N;\n\tll** ans = new ll * [N];\n\tint c = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = new ll[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) { ans[i][j] = bignum; }\n\t\t\telse {\n\t\t\t\tans[i][j] = v[c];\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\n\tset<ll> st;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tll c = 1;\n\t\t\t\tif (i > 0) { c = lcm(c, ans[i - 1][j]); }\n\t\t\t\tif (j > 0) { c = lcm(c, ans[i][j - 1]); }\n\t\t\t\tif (i < N - 1) { c = lcm(c, ans[i + 1][j]); }\n\t\t\t\tif (j < N - 1) { c = lcm(c, ans[i][j + 1]); }\n\t\t\t\tll d = c;\n\t\t\t\twhile (st.find(d) != st.end()) {\n\t\t\t\t\td += c;\n\t\t\t\t}\n\t\t\t\tst.insert(d);\n\t\t\t\tans[i][j] += d;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define lf '\\n'\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 507 , __ = 9999999;\nconst int go[2][4] = {{1,0,-1,0},{0,1,0,-1}};\n\ninline lint gcd(lint a,lint b){while(b)a%=b,swap(a,b);return a;}\ninline lint lcm(lint a,lint b){return a/gcd(a,b)*b;}\n\nint pri[__]={0},isnp[__]={0},pcnt=0;\n\ninline void shai(int n=__-1)\n{\n\tisnp[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!isnp[i])pri[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt && 1ll*i*pri[j]<=n;j++)\n\t\t{\n\t\t\tint a=i*pri[j];\n\t\t\tisnp[a]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\n\nint n;\nlint val[_][_];\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\t\n\tshai();\n\t\n\tn=ty();\n\tif(n==2){cout<<\"4 7\\n23 10\\n\";return 0;}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1,rk1,rk2;j<=n;j++)\n\t\t\tif((i+j)&1)rk1=(i+j+1)/2,rk2=(i-j+n+1)/2,val[i][j]=pri[rk1]*pri[rk2+n];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j+1)&1)\n\t\t\t{\n\t\t\t\tval[i][j]=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(val[i+go[0][k]][j+go[1][k]])val[i][j]=lcm(val[i][j],val[i+go[0][k]][j+go[1][k]]);\n\t\t\t\tval[i][j]++;\n\t\t\t}\n\n\t/*\n\n\tfor(int i=1;i<=n;i++,cout<<lf)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<val[i][j]<<' ';\n\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tint a=i+go[0][k],b=j+go[1][k];\n\t\t\t\tif(a<=0 || a>n || b<=0 || b>n)continue;\n\t\t\t\tcerr<<i<<\" \"<<j<<\" | \"<<a<<\" \"<<b<<\" : \"<<max(val[i][j],val[a][b])%min(val[i][j],val[a][b])<<lf;\n\t\t\t}\n\t\t\t\n\t\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  donttttttt use vector \n  run n = 1 and n = MAXN before submit\n  try to AC within one submission\n*/\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\n\n#define int long long\n\nconst int N = 555;\nconst int M = 5e6 + 233;\nbool np[M], ban[M]; int p[M / 10], p_cnt;\nint n, a[N][N], bad[N][N];\n\ninline void prepare(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (np[i]) continue;\n\t\tp[++p_cnt] = i;\n\t\tfor (int j = i + i; j <= n; j += i) {\n\t\t\tnp[j] = true;\n\t\t}\n\t}\n}\n\ninline int lcm(int x, int y) {\n\treturn x / __gcd(x, y) * y;\n}\n\nsigned main(void) {\n\tprepare(10000);\n\tread(n);\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\trep (i, n) rep (j, n) bad[i][j] = ~(i + j) & 1;\n\tint tot = 0;\n\trep (len, n + n) if (len % 2 == 0) {\n\t\t++tot;\n\t\trep (i, n) rep (j, n)\n\t\t\tif (i + j == len && bad[i][j])\n\t\t\t\ta[i][j] = p[tot];\n\t}\n\trep (len, n + n) {\n\t\tint cnt = 0;\n\t\trep (i, n) rep (j, n)\n\t\t\tif ((n - i + 1 + j) == len && bad[i][j])\n\t\t\t\t++cnt;\n\t\tif (cnt) {\n\t\t\t++tot;\n\t\t}\n\t\trep (i, n) rep (j, n)\n\t\t\tif ((n - i + 1 + j) == len && bad[i][j])\n\t\t\t\ta[i][j] *= p[tot];\n\t}\n\t// cerr << p[500] * p[1000] << \"\\n\";\n\t// rep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n\trep (i, n) rep (j, n) if ((i + j) & 1) {\n\t\ta[i][j] = 1;\n\t\tauto add = [&](int x, int y) {\n\t\t\tif (x < 1 || x > n || y < 1 || y > n) return ;\n\t\t\tint t = lcm(a[i][j], a[x][y]), base = t;\n\t\t\ta[i][j] = t;\n\t\t\treturn ;\n\t\t};\n\t\tadd(i - 1, j);\n\t\tadd(i + 1, j);\n\t\tadd(i, j - 1);\n\t\tadd(i, j + 1);\n\t\t++a[i][j];\n\t}\n\trep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nvector<int> makePrimeLst(int N)\n{\n    if (N < 2) return vector<int>();\n    if (N == 2) return vector<int>{2};\n    vector<int> ans;\n    vector<int> alive(N+1, 1);\n    for (int i=2; (long long)i*i<=(long long)N; i++)\n    {\n        if (alive[i]) ans.push_back(i);\n        for (int t = i; t<=N; t += i) alive[t] = 0;\n    }\n    for (int i=ans.back()+1; i<=N; i++) if (alive[i]) ans.push_back(i);\n    return ans;\n}\n\nconstexpr int Nmax = 501;\nlint ans[Nmax][Nmax];\n\nint main()\n{\n    vector<int> info = makePrimeLst(100000);\n    vector<lint> p, q;\n    int now = 1;\n    while (p.size() < Nmax + 1)\n    {\n        p.insert(p.begin(), info[now++]);\n        q.insert(q.begin(), info[now++]);\n        p.push_back(info[now++]);\n        q.push_back(info[now++]);\n    }\n\n    REP(i, Nmax) REP(j, Nmax)\n    {\n        int u = (i + j) / 2, v = (i + (Nmax - 1 - j)) / 2;\n        if ((i + j) & 1)\n        {\n            ans[i][j] = p[u + 1] * q[v + 1];\n        }\n        else\n        {\n            ans[i][j] = p[u] * p[u + 1] * q[v] * q[v + 1] + 2;\n        }\n        if (ans[i][j] > 1000000000000000LL) exit(1);\n    }\n\n    int N;\n    cin >> N;\n    REP(i, N)\n    {\n        REP(j, N) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<ll>> a(N, vector<ll>(N));\n\tint tmp = 2;\n\tunordered_set<ll> st;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 0) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\ta[i][j] = tmp++;\n\t\t\t\tst.insert(a[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[i][j] = a[i - 1][j - 1] * 2;\n\t\t\t}\n\t\t\tst.insert(a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 1) {\n\t\t\tll g = 0;\n\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\tint ti = i + dx[d], tj = j + dy[d];\n\t\t\t\tif (0 <= ti && ti < N && 0 <= tj && tj < N) {\n\t\t\t\t\tll aa = g == 0 ? a[ti][tj] : a[ti][tj] / __gcd(a[ti][tj], g) * g;\n\t\t\t\t\tg = aa;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll t = g + 1;\n\t\t\twhile (st.count(t)) {\n\t\t\t\tt += g;\n\t\t\t}\n\t\t\ta[i][j] = t;\n\t\t\tst.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j + 1 == N];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=502;\nint n,ar[N][N],lis[1006],dx[]={0,0,-1,1},dy[]={-1,1,0,0},ar1[N][N];\nbool check(int x,int y){\n  if(x>0&&x<=n){\n    if(y>0&&y<=n){\n      return true;\n    }\n  }\n  return false;\n}\nbool check1(int x){\n    int i;\n    for(i=2;i*i<=x;i++){\n     if(x%i==0){\n         return false;\n     }\n    }\n    return true;\n}\nint LCM(int x,int y){\n  return (x/__gcd(x,y)) * y;\n}\nsigned main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int i,j,k,l,num=0,hichic=0;\n  cin>>n;\n  if(n==2){\n    cout<<\"4 7\\n23 10\";\n    return 0;\n  }\n  for(i=2;i<=10000;i++){\n    //cout<<i<<endl;\n    if(check1(i)){\n      num++;\n      lis[num]=i;\n      cout<<num<<' '<<i<<endl;\n      if(num==1002){\n        //cout<<num<<' '<<\"cac\"<<endl;\n        break;\n      }\n    }\n    //cout<<num<<endl;\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n        if(!((i+j)&1)){\n          continue;\n        }\n        if(i-1&&j-1){\n          ar[i][j]=ar[i-1][j-1];\n        }\n        else{\n          hichic++;\n          ar[i][j]=lis[hichic];\n        }\n      }\n    }\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n        if(!((i+j)&1)){\n          continue;\n        }\n        if(i-1&&j+1<=n){\n    \t\tar1[i][j]=ar1[i-1][j+1];\n          \tar[i][j]*=ar1[i][j];\n        }\n        else{\n          hichic++;\n          ar[i][j]*=lis[hichic];\n          ar1[i][j]=lis[hichic];\n        }\n      }\n    }\n    //cout<<\"cac\"<<endl;\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n        if(!((i+j)&1)){\n          ar[i][j]=1;\n          for(l=0;l<4;l++){\n            if(check(i+dx[l],j+dy[l])){\n              ar[i][j]=LCM(ar[i][j],ar[i+dx[l]][j+dy[l]]);\n            }\n          }\n        }\n        cout<<ar[i][j]<<' ';\n      }\n      cout<<'\\n';\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n不妨令 m = 1 ，设 n 为奇数。\n将矩阵黑白染色，确定白色的值，然后令黑色的值为周围白色的值的 lcm + 1 。\n一个简单的构造时在两个对角线上放质数，然后把白格子按两个对角线建坐标轴，\n每个白色的值钦定为在在两个坐标轴上对应的质数的乘积。\n那么每个黑色的格子一定是四个质数的乘积加一。\n然而第 1000 个质数是 7000+ ，四个如此大小的质数相乘会超出范围。\n因此放质数也有讲究，要把最大的和最小的交替放，避免两个大质数相乘。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 505;\nint prime[maxn << 1], tmp[maxn << 1], pp;\nll a[maxn][maxn];\n\nll gcd(ll x, ll y) {\n\tif(!y) return x;\n\treturn gcd(y, x % y);\n}\n\nll lcm(ll x, ll y) {\n\tif(!x or !y) return x + y;\n\treturn x / gcd(x, y) * y;\n}\n\nint main() {\n\tint n = read;\n\tbool mark = !(n & 1);\n\tif(mark) ++ n;\n\n\tfor(int x = 2; pp < n * 2; x ++) {\n\t\tbool ok = 1;\n\t\tfor(int d = 2; d * d <= x; d ++)\n\t\t\t// XXX: 震惊！这里不强制转 bool 竟然会出错？！\n\t\t\tok &= bool(x % d);\n\t\tif(ok)\n\t\t\ttmp[++ pp] = x;\n\t}\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tprime[i * 2 - 1] = tmp[i];\n\tfor(int i = 1; i <= n; i ++)\n\t\tprime[pp - i * 2 + 2] = tmp[n + i];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i][i] = prime[i];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i][n - i + 1] = prime[n + i];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) ? 1 : 2; j <= n; j += 2)\n\t\t\tif(!a[i][j])\n\t\t\t\ta[i][j] = a[(i + j) >> 1][(i + j) >> 1] *\n\t\t\t\t\ta[(n + 1 + i - j) >> 1][(n + 1 + j - i) >> 1];\n\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) ? 2 : 1; j <= n; j += 2)\n\t\t\ta[i][j] = lcm(a[i - 1][j], lcm(a[i][j - 1],\n\t\t\t\t\t\tlcm(a[i + 1][j], a[i][j + 1]))) + 1;\n\n\tif(mark) -- n;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nint a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a * b / __gcd(a, b);\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15);\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 10000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nvector<int> prime,flag;\n\nvoid list_prime(int N){\n\tflag.resize(N + 1);\n\tflag[0] = 1;\n\tflag[1] = 1;\n\tfor(int i = 4;i <= N;i += 2) flag[i] = 1;\n\tfor(int i = 3;i * i <= N;i += 2){\n\t\tif(flag[i]) continue;\n\t\tfor(int j = i * 2;j <= N;j += i) flag[j] = 1;\n\t}\n\tfor(int i = 0;i <= N;i++) if(!flag[i]) prime.push_back(i);\n\tfor(int i = 0;i <= N;i++) flag[i] = !flag[i];\n}\n\nint gcd(int a,int b){\n\tif(a < b) swap(a,b);\n\tif(!b) return a;\n\treturn gcd(b,a % b);\n}\n\nint lcm(int a,int b){\n\treturn a / gcd(a,b) * b;\n}\n\nconst int ofs = 510;\nint n,a[1520][1520] = {};\n\nsigned main(){\n\tcin >> n;\n\tlist_prime(10000);\n\tfor(int i = 0;i <= 2 * n;i += 2){\n\t\tint t = n + 1;\n\t\tfor(int j = (int)(n / 2) * -2;j <= (int)(n / 2) * 2;j += 2){\n\t\t\tint x = (i + j) / 2,y = (i - j) / 2;\n\t\t\ta[x + ofs][y + ofs] = prime[i / 2] * prime[t];\n\t\t\tt++;\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(!a[i + ofs][j + ofs]){\n\t\t\t\ta[i + ofs][j + ofs] = 1;\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tint x = i + dx[k],y = j + dy[k];\n\t\t\t\t\ta[i + ofs][j + ofs] = lcm(a[i + ofs][j + ofs],a[x + ofs][y + ofs]);\n\t\t\t\t}\n\t\t\t\ta[i + ofs][j + ofs]++;\n\t\t\t}\n\t\t\tcout << (j ? \" \" : \"\") << a[i + ofs][j + ofs];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\nusing namespace std;\n\n#define NMAX 502\n#define DIM 7920\n\nint d[DIM], p[DIM];\nlong long sol[NMAX][NMAX];\n\nvoid ciur(int n) {\n    for (int i = 2; i <= n; i++) {\n        if (d[i] == 0) {\n            p[++p[0]] = i;\n            for (int j = i + i; j <= n; j += i) {\n                d[j] = 1;\n            }\n        }\n    }\n}\n\n__int128 gcd(__int128 a, __int128 b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n__int128 lcm(vector <long long>& v) {\n    __int128 l = 1;\n    for (const long long x : v) {\n        if (x == 0)\n            continue;\n        __int128 d = gcd(l, (__int128)x);\n        l = l * x / d;\n\n    }\n    return (long long)l;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << \"4 7\\n23 10\\n\";\n        return 0;\n    }\n    ciur(DIM - 1);\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            sol[i][j] = 1;\n        }\n    }\n\n    int cnt = 1;\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col > n)\n                break;\n            sol[i][col] *= p[cnt];\n            col++;\n        }\n        cnt++;\n    }\n\n    for (int i = 3; i <= n; i += 2) {\n        int lin = i;\n        for (int j = 1; j <= n; j++) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col <= 0)\n                break;\n            sol[i][col] *= p[cnt];\n            col--;\n        }\n        cnt++;\n    }\n\n    for (int i = n; i > 1; i -= 2) {\n        int lin = i;\n        for (int j = n; j >= 1; j--) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) % 2 == 0)\n                continue;\n            vector <long long> v = {sol[i - 1][j], sol[i + 1][j], sol[i][j - 1], sol[i][j + 1]};\n            sol[i][j] = lcm(v);\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << sol[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 250010\n#define N 1010\nusing namespace std;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint prime[maxn], tot_prime;\nll res[N][N];\nset<ll> S;\nll gcd(ll a, ll b)\n{\n\tll y = a % b;\n\twhile (y)\n\t{\n\t\ta = b;\n\t\tb = y;\n\t\ty = a % b;\n\t}\n\treturn b;\n}\nbool check(int x)\n{\n\tfor (int i = 2; i <= x - 1; i++)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tll T = 1e15;\n\tfor (int i = 2; i <= 10000; i++)\n\t\tif (check(i)) prime[++tot_prime] = i;\n\tint cur = 0;\n\tfor (int i = 2; i <= n + n; i += 2)\n\t{\n\t\tcur++;\n\t\tfor (int j = 1; j <= i && j <= n; j++)\n\t\t{\n\t\t\tint x = j, y = i - j;\n\t\t\tif (y <= n) res[x][y] *= prime[cur];\n\t\t}\n\t}\n\tint st = 1 - n;\n\tif (st % 2) st++;\n\tfor (int i = st; i <= n - 1; i += 2)\n\t{\n\t\tcur++;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tint x = j, y = x - i;\n\t\t\tif (x > 0 && y > 0 && x <= n && y <= n) res[x][y] *= prime[cur];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) % 2 == 0) S.insert(res[i][j]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t{\n\t\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\t\tif (tx && ty && tx <= n && ty <= n)\n\t\t\t\t\t{\n\t\t\t\t\t\tres[i][j] = res[i][j] / gcd(res[i][j], res[tx][ty]) * res[tx][ty];\n\t\t\t\t\t\tassert(res[i][j] <= T);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tll pre = res[i][j];\n\t\t\twhile (S.find(res[i][j]) != S.end()) res[i][j] += pre;\n\t\t\tS.insert(res[i][j]);\n\t\t\tres[i][j]++;\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tprintf(\"%lld \", res[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 3000; \nconst long long INF = 0x3f3f3f3f; \n\nint x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}, elm[Maxv], cnt, idx, n; \nlong long ans[650][650], max = -INF; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void pre_Opt() {\n    int num; \n    for (int i = 2;; i++) {\n        for (num = 2; num * num <= i; num++) {\n            if (i % num == 0) break; \n        }\n\n        if (num * num > i) elm[++cnt] = i; \n        if (cnt >= Maxv - 5) break; \n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    pre_Opt(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", elm[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = elm[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= elm[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        printf(\"\\n\"); \n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "/*input\n3\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=505;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll g[maxn][maxn];\n\nvector<int> a,b;\n\nll lcm(ll a,ll b){\n\tif(a==0||b==0) return a+b;\n\treturn a*b/__gcd(a,b);\n}\nbool isp[300000]={0};\nvector<int> p;\n\nint main()\n{\n\tIOS;\n\n\n\tfor(int i=2;i<300000;i++){\n\t\tif(!isp[i]) p.pb(i);\n\t\tfor(int j=0;i*p[j]<300000;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tREP(i,500) a.pb(p[i]);\n\tREP(i,500) b.pb(p[i+500]);\n\n\tREP(i,500) REP(j,500) if((i+j)%2==0){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j)/2];\n\t\tg[i][j]*=b[(i-j+499)/2];\n\t}\n\n\tREP(i,500) REP(j,500) if((i+j)%2){\n\t\tg[i][j]=0;\n\n\t\tif(i+1<500) g[i][j]=lcm(g[i][j],g[i+1][j]);\n\t\tif(j+1<500) g[i][j]=lcm(g[i][j],g[i][j+1]);\n\t\tif(i) g[i][j]=lcm(g[i][j],g[i-1][j]);\n\t\tif(j) g[i][j]=lcm(g[i][j],g[i][j-1]);\n\t\tg[i][j]++;\n\t\tassert(g[i][j]<1e15);\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<g[i][j]<<\" \\n\"[j==n-1];\n\n\tREP(i,n) REP(j,n-1) assert(max(g[i][j],g[i][j+1])%min(g[i][j],g[i][j+1])==1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1111111\n#define int long long\nbool vis[1111111];\nint pri[111111],tot;\nint a[11111],b[11111],f[555][555];\nmap<int,bool>mp;\nsigned main(){\n\tfor (int i=2;tot<=1111 && i<N;i++){\n\t\tif (!vis[i]) pri[++tot]=i;\n\t\tfor (int j=1;j<=tot && pri[j]*i<N;j++){\n\t\t\tvis[i*pri[j]]=1; \n\t\t\tif (i%pri[j]==0) break;\n\t\t}\t\n\t}\n\tint n; scanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=pri[i];\n\t\tb[i]=pri[i+n];\n\t}\n\tfor (int i=0;i<=n+1;i++) f[i][0]=f[0][i]=f[n+1][i]=f[i][n+1]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tf[i][j]=a[(i-j)/2+(n+1)/2]*b[(i+j)/2];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)&1){\n\t\t\t\tf[i][j]=f[i-1][j]*f[i][j-1]*f[i+1][j]*f[i][j+1]+1;\n\t\t\t\tif (mp.count(f[i][j])) f[i][j]=(f[i][j]-1)*2+1;\n\t\t\t\tmp[f[i][j]]=1;\n\t\t\t}\n\t\t\t\t\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",f[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n ;cin>>n;\nfor(int i = 0;i<n;i++) for(int j=0;j<n;j++){\n\tcout<<10000000-i-j;\n  \tcout<<(j==n-1 ? \"\\n\": \" \" );}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint N;\nint a[201][201], vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= MAXN - 1); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return 1;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> N;\n\tif(N == 2) return printf(\"4 7\\n23 10\"), 0; \n\tfor(int i = 1; i <= N; i++) \n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!((i + j) & 1)) a[i][j] = prime[(i + j) / 2] * prime[N + (i - j) / 2 + (N + 1) / 2];\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!a[i][j]) a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#define maxn 510\n#define ll long long\n\nusing namespace std;\n\nint n;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nll a[maxn][maxn];\n\nvoid fill_in()\n{\n\tint pre = 1;\n\tfor (int i = 1; i <= n; i ++ )\n\t{\n\t\tif (i & 1)\n\t\t{\n\t\t\tfor (int j = 1; j <= n; j += 2) a[i][j] = ++pre; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (n & 1) for (int j = n - 1; j >= 2; j -= 2) a[i][j] = ++pre;\n\t\t\telse for (int j = n; j >= 2; j -= 2) a[i][j] = ++pre;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tif (n == 2)\n\t{\n\t\tputs(\"2 6\");\n\t\tputs(\"12 3\");\n\t}\n\telse\n\t{\n\t\tfill_in();\n\t\tfor (int i = 1; i <= n; i ++ )\n\t\t\tfor (int j = 1; j <= n; j ++ )\n\t\t\t\tif ((i + j) & 1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j] = 1ll;\n\t\t\t\t\tfor (int k = 0; k < 4; k ++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\t\t\tif (nx < 1 || nx > n || ny < 1 || ny > n) continue;\n\t\t\t\t\t\ta[i][j] *= a[nx][ny];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\tfor (int i = 1; i <= n; i ++ )\n\t\t{\n\t\t\tfor (int j = 1; j <= n; j ++ ) cout << a[i][j] << ' ';\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i < 499 ? 998 - 2 * i : 2 * i - 999;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 3;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 3;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//const int N = 5e5+5;\n//bool prime[N];\n//ll gcd(ll x, ll y){\n//    if(y == 0)\n//        return x;\n//    return gcd(y,x%y);\n//}\n//void alternate(vi &arr){\n//    vi ans;\n//    for(int i = 0; i < 250; ++i){\n//        ans.pb(arr[i]);\n//        ans.pb(arr[499-i]);\n//    }\n//    arr = ans;\n//}\n//void _(){\n//    fill(prime+2,prime+N,true);\n//    vector<int> primes;\n//    for(int i = 2; i < N; ++i)\n//        if(prime[i]){\n//            for(int j = 2*i; j < N; j += i)\n//                prime[j] = false;\n//            primes.push_back(i);\n//        }\n//    primes.resize(1000);\n//    vi p1;\n//    vi p2;\n//    for(int i = 0; i < 1000; ++i)\n//        if(i%2) \n//            p1.pb(primes[i]);\n//        else\n//            p2.pb(primes[i]);\n//    alternate(p1);\n//    alternate(p2);\n//    //print(p1);\n//    //print(p2);\n//    int n;\n//    cin >> n;\n//    vector<ll> arr;\n//    vvl grid(n,vl(n));\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 == j % 2){\n//                int d1 = (i+j)/2;\n//                int d2 = (i-j+n-1)/2;\n//                ll a = p1[d1];\n//                ll b = p2[d2];\n//                grid[i][j] = a*b;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 != j % 2){\n//                vl neigh;\n//                if(i > 0) neigh.pb(grid[i-1][j]);\n//                if(i+1 < n) neigh.pb(grid[i+1][j]);\n//                if(j > 0) neigh.pb(grid[i][j-1]);\n//                if(j+1 < n) neigh.pb(grid[i][j+1]);\n//                ll ans = 1;\n//                for(ll x : neigh){\n//                    ans = ans*(x/gcd(ans,x));\n//                }\n//                grid[i][j] = ans+1;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            arr.push_back(grid[i][j]);\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            cout << grid[i][j]  << \" \\n\"[j==n-1];\n//    sort(all(arr));\n//    arr.erase(unique(all(arr)),arr.end());\n//    //assert(arr.size() == n*n);\n//    //cout << n*n << ' ' << arr.size() << '\\n';\n//}\n//\n// ================================================ \n// ^^^\tABOVE is what I wrote in my editor\t^^^\n// ------------------------------------------------ \n// vvv\tBELOW is automatically generated \tvvv\n// ================================================ \n#include <numeric>\n#include <set>\n#include <iomanip>\n#include <algorithm> \n#include <cassert>\n#include <vector>\n#include <iostream>\n#define pb push_back \n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<int> vi;\ntemplate<typename IT>\nostream &print(IT b, IT e, string sep = \" \", ostream &stream = cout){\n\tfor(IT it = b; it != e; ++it){\n\t\tstream << *it;\n\t\tif(it+1 != e) stream << sep;\n\t} \n\treturn stream;\n}\ntemplate<typename IT> istream &read(IT b, IT e, istream &stream = cin){\n\tfor(IT it = b; it != e; ++it) stream >> *it; return stream;\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &&t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> istream &operator>>(istream &stream, vector<T> &t){\n\treturn read(all(t),stream);\n}\ntemplate <typename T> \nvoid print(T x){\n\tcout << x << '\\n';\n}\ntemplate <typename t> \nvoid print(vector<t> arr,string sep=\" \"){\n    if(arr.empty())\n        return;\n\tprint(arr.begin(),arr.end(),sep);\n\tcout << '\\n';\n}\ntemplate <typename T> \nvoid print(vector<vector<T> > arr){\n\tfor(int i = 0; i < arr.size(); ++i){\n\t\tcout << \"[\" << arr[i] << \"]\";\n\t\tif(i+1 < arr.size())\n\t\t\tcout << \", \";\n\t}\n\tcout << '\\n';\n}\ntemplate<typename T>\nT _();\nconst ll INF = ll(2e18)+666;\nconst ll MOD = 1e9+7;\ntemplate<typename T>\nvector<T> operator+(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(lhs);\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] += rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator+=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs+rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nvector<T> operator-(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(all(lhs));\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] -= rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator-=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs-rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nT max(const vector<T> arr){\n\tassert(!arr.empty());\n\tT ans = arr[0];\n\tfor(auto &cur : arr)\n\t\tans = max(ans,cur);\n\treturn ans;\n}\ntemplate<typename T>\nT max(const set<T> s){\n\tassert(!s.empty());\n\treturn *--s.end();\n}\ntemplate<typename T, typename G>\nvector<T> set_max(vector<T> &base, const vector<G> &comp){\n\tassert(base.size() == comp.size());\n\tfor(int i = 0; i < (int)comp.size(); ++i)\n\t\tbase[i] = max(base[i],comp[i]);\n\treturn base;\n}\ntemplate <typename T>\nvector<T> unique(vector<T> &arr){\n    sort(all(arr));\n\tarr.erase(unique(all(arr)),arr.end());\n\treturn arr;\n}\nconst int N = 5e5+5;\nbool prime[N];\nll gcd(ll x, ll y){\n    if(y == 0)\n        return x;\n    return gcd(y,x%y);\n}\nvoid alternate(vi &arr){\n    vi ans;\n    for(int i = 0; i < 250; ++i){\n        ans.pb(arr[i]);\n        ans.pb(arr[499-i]);\n    }\n    arr = ans;\n}\nvoid _(){\n    fill(prime+2,prime+N,true);\n    vector<int> primes;\n    for(int i = 2; i < N; ++i)\n        if(prime[i]){\n            for(int j = 2*i; j < N; j += i)\n                prime[j] = false;\n            primes.push_back(i);\n        }\n    primes.resize(1000);\n    vi p1;\n    vi p2;\n    for(int i = 0; i < 1000; ++i)\n        if(i%2) \n            p1.pb(primes[i]);\n        else\n            p2.pb(primes[i]);\n    alternate(p1);\n    alternate(p2);\n    //print(p1);\n    //print(p2);\n    int n;\n    cin >> n;\n    vector<ll> arr;\n    vvl grid(n,vl(n));\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 == j % 2){\n                int d1 = (i+j)/2;\n                int d2 = (i-j+n-1)/2;\n                ll a = p1[d1];\n                ll b = p2[d2];\n                grid[i][j] = a*b;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 != j % 2){\n                vl neigh;\n                if(i > 0) neigh.pb(grid[i-1][j]);\n                if(i+1 < n) neigh.pb(grid[i+1][j]);\n                if(j > 0) neigh.pb(grid[i][j-1]);\n                if(j+1 < n) neigh.pb(grid[i][j+1]);\n                ll ans = 1;\n                for(ll x : neigh){\n                    ans = ans*(x/gcd(ans,x));\n                }\n                grid[i][j] = ans+1;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            arr.push_back(grid[i][j]);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            cout << grid[i][j]  << \" \\n\"[j==n-1];\n    sort(all(arr));\n    arr.erase(unique(all(arr)),arr.end());\n    //assert(arr.size() == n*n);\n    //cout << n*n << ' ' << arr.size() << '\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(12);\n\t_();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector <vector <int> > a = { {2, 3, 7}, {5, 16, 561}, {11, 2073985, 3928} };\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    \n    if (n > 3) exit(1);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 510, M = 1e4, K = 1024;\nint n, m, is[M], c, p[K];\nvoid pre_work() {\n    for (int i = 2; i < M; ++i) {\n        if (!is[i]) p[++c] = i; if (c >= m) break;\n        for (int j = 1; j <= c && p[j] * i < M; ++j) {\n            is[p[j] * i] = 1; if (i % p[j] == 0) break;\n        }\n    }\n}\nint x[K], y[K], res[N][N];\nsigned main() {\n    scanf (\"%lld\", &n);\n    m = n << 1; pre_work();\n    int a = 1, b = c, k = 1;\n    // for (int i = 1; i <= c; ++i) printf (\"%lld \", p[i]); puts (\"\");\n    for (int i = 1; i <= n; ++i) {\n        if (k) x[i * 2] = p[a], ++a;\n        else x[i * 2] = p[b], --b; k ^= 1;\n    }\n    for (int i = n; i >= 1; --i) {\n        if (k) y[i * 2] = p[a], ++a;\n        else y[i * 2] = p[b], --b; k ^= 1;\n    }\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) % 2 == 0) res[i][j] = x[i + j] * y[i + j];\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) & 1) res[i][j] = x[i + j - 1] * x[i + j + 1] * y[i + j - 1] * y[i + j + 1] + 1;\n    if (n == 2) res[2][1] = (res[2][1] - 1) * 2 + 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j)\n            printf (\"%lld \", res[i][j]); puts (\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll ans[1010][1010],n;\nbool vis[10101];\nint tot,p[10101];\ninline void init(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!vis[i]) p[++tot]=i;\n\t\tfor (int j=1;j<=tot;j++){\n\t\t\tif (1ll*i*p[j]>n) break;\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\ninline ll lcm(ll a,ll b){\n\tif (a*b==0) return a+b;\n\treturn a/__gcd(a,b)*b;\n}\nsigned main(){\n\tn=read();\n\tinit(10000);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tans[i][j]=1ll*p[(i+j)/2+n]*p[(i-j)/2+n];\n\t\t\t}\t\t\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2){\n\t\t\t\tans[i][j]=lcm(ans[i-1][j],lcm(ans[i][j-1],lcm(ans[i+1][j],ans[i][j+1])));\n\t\t\t}\t\t\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 520\n#define maxm 20020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nint prime[maxm],cnt,tag[maxm];\nint n,tag1[maxn][maxn],tag2[maxn][maxn],tot;\nll a[maxn][maxn];\nmap <ll,int> num;\nvector <pr> vec;\nll tmp = 1e15;\n\nvoid init(){\n\trep(i,2,10000){\n\t\tif ( !tag[i] ) prime[++cnt] = i;\n\t\trep(j,1,cnt){\n\t\t\tif ( prime[j] * i > 10000 ) break;\n\t\t\ttag[prime[j] * i] = 1;\n\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\tif ( !b ) return a;\n\treturn gcd(b,a % b);\n}\ninline ll lcm(ll a,ll b){\n\tll d = gcd(a,b);\n\treturn a / d * b;\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\t\t\n\tif ( n == 2 ){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1 ) ){\n\t\t\t\tif ( i > 1 && j > 1 && tag1[i - 1][j - 1] ) tag1[i][j] = tag1[i - 1][j - 1];\n\t\t\t\tif ( i < n && j < n && tag1[i + 1][j + 1] ) tag1[i][j] = tag1[i + 1][j + 1];\n\t\t\t\tif ( !tag1[i][j] ) tag1[i][j] = ++tot; \n\t\t\t\tif ( i > 1 && j < n && tag2[i - 1][j + 1] ) tag2[i][j] = tag2[i - 1][j + 1];\n\t\t\t\tif ( i < n && j > 1 && tag2[i + 1][j - 1] ) tag2[i][j] = tag2[i + 1][j - 1];\n\t\t\t\tif ( !tag2[i][j] ) tag2[i][j] = ++tot;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1) ){\n\t\t\t\ta[i][j] = prime[tag1[i][j]] * prime[tag2[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tll cur = 1;\n\t\t\t\tif ( i > 1 ) cur = lcm(cur,a[i - 1][j]);\n\t\t\t\tif ( i < n ) cur = lcm(cur,a[i + 1][j]);\n\t\t\t\tif ( j > 1 ) cur = lcm(cur,a[i][j - 1]);\n\t\t\t\tif ( j < n ) cur = lcm(cur,a[i][j + 1]);\n\t\t\t\ta[i][j] = cur + 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tcout<<a[i][j]<<\" \";\n\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\t//rvc(i,vec) cerr<<vec[i].fi<<\" \"<<vec[i].se<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 203050\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],n,b[505][505],mx,c,o,r;\nint p[maxn];\nvector<ll> h[maxn];\nbool vis[maxn];\nll lcm(ll x,ll y){\n    return x/__gcd(x,y)*y;\n}\nmap<ll,int> f;\n\nint main(){\n    cin >> n;\n    //for (int i=0;i<n*n/2;i++) a[c++]=i+1;\n    //for (int i=0;i<c;i++)cout<<a[i]<<' ';cout<<endl;\n    //random_shuffle(a,a+c);\n    o=1;\n    for (int i=2;i<=n;i+=2)\n        for (int j=(i%4==2)?1:3;j<=n;j+=4)\n            b[i][j]=o*2,o+=2;\n    o=1;\n    for (int i=1;i<=n;i+=2)\n        for (int j=(i%4==1)?2:4;j<=n;j+=4)\n            b[i][j]=o*4,o+=2;\n    o=1;\n    for (int i=2;i<=n;i+=2)\n        for (int j=(i%4==2)?3:1;j<=n;j+=4)\n            b[i][j]=o*8,o+=2;\n    o=1;\n    for (int i=1;i<=n;i+=2)\n        for (int j=(i%4==1)?4:2;j<=n;j+=4)\n            b[i][j]=o*16,o+=2;\n\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) if ((i+j)%2==0){\n            r=1;\n            if (i>1) r=lcm(r,b[i-1][j]);\n            if (i<n) r=lcm(r,b[i+1][j]);\n            if (j>1) r=lcm(r,b[i][j-1]);\n            if (j<n) r=lcm(r,b[i][j+1]);\n            mx=max(r,mx);\n            long long s=1;\n            while (f[r*s]) s++;\n            b[i][j]=r*s+1; f[r*s]=1;\n        }\n\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)cout<<b[i][j]<<' ';cout<<endl;\n    }\n\n    //cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long long ll;\n#define X first\n#define Y second\n#define all(o) o.begin(), o.end()\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\nconst int maxn = 2e5 + 10;\nll a[maxn][maxn];\nint dx[] = {-1, +1, 0, 0};\nint dy[] = {0, 0, +1, -1};\nint n;\nset<ll> st;\nbool isin(int x,int y){\n\treturn (x >= 0 && x < n && y >= 0 && y < n);\n}\nvoid doo(int x,int y){\n\tif(a[x][y]) return;\n\tset<ll> s;\n\tfor(int i=0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(isin(nx, ny) && a[nx][ny] != 0)\n\t\t\ts.insert(a[nx][ny]);\n\t}\n\tint ans = 1;\n\tfor(auto x : s)\n\t\tans *= x;\n\tint cur = ans + 1;\n\twhile(1){\n\t\tif(st.find(cur) == st.end()){\n\t\t\ta[x][y] = cur;\n\t\t\tst.insert(cur);\n\t\t\tbreak;\n\t\t}\n\t\tcur += ans;\n\n\t}\n}\nint32_t main(){\n\tIOS;\n\t\n\t//int n;\n\tcin >> n;\n\tint cur = 2;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(i % 2 == j % 2){\n\t\t\t\ta[i][j] = cur;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<n; j++)\n\t\t\tdoo(i, j);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++)\n\t\t\tcout << a[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nt.me/ivanesipovvpered\n*/\n#pragma ARCENIY_KIRILLOV_POVELITEL_KROKODILOV\n//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"no-stack-protector\")\n//#pragma GCC push_options\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC pop_options\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define rng(a) a.begin(), a.end()\n#define fast ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define int long long\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-5;\nconst int mod = 1e9 + 7;\nconst ll INFLL = 1e18;\nconst int INF = 1e9;\nconst int maxn = 1e6 + 3;\n\nll gcd(ll a, ll b){\n    if (b == 0ll)\n        return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b){\n    return (a / gcd(a, b) )* b;\n}\n\nbool is_prime(ll a){\n    if (a == 2 || a == 3 || a == 5 || a == 7) return true;\n    if (a % 2 == 0 || a%3 == 0 || a%5 == 0 || a%7 == 0)\n        return false;\n    for (ll i = 11; i * i <= a; i += 2){\n        if (a % i == 0)\n            return false;\n    }\n    return true;\n}\n\nll binpow(ll a, int n){\n    if (a == 0)\n        return 1;\n    if (a % 2 == 0){\n        ll q = binpow(a, n / 2);\n        return (q * q)  ;\n    }else return (a * binpow(a, n - 1) ) ;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmain(){\n    int n;\n    cin >> n;\n    vector<ll> primes;\n    ll a[n][n];\n    for (int i = 0; i < n; i++){\n        for (int j = 0; j < n; j++){\n            a[i][j] = 0;\n        }\n    }\n    int fe = 2;\n    while (primes.size() < n + n + 2){\n        if (is_prime(fe)) primes.pb(fe);\n        fe++;\n    }\n    int q = 0;\n    for (int i = 0; i < n; i++){\n        for (int j = 0; j < n; j++){\n            if ((i + j) % 2 == 0){\n                a[i][j] = primes[(i + j) / 2];\n                q = max(q, (i + j) / 2);\n            }\n        }\n    }\n    for (int j = n - 1; j > -1; j--){\n        for (int i = 0; i < n; i++){\n            if ((i + j) % 2 == 0){\n                a[i][j] *= primes[q + 1 + (i + (n - j)) / 2];\n            }\n        }\n    }\n    map<ll,bool> kek;\n    for (int i = 0; i < n; i++){\n        for (int j = 0; j < n; j++){\n            if (a[i][j]) continue;\n            int qe = 1, we = 1;\n            if (i)\n                qe = a[i-1][j];\n            if (i < n - 1)\n                qe = lcm(qe, a[i+1][j]);\n            if (j)\n                we = a[i][j-1];\n            if (j < n-1)\n                we = lcm(we,a[i][j+1]);\n            int ce = lcm(qe, we);\n            int flex = ce;\n            while (kek[ce]){\n                ce += flex;\n            }\n            kek[ce] = 1;\n            a[i][j] = ce + 1;\n        }\n    }\n    for (int i = 0; i < n; i++){\n        for (int j = 0 ; j< n; j++){\n            cout << a[i][j] << ' ';\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\n\nll a[505][505];\nll gcd(ll a, ll b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tif (n == 2) {\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tvector<int> p;\n\tfor (int i = 2; p.size() < 2 * n; ++i)\n\t\tif (prime(i)) p.push_back(i);\n\tauto it = p.begin();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!(i + j & 1)) a[i][j] = 1;\n\tfor (int d = 2; d < 2 * n; d += 2, ++it)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (d - i >= 1 && d - i <= n)\n\t\t\t\ta[i][d - i] *= *it;\n\tfor (int d = n & 1; d < 2 * n; d += 2, ++it)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (d + i - n >= 1 && d + i - n <= n)\n\t\t\t\ta[i][d + i - n] *= *it;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (i + j & 1) {\n\t\t\t\tconst int D[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint x = i + D[k][0], y = j + D[k][1];\n\t\t\t\t\tif (x >= 1 && x <= n && y >= 1 && y <= n)\n\t\t\t\t\t\ta[i][j] = a[i][j] / gcd(a[i][j], a[x][y]) * a[x][y];\n\t\t\t\t}\n\t\t\t\t++a[i][j];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\nconst int INF = 1e9 ;\nconst int maxN = 1010; \nconst int MOD = 1e9 + 7;\nint tot,n;\nint prime[maxN*10]; //记录质数\nint b[maxN * 100]; //标记i 是否为质数 \nll a[maxN][maxN];\nconst int L = 10000;\nvoid check()\n{\n\ttot = 0;\n\tfor(int i=2;i<=L;i++)\n\t{\n\t\tif(b[i] == 0)\n\t\t{\n\t\t\tprime[++tot] = i;\n\t\t\tfor(int j=2;i*j<=L;j++)\n\t\t\t{\n\t\t\t\tb[i*j] = 1;\t\n\t\t\t}\t\n\t\t}\t\n\t} \n} \nvector<pii> l[maxN];\nll lc[maxN];\nint lcnt;\nvector<pii> r[maxN];\nll rc[maxN]; \nint rcnt;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tcheck();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(i,1)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = 1+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int j=2;j<=n;j++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(n,j)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tlcnt = cnt;\n\tcnt = 0;\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint k=1;\n\t\tr[++cnt].push_back(pii(n,j));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint k = 1;\n\t\tr[++cnt].push_back(pii(i,n));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = n-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\t\n\t\t} \n\t}\n\trcnt = cnt;\n\tcnt = 0;\n\tfor(int i=1;i<=lcnt;i+=2)\n\t{\n\t\tlc[i] = prime[++cnt]; \n\t}\n\tfor(int j=2;j<=lcnt;j+=2)\n\t{\n\t\tlc[j] = lc[j-1]*lc[j+1];\n\t}\n\tif(n%2 == 1)\n\t{\n\t\tfor(int i=1;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\tfor(int j=2;j<=rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\t\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\trc[1] = rc[2];\n\t\trc[rcnt] = rc[rcnt-1];\n\t\tfor(int j=3;j<rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][j] = 1ll; \n\t} \n\tfor(int i=1;i<=lcnt;i++)\n\t{\n\t\tfor(int j=0;j<l[i].size();j++)\n\t\t{\n\t\t\tint tx = l[i][j].first;\n\t\t\tint ty = l[i][j].second;\n\t\t\ta[tx][ty] *= lc[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=rcnt;i++)\n\t{\n\t\tfor(int j=0;j<r[i].size();j++)\n\t\t{\n\t\t\tint tx = r[i][j].first;\n\t\t\tint ty = r[i][j].second;\n\t\t\ta[tx][ty] *= rc[i];\n\t\t\tif((tx+ty)%2==1)\n\t\t\t\ta[tx][ty] += 1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j<n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < (int)(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nint lcm(int a, int b) {\n    return a / __gcd(a, b) * b;\n}\n\nint lcm(vi vec) {\n    if (vec.empty())\n        return 1;\n    int ret = vec[0];\n    for (int i = 1; i < SZ(vec); ++i)\n        ret = lcm(ret, vec[i]);\n    return ret;\n}\n\nvi di = {0, 0, -1, 1};\nvi dj = {-1, 1, 0, 0};\nconst int N = 1e5 + 10;\nint ptr[N];\nint n;\nvvi g;\nvi ans;\nvoid dfs(int v) {\n    for (; ptr[v] < n; ++ptr[v]) {\n        int to = ptr[v];\n        if (to != v && !g[v][to]) {\n            g[v][to] = g[to][v] = true;\n            dfs(to);\n        }\n    }\n    ans.push_back(v);\n}\n\nvi get(int sz) {\n    int N = 1e5 + 10;\n    vector<bool> prime(N, true);\n    vi primes;\n    for (int i = 2; i < N; ++i) {\n        if (prime[i]) {\n            primes.push_back(i);\n            int x = SZ(primes);\n            if (x * (x - 1) / 2 > sz)\n                break;\n            for (int j = i * i; j < N; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n\n\n    n = primes.size();\n    g.resize(n);\n    fori (i, n) {\n        g[i].resize(n);\n    }\n    dfs(0);\n    vi ret(sz);\n    for (int i = 0; i < sz; ++i) {\n        ret[i] = primes[ans[i]] * primes[ans[i + 1]];\n    }\n    watch(*max_element(ALL(primes)));\n    return ret;\n}\n\nvoid smain() {\n    int n;\n    cin >> n;\n    vvl a(n, vl(n, 0));\n    set<int> used;\n    map<int, vector<pii>> diags;\n    fori (i, n) {\n        fori (j, n) {\n            if (((i ^ j) & 1)) {\n                diags[i + j].push_back({i, j});\n            }\n        }\n    }\n\n    vi kek;\n    int cur = n + 1;\n    for (auto item : diags) {\n        sort(ALL(item.second), [&] (const pii & f, const pii & s) -> bool {\n            return f.second < s.second;\n        });\n        int s = kek.size();\n        if (s < item.second.size()) {\n            kek.push_back(s + 1);\n            kek.insert(kek.begin(), s + 2);\n        } else if (s > item.second.size()) {\n            kek.erase(kek.begin());\n            kek.pop_back();\n        }\n        fori (i, SZ(kek)) {\n            a[item.second[i].first][item.second[i].second] = kek[i] * cur - 1;\n        }\n        cur++;\n    }\n\n    fori (i, n) {\n        fori (j, n) if (a[i][j] == 0 ) {\n            vi vec;\n\n            fori (dir, SZ(di)) {\n                int ii = i + di[dir];\n                int jj = j + dj[dir];\n                if (ii >= 0 && ii < n && jj >= 0 && jj < n) {\n                    vec.push_back(a[ii][jj] + 1);\n                }\n            }\n            int x = lcm(vec);\n            ll cur = x;\n            while (used.count(cur))\n                cur += x;\n            a[i][j] = cur;\n            used.insert(a[i][j]);\n        }\n    }\n\n    ll mx = 0;\n    fori (i, n) {\n        fori (j, n) {\n//            cerr << a[i][j] << \"   \";\n//            inmax(mx, a[i][j]);\n            cout << a[i][j] * 2 + 2 << ' ';\n        }\n        cout << '\\n';\n    }\n    watch(mx);\n    watch(lcm({11, 22, 12, 24}));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m long long\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1000];\nmain(){m n,t=0,k=555;cin>>n;r(2,i,1e4){bool a=1;r(2,j,i){if(i%j==0)a=0;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long grid[1000][1000];\nint main() {\n#define int long long\n\tvector<int> sosuu;\n\tfor (int i = 2; i <= 10000; ++i) {\n\t\tint ok = 1;\n\t\tfor (int q = 2; q <= sqrt(i); ++q) {\n\t\t\tif (i % q == 0) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok == 1) continue;\n\t\tsosuu.push_back(i);\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tgrid[i][q] = 1;\n\t\t}\n\t}\n\tint now_itr = 0;\n\tfor (int i = 0; i < 1000; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i - q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tfor (int i = -1000; i < 500; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i + q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tint xe[4] = { 1,-1,0,0 };\n\tint ye[4] = { 0,0,-1,1 };\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tif ((i + q) % 2 == 0) continue;\n\t\t\tint now_lcm = 1;\n\t\t\tREP(j, 4) {\n\t\t\t\tint x = xe[j] + i;\n\t\t\t\tint y = ye[j] + q;\n\t\t\t\tif (x >= 0 && x < 500 && y >= 0 && y < 500) {\n\t\t\t\t\tint hoge = gcd(now_lcm, grid[x][y]);\n\t\t\t\t\tnow_lcm /= hoge;\n\t\t\t\t\tnow_lcm *= grid[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid[i][q] = now_lcm + 1LL;\n\t\t\tassert(grid[i][q] <= 1000000000000000LL);\n\t\t}\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tREP(j, 4) {\n\t\t\t\tint x = xe[j] + i;\n\t\t\t\tint y = ye[j] + q;\n\t\t\t\tif (x >= 0 && x < 500 && y >= 0 && y < 500) {\n\t\t\t\t\tassert(max(grid[x][y], grid[i][q]) % min(grid[x][y], grid[i][q]) == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tREP(q, n) {\n\t\t\tif (q != 0) cout << \" \";\n\t\t\tcout << grid[i][q];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll a[510][510];\nbitset<10101> isp; vector<int> ps;\nvoid init(){\n   rep(i,2,10000)isp[i]=1;\n   rep(i,2,10000)if(isp[i]){\n      ps.push_back(i);\n      for(int j=i*i;j<10000;j+=i)isp[j]=0;\n   }\n}\n\nint main(){\n   int n; cin>>n; int idx=0;\n   rep(i,0,n)rep(j,0,n)a[i][j]=1;\n   init();\n   for(int d=-n+(n&1);d<n;d+=2){\n      rep(x,0,n)if(x+d>=0 and x+d<n){\n         a[x][x+d]*=ps[idx];\n         if(x!=n-1)a[x+1][x+d]*=ps[idx];\n         if(x+d!=n-1)a[x][x+d+1]*=ps[idx];\n      } idx++;\n   }\n   for(int d=0;d<=n*2-2;d+=2){\n      rep(x,0,n)if(d-x>=0 and d-x<n){\n         a[x][d-x]*=ps[idx];\n         if(x!=0)a[x-1][d-x]*=ps[idx];\n         if(d-x!=n-1)a[x][d-x+1]*=ps[idx];\n      } idx++;\n   }\n   rep(i,0,n)rep(j,0,n)if((i+j)&1)a[i][j]++;\n   rep(i,0,n){\n      rep(j,0,n)printf(\"%lld \",a[i][j]);\n      putchar('\\n');\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 500, dx[] = { 1, -1, 0, 0 }, dy[] = { 0, 0, 1, -1 };\nint n, c[maxn + 3][maxn + 3], d[maxn + 3][maxn + 3], num[maxn << 2 | 3];\nll a[maxn + 3][maxn + 3];\nbool b[maxn + 3][maxn + 3];\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b) {\n\tif (!a || !b) return a + b;\n\treturn a / gcd(a, b) * b;\n}\n\nint is_prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return false;\n\t}\n\treturn true;\n}\n\nbool valid(int x, int y) {\n\treturn x >= 1 && x <= n && y >= 1 && y <= n;\n}\n\nvoid work(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tb[i][j] = ~(i + j) & 1;\n\t\t}\n\t}\n\tint cur = 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (b[i][j]) {\n\t\t\t\tif (!num[i + j]) {\n\t\t\t\t\twhile (!is_prime(cur)) cur++;\n\t\t\t\t\tnum[i + j] = cur++;\n\t\t\t\t}\n\t\t\t\tc[i][j] = num[i + j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (b[i][j]) {\n\t\t\t\tif (!num[i - j + n * 3]) {\n\t\t\t\t\twhile (!is_prime(cur)) cur++;\n\t\t\t\t\tnum[i - j + n * 3] = cur++;\n\t\t\t\t}\n\t\t\t\td[i][j] = num[i - j + n * 3];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (b[i][j]) {\n\t\t\t\ta[i][j] = c[i][j] * d[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (!b[i][j]) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (valid(i + dx[k], j + dy[k])) {\n\t\t\t\t\t\ta[i][j] = lcm(a[i][j], a[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tif (n == 2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\twork(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tprintf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t  Author : @evenbao\n\t  Created : 2020 / 07 / 30\n*/\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define pii pair<int , int>\n#define mp make_pair\n#define fi first\n#define se second\n\nconst int MAXN = 2e5 + 10;\n\nint pc;\nint pr[MAXN] , f[MAXN];\nLL A[MAXN] , B[MAXN];\n\ntemplate <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }\ntemplate <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }\ntemplate <typename T> inline void read(T &x) {\n    T f = 1; x = 0;\n    char c = getchar();\n    for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n    x *= f;\n}\n\ninline void G(int n) {\n\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\t\tif (!f[i]) f[i] = pr[++pc] = i;\n\t\t\t\tfor (int j = 1; j <= pc && i * pr[j] <= n; ++j) {\n\t\t\t\t\t\tf[i * pr[j]] = pr[j];\n\t\t\t\t\t\tif (i % pr[j] == 0) break;\n\t\t\t\t}\n\t\t}\n}\nint main() {\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\" , &n); G(10000);\n\t\tfor (int i = 1; i <= n; ++i) A[i] = pr[i & 1 ? i / 2 + 1 : n + n - i / 2 + 1];\n\t\tfor (int i = 1; i <= n; ++i) B[i] = pr[(i & 1 ? n - i / 2 : n + i / 2) + (n & 1)];\n\t\tA[0] = A[n + 1] = B[0] = B[n + 1] = 1;\n\t\tfor (int i = 1; i <= n; ++i , printf(\"\\n\")) \n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\tif ((i + j) & 1) printf(\"%lld \" , (LL) A[(i + j) / 2] * A[(i + j) / 2 + 1] * B[(n + i - j + (n & 1)) / 2] * B[(n + i - j + (n & 1)) / 2 + 1] + 1);\n\t\t\t\telse printf(\"%lld \" , A[(i + j) / 2] * B[(n + i - j + (n & 1)) / 2]); \n\t  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=505;\nconst int M=4*N;\nconst int S=10000;\nint pr[M],psz;\nbool sieve[S];\nll val[N][N];\nvector<pair<int,int> > id;\nint Find(pair<int,int> x){ return lower_bound(id.begin(),id.end(),x)-id.begin()+1;}\nint main()\n{\n\tint i,j;\n\tfor(i=2;i<S;i++) if(!sieve[i]){ pr[++psz]=i;for(j=i;j<S;j+=i) sieve[j]=1;}\n\tint n;\n\tscanf(\"%i\",&n);\n\tif(n==2) return 0*printf(\"4 7\\n23 10\\n\");\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if(!((i+j)&1))\n\t{\n\t\tint a=i+j,b=i-j;\n\t\tid.pb(mp(1,a));\n\t\tid.pb(mp(2,b));\n\t}\n\tsort(id.begin(),id.end());\n\tid.erase(unique(id.begin(),id.end()),id.end());\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if(!((i+j)&1))\n\t{\n        int a=Find(mp(1,i+j));\n        int b=Find(mp(2,i-j));\n        val[i][j]=(ll)pr[a]*pr[b];\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n\t\tval[i][j]=1;\n\t\tll g=0;\n        if(i-1>0) val[i][j]*=val[i-1][j],g=__gcd(g,val[i-1][j]);\n        if(j-1>0) val[i][j]*=val[i][j-1],g=__gcd(g,val[i][j-1]);\n        if(i+1<=n) val[i][j]*=val[i+1][j],g=__gcd(g,val[i+1][j]);\n        if(j+1<=n) val[i][j]*=val[i][j+1],g=__gcd(g,val[i][j+1]);\n        val[i][j]/=g;\n        val[i][j]++;\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) printf(\"%lld%c\",val[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<bool> num(n, true);\n\tstd::vector<int> prime;\n\tnum[0] = false;\n\tfor (int i = 0; i*i < n; ++i) {\n\t\tif (num[i]) {\n\t\t\tfor (int j = 2; (i + 1)*j <= n; ++j) {\n\t\t\t\tnum[(i + 1)*j - 1] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (num[i]) {\n\t\t\tprime.push_back(i + 1);\n\t\t}\n\t}\n\treturn prime;\n}\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a%b) : a;\n}\n\nconstexpr int N = 500;\nint a[N][N];\nint b[N][N];\nint c[N][N];\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nsigned main() {\n\tINIT;\n\n\tauto pv(Eratosthenes(100000));\n\n\tint p = 0;\n\t{\n\t\t{\n\t\t\tint j = 0;\n\t\t\tRREP(i, N) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\ta[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tFOR(j, 1, N) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\ta[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\tFOR(i, 1, N) FOR(j, 1, N) a[i][j] = a[i - 1][j - 1];\n\t}\n\t{\n\t\t{\n\t\t\tint j = N - 1;\n\t\t\tRREP(i, N) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\tb[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tRREP(j, N - 1) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\tb[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\tFOR(i, 1, N) REP(j, N - 1) b[i][j] = b[i - 1][j + 1];\n\t\tREP(i, N) REP(j, N) c[i][j] = a[i][j] * b[i][j];\n\t}\n\n\tREP(i, N) REP(j, N) {\n\t\tif (a[i][j] != 0) continue;\n\t\tint t = 1;\n\t\tstd::set<int> set;\n\t\tREP(d, 4) {\n\t\t\tint dy = i + dy4[d];\n\t\t\tint dx = j + dx4[d];\n\t\t\tif (!IN(0, dy, N) || !IN(0, dx, N)) continue;\n\t\t\tif (!set.count(a[dy][dx])) t *= a[dy][dx];\n\t\t\tif (!set.count(b[dy][dx])) t *= b[dy][dx];\n\t\t\tset.insert(a[dy][dx]);\n\t\t\tset.insert(b[dy][dx]);\n\t\t}\n\t\tc[i][j] = t + 1;\n\t}\n\n\tVAR(int, n);\n\tstd::set<int> set;\n\tREP(i, n) REP(j, n) {\n\t\tassert(c[i][j] <= 1000000000000000);\n\t\tset.insert(c[i][j]);\n\t\tOUT(c[i][j])SPBR(j, n);\n\t}\n\tassert(set.size() == n * n);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nll gcd(ll a,ll b){\n    if(a%b==0){return b;}\n    return gcd(b,a%b);\n}\n\nll lcm(vector<ll> &A){\n    ll ret=1;\n    for(int i=0;i<A.size();i++){\n        ret/=gcd(ret,A[i]);\n        ret*=A[i];\n    }\n    return ret;\n}\n\n\n\n\nint main(){\n    ll mx=100000;\n    vector<bool> A(mx,1);\n    vector<ll> P;\n    for(ll i=2;i<mx;i++){\n        if(A[i]){\n            for(ll t=1;i*t<mx;t*=i){\n                P.push_back(i*t);\n            }\n            for(ll t=2;i*t<mx;t++){\n                A[i*t]=0;\n            }\n        }\n    }\n    sort(P.begin(),P.end());\n    vector<vector<ll>> a(500,vector<ll>(500,1));\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if((i+t)&1){\n                a[i][t]*=P[(i+t)/2];\n            }\n            if((i-t)&1){\n                a[i][t]*=P[500+(500+i-t)/2];\n            }\n        }\n    }\n    vector<ll> dx={0,1,0,-1};\n    vector<ll> dy={1,0,-1,0};\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if(a[i][t]==1){\n                vector<ll> A;\n                for(int h=0;h<4;h++){\n                    ll x=i+dx[h];\n                    ll y=t+dy[h];\n                    if(x<0 || y<0 || x>=500 || y>=500){continue;}\n                    A.push_back(a[x][y]);\n                }\n                a[i][t]=lcm(A)+1;\n            }\n        }\n    }\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<a[i][t];\n            if(t+1!=n){cout<<\" \";}\n        }\n        cout<<endl;\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n//最大公約数\nlint gcd( lint m, lint n )\n{\n\tlint a=max(m,n),b=min(m,n);\n\tif(m==0) return n;if(n==0) return m;\n\tif(a%b==0) return b;\n\treturn gcd(b,a-b*(a/b));\n}\n\n//最小公倍数\n//（超えそうだったらlong longにすること！）\nlint lcm( lint m, lint n )\n{\n\tif (( 0 == m ) || ( 0 == n )) return 0;\n\treturn ((m / gcd(m, n)) * n);\n}\nvector<lint> so;\nbool sos[10010];\nlint out[510][510];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nmap<lint,int> me;\nset<lint> se;\nint main()\n{\n\tlint inf=1000000000000000LL;\n\tmemset(sos,false,sizeof(sos));\n\tREP(i,2,10010){\n\t\tif(sos[i]) continue;\n\t\tfor(int j=i+i;j<10010;j+=i) sos[j]=true;\n\t\tif(i>501 && so.size()<510) so.pb(i);\n\t}\n\trep(i,500) rep(j,500){\n\t\tif((i+j)%2==0) continue;\n\t\tout[i][j]=so[i/2]*(j+2);\n\t\t//se.insert(out[i][j]);\n\t\t//cout<<i<<' '<<j<<' '<<out[i][j]<<endl;\n\t}\n\t//cout<<so.size()<<endl;\n\t//cout<<\"a\"<<endl;\n\t//cout<<so[0]<<endl;\n\t//cout<<so[250]<<endl;\n\trep(i,500) rep(j,500){\n\t\tif((i+j)%2==1) continue;\n\t\tout[i][j]=1;\n\t\tout[i][j]*=so[i/2];\n\t\tout[i][j]*=so[(i+1)/2];\n\t\t//if(i+j<1) cout<<out[i][j]<<endl;\n\t\t//cout<<out[i][j]<<endl;\n\t\tfor(int k=max(0,j-1);k<min(500,j+2);k++) out[i][j]*=(k+2);\n\t\t//if(i+j<1) cout<<out[i][j]<<endl;\n\t\tout[i][j]++;\n\t\t//cout<<out[i][j]<<endl;\n\t\t/*rep(k,4){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x<0 || y<0 || x>499 || y>499) continue;\n\t\t\tout[i][j]=lcm(out[i][j],out[x][y]);\n\t\t}\n\t\tlint t=1;\n\t\twhile(se.find(out[i][j]*t)!=se.end()) t++;\n\t\tout[i][j]*=t;\n\t\tse.insert(out[i][j]);\n\t\tout[i][j]++;*/\n\t}\n\trep(i,500) rep(j,500){\n\t\t//assert(out[i][j]<=inf);\n\t\t/*if(out[i][j]>=inf){\n\t\t\tcout<<out[i][j]<<endl;\n\t\t}*/\n\t\t//assert(!me[out[i][j]]);\n\t\t/*if(me[out[i][j]]>0){\n\t\t\tcout<<out[i][j]<<' '<<me[out[i][j]]<<endl;\n\t\t}*/\n\t\tme[out[i][j]]++;\n\t\trep(k,4){\n\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\tif(x<0 || y<0 || x>499 || y>499) continue;\n\t\t\tlint a=max(out[i][j],out[x][y]),b=min(out[i][j],out[x][y]);\n\t\t\t/*if(a%b!=1LL){\n\t\t\t\tcout<<i<<' '<<j<<' '<<x<<' '<<y<<' '<<a<<' '<<b<<endl;\n\t\t\t}*/\n\t\t}\n\t}\n\tint n;cin>>n;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcout<<out[i][j];\n\t\t\tif(j<n-1) cout<<' ';else cout<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=550,M=100100;\nint n,m,p[M],ck[M];\nll a[N][N];\nvoid ini(int n){\n\tFOR(i,2,n){\n\t\tif(!ck[i]) p[++m]=i;\n\t\tFOR(j,1,m){\n\t\t\tif(i*p[j]>n) break;\n\t\t\tck[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){return x&&y?x/gcd(x,y)*y:x|y;}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);ini(100000);n+=2;\n\tFOR(i,1,n)FOR(j,1,n)if(i+j&1)\n\t\ta[i][j]=1ll*p[i+j]*p[i-j+n+!(n&1)];\n\tFOR(i,1,n)FOR(j,1,n)if(!a[i][j]){\n\t\ta[i][j]=a[i-1][j];\n\t\ta[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\ta[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\ta[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\ta[i][j]++;\n\t}\n\tFOR(i,2,n-1)FOR(j,2,n-1) cout<<a[i][j]<<\" \\n\"[j==n-1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nbool Isprime[233333];\nll prime[233333];\nvoid init(int T){\n\tmem(Isprime,true);*prime = 0;\n\tfor(int i=2;i<=T;i++){\n\t\tif(Isprime[i]){\n\t\t\tprime[++*prime] = i;\n\t\t}\n\t\tfor(int j=1;j<=*prime && i * prime[j] <= T;++j){\n\t\t\tIsprime[i*prime[j]] = false;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nll mp1[233333],mp2[233333];\nll ans[505][505],n;\nint main(){\n\tinit(8000);\n\tn = rd();\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tll wzp = 0;\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp1[i+j]) mp1[i+j] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp2[i-j+n]) mp2[i-j+n] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n){\n\t\tif((i+j)&1) ans[i][j] = (ll)mp1[i+j]*mp2[i-j+n];\n\t}\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tll tmp = 1;\n\t\tif(1<=i-1) tmp = tmp * ans[i-1][j] / __gcd(tmp,ans[i-1][j]);\n\t\tif(1<=j-1) tmp = tmp * ans[i][j-1] / __gcd(tmp,ans[i][j-1]);\n\t\tif(i+1<=n) tmp = tmp * ans[i+1][j] / __gcd(tmp,ans[i+1][j]);\n\t\tif(j+1<=n) tmp = tmp * ans[i][j+1] / __gcd(tmp,ans[i][j+1]);\n\t\tans[i][j] = tmp + 1;\n\t}\n\tRep(i,1,n){\n\t\tRep(j,1,n)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nconst ll ccc=1000000;\nbool prime[ccc+1];\nvector<ll> pr;\nvoid makeprime(){\n\tll i,j;\n\tfor(i=2;i<=ccc;i++) prime[i]=true;\n\tfor(i=2;i*i<=ccc;i++) if(prime[i]) for(j=2;j*i<=ccc;j++) prime[j*i]=false;\n\tfor(i=2;i<=ccc;i++) if(prime[i]) pr.push_back(i);\n}\nll ans[500][500];\nint main(){\n\tmakeprime();\n\tconst int N = 500;\n\tint off = N+1;\n\trep(i,N) rep(j,N){\n\t\tif((i+j)%2==0){\t//small\n\t\t\tint x = (i+j)/2;\n\t\t\tint y = (i-j+N)/2 + off;\n\t\t\tans[i][j] = pr[x] * pr[y];\n\t\t}else{\n\t\t\tint x = (i+j)/2;\n\t\t\tint y = (i-j+N)/2 + off;\n\t\t\tans[i][j] = pr[x]*pr[x+1]*pr[y]*pr[y+1] + 1;\n\t\t}\n\t}\n\trep(i,N) rep(j,N) assert(ans[i][j] <= 1000000000000000LL);\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,n) cout<<ans[i][j]<<\" \";\n\t\tputs(\"\");\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 500\n#define NN 8000\n#define INF 1LL << 60\n\nint n;\nlong long a[N][N];\nint prime[2*N];\nchar tbl[NN];\n\nlong long gcd(long long x, long long y)\n{\n\tlong long r;\n\n\tif( x < y ) {\n\t\tswap( x, y );\n\t}\n\twhile((r = x % y) != 0) {\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn y;\n}\n\nlong long lcm(long long x, long long y)\n{\n\treturn (x * (y / gcd(x, y) ) );\n}\n\nint main()\n{\n\tcin >> n;\n\n\tif( n == 2 ) {\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\n\t// create prime table\n\ttbl[0] = tbl[1] = 1;\n\tfor( int i = 0; i < NN; i++ ) {\n\t\tif( !tbl[i] ) {\n\t\t\tfor( int j = i + i; j < NN; j += i ) {\n\t\t\t\ttbl[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint idx = 0;\n\tfor( int i = 0; i < NN; i++ ) {\n\t\tif( !tbl[i] ) {\n\t\t\tprime[idx] = i;\n\t\t\tidx++;\n\t\t\tif( idx >= 2*N ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tif( ( (i + j) % 2) == 0 ) {\n\t\t\t\tint idx1 = (i - j + n - 1) / 2;\n\t\t\t\tint idx2 = (i + j) / 2;\n\t\t\t\ta[i][j] = (long long)prime[idx1] * prime[idx2 + n];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tif(  ( (i + j) % 2) != 0 ) {\n\t\t\t\tlong long aa[4] = {0};\n\t\t\t\tint li = i - 1;\n\t\t\t\tint ri = i + 1;\n\t\t\t\tint uj = j - 1;\n\t\t\t\tint dj = j + 1;\n\t\t\t\tif( li >= 0 ) {\n\t\t\t\t\taa[0] = a[li][j];\n\t\t\t\t}\n\t\t\t\tif( ri < n ) {\n\t\t\t\t\taa[1] = a[ri][j];\n\t\t\t\t}\n\t\t\t\tif( uj >= 0 ) {\n\t\t\t\t\taa[2] = a[i][uj];\n\t\t\t\t}\n\t\t\t\tif( dj < n ) {\n\t\t\t\t\taa[3] = a[i][dj];\n\t\t\t\t}\n\t\t\t\tlong long l = 0;\n\t\t\t\tfor( int k = 0; k < 4; k++ ) {\n\t\t\t\t\tif( aa[k] ) {\n\t\t\t\t\t\tif( l == 0 ) {\n\t\t\t\t\t\t\tl = aa[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tl = lcm( l, aa[k] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j] = l + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\tfor( int j = 0; j < n; j++ ) {\n\t\t\tcout << a[i][j];\n\t\t\tif( j == n - 1 ) {\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) (int)x.size()\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAXN = 505;\nconst int MAX = 5e5;\n\nll n;\nll a[MAXN][MAXN];\nvector <int> prime;\nbool bio[MAX];\n\nll gcm(ll a, ll b){\n    return a / __gcd(a, b) * b;\n}\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n\n        prime.pb(i);\n\n        for(int j = i; j < MAX; j += i){\n            bio[j] = true;\n        }\n    }\n}\n\nvoid diagonala1(){\n    int x = 0, y = 0, cnt = 0;\n\n    while(y < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] = prime[cnt];\n            nx ++; ny --;\n        }\n\n        y += 2; cnt ++;\n    }\n\n    x = 0, y = n - 1;\n    if(!a[0][n - 1])\n        x = 1;\n    x += 2;\n\n    while(x < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] = prime[cnt];\n            nx ++; ny --;\n        }\n\n        x += 2; cnt ++;\n    }\n}\n\nvoid diagonala2(){\n    int x = 0, y = 0, cnt = 0;\n\n    while(y < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny < n){\n            a[nx][ny] *= prime[cnt];\n            nx ++; ny ++;\n        }\n\n        y += 2; cnt ++;\n    }\n\n    x = 0, y = n - 1;\n    if(!a[n - 1][0])\n        x = 1;\n\n    while(x < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny < n){\n            a[nx][ny] *= prime[cnt];\n            nx ++; ny ++;\n        }\n\n        x += 2; cnt ++;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    sito();\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    diagonala1();\n    diagonala2();\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j]) continue;\n\n            ll sol = 1;\n            if(i > 0) sol = gcm(sol, a[i - 1][j]);\n            if(j > 0) sol = gcm(sol, a[i][j - 1]);\n            if(i < n - 1) sol = gcm(sol, a[i + 1][j]);\n            if(j < n - 1) sol = gcm(sol, a[i][j + 1]);\n\n            a[i][j] = sol + 1;\n\n        }\n\n    REP(i, n){\n        REP(j, n)\n            cout << a[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 200005\n#define mo 994711\n//#define ivorysi\nusing namespace std;\ntypedef unsigned long long int64;\ntypedef long double db;\ntypedef unsigned int u32;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 + c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nint N;\nint64 a[505][505];\nbool nonprime[50005];\nint prime[50005],tot;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nmap<int64,pii > mmm;\nint64 gcd(int64 a,int64 b) {\n    return b == 0 ? a : gcd(b,a % b);\n}\nint64 Calc(int x,int y) {\n    int64 res = 1;\n    for(int k = 0 ; k <= 3 ; ++k) {\n\tint tx = x + dx[k],ty = y + dy[k];\n\tif(tx < 1 || tx > N || ty < 1 || ty > N) continue;\n\tres = res / gcd(res,a[tx][ty]) * a[tx][ty];\n    }\n    return res + 1;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 2 ; i <= 50000 ; ++i) {\n\tif(!nonprime[i]) {\n\t    prime[++tot] = i; \n\t}\n\tfor(int j = 1 ; j <= tot ; ++j) {\n\t    if(prime[j] > 50000 / i) break;\n\t    nonprime[i * prime[j]] = 1;\n\t    if(i % prime[j] == 0) break;\n\t}\n    }\n    int st = 1;\n    for(int s = 2 ; s <= N + N ; s += 2) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = s - i;\n\t    if(j < 1 || j > N) continue;\n\t    a[i][j] = prime[st];\n\t}\n\t++st;\n    }\n    int k = N & 1 ? 1 - N : 2 - N;\n    for(int s = k ; s <= N ; s += 2) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = i - s;\n\t    if(j < 1 || j > N) continue;\n\t    a[i][j] = a[i][j] * prime[st];\n\t}\n\t++st;\n    } \n    for(int s = 3 ; s <= N + N ; s += 2) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = s - i;\n\t    if(j < 1 || j > N) continue;\n\t    if(i == 409 && j == 101) {\n\t\tputs(\"QAQ\");\n\t    }\n\t    a[i][j] = Calc(i,j);\n\t    \n\t}\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tfor(int j = 1 ; j <= N ; ++j) {\n\t    out(a[i][j]);\n\t    j == N ? 0 : space;\n\t}\n\tenter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n \nint n,cnt;\nint mark[N * 10];\nlong long pri[N], a[N][N];\n \nvoid getpri() {\n  for (int i=2;i<=10000;i++) {\n    if (!mark[i]) pri[++cnt]=i;\n    if (cnt==1000) break;\n    for (int j=1;j<=cnt && i*pri[j]<=10000;j++) {\n      mark[i*pri[j]]=1;\n      if (i%pri[j]==0) break;\n    }\n  }\n}\n \nlong long lcm(long long x,long long y) {\n  if (!x || !y) return x+y;\n  return x/__gcd(x,y)*y;\n}\n \nint main()\n{\n  getpri();\n  scanf(\"%d\",&n);\n  if (n==2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n  for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n      if ((i+j)%2==0)\n\ta[i][j]=pri[(i+j)/2]*pri[n+(i-j)/2+(n+1)/2];\n  for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n      if (!a[i][j])\n\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n  for (int i=1;i<=n;i++) {\n    for (int j=1;j<=n;j++)\n      printf(\"%lld \",a[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[1100],na,n;\nbool p(int x){for (int i=2;i<x;i++)if (x%i==0)return 0;return 1;}\nint main(){\n\tfor (int i=2;i<=8000;i++)if (p(i))a[++na]=i;\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)cout<<a[(i+j)/2]*a[(i-j+n)/2+n]<<' ';\n\t\t\telse cout<<a[(i+j)/2]*a[(i-j+n)/2+n]*a[(i+j+1)/2]*a[(i-j+n+1)/2+n]<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define INF (1ll<<60)\n\n\n\nlong long gcd(long long x, long long y){\n    if(y==0)return x;\n    return gcd(y,x%y);\n}\n\nint main(int argc, char const *argv[]) {\n    int n;cin>>n;\n    set<long long> used;\n    long long M = 3;\n    n+=2*M;\n    vector<vector<long long>> res(n,vector<long long>(n,-1));\n    long long s = 2;\n    for(int i=1;i<n-1;++i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            // if((tmpi==0&tmpk==0)||(tmpi==0&tmpk==4)||(tmpi==4&tmpk==2)||(tmpi==4&tmpk==6)){\n            if((tmpi==0&tmpk==0)||(tmpi==4&tmpk==2)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                while(used.find(s)!=used.end())s+=1;\n            }\n        }\n    }\n    for(int i=n-2;i>0;--i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            if((tmpi==0&tmpk==4)||(tmpi==4&tmpk==6)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i-1][k] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i+1][k] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i][k-1] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i][k+1] = ss;\n                // used.insert(ss);\n                while(used.find(s)!=used.end())s+=1;\n            }\n        }\n    }\n    for(int i=M;i<n-M;++i){\n        for(int k=M;k<n-M;++k){\n            if((i+k)%2==0){\n                long long tmp = 1,tt;\n                tt = res[i+1][k];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i-1][k];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i][k+1];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i][k-1];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = 1;\n                while(used.find(tt*tmp+1)!=used.end())tt++;\n                res[i][k] = tt*tmp+1;\n                used.insert(tt*tmp+1);\n            }\n        }\n    }\n    for(int i=M;i<n-M;++i){\n        for(int k=M;k<n-M;++k){\n            cout<<res[i][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    auto itr = used.end();\n    itr--;\n    // cout<<*itr<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 510;\nint p[10010];\nvector<int> primes;\nint a[N * 2], b[N * 2];\n\nvoid init() {\n    for (int i = 2; i < 10000; i++) {\n        if (!p[i]) {\n            for (int j = i + i; j < 10000; j += i) {\n                p[j] = 1;    \n            }\n            primes.push_back(i);\n        }\n    }\n}\n\nlong long res[N][N];\nset<long long> has;\n\nlong long lcm(long long a, long long b) {\n    long long c = __gcd(a, b);\n    return a * b / c;    \n}\n\nint main() {\n    init();    \n    int n;\n    scanf(\"%d\", &n);\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        a[i] = primes[cnt++];\n    }   \n    for (int i = 0; i < n; i++) {\n        b[i] = primes[cnt++];\n    }\n    memset(res, -1, sizeof res);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0) {\n                int aa = i + j >> 1;\n                int bb = (i - j + n) >> 1;\n                res[i][j] = 1ll * a[aa] * b[bb];\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0) {\n                continue;\n            }\n            long long foo = 1ll;\n            if (i > 0) {\n                foo = lcm(foo, res[i - 1][j]);\n            }\n            if (i + 1 < n) {\n                foo = lcm(foo, res[i + 1][j]);\n            }\n            if (j > 0) {\n                foo = lcm(foo, res[i][j - 1]);\n            }\n            if (j + 1 < n) {\n                foo = lcm(foo, res[i][j + 1]);\n            }\n            int it = 1;\n            while (has.count(foo * it)) {\n                it++;\n            }\n            has.insert(foo * it);\n            res[i][j] = foo * it + 1;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%lld \", res[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stdint>\nusing namespace std;\n\nconst int MAX = 1000000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 4 << \" \" << 7 << endl << 23 << \" \" << 10; // サンプルケースですね\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX];\n\tfor (int i = 0;i < MAX;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\tcout << prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積\n\t\t\t\tcout << (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i - j - 1) / 2];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは0だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define MOD 1000000007\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\ntypedef unsigned long long int ull;\ntypedef long long lint;\n\nlint LCM(lint a,lint b){\n  if(a==0 || b==0) return 0;\n  lint tmp,r,x;\n  x=a*b;\n  if(a<b) tmp=a,a=b,b=tmp;\n  r=a%b;\n  while(r!=0) a=b,b=r,r=a%b;\n  x=x/b;\n  return x;\n}\n\nlint GCD(lint a,lint b){\n  if(a==0 || b==0) return max(a,b);\n  else return (a*b)/LCM(a,b);\n}\n\nvector<bool> prime;\nvoid primeinit(int N){\n    if(N+1>prime.size()){\n        prime.resize(N+1,true);\n    } \n    prime[0] = false;\n    prime[1] = false;\n    for(int i=2; i*i<=N;i++) if(prime[i]) for(int j=2; i*j<=N;j++) prime[i*j]=false;\n}\n\n\nint main(void){\n    primeinit(1000000);\n    int N;\n    cin >> N;\n    int put=N;\n    N=500;\n    lint primeno[1000];\n    lint ans[N][N];\n    rep(i,N) rep(j,N) ans[i][j]=1;\n    lint now=0;\n    rep(i,1000){\n        while(!prime[now]) now++;\n        primeno[i]=now;\n        now++;\n    }\n    int no=0;\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n        x=i,y=0;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    for(int i=2;i<N;i++){\n        int x=0,y=i;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n    }\n    for(int i=1;i<N;i++){\n        int x=N-1,y=i;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    rep(i,N) rep(j,N){\n        if(ans[i][j]==1){\n            lint in=1;\n            if(i!=0) in=LCM(in,ans[i-1][j]);\n            if(i!=N-1) in=LCM(in,ans[i+1][j]);\n            if(j!=0) in=LCM(in,ans[i][j-1]);\n            if(j!=N-1) in=LCM(in,ans[i][j+1]);\n            ans[i][j]=in+1;\n        }\n    }\n    rep(i,put){\n        rep(j,put) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <set>\n#include <list>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\n#define fi first\t\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\n\nvector<long> vec;\nbool prime(int x)\n{\n\tfor(int i = 2; i <= sqrt(x); i++)\n\t{\n\t\tif(x%i == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\nlong MAXN = 500;\nlong A[503][503];\nlong gcd(long a, long b) {return (b)? gcd(b,a%b) : a;}\nlong lcm(long a, long b) \n{\n\tif(a == b && b == 0) return 0;\n\telse if(a == 0) return b;\n\telse if(b == 0) return a;\n\telse return a/gcd(a,b)*b;\n}\n\nint main()\n{\n\t// ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\n\tfor(int i = 2; i <= 10000; i++)\n\t\tif(prime(i))\n\t\t\tvec.push_back(i);\n\n\tint n; scanf(\"%d\", &n);\n\n\tint idx = 0;\n\tfor(int i = 1; i <= MAXN; i+=2)\n\t{\n\t\tint x = 1, y = i;\n\t\twhile(y <= MAXN)\n\t\t\tA[x++][y++] = vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = 3; i <= MAXN; i+=2)\n\t{\n\t\tint x = i, y = 1;\n\t\twhile(x <= MAXN)\n\t\t\tA[x++][y++] = vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = 1; i <= MAXN; i+=2)\n\t{\n\t\tint x = 1, y = i;\n\t\twhile(y >= 1 && x <= MAXN)\n\t\t\tA[x++][y--] *= vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = MAXN; i >= 2; i-=2)\n\t{\n\t\tint x = i, y = MAXN;\n\t\twhile(y >= 1 && x <= MAXN)\n\t\t\tA[x++][y--] *= vec[idx];\n\t\tidx++;\n\t}\n\n\tlong mx = 0;\n\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(A[i][j] == 0) A[i][j] = lcm(lcm(A[i-1][j],A[i][j-1]),lcm(A[i+1][j],A[i][j+1]))+1;\n\t\t\t// mxnax(A[i][j],mx);\n\t\t\tprintf(\"%lld\", A[i][j]);\n\t\t\tif(j < n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t// printf(\"%lld\\n\", mx);\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 100005;\n\nint di[] = { -1, 0, 0, 1 };\nint dj[] = { 0, -1, 1, 0 };\n\nint n;\nbool p[100005];\nvi primes;\n\nvoid sieve() {\n\tMMS(p, 1);\n\tp[0] = p[1] = 0;\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i]) {\n\t\t\tfor (int j = 2 * i; j < N; j += i)\n\t\t\t\tp[j] = 0;\n\t\t}\n\t}\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i])\n\t\t\tprimes.pb(i);\n\t}\n}\n\nll a[501][501];\n\nll setV(int i, int j) {\n\tint d0 = (i + j) >> 1;\n\tint d1 = n + ((i - j + n - 1) >> 1);\n\treturn primes[d0] * 1LL * primes[d1];\n}\n\nll get(int i, int j) {\n\tif (i < 0 || i >= n || j < 0 || j >= n)\n\t\treturn -1;\n\treturn a[i][j];\n}\n\nll calc(int i, int j) {\n\tll res = 1;\n\tfor (int d = 0; d < 4; d++) {\n\t\tint ni = i + di[d];\n\t\tint nj = j + dj[d];\n\t\tll v = get(ni, nj);\n\t\tif (v != -1)\n\t\t\tres = (res * v) / __gcd(res, v);\n\t}\n\treturn res + 1;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tsieve();\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1) == 0) {\n\t\t\t\ta[i][j] = setV(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1)) {\n\t\t\t\ta[i][j] = calc(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\ta[1][0] *= 2;\n\t\ta[1][0]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j == n - 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n \nconst int N=505;\nconst int LIM=8000;\nint fl[LIM],pri[LIM],n;\nvoid initprime(){\n\tFor(i,2,LIM-1) For(j,2,(LIM-1)/i) fl[i*j]=1;\n\tFor(i,1,LIM-1) if (!fl[i]) pri[++*pri]=i;\n}\nmap<int,int> mp1,mp2;\nmap<ll,int> mp3;\nll ans[N][N];\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid work(){\n\tint l=4;\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp1[i+j]) mp1[i+j]=pri[l++];\n\t\tif (l>333) l=4;\n\t\tans[i][j]=mp1[i+j];\n\t}\n\tl=4;\n\tRep(i,n,1) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp2[i-j]) mp2[i-j]=pri[l++];\n\t\tif (l>333) l=4;\n\t\tans[i][j]*=mp2[i-j];\n\t}\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tint v=mp1[i+j]*mp2[i-j];\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=v);\n\t\tmp3[ans[i][j]]++;\n\t}\n\tll mx=0;\n\tFor(i,1,n) For(j,1,n) if (!ans[i][j]){\n\t\tll lcm=1;\n\t\tif (i!=1) lcm*=ans[i-1][j]/gcd(ans[i-1][j],lcm);\n\t\tif (i!=n) lcm*=ans[i+1][j]/gcd(ans[i+1][j],lcm);\n\t\tif (j!=1) lcm*=ans[i][j-1]/gcd(ans[i][j-1],lcm);\n\t\tif (j!=n) lcm*=ans[i][j+1]/gcd(ans[i][j+1],lcm);\n\t\tans[i][j]=lcm+1;\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=lcm);\n\t\tmp3[ans[i][j]]=1;\n\t\tmx=max(mx,ans[i][j]);\n\t}\n\tFor(i,1,n){\n\t\tFor(j,1,n) printf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tinitprime();\n\twork();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\nusing ll = long long;\nconst ll MOD = 1000000007;\n\nll A[520][520];\n\nint main() {\n\tfor (int i = 0;i < 520;i++) {\n\t\tfor (int j = 0;j < 520;j++) {\n\t\t\tA[i][j] = -1;\n\t\t}\n\t}\n\tset<ll> S;\n\tpriority_queue<ll> T;\n\tbool w;\n\tfor (int i = 5;;i++) {\n\t\tw = 1;\n\t\tif (i % 2 == 0)continue;\n\t\tif (i % 3 == 0)continue;\n\t\tfor (int x : S) {\n\t\t\tif (i % x == 0) {\n\t\t\t\tw = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (w) {\n\t\t\tS.insert(i);\n\t\t\tif (i > 550)T.push(i);\n\t\t\tif (T.size() == 1200)break;\n\t\t}\n\t}\n\tfor (int i = 1;i < 520;i += 2) {\n\t\tll a = i, b = 1, c = T.top();T.pop();\n\t\twhile (a < 520 && b < 520) {\n\t\t\tA[a][b] = c * (a + b);\n\t\t\ta++;b++;\n\t\t}\n\t}\n\tfor (int i = 3;i < 520;i += 2) {\n\t\tll a = 1, b = i, c = T.top();T.pop();\n\t\twhile (a < 520 && b < 520) {\n\t\t\tA[a][b] = c * (a + b);\n\t\t\ta++;b++;\n\t\t}\n\t}\n\n\tfor (int i = 5;i < 513;i++) {\n\t\tfor (int j = 5;j < 513;j++) {\n\t\t\tif (A[i][j] >= 0)continue;\n\t\t\tA[i][j] = A[i - 1][j] * A[i + 1][j] + 1LL;\n\t\t}\n\t}\n\n\tint N;\n\tcin >> N;\n\tfor (int i = 0;i < N;i++) {\n\t\tfor (int j = 0;j < N;j++) {\n\t\t\tcout << A[i + 8][j + 8];\n\t\t\tif (j == N - 1)cout << \"\\n\";\n\t\t\telse cout << \" \";\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 512\n#define ll long long\nint n;\nll a[maxn][maxn];\nbool vis[10240];\nll prim[10240],cnt;\nvoid getprim()\n{\n\tfor(int i=2;i<10240;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tprim[cnt]=i;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*prim[j]<10240;j++)\n\t\t{\n\t\t\tvis[i*prim[j]]=1;\n\t\t\tif(i%prim[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nll gcd(ll a,ll b)\n{\n\tif(!b)\n\t{\n\t\treturn a;\n\t}else\n\t{\n\t\treturn gcd(b,a%b);\n\t}\n}\nll lcm(ll a,ll b)\n{\n\tif(a==0||b==0)\n\t{\n\t\treturn a+b;\n\t}else\n\t{\n\t\treturn a*b/gcd(a,b);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tgetprim();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n\t\t{\n\t\t\ta[i][j]=prim[(i+j)/2]*prim[n+(i-j)/2+(n+1)/2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t{\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }               \n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint pri[N]; bool vis[N];\nvoid init (int n)\n{\n\tfor (int i=2; ; i++)\n\t{\n\t\tif (!vis[i]) pri[++pri[0]]=i;\n\t\tif (pri[0]==n) break;\n\t\tfor (int j=1; j<=pri[0]; j++)\n\t\t{\n\t\t\tint p=pri[j],k=i*p;\n\t\t\tif (k> 10000) break;\n\t\t\tvis[k]=1;\n\t\t\tif (i%p==0) break;\n\t\t}\n\t}\n}\nLL lcm (LL x,LL y) { return (!x||!y)?(x+y):(x*y/__gcd (x,y)); }\nint n; LL a[1010][1010];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n); init (1000);\n\tif (n==2) return puts(\"4 7\\n23 10\"),0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if ((i+j+1)&1)\n\t\t\ta[i][j]=pri[(i+j)/2]*pri[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if (!a[i][j])\n\t\t\ta[i][j]=lcm (lcm (a[i-1][j],a[i][j-1]),lcm (a[i+1][j],a[i][j+1]))+1;\n\tfor (int i=1; i<=n; i++,putchar('\\n'))\n\t\tfor (int j=1; j<=n; j++,putchar(' '))\n\t\t\tprint(a[i][j]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n\n#define int long long \n\nconst int LIM = 2e6 + 7;\nconst int N = 500;\n\nint pr[LIM];\nvector<int> primes;\n\n\nvoid init() {\n    fill(pr, pr + LIM, 1);\n    for (int i = 2; i < LIM; i++) {\n        if (pr[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < LIM; j += i) {\n                pr[j] = 0;\n            }\n        }\n    }\n}\n\nint ans[N][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ans[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) & 1) {\n                ans[i][j] *= primes[i + j];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i - j) % 2 != 0) {\n                ans[i][j] *= primes[(i - j) + N];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                assert(ans[i][j] == 1);\n                if (i > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n                }\n                if (j > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n                }\n                if (i + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n                }\n                if (j + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n                }\n                // cerr << ans[i][j] << '\\n';\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int inf = 1 << 30;\n\nint n;\nLL a[505][505];\n\nLL gcd(LL a,LL b){\n\treturn !b?a:gcd(b,a%b);\n}\nLL lcm(LL a,LL b){\n\tif(a==0)return b;\n\tif(b==0)return a;\n\treturn a/gcd(a,b)*b;\n}\n\nint main(){\n\tLL cnt=0;\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=(i%2==0)+1;j<=n;j+=2){\n\t\t\ta[i][j]=++cnt;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!a[i][j]){\n\t\t\t\ta[i][j]=lcm(lcm(lcm(a[i-1][j],a[i][j-1]),a[i][j+1]),a[i+1][j])+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    long long N,a[500][500];\n    cin >> N;\n    for(int i = 0;i < N;i ++){\n        if(i == 0)for(int j = 0;j < N;j ++){\n            cout << 2*j+3 << \" \";\n            a[i][j] = 2*j+3;\n        }\n        else for(int j = 0;j < N;j ++){\n            if(j == 0){\n                cout << a[i-1][0]*a[i-1][N-1]+2 << \" \";\n                a[i][j] = a[i-1][0]*a[i-1][N-1]+2;\n            }else{\n                cout << a[i][j-1]*a[i-1][j]+2 << \" \";\n                a[i][j] = a[i][j-1]*a[i-1][j]+2;\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    vector<vector<ll>> a(500,vector<ll>(500,0));\n    vector<int> isPrime(5000,true);\n    vector<ll> primes;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            primes.push_back(i);\n            for(int j=2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n    set<ll> vs;\n\n    for(int i=0;i<500;i++){\n        for(int j=i%2;j<500;j+=2){\n            a[i][j]=primes[i/2]*primes[j/2];\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    auto isRange=[](int x,int y){\n        return 0<=x && x<500 && 0<=y && y<500;\n    };\n    auto lcm=[](ll x,ll y){\n        return x/__gcd(x,y)*y;\n    };\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n\n    for(int i=0;i<500;i++){\n        for(int j=(i+1)%2;j<500;j+=2){\n            ll v=1;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dx[k],j+dy[k])){\n                    v=lcm(v,a[i+dx[k]][j+dy[k]]);\n                }\n            }\n            a[i][j]=v;\n            int tmp=2;\n            while(vs.count(a[i][j]+1)){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            a[i][j]++;\n            if(a[i][j]<=1e15) vs.insert(a[i][j]);\n        }\n    }\n    int n;\n    cin>>n;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j+1<n;j++){\n            if(a[i][j]>1e15){\n                cnt++;\n                int tmp=1;\n                bool isok=true;\n                do{\n                    tmp++;\n                    isok=true;\n                    for(int k=0;k<4;k++){\n                        if(isRange(i+dx[k],j+dy[k])){\n                            isok&=(a[i+dx[k]][j+dy[k]]%tmp==1);\n                        }\n                    }\n                }while(!isok && !vs.count(a[i][j]=tmp));\n                vs.insert(a[i][j]);\n            }\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<a[i][n-1]<<endl;\n    }\n    //cerr<<cnt<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong gcd(long a, long b) {\n\tfor (; b; swap(a, b))\n\t\ta %= b;\n\treturn a;\n}\nlong lcm(long a, long b) {\n\ta /= gcd(a, b);\n\tif (double(a)*b > 1e15)\n\t\tthrow 0;\n\treturn a * b;\n}\nlong lcm(long a, long b, long c, long d) {\n\treturn lcm(lcm(a, b), lcm(c, d));\n}\nlong a[555][555];\nint main() {\n\tint N;\n\tcin >> N;\n\tint n = 500;\n\tlong x = 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2) continue;\n\t\t\tif (i % 2) {\n\t\t\t\ta[i][j] = a[i - 1][j - 1] * 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j] = x;\n\t\t\tx += 2;\n\t\t}\n\t}\n\tint s[] = { 0,1,0,-1,0 };\n\tset<long> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) continue;\n\t\t\tlong y[] = { 1,1,1,1 };\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\tif (i + s[k] >= 0 && i + s[k] < n&&j + s[k + 1] >= 0 && j + s[k + 1] < n)\n\t\t\t\t\ty[k] = a[i + s[k]][j + s[k + 1]];\n\t\t\tlong l = lcm(y[0], y[1], y[2], y[3]);\n\t\t\tlong m = 1;\n\t\t\twhile (q.find(m*l + 1) != q.end())\n\t\t\t\tm++;\n\t\t\tq.insert(m*l + 1);\n\t\t\ta[i][j] = m * l + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nlong long gcd(re long long a,re long long b){return b?gcd(b,a%b):a;}\nlong long lcm(re long long a,re long long b){return a/gcd(a,b)*b;}\nlong long a[510][510],pri[1010],cnt;\nbool vis[100100];\nint main()\n{\n\tre int n;\n\tscanf(\"%d\",&n);\n\tif(n==2){puts(\"4 7\\n23 10\");return 0;}\n\tfor(re int i=2;cnt<=1000;i++)\n\t{\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tfor(re int j=1;j<=cnt&&i*pri[j]<=100000;j++)\n\t\t{\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(re int i=-n+1+(!(n&1)),i1=1;i<n;i+=2,i1++)\n\t{\n\t\tfor(re int j=1;j<=n&&i+j<=n;j++)if(i+j>0)a[j][i+j]=pri[i1];\n\t}\n\tfor(re int i=2,i1=n+1;i<=2*n;i+=2,i1++)\n\t{\n\t\tfor(re int j=1;j<=n&&i-j>0;j++)a[j][i-j]*=pri[i1];\n\t}\n\tfor(re int i=1;i<=n;i++)a[i][0]=a[0][i]=a[i][n+1]=a[n+1][i]=1;\n\tfor(re int i=1;i<=n;i++,puts(\"\"))for(re int j=1;j<=n;j++)\n\t{\n\t\tif(!a[i][j])a[i][j]=lcm(lcm(a[i+1][j],a[i-1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\t\tprintf(\"%lld \",a[i][j]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = *this^(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n///////////////////////////\nbool prime(ll n) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return false; }\n\t}\n\treturn true;\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\tvector<ll> p;\n\n\trep(i, 10000) {\n\t\tif (i>2&&prime(i)) { p.push_back(i); }\n\t}\n\n\tll M = (N + 1) / 2+1;\n\n\tvvll a(N + 2, vll(N + 2, 1));\n\n\tset<ll> st;\n\n\trep(i, N+2) {\n\t\trep(j, N+2) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\ta[i][j] = p[i / 2] * p[j / 2 + M];\n\t\t\t\tif (i % 2 == 0) { a[i][j] *= 2; }\n\t\t\t\tst.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\trepn(i, N)repn(j, N) {\n\t\tif ((i + j) % 2 == 0) {\n\t\t\tll X = lcm(a[i - 1][j], lcm(a[i + 1][j], lcm(a[i][j - 1], a[i][j + 1])));\n\n\t\t\tfor (ll k = X + 1; k >= 0; k += X) {\n\t\t\t\tif (!st.count(k)) {\n\t\t\t\t\ta[i][j] = k;\n\t\t\t\t\tst.insert(k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trepn(i, N) {\n\t\trepn(j, N) {\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<assert.h>\ntypedef long long ll;\nconst int T=10000;\nint pr[T+10];\nbool np[T+10];\nvoid sieve(){\n\tint i,j,M=0;\n\tfor(i=2;i<=T;i++){\n\t\tif(!np[i])pr[++M]=i;\n\t\tfor(j=1;j<=M&&i*pr[j]<=T;j++){\n\t\t\tnp[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){return a%b==0?b:gcd(b,a%b);}\nll lcm(ll a,ll b){\n\tif(a==0||b==0)return a|b;\n\treturn a/gcd(a,b)*b;\n}\nll a[510][510];\nint main(){\n\tsieve();\n\tint n,i,j,M;\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tM=0;\n\tfor(i=1;i<n;i+=2){\n\t\tM++;\n\t\tfor(j=1;j<=i;j++)a[j][i-j+1]=pr[M];\n\t}\n\tif(n&1){\n\t\tM++;\n\t\tfor(i=1;i<=n;i++)a[n-i+1][i]=pr[M];\n\t}\n\tfor(i=1;i<n;i+=2){\n\t\tM++;\n\t\tfor(j=1;j<=i;j++)a[n-j+1][n-i+1+j-1]=pr[M];\n\t}\n\tfor(i=1;i<=n;i+=2){\n\t\tM++;\n\t\tfor(j=1;i+j-1<=n;j++)a[j][i+j-1]*=pr[M];\n\t}\n\tfor(i=3;i<=n;i+=2){\n\t\tM++;\n\t\tfor(j=1;i+j-1<=n;j++)a[i+j-1][j]*=pr[M];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif((i+j)&1)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nll lcm(ll a, ll b) {\n    return a / __gcd(a, b) * b; \n}\n\nvoid solve() {\n    int N;\n    cin >> N;\n    if (N == 2) {\n        cout << \"4 7\" << endl;\n        cout << \"23 10\" << endl;\n        return;\n    }\n\n    vector<int> isprime(10001, 1);\n    isprime[0] = isprime[1] = 0;\n    for(int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            for(int j = i + i; j < 10001; j += i) {\n                isprime[j] = 0;\n            }\n        }\n    }\n    vector<ll> primes;\n    for (int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    vector<vector<ll>> P1(N, vector<ll>(N)), P2(N, vector<ll>(N));\n    vector<vector<ll>> ans(N, vector<ll>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                ll p1 = primes[(i + j) / 2];\n                ll p2 = primes[primes.size() - 1 - (i - j + N) / 2];\n                ans[i][j] = p1 * p2;\n            }\n        }\n    }\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, -1, 0, 1};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 1) {\n                ll l = 1;\n                for(int k = 0; k < 4; k++) {\n                    int di = i + dy[k];\n                    int dj = j + dx[k];\n                    if (di < 0 || di >= N || dj < 0 || dj >= N) continue;\n                    l = lcm(l, ans[di][dj]);\n                }\n                ans[i][j] = l + 1;\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nbool notp[MAXN*MAXN];\nint prm[MAXN*MAXN],pn;\nvoid euler(int n)\n{\n\tnotp[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(!notp[i])prm[++pn]=i;\n\t\tfor(int j=1;j<=pn && i*prm[j]<=n;++j)\n\t\t{\n\t\t\tnotp[i*prm[j]]=1;\n\t\t\tif(!(i%prm[j]))break;\n\t\t}\n\t}\n}\nll a[MAXN][MAXN];\ninline ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nunordered_set<ll> s;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\teuler(n*500);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!((i+j)&1))\n\t\t\t{\n\t\t\t\ta[i][j]=prm[(i+j)/2]*prm[(i-j+n+1)/2+n];\n\t\t\t\ts.insert(a[i][j]);\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))continue;\n\t\t\ta[i][j]=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\ta[i][j]=lcm(a[i][j],a[x][y]);\n\t\t\t}\n\t\t\tll x=a[i][j];\n\t\t\t++a[i][j];\n\t\t\twhile(s.count(a[i][j]))a[i][j]+=x;\n\t\t\ts.insert(a[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%d \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=1e5+5;\nint p[N],vis[M];ll a[N][N];\nint n,m;\nvoid init(int n=1e5){\n\tfor(R int i=2;i<=n;++i){\n\t\tif(!vis[i])p[++m]=i;\n\t\tif(m==1000)return;\n\t\tfor(R int j=1;j<=m&&i*p[j]<=n;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\ninline ll lcm(R ll x,R ll y){return x/__gcd(x,y)*y;}\ninline ll calc(R int i,R int j){\n\treturn lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tinit();\n\tscanf(\"%d\",&n);\n\tif(n==2)return puts(\"4 7\\n23 10\\n\"),0;\n\tfp(i,1,n)fp(j,1,n)if((i+j)&1^1)a[i][j]=1ll*p[(i+j)>>1]*p[n-((i-j)>>1)+((n+1)>>1)];\n\tfp(i,1,n)fp(j,1,n)if(!a[i][j])a[i][j]=calc(i,j);\n\tfp(i,1,n)fp(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a/__gcd(a,b)*b;\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;P.PB(0);\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=7919;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t\t//cout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nLL readint(){\n\tchar c=getchar();\n\tLL ret=0ll;\n\tbool neg=0;\n\twhile(!(c>='0' && c<='9')){\n\t\tif(c=='-') neg=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10ll+(LL)(c-'0');\n\t\tc=getchar();\n\t}\n\treturn neg?-ret:ret;\n}\nvoid putint(LL v){\n\tif(v<0){\n\t\tputchar('-');\n\t\tv=-v;\n\t}\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10ll) putint(v/10ll);\n\tputchar('0'+(v%10ll));\n}\nconst int MX=100001;\nbool notp[MX+5];\nvector < int > prms;\nvoid prec(){\n\tint i,j,t;\n\tfor(i=2;i<=MX;++i){\n\t\tif(!notp[i]){\n\t\t\tprms.push_back(i);\n\t\t}\n\t\tfor(j=0;j<(int)prms.size() && (t=i*prms[j])<=MX;++j){\n\t\t\tnotp[t]=1;\n\t\t\tif(!(i%prms[j])) break;\n\t\t}\n\t}\n}\nint n;\nLL a[505][505];\nLL gcd(LL a,LL b){\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nLL lcm(LL a,LL b){\n\treturn a/gcd(a,b)*b;\n}\nconst int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\nmap < LL , bool > mp;\nint main(){\n\tint i,j,k;\n\tprec();\n\tn=readint();\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(!((i+j)&1)) continue;\n\t\t\tint x=(i+j)/2,y=(i-j+n-1)/2;\n\t\t\ta[i][j]=(LL)prms[x]*prms[y+n-1];\n\t\t}\n\t}\n\tfor(i=n-1;i>=0;--i){\n\t\tfor(j=n-1;j>=0;--j){\n\t\t\tif(a[i][j]) continue;\n\t\t\ta[i][j]=1;\n\t\t\tLL stp=1;\n\t\t\tfor(k=0;k<4;++k){\n\t\t\t\tif(i+dx[k]>=0 && i+dx[k]<n && j+dy[k]>=0 && j+dy[k]<n){\n\t\t\t\t\tstp=lcm(stp,a[i+dx[k]][j+dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[i][j]+=stp;\n\t\t\twhile(mp.count(a[i][j])) a[i][j]+=stp;\n\t\t\tmp[a[i][j]]=1;\n\t\t}\n\t}\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define INF (1ll<<60)\n\n\nlong long M = 1000000007;\n\nlong long gcd(long long x, long long y){\n    if(y==0)return x;\n    return gcd(y,x%y);\n}\n\nint main(int argc, char const *argv[]) {\n    int n;cin>>n;\n    set<long long> used;\n    n+=4;\n    vector<vector<long long>> res(n,vector<long long>(n,-1));\n    long long s = 3;\n    for(int i=1;i<n-1;++i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            // if((tmpi==0&tmpk==0)||(tmpi==0&tmpk==4)||(tmpi==4&tmpk==2)||(tmpi==4&tmpk==6)){\n            if((tmpi==0&tmpk==0)||(tmpi==4&tmpk==2)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                while(used.find(s)!=used.end())s++;\n            }\n        }\n    }\n    for(int i=n-2;i>0;--i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            if((tmpi==0&tmpk==4)||(tmpi==4&tmpk==6)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss+=s;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                while(used.find(s)!=used.end())s++;\n            }\n        }\n    }\n    for(int i=2;i<n-2;++i){\n        for(int k=2;k<n-2;++k){\n            if((i+k)%2==0){\n                long long tmp = 1,tt;\n                tt = res[i+1][k];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i-1][k];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i][k+1];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i][k-1];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = 1;\n                while(used.find(tt*tmp+1)!=used.end())tt++;\n                res[i][k] = tt*tmp+1;\n                used.insert(tt*tmp+1);\n            }\n        }\n    }\n    for(int i=2;i<n-2;++i){\n        for(int k=2;k<n-2;++k){\n            cout<<res[i][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    auto itr = used.end();\n    itr--;\n    // cout<<*itr<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5, M = 1005;\nint n, a[M][M], prime[N], vis[N], tot;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid init(int n)\n{\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tif(!vis[i]) prime[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= n; j ++)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\nint gcd(int a, int b) {return !b ? a : gcd(b, a % b);}\nint lcm(int a, int b) {return a / gcd(a, b) * b;}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tinit(10000); n = read();\n\tif(n == 2) {puts(\"4 7\\n23 10\\n\"); return 0;}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\tfor(int i = 1; i <= n; i ++, printf(\"\\n\"))\n\t\tfor(int j = 1; j <= n; j ++, printf(\" \"))\n\t\t\tprintf(\"%lld\", a[i][j]);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) ((int) x.size())\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAX = 2e6;\nconst int MAXN = 505;\n\nbool bio[MAX];\nvector <int> prime;\nint n;\nll a[MAXN][MAXN];\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n        prime.pb(i);\n        for(int j = i; j < MAX; j += i)\n            bio[j] = true;\n    }\n}\n\nint main(){\n    sito();\n\n    int idx1 = 0;\n    int idx2 = 125000;\n\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    REP(i, n)\n        REP(j, n){\n            if(i % 2 == 0 && j % 2 == 0){\n                a[i][j] = prime[idx1 ++];\n            }\n            else if(i % 2 && j % 2){\n                a[i][j] = prime[idx2 --];\n            }\n        }\n\n    set<ll> S;\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j] == 0){\n                ll sol = 0;\n                if(i > 0) sol = a[i - 1][j];\n                if(j > 0) sol = sol == 0 ? a[i][j - 1] : sol * a[i][j - 1];\n                if(i != n - 1) sol = sol == 0 ? a[i + 1][j] : sol * a[i + 1][j];\n                if(j != n - 1) sol = sol == 0 ? a[i][j + 1] : sol * a[i][j + 1];\n                a[i][j] = sol + 1;\n            }\n        }\n\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        //    S.insert(a[i][j]);\n        }\n        cout << \"\\n\";\n    }\n    //cout << sz(S) _ n * n << \"\\n\";\n    //assert(sz(S) == n * n);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 2 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = ml * (ans[i][j - 1] / gcd(ml, ans[i][j - 1]));\n\t\t\t\tif (i < n - 1) ml = ml * (ans[i + 1][j] / gcd(ml, ans[i + 1][j]));\n\t\t\t\tif (j < n - 1) ml = ml * (ans[i][j + 1] / gcd(ml, ans[i][j + 1]));\n\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define int int64_t\n#define all(x) begin(x),end(x)\n\nconst int maxn = 2e2 + 7;\n\n\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i % 2 == j % 2) {\n                cout << 2;\n            } else {\n                cout << 3;\n            }\n            cout << \" \\n\"[j + 1 == n];\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, A[509][509], B1[509], B2[509], cnt; vector<long long>vec, vec2;\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) vec.push_back(i);\n\tfor (int i = N + 1; i <= 200000; i++) {\n\t\tbool prime = true;\n\t\tfor (int j = 2; j*j <= i; j++) {\n\t\t\tif (i%j == 0) prime = false;\n\t\t}\n\t\tif (prime == true) { cnt++; vec2.push_back(i); }\n\t\tif (cnt * 2 >= N) break;\n\t}\n\tint L1 = 0, R1 = N - 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (i % 2 == 0) { B1[i] = vec[L1]; L1++; }\n\t\tif (i % 2 == 1) { B1[i] = vec[R1]; R1--; }\n\t}\n\tint L2 = 0, R2 = vec2.size() - 1;\n\tfor (int i = 0; i < (N + 1) / 2; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tB2[i * 2 + 1] = vec2[L2];\n\t\t\tB2[i * 2 + 2] = vec2[L2];\n\t\t\tL2++;\n\t\t}\n\t\tif (i % 2 == 1) {\n\t\t\tB2[i * 2 + 1] = vec2[R2];\n\t\t\tB2[i * 2 + 2] = vec2[R2];\n\t\t\tR2--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif ((i + j) % 2 == 1) continue;\n\t\t\tA[i][j] = B1[i] * B2[j];\n\t\t}\n\t}\n\tlong long maxn = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (A[i][j] >= 1) continue;\n\t\t\tlong long ret = 1; int dx[4] = { 0,-1,0,1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint fx = i + dx[k], fy = j + dy[k];\n\t\t\t\tif (fx <= 0 || fy <= 0 || fx > N || fy > N) continue;\n\t\t\t\tret = ret / gcd(ret, A[fx][fy])*A[fx][fy];\n\t\t\t}\n\t\t\tA[i][j] = ret + 1; maxn = max(maxn, A[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (j >= 2) cout << \" \"; \n\t\t\tcout << A[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 10010;\n\ninline ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint tot;\nint pri[MAXN];\nint chk[MAXN];\nll a[1010][1010];\n\ninline void Sieve(int n) {\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nunordered_map<int, int>id1, id2, vis;\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tSieve(10000);\n\tint n = ri + 1, N = 0;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\ta[i][j] = 1;\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) {\n\t\t\t\tif(!id1[i + j]) id1[i + j] = ++N;\n\t\t\t\tif(!id2[i - j]) id2[i - j] = ++N;\n\t\t\t\ta[i][j] = pri[id1[i + j]] * pri[id2[i - j]];\n\t\t\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) printf(\"%lld \", a[i][j]);\n\t\t\telse {\n\t\t\t\tll x = lcm(lcm(a[i + 1][j], a[i - 1][j]), lcm(a[i][j + 1], a[i][j - 1])), y = x + 1;\n\t\t\t\twhile(vis[y]) y += x; vis[y] = 1;\n\t\t\t\tprintf(\"%lld \", y);\n\t\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ios\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(nullptr);\n#define VEC(type, name, size)\\\n    V<type> name(size);\\\n    IN(name)\n#define VVEC(type, name, h, w)\\\n    VV<type> name(h, V<type>(w));\\\n    IN(name)\n#define INT(...)\\\n    int __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LL(...)\\\n    ll __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define STR(...)\\\n    string __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define CHAR(...)\\\n    char __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define DOUBLE(...)\\\n    DOUBLE __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LD(...)\\\n    LD __VA_ARGS__;\\\n    IN(__VA_ARGS__)\ntemplate <class T> void scan(T &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((ll)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T Roundup_div(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nconst ll INF = 1e18;\n#pragma endregion\n\nint N = 500;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ninline bool inside(int x, int y) {return x >= 0 and x < N and y >= 0 and y < N;}\n\nV<> pv;\nvector<bool> ip(10010, true);\nvoid er(){\n    ip[0] = ip[1] = 0;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) for(int j = 2 * i; j <= 10000; j += i) ip[j] = false;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) pv.pb(i);\n}\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;};\n\nint main(){\n    ios;\n    er();\n    INT(n);\n    VV<> res(N, V<>(N, 1));\n    REP(i, N) REP(j, N) if(!((i + j) % 2)) res[i][j] = pv[(i + j) / 2 + 1];\n    map<ll,ll> memo;\n    REP(i, N / 2){\n        int x = 0, y = i * 2;\n        while(x < N and y < N){\n            res[x][y] *= pv[i];\n            memo[res[x][y]]++;\n            x++; y++;\n        }\n    }\n    REP(i, N / 2 - 1){\n        int x = i * 2 + 2, y = 0;\n        while(x < N and y < N){\n            res[x][y] *= pv[N - i - 1];\n            memo[res[x][y]]++;\n            x++; y++;\n        } \n    }\n    REP(i, N) REP(j, N){\n        if(((i + j) % 2)){\n            REP(k, 4){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(inside(nx, ny)) res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n        }\n    }\n    REP(i, N) REP(j, N) if(((i + j) % 2)){\n        ll t = res[i][j];\n        res[i][j]++;\n        while(memo[res[i][j]]) res[i][j] += t;\n        memo[res[i][j]]++;\n    }\n    REP(i, n){  \n        REP(j, n) cout << res[i][j] << \" \"; cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long int LL;\nconst int Max_N(505);\nconst int Max_S(10000000);\nconst int dx[] = {+1, -1, +0, +0};\nconst int dy[] = {+0, +0, +1, -1};\n\nconstexpr LL gcd(LL a, LL b)\n{\n\treturn b == 0LL ? a : gcd(b, a % b);\n}\n\nconstexpr LL lcm(LL a, LL b)\n{\n\treturn a == 0LL ? b : a / gcd(a, b) * b;\n}\n\nint N, ps, P[Max_S];\nLL A[Max_N][Max_N];\nbool Prime[Max_S];\n\nint main()\n{\n\tmemset(Prime, true, sizeof(Prime)), Prime[0] = Prime[1] = false;\n\tfor (int i = 2;i < Max_S;++i)\n\t{\n\t\tif (Prime[i])\n\t\t\tP[++ps] = i;\n\t\tfor (int j = 1, x;j <= ps && (x = i * P[j]) < Max_S;++j)\n\t\t{\n\t\t\tPrime[x = false];\n\t\t\tif (x % P[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tprintf(\"%d %d\\n\", 4, 7);\n\t\tprintf(\"%d %d\\n\", 23, 10);\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tA[i][j] = P[(i + j) >> 1] * 1LL * P[N + (i - j) / 2 + (N + 1) / 2];\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tfor (int k = 0, x, y;k < 4;++k)\n\t\t\t\t\tif (1 <= (x = i + dx[k]) && x <= N && 1 <= (y = j + dy[k]) && y <= N)\n\t\t\t\t\t\tA[i][j] = lcm(A[i][j], A[x][y]);\n\t\t\t\t++A[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define ll long long\nusing namespace std;\nconst int N=510,MX=1e6;\nint p[25010];\nint vis[MX];\nll rec[N][N];\nint n,m,cnt;\nvoid prework(int n){\n\tvis[1]=false;\n\tint cnt=0;\n\tfor (int i=2;cnt<n;++i){\n\t\tif (!vis[i])\n\t\t\tp[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<MX;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){\n\tif (!x||!y) return x+y;\n\treturn x/gcd(x,y)*y;\n}\nvoid solve(){\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\trec[i][j]=1LL*p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif (!rec[i][j])\n\t\t\t\trec[i][j]=lcm(lcm(rec[i-1][j],rec[i][j+1]),lcm(rec[i+1][j],rec[i][j-1]))+1;\n}\n \nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tll tmp;\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"%d %d\\n%d %d\\n\",4,7,23,10);\n\t\treturn 0;\n\t}\n\tprework(n*n);\n\tsolve();\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",rec[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nmap<__int128,int> mp;\n__int128 lcm(__int128 x,__int128 y){\n\tif (!(x&&y)) return x^y;\n\treturn (__int128)x*y/__gcd(x,y);\n}\nconst int N=600;\nconst long long INF=1e18;\nlong long z[N][N];\nint n,a[N*N];\nint main(){\n\tscanf(\"%d\",&n);\n\tint tot=((n*n)+1)/2;\n\tfor (int i=1; i<=tot; ++i) a[i]=i*2;\n\t//random_shuffle(a+1,a+tot+1);\n\tint d=0;\n\tfor (int i=2; i<=n; i+=2)\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=a[++d];\n\tfor (int i=(n%2==0?n-1:n); i>=1; i-=2){\n\t\tstack<int> s;\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\ts.push(a[++d]);\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=s.top(),s.pop();\n\t}\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n   \tcerr<<\"tot\"<<tot<<endl;\n\tgetchar(); getchar();*/\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?2:1); j<=n; j+=2){\n\t\t\t__int128 k=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t__int128 zz=k;\n\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\tassert(zz+C<=INF);\n\t\t\t//cerr<<(long long)zz<<\" \"<<(long long)k<<\" \"<<z[i-1][j]<<\" \"<<z[i][j-1]<<\" \"<<z[i+1][j]<<\" \"<<z[i][j+1]<<endl;\n\t\t\t//getchar();\n\t\t\tz[i][j]=zz+C;\n\t\t\tmp[zz+C]=1;\n\t\t}\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%lld \",z[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\ntypedef  long long ll;\nll gcd(ll f , ll s){if(s==0)return f;else return gcd(s,f%s);}\nint const N = 1000006;\nll const M = 998244353;\nlong double const ep = .000000000000000001;\nint p[N];\nqueue<int>q;\nll Farray[1032][1032] , Sarray[1032][1023] , arr[1002][1003];\nint main() {\n\t\n\tint n;cin >> n;\n\tfor(int i = 2 ; i <= 1000 ; i++){\n\t\tif(!p[i]){\n\t\t\tfor(int x = i + i; x <= 100000 ; x+=i)p[x] = 1;\n\t\t}\n\t}\t\n\tfor(int i = 2 ; i <= 100000 ; i++)if(!p[i])q.push(i);\n\tpair<int,int>start = mp(0,0);\n\tfor(pair<int,int> i = start ; i.first < n ; i.first += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second < n ; x.first++ , x.second++){\n\t\t\tFarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\tfor(pair<int,int> i = mp(0,2) ; i.second < n ; i.second += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second < n ; x.first++ , x.second++){\n\t\t\tFarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\t\n\tfor(pair<int,int> i = start ; i.second < n ; i.second += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second >= 0 ; x.first++ , x.second--){\n\t\t\tSarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\n\tfor(pair<int,int> i = mp(1+(n%2),n-1) ; i.first < n ; i.first += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second >= 0 ; x.first++ , x.second--){\n\t\t\tSarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\n\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int x = 0 ; x < n ; x++)\n\t\t\tarr[i][x] = Farray[i][x] * Sarray[i][x];\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 1){\n\t\t\t\tll num = 1 , g = -1;\n\t\t\t\tif(i != 0){\n\t\t\t\t\tg = arr[i-1][j];\n\t\t\t\t\tnum = arr[i-1][j];\n\t\t\t\t}\n\t\t\t\tif(i != n-1){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i+1][j]);\n\t\t\t\t\telse g = arr[i+1][j];\n\t\t\t\t\tnum *= arr[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(j != 0){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i][j-1]);\n\t\t\t\t\telse g = arr[i][j-1];\n\t\t\t\t\tnum *= arr[i][j-1];\n\t\t\t\t}\n\t\t\t\tif(j != n-1){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i][j+1]);\n\t\t\t\t\telse g = arr[i][j+1];\n\t\t\t\t\tnum *= arr[i][j+1];\n\t\t\t\t}\n\t\t\t\tll lol = num / g + 1;\n\t\t\t\tarr[i][j] = lol;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tcout << arr[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 1003, K = 10003, d[2][4] = {{0, 1, 0, -1}, {1, 0, -1, 0}};\nint n, pri[N << 1], tot;\nbool notp[K];\nLL a[N][N];\ninline void init(int m){\n\tnotp[0] = notp[1] = 1;\n\tfor(Rint i = 2;;i ++){\n\t\tif(!notp[i]){pri[++ tot] = i; if(tot == m) break;}\n\t\tfor(Rint j = 1;j <= tot && i * pri[j] <= 10000;j ++){\n\t\t\tnotp[i * pri[j]] = true;\n\t\t\tif(!(i % pri[j])) break;\n\t\t}\n\t}\n}\ninline LL gcd(LL a, LL b){return b ? gcd(b, a % b) : a;}\ninline LL lcm(LL a, LL b){return a / gcd(a, b) * b;}\nint main(){\n\tscanf(\"%d\", &n); init(2 * n);\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tfor(Rint j = 1;j <= n;j ++) if(!(i + j & 1))\n\t\t\ta[i][j] = pri[i + j >> 1] * pri[n + (n + i - j + 1 >> 1)];\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tfor(Rint j = 1;j <= n;j ++){\n\t\t\tif(!a[i][j]){\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor(Rint k = 0;k < 4;k ++){\n\t\t\t\t\tint dx = i + d[0][k], dy = j + d[1][k];\n\t\t\t\t\tif(dx >= 1 && dx <= n && dy >= 1 && dy <= n)\n\t\t\t\t\t\ta[i][j] = lcm(a[i][j], a[dx][dy]);\n\t\t\t\t}\n\t\t\t\t++ a[i][j];\n\t\t\t}\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\n\nint x[501];\nint y[501];\nint so[100000]={0};\nvector<int> ve1,ve2,ve;\nint ans[501][501]={0};\nint ban[1010][1010]={0};\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nrandom_device seed_gen;\n  \t\n mt19937 engine(seed_gen());\n  \tfor(int i=2;i<100000;i++)if(so[i]==0){\n  \t\tif(ve1.size()<500)ve1.pb(i);\n  \t\telse ve2.pb(i);\n  \t\tif(ve2.size()==500) break;\n  \t\tfor(int j=i;j<100000;j+=i)so[j]=1;\n  \t}\n  //\tcout<<ve2.back()<<endl;\n  \tint cnt=0;\n  \twhile(1){\n  \t\tshuffle(ve1.begin(), ve1.end(),engine);\n  \t\tshuffle(ve2.begin(), ve2.end(),engine);\n  \t\tcnt++;\n  //\t\tcout<<cnt<<endl;\n  \t\tve.clear();\n  \t\tfor(int i=0;i<500;i++){\n  \t\t\tve.pb(ve1[i]);\n  \t\t\tve.pb(ve2[i]);\n  \t\t}\n  \t\tfor(int i=0;i<=498;i++)for(int j=500;j<=998;j++){\n  \t\t\tif(ve[i]*ve[i+1]*ve[j]*ve[j+1]>1000000000000000ll){\n  \t\t//\tcout<<i<<\" \"<<j-500<<endl;\n  \t\t\t\tgoto lll;\n  \t\t\t}\n  \t\t\t}\n  \t\t\n  \t\tbreak;\n  \t\tlll:;\n  \t}\n  //\tfor(auto v:ve)cout<<v<<endl;\n  \t\n  \tfor(int i=0;i<=500;i++){\n  \t\tif(i==0) x[i]=ve[i];\n  \t\telse if(i==500) x[i]=ve[i-1];\n  \t\telse{\n  \t\t\tx[i]=ve[i]*ve[i-1];\n  \t\t}\n  \t}\n  \t\n  \tfor(int j=0;j<=500;j++){\n  \t\tif(j==0) y[j]=ve[500+j];\n  \t\telse if(j==500)y[j]=ve[j-1+500];\n  \t\telse{\n  \t\t\ty[j]=ve[j+500]*ve[j-1+500];\n  \t\t}\n  \t}\n  \tint n;\n  \tcin>>n;\t\n  \tfor(int i=0;i<=500;i++)for(int j=0;j<=500;j++){\n  \t\tban[2*i][2*j]=x[i]*y[j];\n  \t//\tassert(x[2*i]*y[2*j]<=1000000000000000ll);\n  \t}\n  \t\n  \t\n  \t\n  \tfor(int i=0;i<=499;i++)for(int j=0;j<=499;j++){\n  \t\tint g=ban[2*i][2*j];\n  \t\tg=gcd(g,ban[2*i+2][2*j]);\n  \t\tg=gcd(g,ban[2*i][2*j+2]);\n // \t\tg=gcd(g,ban[i+1][j]);\n  \t\tg=gcd(g,ban[2*i+2][2*j+2]);\n  \t\tban[2*i+1][2*j+1]=g;\n  //\t\tcout<<g<<\" \"<<se.size()<<endl;\n  \t//\tassert(se.count(g)==0);\n  //\t\tse.insert(g);\n  \t}\n  \t\n  \tset<int> se;\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++){\n  \t\t\n  \t\tint s=(i+j);\n  \t\tint t=(i-j)+500;\n  \t\tif(ban[s][t]<=0){\n  \t\t\tcout<<i<<\" \"<<j<<endl;\n  \t\t}\n  \t\tassert(ban[s][t]>0);\n  \t\tassert(se.count(ban[s][t])==0);\n  \t\tse.insert(ban[s][t]);\n  \t\t\n  \t\tans[i][j]=ban[s][t];\n  \t}\n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \treturn 0;\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++)if((i+j)%2){\n  \t\t\n  \t\tint g;\n  \t\tif(i==0) g=ban[i+1][j];\n  \t\telse g=ban[i-1][j];\n  \t\t\n  \t\tif(i!=499)g=gcd(g,ban[i+1][j]);\n  \t\tif(i>0)g=gcd(g,ban[i-1][j]);\n  \t\tif(j!=499)g=gcd(g,ban[i][j+1]);\n  \t\tif(j)g=gcd(g,ban[i][j-1]);\n  \t\tans[i][j]=g;\n  \t}\n  \tse.clear();\n  \t\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++){\n  \t\tassert(se.count(ans[i][j])==0);\n  \t\tse.insert(ans[i][j]);\n  \t}\n  \t\n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    vector<vector<ll>> a(500,vector<ll>(500,0));\n    vector<int> isPrime(2000,true);\n    vector<ll> primes;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            primes.push_back(i);\n            for(int j=2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n    set<ll> vs;\n    \n    for(int i=0;i<500;i++){\n        for(int j=i%2;j<500;j+=2){\n            a[i][j]=primes[i/2]*primes[j/2];\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    auto isRange=[](int x,int y){\n        return 0<=x && x<500 && 0<=y && y<500;\n    };\n    auto lcm=[](ll x,ll y){\n        return x/__gcd(x,y)*y;\n    };\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n\n    for(int i=0;i<500;i++){\n        for(int j=(i+1)%2;j<500;j+=2){\n            ll v=1;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dx[k],j+dy[k])){\n                    v=lcm(v,a[i+dx[k]][j+dy[k]]);\n                }\n            }\n            a[i][j]=v;\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    int n;\n    cin>>n;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j+1<n;j++){\n            if(a[i][j]>1e15){\n                cnt++;\n                a[i][j]=1;\n            }\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<a[i][n-1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m long long\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nint main(){m n;cin>>n;m t=0;r(2,i,9999){\n\t\tbool a=true;r(2,j,i){if(i%j==0)a=false;}if(a)p[t]=i,t++;}r(0,i,555)r(0,j,555)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+1662-j)/2];r(0,i,555)r(0,j,555)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <set>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 510;\nint n;\n\nll ans[N][N];\n\nset<ll> s;\n\nll gcd(ll x, ll y) {\n\twhile(y) {\n\t\tll t = y;\n\t\ty = x%y;\n\t\tx = t;\n\t}\n\treturn x;\n}\n\nll lcm(ll x, ll y) {\n\treturn x/gcd(x,y)*y;\n}\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\n\tll cur=2;\n\tfor(int i=0; i<=n; i+=2) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\n\tfor(int i=1; i<n; i+=2) {\n\t\tfor(int j=0; j<=n; j+=2) {\n\t\t\tll temp = lcm(ans[i-1][j], ans[i+1][j]);\n\t\t\tll t = temp+1;\n\t\t\twhile(s.count(t)) t+=temp;\n\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\n\t\tfor(int j=1; j<n; j+=2) {\n\t\t\tll temp = lcm(lcm(ans[i-1][j], ans[i+1][j]), lcm(ans[i][j-1], ans[i][j+1]));\n\t\t\tll t = temp+1;\n\n\t\t\twhile(s.count(t)) t+=temp;\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=0; j<n; j++) printf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nll ans[1005][1005],prime[10005],num;\nbool flag[10005];\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tflag[1]=1;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(!flag[i])prime[++num]=i;\n\t\tfor(int j=1;j<=num&&prime[j]*i<=10000;j++)\n\t\t{\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif(!((i+j)&1))\n\t\t{\n\t\t\tint p1=(i+j+1)/2;\n\t\t\tint p2=(i-j+n+1)/2+n;\n\t\t\tans[i][j]=prime[p1]*prime[p2];\n\t\t}\n\t}\n\tll v=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif((i+j)&1)\n\t\t{\n\t\t\tans[i][j]=1;\n\t\t\tif(i!=1)ans[i][j]*=ans[i-1][j]/__gcd(ans[i][j],ans[i-1][j]);\n\t\t\tif(j!=1)ans[i][j]*=ans[i][j-1]/__gcd(ans[i][j],ans[i][j-1]);\n\t\t\tif(i!=n)ans[i][j]*=ans[i+1][j]/__gcd(ans[i][j],ans[i+1][j]);\n\t\t\tif(j!=n)ans[i][j]*=ans[i][j+1]/__gcd(ans[i][j],ans[i][j+1]);\n\t\t}\n\t\tans[i][j]++;\n\t\tv=max(v,ans[i][j]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t  printf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 505;\nint n, dx[4] = {1, 0, -1, 0}, dy[4] = {0, -1, 0, 1};\nlong long mat[N][N], pri[N << 1];\n\nbool check_prime (int p) {\n\tfor (int i = 2; i * i <= p; i++) {\n\t\tif (p % i == 0) return false;\n\t}\n\n\treturn true;\n}\n\nlong long gcd (long long x, long long y) {\n\tif (x < y) swap(x, y);\n\twhile (x % y) {\n\t\tlong long r = x % y;\n\t\tx = y, y = r;\n\t}\n\treturn y;\n}\n\nlong long lcm (long long x, long long y) {\n\treturn (x / gcd(x, y)) * y;\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 2, j = 0; j < (n << 1); i++) {\n\t\tif (check_prime(i)) pri[j++] = i;\n\t}\n\n\tset<long long> s;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tmat[i][j] = pri[i - 1] * pri[j - 1 + n];\n\t\t\t\ts.insert(mat[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tlong long div = mat[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\t\tif (1 <= x && x <= n && 1 <= y && y <= n) div = lcm(div, mat[x][y]);\n\t\t\t\t}\n\t\t\t\tmat[i][j] += div;\n\t\t\t\twhile (s.count(mat[i][j])) mat[i][j] += div;\n\t\t\t\ts.insert(mat[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) printf(\"%lld \", mat[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#define maxn 510\n#define ll long long\n\nusing namespace std;\n\nint n;\nll a[maxn][maxn], primes[2020];\nbool st[1000010];\nint cnt;\n\nvoid getprimes()\n{\n\tfor (int i = 2; i <= 10000; i ++ )\n\t{\n\t\tif (!st[i]) primes[++cnt] = i;\n\t\tfor (int j = 1; primes[j] * i <= 10000; j ++ )\n\t\t{\n\t\t\tst[primes[j] * i] = 1;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n}\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\tif (!a || !b) return a + b;\n\treturn a / gcd(a, b) * b;\n}\n\nint main()\n{\n\tgetprimes();\n\tscanf(\"%d\", &n);\n\t\n\tif (n == 2)\n\t{\n\t\tputs(\"2 3\");\n\t\tputs(\"5 4\");\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = primes[(i + j) / 2] * primes[n + (i - j) / 2 + (n + 1) / 2];\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = ((i & 1) + 1); j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i][j - 1], a[i - 1][j]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t{\n\t\tfor (int j = 1; j <= n; j ++ ) cout << a[i][j] << ' ';\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    vector<vector<ll>> a(500,vector<ll>(500,0));\n    vector<int> isPrime(5000,true);\n    vector<ll> primes;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            primes.push_back(i);\n            for(int j=2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n    set<ll> vs;\n\n    for(int i=0;i<500;i++){\n        for(int j=i%2;j<500;j+=2){\n            a[i][j]=primes[i/2]*primes[j/2];\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    auto isRange=[](int x,int y){\n        return 0<=x && x<500 && 0<=y && y<500;\n    };\n    auto lcm=[](ll x,ll y){\n        return x/__gcd(x,y)*y;\n    };\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n\n    for(int i=0;i<500;i++){\n        for(int j=(i+1)%2;j<500;j+=2){\n            ll v=1;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dx[k],j+dy[k])){\n                    v=lcm(v,a[i+dx[k]][j+dy[k]]);\n                }\n            }\n            a[i][j]=v;\n            int tmp=2;\n            while(vs.count(a[i][j]+1)){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            a[i][j]++;\n            if(a[i][j]<=1e15) vs.insert(a[i][j]);\n        }\n    }\n    int n;\n    cin>>n;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j+1<n;j++){\n            if(a[i][j]>1e15){\n                cnt++;\n                int tmp=1;\n                bool isok=true;\n                do{\n                    tmp++;\n                    isok=true;\n                    for(int k=0;k<4;k++){\n                        if(isRange(i+dx[k],j+dy[k])){\n                            isok&=(a[i+dx[k]][j+dy[k]]%tmp==1);\n                        }\n                    }\n                }while(!isok || vs.count(a[i][j]=tmp));\n                vs.insert(a[i][j]);\n            }\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<a[i][n-1]<<endl;\n    }\n    //cerr<<cnt<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  vector<bool> furui(5001,true);\n  int j;\n  for (int i=2; i<100; i++) {\n    j = 2;\n    while (i * j <= 5000) {\n      furui[i*j] = false;\n      j++;\n    }\n  }\n  \n  vector<long long> prime(500);\n  long long now = 500;\n    \n  for (int i=0; i<500; i++) {\n    while (!furui[now]) {\n      now++;\n    }\n    prime[i] = now;\n    now++;\n  }\n  \n  vector<vector<long long>> ans(500,vector<long long>(500,0));\n  \n  for (int i=0; i<500; i++) {\n    for (int j=0; j<500; j++) {\n      if ((i+j)%2 == 1) {\n        ans[i][j] = prime[(i-j+499)/2];\n        ans[i][j] *= ((i+j+1)/2);\n      }\n    }\n  }\n  \n  ans[0][0] = ans[0][1] * ans[1][0] + 1;\n  ans[499][499] = ans[499][498] * ans[498][499] + 1;\n  \n  for (int i=0; i<500; i++) {\n    for (int j=0; j<500; j++) {\n      if (ans[i][j] == 0) {\n        if (i == 0 || i == 499) {\n          ans[i][j] = ans[i][j-1] * ans[i][j+1] + 1;\n        }\n        else {\n          ans[i][j] = ans[i+1][j] * ans[i-1][j] + 1;\n        }\n      }\n    }\n  }\n  \n  \n  int N;\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      cout << ans[i][j];\n      if (j != N-1) {\n        cout << \" \";\n      }\n    }\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\ninline ll gcd(ll x, ll y)\n{\n\twhile (y)\n\t{\n\t\tauto r = x % y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn x;\n}\ninline bool chk(int n)\n{\n\tfor (int i = 2; i * i <= n; i++)\n\t{\n\t\tif (!(n % i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline ll lcm(ll x, ll y) { return x && y ? x / gcd(x, y) * y : x + y; }\nll pri[1005], arr[505][505];\nint main()\n{\n\t// freopen(\"AGC027-D.in\", \"r\", stdin);\n\tint n, cur = 0, len = 0;\n\tscanf(\"%d\", &n);\n\tbool even = n & 1 ^ 1;\n\tn += even;\n\tfor (int i = 2; len <= n * 2; i++)\n\t{\n\t\tif (chk(i))\n\t\t\tpri[len++] = i;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tarr[i][j] = 1;\n\t}\n\tfor (int i = 0; i < n; i += 2, cur++)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= pri[cur];\n\t\tcur++;\n\t}\n\tfor (int i = 2; i < n; i += 2, cur++)\n\t{\n\t\tint x = 0, y = i;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= pri[cur];\n\t}\n\tcur = len - 1;\n\tfor (int i = 0; i < n; i += 2, cur--)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= pri[cur];\n\t}\n\tfor (int i = 2; i < n; i += 2, cur--)\n\t{\n\t\tint x = n - 1, y = i;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= pri[cur];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i & 1 ^ 1; j < n; j += 2)\n\t\t\tarr[i][j] = lcm(lcm(i ? arr[i - 1][j] : 0, j ? arr[i][j - 1] : 0),\n\t\t\t\t\t\t\tlcm(arr[i + 1][j], arr[i][j + 1])) + 1;\n\t}\n\tn -= even;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tprintf(\"%lld%c\", arr[i][j], \" \\n\"[j + 1 == n]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\nusing namespace std;\ntypedef long long ll;\nint pr[101010];\nll ans[555][555];\nll gcd(ll a, ll b)\n{\n\tfor (;;)\n\t{\n\t\tif (a < b)swap(a, b);\n\t\ta %= b;\n\t\tif (a == 0)return b;\n\t}\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0 || b == 0)return max(a, b);\n\treturn a*b / gcd(a, b);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tdeque<ll>v;\n\tfor (int i = 2; i <= 10000; i++)\n\t{\n\t\tif (pr[i] == 0)\n\t\t{\n\t\t\tfor (int j = i + i; j <= 10000; j += i)pr[j] = -1;\n\t\t\tif (i >= 30 && v.size() < num * 2 + 10)v.push_back(i);\n\t\t}\n\t}\n\tdeque<ll>x, y;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i % 4 == 0)x.push_back(v[i]);\n\t\tif (i % 4 == 1)x.push_front(v[i]);\n\t\tif (i % 4 == 2)y.push_back(v[i]);\n\t\tif (i % 4 == 3)y.push_front(v[i]);\n\t}\n\tfor (int i = 0; i < num + 1; i++)\n\t{\n\t\tfor (int j = 0; j < num + 1; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tans[i + 1][j + 1] = x[(i + j) / 2] * y[(i - j + num + 2) / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < num; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 != 0)\n\t\t\t{\n\t\t\t\tll t = lcm(lcm(lcm(ans[i][j + 1], ans[i + 1][j]), ans[i + 2][j + 1]), ans[i + 1][j + 2]);\n\t\t\t\tans[i + 1][j + 1] = t + 1;\n\t\t\t}\n\t\t\tprintf(\"%lld \", ans[i + 1][j + 1]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 260) t++;\n    rep(i, n) p.eb(P[t++]);\n    random_shuffle(all(p));\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * (i + 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * i;\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * (i + 2) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i + 1) ;\n        }\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif (j)cout << \" \";\n\t\t\tcout << 5 + j + (i % 2 ? -1 : 0);\n\t\t}\n\t\tcout << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nconst int Maxv = 3000; \nconst long long INF = 0x3f3f3f3f; \n\nint x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}, elm[Maxv], cnt, idx, n; \nlong long ans[650][650], max = -INF; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void pre_Opt() {\n    int num; \n    for (int i = 2;; i++) {\n        for (num = 2; num * num <= i; num++) {\n            if (i % num == 0) break; \n        }\n\n        if (num * num > i) elm[++cnt] = i; \n        if (cnt >= Maxv - 5) break; \n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    pre_Opt(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", elm[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = elm[idx]; \n        }\n    }    \n\n    for (int i = n / 2 * 2 + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= elm[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    } \n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        printf(\"\\n\"); \n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nconst int N=1000010;\nint p[N],pnum;\nbool b[N];\nlong long lcm(long long x,long long y){\n\tif (!(x&&y)) return x^y;\n\treturn (__int128)x*y/__gcd(x,y);\n}\nconst int P=510;\nint a[P][P],c[P][P];\nlong long re[P][P];\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tfor (int i=2; pnum<2000; ++i){\n\t\tif (!b[i]) p[pnum++]=i;\n\t\tfor (int j=0; j<pnum&&i*p[j]<=1000000; ++j){\n\t\t\tb[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n\n\tint d=0;\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; ++j)\n\t\t\tif ((i+j)&1) a[i][j]=p[(i+j)/2];\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t  for (int j=1; j<=n; ++j) printf(\"%d \",a[i][j]);*/\n\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif ((i+j)&1) c[i][j]=p[(i-j+n)/2+600];\n\n\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t  for (int j=1; j<=n; ++j) printf(\"%d \",c[i][j]);*/\n\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tre[i][j]=a[i][j]*c[i][j];\n\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t  for (int j=1; j<=n; ++j) printf(\"%lld \",re[i][j]);*/\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tre[i][j]=lcm(re[i-1][j],lcm(re[i][j-1],lcm(re[i][j+1],re[i+1][j])))+C;\n\t\t}\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%lld \",re[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1000000007\n#define LINF 1000000000000000007\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll gcd(ll x, ll y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y){\n\treturn (x / gcd(x,y)) * y; //オーバーフローを防ぐ\n}\n\nbool sosuu(int a){\n\tfor(int i = 2; i * i <= a; i++){\n\t\tif(a % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint n;\nll a[501][501] = {0};\nll so[1001];\n\nint main(){\n\tcin >> n;\n\t\n\tif(n == 2){\n\t\tcout << \"4 7\\n23 10\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tint c = 0;\n\tfor(int i = 2; c < 1001; i++){\n\t\tif(sosuu(i)){\n\t\t\tif(c > 500) so[(c-500)*2-1] = i;\n\t\t\telse so[c*2] = i;\n\t\t\tc++;\n\t\t}\n\t}\n\t\n\tc = 0;\n\tfor(int i = 0; i < n; i+=2){\n\t\tfor(int j = 0; j+i < n; j++){\n\t\t\ta[j][i+j] = so[c];\n\t\t}\n\t\tc++;\n\t}\n\tfor(int i = 2; i < n; i+=2){\n\t\tfor(int j = 0; j+i < n; j++){\n\t\t\ta[i+j][j] = so[c];\n\t\t}\n\t\tc++;\n\t}\n\t\n\tfor(int i = 0; i < n; i+=2){\n\t\tfor(int j = 0; i+j < n; j++){\n\t\t\ta[i+j-(n%2-1)][n-1-j] *= so[c];\n\t\t}\n\t\tc++;\n\t}\n\tfor(int i = 0; i < n; i+=2){\n\t\tfor(int j = 0; i-j >= 0; j++){\n\t\t\ta[i-j][j] *= so[c];\n\t\t}\n\t\tc++;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(a[i][j] == 0){\n\t\t\t\tint dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0};\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(i+dx[k] < n && i+dx[k] >= 0 && j+dy[k] < n && j+dy[k] >= 0){\n\t\t\t\t\t\tif(a[i][j] == 0) a[i][j] = a[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\telse a[i][j] = lcm(a[i][j], a[i+dx[k]][j+dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=10000;\nint prime[10010],tot;\nbool vis[10010];\nlong long a[510][510];\nint gcd(long long a,long long b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\nvoid init()\n{\n\tvis[1]=true;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tvis[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\treturn ;\n}\nint main()\n{\n\tinit();\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\ta[i][j]*=prime[1+(i+j)/2];\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tif((i-j)%2==0)\n\t\t\t\ta[i][j]*=prime[2*n+10-(i-j+n+1)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==1)\n\t\t\t{\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5, M = 1005;\nint n, a[M][M], prime[N], vis[N], tot;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid init(int n)\n{\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tif(!vis[i]) prime[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= n; j ++)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n//int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}\n//int lcm(int a, int b) {return a / gcd(a, b) * b;}\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tinit(10000); n = read();\n\tif(n == 2) {puts(\"4 7\\n23 10\\n\"); return 0;}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\tfor(int i = 1; i <= n; i ++, printf(\"\\n\"))\n\t\tfor(int j = 1; j <= n; j ++, printf(\" \"))\n\t\t\tprintf(\"%lld\", a[i][j]);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 550) t++;\n    rep(i, n) p.eb(P[t++]);\n    random_shuffle(all(p));\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * (i + 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * i;\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * (i + 2) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i + 1) ;\n        }\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <list>\nusing namespace std;\n\nvector <int> construct(int x) {\n\tif (x == 0) {\n\t\tvector <int> X;\n\t\tX.push_back(x);\n\t\treturn X;\n\t}else {\n\t\tvector <int> vv = construct(x - 1);\n\t\tvector <int> X;\n\t\tfor (int i = 0; i < (int) vv.size(); i++)\n\t\t\tX.push_back(vv[i]);\n\t\tfor (int i = 0; i < (int) vv.size() - 1; i++)\n\t\t\tX.push_back(vv[vv.size() - 1 - i] + (1 << (x - 1)));\n\t\treturn X;\n\t}\n}\n\nint prime[11000];\nbool used[11000];\n\nint s1[1100], s2[1100];\nint len;\n\nlong long a[600][600];\nvector <long long> VV;\n\n#define K 503\n\nvoid check(long long x, long long y) {\n\t// printf(\"%lld %lld\\n\", x, y);\n\tassert(max(x, y) % min(x, y) == K);\n}\n\nint main() {\n\tfor (int i = 2; i <= 10000; i++) {\n\t\tif (!used[i]) {\n\t\t\tprime[++len] = i;\n\t\t\tfor (int j = 2 * i; j <= 10000; j += i)\n\t\t\t\tused[j] = true;\n\t\t}\n\t}\n\tint base = 3;\n\tfor (int i = 1; i <= 500; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\ts1[i] = prime[base + i / 2];\n\t\t}else {\n\t\t\ts1[i] = 2 * prime[base + i / 2 - 1] * prime[base + i / 2] + 1;\n\t\t}\n\t}\n\n\tbase = 260;\n\n\tfor (int i = 1; i <= 500; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\ts2[i] = prime[base + i / 2];\n\t\t}else {\n\t\t\ts2[i] = 3 * prime[base + i / 2 - 1] * prime[base + i / 2] + 1;\n\t\t}\n\t}\n\n\tprime[0] = 1;\n\n\t// printf(\"lol %d\\n\", prime[110]);\n\n\tfor (int i = 1; i <= 500; i++)\n\t\tfor (int j = 1; j <= 500; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\ta[i][j] = i * prime[110 + (j + 1) / 2];\n\t\t\t}else {\n\t\t\t\tif (i > 1)\n\t\t\t\t\ta[i][j] = 1LL * (i - 1) * i * (i + 1) * prime[110 + j / 2] * prime[110 + j / 2 + 1] + K;\n\t\t\t\telse\n\t\t\t\t\ta[i][j] = 1LL * i * (i + 1) * prime[110 + j / 2] * prime[110 + j / 2 + 1] + K;\n\t\t\t}\n\t\t}\n\t// printf(\"?? %lld %lld\\n\", a[1][1], a[2][2]);\n\t// printf(\"%d %d\\n%d %d\\n\", s1[1], s1[2], s2[1], s2[2]);\n\tfor (int i = 1; i <= 500; i++)\n\t\tfor (int j = 1; j <= 500; j++) {\n\t\t\tassert(a[i][j] <= 1e15);\n\t\t\tVV.push_back(a[i][j]);\n\t\t}\n\tsort(VV.begin(), VV.end());\n\tfor (int i = 1; i < 250000; i++) {\n\t\t// printf(\"?? %d %lld\\n\", i, VV[i]);\n\t\t// printf(\"%d\\n\", );\n\t\tassert(VV[i] != VV[i - 1]);\n\t}\n\n\t// printf(\"!! %lld %lld\\n\", a[1][1], a[2][1]);\n\tfor (int i = 1; i <= 500; i++)\n\t\tfor (int j = 1; j <= 500; j++) {\n\t\t\tif (i > 1) check(a[i][j], a[i - 1][j]);\n\t\t\tif (i < 500) check(a[i][j], a[i + 1][j]);\n\t\t\tif (j > 1) check(a[i][j], a[i][j - 1]);\n\t\t\tif (j < 500) check(a[i][j], a[i][j + 1]);\n\t\t}\n\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++)\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll __int128\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=500+10,MAXM=1000000+10;\nint n,vis[MAXM],prime[MAXM],cnt,p;\nll G[MAXN][MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void init()\n{\n\tmemset(vis,1,sizeof(vis));\n\tvis[0]=vis[1]=0;\n\tREP(i,2,MAXM-1)\n\t{\n\t\tif(vis[i])prime[++cnt]=i;\n\t\tfor(register int j=1;j<=cnt&&i*prime[j]<MAXM;++j)\n\t\t{\n\t\t\tvis[i*prime[j]]=0;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint main()\n{\n\tread(n);init();int x,y;\n\tREP(i,0,n+1)REP(j,0,n+1)G[i][j]=1;\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y>=0)G[x][y]*=prime[p],x++,y--;\n\t}\n\tREP(i,n+1,0)if(i%2==0)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y<=n+1)G[x][y]*=prime[p],x--,y++;\n\t}\n\tREP(i,0,n+1)if(i%2==0)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y>=0)G[x][y]*=prime[p],x--,y--;\n\t}\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y<=n+1)G[x][y]*=prime[p],x++,y++;\n\t}\n\tREP(i,1,n)REP(j,1,n)if((i+j)%2==0)\n\t\tG[i][j]=G[i-1][j]*G[i][j-1]+1;\n\tREP(i,1,n)\n\t{\n\t\tREP(j,1,n)write(G[i][j],' ');puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint pri[101000], tot = 0;\nbool is[101000];\n\nvoid init()\n{\n\tfor(int i = 2; i <= 100000; i++)\n\t{\n\t\tif(!is[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= 100000; j++)\n\t\t{\n\t\t\tis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nlong long m[1010][1010];\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tinit();\n\tint j = 2;\n\tfor(int i = 2; i <= 2 * n; i += 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i - k >= 1 && i - k <= n) m[k + 1][i - k] = pri[j];\n\t\t}\n\t\tj++;\n\t}\n\t\n\tfor(int i = (n / 2 * 2); i >= - n; i -= 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i + k >= 1 && i + k <= n) m[k + 1][i + k] *= pri[j];\n\t\t}\n\t\tj++;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(!m[i][j])\n\t\t\t{\n\t\t\t\tm[i][j] = 1;\n\t\t\t\tif(i != 1) m[i][j] *= m[i - 1][j];\n\t\t\t\tif(j != 1) m[i][j] *= m[i][j - 1];\n\t\t\t\tif(i != n) m[i][j] *= m[i + 1][j];\n\t\t\t\tif(j != n) m[i][j] *= m[i][j + 1];\n\t\t\t\tm[i][j]++;\n\t\t\t}\n\t\t}\n\tfor(int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \",m[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<ll> a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\ta[i] = 2 + i;\n\t}\n\tif (a.back() % 2 == 0) {\n\t\tfor (int i = 0; i < N; i++) if (a[i] & 1) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\ta[j] += a[i];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << a[(i + j) % N] << \" \\n\"[j + 1 == N];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=0;i<=n+1;i++)for(ll j=0;j<=n+1;j++)a[i][j]=1;\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\tfor(ll j=1;j<=n;j++)\n\tif((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    vll son;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,1,(N*N)/2){\n            prime.pb(aa*2);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==1){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==0){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n//                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n                    a[i][j]=lcm(a[i-1][j],a[i+1][j]);\n                    a[i][j]=lcm(a[i][j],a[i][j-1]);\n                    a[i][j]=lcm(a[i][j],a[i][j+1]);\n                    if(BINS(son,a[i][j])==0){\n                        son.pb(a[i][j]);\n                        SORT(son);\n                    }else{\n                        a[i][j]*=2;\n                    }\n                    a[i][j]++;\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint ans[555][555];\n\nvector<int> pri;\nvoid init(int x){\n  vector<bool> flag(x+1,false);\n  for(int i = 2; i <= x; i++){\n    if(flag[i]) continue;\n    pri.emplace_back(i);\n    for(int j = i; j <= x; j+=i) flag[j] = true;\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  init(10000000);\n  vec id(999),id2(999);\n  int now = 0, cnt = 0;\n  REP(i,999){\n    if(i%2) continue;\n    id[i] = now;\n    if(cnt%2) now = 1000 - now + 1;\n    else now = 1000-now;\n    cnt++;\n  }\n\n  REP(i,999){\n    if(i%2) continue;\n    id2[i] = now;\n    if(cnt%2) now = 1000 - now + 1;\n    else now = 1000-now;\n    cnt++;\n  }\n\n  REP(i,500) REP(j,500){\n    if((i+j)%2) continue;\n    ans[i][j] = pri[id[i+j]];\n  }\n\n  REP(i,500) REP(j,500){\n    if((i-j+498)%2) continue;\n    ans[i][j] *= pri[id2[i-j+498]];\n    assert(ans[i][j]);\n  }\n\n  set<int> st; cnt = 0;\n  REP(i,500) REP(j,500) if(ans[i][j]) st.insert(ans[i][j]), cnt++;\n  //debug(st.size()); debug(cnt);\n  assert(st.size()==500*500/2);\n\n  int dx[] = {1,-1,0,0}, dy[] = {0,0,1,-1};\n  REP(i,500){\n    REP(j,500){\n    if((i+j)%2==0) continue;\n    int lcm = 1;\n    REP(k,4){\n      if(range(i+dx[k],0,500)&&range(j+dy[k],0,500)){\n        lcm = lcm/__gcd(lcm,ans[i+dx[k]][j+dy[k]])*ans[i+dx[k]][j+dy[k]];\n       // debug(lcm);\n      }\n    }\n    // cout << endl;\n    //while(st.find(num+1)!=st.end()) num += lcm;\n    ans[i][j] = lcm+1;\n    //st.insert(num+1);\n    // cout << i SP j << endl;\n    assert(range(ans[i][j],1,(int)1e15+1));\n    }\n  }\n\n  st.clear();\n  REP(i,500) REP(j,500) st.insert(ans[i][j]);\n  // debug(st.size());\n  assert(st.size()==500*500);\n\n  REP(i,n) {\n    REP(j,n){\n      cout << ans[i][j] << \" \";\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <climits>\n#include <algorithm>\n#include <random>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <bitset> \n#include <queue>\n#define inf 0x3f3f3f3f\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0);\n#define rep(i, a, n) for(register int i = a; i <= n; ++ i)\n#define per(i, a, n) for(register int i = n; i >= a; -- i)\n#define ONLINE_JUDGE\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\ntemplate<typename T>void write(T x)\n{\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    if(x>9)\n    {\n        write(x/10);\n    }\n    putchar(x%10+'0');\n}\n \ntemplate<typename T> void read(T &x)\n{\n    x = 0;char ch = getchar();ll f = 1;\n    while(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n    while(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nll ksm(ll a,ll n){//看是否要mod \n\tll ans=1;\n\twhile(n){\n\t\tif(n&1) ans=(ans*a)%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn ans%mod;\n}\n//==============================================================\nconst int maxn=5e2+10;\nint mat[maxn][maxn];\nint n;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\t//===========================================================\n    read(n);\n\tmat[1][1]=2;\n    int x=1,y=2;\n    rep(i,2,n) mat[1][i]=mat[1][i-1]+1;\n    mat[2][n]=mat[1][n]+1;\n    x=2,y=n-1;\n    int dir=1;\n    while(true){\n        if(mat[x-1][y]!=0&&mat[x][y+dir]!=0)mat[x][y]=lcm(mat[x-1][y],mat[x][y+dir])+1;\n        else{\n            mat[x][y]=mat[x][y+dir]+mat[x-1][y]+1;\n        }\n        y-=dir;\n        if(y==0) dir=-1,x++,y=1;\n        if(y==n+1) dir=1,x++,y=n;\n        if(x>n) break;\n    }\n    rep(i,1,n){\n        rep(j,1,n){\n            if(j-1) putchar(' ');\n            write(mat[i][j]);\n        }\n        \n        putchar('\\n');\n    }\n\t//===========================================================\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MaxN = 5e2 + 17;\nlong long arr[MaxN][MaxN];\nlong long prime[4 * MaxN];\nlong long second_matrix[MaxN][MaxN];\nint x[] = {-1, 1, 0, 0};\nint y[] = {0, 0, -1, 1};\nint n = 505;\nmap<long long, bool> mp;\n\nlong long lcm(long long a, long long b)\n{\n    return (a / __gcd(a, b)) * b;\n}\n\nvoid erich()\n{\n    const int MaxS = 2e4 + 17;\n    bool isPrime[MaxS];\n\n    for(int i = 2; i < MaxS; ++i)\n        isPrime[i] = 1;\n\n    int next = 1;\n\n    for(int i = 2; i < MaxS; ++i)\n    {\n        if(isPrime[i])\n        {\n            prime[next++] = i;\n\n            for(int j = i + i; j < MaxS; j += i)\n                isPrime[j] = 0;\n\n        }\n    }\n}\n\nvoid fill_sec()\n{\n    for(int i = n - !(n % 2), j = 1; i >= 1; i -= 2, ++j)\n    {\n        int x = i;\n        int y = 1;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + j];\n            ++x;\n            ++y;\n        }\n    }\n\n    for(int i = 3, j = 1; i <= n; i += 2, ++j)\n    {\n        int x = 1;\n        int y = i;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + n / 2 +  n % 2 + j];\n            ++x;\n            ++y;\n        }\n    }\n}\n\nvoid fill_matrix()\n{\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if(!((i + j) & 1))\n                arr[i][j] = prime[(i + j) / 2] * second_matrix[i][j];\n\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if((i + j) & 1)\n            {\n                arr[i][j] = 1;\n\n                for(int k = 0; k < 4; ++k)\n                {\n                    int xx = i + x[k];\n                    int yy = j + y[k];\n\n                    if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                        arr[i][j] = lcm(arr[i][j], arr[xx][yy]);\n                }\n\n                ++arr[i][j];\n            }\n\n}\nbool check(long long a, long long b)\n{\n    if((max(a, b) % min(a, b)) != 1)\n    {\n        cout << a << ' ' << b << ' ' << (max(a, b) % min(a, b)) <<  '\\n';\n        exit(0);\n    }\n\n    return (max(a, b) % min(a, b)) == 1;\n}\nbool check()\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            assert(arr[i][j] <= 1e15);\n\n            for(int k = 0; k < 4; ++k)\n            {\n                int xx = i + x[k];\n                int yy = j + y[k];\n\n                if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                    assert(check(arr[i][j], arr[xx][yy]));\n\n            }\n        }\n    }\n\n    return true;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    erich();\n    fill_sec();\n    fill_matrix();\n\n   /* for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            if(!((i + j) & 1))\n                cout << prime[(i + j) / 2] << ' ';\n            else\n                cout << 0 << ' ';\n        }\n\n        cout << '\\n';\n    }\n\n    cout << '\\n';\n\n     for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n            cout << second_matrix[i][j] << ' ';\n        cout << '\\n';\n    }*/\n\n    check();\n\n    int m;\n    cin >> m;\n\n\n\n    for(int i = 1; i <= m; ++i)\n    {\n        for(int j = 1; j <= m; ++j)\n            cout << arr[i][j] << ' ';\n        cout << '\\n';\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL K = 750;\nconst LL MP = 20000;\n\nLL pri[20005],pc = 0;\nLL npr[20005] = {0};\nLL w[505][505];\n\nvoid sieve(LL x){\n\tfor(LL i = 2;i <= x;i ++){\n\t\tif(npr[i]) continue;\n\t\tpri[++ pc] = i;\n\t\tfor(LL j = i * i;j <= x;j += i){\n\t\t\tnpr[j] = 1;\n\t\t}\n\t} \n}\n\nLL gcd(LL x,LL y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nLL lcm(LL x,LL y){\n\treturn x / gcd(x,y) * y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL n; cin >> n;\n\tif(n == 2){\n\t\tcout << 4 << ' ' << 7 << endl;\n\t\tcout << 23 << ' ' << 10 << endl;\n\t\treturn 0;\n\t}\n\tsieve(MP);\n\tfor(LL i = 0;i <= n + 1;i ++){\n\t\tfor(LL j = 0;j <= n + 1;j ++){\n\t\t\tw[i][j] = 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tif((i + j) & 1) w[i][j] = pri[(i + j) >> 1] * pri[((i - j) >> 1) + K];\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tif(w[i][j] == 1) w[i][j] = lcm(lcm(w[i - 1][j],w[i][j - 1]),lcm(w[i + 1][j],w[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tcout << w[i][j] << (j == n ? '\\n' : ' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long \nll f[1050][1050];\nint n,t,p[10050],pri[10050];\nint gcd(int a,int b){\n\tif (!(a%b))return b;\n\treturn gcd(b,a%b);\n}\nll lcm(int x,int y){\n\tll ret=1;\n\tif (x>1)ret=ret*f[x-1][y]/gcd(f[x-1][y],ret);\n\tif (y>1)ret=ret*f[x][y-1]/gcd(f[x][y-1],ret);\n\tif (x<n)ret=ret*f[x+1][y]/gcd(f[x+1][y],ret);\n\tif (y<n)ret=ret*f[x][y+1]/gcd(f[x][y+1],ret);\n\treturn ret+1;\n}\nint main(){\n\tfor (int i=2;t<=1000;i++){\n\t\tif (!p[i])pri[++t]=i;\n\t\tfor (int j=1;j<=t&&i*1ll*pri[j]<=10000;j++){\n\t\t\tp[i*pri[j]]=1;\n\t\t\tif (!(i%pri[j]))break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tint tmp=1;\n\tfor (int i=1;i<=n;i+=2,tmp++)\n\t\tfor (int x=1,y=i;x<=n&&y<=n;x++,y++)f[x][y]=pri[tmp]; \n\tfor (int i=3;i<=n;i+=2,tmp++)\n\t\tfor (int y=1,x=i;x<=n&&y<=n;x++,y++)f[x][y]=pri[tmp];\n\tfor (int i=1;i<=n;i+=2,tmp++)\n\t\tfor (int x=1,y=i;x<=n&&y;x++,y--)f[x][y]*=pri[tmp];\n\tfor (int i=(!(n&1)?2:3);i<=n;i+=2,tmp++)\n\t\tfor (int y=n,x=i;x<=n&&y;x++,y--)f[x][y]*=pri[tmp];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)if (!f[i][j])f[i][j]=lcm(i,j);\n\tif (n==2)f[2][1]=61;\n\tfor (int i=1;i<=n;i++,printf(\"\\n\"))\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",f[i][j]); \n} "
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\n\nint x[501];\nint y[501];\nint so[100000]={0};\nvector<int> ve1,ve2,ve;\nint ans[501][501]={0};\nint ban[1010][1010]={0};\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nrandom_device seed_gen;\n  \t\n mt19937 engine(seed_gen());\n  \tfor(int i=2;i<100000;i++)if(so[i]==0){\n  \t\tif(ve1.size()<500)ve1.pb(i);\n  \t\telse ve2.pb(i);\n  \t\tif(ve2.size()==500) break;\n  \t\tfor(int j=i;j<100000;j+=i)so[j]=1;\n  \t}\n  //\tcout<<ve2.back()<<endl;\n  \tint cnt=0;\n  \twhile(1){\n  \t\tshuffle(ve1.begin(), ve1.end(),engine);\n  \t\tshuffle(ve2.begin(), ve2.end(),engine);\n  \t\tcnt++;\n  //\t\tcout<<cnt<<endl;\n  \t\tve.clear();\n  \t\tfor(int i=0;i<500;i++){\n  \t\t\tve.pb(ve1[i]);\n  \t\t\tve.pb(ve2[i]);\n  \t\t}\n  \t\tfor(int i=0;i<=498;i++)for(int j=500;j<=998;j++){\n  \t\t\tif(ve[i]*ve[i+1]*ve[j]*ve[j+1]>1000000000000000ll){\n  \t\t//\tcout<<i<<\" \"<<j-500<<endl;\n  \t\t\t\tgoto lll;\n  \t\t\t}\n  \t\t\t}\n  \t\t\n  \t\tbreak;\n  \t\tlll:;\n  \t}\n  //\tfor(auto v:ve)cout<<v<<endl;\n  \t\n  \tfor(int i=0;i<=500;i++){\n  \t\tif(i==0) x[i]=ve[i];\n  \t\telse if(i==500) x[i]=ve[i-1];\n  \t\telse{\n  \t\t\tx[i]=ve[i]*ve[i-1];\n  \t\t}\n  \t}\n  \t\n  \tfor(int j=0;j<=500;j++){\n  \t\tif(j==0) y[j]=ve[500+j];\n  \t\telse if(j==500)y[j]=ve[j-1+500];\n  \t\telse{\n  \t\t\ty[j]=ve[j+500]*ve[j-1+500];\n  \t\t}\n  \t}\n  \tint n;\n  \tcin>>n;\t\n  \tfor(int i=0;i<=500;i++)for(int j=0;j<=500;j++){\n  \t\tban[2*i][2*j]=x[i]*y[j]+1;\n  \t//\tassert(x[2*i]*y[2*j]<=1000000000000000ll);\n  \t}\n  \t\n  \t\n  \t\n  \tfor(int i=0;i<=499;i++)for(int j=0;j<=499;j++){\n  \t\tint g=ban[2*i][2*j];\n  \t\tg=gcd(g,ban[2*i+2][2*j]);\n  \t\tg=gcd(g,ban[2*i][2*j+2]);\n // \t\tg=gcd(g,ban[i+1][j]);\n  \t\tg=gcd(g,ban[2*i+2][2*j+2]);\n  \t\tban[2*i+1][2*j+1]=g;\n  //\t\tcout<<g<<\" \"<<se.size()<<endl;\n  \t//\tassert(se.count(g)==0);\n  //\t\tse.insert(g);\n  \t}\n  \t\n  \tset<int> se;\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++){\n  \t\t\n  \t\tint s=(i+j);\n  \t\tint t=(i-j)+500;\n  \t\tif(ban[s][t]<=0){\n  \t\t\tcout<<i<<\" \"<<j<<endl;\n  \t\t}\n  \t\tassert(ban[s][t]>0);\n  \t\tassert(ban[s][t]<=1000000000000000ll);\n  \t\tassert(se.count(ban[s][t])==0);\n  \t\tse.insert(ban[s][t]);\n  \t\t\n  \t\tans[i][j]=ban[s][t];\n  \t}\n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \treturn 0;\n\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\n#define MAX_N 100005\n#define int long long\nvector<int> prime;\nbool is_prime[MAX_N];\n\nvoid sieve(int n){\n    for(int i=0;i<=n;i++){\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2;i<=n;i++){\n        if(is_prime[i]){\n            prime.push_back(i);\n            for(int j=2*i;j<=n;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\n\n\nsigned main(){\n    sieve(100000);\n    map<int,int>p,q;\n    int id = 0;\n    for(int i=0;i<=600;i+=2){\n        p[500-i] = prime[id];\n        id++;\n        q[i] = prime[id];\n        id++;\n        if(i!=0){\n            p[500+i] = prime[id];\n            id++;\n            q[-i] = prime[id];\n            id++;\n        }\n    }\n    int n;\n    cin >> n;\n    set<ll>st;\n    vector<vector<ll> > a(n,vector<ll>(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if((i+j)%2==0){\n                //cerr << p[i+j] << \" \" << q[i-j] << endl;\n                a[i][j] = p[i+j]*q[i-j];\n                if(st.count(a[i][j])){\n                    assert(0);\n\n                }\n                st.insert(a[i][j]);\n                \n            }\n        }\n    }\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if((i+j)%2==1){\n                ll s = 1;\n                if(i!=0){\n                    s = lcm(s,a[i-1][j]);\n                }\n                if(i!=n-1){\n                    s = lcm(s,a[i+1][j]);\n                }\n                if(j!=0){\n                    s = lcm(s,a[i][j-1]);\n                }\n                if(j!=n-1){\n                    s = lcm(s,a[i][j+1]);\n                }\n                s+=1;\n                if(st.count(s)==1){\n                    ll t = s-1;\n                    while(1){\n                        if(st.count(s)==0){\n                            st.insert(s);\n                            a[i][j] = s;\n                            break;\n                        }else{\n                            s += t;\n                        }\n                    }\n                }else{\n                    a[i][j] = s;\n                    st.insert(s);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            // if(a[i][j]>=1e15){\n            //     cout << \"ERROR \" << a[i][j] << endl;\n            //     return 0;\n            // }\n            cout << a[i][j];\n            if(j!=n-1){\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nlong long lcm(long long a, long long b) {\n  return a / __gcd(a, b) * b;\n}\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int real_n;\n  cin >> real_n;\n  int n = 500;\n  vector<int> primes;\n  int x = 2;\n  while ((int) primes.size() < 2 * n + 5) {\n    int prime = 1;\n    for (int i = 2; i * i <= x; i++) {\n      if (x % i == 0) {\n        prime = 0;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push_back(x);\n    }\n    x++;\n  }\n  vector<vector<long long>> a(n, vector<long long>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 0) {\n        a[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + n + n / 2 + 2];\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) {\n        a[i][j] = 1;\n        if (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n        if (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n        if (i < n - 1) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n        if (j < n - 1) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n        assert(a[i][j] <= (long long) 1e15);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n - 1; j++) {\n      assert(max(a[i][j], a[i][j + 1]) % min(a[i][j], a[i][j + 1]) == 0);\n      assert(max(a[j][i], a[j + 1][i]) % min(a[j][i], a[j + 1][i]) == 0);\n    }\n  }\n  set<long long> all;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      all.insert(a[i][j]);\n    }\n  }\n  // assert((int) all.size() == n * n);\n  for (int i = 0; i < real_n; i++) {\n    for (int j = 0; j < real_n; j++) {\n      if (j > 0) {\n        cout << \" \";\n      }\n      cout << a[i][j];\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint pri[101000], tot = 0;\nbool is[101000];\n\nvoid init()\n{\n\tfor(int i = 2; i <= 100000; i++)\n\t{\n\t\tif(!is[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= 100000; j++)\n\t\t{\n\t\t\tis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nlong long m[1010][1010];\n\nlong long gcd(long long a, long long b) {return b == 0 ? a : gcd(b, a % b);} \nvoid lcm(long long &a, long long b)\n{\n\ta = a / gcd(a, b) * b; \n}\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tinit();\n\tint j = 2;\n\tfor(int i = 2; i <= 2 * n; i += 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i - k >= 1 && i - k <= n) m[k + 1][i - k] = pri[j];\n\t\t}\n\t\tj++;\n\t}\n\t\n\tfor(int i = (n / 2 * 2); i >= - n; i -= 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i + k >= 1 && i + k <= n) m[k + 1][i + k] *= pri[j];\n\t\t}\n\t\tj++;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(!m[i][j])\n\t\t\t{\n\t\t\t\tm[i][j] = 1;\n\t\t\t\tif(i != 1) lcm(m[i][j], m[i - 1][j]);\n\t\t\t\tif(j != 1) lcm(m[i][j], m[i][j - 1]);\n\t\t\t\tif(i != n) lcm(m[i][j], m[i + 1][j]);\n\t\t\t\tif(j != n) lcm(m[i][j], m[i][j + 1]);\n\t\t\t\tm[i][j]++;\n\t\t\t}\n\t\t}\n\tfor(int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \",m[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nbool prime[30000005];\nint ans[501][501];\nvector<ll> vec;\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tmemset(prime,true,sizeof(prime));\n\tfor(ll i=2;i<30000005;i++){\n\t\tif(prime[i]){\n\t\t\tvec.push_back(i);\n\t\t\tfor(ll j=2LL*i;j<30000005;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tprintf(\"%lld%c\",vec[i*n+j]*vec[n*n]+vec[n*n+1],j+1==n?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdint>\nusing namespace std;\n\nconst int MAX = 1000000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 4 << \" \" << 7 << endl << 23 << \" \" << 10; // サンプルケースですね\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX];\n\tfor (int i = 0;i < MAX;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\tcout << prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積\n\t\t\t\tcout << (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i - j - 1) / 2];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは0だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define value0(a) prime[(a)-1]\n#define value1(b) prime[(b)+749]\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {puts(\"4 7\\n23 10\"); return 0;} \n\tinit(10000);\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)%2==0) {\n\t\tan[i][j]=value0((i+j)/2)*value1((i-j)/2);\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if((x+y)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k],_y=y+dy[k];\n\t\t\tif(_x<1||_x>n||_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t\t++an[x][y]; \n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e3 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, tot, vis[1000005], pri[1000005], a[N][N];\nvoid init(int n) {\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(vis[i] == 0) pri[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= n; ++ j) {\n\t\t\tvis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nint gcd(int x, int y) {return y == 0 ? x : gcd(y, x % y);}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x * y / gcd(x, y);\n}\nsigned main() {\n\tn = read(); init(1e4);\n\tif(n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = pri[(i + j) / 2] * pri[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1]));\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i, puts(\"\")) for(int j = 1; j <= n; ++ j) printf(\"%lld \", a[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll arr[501][501];\n\nll lcm(ll a, ll b) {\n    return a/__gcd(a,b)*b;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    const ll Max = 1e15;\n    unordered_set<ll> seen;\n    const int bound = 1e5;\n    vector<bool> prime(bound, true);\n    prime[0] = prime[1] = false;\n    for(int i = 2; i < bound; ++i) {\n        if(prime[i]) {\n            for(int j = i+i; j < bound; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n    vector<ll> primes;\n    for(int i = 2; i < bound; ++i) {\n        if(prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if((i+j)%2 == 0) {\n                arr[i][j] = primes[i+j] * primes[2*n + i-j];\n            }\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if((i+j)%2 == 1) {\n                ll res = -1;\n                if(i+1 < n) {\n                    if(res == -1) res = arr[i+1][j];\n                    else res = lcm(res, arr[i+1][j]);\n                }\n                if(i-1 >= 0) {\n                    if(res == -1) res = arr[i-1][j];\n                    else res = lcm(res, arr[i-1][j]);\n                }\n                if(j+1 < n) {\n                    if(res == -1) res = arr[i][j+1];\n                    else res = lcm(res, arr[i][j+1]);\n                }\n                if(j-1 >= 0) {\n                    if(res == -1) res = arr[i][j-1];\n                    else res = lcm(res, arr[i][j-1]);\n                }\n                arr[i][j] = res+1;\n            }\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n             cout << arr[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,s,n) for(int i = s; i < n; i++)\nconst int maxn = 505;\nll ans[maxn][maxn];\nll n;\n\nint main(){\n\tcin>>n;\n\tans[0][0] = 4;\n\trep(i,1,n) ans[i][0] = ans[i-1][0]+3;\n\trep(i,0,n) rep(j,1,n){\n\t\tans[i][j] = ans[i][j-1]+3;\n\t}\n\trep(i,0,n){\n\t\trep(j,0,n){\n\t\t\tprintf(\"%I64d \", ans[i][j]);\n\t\t}\n\t\tcout<<endl;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ios\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(nullptr);\n#define VEC(type, name, size)\\\n    V<type> name(size);\\\n    IN(name)\n#define VVEC(type, name, h, w)\\\n    VV<type> name(h, V<type>(w));\\\n    IN(name)\n#define INT(...)\\\n    int __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LL(...)\\\n    ll __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define STR(...)\\\n    string __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define CHAR(...)\\\n    char __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define DOUBLE(...)\\\n    DOUBLE __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LD(...)\\\n    LD __VA_ARGS__;\\\n    IN(__VA_ARGS__)\ntemplate <class T> void scan(T &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((ll)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T Roundup_div(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nconst ll INF = 1e18;\n#pragma endregion\n\nint N = 500;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ninline bool inside(int x, int y) {return x >= 0 and x < N and y >= 0 and y < N;}\n\nV<> pv;\nvector<bool> ip(10010, true);\nvoid er(){\n    ip[0] = ip[1] = 0;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) for(int j = 2 * i; j <= 10000; j += i) ip[j] = false;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) pv.pb(i);\n}\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;};\n\nint main(){\n    ios;\n    er();\n    INT(n);\n    VV<> res(N, V<>(N, 1));\n    V<> ver(N), sid(N);\n    REP(i, N) ver[i] = pv[2 * i];\n    REP(i, N) sid[i] = pv[999 - 2 * i];\n    REP(i, N) REP(j, N) if((i + j) % 2) res[i][j] = ver[i] * sid[j];\n    REP(i, N) REP(j, N){\n        if(!((i + j) % 2)){\n            REP(k, 4){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(inside(nx, ny)) res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n        }\n    }\n    REP(i, n){  \n        REP(j, n) cout << ((i + j) % 2 ? res[i][j] : res[i][j] + 1 )<< \" \"; cout << endl;\n    }\n}   "
  },
  {
    "language": "C++",
    "code": "/*\ngod taekyu\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n;\nll A[505][505];\nint cieve[10000005];\nint p[1500000], pcnt;\nint B[505][505];\npii ord[250005];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin>>n;\n    for(int i=2;i<=1700004;i++) {\n        if(cieve[i] == 0) {\n            p[pcnt++] = i;\n            for(int j=i*2;j<1700005;j+=i) {\n                cieve[j] = 1;\n            }\n        }\n    }\n    int cnt = 0;\n    int dx[4] = {0,1,0,-1};\n    int dy[4] = {1,0,-1,0};\n    int ni = 1, nj = 1, idx = 0;\n    while(1) {\n        if(B[ni][nj] != 0) break;\n        B[ni][nj] = ++cnt;\n        int lcnt = 0;\n        while(1) {\n            lcnt++;\n            int nni = ni + dx[idx];\n            int nnj = nj + dy[idx];\n            if(1<=nni && nni <= n && 1<=nnj && nnj<=n && B[nni][nnj] == 0 || lcnt >=6) {\n                ni = nni;\n                nj = nnj;\n                break;\n            }\n            idx++; idx %= 4;\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            ord[B[i][j]] = pii(i,j);\n        }\n    }\n    for(int i=0;i<=n+1;i++) {\n        A[0][i] = A[i][0] = A[n+1][i] = A[i][n+1] = 1;\n    }\n    cnt = 0;\n    for(int x=n*n;x>=1;x--) {\n        int i = ord[x].first;\n        int j = ord[x].second;\n        if((i+j)%2 == 0) {\n            A[i][j] = (ll)p[cnt++];\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                A[i][j] = (A[i-1][j]) * A[i+1][j] * A[i][j-1] * A[i][j+1] + 1;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            cout<<A[i][j]<<' ';\n        }\n        cout<<'\\n';\n    }\n    return 0;\n}\n\n/*\ngod taekyu\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 100005;\n\nint n;\nbool p[100005];\nvi primes;\n\nvoid sieve() {\n\tMMS(p, 1);\n\tp[0] = p[1] = 0;\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i]) {\n\t\t\tfor (int j = 2 * i; j < N; j += i)\n\t\t\t\tp[j] = 0;\n\t\t}\n\t}\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i])\n\t\t\tprimes.pb(i);\n\t}\n}\n\nll a[501][501];\n\nll setV(int i, int j) {\n\tint d0 = (i + j) >> 1;\n\tint d1 = n + ((i - j + n - 1) >> 1);\n\treturn primes[d0] * 1LL * primes[d1];\n}\n\nll getI(int i, int j) {\n\treturn primes[(i + j) >> 1];\n}\n\nll getJ(int i, int j) {\n\treturn primes[n + ((i - j + n - 1) >> 1)];\n}\n\nll calc(int i, int j) {\n\tll res = 1;\n\tset<ll> S;\n\tif (i + 1 >= 0 && i + 1 < n) {\n\t\tS.insert(getI(i + 1, j));\n\t\tS.insert(getJ(i + 1, j));\n\t}\n\tif (i - 1 >= 0 && i - 1 < n) {\n\t\tS.insert(getI(i - 1, j));\n\t\tS.insert(getJ(i - 1, j));\n\t}\n\tif (j + 1 >= 0 && j + 1 < n) {\n\t\tS.insert(getI(i, j + 1));\n\t\tS.insert(getJ(i, j + 1));\n\t}\n\tif (j - 1 >= 0 && j - 1 < n) {\n\t\tS.insert(getI(i, j - 1));\n\t\tS.insert(getJ(i, j - 1));\n\t}\n\tfor (auto x : S) {\n\t\tres = (res * x) / __gcd(res, x);\n\t}\n\treturn res + 1;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tsieve();\n\tcin >> n;\n\tll mx = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1) == 0) {\n\t\t\t\ta[i][j] = setV(i, j);\n\t\t\t\tmx = max(mx, a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1)) {\n\t\t\t\ta[i][j] = calc(i, j);\n\t\t\t\tmx = max(mx, a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\ta[1][0] *= 2;\n\t\ta[1][0]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j == n - 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    // double input seems slow on CF\n    void re(double& x) { string t; cin >> t; x = stod(t); } \n    void re(ld& x) { string t; cin >> t; x = stold(t); }\n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); \n        re(rest...); \n    }\n    template<class T1, class T2> istream& operator>>(istream& is, pair<T1,T2>& p) {\n        is >> p.f >> p.s;\n        return is;\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& a) {\n        F0R(i,sz(a)) is >> a[i];\n        return is;\n    }\n    \n    // OUTPUT \n    \n    template<class T> void pr(T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(Arg& first, Args&... rest) { \n        pr(first); \n        cout << ' ';\n        pr(rest...); \n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}';\n        return os;\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        os << '{';\n        F0R(i,sz(a)) {\n            if (i) os << \", \";\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n}\n\nusing namespace io;\n\nvector<vl> cur = {{2,0},{0,4}}; \n\nld comb(ld a, ll b) {\n    if (a > 1e15) return a;\n    ll g = __gcd((ll)a,b);\n    return (ld)a/g*b;\n}\n\nld test(int i, int j) {\n    ld g = 1;\n    if (i) g = comb(g,cur[i-1][j]);\n    if (i+1<512) g = comb(g,cur[i+1][j]);\n    if (j) g = comb(g,cur[i][j-1]);\n    if (j+1<512) g = comb(g,cur[i][j+1]);\n    return g;\n}\n\nset<ll> S;\n\nvoid genEven() {\n    vi v = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\n    vi V;\n    for (int i: v) {\n        int cur = i;\n        while (cur < 1000) {\n            V.pb(cur);\n            cur *= cur;\n        }\n    }\n    sort(all(V)); reverse(all(V)); V.pop_back();\n    int sz = 2;\n    while (sz < 512) {\n        auto a = V.back(); V.pop_back();\n        auto b = V.back(); V.pop_back();\n        ll c;\n        if (a*b <= 70) c = a*b;\n        else {\n            c = V.back(); V.pop_back();\n        }\n        //cout << a << \" \" << b << \" \" << c << \"\\n\";\n        \n        vector<vl> CUR(2*sz); F0R(i,2*sz) CUR[i].resize(2*sz);\n        F0R(i,sz) F0R(j,sz) if (cur[i][j]) {\n            CUR[i][j] = cur[i][j];\n            CUR[2*sz-1-i][2*sz-1-j] = cur[i][j]*c;\n            CUR[i+(j % 2 == 0 ? 1 : -1)][2*sz-1-j] = cur[i][j]*a;\n            CUR[2*sz-1-i][j+(i % 2 == 0 ? 1 : -1)] = cur[i][j]*b;\n        }\n        \n        cur = CUR;\n        sz *= 2;\n    }\n    for (auto a: cur) for (auto b: a) if (b) S.insert(b);\n}\n\nvoid genOdd() {\n    vector<pair<ll,pi>> v;\n    F0R(i,512) F0R(j,512) if (cur[i][j] == 0) v.pb({test(i,j),{i,j}});\n    sort(v.rbegin(),v.rend()); // cout << v.front() << \"\\n\";\n    for (auto a: v) {\n        ll t = a.f+1;\n        while (S.count(t)) t += a.f;\n        cur[a.s.f][a.s.s] = t;\n        assert (t <= (1e15));\n        S.insert(t);\n    }\n    F0R(i,512) F0R(j,511) {\n        ll x = max(cur[i][j],cur[i][j+1]), y = min(cur[i][j],cur[i][j+1]);\n        assert (x % y == 1);\n    }\n}\n\nint main() {\n    setIO();\n    genEven();\n    genOdd();\n    int n; re(n);\n    F0R(i,n) {\n        F0R(j,n) cout << cur[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n/* \n* (Actually read this pls)\n    * Rlly bad errors: int overflow, array bounds\n    * Less bad errors: special cases (n=1?), set tle\n    * Common sense: do smth instead of nothing\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N;\nbool prime[1000005];\nvector<llint> pvec;\nllint ans[505][505];\nconst llint di[] = {1, 0, -1, 0}, dj[] = {0, -1, 0, 1};\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tfor(int i = 2; i < 1005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j += i) prime[j] = true;\n\t}\n\tfor(int i = 3; i < 1000005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\tllint pos = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(ans[i][j]) continue;\n\t\t\tllint tmp = 1;\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif(ni > N || nj < 1 || nj > N) continue;\n\t\t\t\tif(ni < 1) tmp *= 2;\n\t\t\t\telse tmp *= ans[ni][nj];\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma optimize(\"no-stack-protector\")\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define ALL(a) a.begin(), a.end()\n#define lowbit(x) ((x) & -(x))\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long u64;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\n\nnamespace io {\n\tconst int L = (1 << 21) + 1;\n\tchar ibuf[L], *iS, *iT, obuf[L], *oS = obuf, *oT = obuf + L - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, L, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush () { fwrite (obuf, 1, oS - obuf, stdout); oS = obuf; }\n\tinline void putc (char x) { *oS ++ = x; if (oS == oT) flush (); }\n\ttemplate <class I> inline void gi (I & x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\ttemplate <class I> inline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0', x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline char read () {\n\t\tfor (c = gc(); c < 'a' || c > 'z'; c = gc());\n\t\treturn c;\n\t}\n\tinline void gs (char *s) {\n\t\tint l;\n\t\tfor (c = gc(); c < 'a' || c > 'z'; c = gc());\n\t\tfor (l = 0; c <= 'z' && c >= 'a'; c = gc()) s[l] = c, ++l;\n\t\ts[l] = 0;\n\t}\n\tinline void ps (const char *s) {\n\t\tint l = strlen(s), i;\n\t\tfor (i = 0; i < l; i ++) putc(s[i]);\n\t}\n\tstruct IOC { ~ IOC () { flush (); } } _ioc_;\n\tinline double readld(){\n\t\tdouble x = 0, y = 1;\n\t\tfor (c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') y = -1;\n\t\tassert(c != '.');\n\t\tfor (c = gc(); c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15);\n\t\tx *= y;\n\t\tassert(c != 'e');\n\t\tif (c == '.') for (c = gc(); c <= '9' && c >= '0'; c = gc()) y *= 0.1, x += y * (c & 15);\n\t\treturn x;\n\t}\n\tinline void printld(double x, int digit){\n\t\tif (x < 0) putc('-'), x = -x;\n\t\tx += 0.5 * pow(0.1, digit);\n\t\tprint((ll)x), putc('.');\n\t\tfor (x -= (ll)x; digit; --digit) x = x * 10, putc((int)x + '0'), x -= (int)x;\n\t}\n} ;\nusing io::gi;\nusing io::gs;\nusing io::ps;\nusing io::putc;\nusing io::read;\nusing io::print;\nusing io::readld;\nusing io::printld;\n\ninline int ctz(int a){ return __builtin_ctz(a); }\ninline int ctz(uint a){ return __builtin_ctz(a); }\ninline int ctz(ll a){ return __builtin_ctzll(a); }\ntemplate <class T> inline T gcd(T a, T b){\n\tint shift = ctz(a | b);\n\tfor (b >>= ctz(b), a >>= ctz(a); a; a -= b, a >>= ctz(a)) if (a < b) swap(a, b);\n\treturn b << shift;\n}\ntemplate <class T> void exgcd(T a, T b, T &x, T &y){\n\tif (!b) return (void)(x = 1, y = 0);\n\texgcd(b, a % b, y, x), y -= a / b * x;\n}\ntemplate<class T> T inv(T a, T p){\n\tT x, y;\n\texgcd(a, p, x, y);\n\treturn (x % p + p) % p;\n}\nint fpow(int a, int t, int p){\n\tstatic int r;\n\tfor (r = 1; t; a = (ll)a * a % p, t >>= 1) if (t & 1) r = (ll)r * a % p;\n\treturn r;\n}\n\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate<class A, class B> string to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate<class A> string to_string(A v) {\n\tbool first = true; string res = \"{\";\n\tfor (const auto &x : v) {\n\t\tif (!first) res += \", \";\n\t\tfirst = false, res += to_string(x);\n\t}\n\tres += \"}\";\n\treturn res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate<class A, class...B> void debug_out(A H, B... T) { cerr << \" \" << to_string(H), debug_out(T...); }\nvoid scan(){}\ntemplate<class A, class...B> void scan(A &a, B &... b) { gi(a), scan(b...); }\n\ntemplate <class T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\ntemplate <class T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\n\nconst int N=505,M=3e7;\nu64 a[N][N],r[N],c[N];\nint n;\nbool chk(int p){\n\tint x;\n\tfor(x=2;x*x<=p;x++)if(p%x==0)return false;\n\treturn true;\n}\n\nint main(){\n\tint p,i,j;\n\tcin>>n;\n\tp=3;\n\tr[1]=c[1]=2;\n\tfor(i=2;i<=n;i++){\n\t\tif((u64)r[i-1]*p<=M)r[i]=r[i-1]*p;\n\t\telse for(r[i]=p;!chk(p);p++);\n\t}\n\tdo p++;while(!chk(p));\n\tfor(i=2;i<=n;i++){\n\t\tif((u64)c[i-1]*p<=M)c[i]=c[i-1]*p;\n\t\telse for(c[i]=p;!chk(p);p++);\n\t}\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)a[i][j]=(u64)r[i]*c[j],print(a[i][j]),putc(\" \\n\"[j==n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif(!x||!y)return x+y;\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=1;i<=n;i++)for(ll j=(i+1&1)+1;j<=n;j+=2)a[i][j]=p[i+j>>1]*p[n+(i-j>>1)+(n+1)>>1];\n\tfor(ll i=1;i<=n;i++)for(ll j=(i&1)+1;j<=n;j+=2)if((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pir pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define pb push_back\nusing namespace std;\n\nconst int N=510,M=10010;\nint n,prime[M],cnt;\nll res[N][N];\nbool vis[M];\nvector<pir> v;\n\nvoid pre(int m) {\n    for(int i=2;i<=m;i++) {\n        if(!vis[i]) prime[++cnt]=i;\n        for(int j=1;j<=cnt;j++) {\n            int tmp=prime[j]*i;\n            if(tmp>m) break;\n            vis[tmp]=1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nbool cmp1(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi+a.se<b.fi+b.se;\n    return a<b;\n}\n\nbool cmp2(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi-a.se<b.fi-b.se;\n    return a<b;\n}\n\nll lcm(ll a,ll b) {\n    return a/__gcd(a,b)*b;\n}\n\nint main() {\n    pre(10000);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2==0) v.pb({i,j});\n            res[i][j]=1;\n        }\n    }\n    sort(v.begin(),v.end(),cmp1);\n    pir pre={0,0};\n    int* ptr=prime;\n    for(auto p:v) {\n        if(p.fi+p.se!=pre.fi+pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    sort(v.begin(),v.end(),cmp2);\n    pre={0,0};\n    for(auto p:v) {\n        if(p.fi-p.se!=pre.fi-pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                if(i>1) res[i][j]=lcm(res[i][j],res[i-1][j]);\n                if(j>1) res[i][j]=lcm(res[i][j],res[i][j-1]);\n                if(i<n) res[i][j]=lcm(res[i][j],res[i+1][j]);\n                if(j<n) res[i][j]=lcm(res[i][j],res[i][j+1]);\n            }\n            printf(\"%lld \",res[i][j]);\n        }\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nint n;\nll a[505][505];\nstd::set<ll> s;\n\ninline bool chk(int x) {\n    for(int i = 2; (ll)i*i <= x; ++i) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    vector<int> v;\n    for(int i = 2; ; ++i) {\n        if(chk(i)) { v.pb(i); }\n        if(v.size() == 1002) break;\n    }\n\n    read(n);\n    if(n == 2) {\n        puts(\"4 7\");\n        puts(\"23 10\");\n        return 0;\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)%2==0) {\n                a[i][j] = 1ll * v[(i+j)/2] * v[(i-j)/2+750];\n                s.insert(a[i][j]);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)&1) {\n                ll lcm = 1;\n                if(i>1) lcm = a[i-1][j] / std::__gcd(lcm, a[i-1][j]) * lcm;\n                if(i<n) lcm = a[i+1][j] / std::__gcd(lcm, a[i+1][j]) * lcm;\n                if(j>1) lcm = a[i][j-1] / std::__gcd(lcm, a[i][j-1]) * lcm;\n                if(j<n) lcm = a[i][j+1] / std::__gcd(lcm, a[i][j+1]) * lcm;\n\n                a[i][j] = lcm + 1;\n                s.insert(a[i][j]);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            printf(\"%lld \", a[i][j]);\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 10010;\n\ninline ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint tot;\nint pri[MAXN];\nint chk[MAXN];\nll a[510][510];\n\ninline void Sieve(int n) {\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nunordered_map<int, int>id1, id2, vis;\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tSieve(10000);\n\tint n = ri, N = 0, t = n - (n & 1); ++n;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\ta[i][j] = 1;\n\tfor(int i = 1; i <= t; i++) id1[i << 1 | 1] = ++N;\n\tfor(int i = 1; i <= t; i++) id2[t + 1 - i * 2] = ++N;\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1)\n\t\t\t\ta[i][j] = pri[id1[i + j]] * pri[id2[i - j]];\n\tfor(int i = 1; i < n; i++) {\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) printf(\"%lld \", a[i][j]);\n\t\t\telse {\n\t\t\t\tll x = lcm(lcm(a[i + 1][j], a[i - 1][j]), lcm(a[i][j + 1], a[i][j - 1])), y = x + 1;\n\t\t\t\twhile(vis[y]) y += x; vis[y] = 1;\n\t\t\t\tprintf(\"%lld \", y);\n\t\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10010;\n\ntypedef long long LL;\n\nint flag[N], prime[N], pcnt;\n\ninline void sieve() {\n    for (int i = 2; i <= N - 10; i++) {\n        if (!flag[i]) prime[++pcnt] = i;\n        for (int j = 1; j <= pcnt && i * prime[j] <= N - 10; j++) {\n            flag[i * prime[j]] = 1;\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\nLL G[510][510];\n\nLL gcd(LL a, LL b) {\n    return b ? gcd(b, a % b) : a;\n}\n\ninline LL lcm(LL a, LL b) {\n    return a / gcd(a, b) * b;\n}\n\ntemplate<typename... T>\ninline LL lcm(LL a, T... b) {\n    LL t = lcm(b...);\n    return a / gcd(a, t) * t;\n}\n\nint main() {\n    int n; scanf(\"%d\", &n), sieve();\n    if (n == 2) return puts(\"4 7\\n23 10\"), 0;\n    for (int i = 0; i <= n + 1; i++)\n        for (int j = 0; j <= n + 1; j++) G[i][j] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) if ((i + j) & 1) {\n            int a = i + j, b = i - j; a = (a - 1) / 2, b = (b + n + 1) / 2;\n            G[i][j] = (LL)prime[a] * prime[b + n - 1];\n        }\n    for (int i = 1; i <= n; i++, puts(\"\"))\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) & 1)) G[i][j] = (LL)lcm(G[i - 1][j], G[i][j - 1], G[i + 1][j], G[i][j + 1]) + 1;\n            printf(\"%lld \", G[i][j]);\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs int N = 1e3 + 50, M = 5e3;\nint n, a[N], b[N]; bool isp[M];\nll mp[N][N]; int prm[M], pc;\nvoid Sieve(){\n\tfor(int i=2; i<M&&pc<n+n; i++){\n\t\tif(!isp[i]) prm[++pc]=i;\n\t\tfor(int j=1; j<=pc; j++){\n\t\t\tif(prm[j]*i>=M) break;\n\t\t\tisp[prm[j]*i]=true; if(i%prm[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y){ return y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y){\n\tif(!x||!y) return x+y; \n\treturn x / gcd(x,y) * y;\n}\nint main(){\n\tscanf(\"%d\",&n); Sieve();\n\tint l=1, r=pc; \n\tfor(int i=1; i<=n; i++)\n\ta[i]=(i&1)?prm[l++]:prm[r--];\n\tfor(int i=1; i<=n; i++)\n\tb[i]=(i&1)?prm[l++]:prm[r--];\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) if((i+j)&1^1){\n\t\tint x=(i+j)>>1, y=(j+(n-i+1))>>1;\n\t\tmp[i][j]=(ll)a[x]*b[y];\n\t} for(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) if((i+j)&1){\n\t\tll x=lcm(mp[i-1][j-1],mp[i-1][j]);\n\t\tll y=lcm(mp[i+1][j],mp[i][j+1]); \n\t\tmp[i][j]=lcm(x,y)+1;\n\t} for(int i=1; i<=n; i++,puts(\"\"))\n\tfor(int j=1; j<=n; j++) cout<<mp[i][j]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) (int)x.size()\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAXN = 505;\nconst int MAX = 5e5;\n\nll n;\nll a[MAXN][MAXN];\nvector <int> prime;\nbool bio[MAX];\n\nll gcm(ll a, ll b){\n    return a / __gcd(a, b) * b;\n}\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n\n        prime.pb(i);\n\n        for(int j = i; j < MAX; j += i){\n            bio[j] = true;\n        }\n    }\n}\n\nvoid diagonala1(){\n    int x = 0, y = 0, cnt = 0;\n\n    while(y < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] = prime[cnt];\n            nx ++; ny --;\n        }\n\n        y += 2; cnt ++;\n    }\n\n    x = 0, y = n - 1;\n    if(!a[0][n - 1])\n        x = 1;\n    x += 2;\n\n    while(x < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] = prime[cnt];\n            nx ++; ny --;\n        }\n\n        x += 2; cnt ++;\n    }\n}\n\nvoid diagonala2(){\n    int x = 0, y = 0, cnt = 0;\n\n    while(y < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] *= prime[cnt];\n            nx ++; ny ++;\n        }\n\n        y += 2; cnt ++;\n    }\n\n    x = 0, y = n - 1;\n    if(!a[n - 1][0])\n        x = 1;\n\n    while(x < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] *= prime[cnt];\n            nx ++; ny ++;\n        }\n\n        x += 2; cnt ++;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    sito();\n    cin >> n;\n\n    diagonala1();\n    diagonala2();\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j]) continue;\n\n            ll sol = 1;\n            if(i > 0) sol = gcm(sol, a[i - 1][j]);\n            if(j > 0) sol = gcm(sol, a[i][j - 1]);\n            if(i < n - 1) sol = gcm(sol, a[i + 1][j]);\n            if(j < n - 1) sol = gcm(sol, a[i][j + 1]);\n\n            a[i][j] = sol + 1;\n\n        }\n\n    REP(i, n){\n        REP(j, n)\n            cout << a[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 233333;\nint notp[N], pri[N], pc = 0;\n\nint main() {\n  notp[1] = 1;\n  for (int i = 2; i < N; i++) {\n    if (!notp[i]) {\n      pri[++pc] = i;\n    }\n    for (int j = 1; j <= pc && i * pri[j] < N; j++) {\n      notp[i * pri[j]] = 1;\n      if (!(i % pri[j])) break;\n    }\n  }\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if ((i + j) & 1) {\n        printf(\"%lld \", (long long) pri[(i - j + n + 3) / 2] * pri[(i + j + n * 2 + 3) / 2]);\n      } else {\n        long long x = 1;\n        if (i > 1 || j > 1) x *= pri[(i + j - 1 + n * 2 + 3) / 2];\n        if (i < n || j < n) x *= pri[(i + j + 1 + n * 2 + 3) / 2];\n        if (i > 1 || j < n) x *= pri[(i - j - 1 + n + 3) / 2];\n        if (i < n || j > 1) x *= pri[(i - j + 1 + n + 3) / 2];\n        if (n == 2 && i == 1 && j == 1) x <<= 1;\n        printf(\"%lld \", x + 1);\n      }\n    }\n    puts(\"\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < (int)(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nint lcm(int a, int b) {\n    return a / __gcd(a, b) * b;\n}\n\nint lcm(vi vec) {\n    if (vec.empty())\n        return 1;\n    int ret = vec[0];\n    for (int i = 1; i < SZ(vec); ++i)\n        ret = lcm(ret, vec[i]);\n    return ret;\n}\n\nvi di = {0, 0, -1, 1};\nvi dj = {-1, 1, 0, 0};\nconst int N = 1e5 + 10;\nint ptr[N];\nint n;\nvvi g;\nvi ans;\nvoid dfs(int v) {\n    for (; ptr[v] < n; ++ptr[v]) {\n        int to = ptr[v];\n        if (to != v && !g[v][to]) {\n            g[v][to] = g[to][v] = true;\n            dfs(to);\n        }\n    }\n    ans.push_back(v);\n}\n\nvi get(int sz) {\n    int N = 1e5 + 10;\n    vector<bool> prime(N, true);\n    vi primes;\n    for (int i = 2; i < N; ++i) {\n        if (prime[i]) {\n            primes.push_back(i);\n            int x = SZ(primes);\n            if (x * (x - 1) / 2 > sz)\n                break;\n            for (int j = i * i; j < N; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n\n\n    n = primes.size();\n    g.resize(n);\n    fori (i, n) {\n        g[i].resize(n);\n    }\n    dfs(0);\n    vi ret(sz);\n    for (int i = 0; i < sz; ++i) {\n        ret[i] = primes[ans[i]] * primes[ans[i + 1]];\n    }\n    watch(*max_element(ALL(primes)));\n    return ret;\n}\n\nbool is_prime(int n) {\n    for (int i = 2; i * i <= n; ++i)\n        if (n % i == 0)\n            return false;\n    return true;\n}\n\nvoid smain() {\n    int n;\n    cin >> n;\n    vvl a(n, vl(n, 0));\n    set<int> used;\n    map<int, vector<pii>> diags;\n    fori (i, n) {\n        fori (j, n) {\n            if (((i ^ j) & 1)) {\n                diags[i + j].push_back({i, j});\n            }\n        }\n    }\n\n    vi kek;\n    int cur = n * 5 + 1;\n    while (!is_prime(cur))\n        cur++;\n    int curkek = 1;\n    for (auto item : diags) {\n        sort(ALL(item.second), [&] (const pii & f, const pii & s) -> bool {\n            return f.second < s.second;\n        });\n        int s = kek.size();\n        if (s < item.second.size()) {\n            curkek++;\n            while (!is_prime(curkek))\n                curkek++;\n            kek.push_back(curkek);\n\n            curkek++;\n            while (!is_prime(curkek))\n                curkek++;\n            kek.insert(kek.begin(), curkek);\n        } else if (s > item.second.size()) {\n            kek.erase(kek.begin());\n            kek.pop_back();\n        }\n        fori (i, SZ(kek)) {\n            a[item.second[i].first][item.second[i].second] = kek[i] * cur - 1;\n        }\n        cur++;\n        while (!is_prime(cur))\n            cur++;\n    }\n\n    fori (i, n) {\n        fori (j, n) if (a[i][j] == 0 ) {\n            vi vec;\n\n            fori (dir, SZ(di)) {\n                int ii = i + di[dir];\n                int jj = j + dj[dir];\n                if (ii >= 0 && ii < n && jj >= 0 && jj < n) {\n                    vec.push_back(a[ii][jj] + 1);\n                }\n            }\n            int x = lcm(vec);\n            ll cur = x;\n            while (used.count(cur))\n                cur += x;\n            a[i][j] = cur;\n            used.insert(a[i][j]);\n        }\n    }\n\n    ll mx = 0;\n    set<int> unq;\n    fori (i, n) {\n        fori (j, n) {\n            cerr << a[i][j] << \"   \";\n            inmax(mx, a[i][j]);\n            cout << a[i][j] * 2 + 2 << ' ';\n            assert(a[i][j] * 2 + 2 <= 1000000000000000L);\n//            if (unq.count(a[i][j] * 2 + 2)) {\n//                watch(i);\n//                watch(j);\n//            }\n            unq.insert(a[i][j] * 2 + 2);\n        }\n        cout << '\\n';\n    }\n    assert(unq.size() == n * n);\n    watch(mx);\n    watch(lcm({11, 22, 12, 24}));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,1,(N*N)/2){\n            prime.pb(aa*2);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==0){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==1){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n//                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n                    a[i][j]=lcm(a[i-1][j],a[i+1][j]);\n                    a[i][j]=lcm(a[i][j],a[i][j-1]);\n                    a[i][j]=lcm(a[i][j],a[i][j+1]);\n                    a[i][j]++;\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "        #include<bits/stdc++.h>\n        #define int long long\n        using namespace std;\n        typedef pair<int,int> P;\n         \n        signed main(){\n          vector<int> v;\n          int t=3;\n          while(v.size()<1000){\n            bool f=1;\n            for(int i=2;i*i<=t;i++)if(t%i==0)f=0;\n            if(f)v.push_back(t);\n            t++;\n          }\n          int d1[500][500],d2[500][500],c=0;\n          for(int i=-498;i<500;i+=2){\n            for(int j=-i;j+i<500;j++){\n              if(0<=j&&j<500&&0<=j+i&&j+i<500)d1[j][j+i]=v[c];\n            }\n            c++;\n          }\n         \n          for(int i=0;i<1000;i+=2){\n            for(int j=1000;i-j<500;j--){\n              if(0<=j&&j<500&&0<=i-j&&i-j<500)d2[j][i-j]=v[c];\n            }\n            c++;\n          }\n         \n          int n;\n          cin>>n;\n          \n          int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n          for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n              if(j)cout<<\" \";\n              if((i+j)%2){\n        \tint res=1;\n        \tset<int> s;\n        \tfor(int k=0;k<4;k++){\n        \t  int nx=j+dx[k],ny=i+dy[k];\n        \t  if(nx<0||ny<0||nx>=500||ny>=500)continue;\n        \t  s.insert(d1[ny][nx]);\n        \t  s.insert(d2[ny][nx]);\n        \t}\n        \tfor(auto z:s){res*=z;}\n        \tcout<<res+1;\n              }\n              else cout<<d1[i][j]*d2[i][j];\n            }\n            cout<<endl;\n          }\n          return 0;\n        }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 5000; \nconst long long INF = 0x3f3f3f3f; \n\nint cnt, idx, n; \nlong long ans[550][550], prime[Maxv], max = -INF; \nlong long x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \nbool notPrime[Maxv]; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void Sieve() {\n    for (int i = 2; i <= Maxv; i++) {\n        if (!notPrime[i]) {\n            prime[++cnt] = i; \n        }\n\n        for (int j = 1; j <= cnt && i * prime[j] <= Maxv; j++) {\n            int num = i * prime[j]; \n            notPrime[num] = true; \n\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    Sieve(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", prime[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = prime[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= prime[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++) cout<<(i+j)*3-2<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin>>n;\n\tlong long d[1010];\n\td[0]=2;\n\tfor(int i=0;i<(2*n-2);i++){\n\t\td[i+1]=d[i]*2+1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcout<<d[i+j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a*b/__gcd(a,b);\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;P.PB(0);\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=7919;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t\t//cout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MN 505\nusing namespace std;\ntypedef long long ll;\nint n,pr[MN<<2],tt;bool p[MN*MN];\nll a[MN][MN];\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=1e5;i++){\n\t\tif(!p[i]){\n\t\t\tpr[++tt]=i;\n\t\t\tif(tt>=4*n)break;\n\t\t}\n\t\tfor(int j=1;j<=tt;j++){\n\t\t\tif(i*pr[j]>1e5)break;\n\t\t\tp[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}ll tt=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==0){\n\t\t\t\ta[i][j]=1ll*pr[i+j>>1]*pr[(i-j)/2+n];\n\t\t\t}else {\n\t\t\t\ta[i][j]=1ll*pr[i+j>>1]*pr[(i+j+1)>>1];\n\t\t\t\tif(i-j<0)a[i][j]*=1ll*pr[(i-j)/2+n]*pr[(i-j-1)/2+n];\n\t\t\t\telse a[i][j]*=1ll*pr[(i-j)/2+n]*pr[(i-j+1)/2+n];a[i][j]++;\n\t\t\t\ttt=max(a[i][j],tt);\n\t\t\t}//printf(\"%lld\\n\",tt);\n/*\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=0;k<4;k++){\n\t\tint tx=i+dx[k],ty=j+dy[k];\n\t\tif(tx>=1&&tx<=n&&ty>=1&&ty<=n){\n\t\t\tif(max(a[i][j],a[tx][ty])%min(a[i][j],a[tx][ty])!=1)printf(\"%d %d %d %d\\n\",i,j,tx,ty);\n\t\t}\n\t}*/\n\tfor(int i=1;i<=n;i++){for(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);puts(\"\");}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(N);\n    for (int i = 0; i < N; i++) {\n        ans[i].resize(N);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = (i % 2); j < N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + N) / 2;\n            ans[i][j] = primes[(p % 2 == 0) ? (p / 2) : (N - 1 - p / 2)] *\n                        primes[(q % 2 == 0) ? (q / 2) : (N - 1 - q / 2) + N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < N; i++) {\n        for (int j = 1 - (i % 2); j < N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < N && 0 <= j + dj[k] &&\n                    j + dj[k] < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                    assert(ans[i][j] <= 1e15);\n                }\n            }\n            ans[i][j]++;\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (auto& row : ans) {\n        for (ll a : row) {\n            cout << a << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int maxN = 500;\n\nlong long gcd(long long a, long long b){\n    return a%b ? gcd(b, a%b) : b;\n}\n\nlong long lcm(long long a, long long b){\n    return a/gcd(a, b)*b;\n}\n\nvector<int> getPrimes(){\n    vector<int> p(100000, 1);\n    vector<int> primes;\n    for(int i=2;;i++){\n        if(!p[i]) continue;\n        primes.push_back(i);\n        if(primes.size() == 2 * maxN) break;\n        for(int j=2*i;j<100000;j+=i) p[j] = 0;\n    }\n    vector<int> res(2*maxN);\n    for(int i=0;i<maxN;i++){\n        res[2*i] = primes[i];\n        res[2*i+1] = primes[2*maxN-1-i];\n    }\n    return res;\n}\n\nvector<vector<long long>> makeBoard(){\n    vector<vector<long long>> res(maxN, vector<long long>(maxN, 0));\n    vector<int> primes = getPrimes();\n    for(int i=0;i<maxN;i++){\n        for(int j=i%2;j<maxN;j+=2){\n            int idxA = (i+j)/2;\n            int idxB = (i-j+maxN-2)/2;\n            res[i][j] = (long long)primes[idxA] * primes[idxB];\n        }\n    }\n    for(int i=0;i<maxN;i++){\n        for(int j=1-i%2;j<maxN;j+=2){\n            res[i][j] = 1;\n            int dx[] = {-1, 0, 1, 0};\n            int dy[] = {0, -1, 0, 1};\n            for(int k=0;k<4;k++){\n                int nx = i + dx[k];\n                int ny = j + dy[k];\n                if(nx < 0 || maxN <= nx || ny < 0 || maxN <= ny) continue;\n                res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n            ++res[i][j];\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N;\n    auto board = makeBoard();\n    while(cin >> N){\n        for(int i=0;i<N;i++){\n            cout << board[i][0];\n            for(int j=1;j<N;j++) cout << \" \" << board[i][j];\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 2000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint pri[N],p[N],tot;\ninline void sieve(int n)\n{\tfor(rint i=2;i<=n;i++)\n\t{\tif(!pri[i]) p[++tot]=i;\n\t\tfor(rint j=1;j<=tot&&i*p[j]<=n;j++)\n\t\t{\tpri[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll a[666][666]; int mov[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\ninline ll lcm(ll x,ll y){return x*y/__gcd(x,y);}\nint main()\n{\tint n,cur=1; cin>>n; sieve(1e6);\n\tfor(rint i=0;i<=n+1;i++)\n\tfor(rint j=0;j<=n+1;j++) a[i][j]=1;\n\tfor(rint i=3;i<=n+n;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i-j&&i-j<=n) a[j][i-j]*=p[cur];\n\tfor(rint i=1;i<=n-1;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=-1;i>=1-n;i-=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=1;i<=n;i++)\n\tfor(rint j=1;j<=n;j++)\n\tif((i+j)%2==0)\n\tfor(rint k=0;k<4;k++) a[i][j]=lcm(a[i][j],a[i+mov[k][0]][j+mov[k][1]]);\n\tfor(rint i=1;i<=n;i++,cout<<\"\\n\")\n\tfor(rint j=1;j<=n;j++) cout<<a[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 2e4 + 5;\nint sito[N];\nint nww(int a, int b) {\n  if (a == 0) { return b; }\n  if (b == 0) { return a; }\n  int g = __gcd(a, b);\n  return a / g * b;\n}\nint Good(int a, int b) {\n  if (a > b) { swap(a, b); }\n  return (b % a == 1);\n}\nint a[505][505];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n\n  int n;\n  cin>>n;\n  vector<int> lp;\n  for (int i = 2; i < N; i++) {\n    if (sito[i] == 0) {\n      lp.PB(i);\n      for (int j = 1; i * j < N; j++) {\n        sito[i * j] = 1;\n      }\n    }\n  }\n  debug(SZ(lp));\n  debug(lp[499]);\n  RE (i, n) {\n    RE (j, n) {\n      if (i % 2 == j % 2) {\n        a[i][j] = lp[(i - j) / 2 + 750] * lp[(i + j) / 2];\n      }\n    }\n  }\n  RE (i, n) {\n    RE (j, n) {\n      if (i % 2 != j % 2) {\n        int mult = 1;\n        if (i == 1 && j == 2) {\n          mult = 2;\n        }\n        a[i][j] = nww(a[i + 1][j], nww(a[i - 1][j], nww(a[i][j + 1], a[i][j - 1]))) * mult + 1;\n      }\n      cout<<a[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  set<int> lols;\n  int ma = 0;\n  RE (i, n) {\n    RE (j, n) {\n      lols.insert(a[i][j]);\n      assert(a[i][j] <= 1e15);\n      maxi(ma, a[i][j]);\n    }\n  }\n  debug(ma);\n  debug(n * n, SZ(lols));\n  assert(SZ(lols) == n * n);\n  RE (i, n) {\n    RE (j, n - 1) {\n      assert(Good(a[i][j], a[i][j + 1]));\n    }\n  }\n  RE (i, n - 1) {\n    RE (j, n) {\n      assert(Good(a[i][j], a[i + 1][j]));\n    }\n  }\n//   RE (i, n) {\n//     RE (j, m) {\n//       if (i % 2 == j % 2) {\n//         a[i][j] = \n//     }\n//   }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n//ARC055D\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n/*int gcd(int a,int b){\n\tif(a==0)return b;\n\tif(b==0)return a;\n\tif(a<0)a=-a;\n\tif(b<0)b=-b;\n\tint s=botbit(a|b);\n\ta>>=botbit(a);\n\tdo{\n\t\tb>>=botbit(b);\n\t\tif(a>b)swap(a,b);\n\t\tb-=a;\n\t}while(b);\n\treturn a<<s;\n\t\n}*/\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nconst int B=500;\n\nvi snuke(int n){\n\tconst int Vmax=1000;\n\tvi u(B+1);\n\tvi res{B};\n\tu[B]=1;\n\twhile(int(res.size())<n){\n\t\tint a=res.back();\n\t\tbool z=0;\n\t\tgnr(b,1,B+1)if(!u[b]&&lcm(a,b)<=Vmax){\n\t\t\tres.pb(b);\n\t\t\tu[b]=1;\n\t\t\tz=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(!z){\n\t\t\tcout<<u.size()<<endl;\n\t\t}\n\t\tassert(z);\n\t}\n\treturn res;\n}\n\nbool isprime(int p){\n\tfor(int i=2;i*i<=p;i++)\n\t\tif(p%i==0)return false;\n\treturn true;\n}\n\nvi pris(int n){\n\tvi res;\n\tint cur=B+1;\n\twhile(int(res.size())<n){\n\t\tif(isprime(cur))res.pb(cur);\n\t\tcur++;\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int n;cin>>n;\n\t//cout<<snuke((n+1)/2)<<endl;\n\t//cout<<pris(n/2*2).back()<<endl;\n\t\n\tint n;cin>>n;\n\tvvc<int> a(n,vi(n,-1));\n\tset<int> s;\n\tauto waf=[&](int v,int off){\n\t\tint d=v+off;\n\t\twhile(s.count(d))d+=v;\n\t\ts.insert(d);\n\t\treturn d;\n\t};\n\tvi c=snuke((n+1)/2);\n\tvi ps=pris(n);\n\trep(i,n){\n\t\tfor(int j=(i+1)%2;j<n;j+=2){\n\t\t\ta[i][j]=ps[i]*c[j/2];\n\t\t}\n\t}\n\tint mx=0;\n\trep(i,n)rep(j,n)chmax(mx,a[i][j]);\n\tcerr<<mx<<endl;\n\tusing T=tuple<int,int,int>;\n\tvc<T> z;\n\trep(i,n)rep(j,n){\n\t\tif((i+j)%2==0){\n\t\t\tint w=1;\n\t\t\tconst int dyx[]{-1,0,1,0,-1};\n\t\t\trep(k,4){\n\t\t\t\tint y=i+dyx[k],x=j+dyx[k+1];\n\t\t\t\tif(0<=y&&y<n&&0<=x&&x<n)\n\t\t\t\t\tw=lcm(w,a[y][x]);\n\t\t\t}\n\t\t\tchmax(mx,w);\n\t\t\tz.eb(w,i,j);\n\t\t}\n\t}\n\tcerr<<mx<<endl;\n\tsort(all(z),greater<T>());\n\tfor(auto p:z){\n\t\tint v,i,j;tie(v,i,j)=p;\n\t\tint d=waf(v,1);\n\t\ta[i][j]=d;\n\t\tchmax(mx,d);\n\t}\n\tcerr<<mx<<endl;\n\tassert(mx<=1000000000000000LL);\n\trep(i,n)\n\t\trep(j,n){\n\t\t\tcout<<a[i][j];\n\t\t\tif(j<n-1)cout<<\" \";\n\t\t\telse cout<<endl;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\nll seq[1005], arr[505][505], row[505], col[505];\ninline bool chk(int n)\n{\n\tfor (int i = 2; i * i <= n; i++)\n\t{\n\t\tif (!(n % i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline ll gcd(ll x, ll y)\n{\n\twhile (y)\n\t{\n\t\tauto r = x % y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn x;\n}\ninline ll lcm(ll x, ll y)\n{\n\tif (!x || !y)\n\t\treturn x + y;\n\treturn (__int128)x * y / gcd(x, y);\n}\nint main()\n{\n\t// freopen(\"AGC027-D.in\", \"r\", stdin);\n\tint n, cnt = 0, cur = 2;\n\tbool flg = true;\n\tscanf(\"%d\", &n);\n\tif (n & 1 ^ 1)\n\t{\n\t\tflg = true;\n\t\tn++;\n\t}\n\twhile (cnt <= n * 2)\n\t{\n\t\tif (chk(cur))\n\t\t\tseq[cnt++] = cur;\n\t\tcur++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tarr[i][j] = 1;\n\t}\n\tcur = 0;\n\tfor (int i = 0; i < n; i += 2)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= seq[cur];\n\t\tcur++;\n\t}\n\tfor (int i = 2; i < n; i += 2)\n\t{\n\t\tint x = 0, y = i;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= seq[cur];\n\t\tcur++;\n\t}\n\tcur = cnt - 1;\n\tfor (int i = 0; i < n; i += 2)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= seq[cur];\n\t\tcur--;\n\t}\n\tfor (int i = 2; i < n; i += 2)\n\t{\n\t\tint x = n - 1, y = i;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= seq[cur];\n\t\tcur--;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i & 1 ^ 1; j < n; j += 2)\n\t\t\tarr[i][j] = lcm(lcm(i ? arr[i - 1][j] : 0, j ? arr[i][j - 1] : 0),\n\t\t\t\t\t\t\tlcm(arr[i + 1][j], arr[i][j + 1])) + 1;\n\t}\n\tif (flg)\n\t\tn--;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tprintf(\"%lld%c\", arr[i][j], \" \\n\"[j + 1 == n]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\ntypedef  long long ll;\nll gcd(ll f , ll s){if(s==0)return f;else return gcd(s,f%s);}\nint const N = 1000006;\nll const M = 998244353;\nlong double const ep = .000000000000000001;\nint p[N];\nqueue<int>q;\nll Farray[1032][1032] , Sarray[1032][1023] , arr[1002][1003];\nint main() {\n\t\n\tint n;cin >> n;\n\tfor(int i = 2 ; i <= 1000 ; i++){\n\t\tif(!p[i]){\n\t\t\tfor(int x = i + i; x <= 100000 ; x+=i)p[x] = 1;\n\t\t}\n\t}\t\n\tfor(int i = 2 ; i <= 100000 ; i++)if(!p[i])q.push(i);\n\tpair<int,int>start = mp(0,0);\n\tfor(pair<int,int> i = start ; i.first < n ; i.first += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second < n ; x.first++ , x.second++){\n\t\t\tFarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\tfor(pair<int,int> i = mp(0,2) ; i.second < n ; i.second += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second < n ; x.first++ , x.second++){\n\t\t\tFarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\t\n\tfor(pair<int,int> i = start ; i.second < n ; i.second += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second >= 0 ; x.first++ , x.second--){\n\t\t\tSarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\n\tfor(pair<int,int> i = mp(1+(n%2),n-1) ; i.first < n ; i.first += 2){\n\t\tint currP = q.front();\n\t\tq.pop();\n\t\tfor(pair<int,int> x = i ; x.first < n && x.second >= 0 ; x.first++ , x.second--){\n\t\t\tSarray[x.first][x.second] = currP;\n\t\t}\n\t}\n\n\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int x = 0 ; x < n ; x++)\n\t\t\tarr[i][x] = Farray[i][x] * Sarray[i][x];\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 1){\n\t\t\t\tset<ll>s;\n\t\t\t\tif(i != 0){\n\t\t\t\t\ts.insert(Farray[i-1][j]);\n\t\t\t\t\ts.insert(Sarray[i-1][j]);\n\t\t\t\t}\n\t\t\t\tif(i != n-1){\n\t\t\t\t\ts.insert(Sarray[i+1][j]);\n\t\t\t\t\ts.insert(Sarray[i+1][j]);\n\t\t\t\t}\n\t\t\t\tif(j != 0){\n\t\t\t\t\ts.insert(Sarray[i][j-1]);\n\t\t\t\t\ts.insert(Sarray[i][j-1]);\n\t\t\t\t}\n\t\t\t\tif(j != n-1){\n\t\t\t\t\ts.insert(Sarray[i][j+1]);\n\t\t\t\t\ts.insert(Sarray[i][j+1]);\n\t\t\t\t}\n\t\t\t\tarr[i][j] = 1;\n\t\t\t\tset<ll>::iterator it = s.begin();\n\t\t\t\tfor(;it!=s.end() ; it++)arr[i][j]*= *(it);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tcout << arr[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair < int, int > PII;\ntypedef pair < LL, LL > PLL;\ntypedef pair < LD, LD > PDD;\n\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntemplate < typename _T > inline void _DBG(const char *s, _T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate < typename _T, typename... args > void _DBG(const char *s, _T x, args... a) { while(*s != ',') cerr << *s++; cerr << \" = \" << x << ','; _DBG(s + 1, a...); }\n\n#ifdef LOCAL\n#define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0) cout\n#endif\n\n// ********************** CODE ********************** //\n\nconst int N = 500;\n\nLL pri[] = {1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521};\n\nLL T[N][N];\nunordered_set < LL > S;\n\nLL nwd(LL a, LL b)\n{\n    if(b == 0) return a;\n    return nwd(b, a % b);\n}\n\nLL nww(LL a, LL b)\n{\n    return a / nwd(a, b) * b;\n}\n\nint main()\n{\n    _upgrade\n    srand(time(NULL) + getpid());  \n    random_shuffle(pri, pri + 1000);\n    for(int i = 0; i <= 2 * N; i += 2)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if(0 <= k && k < N)\n            {\n                T[j][k] = pri[i / 2];\n            }\n        }\n    }\n    LL st = 500;\n    for (int i = 0; i <= 2 * N; i += 2)\n    {\n        LL p = st;\n        for (int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if (0 <= k && k < N)\n            {\n                //DBG(j, k, T[j][k], p);\n                T[j][k] *= p;\n                S.insert(T[j][k]);\n                p++;\n            }\n        }\n        if(i + 1 < N)\n            st--;\n        else\n            st++;\n    }\n    LL lim = 1e15;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(T[i][j] != 0) continue;\n            vector < LL > v;\n            if(i > 0)\n                v.push_back(T[i - 1][j]);\n            if(j > 0)\n                v.push_back(T[i][j - 1]);\n            if(i + 1 < N)\n                v.push_back(T[i + 1][j]);\n            if(j + 1 < N)\n                v.push_back(T[i][j + 1]);\n            LL can = 0;\n            if(sz(v) == 1)\n            {\n                can = v[0];\n            }\n            else if(sz(v) == 2)\n            {\n                can = nww(v[0], v[1]);\n            }\n            else if(sz(v) == 3)\n            {\n                can = nww(v[0], nww(v[1], v[2]));\n            }\n            else\n            {\n                can = nww(v[0], nww(v[1], nww(v[2], v[3])));\n            }\n            //DBG(can, sz(v));\n            LL cp = can;\n            while(can + 1 <= lim && S.find(can + 1) != S.end())\n            {\n                //DBG(can + 1);\n                can += cp;\n            }\n            //DBG(i, j, T[i][j]);\n            if(can + 1 > lim)\n            {\n                //DBG(i, j, T[i][j]);\n                //for (auto u : v)\n                //    DBG(u);\n                //cout << \"KUPA\\n\";\n                //return 0;\n            }\n            S.insert(can + 1);\n            T[i][j] = can + 1;\n        }\n    }\n    /*\n    cout << \"{ \";\n    for(int i = 0; i < N; i++)\n    {\n        cout << \"{ \";\n        for(int j = 0; j < N; j++)\n        {\n            cout << T[i][j] << (j + 1 < N ? \", \" : \"\");\n        }\n        cout << \" }\" << (i + 1 < N ? \", \" : \"\");\n    }\n    cout << \" }\";\n    */\n    int n; cin >> n;\n    for(int  i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 924844033;\nconst int N = 20335;\nconst int K = 700 ;\nint ans[K][K], f[N], p[N], pp[N];\nvector < int > pr;\nmap < int, int > used;\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 2; i < N; i++){\n        if (f[i] == 0) pr.pb(i);\n        for (int j = i; j < N; j += i) f[j] = 1;\n    }\n    int l = 2;\n    int r = n + 1;\n    for (int i = 1; i <= n; i++){\n        if (i % 2){\n            p[i] = l;\n            l++;\n        } else{\n            p[i] = r;\n            r--;\n        }\n    }\n    l = 100;\n    r = n + n + 150;;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            if ((i + j) % 2 == 1) continue;\n            int d = i - j;\n            if (pp[d + n] == 0){\n                if (abs(d) % 4 == 2){\n                    l++;\n                    pp[d + n] = pr[l];\n                } else{\n                    r--;\n                    pp[d + n] = pr[r];\n                }\n            }\n            ans[i][j] = p[j] * pp[d + n];\n        }\n    }\n    int q = 0;\n    int cnt = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            if ((i + j) % 2 == 0) continue;\n            int x = 1;\n            if (ans[i - 1][j] != 0) x = ans[i - 1][j] * x / __gcd(ans[i - 1][j], x);\n            if (ans[i + 1][j] != 0) x = ans[i + 1][j] * x / __gcd(ans[i + 1][j], x);\n            if (ans[i][j - 1] != 0) x = ans[i][j - 1] * x / __gcd(ans[i][j - 1], x);\n            if (ans[i][j + 1] != 0) x = ans[i][j + 1] * x / __gcd(ans[i][j + 1], x);\n            int y = x;\n            while(used[y]){\n                y += x;\n                cnt++;\n            }\n            ans[i][j] = y;\n            if (y < 0){\n                cout << y;\n                return 0;\n            }\n            used[x] = 1;\n            q = max(q, y);\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 2005;\n\nint n, pri[N], isnt_pri[N], cnt;\nll a[N], b[N], c[N][N];\n\ninline ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\ninline ll lcm(ll x, ll y) { return (x && y) ? (x / gcd(x, y) * y) : (x | y); }\n\ninline void init()\n{\n\tfor (int i = 2; i < N; ++i)\n\t{\n\t\tif (!isnt_pri[i]) pri[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * pri[j] < N; ++j)\n\t\t{\n\t\t\tisnt_pri[i * pri[j]] = true;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tinit();\n\tif (n == 2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++i) a[i] = pri[i];\n\tfor (int i = 1; i <= n; ++i) b[i] = pri[i + n];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i ^ j) & 1) c[i][j] = a[i] * b[j];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!((i ^ j) & 1)) c[i][j] = lcm(lcm(c[i - 1][j], c[i][j - 1]), lcm(c[i + 1][j], c[i][j + 1])) + 1;\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) printf(\"%lld%c\", c[i][j], j == n ? '\\n' : ' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#define maxn 510\n#define ll long long\n\nusing namespace std;\n\nint n;\nll a[maxn][maxn], primes[2020];\nbool st[1000010];\nint cnt;\n\nvoid getprimes()\n{\n\tfor (int i = 2; i <= 10000; i ++ )\n\t{\n\t\tif (!st[i]) primes[++cnt] = i;\n\t\tfor (int j = 1; primes[j] * i <= 10000; j ++ )\n\t\t{\n\t\t\tst[primes[j] * i] = 1;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n}\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\tif (!a || !b) return a + b;\n\treturn a / gcd(a, b) * b;\n}\n\nint main()\n{\n\tgetprimes();\n\tscanf(\"%d\", &n);\n\t\n\tif (n == 2)\n\t{\n\t\tputs(\"2 6\");\n\t\tputs(\"12 3\");\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = primes[(i + j) / 2] * primes[n + (i - j) / 2 + (n + 1) / 2];\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = ((i & 1) + 1); j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i][j - 1], a[i - 1][j]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t{\n\t\tfor (int j = 1; j <= n; j ++ ) cout << a[i][j] << ' ';\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, cnt = 2;\nlong long res[507][507];\nmap<int, int>a, b;\nint nxt()\n{\n\twhile (1)\n\t{\n\t\tbool ok = 1;\n\t\tfor (int i = 2; i * i <= cnt && ok; i++)\n\t\t\tif (cnt % i == 0)ok = 0;\n\t\tif (ok)return cnt++;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\nlong long gcd(long long a, long long b)\n{\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nlong long lcm(long long a, long long b)\n{\n\tif (!a || !b)return 0;\n\treturn a / gcd(a, b) * b;\n}\nint main()\n{\n\tcin >> n;\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tif (!a[i + j])a[i + j] = nxt();\n\t\t\t\tif (!b[i - j])b[i - j] = nxt();\n\t\t\t\tres[i][j] = 1LL * a[i + j] * b[i - j];\n\t\t\t\tres[i - 1][j] = lcm(res[i - 1][j], res[i][j]);\n\t\t\t\tres[i][j - 1] = lcm(res[i][j - 1], res[i][j]);\n\t\t\t\tres[i + 1][j] = lcm(res[i + 1][j], res[i][j]);\n\t\t\t\tres[i][j + 1] = lcm(res[i][j + 1], res[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tres[i][j]++;\n\tfor (int i = 1; i <= n; i++, putchar('\\n'))\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tprintf(\"%lld \", res[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\ntemplate <typename T>\nvoid chkmax(T &dp, const T &val) {\n    if (val > dp) {\n        dp = val;\n    }\n}\n\nconst size_t N = 5E2 + 5;\nconst size_t M = 2E4 + 5;\n\nbool npr[M];\nmap<int, int> mp[N][N];\nLL a[N][N];\n\nvoid upd(map<int, int> &mp, const map<int, int> &dat) {\n    for (auto &pr : dat) {\n        int p = pr.first, e = pr.second;\n        chkmax(mp[p], e);\n    }\n}\n\nLL get_val(const map<int, int> &mp) {\n    LL ret = 1;\n    for (const auto &pr : mp) {\n        int p = pr.first, e = pr.second;\n        while (e--) {\n            ret *= p;\n        }\n    }\n    return ret;\n}\n\nLL calc(LL a, LL b) {\n    if (a < b) swap(a, b);\n    return a % b;\n}\n\nint main() {\n    vector<int> vc;\n    for (uint i = 2; i < M; ++i) {\n        if (!npr[i]) {\n            vc.emplace_back(i);\n            for (uint j = i << 1; j < M; j += i) {\n                npr[j] = true;\n            }\n        }\n    }\n\n    int n = read();\n    for (int s = 2, c = 0; s <= n + n; ++s) {\n        if (s & 1) continue;\n        for (int i = 1; i <= n; ++i) {\n            int j = s - i;\n            if (1 <= i && i <= n &&\n                1 <= j && j <= n) {\n                ++mp[i][j][vc[c]];\n            }\n        }\n        ++c;\n    }\n    for (int d = 1 - n, c = 0; d <= n - 1; ++d) {\n        if (d & 1) continue;\n        for (int i = 1; i <= n; ++i) {\n            int j = d + i;\n            if (1 <= i && i <= n &&\n                1 <= j && j <= n) {\n                ++mp[i][j][vc[c]];\n            }\n        }\n        ++c;\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if ((i ^ j) & 1) {\n                upd(mp[i][j], mp[i - 1][j]);\n                upd(mp[i][j], mp[i][j - 1]);\n                upd(mp[i][j], mp[i][j + 1]);\n                upd(mp[i][j], mp[i + 1][j]);\n                a[i][j] = get_val(mp[i][j]) + 1;\n            } else {\n                a[i][j] = get_val(mp[i][j]);\n            }\n            printf(\"%lld%c\", a[i][j], \"\\n \"[j < n]);\n        }\n    }\n    LL mx = 0;\n    set<LL> s;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (i < n) s.emplace(calc(a[i][j], a[i + 1][j]));\n            if (j < n) s.emplace(calc(a[i][j], a[i][j + 1]));\n            mx = max(mx, a[i][j]);\n        }\n    }\n    assert(s.size() == 1 && mx <= (LL) 1E15);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define FOR(i,n) for (int i = 0; i < n; i++)\n#define FORR(i,a,b) for (int i = a; i <= b; i++)\n#define ALL(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ii> vii;\n\nconst int MX = 505;\nint n, m = 0;\nll res[MX][MX], p[MX*2], mx = 0;\n\nvoid pre () {\n\tfor (int i = 2; m < 1000; i++) {\n\t\tbool f = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tf |= i % p[j] == 0;\n\t\tif (!f) p[m++] = i;\n\t}\n\n\tfor (int i = 0; i < MX; i++)\n\t\tfor (int j = 0; j < MX; j++)\n\t\t\tres[i][j] = 1;\n}\n\nint mv[] = {1, 0, -1, 0, 0, 1, 0, -1};\n\n__int128 gcd (__int128 a, __int128 b) { return b ? gcd(b, a%b) : a; }\n\nll lcm (int i, int j) {\n\t__int128 a = 1;\n\n\tfor (int l = 0; l < 4; l++) {\n\t\tint x = i + mv[l*2];\n\t\tint y = j + mv[l*2+1];\n\n\t\tif (x >= 0 && y >= 0 && x < n && y < n)\n\t\t\ta = a * res[x][y] / gcd(a, res[x][y]);\n\t}\n\n\tassert(0 < a && a <= 1e15);\n\treturn a;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tpre();\n\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\" << endl;\n\t\treturn 0;\n\t}\n\n\tint k = 0;\n\tfor (int i = 0; i < n; i++, k++) \n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (0 <= i*2-j && i*2-j < n)\n\t\t\t\tres[i*2-j][j] *= p[k];\n\n\tfor (int i = 0; 2 * i < n; i++, k++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (0 <= i*2+j && i*2+j < n)\n\t\t\t\tres[i*2+j][j] *= p[k];\n\n\tfor (int i = 1; -2 * i + n - 1 >= 0; i++, k++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (0 <= -i*2+j && -i*2+j < n)\n\t\t\t\tres[-i*2+j][j] *= p[k];\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (res[i][j] == 1)\n\t\t\t\tres[i][j] = lcm(i, j);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << res[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 100000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( ;i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\n__int128 cmmdc ( __int128 a , __int128 b ){\n\n    while ( b ){\n        __int128 t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\n__int128 calcLCM ( __int128 a , __int128 b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int i = 0 ; i < 2 * noLin ; i+=1 ){\n        diagPrin [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < 2 * noLin ; i+=2 ){\n        diagSec [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < noLin ; i+=1 ){\n        for ( int j = 0 ; j < noLin ; j+=1 ){\n            int crPrin = j - i + noLin - 1 ;\n            int crSec = 2*noLin - i - j - 1 ;\n\n            mat [ i ][ j ] = diagPrin [ crPrin ] * diagSec [ crSec ];\n        }\n    }\n\n    int jj = 0 ;\n    if ( noLin == 2 ){\n        int jj= 1 ;\n    }\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = jj ; j < noLin ; j++ ){\n\n            __int128  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            cout << mat [ i ][ j ] << \" \" ;\n//            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nll T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    n = 500;\n    vector<vector<ll>> m(n + 2, vector<ll>(n + 2, 1));\n    set<ll> used;\n    ll c = n*n;\n    for(int i=1;i<=n;i+=2) {\n        for(int j=1;j<=n;j+=2) {\n            assert(used.count(c) == 0);\n            assert(used.count(c * 2) == 0);\n            used.insert(c);\n            used.insert(c * 2);\n            m[i][j] = c;\n            m[i+1][j+1] = c*2;\n            c ++;\n        }\n    }\n\n    for(int i=1;i<=n;i+=1) {\n        for(int j=1;j<=n;j+=1) {\n            if (m[i][j] != 1) {\n                continue;\n            }\n            ll x = max(m[i-1][j], m[i][j+1]) * max(m[i][j-1], m[i+1][j]);\n            ll y = x;\n            while (used.count(y + 1)) y += x;\n            m[i][j] = y + 1;\n            used.insert(y + 1);\n        }\n    }\n\n    cin >> n;\n    REPS(i, n) {\n        REPS(j, n) {\n            cout << m[i][j] << \" \\n\"[j == n];\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nconst ll ccc=1000000;\nbool prime[ccc+1];\nvector<ll> pr;\nvoid makeprime(){\n\tll i,j;\n\tfor(i=2;i<=ccc;i++) prime[i]=true;\n\tfor(i=2;i*i<=ccc;i++) if(prime[i]) for(j=2;j*i<=ccc;j++) prime[j*i]=false;\n\tfor(i=2;i<=ccc;i++) if(prime[i]) pr.push_back(i);\n}\nll ans[500][500];\nint main(){\n\tmakeprime();\n\tconst int N = 500;\n\tint off = N+1;\n\trep(i,N) rep(j,N){\n\t\tif((i+j)%2==0){\t//small\n\t\t\tint x = (i+j)/2;\n\t\t\tint y = (i-j+N)/2 + off;\n\t\t\tans[i][j] = pr[x] * pr[y];\n\t\t}else{\n\t\t\tint x = (i+j)/2;\n\t\t\tint y = (i-j+N)/2;\n\t\t\tans[i][j] = pr[x]*pr[x+1]*pr[y]*pr[y+1];\n\t\t}\n\t}\n\trep(i,N) rep(j,N) assert(ans[i][j] <= 1000000000000000LL);\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,n) cout<<ans[i][j]<<\" \";\n\t\tputs(\"\");\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <cmath>\n\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nmap <ll, bool> hsh;\n\nll X[555][555];\n\nbool vis[55555555];\n\nint gcd(int a, int b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n    return a / gcd(a, b) * b;\n}\n\nsigned main() {\n    int n;\n    scanf(\"%lld\", &n);\n    for(int i = 0; i <= n + 1; i++)\n        for(int j = 0; j <= n + 1; j++)\n            X[i][j] = 1;\n    for(int i = 1; i <= n; i += 2) {\n        int cnt = 1, s = pow(i + 1, 1.5);\n        for(int j = 1; i + j - 1 <= n; j++) {\n            while(vis[cnt * ((int) s)]) cnt++;\n            X[j][i + j - 1] = cnt * s;\n            vis[cnt * s] = 1;\n            hsh[cnt * s] = 1;\n        }\n    }\n    for(int j = 3; j <= n; j += 2) {\n        int cnt = 1, s = pow(j, 1.5);\n        for(int i = 1; i + j - 1 <= n; i++) {\n            while(vis[cnt * ((int) s)]) cnt++;\n            X[i + j - 1][i] = cnt * ((int) s);\n            vis[cnt * s] = 1;\n            hsh[cnt * s] = 1;\n            \n        }\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            if((i + j) % 2) {\n                X[i][j] = lcm(lcm(X[i + 1][j], X[i][j + 1]), lcm(X[i - 1][j], X[i][j - 1]));\n                for(int k = 1; ; k++) if(!hsh[X[i][j] * k]) {\n                    X[i][j] *= k;\n                    hsh[X[i][j]] = 1;\n                    X[i][j]++;\n                    break;\n                }\n            }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            printf(\"%lld \", X[i][j]);\n            if(X[i][j] > 1e15) {\n                puts(\"----------------\");\n                printf(\"%lld %lld\\n\", i, j);\n                exit(0);\n            }\n        }\n        putchar('\\n');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n;\nll ans[555][555];\n\ndeque<int>pri;\nbool np[1001000];\n\nll lcm(ll x,ll y){\n    if (!x||!y) return x+y;\n    return x/__gcd(x,y)*y;\n}\n\nvoid prepri(int n){\n    for (int i=2;i<=n;++i){\n        if (np[i]) continue;\n        if (i!=2) pri.push_back(i);\n        for (int j=i+i;j<=n;j+=i)\n            np[j]=1;\n    }\n}\n\nmap<int,ll>ad, su;\n\nint main(){\n    prepri(1e4);\n    cin>>n;\n    for (int i=0;i<=n+1;++i)\n        for (int j=0;j<=n+1;++j)\n            if ((i+j)%2==0){\n                if (!ad[i+j]){\n                    if (i+j/2&1){\n                        ad[i+j]=pri.front();\n                        pri.pop_front();\n                    }else{\n                        ad[i+j]=pri.back();\n                        pri.pop_back();\n                    }\n                }\n                if (!su[i-j]){\n                    if (i+j/2&1){\n                        su[i-j]=pri.front();\n                        pri.pop_front();\n                    }else{\n                        su[i-j]=pri.back();\n                        pri.pop_back();\n                    }\n                }\n                ans[i][j]=ad[i+j]*su[i-j];\n            }\n    int dx[4]={0,0,1,-1};\n    int dy[4]={1,-1,0,0};\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            if ((i+j)%2==1){\n                ll l=1;\n                for (int d=0;d<4;++d)\n                    l=lcm(l,ans[i+dx[d]][j+dy[d]]);\n                ans[i][j]=l+1;\n            }\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j){\n            printf(\"%lld \",ans[i][j]);\n        }\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    LL n;\n    cin >> n;\n    vector<vector<LL> > a(n,vector<LL>(n));\n    LL maxa = 0;\n    set<LL> f;\n    vector<int> pr;\n    for(int j = 2; ; j++){\n        if(pr.size() >= 1200) break;\n        int ok = 1;\n        for(int z = 2; z * z <= j; z++){\n            if(j % z == 0) ok = 0;\n        }\n        if(ok){\n            pr.push_back(j);\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if((i + j) % 2) {\n                LL mult = (2*(i-j + 500) + 301) * (2 * (i+j) + 301);\n                for(LL q = 1; ; q++){\n                    if(f.find(mult * q) == f.end()){\n                        a[i][j] = mult * q;\n                        maxa = max(maxa, a[i][j]);\n                        f.insert(a[i][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if((i + j) % 2 == 0){\n                vector<int> dx = {0, 1, 0, -1};\n                vector<int> dy = {1, 0, -1, 0};\n                LL mult = 1;\n                for(int r = 0; r < 4; r++){\n                    LL ni = i + dx[r];\n                    LL nj = j + dy[r];\n                    if(ni < 0 || nj < 0 || ni >= n || nj >= n) continue;\n                    LL g = __gcd(mult, a[ni][nj]);\n                    mult = mult * a[ni][nj] / g;\n                }\n                for(LL q = 1; ; q++){\n                    if(f.find(mult * q + 1) == f.end()){\n                        a[i][j] = mult * q + 1;\n                        maxa = max(maxa, a[i][j]);\n                        f.insert(a[i][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long GCD(long long A, long long B) {\n\treturn (B == 0 ? A : GCD(B, A % B));\n}\n\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint L = ((N + 1) / 2) * 2;\n\tvector<int> Primes;\n\tfor (int i = 100; ; i++) {\n\t\tbool check = true;\n\t\tfor (int j = 2; j * j <= i; j++) {\n\t\t\tif (i % j == 0) {\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check) Primes.push_back(i);\n\t\tif (Primes.size() == L) break;\n\t}\n\tvector<long long> X(N), Y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tX[i] = Primes[i / 2];\n\t\t\tY[i] = Primes[i / 2 + L / 2];\n\t\t}\n\t\telse {\n\t\t\tX[i] = X[i - 1] * 2;\n\t\t\tY[i] = Y[i - 1] * 2;\n\t\t}\n\t}\n\tvector<vector<long long> > ANS(N, vector<long long>(N));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i & 1) == (j & 1)) ANS[i][j] = X[i] * Y[j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tANS[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ni = i + dx[k], nj = j + dy[k];\n\t\t\t\t\tif (0 <= ni && ni < N && 0 <= nj && nj < N) {\n\t\t\t\t\t\tANS[i][j] *= ANS[ni][nj] / GCD(ANS[i][j], ANS[ni][nj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i % 2 == 0) ANS[i][j] *= 2;\n\t\t\t\tANS[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << ANS[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }               \n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint pri[N]; bool vis[N];\nvoid init (int n)\n{\n\tfor (int i=2; ; i++)\n\t{\n\t\tif (!vis[i]) pri[++pri[0]]=i;\n\t\tif (pri[0]==n) break;\n\t\tfor (int j=1; j<=pri[0]; j++)\n\t\t{\n\t\t\tint p=pri[j],k=i*p;\n\t\t\tif (k> 10000) break;\n\t\t\tvis[k]=1;\n\t\t\tif (i%p==0) break;\n\t\t}\n\t}\n}\nLL lcm (LL x,LL y) { return (!x||!y)?(x+y):(x/__gcd (x,y)*y); }\nint n; LL a[1010][1010];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n); init (1000);\n\tif (n==2) return puts(\"4 7\\n23 10\"),0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if ((i+j+1)&1)\n\t\t\ta[i][j]=pri[(i+j)/2]*pri[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if (!a[i][j])\n\t\t\ta[i][j]=lcm (lcm (a[i-1][j],a[i][j-1]),lcm (a[i+1][j],a[i][j+1]))+1;\n\tfor (int i=1; i<=n; i++,putchar('\\n'))\n\t\tfor (int j=1; j<=n; j++,putchar(' '))\n\t\t\tprint(a[i][j]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,j,book[8005],top,zhan[8005],a[505][505];\nlong long gcd(long long u,long long v){\n\tif(v==0) return u;\n\treturn gcd(v,u%v);\n}\nlong long lcm(long long u,long long v){\n\tif(u==0) return v;\n\tif(v==0) return u;\n\treturn u/gcd(u,v)*v;\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tfor(i=2;i<=8000;i++)\n\t\tif(book[i]==0){\n\t\t\ttop++;\n\t\t\tzhan[top]=i;\n\t\t\tfor(j=i*2;j<=8000;j+=i)\n\t\t\t\tbook[j]=1;\n\t\t}\n\tn=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==0)\n\t\t\t\ta[i][j]=zhan[(i+j)/2]*zhan[(i-j)/2+n+(n+1)/2];\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n  \tfor(i=1;i<=n;i++,cout<<endl)\n  \t\tfor(j=1;j<=n;j++)\n  \t\t\tpus(a[i][j],1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N;\nll A[505][505];\n\nconst int prime_max = 1000000;\nint NP,prime[100000],divp[prime_max];\nmap<int,int> M;\n\nvoid cprime() {\n\tif(NP) return;\n\tfor(int i=2;i<prime_max;i++) if(divp[i]==0) {\n\t\tprime[NP++]=i;\n\t\tfor(ll j=1LL*i*i;j>=i&&j<prime_max;j+=i) if(divp[j]==0) divp[j]=i;\n\t}\n}\n\nll LCM(ll a,ll b) {\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/__gcd(a,b)*b;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\t\n\tcprime();\n\t\n\tvector<int> P[2];\n\tFOR(i,500) {\n\t\tif(i%2==0) {\n\t\t\tP[0].push_back(prime[i]);\n\t\t\tP[1].push_back(prime[i+1]);\n\t\t}\n\t\telse {\n\t\t\tP[0].push_back(prime[998-(i-1)]);\n\t\t\tP[1].push_back(prime[999-(i-1)]);\n\t\t}\n\t}\n\t\n\tFOR(y,500) FOR(x,500) if((x+y)%2==0) {\n\t\ti=(x+y)/2;\n\t\tj=(x-y)/2+249;\n\t\tA[y][x]=1LL*P[0][i]*P[1][j];\n\t}\n\tFOR(y,500) FOR(x,500) if((x+y)%2==1) {\n\t\tif(y) A[y][x]=LCM(A[y-1][x],A[y][x]);\n\t\tif(x) A[y][x]=LCM(A[y][x-1],A[y][x]);\n\t\tif(y<499) A[y][x]=LCM(A[y+1][x],A[y][x]);\n\t\tif(x<499) A[y][x]=LCM(A[y][x+1],A[y][x]);\n\t\tA[y][x]++;\n\t}\n\t\n\t\n\tFOR(y,N) {\n\t\tFOR(x,N) cout<<A[y][x]<<\" \";\n\t\tcout<<endl;\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma gcc optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,0,-1,1,0,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1)\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = arr[i][j] * arr[i + dir[k][0]][j + dir[k][1]] / __gcd(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n\tcin >> N >> M;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= M ; ++j) cout << arr[i][j] << \" \\n\"[j == M];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 2 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = (ml * ans[i][j - 1]) / gcd(ml, ans[i][j - 1]);\n\t\t\t\tif (i < n - 1) ml = (ml * ans[i + 1][j]) / gcd(ml, ans[i + 1][j]);\n\t\t\t\tif (j < n - 1) ml = (ml * ans[i][j + 1]) / gcd(ml, ans[i][j + 1]);\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n\n#define int long long \n\nconst int LIM = 2e6 + 7;\nconst int N = 500;\n\nint pr[LIM];\nvector<int> primes;\n\nint lcm(int a, int b) {\n    #ifdef LOCAL\n    return a / (gcd(a, b)) * b;\n    #else\n    return a / (__gcd(a, b)) * b;\n    #endif\n}\n\nvoid init() {\n    fill(pr, pr + LIM, 1);\n    for (int i = 2; i < LIM; i++) {\n        if (pr[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < LIM; j += i) {\n                pr[j] = 0;\n            }\n        }\n    }\n}\n\nint ans[N][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ans[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) & 1) {\n                ans[i][j] *= primes[i + j];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i - j) % 2 != 0) {\n                ans[i][j] *= primes[(i - j) + N];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                assert(ans[i][j] == 1);\n                if (i > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n                }\n                if (j > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n                }\n                if (i + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n                }\n                if (j + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n                }\n                ans[i][j]++;\n                // cerr << ans[i][j] << '\\n';\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, p[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tp[ pn++] = i;\n}\n\n\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%d\", &n );\n\tPrimeMap();\n\t\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0; j<n; ++j){\n\t\t\tint s= (i+j)>>1, d=(i-j)>>1;\n\t\t\t#ifdef che\n\t\t\tdebug(\"(x-y)=%d, d=%d\\n\", i-j, d);\n\t\t\t#endif\n\t\t\tif ( (i^j)&1 ) printf(\"%d \", p[s+1]*p[d+n+(n>>1)+1]);\n\t\t\t\telse\n\t\t\tprintf(\"%lld \",1ll*p[s+1]*p[s]*p[d+n+(n>>1)+1]*p[d+n+(n>>1)]+1);\n\t\t\t\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\tscanf(\"%d\", &n);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n\nll N;\nll prm[101010];\nll prmn;\nll ans[1010][1010];\nll i, j, k;\nll gcd(ll a,ll b){\n    if(b==0)\n        return a;\n    return gcd(b, a % b);\n}\nint main(){\n    scanf(\"%lld\",&N);\n    if(N==2){\n        printf(\"4 7\\n23 10\");\n        return 0;\n    }\n    i = 3;\n    prm[0] = 2;\n    prmn = 1;\n    while(prmn<=N*2){\n        fornum(k,1,prmn){\n            if(i%prm[k]==0){\n                break;\n            }\n        }\n        if(k==prmn){\n            prm[prmn] = i;\n            prmn++;\n            //printf(\"%lld,%lldd\\n\", i, prmn);\n        }\n        i += 2;\n    }\n    \n    fornum(i,0,N){\n        ans[i+10][N+10] =ans[N+10][i+10] = ans[i+10][9] =ans[9][i+10] = 1;\n        fornum(j,0,N){\n            if((i+j)%2)\n                continue;\n            //printf(\"%lld,%lld:%lld,%lld\\n\", i, j,(i-j+N)/2,(i+j)/2+N);\n            ans[i + 10][j + 10] = prm[(i - j + N) / 2] * prm[(i + j) / 2 + N];\n        }\n    }\n    fornum(i,0,N){\n        fornum(j,0,N){\n            if((i+j)%2){\n                ll d1 = ans[i + 9][j + 10] * ans[i + 10][j + 9]/gcd(ans[i + 9][j + 10] , ans[i + 10][j + 9]);\n                ll d2 = ans[i + 11][j + 10] * ans[i + 10][j + 11]/gcd(ans[i + 11][j + 10] , ans[i + 10][j + 11]);\n                ll d = d1 * d2 / gcd(d1, d2);\n                ans[i + 10][j + 10] = d + 1;\n            }\n            printf(\"%lld \", ans[i + 10][j + 10]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n\n  const int MAX = 3613;\n\n  vb vec(MAX + 1, true);\n  deque<int> prime;\n\n  for (int i=3; i<=MAX; i+=2) {\n    if (vec[i]) {\n      prime.emplace_back(i);\n      for (int j=i*i; j<=MAX; j+=2*i) {\n        vec[j] = false;\n      }\n    }\n  }\n\n  vl xs, ys;\n  rep(_,126) {\n    xs.emplace_back(prime.front());\n    prime.pop_front();\n    xs.emplace_back(prime.back());\n    prime.pop_back();\n  }\n  rep(_,126) {\n    ys.emplace_back(prime.front());\n    prime.pop_front();\n    ys.emplace_back(prime.back());\n    prime.pop_back();\n  }\n\n  bool odd = (n & 1) && (++n, true);\n\n  Graph<ll> ans(n, vl(n, 0));\n\n  rep(i,n/2) {\n    rep(j,n/2) {\n      ans[i*2+1][j*2+1] = 2 * (ans[i*2][j*2] = 2 * xs[i+1] * ys[j+1]);\n      ans[i*2][j*2+1] = 4 * xs[i+1] * xs[i] * ys[j+1] * ys[j+2] + 1;\n      ans[i*2+1][j*2] = 8 * xs[i+1] * xs[i+2] * ys[j+1] * ys[j] + 1;\n    }\n  }\n\n  if (odd) {\n    ans.pop_back();\n    for (auto &vec : ans) vec.pop_back();\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 8e3+10;\nint p[SIZE];\nvector<int>pp;\nvoid prime_init(){\n    for(int i=2;i<SIZE;i++){\n        if(!p[i]){\n            pp.PB(i);\n            for(int j=i;j<SIZE;j+=i){\n                if(!p[j])p[j]=i;\n            }\n        }\n    }\n}\nbool is_prime(int x){\n    return p[x]==x;\n}\nLL an[500][500];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nLL lcm(LL x,LL y){return x/__gcd(x,y)*y;}\nset<LL>AA;\nint main(){\n    prime_init();\n    int N;\n    R(N);\n    REP(i,N)REP(j,N)an[i][j]=1;\n    int ll=0,rr=1000;\n    int now=0;\n    for(int i=0;i<2*N-1;i+=2){\n        if(!now){\n            for(int j=0;j<=i&&j<N;j++){\n                if(i-j<N)an[j][i-j]*=pp[ll];\n            }\n            ll++;\n        }\n        else{\n            for(int j=0;j<=i&&j<N;j++){\n                if(i-j<N)an[j][i-j]*=pp[rr];\n            }\n            rr--;\n        }\n        now^=1;\n    }\n    for(int i=-((N-1)&(~1));i<N;i+=2){\n        if(!now){\n            REP(j,N){\n                if(i+j>=0&&i+j<N){\n                    an[i+j][j]*=pp[ll];\n                }\n            }\n            ll++;\n        }\n        else{\n            REP(j,N){\n                if(i+j>=0&&i+j<N){\n                    an[i+j][j]*=pp[rr];\n                }\n            }\n            rr--;\n        }\n        now^=1;\n    }\n    //REP(i,N)W(VL(an[i],an[i]+N));\n    LL ma=0;\n    REP(i,N)REP(j,N){\n        if(an[i][j]!=1)continue;\n        LL v=0;\n        REP(k,4){\n            int x=i+dx[k];\n            int y=j+dy[k];\n            if(x>=0&&y>=0&&x<N&&y<N){\n                if(!v)v=an[x][y];\n                else v=lcm(an[x][y],v);\n            }\n        }\n        int tt=1;\n        while(AA.count(v*tt+1))tt++;\n        an[i][j]=v*tt+1;\n        ma=max(ma,an[i][j]);\n        AA.insert(v*tt+1);\n    }\n    REP(i,N)W(VL(an[i],an[i]+N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n//#include <cassert>\nusing namespace std;\n\nconst int N = 10000;\ntypedef long long ll;\n\nint prime[N] , tot;\nvoid Init() {\n//\tvis[0] = vis[1] = true;\n\tstatic bool vis[N];\n\tfor(int i = 2 ; i < N ; ++i) {\n\t\tif(!vis[i]) prime[tot++] = i;\n\t\tfor(int j = 0 ; j < tot && prime[j] * i < N ; ++j) {\n\t\t\tvis[prime[j] * i] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n ;\nll ans[505][505];\n\ntemplate<typename T> T __lcm(T x , T y) {return x / __gcd(x , y) * y ;}\nbool valid(int x , int y) {return x > 0 && y > 0 && x <= n && y <= n;}\n\nint main() {\n//\tfreopen(\"atcoder.txt\" , \"w\" , stdout);\n\tInit();\n\tcin >> n;\n\tif(n == 2) {\n\t\tputs(\"2 3\");\n\t\tputs(\"5 4\");\n\t\treturn 0;\n\t}\n\tint l = 0 , r = 2 * n - 1 - ((n ^ 1) & 1), cur = 0;\n\t\n\tfor(int lim = (n & 1) ? (n - 1) : (n - 2) , d = -lim ; d <= lim ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , 1 + d) ; i <= min(n , n + d) ; ++i)\n\t\t\tans[i][i - d] = cur ? prime[l] : prime[r];\t\n\tfor(int d = 2 ; d <= 2 * n ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , d - n) ; i <= min(n , d - 1) ; ++i)\n\t\t\tans[i][d - i] *= cur ? prime[l] : prime[r];\n\t\n//\tassert(l == r + 1);\n//\tll max_val = 0;\n\tfor(int i = 1 ; i <= n ; ++i , putchar('\\n'))\n\t\tfor(int j = 1 ; j <= n ; ++j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tif(valid(i - 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i - 1][j]);\n\t\t\t\tif(valid(i + 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i + 1][j]);\t\n\t\t\t\tif(valid(i , j - 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j - 1]);\n\t\t\t\tif(valid(i , j + 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j + 1]);\n\t\t\t\tans[i][j]++;\t\n\t\t\t}\n\t\t\tprintf(\"%lld \" , ans[i][j]);\n//\t\t\tmax_val = max(max_val , ans[i][j]);\n\t\t}\n//\tfprintf(stderr , \"max_val = %lld\\n\" , max_val);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;++i)\n#define repd(i,a,b) for(int i=a;i>=b;--i) \n#define per(i,a,b) for(int i=a;i>=b;--i)\n#define rvc(i,S) for(int i=0;i<(int)S.size();++i)\n\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define maxn 400020\n#define N 8000020\n\nusing namespace std;\n\nint n;\n\n\nint main()\n{ cin>>n;\n  rep(i,1,n)\n    { int st; \n      if(i&1) st=2; else st=3;\n      rep(j,1,n)\n       { if(j&1) printf(\"%d \",st); else  printf(\"%d \",st+1);\n\t   }\n\t  puts(\"\");\n\t}\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N;\nbool prime[1000005];\nvector<llint> pvec;\nllint ans[505][505];\nconst llint di[] = {1, 0, -1, 0}, dj[] = {0, -1, 0, 1};\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tfor(int i = 2; i < 1005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j += i) prime[j] = true;\n\t}\n\tfor(int i = 3; i < 1000005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\tvector<llint> vec;\n\tfor(int i = 0; i < pvec.size(); i++){\n\t\tfor(int j = 0; j < 5; j++) vec.push_back(pvec[i] << j);\n\t}\n\tsort(vec.begin(), vec.end());\n\tpvec = vec;\n\t\n\tllint pos = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(ans[i][j]) continue;\n\t\t\tllint tmp = 1;\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif(ni > N || nj < 1 || nj > N) continue;\n\t\t\t\tif(ni < 1) tmp *= 32;\n\t\t\t\telse tmp *= ans[ni][nj];\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 20000\nusing namespace std;\nll a[505][505];\nll prime[1005];\nint cnt,p[20005],n;\n\nvoid print(ll x){\n\tif(x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\n\nll lcm(ll x,ll y){\n\treturn x/__gcd(x,y)*y;\n}\n\nint main(){\n\tfor(int i=2;i<=maxn;i++){\n\t\tif(p[i]==0) prime[++cnt]=i;\n\t\tif(cnt==1000) break;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<=maxn;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!((i&1)^(j&1))) a[i][j]=prime[(i+j)/2]*prime[n+(n+1+i-j)/2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)^(j&1)){\n\t\t\t\ta[i][j]=1;\n\t\t\t\tif(i>1) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\t\tif(i<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\t\tif(j>1) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\t\tif(j<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) print(a[i][j]),putchar(' ');\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn primes[x];\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn primes[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p >= MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = mind(i - j) * plud(i + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nconst int N=500;\nbool isprime[1000010];\nvector<ll> ps;\nll res[N][N];\nint di[]={-1,0,1,0};\nint dj[]={0,1,0,-1};\n\nll lcm(ll a,ll b){\n  return (a/__gcd(a,b))*b;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  repl(i,2,1000000)isprime[i]=true;\n  repl(i,2,1000000){\n    if(isprime[i]){\n      ps.push_back(i);\n      for(ll j=i*2;j<1000000;j+=i)isprime[j]=false;\n    }\n  }\n\n  while(ps.size()>1000)ps.pop_back();\n\n\n    rep(i,N)rep(j,N)res[i][j]=1;\n    for(ll s=0;s<2*N-1;s+=2){\n      rep(i,N){\n        ll j=s-i;\n        if(j>=N||j<0)continue;\n        res[i][j]*=ps[s/2];\n      }\n      rep(i,N){\n        ll s2=s-N+2;\n        ll j=i-s2;\n        if(j>=N||j<0)continue;\n        res[i][j]*=ps[N+(s/2)];\n      }\n    }\n\n    rep(i,N)rep(j,N){\n      if(res[i][j]==1){\n        ll lc=1;\n        rep(dir,4){\n          int ni=i+di[dir],nj=j+dj[dir];\n          if(ni<0||ni>=N||nj<0||nj>=N)continue;\n          lc=lcm(lc,res[ni][nj]);\n        }\n        res[i][j]=lc+1;\n      }\n    }\n\n  int n;\n  cin>>n;\n  rep(i,n){\n    rep(j,n){\n      cout<<res[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[510][510],c[510][501],ans[510][510],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=zs[(i+j)/2]*zs[n+(i-j)/2+(n+1)/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\nconst int N = 10000;\ntypedef long long ll;\n\nint prime[N] , tot;\nvoid Init() {\n//\tvis[0] = vis[1] = true;\n\tstatic bool vis[N];\n\tfor(int i = 2 ; i < N ; ++i) {\n\t\tif(!vis[i]) prime[tot++] = i;\n\t\tfor(int j = 0 ; j < tot && prime[j] * i < N ; ++j) {\n\t\t\tvis[prime[j] * i] = true;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint n ;\nll ans[505][505];\n\ntemplate<typename T> T __lcm(T x , T y) {return x * y / __gcd(x , y);}\nbool valid(int x , int y) {return x > 0 && y > 0 && x <= n && y <= n;}\n\nint main() {\n\tInit();\n\tcin >> n;\n\tif(n == 2) {\n\t\tputs(\"2 3\");\n\t\tputs(\"5 4\");\n\t\treturn 0;\n\t}\n\tint l = 0 , r = 2 * n - 1 - ((n ^ 1) & 1), cur = 1;\n\t\n\tfor(int lim = (n & 1) ? (n - 1) : (n - 2) , d = -lim ; d <= lim ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , 1 + d) ; i <= min(n , n + d) ; ++i)\n\t\t\tans[i][i - d] *= cur ? prime[l] : prime[r];\t\n\tfor(int d = 2 ; d <= 2 * n ; d += 2 , cur ? (cur = 0 , ++l) : (cur = 1 , --r))\n\t\tfor(int i = max(1 , d - n) ; i <= min(n , d - 1) ; ++i)\n\t\t\tans[i][d - i] = cur ? prime[l] : prime[r];\n\t\n\tassert(l == r + 1);\n\tll max_val = 0;\n\tfor(int i = 1 ; i <= n ; ++i , putchar('\\n'))\n\t\tfor(int j = 1 ; j <= n ; ++j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tif(valid(i - 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i - 1][j]);\n\t\t\t\tif(valid(i + 1 , j)) ans[i][j] = __lcm(ans[i][j] , ans[i + 1][j]);\t\n\t\t\t\tif(valid(i , j - 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j - 1]);\n\t\t\t\tif(valid(i , j + 1)) ans[i][j] = __lcm(ans[i][j] , ans[i][j + 1]);\n\t\t\t\tans[i][j]++;\t\n\t\t\t}\n\t\t\tprintf(\"%lld \" , ans[i][j]);\n\t\t\tmax_val = max(max_val , ans[i][j]);\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\n// ここから編集しろ\nlong long ans[510][510];\nint p[21000];\nvector<int>v;\nlong long gcd(long long a,long long b){\n\twhile(a){b%=a;swap(a,b);}return b;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tif(a==2){\n\t\tprintf(\"4 7\\n23 10\\n\");return 0;\n\t}\n\tp[0]=p[1]=-1;\n\tfor(int i=2;i<21000;i++){\n\t\tif(p[i]!=-1){\n\t\t\tif(i>2)v.push_back(i);\n\t\t\tp[i]=1;\n\t\t\tfor(int j=i+i;j<21000;j+=i)p[j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif((i+j)%2)continue;\n\t\t\tint X=(i+j)/2;\n\t\t\tint Y=(i-j+500)/2+500;\n\t\t\tlong long ks=1;\n\t\t\tks*=v[X];\n\t\t\tks*=v[Y];\n\t\t\tans[i][j]=ks;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif((i+j)%2){\n\t\t\t\tlong long cur=1;\n\t\t\t\tif(i)cur=cur/gcd(cur,ans[i-1][j])*ans[i-1][j];\n\t\t\t\tif(j)cur=cur/gcd(cur,ans[i][j-1])*ans[i][j-1];\n\t\t\t\tif(i<a-1)cur=cur/gcd(cur,ans[i+1][j])*ans[i+1][j];\n\t\t\t\tif(j<a-1)cur=cur/gcd(cur,ans[i][j+1])*ans[i][j+1];\n\n\t\t\t\tcur++;\n\t\t\t\tans[i][j]=cur;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(j)printf(\" \");\n\t\t\tprintf(\"%lld\",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 3000, M = 100010;\nLL a[N][N], prime[M], tot;\nbool vis[M];\n\nvoid init(int n) {\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (int j = 1; j <= tot && prime[j] * i <= n; ++ j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nLL lcm(LL x, LL y) {\n\tif (!x || !y) return x | y;\n\tLL o = std::__gcd(x, y);\n\treturn x / o * y;\n}\n\nsigned main() {\n\tinit(M - 1);\n\tint n = read();\n\tif (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i + 1][j], a[i][j + 1]));\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define value0(a) prime[(a)-1]\n#define value1(b) prime[(b)+749]\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {puts(\"4 7\\n23 10\"); return 0;} \n\tinit(10000);\n\tint ncnt=0;\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)%2==0) {\n\t\tan[i][j]=value0((i+j)/2)*value1((i-j)/2);\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if((x+y)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k],_y=y+dy[k];\n\t\t\tif(_x<1||_x>n||_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int N = 505, P = 10005;\nint p[P], pc = 0;\nbool np[P];\nvoid prime_sieve(int n) {\n  for (int i = 2; i <= n; ++i) {\n    if (!np[i]) p[pc++] = i;\n    for (int j = 0; j < pc && i * p[j] <= n; ++j) {\n      np[i * p[j]] = true;\n      if (i % p[j] == 0) break;\n    }\n  }\n}\n\nll a[N][N];\n\nll gcd(ll x, ll y) {\n  ll t;\n  while (y) t = x, x = y, y = t % y;\n  return x;\n}\nll lcm(ll x, ll y) {\n  if (!x || !y) return x | y;\n  return x / gcd(x, y) * y;\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint n;\nint border(int x, int y) {\n  return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nint main() {\n//  File(\"agc027d\");\n  prime_sieve(10000);\n  read(n);\n  if (n == 2) {\n    write(4, 7), endl();\n    write(23, 10), endl();\n  }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) {\n      if (((i ^ j) & 1) == 0) {\n        int l1 = (i + j) / 2;\n        int l2 = n + ((i - j) / 2) + (n - 1) / 2;\n        a[i][j] = p[l1] * p[l2];\n      }\n    }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (!a[i][j]) {\n        a[i][j] = 1;\n        for (int d = 0; d < 4; ++d)\n          if (border(i + dx[d], j + dy[d]))\n            a[i][j] = lcm(a[i][j], a[i + dx[d]][j + dy[d]]);\n      }\n      write(a[i][j]), space();\n    }\n    endl();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: wxyww\n* @Date: 2020-03-27 12:30:08\n* @Last Modified time: 2020-03-27 12:42:34\n*/\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1010;\nll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nll a[N][N];\nll prime[10010],tot,vis[10010];\nvoid pre() {\n\tfor(int i = 2;i <= 10000;++i) {\n\t\tif(!vis[i]) \n\t\t\tprime[++tot] = i;\n\t\tfor(int j = 1;j <= tot && prime[j] * i <= 10000;++j) {\n\t\t\tvis[prime[j] * i] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y) {\n\treturn !y ? x : gcd(y,x % y);\n}\nll lcm(ll x,ll y) {\n\treturn x * (y / gcd(x,y));\n}\nint main() {\n\tint n = read();\n\tif(n == 2) {\n\t\tputs(\"4 7\\n23 10\");return 0;\n\t}\n\n\tpre();\n\tfor(int i = 1;i <= n;++i) {\n\t\tfor(int j = 1;j <= n;++j) {\n\t\t\tif(!((i + j) & 1)) {\n\t\t\t\tint k1 = (i + j + 1) >> 1;\n\t\t\t\tint k2 = ((i - j + n + 1) >> 1) + n;\n\t\t\t\ta[i][j] = prime[k1] * prime[k2];\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor(int i = 1;i <= n;++i) {\n\t\tfor(int j = 1;j <= n;++j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\tll L = 1;\n\t\t\t\tif(i + 1 <= n)\n\t\t\t\t\tL = lcm(L,a[i + 1][j]);\n\t\t\t\t// cout<<L<<endl;\n\t\t\t\tif(j + 1 <= n)\n\t\t\t\t\tL = lcm(L,a[i][j + 1]);\n\t\t\t\tif(i - 1)\n\t\t\t\t\tL = lcm(L,a[i - 1][j]);\n\t\t\t\tif(j - 1)\n\t\t\t\t\tL = lcm(L,a[i][j - 1]);\n\n\t\t\t\ta[i][j] = L + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// puts(\"!!!\");\n\n\tfor(int i = 1;i <= n;++i) {\n\t\tfor(int j = 1;j <= n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// AT027D: Modular Matrix\n\nint main(){\n    int n; cin >> n;\n    int N = 500;\n    int M = 10*N;\n\n    bool squarefree[M];\n    for(int i = 1; i < M; i++) squarefree[i] = true;\n    for(int i = 2; i * i <= M; i++)\n        for(int j = i * i; j <= M; j += i * i) \n            squarefree[j] = false;\n\n    vector<int> sqfree;\n    for(int i = 2; i < M; i++) if(squarefree[i]) sqfree.push_back(i);\n\n    vector<long long> a(N+1);\n    for(int i = 0; i <= N; i += 4) a[i] = sqfree[i/4];\n    for(int i = 2; i <= N; i += 4) a[i] = sqfree[N/2-i/4];\n    for(int i = 1; i < N; i += 2) a[i] = a[i-1] * a[i+1];\n\n    for(int i = 0; i < n; i++) {\n    \tfor(int j = 0; j < n; j++) cout << a[i] * a[j] * a[j] << \" \";\n    \tcout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 510;\nint p[10010];\nvector<int> primes;\nint a[N * 2], b[N * 2];\n\nvoid init() {\n    for (int i = 2; i < 10000; i++) {\n        if (!p[i]) {\n            for (int j = i + i; j < 10000; j += i) {\n                p[j] = 1;    \n            }\n            primes.push_back(i);\n        }\n    }\n}\n\nlong long res[N][N];\nset<long long> has;\n\nlong long lcm(long long a, long long b) {\n    long long c = __gcd(a, b);\n    return (a / c) * b;\n}\n\nint main() {\n    init();    \n    int n;\n    scanf(\"%d\", &n);\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        a[i] = primes[cnt++];\n    }   \n    for (int i = 0; i < n; i++) {\n        b[i] = primes[cnt++];\n    }\n    memset(res, -1, sizeof res);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0) {\n                int aa = i + j >> 1;\n                int bb = (i - j + n) >> 1;\n                res[i][j] = 1ll * a[aa] * b[bb];\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0) {\n                continue;\n            }\n            long long foo = 1ll;\n            if (i > 0) {\n                foo = lcm(foo, res[i - 1][j]);\n            }\n            if (i + 1 < n) {\n                foo = lcm(foo, res[i + 1][j]);\n            }\n            if (j > 0) {\n                foo = lcm(foo, res[i][j - 1]);\n            }\n            if (j + 1 < n) {\n                foo = lcm(foo, res[i][j + 1]);\n            }\n            int it = 1;\n            while (has.count(foo * it)) {\n                it++;\n            }\n            has.insert(foo * it);\n            res[i][j] = foo * it + 1;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%lld \", res[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(MAX_N);\n    for (int i = 0; i < MAX_N; i++) {\n        ans[i].resize(MAX_N);\n    }\n\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = (i % 2); j < MAX_N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + MAX_N) / 2;\n            ans[i][j] =\n                primes[(p % 2 == 0) ? (p / 2) : (MAX_N - 1 - p / 2)] *\n                primes[(q % 2 == 0) ? (q / 2) : (MAX_N - 1 - q / 2) + MAX_N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = 1 - (i % 2); j < MAX_N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < MAX_N && 0 <= j + dj[k] &&\n                    j + dj[k] < MAX_N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                }\n            }\n            ans[i][j]++;\n            assert(ans[i][j] << 1e15);\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  int n;\n  cin >> n;\n  int val = n * n / 4;\n  vector<vector<ll>> ans(n + 2, vector<ll>(n + 2, 1));\n  int cnt = 0, l = 3, r = val * 2 + 1;\n  set<ll> st;\n  for (int i = 3; i <= n * 2; i += 2)\n    for (int x = max(1, i - n), y = i - x; x + 1 <= n && y - 1 > 0; x += 2, y -= 2) {\n      if (++cnt & 1) {\n        ans[x][y] = l;\n        ans[x + 1][y - 1] = l * 2;\n        st.insert(l); st.insert(l * 2);\n        l += 2;\n      } else {\n        ans[x][y] = r;\n        ans[x + 1][y - 1] = r * 2;\n        st.insert(r); st.insert(r * 2);\n        r -= 2;\n      } \n    }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j) {\n      if (ans[i][j] == 1) {\n        ll l = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n        ll v = 1;\n        while (st.count(v * l + 1)) ++v;\n        ans[i][j] += l * v;\n        st.insert(ans[i][j]);\n      }\n    }\n  for (int i = 1; i <= n; ++i)\n    cout << vector<ll>(ans[i].begin() + 1, ans[i].begin() + n + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nsigned main(){\n  vector<int> v;\n  int t=3;\n  while(v.size()<1000){\n    bool f=1;\n    for(int i=2;i*i<=t;i++)if(t%i==0)f=0;\n    if(f)v.push_back(t);\n    t++;\n  }\n  int d1[500][500],d2[500][500],c=0;\n  for(int i=-498;i<500;i+=2){\n    for(int j=-i;j+i<500;j++){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d1[j][j+i]=v[c];\n    }\n    c++;\n  }\n\n  for(int i=0;i<1000;i+=2){\n    for(int j=1000;i-j<500;j--){\n      if(0<=j&&j<500&&0<=i-j&&i-j<500)d2[j][i-j]=v[c];\n    }\n    c++;\n  }\n\n  int n;\n  cin>>n;\n  \n  int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(j)cout<<\" \";\n      if((i+j)%2){\n\tint res=1;\n\tset<int> s;\n\tfor(int k=0;k<4;k++){\n\t  int nx=j+dx[k],ny=i+dy[k];\n\t  if(nx<0||ny<0||nx>=500||ny>=500)continue;\n\t  s.insert(d1[ny][nx]);\n\t  s.insert(d2[ny][nx]);\n\t}\n\tfor(auto z:s){res*=z;}\n\tcout<<res+1;\n      }\n      else cout<<d1[i][j]*d2[i][j];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool IsGood(int x, const vector<int>& d) {\n  for (int y : d) {\n    while (x % y == 0) x /= y;\n  }\n  return x == 1;\n}\n\nll GCD(ll a, ll b) {\n  if (a == 0) return b;\n  return GCD(b % a, a);\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  if (n == 2) {\n    printf(\"4 7\\n23 10\\n\");\n    return 0;\n  }\n  const int BUBEN = 3e6;\n  vector<bool> p(BUBEN, true);\n  vector<ll> primes;\n  for (int i = 2; i < BUBEN; ++i) {\n    if (!p[i]) continue;\n    primes.push_back(i);\n    if (primes.size() >= 10000) break;\n    for (int j = i; j < BUBEN; j += i) p[j] = false;\n  }\n  vector<int> odd, even;\n  for (int i = 0; i < 2 * n; ++i) {\n    if (i % 2) odd.push_back(primes[i]); else even.push_back(primes[i]);\n  }\n  vector<ll> x, y;\n  for (int cur = 1; ; ++cur) {\n    if (x.size() == n && y.size() == n) break;\n    if (x.size() < n && IsGood(cur, odd)) {\n      x.push_back(cur);\n    } else if (y.size() < n && IsGood(cur, even)) {\n      y.push_back(cur);\n    }\n  }\n  vector<vector<ll>> ans(n, vector<ll>(n, 1));\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    if ((i + j) % 2 == 1) continue;\n    ans[i][j] = x[(i + j) / 2] * y[(i - j + n - 1) / 2];\n  }\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    if ((i + j) % 2 == 0) continue;\n    ll cur = 1;\n    for (int di = -1; di <= 1; ++di) for (int dj = -1; dj <= 1; ++dj) if (di * di + dj * dj == 1) {\n      int ii = i + di;\n      int jj = j + dj;\n      if (ii < 0 || ii >= n || jj < 0 || jj >= n) continue;\n      ll g = GCD(cur, ans[ii][jj]);\n      cur *= ans[ii][jj] / g;\n    }\n    ans[i][j] = cur + 1;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (j) cout << \" \";\n      cout << ans[i][j];\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n\n#define int long long \n\nconst int LIM = 2e6 + 7;\nconst int N = 500;\n\nint pr[LIM];\nvector<int> primes;\n\nint lcm(int a, int b) {\n    #ifdef LOCAL\n    return a / (gcd(a, b)) * b;\n    #else\n    return a / (__gcd(a, b)) * b;\n    #endif\n}\n\nvoid init() {\n    fill(pr, pr + LIM, 1);\n    for (int i = 2; i < LIM; i++) {\n        if (pr[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < LIM; j += i) {\n                pr[j] = 0;\n            }\n        }\n    }\n}\n\nint ans[N][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ans[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) & 1) {\n                ans[i][j] *= primes[i + j];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i - j) % 2 != 0) {\n                ans[i][j] *= primes[(i - j) + 3 * N];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                assert(ans[i][j] == 1);\n                if (i > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n                }\n                if (j > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n                }\n                if (i + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n                }\n                if (j + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n                }\n                ans[i][j]++;\n                // cerr << ans[i][j] << '\\n';\n            }\n        }\n    }\n    {\n        set<int> s;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                s.insert(ans[i][j]);\n            }\n        }\n        assert(s.size() == N * N);\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconstexpr int maxn = 10010;\ntypedef long long ll;\nint mnp[maxn], p[maxn], cnt;\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (!mnp[i]) mnp[i] = i, p[cnt++] = i;\n\t\tfor (int j = 0; j < cnt && p[j] * i <= n; ++j) {\n\t\t\tmnp[p[j] * i] = p[j];\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n; ll a[600][600];\ninline int get1(int x, int y) {\n\tif (x + y < 0 || (x + y) >> 1 >= n) return 1;\n\treturn p[(x + y) >> 1];\n}\ninline int get2(int x, int y) {\n\tif ((y - x) >> 1 < 0 || (y + n - x) >> 1 >= n) return 1;\n\treturn p[((y - x) >> 1) + n];\n}\nint main() {\n\tsieve(10000);\n\tstd::cin >> n;\n\tif (n == 2) {\n\t\tstd::cout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tstd::cout << ((i + j) % 2 == 0 ? 1ll * get1(i, j) * get2(i, j) : 1ll * get1(i, j - 1) * get1(i, j + 1) * get2(i, j - 1) * get2(i, j + 1) + 1) << \"\\n \"[j != n - 1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+5;\nint n,pri[N],tot,zhi[N],m;\nlong long ans[505][505];\nlong long lcm(long long x,long long y){\n\tif(!x)x=1;if(!y)y=1;\n\treturn x/__gcd(x,y)*y;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2)return puts(\"7 3\\n2 13\"),0;\n\tfor(int i=2;i<N;++i)\n\t\tif(!zhi[i]){\n\t\t\tpri[++tot]=i;\n\t\t\tfor(int j=i+i;j<N;j+=i)zhi[j]=1;\n\t\t}\n\tfor(int s=3;s<=n+n;s+=2){\n\t\tint p=pri[++m];\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tint j=s-i;\n\t\t\tif(1<=j&&j<=n)ans[i][j]=p;\n\t\t}\n\t}\n\tfor(int s=n&1?2-n:1-n;s<n;s+=2){\n\t\tint p=pri[++m];\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tint j=i+s;\n\t\t\tif(1<=j&&j<=n)ans[i][j]*=p;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i,puts(\"\"))\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(!ans[i][j])\n\t\t\t\tans[i][j]=lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]))+1;\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = min(min(n - i + 1, n - j + 1), min(i, j));\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=500+5,M=1e4+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n;\nint vis[M],l[M];\nvoid input()\n{\n\tn=read<int>();\n}\nvoid init(int Max)\n{\n\tFor(i,2,Max)\n\t{\n\t\tif(!vis[i])l[++l[0]]=i;\n\t\tfor(int j=1;j<=l[0]&&i*l[j]<=Max;j++)\n\t\t{\n\t\t\tvis[l[j]*i]=1;\n\t\t\tif(i%l[j]==0)break;\n\t\t}\n\t}\n}\nll mp[N][N];\nmap<ll,bool>used;\nint x[N<<1],y[N<<1];\nll lcm(ll x,ll y)\n{\n\tif(!x||!y)return x|y;\n\treturn x/__gcd(x,y)*y;\n}\nvoid work()\n{\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\tint t1=1,t2=1000;\n\tFor(i,1,n)For(j,1,n)if((i+j)&1)\n\t{\n\t\tif(!x[j-i+n])x[j-i+n]=l[t1++];\n\t\tif(!y[i+j])y[i+j]=l[t2--];\n\t\tmp[i][j]=x[j-i+n]*y[i+j];\n\t}\n\tFor(i,1,n)For(j,1,n)if(!mp[i][j])\n\t{\n\t\tmp[i][j]=lcm(mp[i][j],mp[i-1][j]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i+1][j]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i][j-1]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i][j+1]);\n\t\tmp[i][j]++;\n\t\tassert(used[mp[i][j]]==0);\n\t\tused[mp[i][j]]=1;\n\t}\n\tFor(i,1,n)For(j,1,n)\n\t{\n\t\t//cerr<<mp[i][j]<<endl;\n\t\tassert(mp[i][j]<=1e15);\n\t\tif(j>1)assert(max(mp[i][j],mp[i][j-1])%min(mp[i][j],mp[i][j-1])==1);\n\t\tif(i>1)assert(max(mp[i][j],mp[i-1][j])%min(mp[i][j],mp[i-1][j])==1);\n\t}\n\tFor(i,1,n)For(j,1,n)write(mp[i][j],j==n?'\\n':' ');\n}\nint main()\n{\n//\tfile();\n\tinput();\n\tinit(1e4);\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm> \n#include<set>\ntypedef long long ll;\nconst int N=500,vx[4]={-1,0,0,1},vy[4]={0,-1,1,0};\nint X=14414400;//245044800;\nll a[510][510];\nstd::set<ll>S;\nint d[510],dc,p[510];\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nint main(){\n\tfor(int i=1;dc<500;i++)if(X%i==0)d[dc++]=i;\n\tint pl=0,pr=249;\n\tfor(int i=17,ty=0,cnt=0;cnt<250;i+=2){\n\t\tif(i%2!=0&&i%3!=0&&i%5!=0&&i%7!=0&&i%11!=0&&i%13!=0&&i%17!=0)cnt++%2?p[pr]=i,pr-=2:(p[pl]=i,pl+=2);\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i+j)%2==0)a[i][j]=1ll*d[j]*p[i/2];\n\t\t}\n\t\tll mx=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tll L=1;\n\t\t\t\tfor(int d=0,dx,dy;d<4;d++)if((dx=i+vx[d])>=0&&dx<N&&(dy=j+vy[d])>=0&&dy<N)L=lcm(L,a[dx][dy]);\n\t\t\t\tfor(a[i][j]=L+1;S.find(a[i][j])!=S.end();a[i][j]+=L);\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t\tif(a[i][j]>mx)mx=a[i][j];\n\t\t\t}\n\t\t}\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 505;\nconst int Maxm = 100000;\n\nbool nprime[Maxm];\nvector <int> pr;\nint n;\nll B[Maxn][Maxn];\nset <ll> S;\n\nll gcd(ll x, ll y) { return x? gcd(y % x, x): y; }\n\nll lcm(ll x, ll y) { return x / gcd(x, y) * y;  }\n\nll Get(ll a, ll b) { return max(a, b) % min(a, b); }\n\nint main()\n{\n    for (int i = 2; i < Maxm; i++) if (!nprime[i]) {\n        pr.push_back(i);\n        for (int j = i + i; j < Maxm; j += i)\n            nprime[j] = true;\n    }\n    scanf(\"%d\", &n);\n    int pnt = 2;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i + j) % 2 == 0) {\n            B[i][j] = pr[(i + j) / 2] * pr[n + (i - j + n) / 2];\n            S.insert(B[i][j]);\n        }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i + j) % 2) {\n            ll my = 1;\n            if (i > 0) my = lcm(my, B[i - 1][j]);\n            if (i + 1 < n) my = lcm(my, B[i + 1][j]);\n            if (j > 0) my = lcm(my, B[i][j - 1]);\n            if (j + 1 < n) my = lcm(my, B[i][j + 1]);\n            ll cur = my;\n            while (S.find(cur + 1) != S.end()) {\n                cur += my;\n            }\n            B[i][j] = cur + 1;\n            S.insert(B[i][j]);\n        }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            printf(\"%lld%c\", B[i][j], j + 1 < n? ' ': '\\n');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconstexpr int maxn = 10010;\ntypedef long long ll;\nint mnp[maxn], p[maxn], cnt;\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (!mnp[i]) mnp[i] = i, p[cnt++] = i;\n\t\tfor (int j = 0; j < cnt && p[j] * i <= n; ++j) {\n\t\t\tmnp[p[j] * i] = p[j];\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n; ll a[600][600];\ninline int get1(int x, int y) {\n\tif (x + y < 0 || (x + y) >> 1 >= n) return 1;\n\treturn p[(x + y) >> 1];\n}\ninline int get2(int x, int y) {\n\tif ((y - x) >> 1 < 0 || (y + n - x) >> 1 >= n) return 1;\n\treturn p[((y - x) >> 1) + n];\n}\nint main() {\n\tsieve(10000);\n\tstd::cin >> n;\n\tstd::cout << n << std::endl;\n\tif (n == 2) {\n\t\tstd::cout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tstd::cout << ((i + j) % 2 == 0 ? 1ll * get1(i, j) * get2(i, j) : 1ll * get1(i, j - 1) * get1(i, j + 1) * get2(i, j - 1) * get2(i, j + 1) + 1) << \"\\n \"[j != n - 1];\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<9, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define lcm(x, y) (((x)/__gcd(x, y))*(y))\n\nbool prime(int a) {\n\tfor(int d = 2; d*d <= a; d++) if(a%d == 0) return 0;\n\treturn 1;\n}\n\nint n;\nll mat[maxn][maxn];\nvoid check() {\n\tll m = max(mat[0][0], mat[0][1]) % min(mat[0][0], mat[0][1]);\n\tfor(int i = 0; i + 1 < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(max(mat[i][j], mat[i + 1][j]) % min(mat[i][j], mat[i + 1][j]) != m) cerr << i << \" \" << j << \" \" << \"d\\n\";\n\tfor(int j = 0; j + 1 < n; j++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(max(mat[i][j], mat[i][j + 1]) % min(mat[i][j], mat[i][j + 1]) != m) cerr << i << \" \" << j << \" \" << \"f\\n\";\n\tll mcnt = 0;\n\tmap<ll, ll> cnt;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tmcnt = max(mcnt, ++cnt[mat[i][j]]);\n\tif(mcnt > 1)cerr << \"BAD\\n\";\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tn+=2;\n\tvi a, b;\n\tfor(int i = 2; b.size() < n; i++) {\n\t\tif(!prime(i)) continue;\n\t\tif(a.size() < n/2) {\n\t\t\tif(a.size()) {\n\t\t\t\ta.pb(a.back()*i);\n\t\t\t}\n\t\t\ta.pb(i);\n\t\t} else {\n\t\t\tif(b.size()) {\n\t\t\t\tb.pb(b.back()*i);\n\t\t\t}\n\t\t\tb.pb(i);\n\t\t}\n\t}\n\tset<ll> pf;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = (i&1)^1; j < n; j+=2) {\n\t\t\tmat[i][j] = a[i/2] * b[j/2];\n\t\t\twhile(pf.count(mat[i][j])) mat[i][j] *= 2;\n\t\t\tpf.insert(mat[i][j]);\n\t\t}\n\t}\nll on = n; n = 502;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = 1;\n\t\t\tif(i) g = lcm(g, mat[i-1][j]);\n\t\t\tif(i+1 < n) g = lcm(g, mat[i+1][j]);\n\t\t\tif(j) g = lcm(g, mat[i][j-1]);\n\t\t\tif(j+1 < n) g = lcm(g, mat[i][j+1]);\n\t\t\tmat[i][j] = g + 1;\n\t\t}\n\tset<ll> found = pf;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = mat[i][j]-1;\n\t\t\twhile(found.count(mat[i][j])) mat[i][j] += g;\n\t\t\tfound.insert(mat[i][j]);\n\t\t}\n\tn=on;\n\tll mx = 0;\n\tfor(int i = 0; i < n; i++, cout << '\\n')\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\tcheck();\n\t//if(mx > 1e15) exit(-1);\n}\n//\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i,a,b) for (int i = a; i <= b; i++)\n#define rep1(i, a, b) for(int i =a; i >=b; i--)\n#define f first\n#define ss second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\n\n\nint n,ans[2000][2000];\nset<int> primes;\nbool siv[100005];\n\nint lc (int w,int x,int y, int z){\n       int res = __gcd(w,x);\n       res = w*x/res;\n       res = res*y/__gcd(res,y);\n       res = res*z/__gcd(res,z);\n       //cout << res << endl;\n       return res;\n}\n\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n//freopen(\"input.txt\",\"r\",stdin);\n//freopen(\"output.txt\",\"w\",stdout);\n\ncin >> n;\nif(n==2){\n       cout << \"4 7 \\n23 10 \\n\";\n       return 0;\n}\nfor(int i=0;i<=n+1;i++){\n       for(int j=0;j<=n+1;j++)ans[i][j]=1;\n}\nfor(int i=2;i<100000;i++){\n       if(siv[i])continue;\n       for(int j=i+i;j<100000;j+=i){\n              siv[j]=true;\n       }\n}\nfor(int i=2;i<100000;i++){\n       if(!siv[i])primes.insert(i);\n}\n\n\nint t=n;\nif(n%2==0)t--;\nfor(int i=1;i<=n;i+=2){\n       auto it=primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       it = primes.begin();\n       int cur1 = *it;\n       primes.erase(it);\n       for(int k=0;i+k<=n;k++){\n              ans[1+k][i+k]*=cur;\n              if(i!=1){\n                     ans[i+k][1+k]*=cur1;\n              }\n       }\n}\n/*\nfor(int i=t;i>=1;i=-2){\n       auto it=primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       ans[i][n-i+1]*=cur;\n       if(ans[n][i]==1)\n       for(int k=0;i-k>0;k++){\n              ans[n-k][i-k]*=cur;\n              ans[n-k][i-k]*=cur;\n       }\n}\n*/\n\nfor(int i=1;i<=n;i++){\n       auto it = primes.begin();\n       int cur = *it;\n       primes.erase(it);\n       ans[i][i]*=cur;\n       for(int k=1;i-k>0;k++){\n              ans[i-k][i+k]*=cur;\n              ans[i+k][i-k]*=cur;\n       }\n}\n\nfor(int i=1;i<=n;i++){\n       for(int j=1;j<=n;j++){\n\n              if(ans[i][j]==1){\n                     ans[i][j] = lc(ans[i-1][j],ans[i+1][j],ans[i][j+1],ans[i][j-1]) + 1;\n              }\n\n              cout << ans[i][j] << \" \";\n       }\n       cout << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MaxN = 5e2 + 17;\nlong long arr[MaxN][MaxN];\nlong long prime[2 * MaxN];\nlong long second_matrix[MaxN][MaxN];\nint x[] = {-1, 1, 0, 0};\nint y[] = {0, 0, -1, 1};\nint n;\nmap<long long, bool> mp;\n\nlong long lcm(long long a, long long b)\n{\n    return (a * b) / __gcd(a, b);\n}\n\nvoid erich()\n{\n    const int MaxS = 1e4 + 17;\n    bool isPrime[MaxS];\n\n    for(int i = 1; i < 2 * MaxN; ++i)\n        isPrime[i] = 1;\n\n    int next = 1;\n\n    for(int i = 2; i <= MaxS; ++i)\n    {\n        if(isPrime[i])\n        {\n            prime[next++] = i;\n\n            for(int j = i + i; j <= MaxS; j += i)\n                isPrime[j] = 0;\n\n        }\n    }\n}\n\nvoid fill_sec()\n{\n    for(int i = n - !(n % 2), j = 1; i >= 1; i -= 2, ++j)\n    {\n        int x = i;\n        int y = 1;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + j];\n            ++x;\n            ++y;\n        }\n    }\n\n    for(int i = 3, j = 1; i <= n; i += 2, ++j)\n    {\n        int x = 1;\n        int y = i;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + n / 2 +  n % 2 + j];\n            ++x;\n            ++y;\n        }\n    }\n}\n\nvoid fill_matrix()\n{\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if(!((i + j) & 1))\n            {\n                arr[i][j] = prime[(i + j) / 2] * second_matrix[i][j];\n                mp[arr[i][j]] = 1;\n            }\n\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if((i + j) & 1)\n            {\n                arr[i][j] = 1;\n\n                for(int k = 0; k < 4; ++k)\n                {\n                    int xx = i + x[k];\n                    int yy = j + y[k];\n\n                    if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                        arr[i][j] = lcm(arr[i][j], arr[xx][yy]);\n                   // cout << \"KEK  \" << arr[i][j] << '\\n';\n                    if(mp[arr[i][j]])\n                    {\n                        int mul = 2;\n\n                        while(mp[arr[i][j] * mul])\n                            ++mul;\n\n                        arr[i][j] *= mul;\n                    }\n\n                    mp[arr[i][j]] = 1;\n                }\n            }\n\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n\n    erich();\n    fill_sec();\n    fill_matrix();\n\n\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n            cout << arr[i][j] << ' ';\n        cout << '\\n';\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef unsigned __int128 ll;\nusing namespace std;\nconst int MN=8000;\nint n,pri[1001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+(abs(i-j)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tprintf(\"%d \",a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nLL A[500][500];\n\nLL GCD(LL a, LL b) {\n\tif (b == 0) return a;\n\treturn GCD(b, a % b);\n}\nLL LCM(LL a, LL b) {\n\treturn a / GCD(a, b) * b;\n}\n\nconst int di[] = { 1, 0, -1, 0 };\nconst int dj[] = { 0, 1, 0, -1 };\n\nvector<int> primes;\nvector<int> primes1;\nvector<int> primes2;\n\nvoid pre() {\n\tconst int MAX = 300000;\n\t\n\tREP(i, 2, MAX) {\n\t\tbool pr = true;\n\t\tfor (int div = 2; div * div <= i; ++div) {\n\t\t\tif (i % div == 0) {\n\t\t\t\tpr = false;\n\t\t\t}\n\t\t}\n\t\tif (pr) primes.push_back(i);\n\t}\n\n\t//for (int i = 0; i < primes.size(); ++i) {\n\t//\t(i % 2 == 0 ? primes1 : primes2).push_back(primes[i]);\n\t//}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tprimes1.push_back(primes[i]);\n\t}\n\tfor (int i = N; i < 2 * N; ++i) {\n\t\tprimes2.push_back(primes[i]);\n\t}\n}\n\nvoid sub() {\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn;\n\t}\n\tpre();\n\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tA[i][j] = primes1[(N + i - j) / 2] * primes2[(i + j) / 2];\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tif (i % 2 == j % 2) continue;\n\t\t\tvector<LL> v;\n\t\t\tREP(k, 0, 4) {\n\t\t\t\tint ni = i + di[k];\n\t\t\t\tint nj = j + dj[k];\n\t\t\t\tif (Inside(ni, nj, N, N)) {\n\t\t\t\t\tv.push_back(A[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLL lcm = 1;\n\t\t\tfor (LL p : v) {\n\t\t\t\tlcm = LCM(lcm, p);\n\t\t\t}\n\t\t\tA[i][j] = lcm + 1;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tcout << A[i][j] << (j == N - 1 ? '\\n' : ' ');\n\t\t}\n\t}\n}\n\nint main() {\n\tsub();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#define maxn 510\n#define ll long long\n\nusing namespace std;\n\nint n;\nll a[maxn][maxn], primes[2020];\nbool st[1000010];\nint cnt;\n\nvoid getprimes()\n{\n\tfor (int i = 2; i <= 10000; i ++ )\n\t{\n\t\tif (!st[i]) primes[++cnt] = i;\n\t\tfor (int j = 1; primes[j] * i <= 10000; j ++ )\n\t\t{\n\t\t\tst[primes[j] * i] = 1;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n}\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\tif (!a || !b) return a + b;\n\treturn a / gcd(a, b) * b;\n}\n\nint main()\n{\n\tgetprimes();\n\tscanf(\"%d\", &n);\n\t\n\tif (n == 2)\n\t{\n\t\tputs(\"2 3\");\n\t\tputs(\"5 4\");\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = primes[(i + j) / 2] * primes[n + (i - j) / 2 + (n + 1) / 2];\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = ((i & 1) + 1); j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i][j - 1], a[i - 1][j]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t{\n\t\tfor (int j = 1; j <= n; j ++ ) cout << a[i][j] << ' ';\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nsigned main(){\n  vector<int> v;\n  int t=3;\n  while(v.size()<1000){\n    bool f=1;\n    for(int i=2;i*i<=t;i++)if(t%i==0)f=0;\n    if(f)v.push_back(t);\n    t++;\n  }\n  int d1[500][500],d2[500][500],c=0;\n  for(int i=-498;i<500;i+=2){\n    for(int j=-i;j+i<500;j++){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d1[j][j+i]=v[c];\n    }\n    c++;\n  }\n\n  for(int i=0;i<1000;i+=2){\n    for(int j=1000;i-j<500;j--){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d2[j][i-j]=v[c];\n    }\n    c++;\n  }\n  int n;\n  cin>>n;\n  \n  int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(j)cout<<\" \";\n      if((i+j)%2){\n\tint res=1;\n\tset<int> s;\n\tfor(int k=0;k<4;k++){\n\t  int nx=j+dx[k],ny=i+dy[k];\n\t  if(nx<0||ny<0||nx>=500||ny>=500)continue;\n\t  s.insert(d1[ny][nx]);\n\t  s.insert(d2[ny][nx]);\n\t}\n\tfor(auto z:s){res*=z;}\n\tcout<<res+1;\n      }\n      else cout<<d1[i][j]*d2[i][j];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint ncnt,val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {\n\t\tputs(\"4 7\"),puts(\"23 10\");\n\t\treturn 0;\n\t}\n\tinit(10000);\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)&1) {\n\t\tif(!val0[i+j]) val0[i+j]=prime[ncnt++]; \n\t\tif(!val1[i-j+n]) val1[i-j+n]=prime[ncnt++];\n\t\tan[i][j]=val0[i+j]*val1[i-j+n];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k]; if(_x<1||_x>n) continue;\n\t\t\tint _y=y+dy[k]; if(_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t\t++an[x][y];\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat;\nint n,p[10005],vis[10005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint nex(int x){\n\tif (!mat[x])mat[x]=p[p[0]--];\n\treturn mat[x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=p[0]/2;i++)swap(p[i],p[p[0]-i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=nex(i+j);\n\tmat.clear();\n\tfor(int i=n;i;i--)\n\t\tfor(int j=n;j;j--)\n\t\t\tif ((i+j)%2==0)a[i][j]*=nex(i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=lcm(a[i-1][j],lcm(a[i][j-1],lcm(a[i+1][j],a[i][j+1])))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\t\n\tscanf(\"%d\", &n);\n//\trandom_shuffle(prime, prime+n+n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0 ; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\n\tfor (int i=n-1; ~i; --i)\n\t\tfor (int j=n-1; ~j; --j) if ( (i&1)^(j&1))\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\n\t#ifdef che\n\tdebug(\"last = %d\\n\", prime[cur]);\n\t#endif\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tif ( i) s *= a[i-1][j];\n\t\tif ( i+1<n ) s*=a[i+1][j];\n\t\tif ( j) s*= b[i][j-1];\n\t\tif ( j+1<n ) s*=b[i][j+1];\n\t\t\n\t\tLL ss= \n\t\ta[i][j] = s+1;\n\t}\n\tfor (int i=0; i<n; ++i) for (int j=0; j<n; ++j) if (b[i][j])\n\t\ta[i][j] *= b[i][j];\n//\tif( n==2) a[1][1] = 2*a[1][1]-1;\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL gcd(LL a,LL b){\n\treturn b?gcd(b,a%b):a;\n}\nLL lcm(LL a,LL b){\n\tif(!a)return b;\n\tif(!b)return a;\n\tLL g=gcd(a,b);\n\treturn a/g*b;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;P.PB(0);\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=7919;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t\t//cout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(i%2!=j%2){\n\t\tg[i][j]+=lcm(lcm(g[i-1][j],g[i][j-1]),lcm(g[i+1][j],g[i][j+1]));\n\t}\n\t\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"complex\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\n\nlong long int N, M, K, H, W, L, R;\n\nlist<int> Prime(int num) {\n\tlist<int>P;\n\tfor (int i = 5; i <= num; i += 6) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t\tflag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i + 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((i + 2) % j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i + 2);\n\t}\n\tP.push_front(3);\n\tP.push_front(2);\n\treturn P;\n}\n\ninline long long int gcd(long long int a, long long int b) {\n\tif (a < b)a ^= b ^= a ^= b;\n\twhile (b) {\n\t\ta %= b;\n\t\ta ^= b ^= a ^= b;\n\t}\n\treturn a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tauto P = Prime(10000);\n\tlist<int>p;\n\tP.pop_front();\n\twhile (p.size() < N + 2) {\n\t\tp.push_back(P.front());\n\t\tP.pop_front();\n\t}\n\tvector<int>tate((N+2)/2);\n\tvector<int>yoko((N+2)/2);\n\tfor (int i = 0; i < (N + 2) / 2; i++) {\n\t\tif (i % 2) {\n\t\t\ttate[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\ttate[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tfor (int i = 0; i < N/2+1; i++) {\n\t\tif (i % 2) {\n\t\t\tyoko[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\tyoko[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tvector<vector<long long int>>v(N, vector<long long int>(N));\n\tmap<long long int, int>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i^j) & 1) {\n\t\t\t\tv[i][j] = tate[i / 2] * yoko[j / 2] * 2;\n\t\t\t\tif (m[v[i][j]])v[i][j] *= 2;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dir[] = { 0,1,0,-1,0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (!v[i][j]) {\n\t\t\t\tv[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = i + dir[k];\n\t\t\t\t\tint nx = j + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)continue;\n\t\t\t\t\tv[i][j] = v[i][j] / gcd(v[i][j], v[ny][nx])*v[ny][nx];\n\t\t\t\t}\n\t\t\t\tv[i][j]++;\n\t\t\t\tif (m[v[i][j]])v[i][j] = v[i][j] * 2 - 1;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int mx = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j)cout << \" \";\n\t\t\tcout << v[i][j];\n\t\t\tmx = max(mx, v[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nconst int maxp = 8000 + 10;\ntypedef long long ll;\n\nbool notprime[maxp];\nint prime[maxp] , prime_cnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxp;i++){\n\t\tif(!notprime[i]) prime[prime_cnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxp && j < prime_cnt;j++){\n\t\t\tll t = i * prime[j]; notprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nll gcd(ll a,ll b){ return b ? gcd(b,a % b) : a;}\nll lcm(ll a,ll b) { return a / gcd(a,b) * b;}\n\nconst int maxn = 500 + 10;\nll a[maxn][maxn];\nint cnt,n;\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&n);\n\tif(n == 2) return !printf(\"4 7\\n23 10\");\n\tfor(int i = 0;i <= n + 1;i++){\n\t\tfor(int j = 0;j <= n + 1;j++){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 ==  0){\n\t\t\t\ta[i][j] = prime[(i + j >> 1) - 1] * prime[(i - j) / 2 + n + n / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) & 1){\n\t\t\t\ta[i][j] = lcm(a[i][j - 1] , lcm(a[i][j + 1],lcm(a[i - 1][j],a[i + 1][j])));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%I64d%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    vector<vector<ll>> a(500,vector<ll>(500,0));\n    vector<int> isPrime(2000,true);\n    vector<ll> primes;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            primes.push_back(i);\n            for(int j=2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n    set<ll> vs;\n    cerr<<primes.size()<<endl;\n    \n    for(int i=0;i<500;i++){\n        for(int j=i%2;j<500;j+=2){\n            a[i][j]=primes[i/2]*primes[j/2];\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    auto isRange=[](int x,int y){\n        return 0<=x && x<500 && 0<=y && y<500;\n    };\n    auto lcm=[](ll x,ll y){\n        return x*y/__gcd(x,y);\n    };\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n\n    for(int i=0;i<500;i++){\n        for(int j=(i+1)%2;j<500;j+=2){\n            ll v=1;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dx[k],j+dy[k])){\n                    v=lcm(v,a[i+dx[k]][j+dy[k]]);\n                }\n            }\n            a[i][j]=v;\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    int n;\n    cin>>n;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j+1<n;j++){\n            if(a[i][j]>1e15){\n                cnt++;\n                a[i][j]=1;\n            }\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<a[i].back()<<endl;\n    }\n    cerr<<cnt<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=1;i<=n;i++)for(ll j=(i+1&1)+1;j<=n;j+=2)a[i][j]=p[i+j>>1]*p[n+(i-j>>1)+(n+1)>>1];\n\tfor(ll i=1;i<=n;i++)for(ll j=(i&1)+1;j<=n;j+=2)if((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,1,(N*N)/2){\n            prime.pb(aa*2);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==1){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==0){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 924844033;\nconst int N = 20335;\nconst int K = 700 ;\nint ans[K][K], f[N], p[N], pp[N];\nvector < int > pr;\nmap < int, int > used;\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 2; i < N; i++){\n        if (f[i] == 0) pr.pb(i);\n        for (int j = i; j < N; j += i) f[j] = 1;\n    }\n    int l = 2;\n    int r = n + 1;\n    for (int i = 1; i <= n; i++){\n        if (i % 2){\n            p[i] = l;\n            l++;\n        } else{\n            p[i] = r;\n            r--;\n        }\n    }\n    l = 100;\n    r = n + n + 150;;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            if ((i + j) % 2 == 1) continue;\n            int d = i - j;\n            if (pp[d + n] == 0){\n                if (abs(d) % 4 == 2){\n                    l++;\n                    pp[d + n] = pr[l];\n                } else{\n                    r--;\n                    pp[d + n] = pr[r];\n                }\n            }\n            ans[i][j] = p[j] * pp[d + n];\n        }\n    }\n    int q = 0;\n    int cnt = 0;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            if ((i + j) % 2 == 0) continue;\n            int x = 1;\n            if (ans[i - 1][j] != 0) x = ans[i - 1][j] * x / __gcd(ans[i - 1][j], x);\n            if (ans[i + 1][j] != 0) x = ans[i + 1][j] * x / __gcd(ans[i + 1][j], x);\n            if (ans[i][j - 1] != 0) x = ans[i][j - 1] * x / __gcd(ans[i][j - 1], x);\n            if (ans[i][j + 1] != 0) x = ans[i][j + 1] * x / __gcd(ans[i][j + 1], x);\n            int y = x;\n            while(used[y]){\n                y += x;\n                cnt++;\n            }\n            ans[i][j] = y + 1;\n            if (y < 0){\n                cout << y;\n                return 0;\n            }\n            used[x] = 1;\n            q = max(q, y);\n        }\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e3 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, tot, vis[1000005], pri[1000005], a[N][N];\nvoid init(int n) {\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(vis[i] == 0) pri[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= n; ++ j) {\n\t\t\tvis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nint gcd(int x, int y) {return y == 0 ? x : gcd(y, x % y);}\nint lcm(int x, int y) {return x * y / gcd(x, y);}\nsigned main() {\n\tn = read(); init(1e4);\n\tif(n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = pri[(i + j) / 2] * pri[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1]));\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i, puts(\"\")) for(int j = 1; j <= n; ++ j) printf(\"%lld \", a[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nlong long LCM(long long a , long long b){return (__int128)a * b / __gcd(a , b);}\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1)\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = LCM(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n\tcin >> N >> M;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= M ; ++j) cout << arr[i][j] << \" \\n\"[j == M];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>//\tTはintかll\nT gcd(T a, T b) {//\t最大公約数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tif (a < b) {\n\t\treturn gcd(a, b % a);\n\t}\n\treturn gcd(b, a % b);\n}\ntemplate <typename T>//\tTはintかll\nT gcd(int size, T* a) {//\t配列の最大公約数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tT c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = gcd(c, a[i]);\n\t\tif (c == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate <typename T>//\tTはintかll\nll lcm(T a, T b) {//\t最小公倍数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tll x = a;\n\tx /= gcd(a, b);\n\tx *= b;\n\treturn x;\n}\ntemplate <typename T>//\tTはintかll\nll lcm(int size, T* a) {//\t配列の最小公倍数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tll c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = lcm(c, (ll)a[i]);\n\t}\n\treturn c;\n}\n\nll l_sqrt(ll n) {\n\tif (n <= 0) { return 0; }\n\n\tif (n > 256) {\n\t\tll k = l_sqrt(n / 4) * 2;\n\t\twhile ((k + 1) * (k + 1) <= n) { k++; }\n\t\treturn k;\n\t}\n\telse {\n\t\tfor (int i = 16; i >= 1; i--) {\n\t\t\tif (i * i <= n) { return i; }\n\t\t}\n\t}\n\treturn 0;\n}\nclass primeFactorClass {// 素因数分解をする\npublic:\n\tprimeFactorClass() {\n\t\tfactorNum = 0;\n\t}\n\t~primeFactorClass() {\n\t\treset();\n\t}\n\n\tint factorNum;// 素因数の個数\n\tvector<ll> prime;// 素因数\n\tvector<int> degree;// 次数\n\n\tvoid factorize(ll n) {// 素因数分解\n\t\treset();\n\t\tif (n < 0) { n = -n; }\n\t\tif (n <= 1) { return; }\n\n\t\tif (n % 2 == 0) {\n\t\t\tfactorNum++;\n\t\t\tprime.push_back(2);\n\t\t\tint count = 0;\n\t\t\twhile (n % 2 == 0) { count++; n /= 2; }\n\t\t\tdegree.push_back(count);\n\t\t}\n\n\t\tll M = l_sqrt(n) + 1;\n\t\tfor (ll i = 3; i < M; i += 2) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tfactorNum++;\n\t\t\t\tprime.push_back(i);\n\t\t\t\tint count = 0;\n\t\t\t\twhile (n % i == 0) { count++; n /= i; }\n\t\t\t\tdegree.push_back(count);\n\t\t\t\tM = l_sqrt(n) + 1;\n\t\t\t\tif (n == 1) { break; }\n\t\t\t}\n\t\t}\n\n\t\tif (n != 1) {\n\t\t\tfactorNum++;\n\t\t\tprime.push_back(n);\n\t\t\tdegree.push_back(1);\n\t\t}\n\t}\n\nprivate:\n\tvoid reset() {\n\t\tfactorNum = 0;\n\t\tprime.clear();\n\t\tdegree.clear();\n\t}\n};\n\nvector<ll> v;\nvoid func(primeFactorClass& p, ll x, int depth) {\n\tif (depth == p.prime.size()) {\n\t\tif (x == 1) { return; }\n\t\tv.push_back(x);\n\t}\n\telse {\n\t\tfor (int i = 0; i <= p.degree[depth]; i++) {\n\t\t\tfunc(p, x, depth + 1);\n\t\t\tx *= p.prime[depth];\n\t\t}\n\t}\n}\n\nint main() {\n\tll bignum = 128LL * 243LL * 125LL * 49LL * 11LL * 13LL * 17LL * 19LL * 23LL;\n\tprimeFactorClass p; p.factorize(bignum);\n\tfunc(p, 1, 0);\n\n\tint N; cin >> N;\n\tll** ans = new ll * [N];\n\tint c = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = new ll[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) { ans[i][j] = bignum; }\n\t\t\telse {\n\t\t\t\tans[i][j] = v[c];\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\n\tset<ll> st;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tll c = 1;\n\t\t\t\tif (i > 0) { c = lcm(c, ans[i - 1][j]); }\n\t\t\t\tif (j > 0) { c = lcm(c, ans[i][j - 1]); }\n\t\t\t\tif (i < N - 1) { c = lcm(c, ans[i + 1][j]); }\n\t\t\t\tif (j < N - 1) { c = lcm(c, ans[i][j + 1]); }\n\t\t\t\tll d = c;\n\t\t\t\twhile (st.find(d) != st.end()) {\n\t\t\t\t\td += c;\n\t\t\t\t}\n\t\t\t\tst.insert(d);\n\t\t\t\tans[i][j] += d + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n \nconst int N=505;\nconst int LIM=8000;\nint fl[LIM],pri[LIM],n;\nvoid initprime(){\n\tFor(i,2,LIM-1) For(j,2,(LIM-1)/i) fl[i*j]=1;\n\tFor(i,1,LIM-1) if (!fl[i]) pri[++*pri]=i;\n}\nmap<int,int> mp1,mp2;\nmap<ll,int> mp3;\nll ans[N][N];\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid work(){\n\tint l=2;\n\tFor(i,0,n-1) if ((n+1-i)&1){\n\t\tmp1[n+1-i]=pri[l++];\n\t\tif (i) mp1[n+1+i]=pri[l++];\n\t\tif (l>235) l=2;\n\t}\n\tl=2;\n\tFor(i,1,n-1) if (i&1){\n\t\tmp2[i]=pri[l++];\n\t\tif (i) mp2[-i]=pri[l++];\n\t\tif (l>235) l=2;\n\t}\t\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tint v=mp1[i+j]*mp2[i-j]; ans[i][j]=v;\n\t\tassert(v);\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=v);\n\t\tmp3[ans[i][j]]++;\n\t}\n\tll mx=0;\n\tFor(i,1,n) For(j,1,n) if (!ans[i][j]){\n\t\tll lcm=1;\n\t\tif (i!=1) lcm*=ans[i-1][j]/gcd(ans[i-1][j],lcm);\n\t\tif (i!=n) lcm*=ans[i+1][j]/gcd(ans[i+1][j],lcm);\n\t\tif (j!=1) lcm*=ans[i][j-1]/gcd(ans[i][j-1],lcm);\n\t\tif (j!=n) lcm*=ans[i][j+1]/gcd(ans[i][j+1],lcm);\n\t\tans[i][j]=lcm+1;\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=lcm);\n\t\tmp3[ans[i][j]]=1;\n\t\tmx=max(mx,ans[i][j]);\n\t}\n\tFor(i,1,n){\n\t\tFor(j,1,n) printf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tinitprime();\n\twork();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat;\nint n,p[10005],vis[10005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x/gcd(x,y)*y;\n}\nint nex(int x){\n\tif (!mat[x])mat[x]=p[p[0]--];\n\treturn mat[x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=p[0]/2;i++)swap(p[i],p[p[0]-i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=nex(i+j);\n\tmat.clear();\n\tfor(int i=n;i;i--)\n\t\tfor(int j=n;j;j--)\n\t\t\tif ((i+j)%2==0)a[i][j]*=nex(i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v((i + j - 2) / 2)] * p[v((1500 + i - j) / 2)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v((i + j) / 2)] * p[v((1500 + i - j) / 2)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nint_fast64_t N;\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(size_t i = 0; i < N; ++i)\n        for(size_t j = 0; j < N; ++j)printf(\"%lld%c\", a.at(i, j), j == N - 1 ? '\\n' : ' ');\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long int LL;\nconst int Max_N(505);\nconst int Max_S(10000000);\nconst int dx[] = {+1, -1, +0, +0};\nconst int dy[] = {+0, +0, +1, -1};\n\nconstexpr LL gcd(LL a, LL b)\n{\n\treturn b == 0LL ? a : gcd(b, a % b);\n}\n\nconstexpr LL lcm(LL a, LL b)\n{\n\treturn b == 0LL ? a : a / gcd(a, b) * b;\n}\n\nint N, ps, P[Max_S];\nLL A[Max_N][Max_N];\nbool Prime[Max_S];\n\nint main()\n{\n\tmemset(Prime, true, sizeof(Prime)), Prime[0] = Prime[1] = false;\n\tfor (int i = 2;i < Max_S;++i)\n\t{\n\t\tif (Prime[i])\n\t\t\tP[++ps] = i;\n\t\tfor (int j = 1, x;j <= ps && (x = i * P[j]) < Max_S;++j)\n\t\t{\n\t\t\tPrime[x] = false;\n\t\t\tif (x % P[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &N);\n\tif (N == 2)\n\t{\n\t\tprintf(\"%d %d\\n\", 4, 7);\n\t\tprintf(\"%d %d\\n\", 23, 10);\n\t\treturn 0;\n\t}\n\tfor (int i = 0;i <= N + 1;++i)\n\t\tfor (int j = 0;j <= N + 1;++j)\n\t\t\tA[i][j] = 1LL;\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tA[i][j] = P[(i + j) >> 1] * 1LL * P[N + (i - j) / 2 + (N + 1) / 2];\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tfor (int k = 0, x, y;k < 4;++k)\n\t\t\t\t\tif (1 <= (x = i + dx[k]) && x <= N && 1 <= (y = j + dy[k]) && y <= N)\n\t\t\t\t\t\tA[i][j] = lcm(A[i][j], A[x][y]);\n\t\t\t\t++A[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n\n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n\n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n\nconst int N=505;\nconst int LIM=8000;\nint fl[LIM],pri[LIM],n;\nvoid initprime(){\n\tFor(i,2,LIM-1) For(j,2,(LIM-1)/i) fl[i*j]=1;\n\tFor(i,2,LIM-1) if (!fl[i]) pri[++*pri]=i;\n}\nmap<int,int> mp1,mp2;\nmap<ll,int> mp3;\nll ans[N][N];\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid work(){\n\tint l=1;\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp1[i+j]) mp1[i+j]=pri[l++]; ans[i][j]=mp1[i+j];\n\t\tmp3[ans[i][j]]=1;\n\t}\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp2[i-j]) mp2[i-j]=pri[l++]; ans[i][j]*=mp2[i-j];\n\t}\n\tll mx=0;\n\tFor(i,1,n) For(j,1,n) if (!ans[i][j]){\n\t\tll lcm=1;\n\t\tif (i!=1) lcm*=ans[i-1][j]/gcd(ans[i-1][j],lcm);\n\t\tif (i!=n) lcm*=ans[i+1][j]/gcd(ans[i+1][j],lcm);\n\t\tif (j!=1) lcm*=ans[i][j-1]/gcd(ans[i][j-1],lcm);\n\t\tif (j!=n) lcm*=ans[i][j+1]/gcd(ans[i][j+1],lcm);\n\t\tans[i][j]=lcm+1;\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=lcm);\n\t\tmp3[ans[i][j]]=1;\n\t\t//if (ans[i])\n\t\tmx=max(mx,ans[i][j]);\n\t}\n\tFor(i,1,n){\n\t\tFor(j,1,n) printf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tinitprime();\n\twork();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint N;\nint A[550][550];\ndeque<int> prime;\nunordered_map<int, int> mpA, mpB;\nunordered_map<int, bool> ex;\nsigned main() {\n    cin >> N;\n    for (int i = 2; i <= 1100; i++) {\n        prime.push_back(i);\nnene:;\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        if (i % 2 == 0) {mpA[2 * i] = prime.front(); prime.pop_front();}\n        else {mpA[2 * i] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 10; i++) {\n        if (i % 2 == 0) {mpB[2 * i - (N + 4) - N % 2] = prime.front(); prime.pop_front();}\n        else {mpB[2 * i - (N + 4) - N % 2] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n            A[i][j] = mpA[i + j] * mpB[i - j];\n            ex[A[i][j]] = true;\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if ((i + j) % 2 == 0) {cout << A[i][j] << \" \"; continue;}\n            int cur = 1;\n            for (int k = 0; k < 4; k++) {\n                cur = cur / gcd(cur, A[i + dy[k]][j + dx[k]]) * A[i + dy[k]][j + dx[k]];\n            }\n            int c = 1;\n            while (ex[cur * c + 1])c++;\n            cout << cur * c + 1 << \" \";\n            ex[cur * c + 1] = true;\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=10000;\nint prime[10010],tot;\nbool vis[10010];\nint a[510][510];\nint gcd(long long a,long long b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\nvoid init()\n{\n\tvis[1]=true;\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!vis[i])prime[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prime[j]<=N;j++)\n\t\t{\n\t\t\tvis[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\treturn ;\n}\nint main()\n{\n\tinit();\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\ta[i][j]*=prime[1+(i+j)/2];\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tif((i-j)%2==0)\n\t\t\t\ta[i][j]*=prime[2*n+10-(i-j+n+1)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==1)\n\t\t\t{\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\t\ta[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nmap<long long,int> mp;\nlong long lcm(long long x,long long y){\n\tif (!(x&&y)) return x^y;\n\treturn (__int128)x*y/__gcd(x,y);\n}\nconst int N=600;\nint z[N][N],n,a[N*N];\nint main(){\n\tscanf(\"%d\",&n);\n\tint tot=((n*n)+1)/2;\n\tfor (int i=1; i<=tot; ++i) a[i]=i*2;\n\trandom_shuffle(a+1,a+tot+1);\n\tint d=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=a[++d];\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n\t\tcerr<<\"tot\"<<tot<<endl;*/\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?2:1); j<=n; j+=2){\n\t\t\tlong long k=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\tlong long zz=k;\n\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\tz[i][j]=zz+C;\n\t\t\tmp[zz+C]=1;\n\t\t}\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 2005;\nconst int M = 1e5 + 50;\n\nint n, pri[M], isnt_pri[M], cnt;\nll a[N], b[N], c[N][N];\n\ninline ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\ninline ll lcm(ll x, ll y) { return (x && y) ? (x / gcd(x, y) * y) : (x | y); }\n\ninline void init()\n{\n\tfor (int i = 2; i < M; ++i)\n\t{\n\t\tif (!isnt_pri[i]) pri[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * pri[j] < M; ++j)\n\t\t{\n\t\t\tisnt_pri[i * pri[j]] = true;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tinit();\n\tif (n == 2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++i) a[i] = pri[i];\n\tfor (int i = 1; i <= n; ++i) b[i] = pri[2 * n - i + 1];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i ^ j) & 1) c[i][j] = a[(i + j) / 2] * b[(i - j + n + 1) / 2];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!((i ^ j) & 1)) c[i][j] = lcm(lcm(c[i - 1][j], c[i][j - 1]), lcm(c[i + 1][j], c[i][j + 1])) + 1;\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) \n\t{\n\t\tassert(c[i][j] > 0 && c[i][j] <= 1e15);\n\t\tprintf(\"%lld%c\", c[i][j], j == n ? '\\n' : ' ');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#  define _GLIBCXX_DEBUG_PEDANTIC\n#endif\n\n#include \"bits/stdc++.h\"\n#define ff first\n#define ss second\n#define szof(_x) ((int) (_x).size())\n#define TASK_NAME \"\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\nconst ll INFL = 1e18 + 123;\nconst double PI = atan2(0, -1);\nmt19937 tw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(tw) % (y - x + 1) + x; }\n\nconst ll MAXV = 1000000000000000;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid solve() {\n\tint prime_cnt = 2;\n\tmap<pii, int> primes;\n\tauto get_prime = [&](pii p) {\n\t\tif (primes.count(p)) {\n\t\t\treturn primes[p];\n\t\t}\n\t\t/*if (p.ff == 0 && p.ss % 4 == 1) {\n\t\t\treturn primes[p] = 1;\n\t\t}*/\n\t\twhile (true) {\n\t\t\tbool fl = true;\n\t\t\tfor (int j = 2; j * j <= prime_cnt; ++j) {\n\t\t\t\tif (prime_cnt % j == 0) {\n\t\t\t\t\tfl = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fl) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++prime_cnt;\n\t\t}\n\t\treturn primes[p] = prime_cnt++;\n\t};\n\tint n;\n\tcin >> n;\n\tvector<vector<ll>> ans(n, vector<ll>(n));\n\t// int cnt = 2;\n\tset<ll> have;\n\tvector<pii> order;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif ((i + j) & 1) {\n\t\t\t\torder.push_back({i, j});\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto p : order) {\n\t\tint i, j;\n\t\ttie(i, j) = p;\n\t\tans[i][j] = get_prime({0, i + j});\n\t\t// have.insert(ans[i][j]);\n\t}\n\n\tfor (auto p : order) {\n\t\tint i, j;\n\t\ttie(i, j) = p;\n\t\tans[i][j] *= get_prime({1, i - j});\n\t\thave.insert(ans[i][j]);\n\t}\t\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (!((i + j) & 1)) {\n\t\t\t\tll res = 1;\n\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\tint nx = i + dx[d];\n\t\t\t\t\tint ny = j + dy[d];\n\t\t\t\t\tif (0 <= nx && nx < n && 0 <= ny && ny < n) {\n\t\t\t\t\t\tll tmp = __gcd(res, ans[nx][ny]);\n\t\t\t\t\t\tassert((double) res * ans[nx][ny] / tmp < 1e18);\n\t\t\t\t\t\tres = res / tmp * ans[nx][ny];\n\t\t\t\t\t\tif (res > MAXV) {\n\t\t\t\t\t\t\tcerr << i << \" \" << j << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(res <= MAXV);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint mult = 1;\n\t\t\t\twhile (have.count(res * mult + 1)) {\n\t\t\t\t\t++mult;\n\t\t\t\t\tassert(res * mult + 1 <= MAXV);\n\t\t\t\t}\n\t\t\t\tans[i][j] = res * mult + 1;\n\t\t\t\thave.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// cerr << MAXV << endl;\n\tset<ll> check;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tassert(!check.count(ans[i][j]));\n\t\t\tcheck.insert(ans[i][j]);\n\t\t\tassert(1 <= ans[i][j] && ans[i][j] <= MAXV);\n\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\tint nx = i + dx[d];\n\t\t\t\tint ny = j + dy[d];\n\t\t\t\tif (0 <= nx && nx < n && 0 <= ny && ny < n) {\n\t\t\t\t\tassert(max(ans[nx][ny], ans[i][j]) % min(ans[nx][ny], ans[i][j]) == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto& v : ans) {\n\t\tfor (auto num : v) {\n\t\t\tcout << num << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}\n\n\nint main() {\n\t//freopen(TASK_NAME \".in\", \"r\", stdin);\n\t//freopen(TASK_NAME \".out\", \"w\", stdout);\n\tcerr << fixed << setprecision(15);\n\tcout << fixed << setprecision(15);\n\tios::sync_with_stdio(false);\n\n\tint tests = 1;\n\t// cin >> tests;\n\tfor (int it = 1; it <= tests; ++it) {\n\t\tsolve();\n\t}\n\t\n\t#ifdef LOCAL\n\t\tcerr << \"time: \" << clock() << \" ms\\n\";\n\t#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nll T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    n = 500;\n    vector<vector<ll>> m(n + 2, vector<ll>(n + 2, 1));\n    set<ll> used;\n    ll c = n*n;\n    for(int i=1;i<=n;i+=2) {\n        for(int j=1;j<=n;j+=2) {\n            assert(used.count(c) == 0);\n            assert(used.count(c * 2) == 0);\n            used.insert(c);\n            used.insert(c * 2);\n            m[i][j] = c;\n            m[i+1][j+1] = c*2;\n            c ++;\n        }\n    }\n\n    for(int i=1;i<=n;i+=1) {\n        for(int j=1;j<=n;j+=1) {\n            if (m[i][j] != 1) {\n                continue;\n            }\n            ll x = m[i-1][j] / __gcd(m[i-1][j], m[i+1][j]) * m[i+1][j];\n            x = x / __gcd(x, m[i][j-1]) * m[i][j-1];\n            x = x / __gcd(x, m[i][j+1]) * m[i][j+1];\n            ll y = x;\n            while (used.count(y + 1)) y += x;\n            m[i][j] = y + 1;\n            used.insert(y + 1);\n        }\n    }\n\n    cin >> n;\n    REPS(i, n) {\n        REPS(j, n) {\n            cout << m[i][j] << \" \\n\"[j == n];\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 500;\nconst int MAX2 = 10000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 2 << \" \" << 8 << endl << 4 << \" \" << 16;\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX2];\n\tfor (int i = 0;i < MAX2;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX2 - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tstatic int64_t a[MAX][MAX];\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\ta[i][j] = prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積\n\t\t\t\tif (i == 0 && j == N - 1) a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t\telse if (i == N - 1 && j == 0) a[i][j] = (int64_t)prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t\telse a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int64_t> chk;\n\tfor (int i = 0;i < N;++ i) { // 要らないけど、整合性チェック\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tint d[] = {0, 1, 0, -1, 0};\n\t\t\tint check[] = {-1, -1, -1, -1};\n\t\t\tfor (int k = 0;k < 4;++ k) {\n\t\t\t\tif (i + d[k] >= 0 && i + d[k] < N && j + d[k + 1] >= 0 && j + d[k + 1] < N) {\n\t\t\t\t\tcheck[k] = max(a[i][j], a[i + d[k]][j + d[k + 1]]) % min(a[i][j], a[i + d[k]][j + d[k + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(check, check+4);\n\t\t\tfor (int i = 0;i < 3;i ++) {\n\t\t\t\tif (check[i] >= 0 && check[i] != check[i + 1]) {\n\t\t\t\t\tcerr << \"err\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i][j] >= 1000000000000000) cerr << \"err\" << endl;\n\t\t\tchk.push_back(a[i][j]);\n\t\t}\n\t}\n\tsort(chk.begin(), chk.end());\n\tfor (int i = 1;i < chk.size();++ i) {\n\t\tif (chk[i] == chk[i - 1]) cerr << \"err\" << endl;\n\t}\n\tcerr << chk[chk.size() - 1] << endl;\n\t\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは0だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll a[505][505];\nbool chk[23333333];\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint nxtPrime(int&x){\n    auto chk=[&](int x){\n        if(x<2)return false;\n        for(int i=2;i*i<=x;i++)\n            if(x%i==0)\n                return false;\n        return true;\n    };\n    do x++;while(!chk(x));\n    ::chk[x]=true;\n    return x;\n}\nint main(){\n    int n,p=0;cin>>n;\n    for(int i=1,j=n-(~n&1);i<=n;i++,j--)\n        if(!a[i][j]&&1<=j&&j<=n)\n            a[i][j]=nxtPrime(p);\n    for(int i=n,j=n;i>=1;i--,j--)\n        if(!a[i][j])\n            a[i][j]=nxtPrime(p);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)%2==0){\n                if(a[i][j])continue;\n                auto get=[&](int dx,int dy)->ll{\n                    int x=i,y=j;\n                    while(1<=x&&x<=n&&1<=y&&y<=n){\n                        if(chk[a[x][y]])return a[x][y];\n                        x+=dx,y+=dy;\n                    }\n                    return 1;\n                };\n                a[i][j]=get(+1,+1)*get(+1,-1)*get(-1,+1)*get(-1,-1);\n            }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)%2==1){\n                auto upd=[&](int dx,int dy){\n                    if(a[i+dx][j+dy])\n                        a[i][j]=lcm(a[i][j],a[i+dx][j+dy]);\n                };\n                a[i][j]=1;\n                upd(+1,0);\n                upd(-1,0);\n                upd(0,+1);\n                upd(0,-1);\n                a[i][j]++;\n            }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cout<<a[i][j]<<\" \\n\"[j==n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 503;\nint n,pr[1500],v[10003],tot,cnt;\nll ans[N][N];\nmap<PII,ll> ch;\n\nvoid init(){\n    for(int i = 2; i <= 10000; i++){\n        if(!v[i]){\n            pr[++tot]=i;\n            v[i]=i;\n        }\n        for(int j = 1; j <= tot && i*pr[j] <= 10000; j++){\n            v[pr[j]*i]=pr[j];\n            if(v[i]==pr[j]) break;\n        }\n    }\n}\nll getval(int x,int y){\n    ll ret=1;\n    int stx[4]={1,-1,0,0},sty[4]={0,0,1,-1};\n    auto valid=[&](int x,int y){\n        return 1<=x&&x<=n&&1<=y&&y<=n;\n    };\n    for(int i = 0; i < 4; i ++){\n        int nx=x+stx[i],ny=y+sty[i];\n        if(!valid(nx,ny)) continue;\n        ret=ret/__gcd(ret,ans[nx][ny])*ans[nx][ny];\n    }\n    return ret+1;\n}\nint main(){\n    //freopen(\"my.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n    init();\n    for(int i = 2; i <= n+n; i+=2) ch[Mp(i,0)]=pr[++cnt];\n    for(int i = 0,j = 0; i < n; i+=2,j-=2) ch[Mp(i,1)]=pr[++cnt],ch[Mp(j,1)]=pr[++cnt];\n    //puts(\"1\");\n    //for(auto it:ch) printf(\"%d %d %d\\n\",it.fi.fi,it.fi.se,it.se);\n    rep(i,1,n) rep(j,1,n) if((i+j)%2==0){\n        ans[i][j]=ch[Mp(i+j,0)]*ch[Mp(i-j,1)];\n    }\n    //rep(i,1,n) rep(j,1,n) printf(\"%lld%c\",ans[i][j],j==n?'\\n':' ');\n    rep(i,1,n) rep(j,1,n) if((i+j)%2==1){\n        ans[i][j]=getval(i,j);\n    }\n    // printf(\"%d\\n\",n);\n    rep(i,1,n) rep(j,1,n) printf(\"%lld%c\",ans[i][j],j==n?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {puts(\"4 7\\n23 10\"); return 0;} \n\tinit(10000);\n\tint ncnt=0;\n\tfor(int i=1;i<=(n<<1);i+=2) if(!val0[i]) val0[i]=prime[ncnt++];\n\tfor(int i=2*n;i>=0;--i) if((i-n)&1) val1[i]=prime[ncnt++];\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)&1) {\n\t\tan[i][j]=val0[i+j]*val1[i-j+n];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k],_y=y+dy[k];\n\t\t\tif(_x<1||_x>n||_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t}\n//\tmap<ll,bool> vis;\n//\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {\n//\t\tif(an[i][j]>1e15||vis[an[i][j]]) {\n//\t\t\tdebug(\"%d %d %lld\\n\",i,j,an[i][j]);\n//\t\t\texit(-1);\n//\t\t}\n//\t\tvis[an[i][j]]=1;\n//\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll a[555][555];\nconst ll INF=ll(1e15);\nbool check(int n)\n{\n\tset<ll> GD; set<ll> N; ll mn=INF; ll mx=-INF;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tmx=max(mx,a[i][j]); mn=min(mn,a[i][j]);\n\t\t\t//if(a[i][j]<1||a[i][j]>=INF) return false;\n\t\t\tN.insert(a[i][j]);\n\t\t\tif(j+1<n) GD.insert(max(a[i][j+1],a[i][j])%min(a[i][j+1],a[i][j]));\n\t\t\tif(i+1<n) GD.insert(max(a[i+1][j],a[i][j])%min(a[i+1][j],a[i][j]));\n\t\t}\n\t}\n\tcerr<<\"MIN MAX \"<<mn<<' '<<mx<<'\\n';\n\treturn (mn>=1&&mx<=INF)&&(int(N.size())==n*n)&&(int(GD.size())==1);\n}\n\nvoid outtest(int n)\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tcerr<<a[i][j];\n\t\t\tif(j+1<n) cerr<<' ';\n\t\t}\n\t\tcerr<<'\\n';\n\t}\n}\n\nvoid out(int n)\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tcout<<a[i][j];\n\t\t\tif(j+1<n) cout<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t}\n}\n\nll lcm(ll a, ll b)\n{\n\tll g=__gcd(a,b);\n\tll ans = a/g;\n\tif(ans>=ll(1e18)/b) return INF+1;\n\telse return ans*b; \n}\n\nconst int N = 500;\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\nvector<ll> primes;\nvector<bool> prime;\nvoid Sieve(ll n)\n{\n\tprime.assign(n+1, 1);\n\tprime[1] = false;\n\tfor(ll i = 2; i <= n; i++)\n\t{\n\t\tif(prime[i])\n\t\t{\n\t\t\tprimes.pb(i);\n\t\t\tfor(ll j = i*2; j <= n; j += i)\n\t\t\t{\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\nbool isvalid(int x, int y, int n)\n{\n\treturn (x>=0&&x<n&&y>=0&&y<n);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tSieve(1000000);\n\tint n; cin>>n;\n\tset<ll> S; int ct[2]={0,0};\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tct[i&1]++;\n\t\t\t}\n\t\t}\n\t}\n\t//primes.resize(ct);\n\t//random_shuffle(C.begin(),C.end());\n\tvi L,M,R;\n\tint cr=0;\n\t/*\n\tfor(int i=0;i<(n+1)/2;i++)\n\t{\n\t\tL.pb(primes[cr++]);\n\t}\n\tfor(int i=0;i<(n+1)/2;i++)\n\t{\n\t\tM.pb(primes[cr++]);\n\t}\n\tfor(int i=0;i<(n+1)/2;i++)\n\t{\n\t\tR.pb(primes[cr++]);\n\t}\n\t*/\n\tcr++;\n\tfor(int j=0;j<(n+1)/2;j++) R.pb(primes[cr++]);\n\tfor(int i=0;i<(n+1)/2;i++) L.pb(primes[cr++]);\n\t//cerr<<L.back()<<' '<<R.back()<<'\\n';\n\t//cerr<<\"R : \"<<R.back()<<'\\n';\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tif(i&1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j] = R[i/2]*L[j/2];//L[((j/2)&1)?j/4:int(L.size())-1-j/4];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[i][j] = R[i/2]*L[j/2]*2;//R[i/2]*M[((j/2)&1)?j/4:int(M.size())-1-j/4];\n\t\t\t\t}\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)%2==0)\n\t\t\t{\n\t\t\t\tll cur = 1;\n\t\t\t\tfor(int dir=0;dir<4;dir++)\n\t\t\t\t{\n\t\t\t\t\tint x = i+dx[dir]; int y=j+dy[dir];\n\t\t\t\t\tif(isvalid(x,y,n)) cur=lcm(cur,a[x][y]);\n\t\t\t\t}\n\t\t\t\tfor(ll q=1;;q++)\n\t\t\t\t{\n\t\t\t\t\tll val = q*cur+1; \n\t\t\t\t\tif(S.find(val)!=S.end()) continue;\n\t\t\t\t\ta[i][j]=val; break;\n\t\t\t\t}\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t//outtest(n);\n\t//assert(check(n));\n\tout(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nlong long gcd(long long a, long long b) {\n  return (b ? gcd(b, a % b) : a);\n}\n\nlong long lcm(long long a, long long b) {\n  return a / gcd(a, b) * b;\n}\n\nconst int maxn = 505;\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  return true;\n}\n\nconst long long maxx = (long long) 1e15 + 1;\nconst int gox[] = {1, 0, -1, 0};\nconst int goy[] = {0, 1, 0, -1};\nlong long a[maxn][maxn];\n\nconst int K = 505;\n\nvoid solve() {\n  set<long long> used;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (!((i + j) & 1)) {\n        a[i][j] = (K + i) * ((j + 2) / 2);\n        used.insert(a[i][j]);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (!((i + j) & 1)) {\n        continue;\n      }\n      long long x = 1;\n      for (int dir = 0; dir < 4; dir++) {\n        int ni = i + gox[dir], nj = j + goy[dir];\n        if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n          continue;\n        }\n        x = lcm(x, a[ni][nj]);\n      }\n      long long y = x;\n      while (used.count(x + 1)) {\n        x += y;\n      }\n      x++;\n      assert(x < maxx);\n      a[i][j] = x;\n      used.insert(x);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%lld \", a[i][j]);\n    }\n    printf(\"\\n\");\n  } \n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst int MAX = 10000000;\nint min_factor[MAX+1];\nvector<int>prime;\nvoid make_prime() {\n    for (int i=2; i<=MAX; i+=2) min_factor[i] = 2;\n    for (int i=3; i<=MAX; i+=3) if (!min_factor[i]) min_factor[i] = 3;\n    for (int i=5, d=2; i*i<=MAX; ) {\n\tif (!min_factor[i]) {\n\t    min_factor[i] = i;\n\t    for (int j=i*i; j<=MAX; j+=i)\n\t\tif (!min_factor[j]) min_factor[j] = i;\n\t}\n\ti += d; d = 6 - d;\n    }\n    for (int i=2; i<=MAX; i++) {\n\tif (min_factor[i]==0) min_factor[i] = i;\n\tif (min_factor[i]==i) prime.push_back(i);\n    }\n}\ntypedef unsigned long long ULL;\n\nint N;\nconst int SIZE = 500;\nULL A[511][511];\n\nvoid MAIN() {\n    make_prime();\n\n    scanf(\"%d\", &N);\n\n    REP (i, SIZE) REP (j, SIZE) if ((i+j)%2 == 0) {\n\tA[i][j] = (LL)prime[(i+j)%SIZE] * prime[(i-j+SIZE)%SIZE+SIZE];\n    }\n    REP (i, SIZE) REP (j, SIZE) if ((i+j)%2 == 1) {\n\tA[i][j] = A[i][(j-1+SIZE)%SIZE] * A[i][(j+1)%SIZE] + 1;\n    }\n\n    REP (i, N) rprintf(\"%llu\", A[i], A[i]+N);\n\n}\n\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\n//~ #warning bigger nax\nconst int nax = 1e6 + 5;\nbool is_prime[nax];\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nint main() {\n\tfor(int i = 2; i < nax; ++i) {\n\t\tis_prime[i] = true;\n\t}\n\tfor(int i = 2; i < nax; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tfor(int j = 2 * i; j < nax; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> primes;\n\tfor(int i = 2; i < nax; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<ll>> grid(n, vector<ll>(n));\n\tint nxt = 5;\n\tvector<int> odd;\n\tfor(int i = 5; i <= 62751 + 20; i += 2) {\n\t\todd.push_back(i);\n\t}\n\t//~ random_shuffle(odd.begin(), odd.end());\n\tint z = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif((i + j) % 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst int M = 4;\n\t\t\tif(i % M == 0 || j == 0) {\n\t\t\t\tassert(!odd.empty());\n\t\t\t\tif(i % (2 * M) == 0) {\n\t\t\t\t\tgrid[i][j] = odd.back();\n\t\t\t\t\todd.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = odd[z++];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\tgrid[i][j] = nxt; //primes[nxt++];\n\t\t\t\tnxt += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[i][j] = grid[i-1][j-1] * 2;\n\t\t\t\t//~ int dist = min(j, i - i / M * M);\n\t\t\t\t//~ grid[i][j] = grid[i-dist][j-dist] * (dist + 1);\n\t\t\t}\n\t\t}\n\t}\n\tauto inside = [&] (int a, int b) {\n\t\treturn 0 <= a && 0 <= b && a < n && b < n;\n\t};\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(grid[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgrid[i][j] = 1;\n\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\t\tint i2 = i + dx[dir];\n\t\t\t\tint j2 = j + dy[dir];\n\t\t\t\tif(inside(i2, j2)) {\n\t\t\t\t\tgrid[i][j] = grid[i][j] / __gcd(grid[i][j], grid[i2][j2]) * grid[i2][j2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0)for(int rep = 0; rep < 4; ++rep) {\n\t\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint i2 = i + dx[dir];\n\t\t\t\t\tint j2 = j + dy[dir];\n\t\t\t\t\tif(inside(i2, j2) && grid[i][j] == grid[i2][j2]) {\n\t\t\t\t\t\tgrid[i][j] *= 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset<ll> secik;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\tassert(!secik.count(grid[i][j]));\n\t\t\t\tsecik.insert(grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\twhile((i + j) % 2 == 1 && secik.count(grid[i][j] + 1)) {\n\t\t\t\tgrid[i][j] *= 2;\n\t\t\t}\n\t\t\tprintf(\"%lld \", grid[i][j] + 1);\n\t\t\t//~ fflush(stdout);\n\t\t\tif((i + j) % 2 == 1) {\n\t\t\t\tassert(!secik.count(grid[i][j] + 1));\n\t\t\t\tsecik.insert(grid[i][j] + 1);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t\t//~ debug() << grid[i];\n\t}\n\tassert((int) secik.size() == n * n);\n\tll big = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tbig = max(big, grid[i][j]);\n\t\t}\n\t}\n\tcerr << \"big = \" << big << endl;\n\tdebug() << imie(big) imie(big / (ll) 1e12) imie(nxt) imie(primes.size());\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(j != n - 1) {\n\t\t\t\tassert(max(grid[i][j], grid[i][j+1]) % min(grid[i][j], grid[i][j+1]) == 0);\n\t\t\t}\n\t\t\tif(i != n - 1) {\n\t\t\t\tassert(max(grid[i][j], grid[i+1][j]) % min(grid[i][j], grid[i+1][j]) == 0);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n    int f=1,sum=0;\n    char x=getchar();\n    for(;(x<'0'||x>'9');x=getchar()) if(x=='-') f=-1;\n    for(;x>='0'&&x<='9';x=getchar()) sum=sum*10+x-'0';\n    return f*sum;\n}\n\n#define M 505\n#define N 8000\nint n;\nll a[M][M];\nint prime[N+5];\nbool notprime[N+5];\n\nvoid get_prime() {\n    for1(2,N,i) {\n        if(!notprime[i]) prime[++prime[0]]=i;\n        for1(1,prime[0],j) {\n            if(i*prime[j]>N) break;\n            notprime[i*prime[j]]=1;\n            if(!(i%prime[j])) break;\n        }\n    }\n}\n\ninline ll gcd(ll x,ll y) {return y?gcd(y,x%y):x;}\ninline ll Lcm(ll x,ll y) {return x/gcd(x,y)*y;}\n\nint main () {\n    //freopen(\"a.in\",\"r\",stdin);\n    n=read();\n    if(n==2) {\n        puts(\"4 7\");\n        puts(\"23 10\");\n        return 0;\n    }\n    get_prime();\n    for1(0,n+1,i) for1(0,n+1,j) a[i][j]=1;\n    for1(1,n,i) for1(1,n,j) if(!(i+j&1)) a[i][j]=prime[(i+j)/2]*prime[1000-(i-j)/2-(n+1)/2+1];\n    for1(1,n,i) for1(1,n,j) if(i+j&1) a[i][j]=Lcm(Lcm(a[i-1][j],a[i][j-1]),Lcm(a[i][j+1],a[i+1][j]));\n    for1(1,n,i) {\n        for1(1,n,j) printf(\"%lld \",a[i][j]);\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nll a[MAXN][MAXN],prime[MAXN];\nbool check(int x)\n{\n\tfor (int i=2;1ll*i*i<=x;i++)\n\t\tif (x%i==0) return 0;\n\treturn 1;\n}\nll gcd(ll x,ll y) { return y==0?x:gcd(y,x%y); }\nint main()\n{\n\tint n=read(),num=0;\n\tif (n==2) { printf(\"4 7\\n23 10\\n\"); return 0; }\n\tfor (int i=2;i<=100000;i++)\n\t\tif (check(i))\n\t\t{\n\t\t\tprime[++num]=i;\n\t\t\tif (num==n<<1) break;\n\t\t}\n\tfor (int i=0;i<=n+1;i++)\n\t\tfor (int j=0;j<=n+1;j++) a[i][j]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i&1)^(j&1)) continue;\n\t\t\ta[i][j]=prime[(i+j)>>1]*prime[n+((i-j+n+1)>>1)];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i&1)^(j&1)) a[i][j]=max(a[i-1][j]*a[i+1][j],a[i][j-1]*a[i][j+1])+1;\n\ta[1][1]=a[2][1]*a[1][2]/gcd(a[2][1],a[1][2])+1;\n\ta[n][1]=a[n-1][1]*a[n][2]/gcd(a[n-1][1],a[n][2])+1;\n\ta[1][n]=a[2][n]*a[1][n-1]/gcd(a[2][n],a[1][n-1])+1;\n\ta[n][n]=a[n-1][n]*a[n][n-1]/gcd(a[n-1][n],a[n][n-1])+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n3\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=505;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll g[maxn][maxn];\n\nvector<int> a,b;\n\nll lcm(ll a,ll b){\n\tif(a==0||b==0) return a+b;\n\treturn a*b/__gcd(a,b);\n}\nbool isp[300000]={0};\nvector<int> p;\n\nint main()\n{\n\tIOS;\n\n\n\tfor(int i=2;i<300000;i++){\n\t\tif(!isp[i]) p.pb(i);\n\t\tfor(int j=0;i*p[j]<300000;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tREP(i,500) a.pb(p[i]);\n\tREP(i,500) b.pb(p[i+500]);\n\n\tREP(i,500) REP(j,500) if((i+j)%2==0){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j)/2];\n\t\tg[i][j]*=b[(i-j+499)/2];\n\t}\n\n\tREP(i,500) REP(j,500) if((i+j)%2){\n\t\tg[i][j]=0;\n\n\t\tif(i+1<500) g[i][j]=lcm(g[i][j],g[i+1][j]);\n\t\tif(j+1<500) g[i][j]=lcm(g[i][j],g[i][j+1]);\n\t\tif(i) g[i][j]=lcm(g[i][j],g[i-1][j]);\n\t\tif(j) g[i][j]=lcm(g[i][j],g[i][j-1]);\n\t\tg[i][j]++;\n\t\t//assert(g[i][j]<1e15);\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<g[i][j]<<\" \\n\"[j==n-1];\n\n\tREP(i,n) REP(j,n-1) assert(max(g[i][j],g[i][j+1])%min(g[i][j],g[i][j+1])==1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    set<int> used;\n    ll cur = 2;\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            a[i][j] = cur++;\n            used.insert(a[i][j]);\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            ll val = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    val = LCM(val, a[ni][nj]);\n                }\n            }\n            a[i][j] = val + 1;\n            while(used.count(a[i][j])) a[i][j] += val;\n            used.insert(a[i][j]);\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 500 + 20 , M = 3e4 + 20 ;\nint n , a[N][N] ;\nbool np[M] ;\nvector <int> vec ;\n\ninline void add (int &a , int b) {\n\ta = a / __gcd(a , b) * b ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\" ;\n\t\treturn 0 ;\n\t}\n\n\tnp[0] = np[1] = 1 ;\n\tfor (int i = 2 ; i < M ; i ++) {\n\t\tif (_sz(vec) == 2 * N) break ;\n\t\tif (np[i]) continue ;\n\n\t\tvec.push_back(i) ;\n\n\t\tfor (int j = 2 * i ; j < M ; j += i) np[j] = 1 ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 0) \n\t\t\t\ta[i][j] = vec[(i + j) >> 1] * vec[((i - j + n) >> 1) + n] ;\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 1) {\n\t\t\t\ta[i][j] = 1 ;\n\t\t\t\tif (i > 0) add(a[i][j] , a[i - 1][j]) ;\n\t\t\t\tif (i < n - 1) add(a[i][j] , a[i + 1][j]) ;\n\t\t\t\tif (j > 0) add(a[i][j] , a[i][j - 1]) ;\n\t\t\t\tif (j < n - 1) add(a[i][j] , a[i][j + 1]) ;\n\t\t\t}\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int j = 0 ; j < n ; j ++) cout << a[i][j] << ' ' ;\n\t\tcout << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n\n#define int long long \n\nconst int LIM = 2e6 + 7;\nconst int N = 500;\n\nint pr[LIM];\nvector<int> primes;\n\nint lcm(int a, int b) {\n    #ifdef LOCAL\n    return a / (gcd(a, b)) * b;\n    #else\n    return a / (__gcd(a, b)) * b;\n    #endif\n}\n\nvoid init() {\n    fill(pr, pr + LIM, 1);\n    for (int i = 2; i < LIM; i++) {\n        if (pr[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < LIM; j += i) {\n                pr[j] = 0;\n            }\n        }\n    }\n}\n\nint ans[N][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ans[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) & 1) {\n                ans[i][j] *= primes[i + j];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i - j) % 2 != 0) {\n                ans[i][j] *= primes[(i - j) + N];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                assert(ans[i][j] == 1);\n                if (i > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n                }\n                if (j > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n                }\n                if (i + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n                }\n                if (j + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n                }\n                // cerr << ans[i][j] << '\\n';\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 8e3+10;\nint p[SIZE];\nvector<int>pp;\nvoid prime_init(){\n    for(int i=2;i<SIZE;i++){\n        if(!p[i]){\n            pp.PB(i);\n            for(int j=i;j<SIZE;j+=i){\n                if(!p[j])p[j]=i;\n            }\n        }\n    }\n}\nbool is_prime(int x){\n    return p[x]==x;\n}\nLL an[500][500];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nLL lcm(LL x,LL y){return x/__gcd(x,y)*y;}\nset<LL>AA;\nint main(){\n    prime_init();\n    int N;\n    R(N);\n    REP(i,N)REP(j,N)an[i][j]=1;\n    int ll=0,rr=1000;\n    int now=0;\n    for(int i=0;i<N;i+=2){\n        if(!now){\n            for(int j=0;j<=i;j++){\n                if(i-j<N)an[i][j]*=pp[ll];\n            }\n            ll++;\n        }\n        else{\n            for(int j=0;j<=i;j++){\n                if(i-j<N)an[i][j]*=pp[rr];\n            }\n            rr--;\n        }\n        now^=1;\n    }\n    for(int i=-((N-1)&(~1));i<N;i+=2){\n        if(!now){\n            REP(j,N){\n                if(i+j>=0&&i+j<N){\n                    an[i+j][j]*=pp[ll];\n                }\n            }\n            ll++;\n        }\n        else{\n            REP(j,N){\n                if(i+j>=0&&i+j<N){\n                    an[i+j][j]*=pp[rr];\n                }\n            }\n            rr--;\n        }\n        now^=1;\n    }\n    //REP(i,N)W(VL(an[i],an[i]+N));\n    LL ma=0;\n    REP(i,N)REP(j,N){\n        if(an[i][j]!=1)continue;\n        LL v=0;\n        REP(k,4){\n            int x=i+dx[k];\n            int y=j+dy[k];\n            if(x>=0&&y>=0&&x<N&&y<N){\n                if(!v)v=an[x][y];\n                else v=lcm(an[x][y],v);\n            }\n        }\n        int tt=1;\n        while(AA.count(v*tt+1))tt++;\n        an[i][j]=v*tt+1;\n        ma=max(ma,an[i][j]);\n        AA.insert(v*tt+1);\n    }\n    REP(i,N)W(VL(an[i],an[i]+N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000000LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool prime[1000005];\nll ans[501][501];\n\nll gcd(ll a,ll b){\n\tif(b==0LL)return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\tll g=gcd(a,b);\n\ta/=g;\n\treturn a*b;\n}\n\nvoid solve(int n){\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\tvector<ll> vec;\n\tmemset(prime,true,sizeof(prime));\n\tfor(ll i=2;i<1000005;i++){\n\t\tif(prime[i]){\n\t\t\tif(i!=2)vec.push_back(i);\n\t\t\tif(vec.size()>=n*2)break;\n\t\t\tfor(ll j=2LL*i;j<1000005;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tdeque<ll> x,y;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(i%4==0){\n\t\t\tx.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==1){\n\t\t\ty.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==2){\n\t\t\tx.push_back(vec[i]);\n\t\t}\n\t\tif(i%4==3){\n\t\t\ty.push_back(vec[i]);\n\t\t}\n\t}\n\tset<ll> s;\n\t//printf(\"%d %d\\n\",(int)x.size(),(int)y.size());\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==0){\n\t\t\t\tint diff=(i-j)/2;\n\t\t\t\t//printf(\"%d %d\\n\",(i+j)/2,diff+n/2);\n\t\t\t\tans[i][j]=x[(i+j)/2];\n\t\t\t\tans[i][j]*=y[diff+n/2];\n\t\t\t\tassert(s.find(ans[i][j])==s.end());\n\t\t\t\ts.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tans[i][j]=1;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\t\tans[i][j]=lcm(ans[i][j],ans[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\tassert(s.find(ans[i][j])==s.end());\n\t\t\t\ts.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint nx=j+dx[k];\n\t\t\t\tint ny=i+dy[k];\n\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\tassert(max(ans[i][j],ans[ny][nx])%min(ans[i][j],ans[ny][nx])==1LL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%lld%c\",ans[i][j],j+1==n?'\\n':' ');\n\t\t}\n\t}\n\treturn;\n} \n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tsolve(n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\trandom_shuffle(vec1.begin(), vec1.end());\n\trandom_shuffle(vec2.begin(), vec2.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool prime[1000005];\nll ans[501][501];\n\nll gcd(ll a,ll b){\n\tif(b==0LL)return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\tll g=gcd(a,b);\n\ta/=g;\n\treturn a*b;\n}\n\nvoid solve(int n){\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\tvector<ll> vec;\n\tmemset(prime,true,sizeof(prime));\n\tfor(ll i=2;i<1000005;i++){\n\t\tif(prime[i]){\n\t\t\tvec.push_back(i);\n\t\t\tif(vec.size()>=n*2)break;\n\t\t\tfor(ll j=2LL*i;j<1000005;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tdeque<ll> x,y;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(i%4==0){\n\t\t\tx.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==1){\n\t\t\ty.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==2){\n\t\t\tx.push_back(vec[i]);\n\t\t}\n\t\tif(i%4==3){\n\t\t\ty.push_back(vec[i]);\n\t\t}\n\t}\n\t//printf(\"%d %d\\n\",(int)x.size(),(int)y.size());\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==0){\n\t\t\t\tint diff=(i-j)/2;\n\t\t\t\t//printf(\"%d %d\\n\",(i+j)/2,diff+n/2);\n\t\t\t\tans[i][j]=x[(i+j)/2];\n\t\t\t\tans[i][j]*=y[diff+n/2];\n\t\t\t}\n\t\t}\n\t}\n\tset<ll> s;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tans[i][j]=1;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\t\tans[i][j]=lcm(ans[i][j],ans[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\ts.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tprintf(\"%lld%c\",ans[i][j],j+1==n?'\\n':' ');\n\t\t}\n\t}\n\treturn;\n} \n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tsolve(n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong gcd(long a, long b) {\n\tfor (; b; swap(a, b))\n\t\ta %= b;\n\treturn a;\n}\nlong lcm(long a, long b) {\n\ta /= gcd(a, b);\n\tif (double(a)*b > 1e15)\n\t\tthrow 0;\n\treturn a * b;\n}\nlong lcm(long a, long b, long c, long d) {\n\treturn lcm(lcm(a, b), lcm(c, d));\n}\nlong a[555][555];\nint main() {\n\tint N;\n\tcin >> N;\n\tint n = 500;\n\tlong x = 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2) continue;\n\t\t\tif (i % 4) {\n\t\t\t\ta[i][j] = a[i - 1][j + 1 - i % 2 * 2] * 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j] = x;\n\t\t\tx += 2;\n\t\t}\n\t}\n\tint s[] = { 0,1,0,-1,0 };\n\tset<long> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) continue;\n\t\t\tlong y[] = { 1,1,1,1 };\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\tif (i + s[k] >= 0 && i + s[k] < n&&j + s[k + 1] >= 0 && j + s[k + 1] < n)\n\t\t\t\t\ty[k] = a[i + s[k]][j + s[k + 1]];\n\t\t\tlong l = lcm(y[0], y[1], y[2], y[3]);\n\t\t\tlong m = 1;\n\t\t\twhile (q.find(m*l + 1) != q.end())\n\t\t\t\tm++;\n\t\t\tq.insert(m*l + 1);\n\t\t\ta[i][j] = m * l + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nbool notp[MAXN*MAXN];\nint prm[MAXN*MAXN],pn;\nvoid euler(int n)\n{\n\tnotp[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(!notp[i])prm[++pn]=i;\n\t\tfor(int j=1;j<=pn && i*prm[j]<=n;++j)\n\t\t{\n\t\t\tnotp[i*prm[j]]=1;\n\t\t\tif(!(i%prm[j]))break;\n\t\t}\n\t}\n}\nll a[MAXN][MAXN];\ninline ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nunordered_set<ll> s;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\teuler(n*500);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!((i+j)&1))\n\t\t\t\ta[i][j]=prm[(i+j)/2]*prm[(i-j+n+1)/2+n];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))continue;\n\t\t\ta[i][j]=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\ta[i][j]=lcm(a[i][j],a[x][y]);\n\t\t\t}\n\t\t\tll x=a[i][j];\n\t\t\t++a[i][j];\n\t\t\twhile(s.count(a[i][j]))a[i][j]+=x;\n\t\t\ts.insert(a[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%d \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint prime[maxn],ptot,mark[maxn];\n\ninline void prepare()\n{\n\tREP(i,2,1e5)\n\t{\n\t\tif(!mark[i])prime[++ptot]=i;\n\t\tfor(int j=1,k;j<=ptot && i*prime[j]<=1e5;j++)\n\t\t{\n\t\t\tk=i*prime[j]; mark[k]=1;\n\t\t\tif(!(i%prime[j]))break;\n\t\t}\n\t}\n}\n\nint n;\nll a[520][520];\nint mpa[maxn],mpb[maxn];\n\ninline void init()\n{\n\tint now=0;\n\tn=read();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");exit(0);\n\t}\n\tREP(i,1,n)REP(j,1,n)if(i+j&1)\n\t{\n\t\tif(!mpa[i+j])\n\t\t\tmpa[i+j]=prime[++now];\n\t\tif(!mpb[i-j+n])\n\t\t\tmpb[i-j+n]=prime[++now];\n\t\ta[i][j]=1ll*mpa[i+j]*mpb[i-j+n];\n\t}\n\tREP(i,0,1e4)chkmax(mpa[i],1),chkmax(mpb[i],1);\n\tREP(i,1,n)REP(j,1,n)if(~i+j&1)\n\t{\n\t\ta[i][j]=1ll*mpa[i+j-1]*mpa[i+j+1]*mpb[i-j-1+n]*mpb[i-j+1+n]+1;\n\t}\n\tREP(i,1,n)REP(j,1,n)printf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n}\n\ninline void doing()\n{\n\t\n}\n\nint main()\n{\n\tprepare();\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x << \" = \" << x << endl\n#define fori(i, ini, lim) for(int i = int(ini); i < int(lim); i++)\n#define ford(i, ini, lim) for(int i = int(ini); i >= int(lim); i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\n\nconst int MAX = 1000 + 5;\nll mat[MAX][MAX];\nvector<int> primes;\nint n;\n\nvoid sieve() {\n    for(int i = 2; (int) primes.size() < MAX; i++) {\n        bool is_prime = true;\n        fori(j, 2, i) {\n            if(i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime) {\n            primes.push_back(i);\n        }\n    }\n}\n\nll gcd(ll a, ll b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n    return (a * (b / (gcd(a, b))));\n}\n\nbool construct() {\n    random_shuffle(primes.begin(), primes.end()); \n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            mat[i][j] = 1;\n        }\n    }\n    int k = 0;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == 1) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj <= n; ni++, nj++) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == n) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj >= 1; ni++, nj--) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    const vector<ii> dir {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i + j) % 2 == 0) {\n                ll l = 1;\n                for(auto &each : dir) {\n                    int ni = i + each.first;\n                    int nj = j + each.second;\n                    if(ni >= 1 && ni <= n && nj >= 1 && nj <= n) {\n                        l = lcm(l, mat[ni][nj]);\n                    }\n                }\n                mat[i][j] = l + 1;\n            }\n        }\n    }\n    set<ll> all;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            all.insert(mat[i][j]);\n            assert(mat[i][j] > 0);\n        }\n    }\n    return (int) all.size() == n * n;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    srand(time(nullptr));\n    cin >> n;\n    if(n == 2) {\n        cout << \"4 7\" << '\\n';\n        cout << \"23 10\" << '\\n';\n        return 0;\n    }\n    sieve();\n    while(!construct());\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if(j > 1) {\n                cout << \" \";\n            }\n            cout << mat[i][j];\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\n#include <cassert>\n#pragma warning (disable: 4996)\nusing namespace std;\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    if (n < 0)return 0;\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvector<int> tpsort(vector<vector<int>>& G) {\n    int V = G.size();\n    vector<int> sorted_vertices;\n    queue<int> que;\n    vector<int> indegree(V);\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < G[i].size(); j++) {\n            indegree[G[i][j]]++;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n    while (que.empty() == false) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        sorted_vertices.push_back(v);\n    }\n    return sorted_vertices;\n}\n\nstruct Point\n{\n    double x;\n    double y;\n};\n\nstruct LineSegment\n{\n    Point start;\n    Point end;\n};\n\ndouble tenkyori(const LineSegment& line, const Point& point)\n{\n    double x0 = point.x, y0 = point.y;\n    double x1 = line.start.x, y1 = line.start.y;\n    double x2 = line.end.x, y2 = line.end.y;\n\n    double a = x2 - x1;\n    double b = y2 - y1;\n    double a2 = a * a;\n    double b2 = b * b;\n    double r2 = a2 + b2;\n    double tt = -(a * (x1 - x0) + b * (y1 - y0));\n\n    if (tt < 0)\n        return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n    else if (tt > r2)\n        return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));\n\n    double f1 = a * (y1 - y0) - b * (x1 - x0);\n    return sqrt((f1 * f1) / r2);\n}\nvoid dfs1(vector<vector<ll>>& z, ll k, ll oya, ll& ans, vector<ll>& b) {\n    for (auto m : z[k]) {\n        if (m != oya)dfs1(z, m, k, ans, b);\n    }\n    vector<ll> s;\n    for (auto m : z[k]) {\n        if (m != oya)s.push_back(b[m]);\n    }\n    ll m = b.size() - 1;\n    for (auto d : s) {\n        m -= d;\n    }\n    b[k] = b.size() - m;\n    if (m != 0)s.push_back(m);\n    ll a = modinv(2, 1000000007);\n    for (auto d : s) {\n        a += 1000000007 - modinv(modpow(2, b.size() - d, 1000000007), 1000000007);\n    }\n    a += modinv(modpow(2, b.size(), 1000000007), 1000000007) * (z[k].size() - 1);\n    ans += a;\n    ans %= 1000000007;\n    return;\n}\n\nll merge_cnt(vector<int>& a) {\n    int n = a.size();\n    if (n <= 1) { return 0; }\n\n    ll cnt = 0;\n    vector<int> b(a.begin(), a.begin() + n / 2);\n    vector<int> c(a.begin() + n / 2, a.end());\n\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    vector<vector<ll>> z(500,vector<ll>(500));\n    vector<ll> x(500,1);\n    for (int i = 0; i < 500; i++) {\n        ll k = i;\n        x[i] *= modpow(2, k % 7, 1000000007);\n        k /= 7;\n        x[i] *= modpow(3, k % 3, 1000000007);\n        k /= 3;\n        x[i] *= modpow(5, k % 3, 1000000007);\n        k /= 3;\n        x[i] *= modpow(7, k % 2, 1000000007);\n        k /= 2;\n        x[i] *= modpow(11, k % 2, 1000000007);\n        k /= 2;\n        x[i] *= modpow(13, k % 2, 1000000007);\n        k /= 2;\n    }\n    vector<ll> t(250);\n    ll c = 0;\n    for (int i = 160; i < 1000000; i++) {\n        if (i % 2 != 0 && i % 3 != 0 && i % 5 != 0 && i % 7 != 0 && i % 11 != 0 && i % 13 != 0) {\n            t[c] = i;\n            c++;\n        }\n        if (c == 250) {break; }\n    }\n    t[249] = 151;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 1) {\n                if(i<j)z[i][j] = x[(i + j) / 2];\n                else z[i][j] = x[((i + j) / 2+250)%500];\n                z[i][j] *= t[(i - j + 500) / 2 % 250];\n            }\n        }\n    }\n    ll u = 0;\n    set<ll> s;\n    ll us = 0;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 0) {\n                ll a = 1;\n                ll b = 1;\n                ll c = 1;\n                ll d = 1;\n                if (i != 0)a = z[i - 1][j];\n                if (j != 0)b = z[i][j - 1];\n                if (i != 499)c = z[i + 1][j];\n                if (j != 499)d = z[i][j + 1];\n                ll p = a / ll_gcd(a, b) * b;\n                p *= c / ll_gcd(p, c);\n                p *= d / ll_gcd(p, d);\n                z[i][j] = p + 1;\n                while (s.count(z[i][j])) {\n                    z[i][j] += p;\n                }\n                s.insert(z[i][j]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << z[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define I64d_OJ\n\n//#ifdef I64d_OJ\n//#define LL __int64\n//#endif // I64d_OJ\n#ifdef I64d_OJ\n#define LL long long\n#endif // I64d_OJ\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vi;\n\ninline LL read(){\n    LL x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define ls rt<<1\n#define rs rt<<1|1\n#define MID(a,b) (((LL)(a)+(LL)(b))>>1)\n#define absx(a) ((a)<0?-(a):(a))\n#define MK(a,b) make_pair(a,b)\n#define PB(a) push_back(a)\n#define lowbit(x) ((x)&-(x))\n\ntemplate< typename T >\ninline void Max(T &a,T &b){if(a<b) a=b;}\ntemplate< typename T>\ninline void Min(T &a,T &b){if(a>b) a=b;}\n\nconst double pi=(double)acos(-1.0);\nconst double eps=(double)1e-10;\nconst int INF = (int) 0x3f3f3f3f;\nconst int MOD = (int) 1e9+7;\nconst int MAXN =(int) 5e2+10;\nconst int MAXM = (int) 2e5+10;\nconst int sigma_size = (int) 26;\n\n///--------------------START-------------------------\nLL a[MAXN][MAXN];\nconst int N = (int) 2e5 +10;\nint prime[N],phi[N],cnt;// prime:记录质数，phi记录欧拉函数\nint Min_factor[N];// i的最小素因子\nbool vis[N];\nvoid Init()\n{\n    cnt=0;\n    phi[1]=1;\n    int x;\n    for(int i=2;i<N;i++)\n    {\n        if(!vis[i])\n        {\n            prime[++cnt]=i;\n            phi[i]=i-1;\n            Min_factor[i]=i;\n        }\n        for(int k=1;k<=cnt&&prime[k]*i<N;k++)\n        {\n            x=prime[k]*i;\n            vis[x]=true;\n            Min_factor[x]=prime[k];\n            if(i%prime[k]==0)\n            {\n                phi[x]=phi[i]*prime[k];\n                break;\n            }\n            else phi[x]=phi[i]*(prime[k]-1);\n        }\n    }\n}\n\nLL gcd(LL x,LL y){\n    return x==0 ? y : gcd(y%x,x);\n}\nset<LL> st;\n\nvoid work(){\n    int n=500;\n    for(int i=0;i<=n+1;i++){\n        for(int j=0;j<=n+1;j++){\n            a[i][j]=1;\n        }\n    }\n    Init();\n    int p=1;\n    for(int i=2;i<=500;i+=2) a[1][i]=prime[++p];\n    for(int i=1;i<=500;i+=2) a[2][i]=prime[++p];\n    for(int i=3;i<=n;i++){\n        int x=(i+1)/2;\n        for(int j=1;j<=n;j++)if(a[i-2][j]>1){\n            a[i][j]=a[i-2][j]/(x-1)*x;\n        }\n    }\n    int mi=0;\n    LL mx=0;\n//    for(int i=1;i<=5;i++){\n//        for(int j=1;j<=5;j++){\n//            printf(\"%lld \",a[i][j]);\n//        }\n//        printf(\"\\n\");\n//    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++)if(a[i][j]==1){\n            LL g1=gcd(a[i-1][j],a[i][j-1]);\n            LL g2=gcd(a[i+1][j],a[i][j+1]);\n            LL t1=a[i-1][j]*a[i][j-1]/g1;\n            LL t2=a[i+1][j]*a[i][j+1]/g2;\n            LL g3=gcd(t1,t2);\n            LL T=t1*t2/g3;\n            LL t=2,tmp=T+1;\n            while(st.count(tmp)){\n                tmp=T*t+1;\n                t++;\n            }\n            a[i][j]=tmp;\n            st.insert(a[i][j]);\n//            mx=max(mx,a[i][j]);\n        }\n    }\n//    printf(\"mi = %d\\n\",mi);\n    printf(\"mx = %lld\\n\",mx);\n//    for(int i=499;i<=n;i++){\n//        for(int j=499;j<=n;j++){\n//            printf(\"%lld \",a[i][j]);\n//        }\n//        printf(\"\\n\");\n//    }\n    int N; scanf(\"%d\",&N);\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            printf(\"%lld\",a[i][j]);\n            if(j<N) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n}\n\n///--------------------END-------------------------\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001], prm[2003];\nint vis[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=5e2+10;\nconst int MAXM=1e5+10;\nint n;\nll Mat[MAXN][MAXN];\nint pcnt=0,prime[MAXM],vis[MAXM];\nvoid Linear_Shaker()\n{\n\tfor(rg int i=2;i<=MAXM;++i)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t\tprime[++pcnt]=i;\n\t\t\tfor(rg int j=1;i*prime[j]<=MAXM;++j)\n\t\t\t\t{\n\t\t\t\t\tvis[i*prime[j]]=1;\n\t\t\t\t\tif(i % prime[j]==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n}\nll GCD(ll x,ll y)\n{\n\treturn y==0? x: GCD(y,x%y);\n}\nll LCM(ll x,ll y)\n{\n\treturn x / GCD(x,y) * y;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tLinear_Shaker();\n\tfor(rg int i=1;i<=n;++i)\n\t\tfor(rg int j=1;j<=n;++j)\n\t\t\tMat[i][j]=1ll;\n\tfor(rg int i=1;i<=n;++i)\n\t\tfor(rg int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif((i&1)==(j&1))\n\t\t\t\t\t{\n\t\t\t\t\t\tMat[i][j]=1ll* prime[(i+j)/2] * prime[(i+n+1-j)/2+n];\n\t\t\t\t\t\tMat[i+1][j]=LCM(Mat[i+1][j],Mat[i][j]);\n\t\t\t\t\t\tMat[i-1][j]=LCM(Mat[i-1][j],Mat[i][j]);\n\t\t\t\t\t\tMat[i][j+1]=LCM(Mat[i][j+1],Mat[i][j]);\n\t\t\t\t\t\tMat[i][j-1]=LCM(Mat[i][j-1],Mat[i][j]);\n\t\t\t\t\t}\n\t\t\t}\n\tfor(rg int i=1;i<=n;++i)\n\t\tfor(rg int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld%c\",(i&1)==(j&1)?Mat[i][j]:Mat[i][j]+1,j==n?'\\n':' ');\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////\n//                          Give me AC!!!                                     //\n////////////////////////////////////////////////////////////////////////////////\n#include <iostream>\n#include <random>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nnamespace mp = boost::multiprecision;\nusing namespace mp;\nusing ull = __int128;\nusing ll = long long;\nusing cll = cpp_int;\nusing Graph = vector<vector<ll>>; \n#define coutY cout<<\"YES\"<<endl\n#define couty cout<<\"Yes\"<<endl\n#define coutN cout<<\"NO\"<<endl\n#define coutn cout<<\"No\"<<endl\n#define coutdouble(a,b) cout << fixed << setprecision(a) << double(b) ;\n#define vi(a,b) vector<int> a(b)\n#define vl(a,b) vector<ll> a(b)\n#define vs(a,b) vector<string> a(b)\n#define vll(a,b,c)  vector<vector<ll>> a(b, vector<ll>(c));\n#define intque(a) queue<int> a;\n#define llque(a) queue<ll> a;\n#define intque2(a) priority_queue<int, vector<int>, greater<int>> a;\n#define llque2(a) priority_queue<ll, vector<ll>, greater<ll>> a;\n#define pushback(a,b) a.push_back(b)\n#define mapii(M1) map<int, int> M1;\n#define cou(v,x) count(v.begin(), v.end(), x)\n#define mapll(M1) map<ll,ll> M1;\n#define mapls(M1) map<ll, string> M1;\n#define mapsl(M1) map<string, ll> M1;\n#define twolook(a,l,r,x) lower_bound(a+l, a+r, x) - a\n#define sor(a) sort(a.begin(), a.end())\n#define rever(a) reverse(a.begin(),a.end())\n#define rep(i,a) for(ll i=0;i<a;i++)\n#define vcin(n) for(ll i=0;i<ll(n.size());i++) cin>>n[i]\n#define vcout(n) for(ll i=0;i<ll(n.size());i++) cout<<n[i]\n#define vcin2(n) rep(i,ll(n.size())) rep(j,ll(n.at(0).size())) cin>>n[i][j]\nconst ll mod = 1000000007;\nconst ll MOD = 1000000007;\nconst ll MAX = 200000;\n//const ll _max = 9223372036854775807;\nconst ll _max = 1223372036854775807;\n  \nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< mod >;\n\nint modPow(long long a, long long n, long long p) {\n  if (n == 0) return 1; // 0乗にも対応する場合\n  if (n == 1) return a % p;\n  if (n % 2 == 1) return (a * modPow(a, n - 1, p)) % p;\n  long long t = modPow(a, n / 2, p);\n  return (t * t) % p;\n}\n\nll clocks(ll a,ll b,ll c){\n  return a*3600+b*60+c;\n}\nll divup(ll b,ll d){\n   if(b%d==0){\n    return b/d;\n  }\n  else{\n    return b/d+1;\n  }\n}\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\n\nstruct Edge {\n    int to;     // 辺の行き先\n    int weight; // 辺の重み\n    Edge(int t, int w) : to(t), weight(w) { }\n};\n\nusing Graphw = vector<vector<Edge>>;\nll zero(ll a){\n  return max(ll(0),a);\n}\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\n//aはbの何乗以下かを満たす数の内最大の物,(a,10)はaの桁数\nll expless(ll a,ll b){\n  ll k=0;\n  ll o=1;\n  while(a>=o){\n    k++;\n    o=o*b;\n  }\n  return k;\n}\n//aをb進法で表す\nll base(ll a,ll b){\n  ll ans=0;\n  ll k;\n while(a>0){\n    k=a%b;\n    ans+=k;\n    a=a/b;\n }\n  return ans;\n}\n//b進法のaを10進法に直す\nll tenbase(ll a,ll b){\n  ll c=expless(a,10);\n  ll ans=0;\n  ll k=1;\n  for(int i=0;i<c;i++){\n    ans+=(a%10)*k;\n    k=k*b;\n    a=a/10;\n  }\n  return ans;\n}\nvector<pair<long long, long long> > prime_factorize(long long N) {\n    vector<pair<long long, long long> > res;\n    for (long long a = 2; a * a <= N; ++a) {\n        if (N % a != 0) continue;\n        long long ex = 0; // 指数\n\n        // 割れる限り割り続ける\n        while (N % a == 0) {\n            ++ex;\n            N /= a;\n        }\n\n        // その結果を push\n        res.push_back({a, ex});\n    }\n\n    // 最後に残った数について\n    if (N != 1) res.push_back({N, 1});\n    return res;\n}\nll atll(ll a,ll b){\n  b++;\n  ll c=expless(a,10);\n  ll d=c-b;\n  ll f=1;\n  for(int i=0;i<d;i++){\n    f=f*10;\n  }\n  a=(a/f);\n  return a%10;\n}\n//aがbで何回割り切るか\nll exp(ll a,ll b){\n  ll ans=0;\n  while(a%b==0){\n    a=a/b;\n    ans++;\n  }\n  return ans;\n}\nstd::vector<ll> Eratosthenes( const ll N )\n{\n    std::vector<bool> is_prime( N + 1 );\n    for(ll i = 0; i <= N; i++ )\n    {\n        is_prime[ i ] = true;\n    }\n    std::vector<ll> P;\n    for( ll i = 2; i <= N; i++ )\n    {\n        if( is_prime[ i ] )\n        {\n            for( ll j = 2 * i; j <= N; j += i )\n            {\n                is_prime[ j ] = false;\n            }\n            P.emplace_back( i );\n        }\n    }\n    return P;\n}\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int X[6]={1,1,0,-1,-1,0};\nconst int Y[6]={0,1,1,0,-1,-1};\nint main() {\nCOMinit();\n   vector<ll> p=Eratosthenes(10000);\n vector<vector<ll>> ans(500, vector<ll>(500));\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      ans.at(i).at(j)=1;\n    }\n  }\n for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      if((i+j)%2==0){\n        ans.at(i).at(j)*=p.at((i+j)/2);\n      }\n      if((i-j)%2==0){\n        ans.at(i).at(j)*=p.at(((i-j)/2)+749);\n      }\n    }\n  }\n    for(int i=0;i<500;i++){\n     for(int j=0;j<500;j++){\n       if((i+j)%2==1){\n     if(i==0&&j==499){\n       ans.at(i).at(j)*=ans.at(i).at(j-1)*ans.at(i+1).at(j);\n     }\n     else if(i==499&&j==0){\n       ans.at(i).at(j)*=ans.at(i-1).at(j)*ans.at(i).at(j+1);\n     }\n   else if(j==0||j==499){\n     ans.at(i).at(j)=ans.at(i-1).at(j)*ans.at(i+1).at(j);\n   }\n         else{\n           ans.at(i).at(j)=ans.at(i).at(j-1)*ans.at(i).at(j+1);\n         }\n           ans.at(i).at(j)++; \n      }\n    }\n  }\n  ll a;\n  cin>>a;\n  for(int i=0;i<a;i++){\n    for(int j=0;j<a;j++){\n      cout<<ans.at(i).at(j);\n      if(j!=a-1){\n        cout<<\" \";\n      }\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ph push\n#define ptc putchar\n#define enter putchar('\\n')\n#define mod 998244353\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef long long lnt;\ninline int read(){\n\tint x = 0;char c = getchar();\n\twhile (!isdigit(c)) c = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + c - '0' , c = getchar();\n\treturn x;\n}\ninline void write(int x){\n\tif (!x){\n       ptc('0');\n       return;\n\t}\n\tint dg[20] , len = 0;\n\twhile (x) dg[len++] = x % 10 , x /= 10;\n\twhile (len--) ptc(dg[len]+'0');\n}\ninline void writeln(int x){\n\twrite(x);\n\tptc('\\n');\n}\ninline int add(int x,int y){\n\tx += y;if (x >= mod) x -= mod;\n\treturn x;\n}\ninline int sub(int x,int y){\n\tx -= y;if (x < 0) x += mod;\n\treturn x;\n}\ninline int qpow(int x,int y){\n\tint res = 1;\n\twhile (y){\n\t\tif (y & 1) res = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod;y >>= 1;\n\t}\n\treturn res;\n}\nconst int N = 500 + 10;\nconst int dx[] = {0 , 0 , 1 , -1};\nconst int dy[] = {1 , -1 , 0 , 0};\n\nll res[N][N] ;\nint n;\nint pri[N * 4] , pcnt;\n\nvoid getp(){\n\tfor (int i = 2;pcnt <= 1100;i++){\n\t\tfor (int j = 1;j <= pcnt;j++){\n\t\t\tif (i % pri[j] == 0) goto wxh;\n\t\t}\n\t\tpri[++pcnt] = i;\n\t\twxh:;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\t\n    if(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tgetp();\n\tfor (int i = 1;i <= n;i++)\n\tfor (int j = 1;j <= n;j++)\n\tif ( !((i + j) & 1)){\n\t\tres[i][j] = 1ll * pri[(i + j) >> 1] * pri[((i - j) >> 1) + ((n + 1) / 2) + n];\n\t}\n\tfor (int i = 1;i <= n;i++)\n\tfor (int j = 1;j <= n;j++)\n\tif ( ((i + j) & 1)){\n\t\tll d = 1;\n\t\tfor (int o = 0;o < 4;o++){\n\t\n\t\t\tint ni = i + dx[o] , nj = j + dy[o];\n\t\t\tif (ni > n || ni < 1 || nj > n || nj < 1) continue;\n\t\t\td = 1ll * d * res[ni][nj] / __gcd(d , res[ni][nj]);\n\t\t}\n\t\tres[i][j] = d + 1;\n\t}\n\t\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tfor (int j = 1;j <= n;j++){\n\t\t\tprintf(\"%lld \",res[i][j]);\n\t\t}enter;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1111111\n#define int long long\nbool vis[1111111];\nint pri[111111],tot;\nint a[11111],b[11111],f[555][555];\nmap<int,bool>mp;\nint LCM(int a,int b){return a/__gcd(a,b)*b;}\nint LCM(int a,int b,int c,int d){\n\treturn LCM(LCM(LCM(a,b),c),d);\n}\nsigned main(){\n\tfor (int i=2;tot<=1111 && i<N;i++){\n\t\tif (!vis[i]) pri[++tot]=i;\n\t\tfor (int j=1;j<=tot && pri[j]*i<N;j++){\n\t\t\tvis[i*pri[j]]=1; \n\t\t\tif (i%pri[j]==0) break;\n\t\t}\t\n\t}\n\tint n; scanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=pri[i];\n\t\tb[i]=pri[i+n];\n\t}\n\tfor (int i=0;i<=n+1;i++) f[i][0]=f[0][i]=f[n+1][i]=f[i][n+1]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tf[i][j]=a[(i-j)/2+(n+1)/2]*b[(i+j)/2];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)&1){\n\t\t\t\tf[i][j]=LCM(f[i-1][j],f[i][j-1],f[i+1][j],f[i][j+1])+1;\n\t\t\t\twhile (mp.count(f[i][j])) f[i][j]=(f[i][j]-1)*2+1;\n\t\t\t\tmp[f[i][j]]=1;\n\t\t\t}\n\t\t\t\t\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",f[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\t\n\tscanf(\"%d\", &n);\n//\trandom_shuffle(prime, prime+n+n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0 ; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\n\t#ifdef che\n\tdebug(\"last = %d\\n\", prime[cur]);\n\t#endif\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tif ( i) s *= a[i-1][j];\n\t\tif ( i+1<n ) s*=a[i+1][j];\n\t\tif ( j) s*= b[i][j-1];\n\t\tif ( j+1<n ) s*=b[i][j+1];\n\t\t\n\t\tassert(s <= LL(1e15)  );\n\t\ta[i][j] = s+1;\n\t}\n\tfor (int i=0; i<n; ++i) for (int j=0; j<n; ++j) if (b[i][j])\n\t\ta[i][j] *= b[i][j];\n\tif( n==2) a[1][1] = 2*a[1][1]-1;\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline ll gcd(ll a, ll b) {return b == 0 ? a : gcd(b, a % b);}\nll ans[510][510];\nint n;\nint prime[20010], cnt;\nint np[20010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n + 1; i++) ans[0][i] = ans[i][0] = ans[n + 1][i] = ans[i][n + 1] = 1;\n    for (int i = 2; i <= 20000; i++) {\n        if (!np[i]) prime[++cnt] = i;\n        for (int j = 1; prime[j] * i <= 20000; j++) {\n            np[i * prime[j]] = 1;\n            if (i % prime[j] == 0) break;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) & 1) ans[i][j] = prime[i + j] * prime[i - j + 3 * n];\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            if ((i + j) % 2 == 0) {\n                ans[i][j] = 1;\n                ans[i][j] *= ans[i - 1][j] / gcd(ans[i - 1][j], ans[i][j]);\n                ans[i][j] *= ans[i + 1][j] / gcd(ans[i + 1][j], ans[i][j]);\n                ans[i][j] *= ans[i][j - 1] / gcd(ans[i][j - 1], ans[i][j]);\n                ans[i][j] *= ans[i][j + 1] / gcd(ans[i][j + 1], ans[i][j]);\n            }\n    for (int i = 1; i <= n; i++, puts(\"\"))\n        for (int j = 1; j <= n; j++) printf(\"%lld \", ans[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  vector<bool> furui(5001,true);\n  int j;\n  for (int i=2; i<100; i++) {\n    j = 2;\n    while (i * j <= 5000) {\n      furui[i*j] = false;\n      j++;\n    }\n  }\n  \n  vector<long long> prime(500);\n  long long now = 500;\n    \n  for (int i=0; i<500; i++) {\n    while (!furui[now]) {\n      now++;\n    }\n    prime[i] = now;\n  }\n  \n  vector<vector<long long>> ans(500,vector<long long>(500,0));\n  \n  for (int i=0; i<500; i++) {\n    for (int j=0; j<500; j++) {\n      if ((i+j)%2 == 1) {\n        ans[i][j] = prime[(i-j+499)/2];\n        ans[i][j] *= ((i+j+1)/2);\n      }\n    }\n  }\n  \n  ans[0][0] = ans[0][1] * ans[1][0] + 1;\n  ans[499][499] = ans[499][498] * ans[498][499] + 1;\n  \n  for (int i=0; i<500; i++) {\n    for (int j=0; j<500; j++) {\n      if (ans[i][j] == 0) {\n        if (i == 0 || i == 499) {\n          ans[i][j] = ans[i][j-1] * ans[i][j+1] + 1;\n        }\n        else {\n          ans[i][j] = ans[i+1][j] * ans[i-1][j] + 1;\n        }\n      }\n    }\n  }\n  \n  \n  int N;\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      cout << ans[i][j];\n      if (j != N-1) {\n        cout << \" \";\n      }\n    }\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef long long ll;\nconst int T=10000;\nint pr[T+10];\nbool np[T+10];\nvoid sieve(){\n\tint i,j,M=0;\n\tfor(i=2;i<=T;i++){\n\t\tif(!np[i])pr[++M]=i;\n\t\tfor(j=1;j<=M&&i*pr[j]<=T;j++){\n\t\t\tnp[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){return a%b==0?b:gcd(b,a%b);}\nll lcm(ll a,ll b){\n\tif(a==0||b==0)return a|b;\n\treturn a*b/gcd(a,b);\n}\nll a[510][510];\nint main(){\n\tsieve();\n\tint n,i,j,M;\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tM=0;\n\tfor(i=1;i<n;i+=2){\n\t\tM++;\n\t\tfor(j=1;j<=i;j++)a[j][i-j+1]=pr[M];\n\t}\n\tif(n&1){\n\t\tM++;\n\t\tfor(i=1;i<=n;i++)a[n-i+1][i]=pr[M];\n\t}\n\tfor(i=1;i<n;i+=2){\n\t\tM++;\n\t\tfor(j=1;j<=i;j++)a[n-j+1][n-i+1+j-1]=pr[M];\n\t}\n\tfor(i=1;i<=n;i+=2){\n\t\tM++;\n\t\tfor(j=1;i+j-1<=n;j++)a[j][i+j-1]*=pr[M];\n\t}\n\tfor(i=3;i<=n;i+=2){\n\t\tM++;\n\t\tfor(j=1;i+j-1<=n;j++)a[i+j-1][j]*=pr[M];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif((i+j)&1)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,tot;\nconst int N=1005;\nLL a[N][N],zhi[N<<1],vis[10010];\nLL GCD(LL a,LL b){return b?GCD(b,a%b):a;}\nLL LCM(LL a,LL b){return a&b?a/GCD(a,b)*b:a+b;}\nvoid YYCH()\n{\n\tvis[1]=1;\n\tfor(int i=2;i<=10000;++i)\n\t{\n\t\tif(!vis[i])zhi[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*zhi[j]<=10000;++j)\n\t\t{\n\t\t\tvis[i*zhi[j]]=1;\n\t\t\tif(!(i%zhi[j]))break;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;if(n==2)return printf(\"4 7\\n23 10\\n\")==233;\n\tYYCH();\n    for(int i=1;i<=n;++i)\n    \tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n    \t\ta[i][j]=zhi[(i+j)/2]*zhi[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n    \tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t\ta[i][j]=LCM(LCM(a[i-1][j],a[i][j-1]),LCM(a[i+1][j],a[i][j+1]))+1;\n    for(int i=1;i<=n;++i,puts(\"\"))\n    \tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=10005;\nconst int MAXM=505;\nint pr[MAXN],is[MAXN],plen;\nvoid getpr()\n{\n\tfor(int i=2;i<MAXN;i++)\n\t{\n\t\tif(!is[i])pr[++plen]=i;\n\t\tfor(int j=1;j<=plen&&i*pr[j]<MAXN;j++)\n\t\t{\n\t\t\tis[i*pr[j]]=1;\n\t\t\tif(!(i%pr[j]))break;\n\t\t}\n\t}\n}\nint n,vis[MAXM][MAXM],now;LL a[MAXM][MAXM],b[MAXM][MAXM];\nLL gcd(LL a,LL b){return a==0?b:gcd(b%a,a);}\nvoid get1(int x,int y)\n{\n\tif(x>n||y>n)return ;\n\tvis[x][y]=1;a[x][y]*=pr[now];\n\tget1(x+1,y+1);\n}\nvoid get2(int x,int y)\n{\n\tif(x<1||x>n||y<1||y>n)return ;\n\tvis[x][y]=1;a[x][y]*=pr[now];\n\tget2(x+1,y-1);\n}\nbool in(int x,int y){return x>=1&&x<=n&&y>=1&&y<=n;}\nLL lcm(LL a,LL b){return a/gcd(a,b)*b;}\nint main()\n{\n\tgetpr();\t\n\tn=read();now=0;\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");return 0;\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)a[i][j]=1;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(((i+j-1)&1)&&!vis[i][j])\n\t\t++now,get1(i,j);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(((i+j-1)&1)&&!vis[i][j])\n\t\t++now,get2(i,j);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(!((i+j-1)&1))\n\t{\n\t\tif(in(i-1,j))a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\tif(in(i+1,j))a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\tif(in(i,j-1))a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\tif(in(i,j+1))a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t++a[i][j];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)pr1(a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\nmt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector<ll>divisor_enum(ll n){\n  vector<ll>ret;\n  for(ll i=1;i*i<=n;i++){\n    if(n%i==0){\n      if(i*i==n)ret.PB(i);\n      else{\n        ret.PB(i);\n        ret.PB(n/i);\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto v=vec(n,n,0LL);\n  set<ll>st;\n  st.insert(0);\n  rep(i,0,2*n-1){\n    if(~i&1)continue;\n    ll cnt=1;\n    const ll sta=500;\n    ll k=i/2+sta;\n    if((i/2)&1)k=2*sta-(k-sta);\n    rep(j,0,n){\n      ll x,y;\n      if((i/2)&1)x=j;else x=n-j-1;\n      y=i-x;\n      if(x<0||x>=n||y<0||y>=n)continue;\n      while(st.count(cnt*k))cnt++;\n      v[x][y]=cnt*k;\n      st.insert(v[x][y]);\n    }\n  }\n  //cout<<*st.rbegin()<<endl;\n  //debug(v,n,n);\n  ll lim=1e15;\n  rep(i,0,n)rrep(j,0,n){\n    if((i+j)&1)continue;\n    ll t=1,tg=0;\n    rep(o,0,4){\n      ll x=i+dx[o],y=j+dy[o];\n      if(x<0||y<0||x>=n||y>=n)continue;\n      t=t/gcd(t,v[x][y])*v[x][y];\n      //tg=gcd(tg,v[x][y]);\n    }\n    rep(o,1,500){\n      //cout<<t spa o<<endl;\n      if(st.count(t*o+1))continue;\n      v[i][j]=t*o+1;\n      st.insert(v[i][j]);\n      //assert(v[i][j]);\n      break;\n    }\n  }\n  rep(i,0,n)rep(j,0,n){\n    chmax(res,v[i][j]);\n    //if(v[i][j]==0)cout<<i spa j<<endl;\n  }\n  debug(v,n,n);\n  //cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint p[10000];\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tvi ps;\n\tfor(int i = 2; i < 10000; i++) if(!p[i]){\n\t\tps.pb(i);\n\t\tfor(int j = i * i; j < 10000; j += i) p[j] = 1;\n\t}\n\t\n\tint n; cin >> n;\n\tconst int N = 501;\n\tvector<vector<ll>> ans(N, vector<ll>(N, 1));\n\trep(i, N) rep(j, 2 * i + 1){\n\t\tint y = j, x = 2 * i - j;\n\t\tif(x < 0 || x >= N || y < 0 || y >= N) continue;\n\t\tans[y][x] *= ps[i];\n\t\tans[y][N - x - 1] *= ps[i + N];\n\t}\n\tset<ll> used;\n\trep(i, N) rep(j, N) used.insert(ans[i][j]);\n\t\n\t//dbg(used.size());\n\t//rep(i, N) rep(j, N) cerr<<ans[i][j]<<(j==N-1?\"\\n\":\" \");\n\t\n\trep(i, N) rep(j, N) if(ans[i][j] == 1){\n\t\tll pd = 1;\n\t\tfor(int dy = -1; dy < 2; dy++) for(int dx = -1; dx < 2; dx++){\n\t\t\tif(!dy && !dx) continue;\n\t\t\tif(abs(dy) + abs(dx) > 1) continue;\n\t\t\tif(i + dy < 0 || i + dy >= N || j + dx < 0 || j + dx >= N) continue;\n\t\t\tll g = __gcd(ans[i + dy][j + dx], pd);\n\t\t\tpd = pd / g * ans[i + dy][j + dx];\n\t\t}\n\t\tfor(ll x = pd + 1; ; x += pd){\n\t\t\tif(!used.count(x)){\n\t\t\t\tused.insert(x);\n\t\t\t\tans[i][j] = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, N) rep(j, N) assert(ans[i][j] > 0 && ans[i][j] < 1e15);\n\trep(i, n) rep(j, n) cout << ans[i][j] << (j==n-1?\"\\n\":\" \");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005;\n\n#define int long long\n\nint gcd(int x, int y) {\n\treturn (!y) ? x : gcd(y, x % y);\n}\n\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint n, A[N][N], pr[N], cnt;\nbitset <100005> isp;\n\nvoid prework(int tot) {\n\tfor(int i = 1; i < 100005; ++ i) isp[i] = 1;\n\tisp[1] = 0;\n\tfor(int i = 1; cnt < tot; ++ i) {\n\t\tif(isp[i]) pr[++ cnt] = i;\n\t\tfor(int j = 1; j <= cnt && pr[j] * i <= 100000; ++ j) {\n\t\t\tisp[i * pr[j]] = 0;\n\t\t\tif(i % pr[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain() {\n\tisp = 0;\n\tcin >> n;\n\tn += 2;\n\tprework(n * 2 + 2);\n\t//for(int i =1; i <= cnt; ++ i) cerr << pr[i] << \" \";\n\t//puts(\"\");\n\tfor(int i = 0; i <= n + 1; ++ i) {\n\t\tfor(int j = 0; j <= n + 1; ++ j) {\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i = 1; i <= n; i += 2) {\n\t\tint nx = i, ny = 1;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 3; i <= n; i += 2) {\n\t\tint nx = 1, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n; i >= 1; i -= 2) {\n\t\tint nx = n, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n - ((n & 1) ^ 1); i >= 1; i -= 2) {\n\t\tint nx = i, ny = 1;\n\t\tif(i == n) continue;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\t//cerr << i <<\" \" << j << endl;\n\t\t\t\t//cerr << A[i][j - 1] <<\" \" << A[i - 1][j] <<\" \" << A[i + 1][j] <<\" \" << A[i][j + 1] << endl;\n\t\t\t\tA[i][j] = lcm(lcm(A[i][j - 1], A[i - 1][j]), lcm(A[i + 1][j], A[i][j + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2; i <= n - 1; ++ i) {\n\t\tfor(int j = 2; j <= n - 1; ++ j) printf(\"%lld \", A[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong gcd(long a, long b) {\n\tfor (; b; swap(a, b))\n\t\ta %= b;\n\treturn a;\n}\nlong lcm(long a, long b) {\n\ta /= gcd(a, b);\n\tif (double(a)*b > 1e15)\n\t\tthrow 0;\n\treturn a * b;\n}\nlong lcm(long a, long b, long c, long d) {\n\treturn lcm(lcm(a, b), lcm(c, d));\n}\nlong a[555][555];\nint main() {\n\tint N;\n\tcin >> N;\n\tint n = 500;\n\tlong x = 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2) continue;\n\t\t\tif (i % 5) {\n\t\t\t\ta[i][j] = a[i - 1][j + 1 - i % 2 * 2] * 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j] = x;\n\t\t\tx += 2;\n\t\t}\n\t}\n\tint s[] = { 0,1,0,-1,0 };\n\tset<long> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) continue;\n\t\t\tlong y[] = { 1,1,1,1 };\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\tif (i + s[k] >= 0 && i + s[k] < n&&j + s[k + 1] >= 0 && j + s[k + 1] < n)\n\t\t\t\t\ty[k] = a[i + s[k]][j + s[k + 1]];\n\t\t\tlong l = lcm(y[0], y[1], y[2], y[3]);\n\t\t\tlong m = 1;\n\t\t\twhile (q.find(m*l + 1) != q.end())\n\t\t\t\tm++;\n\t\t\tq.insert(m*l + 1);\n\t\t\ta[i][j] = m * l + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 505;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  donttttttt use vector \n  run n = 1 and n = MAXN before submit\n  try to AC within one submission\n*/\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\n\n#define int long long\n\nconst int N = 555;\nconst int M = 5e6 + 233;\nbool np[M]; int p[M / 10], p_cnt;\nint n, a[N][N];\n\ninline void prepare(int n) {\n\tnp[1] = true;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (np[i]) continue;\n\t\tp[++p_cnt] = i;\n\t\tfor (int j = i + i; j <= n; j += i)\n\t\t\tnp[j] = true;\n\t}\n}\n\nsigned main(void) {\n\tread(n);\n\tprepare(5e6);\n\tvector <int> ch;\n\tint need = n * n - (n * n) / 2;\n\tint tot = 1;\n\tfor (int i = 2; i <= p_cnt && ch.size() < need; i++)\n\t\tch.push_back((tot += 2));\n\trandom_shuffle(ch.begin(), ch.end());\n\trep (i, n) rep (j, n) if ((i + j) % 2 == 0) {\n\t\ta[i][j] = ch.back(); ch.pop_back();\n\t}\n\t// rep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n\trep (i, n) rep (j, n) if ((i + j) & 1) {\n\t\ta[i][j] = 1;\n\t\tauto add = [&](int x, int y) {\n\t\t\tif (x < 1 || x > n || y < 1 || y > n) return ;\n\t\t\ta[i][j] *= a[x][y];\n\t\t\treturn ;\n\t\t};\n\t\tadd(i - 1, j);\n\t\tadd(i + 1, j);\n\t\tadd(i, j - 1);\n\t\tadd(i, j + 1);\n\t\t++a[i][j];\n\t}\n\trep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nint N;\nint a[201][201], tot = 2;\nmain() {\n\tcin >> N;\n\ta[1][1] = 2;\n\tfor(int i = 2; i <= N; i++) a[1][i] = ++tot;\n\tif((tot & 1)) tot++;\n\tfor(int i = 2; i <= N; i++) a[i][1] = ++tot;\n\tfor(int i = 2; i <= N; i++)\n\t\tfor(int j = 2; j <= N; j++)\n\t\t\ta[i][j] = a[i - 1][j] * a[i][j - 1] / __gcd(a[i - 1][j], a[i][j - 1]) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a*b/__gcd(a,b);\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=N;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t//\tcout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\tint d=(i-j+n+1)/2-1;\n\t\t\tg[i][j]*=P[d+500];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 1;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\n#include <cassert>\n#pragma warning (disable: 4996)\nusing namespace std;\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    if (n < 0)return 0;\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvector<int> tpsort(vector<vector<int>>& G) {\n    int V = G.size();\n    vector<int> sorted_vertices;\n    queue<int> que;\n    vector<int> indegree(V);\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < G[i].size(); j++) {\n            indegree[G[i][j]]++;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n    while (que.empty() == false) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        sorted_vertices.push_back(v);\n    }\n    return sorted_vertices;\n}\n\nstruct Point\n{\n    double x;\n    double y;\n};\n\nstruct LineSegment\n{\n    Point start;\n    Point end;\n};\n\ndouble tenkyori(const LineSegment& line, const Point& point)\n{\n    double x0 = point.x, y0 = point.y;\n    double x1 = line.start.x, y1 = line.start.y;\n    double x2 = line.end.x, y2 = line.end.y;\n\n    double a = x2 - x1;\n    double b = y2 - y1;\n    double a2 = a * a;\n    double b2 = b * b;\n    double r2 = a2 + b2;\n    double tt = -(a * (x1 - x0) + b * (y1 - y0));\n\n    if (tt < 0)\n        return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n    else if (tt > r2)\n        return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));\n\n    double f1 = a * (y1 - y0) - b * (x1 - x0);\n    return sqrt((f1 * f1) / r2);\n}\nvoid dfs1(vector<vector<ll>>& z, ll k, ll oya, ll& ans, vector<ll>& b) {\n    for (auto m : z[k]) {\n        if (m != oya)dfs1(z, m, k, ans, b);\n    }\n    vector<ll> s;\n    for (auto m : z[k]) {\n        if (m != oya)s.push_back(b[m]);\n    }\n    ll m = b.size() - 1;\n    for (auto d : s) {\n        m -= d;\n    }\n    b[k] = b.size() - m;\n    if (m != 0)s.push_back(m);\n    ll a = modinv(2, 1000000007);\n    for (auto d : s) {\n        a += 1000000007 - modinv(modpow(2, b.size() - d, 1000000007), 1000000007);\n    }\n    a += modinv(modpow(2, b.size(), 1000000007), 1000000007) * (z[k].size() - 1);\n    ans += a;\n    ans %= 1000000007;\n    return;\n}\n\nll merge_cnt(vector<int>& a) {\n    int n = a.size();\n    if (n <= 1) { return 0; }\n\n    ll cnt = 0;\n    vector<int> b(a.begin(), a.begin() + n / 2);\n    vector<int> c(a.begin() + n / 2, a.end());\n\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    vector<vector<ll>> z(500,vector<ll>(500));\n    vector<ll> x(500,1);\n    for (int i = 0; i < 500; i++) {\n        ll k = i;\n        x[i] *= modpow(2, k % 7, 1000000007);\n        k /= 7;\n        x[i] *= modpow(3, k % 3, 1000000007);\n        k /= 3;\n        x[i] *= modpow(5, k % 3, 1000000007);\n        k /= 3;\n        x[i] *= modpow(7, k % 2, 1000000007);\n        k /= 2;\n        x[i] *= modpow(11, k % 2, 1000000007);\n        k /= 2;\n        x[i] *= modpow(13, k % 2, 1000000007);\n        k /= 2;\n    }\n    vector<ll> t(250);\n    ll c = 0;\n    for (int i = 160; i < 1000000; i++) {\n        if (i % 2 != 0 && i % 3 != 0 && i % 5 != 0 && i % 7 != 0 && i % 11 != 0 && i % 13 != 0) {\n            t[c] = i;\n            c++;\n        }\n        if (c == 250) {break; }\n    }\n    t[249] = 151;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 1) {\n                if(i<j)z[i][j] = x[(i + j) / 2];\n                else z[i][j] = x[((i + j) / 2+250)%500];\n                z[i][j] *= t[(i - j + 500) / 2 % 250];\n            }\n        }\n    }\n    ll u = 0;\n    set<ll> s;\n    ll us = 0;\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 0) {\n                ll a = 1;\n                ll b = 1;\n                ll c = 1;\n                ll d = 1;\n                if (i != 0)a = z[i - 1][j];\n                if (j != 0)b = z[i][j - 1];\n                if (i != 499)c = z[i + 1][j];\n                if (j != 499)d = z[i][j + 1];\n                ll p = a / __gcd(a, b) * b;\n                p *= c / __gcd(p, c);\n                p *= d / __gcd(p, d);\n                z[i][j] = p + 1;\n                while (s.count(z[i][j])) {\n                    z[i][j] += p;\n                }\n                s.insert(z[i][j]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << z[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1010\n#define ll long long\n\nint n,cnt;\nint mark[N*10];\nll pri[N],a[N][N];\n\nvoid getpri() {\n\tfor (int i=2;i<=10000;i++) {\n\t\tif (!mark[i]) pri[++cnt]=i;\n\t\tif (cnt==1000) break;\n\t\tfor (int j=1;j<=cnt && i*pri[j]<=10000;j++) {\n\t\t\tmark[i*pri[j]]=1;\n\t\t\tif (i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\nll lcm(ll x,ll y) {\n\tif (!x || !y) return x+y;\n\treturn x/__gcd(x,y)*y;\n}\n\nint main()\n{\n\tgetpri();\n\tscanf(\"%d\",&n);\n\tif (n==2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\ta[i][j]=pri[(i+j)/2]*pri[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (!a[i][j])\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]));\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\n__int128 cmmdc ( __int128 a , __int128 b ){\n\n    while ( b ){\n        __int128 t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\n__int128 calcLCM ( __int128 a , __int128 b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int i = 0 ; i < 2 * noLin ; i+=1 ){\n        diagPrin [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < 2 * noLin ; i+=2 ){\n        diagSec [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < noLin ; i+=1 ){\n        for ( int j = 0 ; j < noLin ; j+=1 ){\n            int crPrin = j - i + noLin - 1 ;\n            int crSec = 2*noLin - i - j - 1 ;\n\n            mat [ i ][ j ] = diagPrin [ crPrin ] * diagSec [ crSec ];\n        }\n    }\n\n    int jj = 0 ;\n    if ( noLin == 2 ){\n        int jj= 1 ;\n    }\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = jj ; j < noLin ; j++ ){\n\n            __int128  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            cout << mat [ i ][ j ] << \" \" ;\n//            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 510;\nint n,tot;\nll a[N][N];\nconst int dx[]={0,0,1,-1};\nconst int dy[]={-1,1,0,0};\nll _lcm(ll x, ll y) {\n\tif (!y) return x;\n\treturn x/gcd(x,y)*y;\n}\n\nint main() {\n\tcin>>n;\n\tREP(i,1,N-1) REP(j,1,N-1) if (i+j&1) a[i][j]=++tot;\n\tREP(i,1,n) REP(j,1,n) if (!a[i][j]) {\n\t\tint x = 1;\n\t\tREP(d,0,3) {\n\t\t\tint ii=i+dx[d],jj=j+dy[d];\n\t\t\tx = _lcm(x,a[ii][jj]);\n\t\t}\n\t\ta[i][j] = x+1;\n\t}\n\tREP(i,1,n) {\n\t\tREP(j,1,n) cout<<a[i][j]<<' ';hr;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nLL a[500][500];\nvector<int> v[500][500];\nconst unsigned long long MX = LL(19e18);\n\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; ++i) {\n        if (x % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nset<LL> se;\n\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nLL lcm(unsigned long long a, unsigned long long b) {\n    assert(MX / a > b);\n    return a * b / gcd(a, b);\n}\n\nvoid ap(vector<int> &a, vector<int> &b) {\n    for (int x : b) {\n        a.pb(x);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    if (n == 2) {\n        cout << \"4 7\" << endl;\n        cout << \"23 10\" << endl;\n        return 0;\n    }\n    forn(i, n) forn(j, n) {\n        a[i][j] = 1;\n    }\n    int pr = 2;\n    for (int st = 0; st < 2 * n + 5; st += 2) {\n        bool firstTime = true;\n        for (int i = 0; i < n; ++i) {\n            int j = st - i;\n            if (j >= 0 && j < n) {\n                if (firstTime) {\n                    firstTime = false;\n                    while (!isPrime(pr)) {\n                        ++pr;\n                    }\n                }\n                a[i][j] *= pr;\n                v[i][j].pb(pr);\n            }\n        }\n        if (!firstTime) {\n            ++pr;\n        }\n    }\n    for (int st = 0; st < n; st += 2) {\n        bool firstTime = true;\n        for (int i = 0; i < n; ++i) {\n            int j = i + st;\n            if (j >= 0 && j < n) {\n                if (firstTime) {\n                    firstTime = false;\n                    while (!isPrime(pr)) {\n                        ++pr;\n                    }\n                }\n                a[i][j] *= pr;\n                v[i][j].pb(pr);\n            }\n        }\n        if (!firstTime) {\n            ++pr;\n        }\n    }\n    for (int st = 2; st < n; st += 2) {\n        bool firstTime = true;\n        for (int j = 0; j < n; ++j) {\n            int i = j + st;\n            if (i >= 0 && i < n) {\n                if (firstTime) {\n                    firstTime = false;\n                    while (!isPrime(pr)) {\n                        ++pr;\n                    }\n                }\n                a[i][j] *= pr;\n                v[i][j].pb(pr);\n            }\n        }\n        if (!firstTime) {\n            ++pr;\n        }\n    }\n\n//    forn(i, n) {\n//        forn(j, n) printf(\"%7d\", (int)a[i][j]);\n//        puts(\"\");\n//    }\n\n    LL mx = 0;\n    forn(i, n) forn(j, n) {\n        if ((i + j) % 2 == 1) {\n            LL res = 1;\n            vector<int> vv;\n            if (i > 0) ap(vv, v[i - 1][j]);\n            if (i < n - 1) ap(vv, v[i + 1][j]);\n            if (j > 0) ap(vv, v[i][j - 1]);\n            if (j < n - 1) ap(vv, v[i][j + 1]);\n            sort(vv.begin(), vv.end());\n            res = vv[0];\n            for (int i = 1; i < (int)vv.size(); ++i) {\n                if (vv[i] != vv[i - 1]) {\n                    res *= vv[i];\n                }\n            }\n            res += 1;\n            a[i][j] = res;\n        }\n    }\n\n    forn(i, n) forn(j, n) {\n        mx = max(mx, a[i][j]);\n        assert(!se.count(a[i][j]));\n        se.insert(a[i][j]);\n    }\n\n    forn(i, n) {\n        forn(j, n) printf(\"%lld \", a[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,j,book[8005],top,zhan[8005],a[205][205];\nlong long gcd(long long u,long long v){\n\tif(v==0) return u;\n\treturn gcd(v,u%v);\n}\nlong long lcm(long long u,long long v){\n\tif(u==0) return v;\n\tif(v==0) return u;\n\treturn u/gcd(u,v)*v;\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tfor(i=2;i<=8000;i++)\n\t\tif(book[i]==0){\n\t\t\ttop++;\n\t\t\tzhan[top]=i;\n\t\t\tfor(j=i*2;j<=8000;j+=i)\n\t\t\t\tbook[j]=1;\n\t\t}\n\tn=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=zhan[i+j-1]*zhan[i-j+n*3];\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==0)\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]));\n  \tfor(i=1;i<=n;i++,cout<<endl)\n  \t\tfor(j=1;j<=n;j++)\n  \t\t\tpus(a[i][j],1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n*/\n#include <cstdio>\n#include <algorithm>\ntypedef long long LL;\nconst int N=505,M=8100;\n\nint P[1005];\nLL A[N][N];\n\nvoid Init()\n{\n\tstatic bool notP[M];\n\tfor(int cnt=0,i=2; cnt<1000; ++i)\n\t{\n\t\tif(!notP[i]) P[++cnt]=i;\n\t\tfor(int j=1,v; j<=cnt&&(v=i*P[j])<M; ++j)\n\t\t{\n\t\t\tnotP[v]=1;\n\t\t\tif(!(i%P[j])) break;\n\t\t}\n\t}\n}\ninline LL LCM(int x,int y)\n{\n\treturn 1ll*x/std::__gcd(x,y)*y;\n}\n\nint main()\n{\n\tInit();\n\tint n; scanf(\"%d\",&n);\n\tif(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tfor(int i=0; i<=n+1; ++i) A[0][i]=1, A[n+1][i]=1, A[i][n+1]=A[i][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=n; ++j)\n\t\t\tif(!(i+j&1)) A[i][j]=P[i+j>>1]*P[(i-j+n+1)/2+n];\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=n; ++j)\n\t\t\tif(i+j&1) A[i][j]=LCM(LCM(A[i-1][j],A[i][j-1]),LCM(A[i+1][j],A[i][j+1]))+1;\n\tfor(int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor(int j=1; j<=n; ++j) printf(\"%lld \",A[i][j]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong gcd(long a, long b) {\n\tfor (; b; swap(a, b))\n\t\ta %= b;\n\treturn a;\n}\nlong lcm(long a, long b) {\n\ta /= gcd(a, b);\n\tif (double(a)*b > 1e15)\n\t\tthrow 0;\n\treturn a * b;\n}\nlong lcm(long a, long b, long c, long d) {\n\treturn lcm(lcm(a, b), lcm(c, d));\n}\nlong a[555][555];\nint main() {\n\tint N;\n\tcin >> N;\n\tint n = 500;\n\tlong x = 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2) continue;\n\t\t\tif (i % 8) {\n\t\t\t\ta[i][j] = a[i - 1][j + 1 - i % 2 * 2] * 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j] = x;\n\t\t\tx += 2;\n\t\t}\n\t}\n\tint s[] = { 0,1,0,-1,0 };\n\tset<long> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) continue;\n\t\t\tlong y[] = { 1,1,1,1 };\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\tif (i + s[k] >= 0 && i + s[k] < n&&j + s[k + 1] >= 0 && j + s[k + 1] < n)\n\t\t\t\t\ty[k] = a[i + s[k]][j + s[k + 1]];\n\t\t\tlong l = lcm(y[0], y[1], y[2], y[3]);\n\t\t\tlong m = 1;\n\t\t\twhile (q.find(m*l + 1) != q.end())\n\t\t\t\tm++;\n\t\t\tq.insert(m*l + 1);\n\t\t\ta[i][j] = m * l + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define ph push\n#define ptc putchar\n#define enter putchar('\\n')\n#define mod 998244353\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long double ldb;\ntypedef long long ll;\ntypedef long long lnt;\ninline int read(){\n\tint x = 0;char c = getchar();\n\twhile (!isdigit(c)) c = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + c - '0' , c = getchar();\n\treturn x;\n}\ninline void write(int x){\n\tif (!x){\n       ptc('0');\n       return;\n\t}\n\tint dg[20] , len = 0;\n\twhile (x) dg[len++] = x % 10 , x /= 10;\n\twhile (len--) ptc(dg[len]+'0');\n}\ninline void writeln(int x){\n\twrite(x);\n\tptc('\\n');\n}\ninline int add(int x,int y){\n\tx += y;if (x >= mod) x -= mod;\n\treturn x;\n}\ninline int sub(int x,int y){\n\tx -= y;if (x < 0) x += mod;\n\treturn x;\n}\ninline int qpow(int x,int y){\n\tint res = 1;\n\twhile (y){\n\t\tif (y & 1) res = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod;y >>= 1;\n\t}\n\treturn res;\n}\nconst int N = 500 + 10;\nconst int dx[] = {0 , 0 , 1 , -1};\nconst int dy[] = {1 , -1 , 0 , 0};\n \nll res[N][N] ;\nint n;\nint pri[N * 4] , pcnt;\n \nvoid getp(){\n\tfor (int i = 2;pcnt <= 1100;i++){\n\t\tfor (int j = 1;j <= pcnt;j++){\n\t\t\tif (i % pri[j] == 0) goto wxh;\n\t\t}\n\t\tpri[++pcnt] = i;\n\t\twxh:;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\t\n    if(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tgetp();\n\tfor (int i = 1;i <= n;i++)\n\tfor (int j = 1;j <= n;j++)\n\tif ( !((i + j) & 1)){\n\t\tres[i][j] = 1ll * pri[(i + j) >> 1] * pri[((i - j) >> 1) + ((n + 1) / 2) + n];\n\t}\n\tfor (int i = 1;i <= n;i++)\n\tfor (int j = 1;j <= n;j++)\n\tif ( ((i + j) & 1)){\n\t\tll d = 1;\n\t\tfor (int o = 0;o < 4;o++){\n\t\n\t\t\tint ni = i + dx[o] , nj = j + dy[o];\n\t\t\tif (ni > n || ni < 1 || nj > n || nj < 1) continue;\n\t\t\td = d / __gcd(d , res[ni][nj]) * res[ni][nj] ;\n\t\t}\n\t\tres[i][j] = d + 1;\n\t}\n\t\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tfor (int j = 1;j <= n;j++){\n\t\t\tprintf(\"%lld \",res[i][j]);\n\t\t}enter;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 750) t++;\n    rep(i, n) p.eb(P[t++]);\n    shuffle(p);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    vll even, odd;\n    rep(i, 125) {\n        even.eb(i * 2 + 2);\n        even.eb(600 - i * 2);\n        odd.eb(i * 2 + 3);\n        odd.eb(601 - i * 2);\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * even[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * even[i / 2 - 1];\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * odd[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * odd[i / 2 - 1];\n        }\n    }\n    INT(N);\n    map<ll, pii> s;\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        rep(j, N) { s[a[i][j]] = {i, j}; }\n        cout << endl;\n    }\n    // cout << (--s.end())->first << endl;\n    // cout << s.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<ll>> a(N, vector<ll>(N));\n\tint tmp = 2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 0) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\ta[i][j] = tmp++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[i][j] = a[i - 1][j - 1] * 2;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 1) {\n\t\t\tll g = 0;\n\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\tint ti = i + dx[d], tj = j + dy[d];\n\t\t\t\tif (0 <= ti && ti < N && 0 <= tj && tj < N) {\n\t\t\t\t\tll aa = g == 0 ? a[ti][tj] : a[ti][tj] / __gcd(a[ti][tj], g) * g;\n\t\t\t\t\tg = aa;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[i][j] = g + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j + 1 == N];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MAX=30000;\nvector<ll> prime;\nbool isprime[MAX];\nvoid sieve(){\n\tfor(ll i=3; i<MAX; i+=2){\n\t\tisprime[i]=1;\n\t}\n\tisprime[2]=1;\n\tprime.push_back(2);\n\tfor(ll i=3; i<MAX; i++){\n\t\tif(isprime[i]){\n\t\t\tprime.push_back(i);\n\t\t\tfor(ll j=2*i; j<MAX; j+=i){\n\t\t\t\tisprime[j]=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tsieve();\n\tll x[1010];\n\tfor(int i=0; i<n; i++){\n\t\tx[i]=prime[i+1];\n\t}\n\tll a[505][505];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif((i+j)%2==0){\n\t\t\t\tif(j<n/2) a[i][j]=x[(n-1+i-j)/2]*x[(i+j)/2];\n\t\t\t\telse a[i][j]=2*x[(n-1+i-j)/2]*x[(i+j)/2];\n\t\t\t}else{\n\t\t\t\tif(j<n/2) a[i][j]=1+2*x[(n-1+i-j-1)/2]*x[(n-1+i-j+1)/2]*x[(i+j-1)/2]*x[(i+j+1)/2];\n\t\t\t\telse a[i][j]=1+4*x[(n-1+i-j-1)/2]*x[(n-1+i-j+1)/2]*x[(i+j-1)/2]*x[(i+j+1)/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcout<<a[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {puts(\"4 7\\n23 10\"); return 0;} \n\tinit(10000);\n\tint ncnt=0;\n\tfor(int i=3;i<=(n<<1);i+=2) if(!val0[i]) val0[i]=prime[ncnt++];\n\tfor(int i=2*n;i>=0;--i) if((i-n)%2==1) val1[i]=prime[ncnt++];\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)&1) {\n\t\tan[i][j]=val0[i+j]*val1[i-j+n];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k],_y=y+dy[k];\n\t\t\tif(_x<1||_x>n||_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t}\n//\tmap<ll,bool> vis;\n//\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {\n//\t\tif(an[i][j]>1e15||an[i][j]<0||vis[an[i][j]]) {\n//\t\t\tdebug(\"%d %d %lld\\n\",i,j,an[i][j]);\n//\t\t\texit(-1);\n//\t\t}\n//\t\tvis[an[i][j]]=1;\n//\t}\n//\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {\n//\t\tif(j<n) if(max(an[i][j],an[i][j+1])%min(an[i][j],an[i][j+1])) return -1;\n//\t\tif(i<n) if(max(an[i][j],an[i+1][j])%min(an[i][j],an[i+1][j])) return -1;\n//\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int ui;\ntypedef unsigned long long ul;\n#define ri register int\n#define vi vector<int>\n#define pb push_back\n#define fi first\n#define se second\n#define mid ((l + r) >> 1)\n#define ls (i << 1)\n#define rs (i << 1 | 1)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\n#define adde(x, y) { e[++z].v = y; e[z].nxt = h[x]; h[x] = &e[z]; }\n#define addrev(u, v) { adde(u, v); adde(v, u); }\n#define ae(x) for(node *p = h[x]; p; p = p->nxt)\n#define FO(x) { freopen(\"#x.in\", \"r\", stdin); freopen(\"#x.out\", \"w\", stdout); }\ninline int read() // ret >= 0\n{\n\tint ret = 0; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\n\t\tch = getchar();\n\tdo {\n\t\tret = ret * 10 + ch - '0';\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9');\n\treturn ret;\n}\ninline void write(int x) // x >= 0\n{\n\tif(x < 10)\n\t{\n\t\tputchar(x + '0');\n\t\treturn ;\n\t}\n\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\n#define maxn 510\nint n;\nint a[maxn][maxn];\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\ta[0][0] = 1e9;\n\tfor(int i = 0; i < n; i ++)\n\t{\n\t\tif(i != 0)\n\t\t\ta[i][0] = a[i - 1][0] + 1;\n\t\tcout << a[i][0] << ' ';\n\t\tfor(int j = 1; j < n; j ++)\n\t\t{\n\t\t\ta[i][j] = a[i][j - 1] + 1;\n\t\t\tcout << a[i][j] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[510][510],c[510][501],ans[510][510],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=zs[(i+j)/2]*zs[n+(i+j)/2+(n+1)/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=505,MAXM=1e4+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,N,cnt,p[MAXM],vis[MAXM],v[MAXN*3];ll ans[MAXN][MAXN];\ninline void pre(int n=1e4){\n\tRep(i,2,n){\n\t\tif(!vis[i])p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}\n}ll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint main(){\n\tpre(),n=read();if(n==2){puts(\"4 7\\n23 10\");return 0;}\n\tRep(i,1,n)Rep(j,1,n)if((i+j)&1){if(!v[i-j+n])v[i-j+n]=p[++N];ans[i][j]=v[i-j+n];}\n\tmemset(v,0,sizeof(v));\n\tRep(i,1,n)Rep(j,1,n)if((i+j)&1){if(!v[i+j])v[i+j]=p[++N];ans[i][j]*=v[i+j];}\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tans[i][j]=1;\n\t\tif(i>1)ans[i][j]=lcm(ans[i][j],ans[i-1][j]);if(j>1)ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n\t\tif(i<n)ans[i][j]=lcm(ans[i][j],ans[i+1][j]);if(j<n)ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n\t}Rep(i,1,n){Rep(j,1,n)cout<<ans[i][j]<<' ';cout<<'\\n';}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nunordered_set<ll> presents;\nll gg1[2 * MAXN], gg2[2 * MAXN];\nll f1[6] = {1, 2, 3, 4, 6, 12}, f2[6] = {12, 6, 4, 3, 2, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn gg1[x];\n\t// return (primes[x] < 4000 ? primes[x] : primes[x] / 2);\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn gg2[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p >= MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\twhile(true)\n\t{\n\t\t// cerr << \"test\\n\";\n\t\tfor (int i = 0; i <= 2 * N; i++)\n\t\t{\n\t\t\tgg1[i] = primes[i / 6 + 3] * f1[i % 6];\n\t\t\tgg2[i] = primes[i / 6 + 3] * f2[i % 6];\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[i][j] = lcm(mind(i - j), plud(i + j));\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j]) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j] + 1) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\t// cerr << \"set\\n\"\n\t\tbreak;\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,ans;\nint ss[100010];bool pri[100010];\nvoid init(){\n\tfor(rt i=2;i<=100000;i++){\n\t\tif(!pri[i])ss[++cnt]=i;\n\t\tfor(rt j=1;j<=cnt&&i*ss[j]<=100000;j++){\n\t\t\tpri[i*ss[j]]=0;\n\t\t\tif(i%ss[j]==0)break;\n\t\t}\n\t}\n}\nll a[505][505];\nll lcm(ll x,ll y){\n\tif(!x)return y;if(!y)return x;\n\treturn x/__gcd(x,y)*y;\n}\nint main(){\n\tn=r;\n\tif(n==2)return printf(\"10 31\\n61 15\"),0;\n\tinit();\n\tfor(rt i=1;i<=n;i++)\n\tfor(rt j=1;j<=n;j++)if(i+j&1^1){\n\t\ta[i][j]=1ll*ss[(i+j)/2]*ss[(i-j)/2+n+n/2+1];\n\t}\n\tfor(rt i=1;i<=n;i++)for(rt j=1;j<=n;j++)if(i+j&1){\n\t\ta[i][j]=lcm(lcm(a[i+1][j],a[i][j+1]),lcm(a[i-1][j],a[i][j-1]))+1;\n\t}\n\tfor(rt i=1;i<=n;i++){\n\t\tfor(rt j=1;j<=n;j++)cout<<a[i][j]<<\" \\n\"[j==n];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=924844033;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcout<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tllint n,i,j;cin>>n;\n\tvector<llint>usa;\n\tusa.reserve(n+n+10);\n\tfor(i=2;;i++){\n\t\tbool ok=1;\n\t\tfor(j=2;j*j<=i;j++){\n\t\t\tif(i%j==0){ok=0;break;}\n\t\t}\n\t\tif(ok){usa.pub(i);if(usa.size()>=n+n+10){break;}}\n\t}\n\tint m=n;\n\tif(n%2==1){m++;}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((i+j)%2==0){//大\n\t\t\t\tllint ans=1;\n\t\t\t\tint x=(i+j)/2;\n\t\t\t\t//xとx+1\n\t\t\t\tans*=usa[x];\n\t\t\t\tans*=usa[x+1];\n\t\t\t\tint y=(i+m-j)/2 +2;\n\t\t\t\tans*=usa[n+5+y];\n\t\t\t\tans*=usa[n+6+y];\n\t\t\t\tcout<<ans+1;\n\t\t\t}else{\n\t\t\t\tllint ans=1;\n\t\t\t\tint x=(i+j)/2;\n\t\t\t\t//xとx+1\n\t\t\t\tans*=usa[x+1];\n\t\t\t\tint y=(i+m-j)/2 +2;\n\t\t\t\tans*=usa[n+6+y];\n\t\t\t\tcout<<ans;\n\t\t\t}\n\t\t\tif(j+1<n){cout<<\" \";}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 7920;\ntypedef long long ll;\ntypedef std::vector<ll> vec;\nstd::set<ll> a0,a1;\nvec x0,x1;\nint ok[maxn],n;\ninline void init(std::set<ll>&s,vec&y){\n\ty.push_back(*s.begin()); s.erase(s.begin());\n\tconst ll lim = 3e7;\n\tfor(;s.size();){\n\t\tauto it = s.upper_bound(lim / *y.rbegin()); --it;\n\t\ty.push_back(*it); s.erase(it);\n\t}\n}\nint main() {\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tfor(int i = 2,c=0;i < maxn;++i)if(!ok[i]){\n\t\t(++c >> 1 & 1 ? a0 : a1).insert(i);\n\t\tfor(int j = i;j < maxn;j += i)ok[j] = 1;\n\t}\n\tinit(a0,x0), init(a1,x1);\n\tstd::cin >> n;\n\tfor(int i = 1;i <= n;++i) for(int j = 1;j <= n;++j) {\n\t\tif(i + j & 1) {\n\t\t\tstd::cout << x0[i + j - 3 >> 1] * x1[i + n - j - 2 >> 1] * x0[i + j - 1 >> 1] * x1[i + n - j >> 1] + 1;\n\t\t} else {\n\t\t\tstd::cout << x0[i + j - 2 >> 1] * x1[i + n - j - 1 >> 1];\n\t\t}\n\t\tstd::cout << \" \\n\"[j == n];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=5e2+5;\nconst int L=3e7;\nint n,pr[L+1], npr[L+1];\nLL a[N][N],b[N][N];\nmap <LL,bool> S;\ninline bool is_pr(int t) {\n\tfor(int i=2;(LL)i*i<=t;++i) if(!(t%i)) return false;\n\treturn true;\n}\ninline int nxt_prime() {\n\tstatic int hd=2;\n\twhile(!is_pr(hd)) ++hd;\n\treturn hd++;\n}\ninline LL lcm(LL x,LL y) {\n\treturn (!x || !y) ? (x+y) : (x/__gcd(x,y)*y);\n}\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) \n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==((n+1)&1)) {\n\t\t\t\tif(i==1 || j==1) a[i][j]=nxt_prime();\n\t\t\t\telse a[i][j]=a[i-1][j-1];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=n;j>=1;j--)\n\t\t\tif(((i+j)&1)==((n+1)&1)) {\n\t\t\t\tif(i==1 || j==n) b[i][j]=nxt_prime();\n\t\t\t\telse b[i][j]=b[i-1][j+1];\n\t\t\t\ta[i][j]*=b[i][j];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) if(!a[i][j]) {\n\t\t\tLL v=lcm(lcm(lcm(a[i-1][j],a[i+1][j]),a[i][j-1]),a[i][j+1]);\n\t\t\tLL nowval=v;\n\t\t\twhile(S[nowval]) nowval+=v;\n\t\t\ta[i][j]=nowval+1;  S[nowval]=1;\n\t\t}\n\tfor(int i=1;i<=n;cout<<'\\n',i++)\n\t\tfor(int j=1;j<=n;cout<<a[i][j++]<<' ');\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001], prm[2003];\nint vis[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,1,(N*N)/2){\n            prime.pb(aa*2);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==1){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==0){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n//                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n                    a[i][j]=lcm(a[i-1][j],a[i+1][j]);\n                    a[i][j]=lcm(a[i][j],a[i][j-1]);\n                    a[i][j]=lcm(a[i][j],a[i][j+1]);\n                    a[i][j]++;\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 2005;\nconst int M = 1e5 + 50;\n\nint n, pri[M], isnt_pri[M], cnt;\nll a[N], b[N], c[N][N];\n\ninline ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\ninline ll lcm(ll x, ll y) { return (x && y) ? (x / gcd(x, y) * y) : (x | y); }\n\ninline void init()\n{\n\tfor (int i = 2; i < M; ++i)\n\t{\n\t\tif (!isnt_pri[i]) pri[++cnt] = i;\n\t\tfor (int j = 1; j <= cnt && i * pri[j] < N; ++j)\n\t\t{\n\t\t\tisnt_pri[i * pri[j]] = true;\n\t\t\tif (i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tinit();\n\tif (n == 2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++i) a[i] = pri[i];\n\tfor (int i = 1; i <= n; ++i) b[i] = pri[2 * n - i + 1];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i ^ j) & 1) c[i][j] = a[(i + j) / 2] * b[(i - j + n + 1) / 2];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!((i ^ j) & 1)) c[i][j] = lcm(lcm(c[i - 1][j], c[i][j - 1]), lcm(c[i + 1][j], c[i][j + 1])) + 1;\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) \n\t{\n\t\tassert(c[i][j] > 0 && c[i][j] <= 1e15);\n\t\tprintf(\"%lld%c\", c[i][j], j == n ? '\\n' : ' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[100005];\nint n,f[100005],nx[100005][2],sum=0;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tf[n+1]=1;nx[n+1][0]=nx[n+1][1]=nx[n+2][0]=nx[n+2][1]=n+2;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum=(sum+(s[i]-'a'+1))%3;\n\t\tnx[i][0]=(s[i]=='a')?i+1:((s[i+1]=='b')?i+2:nx[i+2][0]);\n\t\tnx[i][1]=(s[i]=='b')?i+1:((s[i+1]=='a')?i+2:nx[i+2][1]);\n\t\tf[i]=(f[nx[i][0]]+f[nx[i][1]]+(sum==0))%mod;\n\t}\n\tprintf(\"%d\\n\",(f[1]-(sum==0)+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\t\nusing namespace std;\n\ntypedef double db;\ntypedef long long LL;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 505;\nconst int L = 1e5+5;\n\nint n;\nbool bz[L];\nint pri[L],k;\nint a[N][N];\nset<LL>s;\n\nLL gcd(LL x,LL y){return !y?x:gcd(y,x%y);}\n\nLL lcm(LL x,LL y){\n\treturn x*y/gcd(x,y);\n}\n\nint main(){\n\tn=get();\n\tfo(i,2,1e5)\n\tif(!bz[i]){\n\t\tpri[++k]=i;\n\t\tfo(j,1,1e5/i)bz[i*j]=1;\n\t}\n\tfo(i,1,n)fo(j,1,n)a[i][j]=1;\n\tint w=1;\n\tfo(i,1,n){\n\t\tint st=(i&1)?1:2;\n\t\tfor(int j=st;j<=n;j+=2)a[i][j]=pri[w];\n\t\tw++;\n\t}\n\tfo(j,1,n){\n\t\tint st=(j&1)?1:2;\n\t\tfor(int i=st;i<=n;i+=2)a[i][j]=a[i][j]*pri[w]*2;\n\t\tw++;\n\t}\n\ts.clear();\n\tfo(i,1,n)fo(j,1,n)if((i+j)%2==0)s.insert(a[i][j]);\n\tfo(i,1,n)\n\t\tfo(j,1,n)\n\t\tif ((i+j)%2==1){\n\t\t\tLL v=1;\n\t\t\tif (i>1) v=lcm(v,a[i-1][j]);\n\t\t\tif (i<n)v=lcm(v,a[i+1][j]);\n\t\t\tif (j>1)v=lcm(v,a[i][j-1]);\n\t\t\tif (j<n)v=lcm(v,a[i][j+1]);\n\t\t\tLL now=v;\n\t\t\twhile(s.find(now)!=s.end())now=now+v;\n\t\t\ts.insert(now);\n\t\t\ta[i][j]=now+1;\n\t\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)printf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<unordered_set>\nlong long gcd(long long x,long long y){\n    if(x<y)return gcd(y,x);\n    else if(x%y==0)return y;\n    else return gcd(y,x%y);\n}\nlong long lcm(long long x,long long y){\n    return x/gcd(x,y)*y;\n}\nint divisor(long long n,long long l[]){\n    int k=0;\n    long long m;\n    for(m=1;m*m<n;m++){\n        if(n%m==0){\n            l[k]=m;\n            l[k+1]=n/m;\n            k+=2;\n        }\n    }\n    if(m*m==n){\n        l[k]=m;\n        k++;\n    }\n    return k;\n}\nlong long a[500][500],l[1000];\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    std::unordered_set<long long> s;\n    a[0][0]=2;\n    s.insert(1);\n    for(int k=1;k<=2*n-2;k++){\n        for(int i=0;i<=k;i++){\n            int j=k-i;\n            if(i<n && j<n){\n                long long c,d;\n                if(i==0)c=a[i][j-1];\n                else if(j==0)c=a[i-1][j];\n                else{\n                    c=gcd(a[i][j-1]-1,a[i-1][j]-1);\n                    int r=divisor(c,l);\n                    bool flag=false;\n                    for(int t=0;t<r;t++){\n                        if(s.count(l[t])==0){\n                            a[i][j]=l[t];\n                            s.insert(l[t]);\n                            flag=true;\n                            break;\n                        }\n                    }\n                    if(flag)continue;\n                    c=lcm(a[i][j-1],a[i-1][j]);\n                }\n                d=c+1;\n                while(s.count(d)!=0)d+=c;\n                a[i][j]=d;\n                s.insert(d);\n            }\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            printf(\"%lld \",a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int K = 1e6;\nbool pr[K];\nset<int> m[K];\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    for (int i=2; i < K; i++){\n        if (!pr[i]){\n            for (int j=i+i; j < K; j+=i){\n                pr[j] = true;\n                m[j].insert(i);\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    int a[n][n];\n    for (int i=0; i < n; i++) for (int j=0; j < n; j++) a[i][j] = 0;\n    int u = 125000;\n    for (int i=0; i < n; i+=2){\n        for (int j=0; j < n; j++){\n            if ((i+j)%2!=0) continue;\n            a[i][j] = u;\n            int K = u*2;\n            if (u%2==0) K = u/2;\n            if (i+1 < n && j+1 < n) a[i+1][j+1] = K;\n            u++;\n        }\n    }\n    set<int> used;\n    for (int i=0; i < n; i++){\n        for (int j=0; j < n; j++){\n            if (a[i][j] != 0) continue;\n            vector<int> b;\n            if (i-1 >= 0) b.push_back(a[i-1][j]);\n            if (j+1 < n) b.push_back(a[i][j+1]);\n            if (i+1 < n) b.push_back(a[i+1][j]);\n            if (j-1>=0) b.push_back(a[i][j-1]);\n            set<int> gl;\n            for (int p=0; p < b.size(); p++) {\n                for (set<int>::iterator it = m[b[p]].begin(); it != m[b[p]].end(); it++){\n                    //cout << (*it) << endl;\n                    gl.insert(*it);\n                }\n            }\n            //cout << endl;\n            int R = 1;\n            for (set<int>::iterator it = gl.begin(); it != gl.end(); it++){\n                int num = *it;\n                int kf = 0;\n                for (int p=0; p < b.size(); p++){\n                    int s = 0;\n                    while (b[p] % num == 0){\n                        b[p] /= num;\n                        s++;\n                    }\n                    kf = max(kf, s);\n                }\n                for (int e=0;e<kf;e++) R *= num;\n            }\n            int rr = R+1;\n            while (used.count(rr)) rr += R;\n            R = rr;\n            if (R > 1e15){\n                cout << R/(int)1e15 << endl;\n                return 0;\n            }\n            a[i][j] = R;\n            used.insert(R);\n        }\n    }\n    for (int i=0;i<n;i++){\n        for (int j=0;j<n;j++) cout << a[i][j] << \" \";\n        cout << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/* \n从第左上角第一个点开始染色，相邻不同色，染法唯一\n那么一个点的四周与他不同色，我们另这个点比四周都大，那么这个点权值可以使lcm(四周的点权值)+1\n于是我们就得到了一种构造方案，染色后对一种颜色的点进行赋值，然后另一种颜色的点取lcm\n可是....直接这样瞎构造会爆掉1e15\n对于一种染色点，可以按照i + j和i - j分为两类,每一类乘上一个相同的质数\n对于当前格子的价值就是从左上角到右下角，和从右上角到左下角穿过他的第k素数乘积\n这样构造的lcm最大就是四个素数(prime[n],prime[n - 1],prime[2 * n],prime[2 * n - 1])的乘积\n不会超过1e15 \n*/ \n#include<cstdio> \n#include<cctype> \n#include<cstring> \n#include<algorithm> \n#define gc getchar() \n#define pc putchar\n#define LL long long\ninline int read() { \n\tint x = 0,f = 1; \n\tchar c = getchar(); \n\twhile(c < '0' || c > '9') c = gc; \n\twhile(c <= '9' && c >= '0') x = x * 10 + c - '0',c = getchar(); \n\treturn x * f; \n}\nvoid print(LL x) { \n\tif(x < 0) { \n\t\tpc('-'); \n\t\tx = -x; \n\t} \n\tif(x >= 10) print(x / 10); \n\tpc(x % 10 + '0'); \n} \nconst int maxn = 20007; \nint n; \nint prime[maxn]; \nbool vis[maxn]; \nvoid pre(int lim = 10000) {  \n\tfor(int cnt = 0,i = 2;i <= lim;++ i) { \n\t\tif(!vis[i]) prime[++ cnt] = i; \n\t\tfor(int j = 1;j <= cnt && prime[j] * i <= lim;++ j) { \n\t\t\tvis[i * prime[j]] = 1; \n\t\t\tif(i % prime[j] == 0) break; \n\t\t} \n\t} \n} \nLL a[507][507]; \nLL gcd(LL x,LL y) { \n\treturn y == 0 ? x : gcd(y,x % y); \n} \nLL lcm(LL x,LL y) {\n\treturn x / gcd(x,y) * y; \n} \nint main() { \n\tn = read(); \n\tpre(); \n\tif(n == 2) {\n\t\tpc('4');pc(' ');pc('7');pc('\\n'); \n\t\tprint(23);pc(' '); print(10); pc('\\n');\t\n\t\treturn 0;  \n\t} \n\tfor(int i = 0;i <= n + 1;++ i) \n\t\tfor(int j = 0;j <= n + 1;++ j) \n\t\t\t\ta[i][j] = 1; \n\tfor(int i = 1;i <= n;++ i) \n\t\tfor(int j = 1;j <= n;++ j) { \n\t\t\tif((j & 1) == (i & 1)) { \n\t\t\t\ta[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n]; \t\n\t\t\t\ta[i + 1][j] = lcm(a[i + 1][j],a[i][j]); \n\t\t\t\ta[i - 1][j] = lcm(a[i - 1][j],a[i][j]); \n\t\t\t\ta[i][j + 1] = lcm(a[i][j + 1],a[i][j]); \n\t\t\t\ta[i][j - 1] = lcm(a[i][j - 1],a[i][j]); \n\t\t\t} \n\t\t} \n\tfor(int i = 1;i <= n;++ i) \n\t\tfor(int j = 1;j <= n;++ j) \n\t\t\tif((i & 1) == (j & 1)); \n\t\t\telse a[i][j] ++; \n\tfor(int i = 1;i <= n;++ i,pc('\\n')) \n\t\tfor(int j = 1;j <= n;++ j) \n\t\t\tprint(a[i][j]),pc(' '); \n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nint main(){\n\tint n=read();\n\tREP(i,1,n) REP(j,1,n) printf(\"%d%c\",(((i+j)&1)?2:3),j==jend?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint n;\nint a[1001][1001], b[1001][1001],c[1001][1001],vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= 10000); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> n;\n\tif(n == 2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=prime[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=prime[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=prime[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=prime[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n//\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\ta[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(!a[i][j]) \n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst int SZ=1e6+5,N=505;\n\nint n;\n\nbool bp[SZ];\nLL pn[SZ],lp;\nvoid sieve(){\n    bp[0]=bp[1]=1;\n    FOR(i,2,SZ-1){\n        if(!bp[i])pn[++lp]=i;\n        if(lp>=1000)break;\n        FOR(j,1,lp){\n            int pj=pn[j];\n            if(i*pj>=SZ)break;\n            bp[i*pj]=1;\n            if(i%pj==0)break;\n        }\n    }\n}\nLL gcd(LL a,LL b){return b?gcd(b,a%b):a;}\nLL lcm(LL a,LL b){\n    if(a==0)a=1;\n    if(b==0)b=1;\n    return a/gcd(a,b)*b;}\nLL lcm(LL a,LL b,LL c,LL d){\n    return lcm(lcm(a,b),lcm(c,d));\n}\nLL a[N][N],b[N][N];\n\nint main(){\n    scanf(\"%d\",&n);\n    if(n==2)return puts(\"4 7\\n23 10\"),0;\n    sieve();\n    int pos=0;\n    for(int i=1;i<=n;i+=2)a[i][1]=pn[++pos];\n    for(int i=n&1?1:2;i<=n;i+=2)a[n][i]=pn[++pos];\n    for(int i=1;i<=n;i+=2)b[1][i]=pn[++pos];\n    for(int i=1;i<=n;i+=2)b[i][1]=pn[++pos];\n    ROF(i,n-1,1)FOR(j,2,n)a[i][j]=a[i+1][j-1];\n    FOR(i,2,n)FOR(j,2,n)b[i][j]=b[i-1][j-1];\n    //FOR(i,1,n)FOR(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n    //FOR(i,1,n)FOR(j,1,n)printf(\"%lld%c\",b[i][j],\" \\n\"[j==n]);\n    FOR(i,1,n)FOR(j,1,n)a[i][j]*=b[i][j];\n    FOR(i,1,n)FOR(j,1,n)if(!a[i][j]){\n        a[i][j]=lcm(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n    }\n    FOR(i,1,n)FOR(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\nusing namespace std;\n\n#define NMAX 502\n#define DIM 7920\n\nint d[DIM], p[DIM];\nlong long sol[NMAX][NMAX];\n\nvoid ciur(int n) {\n    for (int i = 2; i <= n; i++) {\n        if (d[i] == 0) {\n            p[++p[0]] = i;\n            for (int j = i + i; j <= n; j += i) {\n                d[j] = 1;\n            }\n        }\n    }\n}\n\n__int128 gcd(__int128 a, __int128 b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n__int128 lcm(vector <long long>& v) {\n    __int128 l = 1;\n    for (const long long x : v) {\n        if (x == 0)\n            continue;\n        __int128 d = gcd(l, (__int128)x);\n        l = l * x / d;\n\n    }\n    return (long long)l;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << \"4 7\\n23 10\\n\";\n        return 0;\n    }\n    ciur(DIM - 1);\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            sol[i][j] = 1;\n        }\n    }\n\n    int cnt = 1;\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col > n)\n                break;\n            sol[i][col] *= p[cnt];\n            col++;\n        }\n        cnt++;\n    }\n\n    for (int i = 3; i <= n; i += 2) {\n        int lin = i;\n        for (int j = 1; j <= n; j++) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col <= 0)\n                break;\n            sol[i][col] *= p[cnt];\n            col--;\n        }\n        cnt++;\n    }\n\n    for (int i = n; i > 1; i -= 2) {\n        int lin = i;\n        for (int j = n; j >= 1; j--) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) % 2 == 0)\n                continue;\n            vector <long long> v = {sol[i - 1][j], sol[i + 1][j], sol[i][j - 1], sol[i][j + 1]};\n            sol[i][j] = lcm(v) + 1;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << sol[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll a[510][510];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nbitset<10101> isp; vector<int> ps;\nvoid init(){\n   rep(i,2,10000)isp[i]=1;\n   rep(i,2,10000)if(isp[i]){\n      ps.push_back(i);\n      for(int j=i*i;j<10000;j+=i)isp[j]=0;\n   }\n}\n\nint main(){\n   int n; cin>>n;\n   if(n==2){\n      cout<<\"4 7\"<<endl;\n      cout<<\"23 10\"<<endl;\n      return 0;\n   }\n   int idx=0;\n   rep(i,0,n)rep(j,0,n)a[i][j]=1;\n   init();\n   for(int d=-n+(n&1);d<n;d+=2){\n      rep(x,0,n)if(x+d>=0 and x+d<n){\n         a[x][x+d]*=ps[idx];\n      } idx++;\n   }\n   for(int d=0;d<=n*2-2;d+=2){\n      rep(x,0,n)if(d-x>=0 and d-x<n){\n         a[x][d-x]*=ps[idx];\n      } idx++;\n   }\n   rep(i,0,n)rep(j,0,n)if((i+j)&1){\n      a[i][j]=1;\n      rep(k,0,4){\n         int tx=i+dx[k],ty=j+dy[k];\n         if(tx<0 or tx>=n or ty<0 or ty>=n)continue;\n         a[i][j]=a[i][j]/gcd(a[i][j],a[tx][ty])*a[tx][ty];\n      } a[i][j]++;\n   }\n   rep(i,0,n){\n      rep(j,0,n)cout<<a[i][j]<<(j==n-1?'\\n':' ');\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<tuple>\n#define rep(index,num) for(int index=0;index<num;index++)\n#define rep1(index,num) for(int index=1;index<=num;index++)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-15\n#define mp(a1,a2) make_pair(a1,a2)\n#define YMAX 250001\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=1e+18+1;\nint INF=1e+9+1;\nll gcd(ll x,ll y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nint main(){\n\tint N;\n\tll a[501][501];\n\tscan(N);\n\tif(N>=5) return 0;\n\tfor(ll mod=1;mod<=1e+3;mod++){\n\t\tll usedmax=0;\n\t\tint flag=1;\n\t\tmap<ll,ll> used;\n\t\trep(j,N){\n\t\t\trep(i,N){\n\t\t\t\tif(j){\n\t\t\t\t\tif(i){\n\t\t\t\t\t\tll bigtonari=max(a[i-1][j],a[i][j-1]);\n\t\t\t\t\t\tll smalltonari=min(a[i-1][j],a[i][j-1]);\n\t\t\t\t\t\tll koubaisu=lcm(a[i-1][j],a[i][j-1]);\n\t\t\t\t\t\tll karia=smalltonari+mod;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(karia>1e+15||karia<=0){\n\t\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//printf(\"j:%d i:%d karia:%lld\\n\",j,i,karia);\n\t\t\t\t\t\t\tif(used[karia]==0){\n\t\t\t\t\t\t\t\tif(karia>bigtonari){\n\t\t\t\t\t\t\t\t\tif(karia%bigtonari==mod&&karia%smalltonari==mod) break;\n\t\t\t\t\t\t\t\t\telse karia=koubaisu+mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tif(bigtonari%karia==mod&&karia%smalltonari==mod) break;\n\t\t\t\t\t\t\t\t\telse karia+=smalltonari;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tif(karia>bigtonari){\n\t\t\t\t\t\t\t\t\tkaria+=koubaisu;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tkaria+=smalltonari;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[i][j]=karia;\n\t\t\t\t\t\tused[a[i][j]]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tll karia=a[i][j-1]+mod;\n\t\t\t\t\t\twhile(used[karia]!=0){\n\t\t\t\t\t\t\tkaria+=a[i][j-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[i][j]=karia;\n\t\t\t\t\t\tused[a[i][j]]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ta[i][j]=mod*(i+1)+1;\n\t\t\t\t\tused[a[i][j]]=1;\n\t\t\t\t}\n\t\t\t\t//printf(\"j:%d i:%d a[i][j]:%lld\\n\",j,i,a[i][j]);\n\t\t\t\tusedmax=max(usedmax,a[i][j]);\n\t\t\t\tif(usedmax>=1e+15||a[i][j]<=0){\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(j==N-1&&i==N-1) flag=-1;\n\t\t\t}\n\t\t\tif(flag==0) break;\n\t\t}\n\t\t//if(mod==1) break;\n\t\tif(flag==-1) break;\n\t}\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tkaigyo;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 2000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint pri[N],p[N],tot;\ninline void sieve(int n)\n{\tfor(rint i=2;i<=n;i++)\n\t{\tif(!pri[i]) p[++tot]=i;\n\t\tfor(rint j=1;j<=tot&&i*p[j]<=n;j++)\n\t\t{\tpri[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll a[666][666]; int mov[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\ninline ll lcm(ll x,ll y)\n{ll g=__gcd(x,y),g1=__gcd(g,x);x/=g1;g/=g1;return x*(y/g);}\nint main()\n{\tint n,cur=1; cin>>n; sieve(1e6);\n\tif(n==2) return !printf(\"4 7\\n23 10\");\n\tfor(rint i=0;i<=n+1;i++)\n\tfor(rint j=0;j<=n+1;j++) a[i][j]=1;\n\tfor(rint i=3;i<=n+n;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i-j&&i-j<=n) a[j][i-j]*=p[cur];\n\tfor(rint i=1;i<=n-1;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=-1;i>=1-n;i-=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=1;i<=n;i++)\n\tfor(rint j=1;j<=n;j++)\n\tif((i+j)%2==0)\n\t{\tfor(rint k=0;k<4;k++) a[i][j]=lcm(a[i][j],a[i+mov[k][0]][j+mov[k][1]]);\n\t\ta[i][j]++;\n\t}\n\tfor(rint i=1;i<=n;i++,cout<<\"\\n\")\n\tfor(rint j=1;j<=n;j++) cout<<a[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int maxn = 250000 + 10;\nconst int maxl = 500 + 10;\ntypedef long long ll;\nbool notprime[maxn];\nll prime[maxn], primecnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxn;i++){\n\t\tif(!notprime[i]) prime[primecnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxn && j < primecnt;j++){\n\t\t\tll t = i * prime[j];\n\t\t\tnotprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\nll a[maxl][maxl];\nvoid solve(int n){\n\tfor(int i = 0;i <= n + 1;i++) for(int j = 0;j <= n + 1;j++) a[i][j] = 1; \n\tint cnt = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 == 1) a[i][j] = prime[cnt++]; \n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\ta[i][j] = a[i][j - 1] * a[i][j + 1] * a[i - 1][j] * a[i + 1][j] + 1;\n\t\t\t\twhile(a[i][j] * a[i][j] <= 1e12) a[i][j] = a[i][j] * a[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tsieve();\n\tint n;\n\tscanf(\"%d\",&n);\n\tsolve(n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%lld%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <set>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 510;\nint n;\n\nll ans[N][N];\n\nset<ll> s;\n\nll gcd(ll x, ll y) {\n\twhile(y) {\n\t\tll t = y;\n\t\ty = x%y;\n\t\tx = t;\n\t}\n\treturn x;\n}\n\nll lcm(ll x, ll y) {\n\treturn x/gcd(x,y)*y;\n}\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\n\tll cur=2;\n\tint i;\n\tfor(i=0; i<n; i+=4) {\n\t\tfor(int j=0; j<n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\n\ti-=2; if(i>=n) i-=4;\n\twhile(i>0) {\n\t\tfor(int j=n-1; j>=0; j--) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t\ti-=4;\n\t}\n\n\tfor(int i=0; i<n; i++) ans[i][n] = 1, ans[n][i] = 1;\n\n\tfor(int i=1; i<n; i+=2) {\n\t\tfor(int j=0; j<=n; j+=2) {\n\t\t\tll temp = lcm(ans[i-1][j], ans[i+1][j]);\n\t\t\tll t = temp+1;\n\t\t\twhile(s.count(t)) t+=temp;\n\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\n\t\tfor(int j=1; j<n; j+=2) {\n\t\t\tll temp = lcm(lcm(ans[i-1][j], ans[i+1][j]), lcm(ans[i][j-1], ans[i][j+1]));\n\t\t\tll t = temp+1;\n\n\t\t\twhile(s.count(t)) t+=temp;\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=0; j<n; j++) printf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1000000007\n#define LINF 1000000000000000007\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll gcd(ll x, ll y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y){\n\treturn (x / gcd(x,y)) * y; //オーバーフローを防ぐ\n}\n\nbool sosuu(int a){\n\tfor(int i = 2; i * i <= a; i++){\n\t\tif(a % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nint n;\nll a[501][501] = {0};\nll so[1001];\n\nint main(){\n\tcin >> n;\n\t\n\tif(n == 2){\n\t\tcout << \"4 7\\n23 10\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tint c = 0;\n\tfor(int i = 2; c < 1001; i++){\n\t\tif(sosuu(i)){\n\t\t\tif(c > 500) so[(c-500)*2-1] = i;\n\t\t\telse so[c*2] = i;\n\t\t\tc++;\n\t\t}\n\t}\n\t\n\tc = 0;\n\tfor(int i = 0; i < n; i+=2){\n\t\tfor(int j = 0; j+i < n; j++){\n\t\t\ta[j][i+j] = so[c];\n\t\t}\n\t\tc++;\n\t}\n\tfor(int i = 2; i < n; i+=2){\n\t\tfor(int j = 0; j+i < n; j++){\n\t\t\ta[i+j][j] = so[c];\n\t\t}\n\t\tc++;\n\t}\n\t\n\tfor(int i = 0; i < n; i+=2){\n\t\tfor(int j = 0; i+j < n; j++){\n\t\t\ta[i+j-(n%2-1)][n-1-j] *= so[c];\n\t\t}\n\t\tc++;\n\t}\n\tfor(int i = 0; i < n; i+=2){\n\t\tfor(int j = 0; i-j >= 0; j++){\n\t\t\ta[i-j][j] *= so[c];\n\t\t}\n\t\tc++;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(a[i][j] == 0){\n\t\t\t\tint dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0};\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(i+dx[k] < n && i+dx[k] >= 0 && j+dy[k] < n && j+dy[k] >= 0){\n\t\t\t\t\t\tif(a[i][j] == 0) a[i][j] = a[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\telse a[i][j] = lcm(a[i][j], a[i+dx[k]][j+dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int inf = 1 << 30;\n\nint n;\nLL a[505][505];\n\nLL gcd(LL a,LL b){\n\treturn !b?a:gcd(b,a%b);\n}\nLL lcm(LL a,LL b){\n\tif(a==0)return b;\n\tif(b==0)return a;\n\treturn a/gcd(a,b)*b;\n}\n\nint notpm[100005],pm[100005],pcnt=0;\nvoid xxs(){\n\tnotpm[1]=1;\n\tfor(int i=2;i<=100000;i++){\n\t\tif(!notpm[i]){\n\t\t\tpm[++pcnt]=i;\n\t\t}\n\t\tfor(int j=1;pm[j]*i<=100000&&j<=pcnt;j++){\n\t\t\tnotpm[i*pm[j]]=1;\n\t\t\tif(i%pm[j]==0)break;\n\t\t}\n\t}\n}\n\nint main(){\n\tLL cnt=0;\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\txxs();\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=(i%2==0)+1;j<=n;j+=2){\n\t\t\ta[i][j]=pm[(i+j)/2];\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=(i%2==0)+1;j<=n;j+=2){\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,n+(j-i+1)/2+2);\n\t\t\ta[i][j]*=pm[n+(j-i+((j-i)%2==0?0:1))/2+2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!a[i][j]){\n\t\t\t\ta[i][j]=lcm(lcm(lcm(a[i-1][j],a[i][j-1]),a[i][j+1]),a[i+1][j])+1;\n\t\t\t}\n\t\t}\n\t}\n\tLL mx=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n//\t\t\tif(a[i][j]==9223216780099161841){\n//\t\t\t\tprintf(\"%d %d %lld %lld %lld %lld\\n\",i,j,a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]);\n//\t\t\t}\n//\t\t\tmx=max(mx,a[i][j]);\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n//\tprintf(\"%lld\\n\",mx);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nvector<ll> primes;\nvoid gen_primes(){\n    primes.push_back(2);\n    while((int) primes.size() < 2 * N){\n        ll cur = primes.back() + 1;\n        while(true){\n            bool ok = false;\n            for(ll p: primes){\n                if(cur % p == 0){\n                    ok = true;\n                    break;\n                }\n            }\n            if(!ok){\n                primes.push_back(cur);\n                break;\n            }\n            cur++;\n        }\n    }\n}\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    gen_primes();\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            int diag1 = (i + j) / 2, diag2 = (i - j) / 2 + N + N / 2;\n            a[i][j] = primes[diag1] * primes[diag2];\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            a[i][j] = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    a[i][j] = LCM(a[i][j], a[ni][nj]);\n                }\n            }\n            a[i][j]++;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=510;\nint n,prm[N*2];\nll a[N][N];\n\nstruct node\n{\n\tint dat,prm;\n}b[N*2];\n\nbool cmp(node x,node y)\n{\n\treturn x.dat<y.dat;\n}\n\nvoid findprm(int k)\n{\n\tfor (int i=2,m=0;m<k;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor (int j=2;j*j<=i;j++)\n\t\t\tif (i%j==0) flag=0;\n\t\tif (flag) prm[++m]=i;\n\t}\n}\n\nll query(int x,int y,int opt)\n{\n\tif (opt==1) return b[(x+y)/2].prm;\n\t\telse return b[(n+x-y+1)/2+n].prm;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif (n==2) return !printf(\"4 7\\n23 10\");\n\tfindprm(2*n);\n\tfor (int i=1;i<=2*n;i++)\n\t{\n\t\tif (i<=n) b[i].dat=i*2-1;\n\t\t\telse b[i].dat=(2*n-i)*2;\n\t\tb[i].prm=prm[i];\n\t}\n\tsort(b+1,b+1+2*n,cmp);\n\tfor (int i=1;i<=n;i++,putchar(10))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)&1)\n\t\t\t\tprintf(\"%lld \",query(i,j,1)*query(i,j,2));\n\t\t\telse \t\n\t\t\t{\n\t\t\t\tif (1<i && i<n)\n\t\t\t\t\tprintf(\"%lld \",query(i-1,j,1)*query(i-1,j,2)*query(i+1,j,1)*query(i+1,j,2)+1);\n\t\t\t\telse if (1<j && j<n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i,j+1,1)*query(i,j+1,2)+1);\n\t\t\t\telse if (i==1 && j==1)\n\t\t\t\t\tprintf(\"%lld \",query(i,j+1,1)*query(i,j+1,2)*query(i+1,j,2)+1);\n\t\t\t\telse if (i==1 && j==n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i+1,j,1)+1);\n\t\t\t\telse if (i==n && j==1)\n\t\t\t\t\tprintf(\"%lld \",query(i,j+1,1)*query(i,j+1,2)*query(i-1,j,1)+1);\n\t\t\t\telse if (i==n && j==n)\n\t\t\t\t\tprintf(\"%lld \",query(i,j-1,1)*query(i,j-1,2)*query(i-1,j,2)+1);\n\t\t\t\telse puts(\"WYC AK IOI!!!!!\");\n\t\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n\n    if(n == 2) {\n        cout << \"4 7\\n23 10\\n\";\n        return 0;\n    }\n\n    vector<ll> prime;\n    for(ll i=2; prime.size()<2*n;++i) {\n        bool flag = true;\n        for(ll j=2; j*j<=i; ++j) {\n            if(i%j==0) flag = false;\n        }\n        if(flag) prime.push_back(i);\n    }\n\n    // cout << prime << endl;\n\n    bool turn = true;\n    ll idx1 = 0, idx2 = 2*n-1;\n    vector<vector<ll>> a(n, vector<ll>(n));\n    for(ll sx=1; sx<n; sx+=2) {\n        for(ll x=sx,y=0; x>=0&&y<n; x--,y++) {\n            if(turn) a[y][x] = prime[idx1];\n            else a[y][x] = prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n        turn = !turn;\n    }\n    for(ll sy=1+!(n%2); sy<n; sy+=2) {\n        for(ll x=n-1,y=sy; x>=0&&y<n; x--,y++) {\n            if(turn) a[y][x] = prime[idx1];\n            else a[y][x] = prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n        turn = !turn;\n    }\n    // REP(i, n) cout << a[i] << endl;\n\n    for(ll sx=n-1-n%2; sx>=0; sx-=2) {\n        for(ll x=sx,y=0; x<n&&y<n; x++,y++) {\n            if(turn) a[y][x] *= prime[idx1];\n            else a[y][x] *= prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n        turn = !turn;\n    }\n    for(ll sy=1; sy<n; sy+=2) {\n        for(ll x=0,y=sy; x<n&&y<n; x++,y++) {\n            if(turn) a[y][x] *= prime[idx1];\n            else a[y][x] *= prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n        turn = !turn;\n    }\n\n    // REP(i, n) cout << a[i] << endl;\n\n    REP(i, n) REP(j, n) {\n        if(a[i][j]) continue;\n        ll t = 1;\n        REP(k, 4) {\n            ll nx = j + dx[k], ny = i + dy[k];\n            if(!IN(0LL,n,nx) || !IN(0LL,n,ny)) continue;\n            t = t / __gcd(t, a[ny][nx]) * a[ny][nx];\n        }\n        a[i][j] = t + 1;\n    }\n\n\n    REP(i, n) REP(j, n) {\n        assert(a[i][j]<=1e15);\n        cout << a[i][j] << (j==n-1?'\\n':' ');\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1010;\ntypedef long long ll;\nint p[N],n,cnt,x[N],cmt,Y[N],*y=Y+N/2;\nll b[N][N];\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=2;cnt<2*n+2;++i){\n\t\tint flag=1;\n\t\tfor(int j=1;j<=cnt;++j)\n\t\t\tif(i%p[j]==0){flag=0;break;}\n\t\tif(flag)p[++cnt]=i;\n\t}\n\tfor(int i=1,j=n+1;i<=j;){\n\t\tx[cmt]=p[j--],cmt+=2;\n\t\tif(i<=j)x[cmt]=p[i++],cmt+=2;\n\t}\n\tcmt=-(n/2*2);\n\tfor(int i=n+2,j=cnt;i<=j;){\n\t\ty[cmt]=p[j--],cmt+=2;\n\t\tif(i<=j)y[cmt]=p[i++],cmt+=2;\n\t}\n\tfor(int i=1;i<=n;i+=2)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(j&1)b[i][j]=x[i+j]*y[i-j],b[i+1][j]=(ll)x[i+j]*y[i-j]*x[i+j+2]*y[i+2-j]+1;\n\t\t\telse b[i+1][j]=x[i+j+1]*y[i+1-j],b[i][j]=(ll)x[i+j+1]*y[i+1-j]*x[i+j-1]*y[i-j-1]+1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)cout<<b[i][j]<<\" \\n\"[j==n],assert(b[i][j]<=1e15);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    //int_fast64_t mn, mx;\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n        //size_t j(i & 1 ? i / 2 : 999 - i / 2);\n        //return j < 250 ? j : j >= 750 ? j : 999 - j;\n    }\n    constexpr Ans() : ans()/*, mn(numeric_limits<int_fast64_t>::max()), mx(0)*/{\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                //mn = min(mn, ans[i][j]);\n                //mx = max(mx, ans[i][j]);\n                if(i < 500 && j < 500){\n                    ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n                    //mn = min(mn, ans[i + 1][j + 1]);\n                    //mx = max(mx, ans[i + 1][j + 1]);\n                }\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE=1<<17, INT_LEN=24, FLT_LEN=400;\n    static constexpr char FLT_FMT[]=\"%.16f\";\n    static char buf[BUF_SIZE|1]={}, *pos=buf, *endbuf=pos+BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos-buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len=std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len=std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template <class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    inline void print(const double out) {\n        char minibuf[FLT_LEN];\n        size_t len=std::snprintf(minibuf, FLT_LEN, FLT_FMT, out);\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minibuf, len);\n        pos += len;\n    }\n\n    inline void print(const bool out) {\n        print(out? \"true\":\"false\");\n    }\n\n    template <class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos=minibuf+INT_LEN;\n        /*if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void)(print(\"128\"));\n                    case 2:\n                        return (void)(print(\"32768\"));\n                    case 3:\n                        return (void)(print(\"8388608\"));\n                    case 4:\n                        return (void)(print(\"2147483648\"));\n                    case 8:\n                        return (void)(print(\"9223372036854775808\"));\n                    case 16:\n                        return (void)(print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }*/\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_=out;\n        do {\n            *--minipos = '0' + out_%10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len=(minibuf+INT_LEN)-minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout=stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template <class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template <class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template <class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\t/*random_shuffle(vec1.begin(), vec1.end());\n\trandom_shuffle(vec2.begin(), vec2.end());*/\n\n\tqueue<pair<ll, ll>> q;\n\tq.push({ 0, 0 });\n\n\tused[0][0] = 1;\n\tvector<pair<ll, ll>> dir1 = { {2, 0}, {0, 2} };\n\twhile (!q.empty()) {\n\t\tpair<ll, ll> v = q.front();\n\t\tq.pop();\n\n\t\tans[v.first][v.second] = vec1.front();\n\t\tvec1.pop_front();\n\n\t\tfor (auto cur : dir1) {\n\t\t\tif (!used[v.first + cur.first][v.second + cur.second] && v.first + cur.first < n && v.second + cur.second < n) {\n\t\t\t\tq.push({v.first + cur.first, v.second + cur.second});\n\t\t\t\tused[v.first + cur.first][v.second + cur.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 520\n#define maxm 20020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nint prime[maxm],cnt,tag[maxm];\nint n,tag1[maxn][maxn],tag2[maxn][maxn],tot;\nll a[maxn][maxn];\n\nvoid init(){\n\trep(i,2,10000){\n\t\tif ( !tag[i] ) prime[++cnt] = i;\n\t\trep(j,1,cnt){\n\t\t\tif ( prime[j] * i > 10000 ) break;\n\t\t\ttag[prime[j] * i] = 1;\n\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\tif ( !b ) return a;\n\treturn gcd(b,a % b);\n}\ninline ll lcm(ll a,ll b){\n\tll d = gcd(a,b);\n\treturn a * b / d;\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1 ) ){\n\t\t\t\tif ( i > 1 && j > 1 && tag1[i - 1][j - 1] ) tag1[i][j] = tag1[i - 1][j - 1];\n\t\t\t\tif ( i < n && j < n && tag1[i + 1][j + 1] ) tag1[i][j] = tag1[i + 1][j + 1];\n\t\t\t\tif ( !tag1[i][j] ) tag1[i][j] = ++tot; \n\t\t\t\tif ( i > 1 && j < n && tag2[i - 1][j + 1] ) tag2[i][j] = tag2[i - 1][j + 1];\n\t\t\t\tif ( i < n && j > 1 && tag2[i + 1][j - 1] ) tag2[i][j] = tag2[i + 1][j - 1];\n\t\t\t\tif ( !tag2[i][j] ) tag2[i][j] = ++tot;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1) ){\n\t\t\t\ta[i][j] = prime[tag1[i][j]] * prime[tag2[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tll cur = 1;\n\t\t\t\tif ( i > 1 ) cur = lcm(cur,a[i - 1][j]);\n\t\t\t\tif ( i < n ) cur = lcm(cur,a[i + 1][j]);\n\t\t\t\tif ( j > 1 ) cur = lcm(cur,a[i][j - 1]);\n\t\t\t\tif ( j < n ) cur = lcm(cur,a[i][j + 1]);\n\t\t\t\ta[i][j] = cur + 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tcout<<a[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\ntypedef long long ll;\n\nconst int MN = 505;\n\nll pr[MN << 1];\n\nint n; bool b[MN * MN];\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\n\tstd::cin >> n;\n\n\tpr[0] = 1;\n\tfor (R int i = 2, p = 0; p <= (n << 1); ++i)\n\t\tif (!b[i]) {\n\t\t\tpr[++p] = i;\n\t\t\tfor (R int j = i << 1; j <= 1e4; j += i)\n\t\t\t\tb[j] = 1;\n\t\t}\n\n\tfor (R int i = 1; i <= n; std::cout << std::endl, ++i)\n\t\tfor (R int j = 1; j <= n; ++j)\n\t\t\tif ((i + j) & 1)\n\t\t\t\tstd::cout << pr[i + j - 1 >> 1] * pr[i + j + 1 >> 1] * pr[i - j + 3 * n + 1 >> 1] * pr[i - j + 3 * n - 1 >> 1] + 1 << \" \";\n\t\t\telse std::cout << pr[i + j >> 1] * pr[i - j + 3 * n >> 1] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n\n#define int long long \n\nconst int LIM = 2e6 + 7;\nconst int N = 500;\n\nint pr[LIM];\nvector<int> primes;\n\nint lcm(int a, int b) {\n    #ifdef LOCAL\n    return a / (gcd(a, b)) * b;\n    #else\n    return a / (__gcd(a, b)) * b;\n    #endif\n}\n\nvoid init() {\n    fill(pr, pr + LIM, 1);\n    for (int i = 2; i < LIM; i++) {\n        if (pr[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < LIM; j += i) {\n                pr[j] = 0;\n            }\n        }\n    }\n}\n\nint ans[N][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ans[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) & 1) {\n                ans[i][j] *= primes[(i + j) / 2];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i - j) % 2 != 0) {\n                ans[i][j] *= primes[(i - j) + 2 * N];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                if (i > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n                }\n                if (j > 0) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n                }\n                if (i + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n                }\n                if (j + 1 < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n                }\n                ans[i][j]++;\n                // cerr << ans[i][j] << '\\n';\n            }\n        }\n    }\n    {\n        set<int> s;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                s.insert(ans[i][j]);\n            }\n        }\n        assert(s.size() == N * N);\n        // cerr << *s.rbegin() << endl;\n        assert(*s.rbegin() <= 1e15);\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n#define int long long\nconst int N = (int) 505, mod = (int) 0;\nint res[N][N];\nmap<int, int> mark;\nint lcm(int x, int y) { return x / __gcd(x, y) * y; }\nint32_t main() {\n\tint n;\n\tcin >> n;\n\tint cnt = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tif ((i + j) & 1)\n\t\t\t\tres[i][j] = cnt * 2, cnt++;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (~(i + j) & 1) {\n\t\t\t\tint all = 1;\n\t\t\t\tif (i)\n\t\t\t\t\tall = lcm(res[i - 1][j], all);\n\t\t\t\tif (j)\n\t\t\t\t\tall = lcm(res[i][j - 1], all);\n\t\t\t\tif (i + 1 < n)\n\t\t\t\t\tall = lcm(res[i + 1][j], all);\n\t\t\t\tif (j + 1 < n)\n\t\t\t\t\tall = lcm(res[i][j + 1], all);\n\t\t\t\tint step = all;\n\t\t\t\twhile (mark[all + 1]) all += step;\n\t\t\t\tmark[all + 1] = 1;\n\t\t\t\tres[i][j] = all + 1;\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcout << res[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n#include <stack>\nusing namespace std;\n \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define ktya(x) sort(all(x))\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 1e18\n#define INFLL 1000000000000000007LL\n#define SIZE 200105\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define PI (acos(-1))\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n//ll MOD = 1000000007;\nll MOD=998244353;\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\nint H,W,N;\nll ans[505][505];\nvector<ll> primes;\nll lgcd(ll p, ll q){\n\tif(p<q)swap(p,q);\n\tif(q==0)return p;\n\treturn lgcd(q,p%q);\n\t\n}\nll llcm(ll a, ll b){\n\tll g=lgcd(a,b);\n\treturn a/g * b;\n\t\n}\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,505)rep(j,505)ans[i][j]=1;\n\tfor(int i=2;i<=100000;i++){\n\t\tbool flag=true;\n\t\tfor(int j=0;j<primes.size()&&primes[j]*primes[j]<=i;j++){\n\t\t\tif(i%primes[j]==0)flag=false;\n\t\t}\n\t\tif(flag)primes.pb(i);\n\t}\n\t\n\trep(i,N)rep(j,N){\n\t\t\n\t\tif((i+j)%2==0){\n\t\t\tans[i+1][j+1]=primes[(i+j)/2]*primes[(i-j)/2+N+(N-1)/2];\n\t\t\t\n\t\t}\n\t\t\n\t}\n\trep(i,N)rep(j,N){\n\t\tif((i+j)%2==1){\n\t\t\tll g1=llcm(ans[i][j+1],ans[i+2][j+1]);\n\t\t\tll g2=llcm(ans[i+1][j],ans[i+1][j+2]);\n\t\t\t\n\t\t\tans[i+1][j+1]=llcm(g1,g2)+1;\n\t\t}\n\t}\n\tif(N==2)ans[2][1]+=30;\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tcout<<ans[i+1][j+1]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define ll long long\nusing namespace std;\nbool mx[1003][1003], flag[10004];\nll a[1003], b[1003], ans[1003][1003];\nll prime[10004];\nll gcd(ll x, ll y){\n\tif (y == 0)\n\t\treturn x;\n\treturn gcd(y, x % y);\n}\nll lcm(ll x, ll y){\n\tif (x == 0 || y == 0)\n\t\treturn x + y;\n\treturn x / gcd(x, y) * y;\n}\nint main(){\n\tint prime_cnt = 0;\n\tfor (int i = 2; i <= 10000; ++ i){\n\t\tif (! flag[i])\n\t\t\tprime[++ prime_cnt] = i;\n\t\tfor (int j = 2; i * j <= 10000; ++ j){\n\t\t\tflag[i * j] = true;\n\t\t\tif (i % j == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tif (n == 2){\n\t\tcout << \"4 7\" << endl << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tif (i % 2 == j % 2)\n\t\t\t\tmx[i][j] = true;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tif (! mx[i][j]){\n\t\t\t\tif (! a[i + j])\n\t\t\t\t\ta[i + j] = prime[++ cnt];\n\t\t\t\tif (! b[i - j + n])\n\t\t\t\t\tb[i - j + n] = prime[++ cnt];\n\t\t\t\tans[i][j] = a[i + j] * b[i - j + n];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tif (mx[i][j])\n\t\t\t\tans[i][j] = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1])) + 1;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tcout << ans[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N_MAX 500\n#define M_MAX 2000000\ntypedef long long lnt;\ninline lnt gcd(lnt a, lnt b)\n{\n\tif (!b)\n\t\treturn a;\n\tfor (register lnt r = a % b; r; r = a % b)\n\t\ta = b, b = r;\n\treturn b;\n}\ninline lnt lcm(lnt a, lnt b)\n{\n\treturn a / gcd(a, b) * b;\n}\nconst int dx[4] = {-1, 0, +1, 0}, dy[4] = {0, -1, 0, +1};\nint n, m, i, j, k, pn, p[M_MAX];\nbool np[M_MAX + 1];\nlnt a[N_MAX][N_MAX];\ninline bool chk(int i) { return i >= 0 && i < n; }\nint main()\n{\n\tm = M_MAX;\n\tfor (i = 2; i <= m; ++i)\n\t{\n\t\tif (!np[i])\n\t\t\tp[pn++] = i;\n\t\tfor (k = 0; (j = i * p[k]) <= m; ++k)\n\t\t{\n\t\t\tnp[j] = true;\n\t\t\tif (i % p[k] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tif (n == 2)\n\t\tputs(\"4 7\\n23 10\");\n\telse\n\t{\n\t\tk = 0;\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = i & 1; j < n; j += 2)\n\t\t\t\ta[i][j] = p[k++];\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = (i & 1) ^ 1; j < n; j += 2)\n\t\t\t{\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor (k = 0; k < 4; ++k)\n\t\t\t\t\tif (chk(i + dx[k]) && chk(j + dy[k]))\n\t\t\t\t\t\ta[i][j] *= a[i + dx[k]][j + dy[k]];\n\t\t\t}\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%lld%c\", a[i][j] * 2 + ((i ^ j) & 1), j < n - 1 ? ' ' : '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 510;\nint n,tot=1;\nll a[N][N];\nconst int dx[]={0,0,1,-1};\nconst int dy[]={-1,1,0,0};\nll _lcm(ll x, ll y) {\n\tif (!y) return x;\n\treturn x/gcd(x,y)*y;\n}\n\nint main() {\n\tcin>>n;\n\tREP(i,1,N-1) REP(j,1,N-1) if (i+j&1) a[i][j]=++tot;\n\tREP(i,1,n) REP(j,1,n) if (!a[i][j]) {\n\t\tint x = 1;\n\t\tREP(d,0,3) {\n\t\t\tint ii=i+dx[d],jj=j+dy[d];\n\t\t\tx = _lcm(x,a[ii][jj]);\n\t\t}\n\t\ta[i][j] = x+1;\n\t}\n\tREP(i,1,n) {\n\t\tREP(j,1,n) cout<<a[i][j]<<' ';hr;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nvector<ll> primes;\nvoid gen_primes(){\n    primes.push_back(2);\n    while((int) primes.size() < 2 * N){\n        ll cur = primes.back() + 1;\n        while(true){\n            bool ok = false;\n            for(ll p: primes){\n                if(cur % p == 0){\n                    ok = true;\n                    break;\n                }\n            }\n            if(!ok){\n                primes.push_back(cur);\n                break;\n            }\n            cur++;\n        }\n    }\n}\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    gen_primes();\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            int diag1 = (i + j) / 2, diag2 = (i - j) / 2 + N;\n            a[i][j] = primes[diag1] * primes[diag2];\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            a[i][j] = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    a[i][j] *= a[ni][nj];\n                }\n            }\n            a[i][j]++;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    cout << '\\n';\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = 1ll * pri[(i + j) / 2] * i;\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << x << std::endl\nusing ll = long long;\nconstexpr int N = 50;\nconstexpr int MAX = 16 * N;\nconstexpr int NUM = 2 * N - 1;\nbool isprime[16 * N];\nll p1[N][N], p2[N][N], ans[N][N];\nstd::mt19937 mt{std::random_device{}()};\nint main()\n{\n    std::fill(isprime, isprime + MAX, true);\n    std::vector<ll> prime;\n    for (int i = 2; i < MAX; i++) {\n        if (not isprime[i]) { continue; }\n        prime.push_back(i);\n        if (prime.size() == NUM) { break; }\n        for (int j = 2; i * j < MAX; j++) { isprime[i * j] = false; }\n    }\n    for (int i = 0; i < 2 * N; i += 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = i - y;\n            if (x < 0 or N <= x) { continue; }\n            p1[y][x] = prime[i / 2];\n        }\n    }\n    std::shuffle(prime.begin(), prime.end(), mt);\n    for (int i = N - 2; i >= -N + 2; i -= 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = y + i;\n            if (x < 0 or N <= x) { continue; }\n            p2[y][x] = prime[(i + N - 2) / 2 + N];\n        }\n    }\n\n    auto get = [&](const int y, const int x) { return y >= 0 and y < N and x >= 0 and x < N ? std::pair<ll, ll>{p1[y][x], p2[y][x]} : std::pair<ll, ll>{1LL, 1LL}; };\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i % 2 == j % 2) {\n                ans[i][j] = p1[i][j] * p2[i][j];\n            } else {\n                std::set<ll> p;\n                p.insert({get(i - 1, j).first,\n                          get(i - 1, j).second,\n                          get(i + 1, j).first,\n                          get(i + 1, j).second,\n                          get(i, j - 1).first,\n                          get(i, j - 1).second,\n                          get(i, j + 1).first,\n                          get(i, j + 1).second});\n                ans[i][j] = 1;\n                for (const ll P : p) { ans[i][j] *= P; }\n                ans[i][j]++;\n            }\n        }\n    }\n    int N;\n    std::cin >> N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            std::cout << ans[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tfor(ll i=0;i<=n+1;i++)for(ll j=0;j<=n+1;j++)a[i][j]=1;\n\tfor(ll st=1;st<=n;st+=4){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=5;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=1;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=5;st<=n;st+=4){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\tfor(ll j=1;j<=n;j++)\n\tif((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(int x){\n\tif(x <= 1) return false;\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 500;\nlong long r[maxn][maxn], p[2][4 * maxn];\nlong long gcd(long long a, long long b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nint main(){\n\tvector<int> primes;\n\tfor(int i = 1; primes.size() < 2000; i++) if(is_prime(i)) primes.push_back(i);\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) r[i][j] = 1;\n\tint stk = 0;\n\tfor(int i = 0; i < maxn + maxn; i += 2){\n\t\tp[0][i] = stk++;\n\t}\n\tfor(int i = maxn + maxn - 2; i >= 0; i -= 2){\n\t\tp[1][i] = stk++;\n\t}\t\n\tassert(stk <= primes.size());\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) {\n\t\tint x = i - j + maxn;\n\t\tint y = i + j;\n\t\tif(x % 2 == 0){\n\t\t\tr[i][j] *= primes[p[0][x]] * primes[p[1][y]];\n\t\t}\n\t}\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++){\n\t\tint x = i - j + maxn;\n\t\tif(x % 2 == 1){\n\t\t\tvector<long long> cand;\n\t\t\tif(i) cand.push_back(r[i - 1][j]);\n\t\t\tif(j) cand.push_back(r[i][j - 1]);\n\t\t\tif(i + 1 < maxn) cand.push_back(r[i + 1][j]);\n\t\t\tif(j + 1 < maxn) cand.push_back(r[i][j + 1]);\n\t\t\tlong long lc = cand[0] / gcd(cand[0], cand[1]) * cand[1];\n\t\t\tfor(int j = 2; j < cand.size(); j++) lc = lc / gcd(lc, cand[j]) * cand[j];\n\t\t\tr[i][j] = lc + 1;\n\t\t}\n\t}\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[i][j], mx = r[i][j + 1];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 1);\n\t\t}\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[j][i], mx = r[j + 1][i];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tcout << r[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll a[510][510];\n\nconst int dx[4] = {-1,1,0,0};\nconst int dy[4] = {0,0,-1,1};\n\nint main() {\n\tint N; cin >> N;\n\tif (N == 2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\n\tvector<ll> vec;\n\tconst int MX = 100000;\n\tvector<int> pr(MX);\n\n\tfor (int i = 2; i < MX && vec.size() <= N * 3; ++i) {\n\t\tif (!pr[i]) {\n\t\t\tvec.pb(i);\n\t\t\tfor (int j = i * 2; j < MX; j += i) {\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif ((i + j) & 1) continue;\n\t\t\ta[i][j] = vec[(i+j)/2] * vec[(i-j+N)/2+N];\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tll t = 1;\n\t\t\t\trep(dir, 4) {\n\t\t\t\t\tint ni = i + dx[dir], nj = j + dy[dir];\n\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < N && nj < N) {\n\t\t\t\t\t\tll d = __gcd(t, a[ni][nj]);\n\t\t\t\t\t\tt = t / d * a[ni][nj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j] = t + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tcout << a[i][j] << (j == N-1 ? '\\n' : ' ');\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=500+5;\nint n;\nLL a[maxn][maxn];\nbool isp[100005];\nvector<int>prime;\nvoid sieve(int ps){\n\tmemset(isp,1,sizeof(isp));isp[1]=0;\n\tfor(int i=2;prime.size()<=ps;i++){\n\t\tif(isp[i])prime.push_back(i);\n\t\tfor(int k=0;k<prime.size()&&i*prime[k]<=100000;k++){\n\t\t\tisp[i*prime[k]]=0;\n\t\t\tif(i%prime[k]==0)break;\n\t\t}\n\t}\n}\nLL lcm(LL x,LL y){return x/__gcd(x,y)*y;}\nint main(){\n\tsieve(1000);\n\tscanf(\"%d\",&n);\n\tif(n==2){printf(\"4 7\\n23 10\\n\");return 0;}\n\tint nxt=n+(n-1)/2;\n\tfor(int i=1;i<=n;i++)\n\ta[0][i]=a[i][0]=a[n+1][i]=a[i][n+1]=1;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1+!(i&1);j<=n;j+=2)\n\ta[i][j]=prime[(i+j)/2-1]*prime[(i-j)/2+nxt];\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1+(i&1);j<=n;j+=2)\n\ta[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nlong long LCM(long long a , long long b){return (__int128)a * b / __gcd(a , b);}\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1){\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = LCM(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n              \t++arr[i][j]; assert(arr[i][j] <= 1e15);\n            }\n\tcin >> N;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= N ; ++j) cout << arr[i][j] << \" \\n\"[j == N];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// AT027D: Modular Matrix\n\nint main(){\n    int n; cin >> n;\n    int N = 500;\n    int M = 100*N;\n\n    bool prime[M];\n    for(int i = 1; i < M; i++) prime[i] = true;\n    for(int i = 2; i < M; i++) if(prime[i])\n        for(int j = i + i; j < M; j += i) \n            prime[j] = false;\n\n    vector<int> p;\n    for(int i = 2; i < M; i++) if(prime[i]) p.push_back(i);\n\n    vector<long long> a(N+1), b(N+1);\n    for(int i = 0; i <= N; i += 2) {\n        a[i] = p[i/2];\n        b[i] = p[N + i/2];\n    }\n    for(int i = 1; i < N; i += 2) {\n        a[i] = a[i-1] * a[i+1];\n        b[i] = b[i-1] * b[i+1];\n    }\n    for(int i = 0; i < n; i++) {\n    \tfor(int j = 0; j < n; j++) cout << a[i] * b[j] << \" \";\n    \tcout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-11 10:55:56\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=1000010,M=510;\nint n,v[N],p[N],c;\ni64 ans[M][M];\ni64 gcd(i64 a,i64 b){ return b?gcd(b,a%b):a; }\ni64 lcm(i64 a,i64 b){ return a*b/gcd(a,b); }\nint main()\n{\n\tn=1000000;\n\tfr(i,2,n)\n\t{\n\t\tif(!v[i]) p[++c]=i;\n\t\tfr(j,1,c)\n\t\t\tif(i*p[j]<=n)\n\t\t\t{\n\t\t\t\tv[i*p[j]]=1;\n\t\t\t\tif(i%p[j]==0) break;\n\t\t\t}\n\t\t\telse break;\n\t}\n\tn=read()+2;\n\tfr(i,0,n+1) fr(j,0,n+1) ans[i][j]=1; \n\tfr(i,1,n) fr(j,1,n) if((i+j)%2==0) ans[i][j]=p[(i+j)/2]*p[(i-j)/2+2*n];\n\tfr(i,1,n) fr(j,1,n) if((i+j)%2==1) ans[i][j]=lcm(ans[i-1][j],lcm(ans[i+1][j],lcm(ans[i][j-1],ans[i][j+1])))+1;\n\tfr(i,2,n-1) fr(j,2,n-1) printf(\"%lld%c\",ans[i][j],j==n-1?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(int n){\n\tif(n == 2 || n == 3) return true; \n\tif(n % 6 != 1 && n % 6 != 5) return false; \n\tfor(int i = 2; i * i <= n; i++){\n\t\tif(n % i == 0) return false; \n\t}\n\treturn true; \n}\nint main(){\n\tvector<int> P;\n\tfor(int i = 3; i < 10000; i+=2){\n\t\tif(is_prime(i)) P.push_back(i); \n\t}\n\tlong long A[1010][1010] = {}; \n\tfor(int i = 0; i <= 500; i++){\n\t\tfor(int j = 0; j <= 500; j++){\n\t\t\tA[i*2][j*2] = P[i] * P[501+j]; \n\t\t}\n\t}\n\tfor(int i = 0; i <= 499; i++){\n\t\tfor(int j = 0; j <= 499; j++){\n\t\t\tA[i*2+1][j*2+1] = A[i*2][j*2] * A[i*2+2][j*2+2] + 1; \n\t\t}\n\t}\n\tlong long ans[510][510] = {}; \n\tfor(int i = 0; i < 500; i++){\n\t\tfor(int j = 0; j < 500; j++){\n\t\t\tans[i][j] = A[500-i+j][i+j]; \n\t\t}\n\t}\n\tint N; cin >> N; \n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tcout << ans[i][j] << \" \"; \n\t\t}\n\t\tcout << endl; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 510, MAX = 10000;\nint isp[MAX + 10], pri[MAX], pcnt;\nvoid prework() {\n  rep (i, 2, MAX) {\n    if (!isp[i]) pri[++pcnt] = i;\n    for (int j = 1; pri[j] * i <= MAX; ++ j) {\n      isp[pri[j] * i] = 1;\n      if (i % pri[j] == 0) break;\n    }\n  }\n}\nll mat[N][N];\nint n, arr[2][N];\nset<ll> st;\nll lcm(ll x,ll y) {\n  return x / __gcd(x, y) * y;\n}\nint main() {\n  prework();\n  read(n);\n  if (n == 2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n  int p = 0;\n  rep (i, 1, n) arr[0][i] = pri[++ p];\n  rrp (i, n, 1) arr[1][i] = pri[++ p];\n  int tmp = (n+1) / 2;\n  rep (i, 1, n) rep (j, 1, n) if ((i+j) % 2 == 0) {\n    int vx = i + j, vy = i - j;\n    vx /= 2;\n    vy /= 2;\n    vy += tmp;\n    mat[i][j] = 1ll * arr[0][vx] * arr[1][vy];\n  }\n  rep (i, 1, n) rep (j, 1, n) if ((i+j)&1) {\n    mat[i][j] = 1;\n    if (i > 1) mat[i][j] = lcm(mat[i][j], mat[i-1][j]);\n    if (i < n) mat[i][j] = lcm(mat[i][j], mat[i+1][j]);\n    if (j > 1) mat[i][j] = lcm(mat[i][j], mat[i][j-1]);\n    if (j < n) mat[i][j] = lcm(mat[i][j], mat[i][j+1]);\n    mat[i][j] ++;\n  }\n  // (i-j, i+j)\n  // rep (i, 1, n) rep (j, 1, n) {\n  //   assert(!st.count(mat[i][j]));\n  //   assert(mat[i][j] <= (ll)1e15);\n  //   st.insert(mat[i][j]);\n  // }\n  rep (i, 1, n) {\n    rep (j, 1, n) printf(\"%lld \", mat[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 500 + 20 , M = 3e4 + 20 ;\nint n , a[N][N] ;\nbool np[M] ;\nvector <int> vec ;\n\ninline void add (int &a , int b) {\n\ta = a * b / __gcd(a , b) ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\" ;\n\t\treturn 0 ;\n\t}\n\n\tnp[0] = np[1] = 1 ;\n\tfor (int i = 2 ; i < M ; i ++) {\n\t\tif (_sz(vec) == 2 * N) break ;\n\t\tif (np[i]) continue ;\n\n\t\tvec.push_back(i) ;\n\n\t\tfor (int j = 2 * i ; j < M ; j += i) np[j] = 1 ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 0) \n\t\t\t\ta[i][j] = vec[(i + j) >> 1] * vec[((i - j + N) >> 1) + N] ;\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 1) {\n\t\t\t\ta[i][j] = 1 ;\n\t\t\t\tif (i > 0) add(a[i][j] , a[i - 1][j]) ;\n\t\t\t\tif (i < n - 1) add(a[i][j] , a[i + 1][j]) ;\n\t\t\t\tif (j > 0) add(a[i][j] , a[i][j - 1]) ;\n\t\t\t\tif (j < n - 1) add(a[i][j] , a[i][j + 1]) ;\n\t\t\t}\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int j = 0 ; j < n ; j ++) cout << a[i][j] << ' ' ;\n\t\tcout << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\ncin>>n;\nfor(int i = 0; i < n; i++) {\n  \tfor(int j = 0; j < n; j++){\n\t\tcout<<10000000-i-j;\n\t\tcout<<(j==n-1 ? \"\\n\": \" \" );\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\n//long long gcd(long long a,long long b)\n//{\n//\tif (b==0) return a;\n//\treturn gcd(b,a%b);\n//}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/__gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n//\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define MOD 1000000007\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\ntypedef unsigned long long int ull;\ntypedef long long lint;\n\nlint LCM(lint a,lint b){\n  if(a==0 || b==0) return 0;\n  lint tmp,r,x;\n  x=a*b;\n  if(a<b) tmp=a,a=b,b=tmp;\n  r=a%b;\n  while(r!=0) a=b,b=r,r=a%b;\n  x=x/b;\n  return x;\n}\n\nlint GCD(lint a,lint b){\n  if(a==0 || b==0) return max(a,b);\n  else return (a*b)/LCM(a,b);\n}\n\nvector<bool> prime;\nvoid primeinit(int N){\n    if(N+1>prime.size()){\n        prime.resize(N+1,true);\n    } \n    prime[0] = false;\n    prime[1] = false;\n    for(int i=2; i*i<=N;i++) if(prime[i]) for(int j=2; i*j<=N;j++) prime[i*j]=false;\n}\n\n\nint main(void){\n    primeinit(1000000);\n    int N;\n    cin >> N;\n    int put=N;\n    N=500;\n    lint primeno[2000];\n    lint ans[N][N];\n    rep(i,N) rep(j,N) ans[i][j]=1;\n    lint now=0;\n    rep(i,2000){\n        while(!prime[now]) now++;\n        primeno[i]=now;\n        now++;\n    }\n    int no=0;\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n        x=i,y=0;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    for(int i=2;i<N;i+=2){\n        int x=0,y=i;\n        while(x<N && y<N){\n            ans[y][x]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n    }\n    for(int i=1;i<N;i+=2){\n        int x=N-1,y=i;\n        while(x>=0 && y<N){\n            ans[y][x]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    rep(i,N) rep(j,N){\n        if(ans[i][j]==1){\n            lint in=1;\n            if(i!=0) in=LCM(in,ans[i-1][j]);\n            if(i!=N-1) in=LCM(in,ans[i+1][j]);\n            if(j!=0) in=LCM(in,ans[i][j-1]);\n            if(j!=N-1) in=LCM(in,ans[i][j+1]);\n            ans[i][j]=in+1;\n        }\n    }\n    rep(i,put){\n        rep(j,put) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 510\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 998244353\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nll a[maxn][maxn];\nconst int S = 10050;\nbool bpr[S];\nmap<int, int> r[2];\nll gcd(int a, int b) {\n\tif (!b) return a;\n\treturn gcd(b, a % b);\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\nint main() {\n\tvi pr;\n\tfor (int i = 0; i < S; i++)\n\t\tbpr[i] = 1;\n\tfor (int i = 2; i < S; i++) {\n\t\tif (!bpr[i]) continue;\n\t\tpr.pb(i);\n\t\tfor (int j = 2; j * i < S; j++)\n\t\t\tbpr[i * j] = 0;\n\t}\n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 4 << ' ' << 7 << endl << 23 << ' ' << 10 << endl;\n\t\treturn 0;\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\tcontinue;\n\t\t\tif (!r[0][i + j]) r[0][i + j] = pr[cnt++];\n\t\t\tif (!r[1][i - j]) r[1][i - j] = pr[cnt++];\n\t\t\ta[i][j] = r[0][i + j] * r[1][i - j];\n \t\t}\n \tfor (int i = 1; i <= n; i++) {\n \t\tfor (int j = 1; j <= n; j++) {\n \t\t\tif ((i + j) % 2 == 0) {\n\t \t\t\tll ns = 1;\n\t \t\t\tif (i >= 2) ns = lcm(ns, a[i - 1][j]);\n\t \t\t\tif (j >= 2) ns = lcm(ns, a[i][j - 1]);\n\t \t\t\tif (i != n) ns = lcm(ns, a[i + 1][j]);\n\t \t\t\tif (j != n) ns = lcm(ns, a[i][j + 1]);\n\t \t\t\ta[i][j] = ns + 1;\n\t\t\t}\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n \nconst int N=505;\nconst int LIM=8000;\nint fl[LIM],pri[LIM],n;\nvoid initprime(){\n\tFor(i,2,LIM-1) For(j,2,(LIM-1)/i) fl[i*j]=1;\n\tFor(i,1,LIM-1) if (!fl[i]) pri[++*pri]=i;\n}\nmap<int,int> mp1,mp2;\nmap<ll,int> mp3;\nll ans[N][N];\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid work(){\n\tint l=4;\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp1[i+j]) mp1[i+j]=pri[l++];\n\t\tans[i][j]=mp1[i+j];\n\t}\n\tRep(i,n,1) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp2[i-j]) mp2[i-j]=pri[l++];\n\t\tans[i][j]*=mp2[i-j];\n\t}\n\n\tll mx=0;\n\tFor(i,1,n) For(j,1,n) if (!ans[i][j]){\n\t\tll lcm=1;\n\t\tif (i!=1) lcm*=ans[i-1][j]/gcd(ans[i-1][j],lcm);\n\t\tif (i!=n) lcm*=ans[i+1][j]/gcd(ans[i+1][j],lcm);\n\t\tif (j!=1) lcm*=ans[i][j-1]/gcd(ans[i][j-1],lcm);\n\t\tif (j!=n) lcm*=ans[i][j+1]/gcd(ans[i][j+1],lcm);\n\t\tans[i][j]=lcm+1;\n\t}\n\tFor(i,1,n){\n\t\tFor(j,1,n) \n\t\t  {//if(mp3[ans[i][j]]) {cout<<\"fuck\"<<endl;exit(0);}  else mp3[ans[i][j]]=1; \n\t\t   printf(\"%lld \",ans[i][j]);\n\t      } \n\t\tputs(\"\");\n\t}\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tinitprime();\n\tif(n==2)\n\t  {cout<<4<<' '<<7<<endl;\n\t   cout<<23<<' '<<10<<endl;\n\t    return 0;\n\t  }\n\twork();\n}"
  },
  {
    "language": "C++",
    "code": "//test\n\n\n#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n\treturn y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n\treturn x / GCD(x, y) * y;\n}\nvoid sieve() {\n\tfor(int i=2;i<=MAXM;i++) {\n\t\tif( !vis[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;i*prm[j]<=MAXM;j++) {\n\t\t\tvis[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n\tsieve(); int N;\n\tscanf(\"%d\", &N);\n\tif( N == 2 ) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tMat[i][j] = 1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) == (j & 1) ) {\n\t\t\t\tMat[i][j] = prm[(i + j) / 2] * prm[(i+N+1-j)/2 + N];\n\t\t\t\tMat[i+1][j] = LCM(Mat[i+1][j], Mat[i][j]);\n\t\t\t\tMat[i-1][j] = LCM(Mat[i-1][j], Mat[i][j]);\n\t\t\t\tMat[i][j+1] = LCM(Mat[i][j+1], Mat[i][j]);\n\t\t\t\tMat[i][j-1] = LCM(Mat[i][j-1], Mat[i][j]);\n\t\t\t}\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) != (j & 1) )\n\t\t\t\tMat[i][j]++;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<N;j++)\n\t\t\tprintf(\"%lld \", Mat[i][j]);\n\t\tprintf(\"%lld\\n\", Mat[i][N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    LL n;\n    cin >> n;\n    vector<vector<LL> > a(n,vector<LL>(n));\n    LL maxa = 0;\n    set<LL> f;\n    vector<int> pr;\n    for(int j = 2; ; j++){\n        if(pr.size() >= 1200) break;\n        int ok = 1;\n        for(int z = 2; z * z <= j; z++){\n            if(j % z == 0) ok = 0;\n        }\n        if(ok){\n            pr.push_back(j);\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if((i + j) % 2) {\n                LL mult = (4*(i-j + 500) + 303) * (4 * (i+j) + 301);\n                for(LL q = 1; ; q++){\n                    if(f.find(mult * q) == f.end()){\n                        a[i][j] = mult * q;\n                        maxa = max(maxa, a[i][j]);\n                        f.insert(a[i][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if((i + j) % 2 == 0){\n                vector<int> dx = {0, 1, 0, -1};\n                vector<int> dy = {1, 0, -1, 0};\n                LL mult = 1;\n                for(int r = 0; r < 4; r++){\n                    LL ni = i + dx[r];\n                    LL nj = j + dy[r];\n                    if(ni < 0 || nj < 0 || ni >= n || nj >= n) continue;\n                    LL g = __gcd(mult, a[ni][nj]);\n                    mult = mult / g * a[ni][nj];\n                }\n                for(LL q = 1; ; q++){\n                    if(f.find(mult * q + 1) == f.end()){\n                        a[i][j] = mult * q + 1;\n                        maxa = max(maxa, a[i][j]);\n                        f.insert(a[i][j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint ncnt,val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nint gcd(int a,int b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {\n\t\tputs(\"4 7\"),puts(\"23 10\");\n\t\treturn 0;\n\t}\n\tinit(10000);\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)&1) {\n\t\tif(!val0[i+j]) val0[i+j]=prime[ncnt++]; \n\t\tif(!val1[i-j+n]) val1[i-j+n]=prime[ncnt++];\n\t\tan[i][j]=val0[i+j]*val1[i-j+n];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k]; if(_x<1||_x>n) continue;\n\t\t\tint _y=y+dy[k]; if(_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t\t++an[x][y];\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%d\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <numeric>\nusing namespace std;\ninline long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\n\nvector<int> prime_table(int n) {\n    vector<int> is_prime(n + 1);\n    if (n) iota(is_prime.begin() + 2, is_prime.end(), 2);\n    for (int i = 2; i * i <= n; i++) if (is_prime[i]) {\n        for (int j = i + i; j <= n; j += i) is_prime[j] = 0;\n    }\n    return is_prime;\n}\nvector<int> make_primes(int ma) {\n    vector<int> ps = prime_table(ma);\n    ps.erase(remove(ps.begin(), ps.end(), 0), ps.end());\n    return ps;\n}\n\nint main() {\n    auto ps = make_primes(10000);\n    int n; cin >> n;\n    vector<long long> pos, neg;\n    int sz = n + 2;\n    pos.insert(pos.end(), ps.begin(), ps.begin() + sz);\n    neg.insert(neg.end(), ps.begin() + sz, ps.begin() + sz * 2);\n    vector<vector<long long>> a(sz, vector<long long>(sz, 1));\n    for (int i = 0; i < sz; i++) for (int j = 0; j < sz; j++) {\n        int wa = i + j, sa = i - j + n + 1;\n        if ((i + j) & 1) a[i][j] = pos[wa / 2] * neg[sa / 2];\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n        if ((i + j) & 1) continue;\n        a[i][j] = lcm(a[i-1][j], lcm(a[i][j-1], lcm(a[i][j+1], a[i+1][j]))) + 1;\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n        cout << a[i][j] << \" \\n\"[j == n];\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint N;\nint A[550][550];\ndeque<int> prime;\nunordered_map<int, int> mpA, mpB;\nsigned main() {\n    cin >> N;\n    for (int i = 2; i <= 8000; i++) {\n        for (int j = 2; j <= sqrt(i); j++) {\n            if (i % j == 0)goto nene;\n        }\n        prime.push_back(i);\nnene:;\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        if (i % 2 == 0) {mpA[2 * i] = prime.front(); prime.pop_front();}\n        else {mpA[2 * i] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 10; i++) {\n        if (i % 2 == 0) {mpB[2 * i - (N + 4) - N % 2] = prime.front(); prime.pop_front();}\n        else {mpB[2 * i - (N + 4) - N % 2] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n            A[i][j] = mpA[i + j] * mpB[i - j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if ((i + j) % 2 == 0) {cout << A[i][j] << \" \"; continue;}\n            int cur = 1;\n            for (int k = 0; k < 4; k++) {\n                cur = cur / gcd(cur, A[i + dy[k]][j + dx[k]]) * A[i + dy[k]][j + dx[k]];\n            }\n            cout << cur * 2 + 1 << \" \";\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i < 499 ? 998 - 2 * i : 2 * i - 999;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 3;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 3;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 507;\nconst int MAXS = 2000007;\n\nint n;\nLL a[MAXN][MAXN];\nint p[MAXS];\nset < LL > s;\nbool isp[MAXS];\nint prm[MAXS], kp;\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nLL gcd ( LL x, LL y )\n{\n\treturn y ? gcd ( y, x%y ) : x;\n}\n\nLL lcm ( LL x, LL y )\n{\n\treturn ( ( ~x ) && ( ~y ) ) ? ( x / gcd ( x, y ) * y ) : ( ~x ) ? x : y;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n\t\n\tINIT ( isp, true );\n\tisp[0] = isp[1] = false;\n\tlp ( i, 2, MAXS ){\n\t\tif ( isp[i] ) prm[++kp] = i;\n\t\tfor ( int j = 1; j <= kp && prm[j] * i < MAXS; ++j ){\n\t\t\tisp[prm[j]*i] = false;\n\t\t\tif ( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d\", &n );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( ( i & 1 ) == ( j & 1 ) ){\n\t\t\t\ta[i][j] = prm[i+j+2*n+1] * ( i - j + n );\n\t\t\t\ts.insert ( a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tLL g = -1;\n\t\t\t\tif ( i > 1 ) g = lcm ( g, a[i-1][j] );\n\t\t\t\tif ( i < n ) g = lcm ( g, a[i+1][j] );\n\t\t\t\tif ( j > 1 ) g = lcm ( g, a[i][j-1] );\n\t\t\t\tif ( j < n ) g = lcm ( g, a[i][j+1] );\n\t\t\t\tLL cg = g + 1;\n\t\t\t\twhile ( s.find ( cg ) != s.end () ) cg += g;\n\t\t\t\ta[i][j] = cg;\n\t\t\t\ts.insert ( a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ) printf ( \"%lld \", a[i][j] );\n\t\tputchar ( '\\n' );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nset<ll> presents;\nll gg1[2 * MAXN], gg2[2 * MAXN];\nll f1[8] = {1, 2, 3, 4, 6, 8, 9, 12}, f2[8] = {6, 9, 2, 12, 4, 8, 3, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn gg1[x];\n\t// return (primes[x] < 4000 ? primes[x] : primes[x] / 2);\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn gg2[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p >= MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i <= 2 * N; i++)\n\t\t{\n\t\t\tgg1[i] = primes[i / 8 + 3] * f1[i % 8];\n\t\t\tgg2[i] = primes[i / 8 + 3] * f2[i % 8];\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[i][j] = lcm(mind(i - j), plud(i + j));\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j]) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j] + 1) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\t// cerr << \"set\\n\"\n\t\tif(*(presents.rbegin()) < 100000000000000ll) break;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tpresents.clear();\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define I64d_OJ\n\n//#ifdef I64d_OJ\n//#define LL __int64\n//#endif // I64d_OJ\n#ifdef I64d_OJ\n#define LL long long\n#endif // I64d_OJ\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vi;\n\ninline LL read(){\n    LL x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define ls rt<<1\n#define rs rt<<1|1\n#define MID(a,b) (((LL)(a)+(LL)(b))>>1)\n#define absx(a) ((a)<0?-(a):(a))\n#define MK(a,b) make_pair(a,b)\n#define PB(a) push_back(a)\n#define lowbit(x) ((x)&-(x))\n\ntemplate< typename T >\ninline void Max(T &a,T &b){if(a<b) a=b;}\ntemplate< typename T>\ninline void Min(T &a,T &b){if(a>b) a=b;}\n\nconst double pi=(double)acos(-1.0);\nconst double eps=(double)1e-10;\nconst int INF = (int) 0x3f3f3f3f;\nconst int MOD = (int) 1e9+7;\nconst int MAXN =(int) 5e2+10;\nconst int MAXM = (int) 2e5+10;\nconst int sigma_size = (int) 26;\n\n///--------------------START-------------------------\nLL a[MAXN][MAXN];\nconst int N = (int) 2e5 +10;\nint prime[N],phi[N],cnt;// prime:记录质数，phi记录欧拉函数\nint Min_factor[N];// i的最小素因子\nbool vis[N];\nvoid Init()\n{\n    cnt=0;\n    phi[1]=1;\n    int x;\n    for(int i=2;i<N;i++)\n    {\n        if(!vis[i])\n        {\n            prime[++cnt]=i;\n            phi[i]=i-1;\n            Min_factor[i]=i;\n        }\n        for(int k=1;k<=cnt&&prime[k]*i<N;k++)\n        {\n            x=prime[k]*i;\n            vis[x]=true;\n            Min_factor[x]=prime[k];\n            if(i%prime[k]==0)\n            {\n                phi[x]=phi[i]*prime[k];\n                break;\n            }\n            else phi[x]=phi[i]*(prime[k]-1);\n        }\n    }\n}\n\nLL gcd(LL x,LL y){\n    return x==0 ? y : gcd(y%x,x);\n}\n\nvoid work(){\n    int n=500;\n    for(int i=0;i<=n+1;i++){\n        for(int j=0;j<=n+1;j++){\n            a[i][j]=1;\n        }\n    }\n    Init();\n    int p=1;\n    for(int i=2;i<=500;i+=2) a[1][i]=++p;\n    for(int i=1;i<=500;i+=2) a[2][i]=++p;\n    for(int i=3;i<=n;i++){\n        int x=(i+1)/2;\n        for(int j=1;j<=n;j++)if(a[i-2][j]>1){\n            a[i][j]=a[i-2][j]/(x-1)*x;\n        }\n    }\n    int mi=0;\n    LL mx=0;\n//    for(int i=1;i<=5;i++){\n//        for(int j=1;j<=5;j++){\n//            printf(\"%lld \",a[i][j]);\n//        }\n//        printf(\"\\n\");\n//    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++)if(a[i][j]==1){\n            LL g1=gcd(a[i-1][j],a[i][j-1]);\n            LL g2=gcd(a[i+1][j],a[i][j+1]);\n            LL t1=a[i-1][j]*a[i][j-1]/g1;\n            LL t2=a[i+1][j]*a[i][j+1]/g2;\n            LL g3=gcd(t1,t2);\n            a[i][j]=t1*t2/g3+1;\n            mx=max(mx,a[i][j]);\n        }\n    }\n//    printf(\"mi = %d\\n\",mi);\n//    printf(\"mx = %lld\\n\",mx);\n//    for(int i=499;i<=n;i++){\n//        for(int j=499;j<=n;j++){\n//            printf(\"%lld \",a[i][j]);\n//        }\n//        printf(\"\\n\");\n//    }\n    int N; scanf(\"%d\",&N);\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            printf(\"%lld\",a[i][j]);\n            if(j<N) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n}\n\n///--------------------END-------------------------\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long LL;\nconst int MX = 10005, MP = 2005;\nconst int MN = 505;\n\nbool ip[MX];\nint p[MP], pc;\ninline void Sieve(int N) {\n\tfor (int i = 2; i <= N; ++i) {\n\t\tif (!ip[i]) p[++pc] = i;\n\t\tfor (int j = 1, k; j <= pc; ++j) {\n\t\t\tif ((k = p[j] * i) > N) break;\n\t\t\tip[k] = 1;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint N, A[MN], B[MN];\n\nint main() {\n\tSieve(10000);\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) A[i] = p[i & 1 ? i / 2 + 1 : N + N - i / 2 + 1];\n\tfor (int i = 1; i <= N; ++i) B[i] = p[(i & 1 ? N - i / 2 : N + i / 2) + (N & 1)];\n\tA[0] = A[N + 1] = B[0] = B[N + 1] = 1;\n\tfor (int i = 1; i <= N; ++i, puts(\"\"))\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tif ((i + j) % 2) printf(\"%lld \", (LL)A[(i + j) / 2] * A[(i + j) / 2 + 1] * B[(N + i - j + (N & 1)) / 2] * B[(N + i - j + (N & 1)) / 2 + 1] + 1);\n\t\t\telse printf(\"%d \", A[(i + j) / 2] * B[(N + i - j + (N & 1)) / 2]);\n\treturn 0;\n}\n\n// Luogu : PinkRabbit"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[2010], cnt, n, dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nlong long Res[600][600];\nlong long gcd(long long a, long long b) {\n\treturn b ? gcd(b, a%b) : a;\n}\nint main() {\n\tint i, j, pv = 0;\n\tfor (i = 2;; i++) {\n\t\tfor (j = 2; j*j <= i; j++) {\n\t\t\tif (i%j == 0)break;\n\t\t}\n\t\tif (j*j > i)w[++cnt] = i;\n\t\tif (cnt >= 2000)break;\n\t}\n\tscanf(\"%d\", &n);\n\tfor (i = 3; i <= n + n; i += 2) {\n\t\tpv++;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tint x = j, y = i - j;\n\t\t\tif (1 > y || y > n)continue;\n\t\t\tRes[x][y] = w[pv];\n\t\t}\n\t}\n\tfor (i = n/2*2+2-1; i >= -n; i -= 2) {\n\t\tpv++;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tint x = j, y = i + j;\n\t\t\tif (1 > y || y > n)continue;\n\t\t\tRes[x][y] *= w[pv];\n\t\t}\n\t}\n\tlong long Mx = -1e9;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\t\t\tif (x<1 || x>n || y<1 || y>n)continue;\n\t\t\t\t\tr = r / gcd(r, Res[x][y])*Res[x][y];\n\t\t\t\t}\n\t\t\t\tMx = max(Mx, r);\n\t\t\t\tRes[i][j] = r + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++)printf(\"%lld \", Res[i][j]);\n\t\tputs(\"\\n\");\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<list>\n#include<deque>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1000)\nvector<int>prim;\n\nvoid prim_make(int k){\n\tif (k >= 2)prim.push_back(2);\n\tif (k >= 3)prim.push_back(3);\n\tif (k >= 5)prim.push_back(5);\n\tint x = 7;\n\tbool v;\n\twhile (x <= k){\n\t\tv = true;\n\t\tfor (int i = 2; prim[i] * prim[i] <= x; i++){\n\t\t\tif (x%prim[i] == 0){\n\t\t\t\tv = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v)prim.push_back(x);\n\t\tif (x % 6 == 1)x += 4;\n\t\telse x += 2;\n\t}\n\treturn;\n}\n\n\n\n\n\n\nint main(){\n\tlong long a[N][N];\n\tset<long long>s;\n\tint n;\n\tlong long k, x, y, z;\n\tlong long ans;\n\tbool v = true;\n\tprim_make(100000);\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tk = 2;\n\tf(i, n){\n\t\tf(j, n)a[i][j] = -1;\n\t}\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif ((i + j) % 2 == 0){\n\t\t\t\ta[i][j] = k;\n\t\t\t\ts.insert(k);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif (a[i][j] == -1){\n\t\t\t\tans = 1;\n\t\t\t\tif (i > 0)ans = ans*a[i - 1][j];\n\t\t\t\tif (i<(n - 1))ans = ans*a[i + 1][j];\n\t\t\t\tif (j > 0)ans = ans*a[i][j - 1];\n\t\t\t\tif (j<(n - 1))ans = ans*a[i][j + 1];\n\t\t\t\tx = 0;\n\t\t\t\twhile (s.count((ans + 1)) == 1){\n\t\t\t\t\tif (x > 0)ans = ans / prim[x - 1];\n\t\t\t\t\tans = ans*prim[x];\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\ta[i][j] = ans + 1;\n\t\t\t\ts.insert((ans + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < (n - 1))printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\ninline int read(){char ch=gc;int w=1,s=0;while(!isdigit(ch)){if(ch=='-') w=-1;ch=gc;};while(isdigit(ch)){s=s*10+ch-'0';ch=gc;} return w*s;}\nll ANS[550][550];\nll lcm(ll a,ll b){return (ll)((__int128)a*b/__gcd(a,b));}\nint N,np[101010],prime[100010],cnt;\nint Hang[100010],Lie[100001];\ninline void Init(int n)\n{\n\tnp[1]=1;\n\tfor(rint i=2;i<=n;++i){\n\t\tif(!np[i]) prime[++cnt]=i;\n\t\tfor(rint j=1;j<=cnt&&i*prime[j]<=n;++j){\n\t\t\tnp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}int dx[]={0,1,0,-1,0},dy[]={0,0,1,0,-1};\nint seq[1000010];\nint main()\n{\n\tN=read();N+=2;\n\tInit(100100);\n//\tfor(rint i=1;i<=N;++i) Hang[i]=prime[i],Lie[i]=prime[i+N];\n\tint a=1,b=(N<<1)+2;int tot=0;\n\twhile(a<b)\n\t{\n\t\tseq[++tot]=prime[a++];\n\t\tseq[++tot]=prime[b--]; \n\t} \n\tfor(rint i=1;i<=N;++i)\n\t{\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))\n\t\t\t{\n\t\t\t\tint mid1=(i+j)>>1;\n\t\t\t\tint mid2=(N-i+j+1)>>1;\n\t\t\t\tANS[i][j]=1ll*seq[mid1]*seq[mid2+N];\n\t\t\t}\n\t\t}\n\t}\n\tfor(rint i=1;i<=N;++i){\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!ANS[i][j])\n\t\t\t{\n\t\t\t\tll res=1;\n\t\t\t\tfor(rint d=1;d<=4;++d)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni<1||nj<1||ni>N||nj>N) continue;\n\t\t\t\t\tres=lcm(ANS[ni][nj],res);\n\t\t\t\t}\n\t\t\t\tANS[i][j]=res+1;\n\t\t\t}\n\t\t\tif(i>1&&i<N&&j>1&&j<N)\n\t\t\tcout<<ANS[i][j]<<\" \";\n\t\t}\n\t\tif(i>1&&i<N)\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\nconst int INF = 1e9 ;\nconst int maxN = 1010; \nconst int MOD = 1e9 + 7;\nint tot,n;\nint prime[maxN]; //记录质数\nint b[maxN * 20]; //标记i 是否为质数 \nll a[maxN][maxN];\nvoid check()\n{\n\tfor(int i=2;i<= maxN*10;i++)\n\t{\n\t\tif(b[i] == 0)\n\t\t{\n\t\t\tprime[++tot] = i;\n\t\t\tfor(int j=2;i*j<=maxN * 10;j++)\n\t\t\t{\n\t\t\t\tb[i*j] = 1;\t\n\t\t\t}\t\n\t\t}\t\n\t} \n} \nvector<pii> l[maxN];\nll lc[maxN];\nint lcnt;\nvector<pii> r[maxN];\nll rc[maxN]; \nint rcnt;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint cnt;\n\tcheck();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(i,1)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = 1+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int j=2;j<=n;j++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(n,j)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tlcnt = cnt;\n\tcnt = 0;\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint k=1;\n\t\tr[++cnt].push_back(pii(n,j));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint k = 1;\n\t\tr[++cnt].push_back(pii(i,n));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = n-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\t\n\t\t} \n\t}\n\trcnt = cnt;\n\tcnt = 0;\n\tfor(int i=1;i<=lcnt;i+=2)\n\t{\n\t\tlc[i] = prime[++cnt]; \n\t}\n\tfor(int j=2;j<=lcnt;j+=2)\n\t{\n\t\tlc[j] = lc[j-1]*lc[j+1];\n\t}\n\tif(n%2 == 1)\n\t{\n\t\tfor(int i=1;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\tfor(int j=2;j<=rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\t\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\trc[1] = rc[2];\n\t\trc[rcnt] = rc[rcnt-1];\n\t\tfor(int j=3;j<rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][j] = 1ll; \n\t} \n\tfor(int i=1;i<=lcnt;i++)\n\t{\n\t\tfor(int j=0;j<l[i].size();j++)\n\t\t{\n\t\t\tint tx = l[i][j].first;\n\t\t\tint ty = l[i][j].second;\n\t\t\ta[tx][ty] *= lc[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=rcnt;i++)\n\t{\n\t\tfor(int j=0;j<r[i].size();j++)\n\t\t{\n\t\t\tint tx = r[i][j].first;\n\t\t\tint ty = r[i][j].second;\n\t\t\ta[tx][ty] *= rc[i];\n\t\t\tif((tx+ty)%2==1)\n\t\t\t\ta[tx][ty] += 1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j<n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30,maxn=2000005;\nint i,j,k,n,v[100000005];\nint f[maxn],prime[maxn],tot,e[100005];\nlong long ans[505][505],mx;\nmap<long long,int> p;\nvoid shai()\n{\n    tot=0;\n    for(int i=2;i<maxn;i++)\n    {\n        if(!f[i])\n            prime[tot++]=i;\n        for(int j=0;j<tot&&prime[j]*i<maxn;j++)\n        {\n            f[i*prime[j]]=1;\n            if(i%prime[j]==0)\n            {\n                break;\n            }\n        }\n    }\n}\nlong long gcd(long long a,long long b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nlong long lcm(long long a,long long b)\n{\n\tif(a==0)\n\t\treturn b;\n\tif(b==0)\n\t\treturn a;\n\treturn a/gcd(a,b)*b;\n}\nint main()\n{\n\tshai();\n\tscanf(\"%d\",&n);\n\tint m=0;\n\tfor(i=1;i<=499;i+=2)\n\t\te[i]=++m;\n\tfor(i=2;i<=499;i+=2)\n\t\te[i]=++m;\n\tfor(i=500;i>=1;--i)\n\t\tfor(j=500;j>=1;--j)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tfor(k=prime[e[(i+j)/2]-1];v[k];k+=prime[e[(i+j)/2]-1]);\n\t\t\t\tans[i][j]=k;\n\t\t\t\tv[k]=1;\n\t\t\t}\n\tfor(i=1;i<=500;++i)\n\t\tfor(j=1;j<=500;++j)\n\t\t\tif(ans[i][j]==0)\n\t\t\t{\n\t\t\t\tlong long s=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i+1][j],ans[i][j+1]));\n\t\t\t\tans[i][j]=s+1;\n\t\t\t\twhile(p[ans[i][j]])\n\t\t\t\t\tans[i][j]+=s;\n\t\t\t\tp[ans[i][j]]=1;\n\t\t\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t\tmx=max(mx,ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t//cout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,zs[500010];\nint n,b[510][510],c[510][501],ans[510][510];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%d \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int MAX = 10010;      // 素数判定する最大の数\nbool IsPrime[MAX];\nvector<int> Era(int n = MAX) {\n    vector<int> res;\n    IsPrime[0] = false; IsPrime[1] = false;\n    for (int i = 2; i < n; ++i) IsPrime[i] = true;\n    for (int i = 2; i < n; ++i) {\n        if (IsPrime[i]) {\n            res.push_back(i);\n            for (int j = i*2; j < n; j += i) IsPrime[j] = false;\n        }\n    }\n    return res;\n}\n\nlong long GCD(long long a, long long b) {\n    if (b == 0) return a;\n    else return GCD(b, a % b);\n}\n\nlong long LCM(long long a, long long b) {\n    long long g = GCD(a, b);\n    return a / g * b;\n}\n\nint main() {\n    int N; cin >> N;\n    vector<vector<long long> > res(N, vector<long long>(N, 0));\n    vector<int> primes = Era();\n    for (int wa = 0; wa <= N*2; wa += 2) {\n        for (int sa = -N/2*2; sa <= N/2*2; sa += 2) {\n            if ((wa + sa) & 1) continue;\n            int i = (wa + sa) / 2;\n            int j = (wa - sa) / 2;\n            if (i < 0 || i >= N || j < 0 || j >= N) continue;\n            if ((i + j) & 1) continue;\n            res[i][j] = primes[wa/2] * primes[(sa + N/2*2)/2 + N];\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if ((i + j) % 2 == 0) continue;\n            long long L = 1;\n            for (int k = 0; k < 4; ++k) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni < 0 || ni >= N || nj < 0 || nj >= N) continue;\n                L = LCM(L, res[ni][nj]);\n            }\n            res[i][j] = L + 1;\n        }\n    }\n    if (N == 2) res[0][1] = res[1][0]*2-1;\n    \n    bool ok = true;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (res[i][j] > 1000000000000000LL) ok = false;\n            cout << res[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    \n    //cout << ok << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e4+10;\nint p[N],lim=10000,p1;\nint flag[N];\nint q[N],q1;\nll a[505][505];\nmap<int,int> px,py;\nint n;\nvoid prep(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!flag[i])p[++p1]=i;\n\t\tfor (int j=1;j<=p1;j++){\n\t\t\tint x=i*p[j];\n\t\t\tif (x>n)break;\n\t\t\tflag[x]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\nll lcm(ll a,ll b){\n\tif (!a||!b)return a+b;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tcin>>n;\n\tif (n==2){\n\t\tcout<<\"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tprep(lim);\n\tp1=0;p[0]=1;\n\tfor (int i=0,j=998;i<j;i++,j--)\n\t\tq[++q1]=p[i],q[++q1]=p[j];\n\tp1=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1)continue;\n\t\t\tif (!px[i+j])px[i+j]=q[++p1];\n//\t\t\tif (!py[i-j])py[i-j]=q[++p1];\n//\t\t\ta[i][j]=px[i+j]*py[i-j];\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1)continue;\n\t\t\tif (!py[i-j])py[i-j]=q[++p1];\n\t\t\ta[i][j]=px[i+j]*py[i-j];\n\t\t}\n\t}\n\tll mx=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1);else continue;\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t\t\tmx=max(mx,a[i][j]);\n\t\t\tif (a[i][j]>1e15){\n\t\t\t\tcout<<px[i+j-1]<<' '<<px[i+j+1]<<endl;\n\t\t\t\tcout<<py[i-j-1]<<' '<<py[i-j+1]<<endl;\n\t\t\t\tcout<<i<<' '<<j<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//\tcout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nlong long ans[500][500];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      ans[i][j] = 100000LL * j + (100000LL * 100000 * i + 100000LL * i * (i + 1) / 2);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%lld \", ans[i][j]);\n    }\n    putchar('\\n');\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\n\nbool updownup(map<int, int>upmp, map<int, int>downmp) {\n\tint mink = upmp.begin()->first;\n\tint maxk = prev(downmp.end())->first;\n\t\n\n\treturn true;\n\n\n}\n\nint main() {\n\tlong long int A=171;\n\tlong long int B=173;\n\tvector<vector<long long int>>v(501,vector<long long int>(501));\n\tv[0][0]=30100;\n\tfor (int y = 0; y < 500; ++y) {\n\t\tfor (int x = 0; x < 500; ++x) {\n\t\t\tif (y % 3 != 2) {\n\n\t\t\t\tv[y + 1][x] = v[y][x] * A + A*B;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[y+1][x]=(v[y][x]-A*B)/(A*A);\n\t\t\t}\n\n\t\t\tif (x % 3 != 2) {\n\n\t\t\t\tv[y][x+1] = v[y][x] * B + A*B;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[y][x+1] = (v[y][x] - A*B) / (B*B);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tset<long long int>aset;\n\tfor (int y = 0; y < 500; ++y) {\n\t\tfor (int x = 0; x < 500; ++x) {\n\t\t\taset.emplace(v[y][x]);\n\t\t}\n\t}\n\t//cout<<v[497][497]<<endl;\n\tint N;cin>>N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout<<v[i][j];\n\t\t\tif(j==N-1)cout<<endl;\n\t\t\telse cout<<\" \";\n\t\t}\n\t}\n\n\t//cout<<aset.size()<<endl;\n\t//int N;cin>>N;\n\t//vector<pair<int,int>>vs;\n\t//map<int,int>upmp,downmp;\n\t//for (int i = 0; i < N; ++i) {\n\t//\tint a,b;cin>>a>>b;\n\t//\tif (b == 1) {\n\t//\t\tupmp[a]++;\n\t//\t}\n\t//\telse {\n\t//\t\tdownmp[a]++;\n\t//\t}\n\t//}\n\n\t//int mink=upmp.begin()->first;\n\t//int maxk=prev(downmp.end())->first;\n\n\t////up down up\n\n\t//{\n\t//\t\n\t//}\n\t//\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v((i + j - 2) / 2)] * p[v((1500 + i - j) / 2)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v((i + j) / 2)] * p[v((1500 + i - j) / 2)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    cin >> N;\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)cout << a.at(i, j)) << \" \";\n        cout << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn primes[x];\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn primes[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p > MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = mind(i - j) * plud(i + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nint p[10010],mn[10010];\nll a[510][510];\nint n,tot;\nvoid euler(int n)\n{\n\ttot=0;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!mn[i])p[++tot]=i,mn[i]=tot;\n\t\tfor(int j=1;j<=mn[i]&&i*p[j]<=n;j++)\n\t\t\tmn[i*p[j]]=j;\n\t}\n}\nint gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nint main()\n{\n\tn=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\teuler(10000);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1){\n\t\t\t\tint x=(i-j+n+1)/2,y=(i+j+1)/2;\n\t\t\t\ta[i][j]=p[x]*p[n+y];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!((i+j)&1)){\n\t\t\t\tll cur=1;\n\t\t\t\tif(i>1)cur=cur/gcd(cur,a[i-1][j])*a[i-1][j];\n\t\t\t\tif(j>1)cur=cur/gcd(cur,a[i][j-1])*a[i][j-1];\n\t\t\t\tif(i<n)cur=cur/gcd(cur,a[i+1][j])*a[i+1][j];\n\t\t\t\tif(j<n)cur=cur/gcd(cur,a[i][j+1])*a[i][j+1];\n\t\t\t\ta[i][j]=cur+1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\twritesp(a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nlong long LCM(long long a , long long b){return a * b / __gcd(a , b);}\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1){\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = LCM(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n              \t++arr[i][j];\n            }\n\tcin >> N;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= N ; ++j) cout << arr[i][j] << \" \\n\"[j == N];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n \nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n \nlong long lcm(long long x, long long y) \n{\n\tif (x==0 || y==0) return x+y;\n\treturn x/gcd(x,y)*y;\n}\n \nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(!ans[i][j]) \n\t\t\t{\n\t\t\t\tans[i][j]=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i][j+1],ans[i+1][j]))+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 100005;\n\nint di[] = { -1, 0, 0, 1 };\nint dj[] = { 0, -1, 1, 0 };\n\nint n;\nbool p[100005];\nvi primes;\n\nvoid sieve() {\n\tMMS(p, 1);\n\tp[0] = p[1] = 0;\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i]) {\n\t\t\tfor (int j = 2 * i; j < N; j += i)\n\t\t\t\tp[j] = 0;\n\t\t}\n\t}\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i])\n\t\t\tprimes.pb(i);\n\t}\n}\n\nll a[501][501];\n\nll setV(int i, int j) {\n\tint d0 = (i + j) >> 1;\n\tint d1 = n + ((i - j + n - 1) >> 1);\n\treturn primes[d0] * 1LL * primes[d1];\n}\n\nll get(int i, int j) {\n\tif (i < 0 || i >= n || j < 0 || j >= n)\n\t\treturn -1;\n\treturn a[i][j];\n}\n\nll calc(int i, int j) {\n\tll res = 1;\n\tfor (int d = 0; d < 4; d++) {\n\t\tint ni = i + di[d];\n\t\tint nj = j + dj[d];\n\t\tll v = get(ni, nj);\n\t\tif (v != -1)\n\t\t\tres = res / __gcd(res, v) * v;\n\t}\n\treturn res + 1;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tsieve();\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1) == 0) {\n\t\t\t\ta[i][j] = setV(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1)) {\n\t\t\t\ta[i][j] = calc(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\ta[1][0] *= 2;\n\t\ta[1][0]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j == n - 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nvector<int> makePrimes(int n) { // [2,n]\n    vector<int> res, pr(n + 1, 1);\n    pr[0] = pr[1] = 0;\n    rep(p, 2, sqrt(n) + 2) if (pr[p]) for (int x = p * 2; x <= n; x += p) pr[x] = 0;\n    rep(p, 2, n + 1) if (pr[p]) res.push_back(p);\n    return res;\n}\nll gcd(ll a, ll b) { return a ? gcd(b%a, a) : b; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N;\nll ans[505][505];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    auto vp = makePrimes(51010);\n    cin >> N;\n\n    if (N == 2) {\n        printf(\"4 7\\n23 10\\n\");\n        return;\n    }\n\n    rep(y, 0, N) rep(x, 0, N) if ((x + y) % 2 == 0) {\n        int u = (x + y) / 2;\n        int v = (x - y) / 2 + N / 2 + 1;\n\n        ans[y][x] = 1LL * vp[u] * vp[2010 - v];\n    }\n\n    rep(y, 0, N) rep(x, 0, N) if ((x + y) % 2 == 1) {\n        ll c = 1;\n        if (0 <= y - 1) c = lcm(c, ans[y - 1][x]);\n        if (y + 1 < N) c = lcm(c, ans[y + 1][x]);\n        if (0 <= x - 1) c = lcm(c, ans[y][x - 1]);\n        if (x + 1 < N) c = lcm(c, ans[y][x + 1]);\n        ans[y][x] = c + 1;\n    }\n\n    rep(y, 0, N) {\n        rep(x, 0, N) {\n            if (x) printf(\" \");\n            printf(\"%lld\", ans[y][x]);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=505;\nint n;\nvector <int> vp;\nLL g[N][N];\nLL gcd(LL x,LL y){\n\treturn y?gcd(y,x%y):x;\n}\nLL lcm(LL x,LL y){\n\tif (!x||!y)\n\t\treturn x+y;\n\treturn x/gcd(x,y)*y;\n}\nint check(int n){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nmap <int,int> mp1,mp2;\nint g1(int x){\n\tif (!mp1[x])\n\t\tmp1[x]=vp.back(),vp.pop_back();\n\treturn mp1[x];\n}\nint g2(int x){\n\tif (!mp2[x])\n\t\tmp2[x]=vp.back(),vp.pop_back();\n\treturn mp2[x];\n}\nint main(){\n\tn=read();\n\tif (n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;vp.size()<n*2;i++)\n\t\tif (check(i))\n\t\t\tvp.push_back(i);\n\treverse(vp.begin(),vp.end());\n\tmp1.clear(),mp2.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]=g1(i+j);\n\tfor (int i=n;i>=1;i--)\n\t\tfor (int j=n;j>=1;j--)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]*=g2(i-j);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1){\n\t\t\t\tg[i][j]=lcm(g[i-1][j],lcm(g[i+1][j],lcm(g[i][j-1],g[i][j+1])))+1;\n\t\t\t\tassert(g[i][j]<=1000000000000000LL);\n\t\t\t}\n\tfor (int i=1;i<=n;i++,puts(\"\"))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",g[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat;\nint n,p[10005],vis[10005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint nex(int x){\n\tif (!mat[x])mat[x]=p[p[0]--];\n\treturn mat[x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=p[0]/2;i++)swap(p[i],p[p[0]-i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=nex(i+j);\n\tmat.clear();\n\tfor(int i=n;i;i--)\n\t\tfor(int j=n;j;j--)\n\t\t\tif ((i+j)%2)a[i][j]*=nex(i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[510][510],c[510][501],ans[510][510],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%d \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong gcd(long a, long b) {\n\tfor (; b; swap(a, b))\n\t\ta %= b;\n\treturn a;\n}\nlong lcm(long a, long b) {\n\ta /= gcd(a, b);\n\tif (double(a)*b > 1e15)\n\t\tthrow 0;\n\treturn a * b;\n}\nlong lcm(long a[]) {\n\treturn lcm(lcm(a[0], a[1]), lcm(a[2], a[3]));\n}\nlong a[555][555];\nint p[10000];\nvector<int> q;\nint main() {\n\tfor (int i = 2; i < 100; i++)\n\t\tif (!p[i]) for (int j = i * i; j < 10000; j += i)\n\t\t\tp[j] = 1;\n\tfor (int i = 2; i < 10000; i++)\n\t\tif (!p[i]) q.push_back(i);\n\tint N;\n\tcin >> N;\n\tint n = min(N * 2, 500);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2) continue;\n\t\t\ta[i][j] = q[(i + j) / 2] * q[(n - 2 + i - j) / 2 + n];\n\t\t}\n\t}\n\tint s[] = { 0,1,0,-1,0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) continue;\n\t\t\tlong y[] = { 1,1,1,1 };\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\tif (i + s[k] >= 0 && i + s[k] < n&&j + s[k + 1] >= 0 && j + s[k + 1] < n)\n\t\t\t\t\ty[k] = a[i + s[k]][j + s[k + 1]];\n\t\t\ta[i][j] = lcm(y) + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n\nvector<int> makePrimeLst(int N)\n{\n    if (N < 2) return vector<int>();\n    if (N == 2) return vector<int>{2};\n    vector<int> ans;\n    vector<int> alive(N+1, 1);\n    for (int i=2; (long long)i*i<=(long long)N; i++)\n    {\n        if (alive[i]) ans.push_back(i);\n        for (int t = i; t<=N; t += i) alive[t] = 0;\n    }\n    for (int i=ans.back()+1; i<=N; i++) if (alive[i]) ans.push_back(i);\n    return ans;\n}\n\nconstexpr int Nmax = 503;\nlint ans[Nmax][Nmax];\n\nint main()\n{\n    vector<int> info = makePrimeLst(100000);\n    vector<lint> p, q;\n    int now = 2;\n    while (p.size() < Nmax + 1)\n    {\n        p.insert(p.begin(), info[now++]);\n        q.insert(q.begin(), info[now++]);\n        p.push_back(info[now++]);\n        q.push_back(info[now++]);\n    }\n\n    set<int> seen;\n    REP(i, Nmax) REP(j, Nmax)\n    {\n        int u = (i + j) / 2, v = (i + (Nmax - 1 - j)) / 2;\n        if ((i + j) & 1)\n        {\n            ans[i][j] = p[u + 1] * q[v + 1];\n        }\n        else\n        {\n            ans[i][j] = p[u] * p[u + 1] * q[v] * q[v + 1] + 3;\n        }\n        // if (seen.find(ans[i][j]) != seen.end()) exit(1);\n        if (ans[i][j] > 1000000000000000LL) exit(1);\n        seen.insert(ans[i][j]);\n    }\n\n    int N;\n    cin >> N;\n    REP(i, N) REP(j, N)\n    {\n        lint min_ = min(ans[i][j], ans[i + 1][j]);\n        lint max_ = max(ans[i][j], ans[i + 1][j]);\n        if (max_ % min_ != 3) exit(1);\n    }\n    REP(i, N) REP(j, N)\n    {\n        lint min_ = min(ans[i][j], ans[i][j + 1]);\n        lint max_ = max(ans[i][j], ans[i][j + 1]);\n        if (max_ % min_ != 3) exit(1);\n    }\n\n    REP(i, N)\n    {\n        REP(j, N) cout << ans[i][j] << (j == N - 1 ? \"\\n\" : \" \");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 510\n#define MAXM 10000\nusing namespace std;\ntypedef long long ll;\nint n,cnt;\nll primes[MAXM];\nll a[MAXN][MAXN];\nbool isprime[MAXM+10];\nvoid prepare(){\n\tfor(int i=2;i<=MAXM;i++){\n\t\tif(isprime[i]==0)\n\t\t\tprimes[++cnt]=i;\t\n\t\tfor(int j=1;i*primes[j]<=MAXM;j++){\n\t\t\tisprime[i*primes[j]]=1;\n\t\t\tif(i%primes[j]==0)\n\t\t\t\tbreak;\t\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\t\n}\nll lcm(ll x,ll y){\n\tif(x==0)\n\t\treturn y;\n\tif(y==0)\n\t\treturn x;\n\tll g=gcd(x,y);\n\treturn x/g*y;\n}\nint main(){\n\tprepare();\n\tSF(\"%d\",&n);\n\tint now=1;\n\tif(n==2){\n\t\tPF(\"4 7\\n23 10\\n\");\n\t\treturn 0;\t\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i%2==j%2){\n\t\t\t\tint nowx=(i+j)/2;\n\t\t\t\tint nowy=(i-j+n)/2+n+1;\n\t\t\t\ta[i][j]=primes[nowx]*primes[nowy];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i%2!=j%2){\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1ll;\t\n\t\t\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tPF(\"%lld \",a[i][j]);\n\t\tPF(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    vi prime;\n    ll Max=5000;\n    vector<bool> flag(Max,1);\n    rep(i,2,Max){\n        if(i%2&&flag[i]){\n            prime.pb(i);\n            for(int j=i;j<Max;j+=i) flag[j]=0;\n        }\n    }\n    ll N; cin>>N;\n    vii ans(N,vi(N,1));\n    rep(i,0,N){\n        rep(j,0,N){\n            if((i+j)%2==0){\n                ans[i][j]=prime[(i+j)/2]*prime[(i-j)/2+N/2];\n                if(prime[(i+j)/2]<prime[(i-j)/2+N/2]) ans[i][j]*=2;\n            }\n        }\n    }\n    vi P={1,0,-1,0},Q={0,1,0,-1};\n    rep(i,0,N){\n        rep(j,0,N){\n            if((i+j)%2){\n                rep(k,0,4){\n                    ll X=i+P[k],Y=j+Q[k];\n                    if(0<=X&&X<N&&0<=Y&&Y<N){\n                        ll Z=std::__gcd(ans[i][j],ans[X][Y]);\n                        ans[i][j]=ans[i][j]/Z*ans[X][Y];\n                    }\n                }\n                ans[i][j]++;\n            }\n        }\n    }\n    std::set<ll> memo;\n    rep(i,0,N){\n        rep(j,0,N){\n            if(memo.count(ans[i][j])) ans[i][j]=(ans[i][j]-1)*2+1;\n            memo.insert(ans[i][j]);\n            cout<<ans[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    //cout<<memo.size()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll a[510][510];\nbitset<10101> isp; vector<int> ps;\nvoid init(){\n   rep(i,2,10000)isp[i]=1;\n   rep(i,2,10000)if(isp[i]){\n      ps.push_back(i);\n      for(int j=i*i;j<10000;j+=i)isp[j]=0;\n   }\n}\n\nint main(){\n   int n; cin>>n; int idx=0;\n   rep(i,0,n)rep(j,0,n)a[i][j]=1;\n   init();\n   for(int d=-n+(n&1);d<n;d+=2){\n      rep(x,0,n)if(x+d>=0 and x+d<n){\n         a[x][x+d]*=ps[idx];\n         if(x!=n-1)a[x+1][x+d]*=ps[idx];\n         if(x+d!=n-1)a[x][x+d+1]*=ps[idx];\n      } idx++;\n   }\n   for(int d=0;d<=n*2-2;d+=2){\n      rep(x,0,n)if(d-x>=0 and d-x<n){\n         a[x][d-x]*=ps[idx];\n         if(x!=0)a[x-1][d-x]*=ps[idx];\n         if(d-x!=n-1)a[x][d-x+1]*=ps[idx];\n      } idx++;\n   }\n   rep(i,0,n)rep(j,0,n)if((i+j)&1)a[i][j]++;\n   rep(i,0,n){\n      rep(j,0,n)cout<<a[i][j]<<(j==n-1?'\\n':' ');\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\t\nusing namespace std;\n\ntypedef double db;\ntypedef long long LL;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 505;\nconst int L = 1e5+5;\n\nint n;\nbool bz[L];\nint pri[L],k;\nLL a[N][N];\nset<LL>s;\n\nLL gcd(LL x,LL y){return !y?x:gcd(y,x%y);}\n\nLL lcm(LL x,LL y){\n\treturn x/gcd(x,y)*y;\n}\n\nint main(){\n\tn=get();\n\tfo(i,2,1e5)\n\tif(!bz[i]){\n\t\tpri[++k]=i;\n\t\tfo(j,1,1e5/i)bz[i*j]=1;\n\t}\n\tsrand(time(NULL));\n\trandom_shuffle(pri+1,pri+1+n*2);\n\tfo(i,1,n)fo(j,1,n)a[i][j]=1;\n\tint w=1;\n\tfor(int i=1;i<=n;i+=2){\n\t\tfor(int x=1,y=i;x<=n&&y<=n;x++,y++)a[x][y]=pri[w];\n\t\tw++;\n\t}\n\tfor(int i=3;i<=n;i+=2){\n\t\tfor(int x=i,y=1;x<=n&&y<=n;x++,y++)a[x][y]=pri[w];\n\t\tw++;\n\t}\n\tfor(int i=1;i<=n;i+=2){\n\t\tfor(int x=1,y=i;x<=n&&y;x++,y--)a[x][y]=a[x][y]*pri[w]*2;\n\t\tw++;\n\t}\n\tfor(int i=3;i<=n;i+=2){\n\t\tfor(int x=i,y=n;x<=n&&y;x++,y--)a[x][y]=a[x][y]*pri[w]*2;\n\t\tw++;\n\t}\n\ts.clear();\n\tfo(i,1,n)fo(j,1,n)if((i+j)%2==0)s.insert(a[i][j]);\n\tfo(i,1,n)\n\t\tfo(j,1,n)\n\t\tif ((i+j)%2==1){\n\t\t\tLL v=1;\n\t\t\tif (i>1) v=lcm(v,a[i-1][j]);\n\t\t\tif (i<n)v=lcm(v,a[i+1][j]);\n\t\t\tif (j>1)v=lcm(v,a[i][j-1]);\n\t\t\tif (j<n)v=lcm(v,a[i][j+1]);\n\t\t\tLL now=v;\n\t\t\twhile(s.find(now)!=s.end())now=now+v;\n\t\t\ts.insert(now);\n\t\t\ta[i][j]=now+1;\n\t\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)printf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nint n;\nll a[505][505];\nstd::set<ll> s;\n\ninline bool chk(int x) {\n    for(int i = 2; i *i <= x; ++i) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    vector<int> v;\n    for(int i = 2; ; ++i) {\n        if(chk(i)) {\n            v.pb(i); \n        }\n        if(v.size() == 600) break;\n    }\n\n    read(n);\n    int cnt = 1;\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)&1) {\n                a[i][j] = 1ll * v[i/2] * v[(j/2)+300];\n                s.insert(a[i][j]);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)%2==0) {\n                ll lcm = 1;\n                if(i>1) lcm = lcm * a[i-1][j] / std::__gcd(a[i-1][j], lcm);\n                if(i<n) lcm = lcm * a[i+1][j] / std::__gcd(a[i+1][j], lcm);\n                if(j>1) lcm = lcm * a[i][j-1] / std::__gcd(a[i][j-1], lcm);\n                if(j<n) lcm = lcm * a[i][j+1] / std::__gcd(a[i][j+1], lcm);\n\n                ll temp = lcm;\n                while(s.count(temp + 1)) temp += lcm;\n\n                a[i][j] = temp + 1;\n                s.insert(temp + 1);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            printf(\"%lld \", a[i][j]);\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=505,M=100005,x[4]={1,-1,0,0},y[4]={0,0,1,-1};\nll ans[N][N],tot;\nint n,p[M],vis[M],q[M];\n#define ld long double\nll lcm(ll x,ll y){\n\tif(x==0)return y; if(y==0)return x;//cout<<x<<\" \"<<y<<endl;\n\t//if((ld)x/__gcd(x,y)*y>(1e15))while(1);\n\treturn x/__gcd(x,y)*y;\n}\nsigned main(){\n\tn=500;\n\tfor(int i=2;i<M;i++)if(!vis[i]){\n\t\tq[++tot]=i; for(int j=i;j<M;j+=i)vis[j]=1;\n\t}\n\tfor(int i=1;i<=1000;i++)if(i&1)p[i]=q[(i+1)/2]; else p[i]=q[1001-i/2];\n\tint tx=248,ty=249;\n\tfor(int i=1;i<=n*2;i+=2){\n\t\tif(i<=n){tx+=2; ty+=1;} else {tx+=2; if(i!=n+1)ty--;}\n\t\tint x=i<=n?1:i-n+1,y=i<=n?n-i+1:1;\n\t\tint t=min(n-x+1,n-y+1);\n\t\tfor(int j=0;j<t;j++){\n\t\t\tans[x+j][y+j]=p[tx]*p[ty-j];\n\t\t\t//if(abs(x+j-2)+abs(y+j-2)==1)cout<<tx<<\" \"<<ty-j<<endl;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if((i+j)%2==0){\n\t//cout<<i<<\" \"<<j<<endl;\n\t\tfor(int k=0;k<4;k++)ans[i][j]=lcm(ans[i][j],ans[i+x[k]][j+y[k]]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\twrite(ans[i][j]); putchar(' ');\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n/*\n\n \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\n\n/*******************************************************/\n\n// n = 1.5e6 -> size = 114155, 800 ms\nvll list_prime_until(int n) {\n\tif (n < 2) return{};\n\tvll ret;\n\tlist<ll> lists(n - 1);\n\tint x = 2;\n\tLoopitr(itr, lists) {\n\t\t*itr = x++;\n\t}\n\tauto begin_itr = lists.begin();\n\twhile (begin_itr != lists.end() && (*begin_itr) * (*begin_itr) < (ll)n) {\n\t\tauto itr = begin_itr;\n\t\titr++;\n\t\twhile (itr != lists.end()) {\n\t\t\tif (*itr % *begin_itr == 0) itr = lists.erase(itr);\n\t\t\telse itr++;\n\t\t}\n\t\tbegin_itr++;\n\t}\n\tLoopitr(itr, lists) {\n\t\tret.push_back(*itr);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvvll table1(n, vll(n, 0));\n\tvvll table2(n, vll(n, 0));\n\tvvll ans(n, vll(n, 1));\n\tvll primes = list_prime_until(10000);\n\tint p = 0;\n\tfor (int k = 0; k < n; k += 2) {\n\t\tint i, j;\n\t\ti = k;\n\t\tj = 0;\n\t\twhile (i < n) {\n\t\t\ttable1[i][j] = primes[p];\n\t\t\tans[i][j] *= primes[p];\n\t\t\t++i; ++j;\n\t\t}\n\t\t++p;\n\t\tif (k == 0) continue;\n\t\ti = 0;\n\t\tj = k;\n\t\twhile (j < n) {\n\t\t\ttable1[i][j] = primes[p];\n\t\t\tans[i][j] *= primes[p];\n\t\t\t++i; ++j;\n\t\t}\n\t\t++p;\n\t}\n\tp = 999;\n\tfor (int k = 0; k < n; k += 2) {\n\t\tint i, j;\n\t\ti = 0;\n\t\tj = k;\n\t\twhile (j >= 0) {\n\t\t\ttable2[i][j] = primes[p];\n\t\t\tans[i][j] *= primes[p];\n\t\t\t++i; --j;\n\t\t}\n\t\t--p;\n\t\tif (k == n - 1) continue;\n\t\ti = n - 1;\n\t\tj = n - 1 - k;\n\t\twhile (j < n) {\n\t\t\ttable2[i][j] = primes[p];\n\t\t\tans[i][j] *= primes[p];\n\t\t\t--i; ++j;\n\t\t}\n\t\t--p;\n\t}\n\tLoop(i, n) {\n\t\tLoop(j, n) {\n\t\t\tif (ans[i][j] == 1) {\n\t\t\t\tvll vals(4, 1);\n\t\t\t\tif (i - 1 >= 0) vals[0] = table1[i - 1][j];\n\t\t\t\tif (j + 1 < n) vals[0] = table1[i][j + 1];\n\t\t\t\tif (j - 1 >= 0) vals[1] = table1[i][j - 1];\n\t\t\t\tif (i + 1 < n) vals[1] = table1[i + 1][j];\n\t\t\t\tif (i - 1 >= 0) vals[2] = table2[i - 1][j];\n\t\t\t\tif (j - 1 >= 0) vals[2] = table2[i][j - 1];\n\t\t\t\tif (i + 1 < n) vals[3] = table2[i + 1][j];\n\t\t\t\tif (j + 1 < n) vals[3] = table2[i][j + 1];\n\t\t\t\tans[i][j] = vals[0] * vals[1] * vals[2] * vals[3] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintmx(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\ninline ll gcd(ll x, ll y)\n{\n\twhile (y)\n\t{\n\t\tauto r = x % y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn x;\n}\ninline bool chk(int n)\n{\n\tfor (int i = 2; i * i <= n; i++)\n\t{\n\t\tif (!(n % i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline ll lcm(ll x, ll y) { return x && y ? x / gcd(x, y) * y : x + y; }\nll pri[1005], arr[505][505];\nint main()\n{\n\t// freopen(\"AGC027-D.in\", \"r\", stdin);\n\tint n, cur = 0, len = 0;\n\tscanf(\"%d\", &n);\n\tbool even = n & 1 ^ 1;\n\tn += even;\n\tfor (int i = 2; len <= n * 2; i++)\n\t{\n\t\tif (chk(i))\n\t\t\tpri[len++] = i;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tarr[i][j] = 1;\n\t}\n\tfor (int i = 0; i < n; i += 2, cur++)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= pri[cur];\n\t}\n\tfor (int i = 2; i < n; i += 2, cur++)\n\t{\n\t\tint x = 0, y = i;\n\t\twhile (x < n && y < n)\n\t\t\tarr[x++][y++] *= pri[cur];\n\t}\n\tcur = len - 1;\n\tfor (int i = 0; i < n; i += 2, cur--)\n\t{\n\t\tint x = i, y = 0;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= pri[cur];\n\t}\n\tfor (int i = 2; i < n; i += 2, cur--)\n\t{\n\t\tint x = n - 1, y = i;\n\t\twhile (x >= 0 && y < n)\n\t\t\tarr[x--][y++] *= pri[cur];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i & 1 ^ 1; j < n; j += 2)\n\t\t\tarr[i][j] = lcm(lcm(i ? arr[i - 1][j] : 0, j ? arr[i][j - 1] : 0),\n\t\t\t\t\t\t\tlcm(arr[i + 1][j], arr[i][j + 1])) + 1;\n\t}\n\tn -= even;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tprintf(\"%lld%c\", arr[i][j], \" \\n\"[j + 1 == n]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-11 10:55:56\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=1000010,M=510;\nint n,v[N],p[N],c;\ni64 ans[M][M];\ni64 gcd(i64 a,i64 b){ return b?gcd(b,a%b):a; }\ni64 lcm(i64 a,i64 b){ return a/gcd(a,b)*b; }\nint main()\n{\n\tn=1000000;\n\tfr(i,2,n)\n\t{\n\t\tif(!v[i]) p[++c]=i;\n\t\tfr(j,1,c)\n\t\t\tif(i*p[j]<=n)\n\t\t\t{\n\t\t\t\tv[i*p[j]]=1;\n\t\t\t\tif(i%p[j]==0) break;\n\t\t\t}\n\t\t\telse break;\n\t}\n\tn=read()+2;\n\tfr(i,0,n+1) fr(j,0,n+1) ans[i][j]=1; \n\tfr(i,1,n) fr(j,1,n) if((i+j)%2==0) ans[i][j]=p[(i+j)/2]*p[(i-j)/2+2*n];\n\tfr(i,1,n) fr(j,1,n) if((i+j)%2==1) ans[i][j]=lcm(ans[i-1][j],lcm(ans[i+1][j],lcm(ans[i][j-1],ans[i][j+1])))+1;\n\tfr(i,2,n-1) fr(j,2,n-1) printf(\"%lld%c\",ans[i][j],j==n-1?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\n#define rll register ll\nconst int N=1e4+5;\nint p[N],a[N],tot;\ninline void prime(ri n){\n\tri i,j,x;\n\tfor(i=2;i<=n;++i){\n\t\tif(!p[i]) a[++tot]=i;\n\t\tfor(j=1;(x=a[j]*i)<=n;++j){\n\t\t\tp[x]=1;\n\t\t\tif(i%a[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\ninline ll calc(ri i,ri j){\n\treturn (ll)a[(i+j+1)/2]*a[(j-i+500+1)/2+505];\n}\ninline ll gcd(rll x,rll y){\n\treturn !y?x:gcd(y,x%y);\n}\ninline ll lcm(rll x,rll y){\n\treturn x/gcd(x,y)*y;\n}\nint main(){\n\tri n,i,j;\n\tscanf(\"%d\",&n);\n\tprime(1e4);\n//\tprintf(\"tot = %d\\n\",tot);\n//\tfor(i=2;i<=n+1;++i){\n//\t\tfor(j=2;j<=n+1;++j)\n//\t\t\tprintf(\"%d \",i+j&1);\n//\t\tputs(\"\");\n//\t}\n\tfor(i=2;i<=n+1;++i){\n\t\tfor(j=2;j<=n+1;++j)\n\t\t\tif(i+j&1)\n\t\t\t\tprintf(\"%lld \",calc(i,j)); \n\t\t\telse\n\t\t\t\tprintf(\"%lld \",lcm(lcm(calc(i-1,j),calc(i+1,j)),lcm(calc(i,j-1),calc(i,j+1)))+1);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a*b/__gcd(a,b);\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<int>P;\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=N;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t//\tcout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tint k=0;\n\tfor(int i=1;i<=n;i+=2){\n\t\tint x=i,y=1;\n\t\twhile(x>=1&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx--,y++;\n\t\t}\n\t\tk++;\n\t}\n\tfor(int j=n&1?3:2;j<=n;j+=2){\n\t\tint x=n,y=j;\n\t\twhile(x>=1&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx--,y++;\n\t\t}\n\t\tk++;\n\t}\n\t\n\tfor(int i=n&1?n:n-1;i>=1;i-=2){\n\t\tint x=1,y=i;\n\t\twhile(x<=n&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx++,y++;\n\t\t}\n\t\tk++;\n\t}\n\tfor(int i=3;i<=n;i+=2){\n\t\tint x=i,y=1;\n\t\twhile(x<=n&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx++,y++;\n\t\t}\n\t\tk++;\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int lim = 31622776;\nbool valid(vector<int> v1, vector<int> v2) {\n\treturn (v1[0] >= v2[0] && v1[1] >= v2[1] && v1[2] >= v2[2] && v1[3] >= v2[3]) || (v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2] && v1[3] <= v2[3]);\n}\nvector<int> solve(int a, int b, int c, int d) {\n\tvector<vector<int> > v;\n\tint basemul = 1;\n\tint ret = 0;\n\tfor(int i = 0; basemul <= lim; ++i) {\n\t\tint bmul = basemul;\n\t\tfor (int j = 0; bmul <= lim; ++j) {\n\t\t\tint mul = bmul;\n\t\t\tfor (int k = 0; mul <= lim; ++k) {\n\t\t\t\tint smul = mul;\n\t\t\t\tfor (int l = 0; smul <= lim; ++l) {\n\t\t\t\t\t++ret;\n\t\t\t\t\tsmul *= d;\n\t\t\t\t\tv.push_back({ i, j, k, l });\n\t\t\t\t}\n\t\t\t\tmul *= c;\n\t\t\t}\n\t\t\tbmul *= b;\n\t\t}\n\t\tbasemul *= a;\n\t}\n\tsort(v.begin(), v.end());\n\tvector<bool> used(v.size());\n\tint cur = v.size() - 1;\n\tvector<vector<int> > seq;\n\twhile (true) {\n\t\tused[cur] = true;\n\t\tseq.push_back(v[cur]);\n\t\tint ncur = -1;\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tif (!used[i] && valid(v[cur], v[i])) {\n\t\t\t\tncur = i;\n\t\t\t}\n\t\t}\n\t\tif (ncur == -1) break;\n\t\tcur = ncur;\n\t}\n\tvector<int> ans;\n\tfor (vector<int> i : seq) {\n\t\tint mul = 1;\n\t\tfor (int j = 0; j < i[0]; ++j) mul *= a;\n\t\tfor (int j = 0; j < i[1]; ++j) mul *= b;\n\t\tfor (int j = 0; j < i[2]; ++j) mul *= c;\n\t\tfor (int j = 0; j < i[3]; ++j) mul *= d;\n\t\tans.push_back(mul);\n\t}\n\treturn ans;\n}\nint main() {\n\tvector<int> c1 = solve(2, 7, 17, 19);\n\tvector<int> c2 = solve(3, 5, 11, 13);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j) cout << ' ';\n\t\t\tcout << 1LL * c1[i] * c2[j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a*b/__gcd(a,b);\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=N;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t//\tcout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tint k=0;\n\tfor(int i=1;i<=n;i+=2){\n\t\tint x=i,y=1;\n\t\twhile(x>=1&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx--,y++;\n\t\t}\n\t\tk++;\n\t}\n\tfor(int j=n&1?3:2;j<=n;j+=2){\n\t\tint x=n,y=j;\n\t\twhile(x>=1&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx--,y++;\n\t\t}\n\t\tk++;\n\t}\n\t\n\tfor(int i=n&1?n:n-1;i>=1;i-=2){\n\t\tint x=1,y=i;\n\t\twhile(x<=n&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx++,y++;\n\t\t}\n\t\tk++;\n\t}\n\tfor(int i=3;i<=n;i+=2){\n\t\tint x=i,y=1;\n\t\twhile(x<=n&&y<=n){\n\t\t\tg[x][y]*=P[k];\n\t\t\tx++,y++;\n\t\t}\n\t\tk++;\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    int N;cin>>N;\n    rep(i,N){\n        rep(j,N){\n            if(j)cout<<\" \";\n            cout<<1+i+j;\n        }cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n3\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=30005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nbool isp[maxn];\nvector<int> p;\n\nll g[maxn][maxn];\n\nvector<int> a,b;\n\nll lcm(ll a,ll b){\n\tif(a==0||b==0) return a+b;\n\treturn a*b/__gcd(a,b);\n}\n\nint main()\n{\n\tIOS;\n\tint N=500;\n\n\tfor(int i=2;i<maxn;i++){\n\t\tif(!isp[i]) p.pb(i);\n\t\tfor(int j=0;i*p[j]<maxn;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tREP(i,500) a.pb(p[i]);\n\tREP(i,500) b.pb(p[i+500]);\n\n\tREP(i,500) REP(j,500) if((i+j)%2==0){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j)/2];\n\t\tg[i][j]*=b[(i-j+499)/2];\n\t}\n\n\tREP(i,500) REP(j,500) if((i+j)%2){\n\t\tg[i][j]=0;\n\n\t\tif(i+1<500) g[i][j]=lcm(g[i][j],g[i+1][j]);\n\t\tif(j+1<500) g[i][j]=lcm(g[i][j],g[i][j+1]);\n\t\tif(i) g[i][j]=lcm(g[i][j],g[i-1][j]);\n\t\tif(j) g[i][j]=lcm(g[i][j],g[i][j-1]);\n\t\tg[i][j]++;\n\t\tassert(g[i][j]<1e15);\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<g[i][j]<<\" \\n\"[j==n-1];\n\n\tREP(i,n) REP(j,n-1) assert(max(g[i][j],g[i][j+1])%min(g[i][j],g[i][j+1])==1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m int64_t\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nmain(){m n;cin>>n;m t=0,k=555;r(2,i,1e4){bool a=true;r(2,j,i){if(i%j==0)a=false;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\nusing namespace std;\n#define m int64_t\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nmain(){m n;cin>>n;m t=0,k=555;r(2,i,1e4){bool a=1;r(2,j,i){if(i%j==0)a=false;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[250+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X(i+j)*Y(abs(i-j));\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2)+1;\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a*b/__gcd(a,b);\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=7919;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t\t//cout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n#define int long long\nconst int N = (int) 505, mod = (int) 0;\nint res[N][N];\nint lcm(int x, int y) { return x / __gcd(x, y) * y; }\nint32_t main() {\n\tint n;\n\tcin >> n;\n\tint cnt = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tif ((i + j) & 1)\n\t\t\t\tres[i][j] = cnt * 2, cnt++;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (~(i + j) & 1) {\n\t\t\t\tint all = 1;\n\t\t\t\tif (i)\n\t\t\t\t\tall = lcm(res[i - 1][j], all);\n\t\t\t\tif (j)\n\t\t\t\t\tall = lcm(res[i][j - 1], all);\n\t\t\t\tif (i + 1 < n)\n\t\t\t\t\tall = lcm(res[i + 1][j], all);\n\t\t\t\tif (j + 1 < n)\n\t\t\t\t\tall = lcm(res[i][j + 1], all);\n\t\t\t\tres[i][j] = all + 1;\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcout << res[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\n#define MAX_N 100005\n#define int long long\nvector<int> prime;\nbool is_prime[MAX_N];\n\nvoid sieve(int n){\n    for(int i=0;i<=n;i++){\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2;i<=n;i++){\n        if(is_prime[i]){\n            prime.push_back(i);\n            for(int j=2*i;j<=n;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\n\n\nsigned main(){\n    sieve(100000);\n    map<int,int>p,q;\n    int id = 0;\n    for(int i=0;i<=600;i+=2){\n        p[500-i] = prime[id];\n        id++;\n        q[i] = prime[id];\n        id++;\n        if(i!=0){\n            p[500+i] = prime[id];\n            id++;\n            q[-i] = prime[id];\n            id++;\n        }\n    }\n    int n;\n    cin >> n;\n    vector<vector<ll> > a(n,vector<ll>(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if((i+j)%2==0){\n                a[i][j] = p[i+j]*q[i-j];\n            }\n        }\n    }\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if((i+j)%2==1){\n                ll s = 1;\n                if(i!=0){\n                    s = lcm(s,a[i-1][j]);\n                }\n                if(i!=n-1){\n                    s = lcm(s,a[i+1][j]);\n                }\n                if(j!=0){\n                    s = lcm(s,a[i][j-1]);\n                }\n                if(j!=n-1){\n                    s = lcm(s,a[i][j+1]);\n                }\n                s+=1;\n                a[i][j] = s;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            // if(a[i][j]>=1e15){\n            //     cout << \"ERROR \" << a[i][j] << endl;\n            //     return 0;\n            // }\n            cout << a[i][j];\n            if(j!=n-1){\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 260) t++;\n    rep(i, n) p.eb(P[t++]);\n    random_shuffle(all(p));\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    ll pre = 1;\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * pre * pre * (i * 2);\n            } else\n                a[x][y] = p[(x + y) / 2] * i * 2;\n        }\n        pre = i * 2;\n    }\n    pre = 1;\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] + a[x][y + 1] * pre * pre * i * 2;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i * 2 + 1);\n        }\n        pre = i * 2 + 1;\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,sz;\nint a[10101],d[10101];\nlong long an[1010][1010];\nvoid init(int N)\n{\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!d[i])a[++sz]=i;\n\t\tfor(int j=1;j<=sz&&a[j]*i<=N;j++)\n\t\t{\n\t\t\td[i*a[j]]=1;\n\t\t\tif(i%a[j]==0) break;\n\t\t}\n\t}\n}\nlong long gcd(long long x,long long y){ return y?gcd(y,x%y):x;}\nlong long lcm(long long x,long long y)\n{\n\tif(!x||!y) return x+y;\n\treturn x/gcd(x,y)*y;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tinit(10000);\n\tif(n==2)\n\t{\n\t\tan[1][1]=4;an[1][2]=7;an[2][1]=23;an[2][2]=10;\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\tan[i][j]=1LL*a[(i+j)/2]*a[(i-j+n)/2+1+n];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)^1)\n\t\t\t\tan[i][j]=lcm(lcm(an[i-1][j],an[i+1][j]),lcm(an[i][j-1],an[i][j+1]))+1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tprintf(\"%lld \",an[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,sz;\nint a[10101],d[10101];\nlong long an[1010][1010];\nvoid init(int N)\n{\n\tfor(int i=2;i<=N;i++)\n\t{\n\t\tif(!d[i])a[++sz]=i;\n\t\tfor(int j=1;j<=sz&&a[j]*i<=N;i++)\n\t\t{\n\t\t\td[i*a[j]]=1;\n\t\t\tif(i%a[j]==0) break;\n\t\t}\n\t}\n}\nlong long gcd(long long x,long long y){ return y?gcd(y,x%y):x;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tinit(10000);\n\tif(n==2)\n\t{\n\t\tan[1][1]=4;an[1][2]=7;an[2][1]=23;an[2][2]=10;\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tint x=(i+j)/2,y=(i-j+n)/2+1;\n\t\t\t\tan[i][j]=1LL*a[x]*a[y+n];\n\t\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)^1)\n\t\t\t{\n\t\t\t\tlong long lcm=1;\n\t\t\t\tif(i!=1) lcm=lcm/gcd(lcm,an[i-1][j])*an[i-1][j];\n\t\t\t\tif(i!=n) lcm=lcm/gcd(lcm,an[i+1][j])*an[i+1][j];\n\t\t\t\tif(j!=1) lcm=lcm/gcd(lcm,an[i][j-1])*an[i][j-1];\n\t\t\t\tif(j!=n) lcm=lcm/gcd(lcm,an[i][j+1])*an[i][j+1];\n\t\t\t\tan[i][j]=lcm+1;\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\tprintf(\"%lld \",an[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nlong long gcd(re long long a,re long long b){return b?gcd(b,a%b):a;}\nlong long lcm(re long long a,re long long b){return a/gcd(a,b)*b;}\nlong long a[510][510],pri[1010],cnt;\nbool vis[100100];\nint main()\n{\n\tre int n;\n\tscanf(\"%d\",&n);\n\tif(n==2){puts(\"4 7\\n23 10\");}\n\tfor(re int i=2;cnt<=1000;i++)\n\t{\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tfor(re int j=1;j<=cnt&&i*pri[j]<=100000;j++)\n\t\t{\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(re int i=-n+1+(!(n&1)),i1=1;i<n;i+=2,i1++)\n\t{\n\t\tfor(re int j=1;j<=n&&i+j<=n;j++)if(i+j>0)a[j][i+j]=pri[i1];\n\t}\n\tfor(re int i=2,i1=n+1;i<=2*n;i+=2,i1++)\n\t{\n\t\tfor(re int j=1;j<=n&&i-j>0;j++)a[j][i-j]*=pri[i1];\n\t}\n\tfor(re int i=1;i<=n;i++)a[i][0]=a[0][i]=a[i][n+1]=a[n+1][i]=1;\n\tfor(re int i=1;i<=n;i++,puts(\"\"))for(re int j=1;j<=n;j++)\n\t{\n\t\tif(!a[i][j])a[i][j]=lcm(lcm(a[i+1][j],a[i-1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\t\tprintf(\"%lld \",a[i][j]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N=1000;\n\tvvl d(N+4,vl(N+4,1));\n\tvi p=primes(100000);\n\tfr(i,N/4+1){\n\t\tfr(j,N+4){\n\t\t\td[4*i][j]*=p[2*i];\n\t\t\td[j][4*i]*=p[2*i+1];\n\t\t\td[4*i+2][j]*=p[N-2*i-1];\n\t\t\td[j][4*i+2]*=p[N-2*i-2];\n\t\t}\n\t}\n\tfr(i,N/2){\n\t\tfr(j,N/2){\n\t\t\td[i*2+1][j*2+1]=d[i*2][j*2]*d[i*2+2][j*2+2]+1;\n\t\t}\n\t}\n\tcin>>N;\n\tfr(i,N){\n\t\tfr(j,N){\n\t\t\tcout<<d[i+j][500-i+j]<<\" \\n\"[j==N-1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n\n    for ( int i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n\n}\n\n\nlong long cmmdc ( long long a , long long b ){\n\n    while ( b ){\n        long long t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\nlong long calcLCM ( long long a , long long b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int i = 0 ; i < 2 * noLin ; i+=1 ){\n        diagPrin [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < 2 * noLin ; i+=2 ){\n        diagSec [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < noLin ; i+=1 ){\n        for ( int j = 0 ; j < noLin ; j+=1 ){\n            int crPrin = j - i + noLin - 1 ;\n            int crSec = 2*noLin - i - j - 1 ;\n\n            mat [ i ][ j ] = diagPrin [ crPrin ] * diagSec [ crSec ];\n        }\n    }\n\n    int jj = 0 ;\n    if ( noLin == 2 ){\n        int jj= 1 ;\n    }\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = jj ; j < noLin ; j++ ){\n\n            long long  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <set>\n#include <list>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\n#define fi first\t\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\n\nvector<long> vec;\nbool prime(int x)\n{\n\tfor(int i = 2; i <= sqrt(x); i++)\n\t{\n\t\tif(x%i == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\nlong MAXN = 500;\nlong A[503][503];\nlong gcd(long a, long b) {return (b)? gcd(b,a%b) : a;}\nlong lcm(long a, long b) \n{\n\tif(a == b && b == 0) return 0;\n\telse if(a == 0) return b;\n\telse if(b == 0) return a;\n\telse return a/gcd(a,b)*b;\n}\n\nint main()\n{\n\t// ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\n\tfor(int i = 2; i <= 10000; i++)\n\t\tif(prime(i))\n\t\t\tvec.push_back(i);\n\n\tint idx = 0;\n\tfor(int i = 1; i <= MAXN; i+=2)\n\t{\n\t\tint x = 1, y = i;\n\t\twhile(y <= MAXN)\n\t\t\tA[x++][y++] = vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = 3; i <= MAXN; i+=2)\n\t{\n\t\tint x = i, y = 1;\n\t\twhile(x <= MAXN)\n\t\t\tA[x++][y++] = vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = 1; i <= MAXN; i+=2)\n\t{\n\t\tint x = 1, y = i;\n\t\twhile(y >= 1 && x <= MAXN)\n\t\t\tA[x++][y--] *= vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = MAXN; i >= 3; i-=2)\n\t{\n\t\tint x = i, y = MAXN;\n\t\twhile(y >= 1 && x <= MAXN)\n\t\t\tA[x++][y--] *= vec[idx];\n\t\tidx++;\n\t}\n\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(A[i][j] == 0) A[i][j] = lcm(lcm(A[i-1][j],A[i][j-1]),lcm(A[i+1][j],A[i][j+1]))+1;\n\t\t\tprintf(\"%lld\", A[i][j]);\n\t\t\tif(j < n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001], prm[2003];\nint vis[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tmap<ll, ll> bal;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (bal.find(j - i) != bal.end()) {\n\t\t\t\t\tans[i][j] = bal[j - i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = d.front();\n\t\t\t\t\td.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbal.clear();\n\tfor (int i =  n - 1; i >= 0; i--) {\n\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (bal.find(j + i) != bal.end()) {\n\t\t\t\t\tans[i][j] = bal[j + i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = d.front();\n\t\t\t\t\td.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = ml * (ans[i][j - 1] / gcd(ml, ans[i][j - 1]));\n\t\t\t\tif (i < n - 1) ml = ml * (ans[i + 1][j] / gcd(ml, ans[i + 1][j]));\n\t\t\t\tif (j < n - 1) ml = ml * (ans[i][j + 1] / gcd(ml, ans[i][j + 1]));\n\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define ll long long\nusing namespace std;\nconst int N=505,M=10000;\nint n,p[M+5],p2[M+5],mu[M+5],ps;\nll a[N][N],h[N],l[N];\nbool b[M+5];\nll gcd(ll x,ll y){\n\tfor(;y;y%=x)swap(x,y);\n\treturn x;\n}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint main(){\n\tn=500;\n\tfo(i,2,M){\n\t\tif(!b[i])p[++ps]=i,mu[i]=1;\n\t\tfor(int j=1,u;(u=i*p[j])<=M;++j){\n\t\t\tb[u]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t\tmu[u]=mu[i];\n\t\t}\n\t}\n\tps=0;\n\tfor(int i=2;i<=n+n;i+=2){\n\t\t++ps;\n\t\tfo(j,max(1,i-n),min(n,i-1)){\n\t\t\tint k=i-j;\n\t\t\ta[j][k]=p[ps];\n\t\t}\n\t}\n\t\n\tfor(int i=n-2;i>=2-n;i-=2){\n\t\t++ps;\n\t\tfo(j,max(i+1,1),min(n,n+i)){\n\t\t\tint k=j-i;\n\t\t\ta[j][k]*=p[ps];\n\t\t}\n\t}\n\t\n\tfo(i,1,n)fo(j,1,n)if(i+j&1){\n\t\ta[i][j]=1;\n\t\tif(i>1)a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\tif(i<n)a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\tif(j>1)a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\tif(j<n)a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t++a[i][j];\n\t}\n\tcin>>n;\n\tfo(i,1,n){\n\t\tfo(j,1,n)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\ntypedef v(vl) vvl;\nconst int di[] = {-1,0,1,0}, dj[] = {0,-1,0,1}; //^<v>\n//const int di[] = {-1,0,1,-1,1,-1,0,1}, dj[] = {-1,-1,-1,0,0,1,1,1};\n\n#define bsf __builtin_ctzll\nll gcd(ll a, ll b) {\n  // a = abs(a); b = abs(b);\n  if (!a || !b) return a|b;\n  int t = bsf(a|b); a >>= bsf(a);\n  do { b >>= bsf(b); if (a > b) swap(a, b); b -= a;} while (b);\n  return a << t;\n}\nll lcm(ll x, ll y) { return x/gcd(x,y)*y;}\n// linear sieve\nvi ps, pf;\nvoid sieve(int mx) {\n  pf = vi(mx);\n  rep(i,mx) pf[i] = i;\n  for (int i = 2; i < mx; ++i) {\n    if (pf[i] == i) ps.pb(i);\n    for (int j = 0; j < sz(ps) && ps[j] <= pf[i]; ++j) {\n      int x = ps[j]*i;\n      if (x >= mx) break;\n      pf[x] = ps[j];\n    }\n  }\n}\ninline bool isp(int x) { return pf[x] == x && x >= 2;}\nvi factor(int x) { // asc\n  vi res;\n  while (x != 1) {\n    res.pb(pf[x]);\n    x /= pf[x];\n  }\n  return res;\n}\n//\n\n\n\nint main() {\n  int n = 500;\n  scanf(\"%d\",&n);\n  if (n == 2) {\n    cout<<\"4 7\"<<endl;\n    cout<<\"23 10\"<<endl;\n    return 0;\n  }\n  sieve(MX);\n  int xs = 0, ys = 0;\n  rep(i,n)rep(j,n) {\n    if (~(i+j)&1) continue;\n    int x = (j+(n-1-i))/2;\n    int y = (i+j)/2;\n    maxs(xs,x);\n    maxs(ys,y);\n  }\n  ++xs; ++ys;\n  vi px, py;\n  rep(i,xs) px.pb(ps[i*2]);\n  rep(i,ys) py.pb(ps[i*2+1]);\n  vi sx, sy;\n  while (sz(px)) {\n    sx.pb(px.back());\n    px.pop_back();\n    reverse(rng(px));\n  }\n  while (sz(py)) {\n    sy.pb(py.back());\n    py.pop_back();\n    reverse(rng(py));\n  }\n\n  vvl ans(n,vl(n,1));\n  rep(i,n)rep(j,n) {\n    if (~(i+j)&1) continue;\n    int x = (j+(n-1-i))/2;\n    int y = (i+j)/2;\n    ans[i][j] = sx[x]*sy[y];\n  }\n  // cerr<<ans<<endl;\n\n  ll mx = 0;\n  rep(i,n)rep(j,n) {\n    if ((i+j)&1) continue;\n    rep(v,4) {\n      int ni = i+di[v], nj = j+dj[v];\n      if (ni<0||nj<0||ni>=n||nj>=n) continue;\n      ans[i][j] = lcm(ans[i][j],ans[ni][nj]);\n    }\n    ans[i][j]++;\n    maxs(mx, ans[i][j]);\n  }\n  // cerr<<mx<<endl;\n  // cerr<<ll(1e15)<<endl;\n\n  // set<ll> st;\n  // rep(i,n)rep(j,n) st.insert(ans[i][j]); assert(sz(st) == n*n);\n\n  rep(i,n) cout<<ans[i]<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n \n//long long gcd(long long a,long long b)\n//{\n//\tif (b==0) return a;\n//\treturn gcd(b,a%b);\n//}\n \nlong long lcm(long long x, long long y) \n{\n\tif (x==0 || y==0) return x+y;\n\treturn x/__gcd(x,y)*y;\n}\n//long long lcm(long long a,long long b)\n//{\n//\treturn a*b/__gcd(a,b);\n//}\n \nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(!ans[i][j]) \n\t\t\t{\n\t\t\t\tans[i][j]=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i][j+1],ans[i+1][j]))+1;\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int i=1;i<=n;i++)\n//\t{\n//\t\tfor (int j=1;j<=n;j++)\n//\t\t{\n//\t\t\tif ((i+j)%2==1)\n//\t\t\t{\n//\t\t\t\tlong long op=0;\n//\t\t\t\tfor (int k=0;k<=3;k++)\n//\t\t\t\t{\n//\t\t\t\t\tint x=i+fx[k][0];\n//\t\t\t\t\tint y=j+fx[k][1];\n//\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n//\t\t\t\t\t{\n//\t\t\t\t\t\tif (op==0) op=ans[x][y];\n//\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tans[i][j]=op+1;\n//\t\t\t}\n//\t\t}\n//\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nll gcd(ll a,ll b){\n    if(a%b==0){return b;}\n    return gcd(b,a%b);\n}\n\nll lcm(vector<ll> &A){\n    ll ret=1;\n    for(int i=0;i<A.size();i++){\n        ret/=gcd(ret,A[i]);\n        ret*=A[i];\n    }\n    return ret;\n}\n\n\n\n\nint main(){\n    ll mx=100000;\n    vector<bool> A(mx,1);\n    vector<ll> P;\n    for(ll i=2;i<mx;i++){\n        if(A[i]){\n            for(ll t=1;i*t<mx;t*=i){\n                P.push_back(i*t);\n            }\n            for(ll t=2;i*t<mx;t++){\n                A[i*t]=0;\n            }\n        }\n    }\n    sort(P.begin(),P.end());\n    vector<vector<ll>> a(500,vector<ll>(500,1));\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if((i+t)&1){\n                a[i][t]*=P[(i+t)/2];\n            }\n            if((i-t)&1){\n                a[i][t]*=P[750+(i-t)/2];\n            }\n        }\n    }\n    vector<ll> dx={0,1,0,-1};\n    vector<ll> dy={1,0,-1,0};\n    for(int i=0;i<500;i++){\n        for(int t=0;t<500;t++){\n            if(a[i][t]==1){\n                vector<ll> A;\n                for(int h=0;h<4;h++){\n                    ll x=i+dx[h];\n                    ll y=t+dy[h];\n                    if(x<0 || y<0 || x>=500 || y>=500){continue;}\n                    A.push_back(a[x][y]);\n                }\n                a[i][t]=lcm(A);\n            }\n        }\n    }\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<a[i][t];\n            if(t+1!=n){cout<<\" \";}\n        }\n        cout<<endl;\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>//\tTはintかll\nT gcd(T a, T b) {//\t最大公約数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tif (a < b) {\n\t\treturn gcd(a, b % a);\n\t}\n\treturn gcd(b, a % b);\n}\ntemplate <typename T>//\tTはintかll\nT gcd(int size, T* a) {//\t配列の最大公約数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tT c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = gcd(c, a[i]);\n\t\tif (c == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate <typename T>//\tTはintかll\nll lcm(T a, T b) {//\t最小公倍数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tll x = a;\n\tx /= gcd(a, b);\n\tx *= b;\n\treturn x;\n}\ntemplate <typename T>//\tTはintかll\nll lcm(int size, T* a) {//\t配列の最小公倍数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tll c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = lcm(c, (ll)a[i]);\n\t}\n\treturn c;\n}\n\nbool f[20000] = {};\n\nint main() {\n\tf[0] = false;\n\tf[1] = false;\n\tf[2] = true;\n\tfor (int i = 3; i < 20000; i++) {\n\t\tf[i] = (i % 2 == 1);\n\t}\n\tfor (int i = 3; i < 20000; i++) {\n\t\tif (f[i] == false) { continue; }\n\t\tfor (int j = i * 2; j < 20000; j += i) {\n\t\t\tf[j] = false;\n\t\t}\n\t}\n\tvector<ll> v;\n\tfor (int i = 0; i < 20000; i++) {\n\t\tif (f[i] == true) {\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\n\tint N = 500;\n\tll** ans = new ll * [N];\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = new ll[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tans[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = v[abs(1000 - 2 * (i + j) + 1) + 1] * v[abs(1000 - 2 * (i - j + N) + 1)];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tll c = 1;\n\t\t\t\tif (i > 0) { c = lcm(c, ans[i - 1][j]); }\n\t\t\t\tif (j > 0) { c = lcm(c, ans[i][j - 1]); }\n\t\t\t\tif (i < N - 1) { c = lcm(c, ans[i + 1][j]); }\n\t\t\t\tif (j < N - 1) { c = lcm(c, ans[i][j + 1]); }\n\n\t\t\t\tans[i][j] += c;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=10005;\nconst int MAXM=505;\nint pr[MAXN],is[MAXN],plen;\nvoid getpr()\n{\n\tfor(int i=2;i<MAXN;i++)\n\t{\n\t\tif(!is[i])pr[++plen]=i;\n\t\tfor(int j=1;j<=plen&&i*pr[j]<MAXN;j++)\n\t\t{\n\t\t\tis[i*pr[j]]=1;\n\t\t\tif(!(i%pr[j]))break;\n\t\t}\n\t}\n}\nint n,vis[MAXM][MAXM],now;LL a[MAXM][MAXM],b[MAXM][MAXM];\nLL gcd(LL a,LL b){return a==0?b:gcd(b%a,a);}\nvoid get1(int x,int y)\n{\n\tif(x>n||y>n)return ;\n\tvis[x][y]=1;a[x][y]*=pr[now];\n\tget1(x+1,y+1);\n}\nvoid get2(int x,int y)\n{\n\tif(x<1||x>n||y<1||y>n)return ;\n\tvis[x][y]=1;a[x][y]*=pr[now];\n}\nbool in(int x,int y){return x>=1&&x<=n&&y>=1&&y<=n;}\nLL lcm(LL a,LL b){return a/gcd(a,b)*b;}\nint main()\n{\n\tgetpr();\t\n\tn=read();now=0;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)a[i][j]=1;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(((i+j-1)&1)&&!vis[i][j])\n\t\t++now,get1(i,j);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(((i+j-1)&1)&&!vis[i][j])\n\t\t++now,get2(i,j);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(!((i+j-1)&1))\n\t{\n\t\tif(in(i-1,j))a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\tif(in(i+1,j))a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\tif(in(i,j-1))a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\tif(in(i,j+1))a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t++a[i][j];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)pr1(a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int maxN = 500;\n\nlong long gcd(long long a, long long b){\n    return a%b ? gcd(b, a%b) : b;\n}\n\nlong long lcm(long long a, long long b){\n    return a/gcd(a, b)*b;\n}\n\nvector<vector<int>> getPrimes(){\n    vector<int> p(100000, 1);\n    vector<int> primes;\n    for(int i=2;;i++){\n        if(!p[i]) continue;\n        primes.push_back(i);\n        if(primes.size() == 4 * maxN) break;\n        for(int j=2*i;j<100000;j+=i) p[j] = 0;\n    }\n    vector<vector<int>> res(2, vector<int>(2*maxN));\n    int seek = 0;\n    for(int i=0;i<maxN;i++){\n        res[0][2*i] = primes[seek];\n        res[0][2*i+1] = primes[3*maxN-1-seek];\n        ++seek;\n    }\n    for(int i=0;i<2*maxN;i++){\n        if(i < maxN/4 || maxN/4*7 <= i){\n            res[1][i] = res[0][i];\n        } else {\n            if(i%2 == 0){\n                res[1][i] = primes[seek];\n            } else {\n                res[1][i] = primes[3*maxN-1-seek];\n                ++seek;\n            }\n        }\n    }\n    return res;\n}\n\nvector<vector<long long>> makeBoard(){\n    vector<vector<long long>> res(maxN, vector<long long>(maxN, 0));\n    auto primes = getPrimes();\n    for(int i=0;i<maxN;i++){\n        for(int j=i%2;j<maxN;j+=2){\n            int idxA = (i+j)/2;\n            int idxB = (i-j+maxN-2)/2;\n            res[i][j] = (long long)primes[0][idxA] * primes[1][idxB];\n        }\n    }\n    for(int i=0;i<maxN;i++){\n        for(int j=1-i%2;j<maxN;j+=2){\n            res[i][j] = 1;\n            int dx[] = {-1, 0, 1, 0};\n            int dy[] = {0, -1, 0, 1};\n            for(int k=0;k<4;k++){\n                int nx = i + dx[k];\n                int ny = j + dy[k];\n                if(nx < 0 || maxN <= nx || ny < 0 || maxN <= ny) continue;\n                res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n            ++res[i][j];\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N;\n    auto board = makeBoard();\n    while(cin >> N){\n        for(int i=0;i<N;i++){\n            cout << board[i][0];\n            for(int j=1;j<N;j++) cout << \" \" << board[i][j];\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\"-Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){int ret=1;do{if(y&1)ret=(ll)ret*x%md;x=(ll)x*x%md;}while(y>>=1);return ret;}\ninline int Rand(){return rand()*32768+rand();}\nint n;\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcout<<2+(i+j)%2<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nbool notp[MAXN*MAXN];\nint prm[MAXN*MAXN],pn;\nvoid euler(int n)\n{\n\tnotp[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(!notp[i])prm[++pn]=i;\n\t\tfor(int j=1;j<=pn && i*prm[j]<=n;++j)\n\t\t{\n\t\t\tnotp[i*prm[j]]=1;\n\t\t\tif(!(i%prm[j]))break;\n\t\t}\n\t}\n}\nll a[MAXN][MAXN];\ninline ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nunordered_set<ll> s;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\teuler(n*500);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!((i+j)&1))\n\t\t\t\ta[i][j]=prm[(i+j)/2]*prm[(i-j+n+1)/2+n];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))continue;\n\t\t\ta[i][j]=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\ta[i][j]=lcm(a[i][j],a[x][y]);\n\t\t\t}\n\t\t\tll x=a[i][j];\n\t\t\twhile(s.count(a[i][j]))a[i][j]+=x;\n\t\t\ts.insert(a[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%d \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nll a[MAXN][MAXN],prime[MAXN];\nbool check(int x)\n{\n\tfor (int i=2;1ll*i*i<=x;i++)\n\t\tif (x%i==0) return 0;\n\treturn 1;\n}\nint main()\n{\n\tint n=read(),num=0;\n\tif (n==2) { printf(\"4 7\\n23 10\\n\"); return 0; }\n\tfor (int i=2;i<=100000;i++)\n\t\tif (check(i))\n\t\t{\n\t\t\tprime[++num]=i;\n\t\t\tif (num==n<<1) break;\n\t\t}\n\tfor (int i=0;i<=n+1;i++)\n\t\tfor (int j=0;j<=n+1;j++) a[i][j]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i&1)^(j&1)) continue;\n\t\t\ta[i][j]=prime[(i+j)>>1]*prime[n+((i-j+n+1)>>1)];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i&1)^(j&1)) a[i][j]=max(a[i-1][j]*a[i+1][j],a[i][j-1]*a[i][j+1])+1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=502;\nconst int inf=1e15;\nvector<int> lis,lis1;\nint ar[N][N];\nint LCM(int x,int y){\n  return (x/__gcd(x,y))* y;\n}\nint dx[]={0,0,-1,1},dy[]={-1,1,0,0};\nsigned main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  srand(time(0));\n  int n,m,i,j,k,l,num=0,now;\n  cin>>n;\n  for(i=1;i<=n;i++){\n    ar[0][i]=1;\n    ar[i][0]=1;\n    ar[i][n+1]=1;\n    ar[n+1][i]=1;\n    for(j=1;j<=n;j++){\n      if(((i+j)&1)){\n        num++;\n      }\n    }\n  }\n  //cout<<num<<endl;\n  for(i=2;i<=num+1;i++){\n    lis.push_back(i);\n  }\n  if(n==2){\n    cout<<\"4 7\\n23 10\";\n    return 0;\n  }\n  //cout<<LCM(1,3)<<endl;\n  for(i=1;i<=50;i++){\n   \tlis1.clear();\n    l=lis.size();\n    for(j=0;j<lis.size();j++){\n      swap(lis[j],lis[(1ll*rand()*rand())%l]);\n    }\n    l=0;\n    for(j=1;j<=n;j++){\n      for(k=1;k<=n;k++){\n        if(((j+k)&1)){\n          ar[j][k]=lis[l];\n          //cout<<lis[l]<<endl;\n          l++;\n        }\n      }\n    }\n    for(j=1;j<=n;j++){\n      for(k=1;k<=n;k++){\n        if(((j+k)&1)){\n          continue;\n        }\n        now=1;\n        for(l=0;l<4;l++){\n          if(now/__gcd(now,ar[j+dx[l]][k+dy[l]])>inf/ar[j+dx[l]][k+dy[l]]){\n            now=inf+1;\n          }\n          else{\n          \tnow=LCM(now,ar[j+dx[l]][k+dy[l]]);\n          }\n        }\n        if(now!=inf+1){\n        \tar[j][k]=now*((1ll*rand()*rand())%(inf/now)+1)+1;\n        \tlis1.push_back(ar[j][k]);\n        }\n        else{\n          ar[j][k]=now+1;\n          lis1.push_back(now+1);\n        }\n        //cout<<now+1<<' '<<\"wtf\"<\n      }\n    }\n    sort(lis1.begin(),lis1.end());\n    //cout<<lis1.size()<<endl;\n    lis1.erase(unique(lis1.begin(),lis1.end()),lis1.end());\n    //cout<<lis1.size()<<' '<<lis.size()<<endl;\n    if(lis1.size()+lis.size()==n*n&&lis1[lis1.size()-1]<=inf){\n      for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n          cout<<ar[i][j]<<' ';\n        }\n        cout<<'\\n';\n      }\n      return 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,nw[510],cnt,N;\nlong long ans[510][510],h[510],l[510];\nmap<long long,int> ma;\n\nlong long gcd(long long a,long long b) {return (!b)?a:gcd(b,a%b);}\nlong long lcm(long long a,long long b) {return a/gcd(a,b)*b;}\n\nint main()\n{\n\tsrand(19260817),scanf(\"%d\",&N),cnt=0,n=501;\n\tfor (int i=1; i<=n; i+=2) cnt+=2;\n\tfor (int i=1; i<=cnt; i++) nw[i]=2*i+1;\n\trandom_shuffle(nw+1,nw+1+cnt);\n\tfor (int i=1; i<=n; i+=2) h[i]=nw[i];\n\tfor (int i=1; i<=n; i+=2) l[i]=nw[i+1];\n\tfor (int i=2; i<=n; i+=2) h[i]=h[i-1]*h[i+1],l[i]=l[i-1]*l[i+1];\n\tfor (int i=0; i<=n+1; i++) ans[i][0]=ans[i][n+1]=ans[0][i]=ans[n+1][i]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=2-(i&1); j<=n; j+=2) ans[i][j]=h[i]*l[j];\n\tma.clear();\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=(i&1)+1; j<=n; j+=2) \n\t\t{\n\t\t\tlong long nw=lcm(lcm(lcm(ans[i-1][j],ans[i+1][j]),ans[i][j-1]),ans[i][j+1]);\n\t\t\tans[i][j]=nw+1;\n\t\t\twhile (ma[ans[i][j]]) ans[i][j]+=nw;\n\t\t\tma[ans[i][j]]=1;\n\t\t}\n\tfor (int i=1; i<=N; i++,puts(\"\"))\n\t\tfor (int j=1; j<=N; j++) printf(\"%lld \",ans[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e4 + 5;\ntypedef long long ll;\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint tot, prime[MAXN], f[MAXN];\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (f[i] == 0) prime[++tot] = f[i] = i;\n\t\tfor (int j = 1; j <= tot && prime[j] <= f[i]; j++) {\n\t\t\tint tmp = prime[j] * i;\n\t\t\tif (tmp > n) break;\n\t\t\tf[tmp] = prime[j];\n\t\t}\n\t}\n}\nint a[MAXN], b[MAXN];\nint main() {\n\tint n; read(n), sieve(1e4);\n\tint now = 1;\n\tfor (int i = 0; i <= n + 1; i++) {\n\t\ta[i] = prime[now];\n\t\tif (i & 1) now++;\n\t}\n\tnow++;\n\tfor (int i = 0; i <= n + 1; i++) {\n\t\tb[i] = prime[now];\n\t\tif (i & 1) now++;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) & 1) {\n\t\t\t\tif (i & 1) printf(\"%lld \", 2ll * a[i - 1] * a[i + 1] * b[j - 1] * b[j + 1] + 1);\n\t\t\t\telse printf(\"%lld \", 4ll * a[i - 1] * a[i + 1] * b[j - 1] * b[j + 1] + 1);\t\n\t\t\t} else {\n\t\t\t\tif (i & 1) printf(\"%lld \", 1ll * a[i] * b[j]);\n\t\t\t\telse printf(\"%lld \", 2ll * a[i] * b[j]);\n\t\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd (ll p, ll q) {\n  if (q == 0) return p;\n  return gcd(q, p % q);\n}\n\nll lcm (ll p, ll q) {\n  ll gc = gcd(p, q);\n  p /= gc;\n  return p * q;\n}\n\nvector<ll> transf (vector<ll> v) {\n  vector<ll> u;\n  while ((int) v.size() > (int) u.size()) {\n    ll x = v.back();\n    v.pop_back();\n    u.push_back(x);\n  }\n\n  vector<ll> ans;\n  for (int i = 0; i < (int) max(u.size(), v.size()); i++) {\n    if (i < (int) u.size()) ans.push_back(u[i]);\n    if (i < (int) v.size()) ans.push_back(v[i]);\n  }\n\n  return ans;\n}\n\nconst int MAX_P = 1e5 + 5;\nconst int MAX_N = 505;\n\nint sieve [MAX_P];\nll grid [MAX_N][MAX_N];\nint ni [4] = {1, 0, -1, 0};\nint nj [4] = {0, 1, 0, -1};\n\nint main () {\n  vector<int> primes;\n  for (int i = 2; i < MAX_P; i++) {\n    if (!sieve[i]) {\n      if (i > 7) primes.push_back(i);\n      for (int j = i; j < MAX_P; j += i) {\n        sieve[j] = 1;\n      }\n    }\n  }\n  \n  int n;\n  cin >> n;\n\n  int ptr = 0;\n  vector<ll> rowpot;\n  vector<ll> colpot;\n  while ((int) rowpot.size() < (n + 20) / 2) {\n    rowpot.push_back(primes[ptr]);\n    ptr++;\n    colpot.push_back(primes[ptr]);\n    ptr++;\n  }\n\n  rowpot = transf(rowpot);\n  colpot = transf(colpot);\n\n  vector<ll> rows;\n  vector<ll> cols;\n  int sgn = 0;\n  for (ll p : rowpot) {\n    rows.push_back(p);\n    if (sgn) {\n      rows.push_back(2 * p);\n    } else {\n      rows.push_back(5 * p);\n    }\n    sgn = !sgn;\n  }\n\n  sgn = 0;\n  for (ll q : colpot) {\n    cols.push_back(q);\n    if (sgn) {\n      cols.push_back(3 * q);\n    } else {\n      cols.push_back(7 * q);\n    }\n    sgn = !sgn;\n  }\n\n  for (int i = 0; i <= n + 1; i++) {\n    for (int j = 0; j <= n + 1; j++) {\n      grid[i][j] = 1;\n    }\n  }\n\n  for (int i = 0; i <= n + 1; i++) {\n    for (int j = 0; j <= n + 1; j++) {\n      if ((i + j) % 2 == 0) {\n        grid[i][j] = rows[i] * cols[j];\n      }\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if ((i + j) % 2 == 1) {\n        for (int k = 0; k < 4; k++) {\n          grid[i][j] = lcm(grid[i][j], grid[i + ni[k]][j + nj[k]]);\n        }\n        grid[i][j]++;\n      }\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      cout << grid[i][j] << \" \";\n    }\n    cout << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fr(i, n) for (int i = 0; i < n; i++)\n#define pb push_back\n#define frab(i, a, b) for (int i = a; i < b; i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-9;\nconst int N = 1e3 + 10;\n\nll a[N][N];\n\nvector <ll> primes;\n\nbool prime(int x) {\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nll f(int i, int j, int n) {\n    ll cur = 1;\n    if (i)\n        cur *= (a[i - 1][j]) / __gcd(cur, a[i - 1][j]);\n    if (i + 1 < n)\n        cur *= (a[i + 1][j]) / __gcd(cur, a[i + 1][j]);\n    if (j)\n        cur *= (a[i][j - 1]) / __gcd(cur, a[i][j - 1]);\n    if (j + 1 < n)\n        cur *= (a[i][j + 1]) / __gcd(cur, a[i][j + 1]);\n    return cur + 1;\n}\n\nvoid check(int n) {\n    set <ll> s;\n    fr(i, n)\n        fr(j, n) {\n            s.insert(a[i][j]);\n            assert(a[i][j] > 0 && a[i][j] < 1e15);\n        }\n    assert(s.size() == n * n);\n    fr(i, n)\n        fr(j, n) {\n            if (i + 1 < n)\n                assert(max(a[i][j], a[i + 1][j]) % min(a[i][j], a[i + 1][j]) == 1);\n            if (j + 1 < n)\n                assert(max(a[i][j], a[i][j + 1]) % min(a[i][j], a[i][j + 1]) == 1);\n        }\n    return;\n}\n\nint main() {\n    //freopen(\"a.in\", \"r\", stdin);\n    int n;\n    scanf(\"%d\", &n);\n    int i = 2;\n    while (primes.size() < 4 * n + 10)\n        if (prime(i++))\n            primes.pb(i - 1);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if ((i + j) % 2 == 0) {\n                a[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + n / 2 + n];\n            }\n    fr(i, n)\n        fr(j, n)\n            if ((i + j) % 2)\n                a[i][j] = f(i, j, n);\n    if (n == 2)\n        a[0][1] = (a[0][1] - 1) * 2 + 1;\n    fr(i, n)\n        fr(j, n)\n            cout << a[i][j] << (j == n - 1 ? \"\\n\" : \" \");\n    check(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 505;\nconst int MP = 10005;\n\nint n, pnum;\nll x[MX][MX], prm[MP];\nbool vis[MP];\n\nll lcm(ll x, ll y)\n{\n\treturn x*y/__gcd(x, y);\n}\n\nvoid sieve()\n{\n\tfor(int i=2; i<MP; i++)\n\t{\n\t\tif(!vis[i]) prm[++pnum] = i;\n\t\tfor(int j=1; j<=pnum; j++)\n\t\t{\n\t\t\tif(prm[j]*i >= MP) break;\n\t\t\tvis[prm[j]*i] = 1;\n\t\t\tif(i%prm[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsieve();\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<=n+1; i++) x[i][0] = x[i][n+1] = x[0][i] = x[n+1][i] = 1;\n\tint t = 0;\n\tfor(int i=0; i<=n+1; i++)\n\t\tfor(int j=0; j<=n+1; j++)\n\t\t\tif((i&1) ^ (j&1))\n\t\t\t\tx[i][j] = prm[i+1] * prm[n+3+j];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(!x[i][j])\n\t\t\t\tx[i][j] = x[i-1][j] * x[i+1][j] + 1;\n\tll mxv = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tprintf(\"%lld \", x[i][j]), mxv = max(mxv, x[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\n\nconst int INF = 1e9 ;\nconst int maxN = 1010; \nconst int MOD = 1e9 + 7;\nint tot,n;\nint prime[maxN*10]; //记录质数\nint b[maxN * 100]; //标记i 是否为质数 \nll a[maxN][maxN];\nconst int L = 10000;\nvoid check()\n{\n\ttot = 0;\n\tfor(int i=2;i<=L;i++)\n\t{\n\t\tif(b[i] == 0)\n\t\t{\n\t\t\tprime[++tot] = i;\n\t\t\tfor(int j=2;i*j<=L;j++)\n\t\t\t{\n\t\t\t\tb[i*j] = 1;\t\n\t\t\t}\t\n\t\t}\t\n\t} \n} \nvector<pii> l[maxN];\nll lc[maxN];\nint lcnt;\nvector<pii> r[maxN];\nll rc[maxN]; \nint rcnt;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tcheck();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(i,1)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = 1+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int j=2;j<=n;j++)\n\t{\n\t\tint k = 1;\n\t\tl[++cnt].push_back(pii(n,j)); \n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j+k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tl[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tlcnt = cnt;\n\tcnt = 0;\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint k=1;\n\t\tr[++cnt].push_back(pii(n,j));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = n-k;\n\t\t\tint ty = j-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tint k = 1;\n\t\tr[++cnt].push_back(pii(i,n));\n\t\twhile(1)\n\t\t{\n\t\t\tint tx = i-k;\n\t\t\tint ty = n-k;\n\t\t\tif(tx<1 || tx>n || ty<1 || ty>n)\n\t\t\t\tbreak;\n\t\t\tr[cnt].push_back(pii(tx,ty));\n\t\t\tk++;\t\n\t\t} \n\t}\n\trcnt = cnt;\n\tcnt = 0;\n\tfor(int i=1;i<=lcnt;i+=2)\n\t{\n\t\tlc[i] = prime[++cnt]; \n\t}\n\tfor(int j=2;j<=lcnt;j+=2)\n\t{\n\t\tlc[j] = lc[j-1]*lc[j+1];\n\t}\n\tif(n%2 == 1)\n\t{\n\t\tfor(int i=1;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\tfor(int j=2;j<=rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\t\n\t}\n\telse\n\t{\n\t\tfor(int i=2;i<=rcnt;i+=2)\n\t\t{\n\t\t\trc[i] = prime[++cnt]; \n\t\t}\n\t\trc[1] = rc[2];\n\t\trc[rcnt] = rc[rcnt-1];\n\t\tfor(int j=3;j<rcnt;j+=2)\n\t\t{\n\t\t\trc[j] = rc[j-1]*rc[j+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ta[i][j] = 1ll; \n\t} \n\tfor(int i=1;i<=lcnt;i++)\n\t{\n\t\tfor(int j=0;j<l[i].size();j++)\n\t\t{\n\t\t\tint tx = l[i][j].first;\n\t\t\tint ty = l[i][j].second;\n\t\t\ta[tx][ty] *= lc[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=rcnt;i++)\n\t{\n\t\tfor(int j=0;j<r[i].size();j++)\n\t\t{\n\t\t\tint tx = r[i][j].first;\n\t\t\tint ty = r[i][j].second;\n\t\t\ta[tx][ty] *= rc[i];\n\t\t\tif((tx+ty)%2==1)\n\t\t\t\ta[tx][ty] += 1;\n\t\t}\n\t}\n\tif(n==2)\n\t{\n\t\ta[1][2] += 30;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j<n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n\n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n\n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n\nconst int N=505;\nconst int LIM=8000;\nint fl[LIM],pri[LIM],n;\nvoid initprime(){\n\tFor(i,2,LIM-1) For(j,2,(LIM-1)/i) fl[i*j]=1;\n\tFor(i,1,LIM-1) if (!fl[i]) pri[++*pri]=i;\n}\nmap<int,int> mp1,mp2;\nmap<ll,int> mp3;\nll ans[N][N];\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid work(){\n\tint l=4;\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp1[i+j]) mp1[i+j]=pri[l++];\n\t\tif (l>333) l=4;\n\t\tans[i][j]=mp1[i+j];\n\t}\n\tl=4;\n\tRep(i,n,1) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp2[i-j]) mp2[i-j]=pri[l++];\n\t\tif (l>333) l=4;\n\t\tans[i][j]*=mp2[i-j];\n\t}\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tint v=mp1[i+j]*mp2[i-j];\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=v);\n\t\tmp3[ans[i][j]]++;\n\t}\n\tll mx=0;\n\tFor(i,1,n) For(j,1,n) if (!ans[i][j]){\n\t\tll lcm=1;\n\t\tif (i!=1) lcm*=ans[i-1][j]/gcd(ans[i-1][j],lcm);\n\t\tif (i!=n) lcm*=ans[i+1][j]/gcd(ans[i+1][j],lcm);\n\t\tif (j!=1) lcm*=ans[i][j-1]/gcd(ans[i][j-1],lcm);\n\t\tif (j!=n) lcm*=ans[i][j+1]/gcd(ans[i][j+1],lcm);\n\t\tans[i][j]=lcm+1;\n\t\tfor (;mp3[ans[i][j]];ans[i][j]+=lcm);\n\t\tmp3[ans[i][j]]=1;\n\t\tmx=max(mx,ans[i][j]);\n\t}\n\tFor(i,1,n){\n\t\tFor(j,1,n) printf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tinitprime();\n\twork();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pir pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define pb push_back\nusing namespace std;\n\nconst int N=510,M=100010;\nint n,prime[M],cnt;\nll res[N][N];\nbool vis[M];\nvector<pir> v;\n\nvoid pre(int m) {\n    for(int i=2;i<=m;i++) {\n        if(!vis[i]) prime[++cnt]=i;\n        for(int j=1;j<=cnt;j++) {\n            int tmp=prime[j]*i;\n            if(tmp>m) break;\n            vis[tmp]=1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nbool cmp1(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi+a.se<b.fi+b.se;\n    return a<b;\n}\n\nbool cmp2(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi-a.se<b.fi-b.se;\n    return a<b;\n}\n\nll lcm(ll a,ll b) {\n    return a/__gcd(a,b)*b;\n}\n\nint main() {\n    pre(100000);\n    scanf(\"%d\",&n);\n    if(n==2) return printf(\"2 3\\n5 4\\n\"),0;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2==0) v.pb({i,j});\n            res[i][j]=1;\n        }\n    }\n    sort(v.begin(),v.end(),cmp1);\n    pir pre={0,0};\n    int* ptr=prime;\n    for(auto p:v) {\n        if(p.fi+p.se!=pre.fi+pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    sort(v.begin(),v.end(),cmp2);\n    pre={0,0};\n    for(auto p:v) {\n        if(p.fi-p.se!=pre.fi-pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                if(i>1) res[i][j]=lcm(res[i][j],res[i-1][j]);\n                if(j>1) res[i][j]=lcm(res[i][j],res[i][j-1]);\n                if(i<n) res[i][j]=lcm(res[i][j],res[i+1][j]);\n                if(j<n) res[i][j]=lcm(res[i][j],res[i][j+1]);\n                printf(\"%lld \",res[i][j]+1);\n            }\n            else printf(\"%lld \",res[i][j]);\n        }\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\t\n\tscanf(\"%d\", &n);\n//\trandom_shuffle(prime, prime+n+n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0 ; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\n\t#ifdef che\n\tdebug(\"last = %d\\n\", prime[cur]);\n\t#endif\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tif ( i) s *= a[i-1][j];\n\t\tif ( i+1<n ) s*=a[i+1][j];\n\t\tif ( j) s*= b[i][j-1];\n\t\tif ( j+1<n ) s*=b[i][j+1];\n\t\t\n\t\tassert(s <= LL(1e15)  );\n\t\ta[i][j] = s+1;\n\t}\n\tif( n==2) a[1][1] = 2*a[1][1]-1;\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nint ip(int x)\n{\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return 0;\n    return x>1;\n}\nconst int Q=1<<16,P=1<<9;\nint pn[Q];\nll als[P][P];\nll Lcm(ll a,ll b)\n{return (a==0||b==0)?a|b:a/__gcd(a,b)*b;}\nll h[Q],z[Q];\nint main()\n{\n    int tp=0,n;\n    for(int i=2;tp<1000;i++)\n        if(ip(i))pn[++tp]=i;\n    scanf(\"%d\",&n);\n    tp=0;\n    for(int i=1-n;i<=n-1;i++)\n        if(i&1^1)h[i+n]=pn[++tp];\n    for(int i=2;i<=(n<<1);i++)\n        if(i&1^1)z[i]=pn[++tp];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1^1)als[i][j]=h[j-i+n]*z[i+j];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1)als[i][j]=Lcm(Lcm(als[i+1][j],als[i-1][j]),Lcm(als[i][j+1],als[i][j-1]));\n    for(int i=1;i<=n;i++,puts(\"\"))\n        for(int j=1;j<=n;j++)\n            printf(\"%lld \",als[i][j]);\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm> \n#include<set>\ntypedef long long ll;\nconst int N=500,vx[4]={-1,0,0,1},vy[4]={0,-1,1,0};\nint X=245044800;\nll a[510][510];\nstd::set<ll>S;\nint d[510],dc,p[510];\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nint main(){\n\tfor(int i=1;dc<500;i++)if(X%i==0)d[dc++]=i;\n\tint pl=0,pr=123;\n\tfor(int i=19,ty=0,cnt=0;cnt<125;i+=2){\n\t\tif(i%2!=0&&i%3!=0&&i%5!=0&&i%7!=0&&i%11!=0&&i%13!=0&&i%17!=0)cnt++%2?p[pr]=i,pr-=2:(p[pl]=i,pl+=2);\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i+j)%2==0)a[i][j]=1ll*d[j]*p[i/4];\n\t\t}\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tll L=1;\n\t\t\t\tfor(int d=0,dx,dy;d<4;d++)if((dx=i+vx[d])>=0&&dx<N&&(dy=j+vy[d])>=0&&dy<N)L=lcm(L,a[dx][dy]);\n\t\t\t\tfor(a[i][j]=L+1;S.find(a[i][j])!=S.end();a[i][j]+=L);\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for (register int i = l; i <= r; i++)\n#define ford(i, r, l) for (register int i = r; i >= l; i--)\n\ntypedef long long ll;\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\nll N, prime[20003], p_cnt, Need, a[505][505];\n\nint main() {\n  srand(time(0));\n  for (int i = 2; i <= 20000; i++) {\n    bool flag = true;\n    for (int j = 2; j * j <= i && flag; j++)\n      if (i % j == 0) flag = false;\n    if (flag) prime[++p_cnt] = i;\n  }\n  scanf(\"%lld\", &N), Need = N + N - 2;\n  if(N == 2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n  //  random_shuffle(prime + 1, prime + Need + 1);\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if (!((i + j) & 1)) continue;\n      int x = (i + j) >> 1;\n      int y = ((N - (N & 1)) - (j - i) + 1) >> 1;\n      a[i][j] = prime[x] * prime[N - 1 + y];\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if ((i + j) & 1) continue;\n      a[i][j] = 1;\n      if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n      if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n      if (i < N) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n      if (j < N) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n      a[i][j]++;\n    }\n  }\n  for (int i = 1; i <= N; i++)\n    for (int j = 1; j <= N; j++) printf(\"%lld%c\", a[i][j], \" \\n\"[j == N]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e8, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (int i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  donttttttt use vector \n  run n = 1 and n = MAXN before submit\n  try to AC within one submission\n*/\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n     \ntypedef long long lo;\n \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\n\nint main(void) {\n\tint n;\n\tread(n);\n\trep (i, n) rep (j, n) cout << i + j << \" \\n\"[j == n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m int64_t\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nmain(){m n;cin>>n;m t=0,k=555;r(2,i,1e4){bool a=1;r(2,j,i){if(i%j==0)a=0;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m int64_t\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1000];\nmain(){m n,t=0,k=555;cin>>n;r(2,i,1e4){bool a=1;r(2,j,i){if(i%j==0)a=0;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30,maxn=2000005;\nint i,j,k,n,v[10000005];\nint f[maxn],prime[maxn],tot;\nlong long ans[505][505];\nmap<long long,int> p;\nvoid shai()\n{\n    tot=0;\n    for(int i=2;i<maxn;i++)\n    {\n        if(!f[i])\n            prime[tot++]=i;\n        for(int j=0;j<tot&&prime[j]*i<maxn;j++)\n        {\n            f[i*prime[j]]=1;\n            if(i%prime[j]==0)\n            {\n                break;\n            }\n        }\n    }\n}\nlong long gcd(long long a,long long b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nlong long lcm(long long a,long long b)\n{\n\tif(a==0)\n\t\treturn b;\n\tif(b==0)\n\t\treturn a;\n\treturn a/gcd(a,b)*b;\n}\nint main()\n{\n\tshai();\n\tscanf(\"%d\",&n);\n\tfor(i=500;i>=1;--i)\n\t\tfor(j=500;j>=1;--j)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tfor(k=prime[(i+j)/2-1];v[k];k+=prime[(i+j)/2-1]);\n\t\t\t\tans[i][j]=k;\n\t\t\t\tv[k]=1;\n\t\t\t}\n\tfor(i=1;i<=500;++i)\n\t\tfor(j=1;j<=500;++j)\n\t\t\tif(ans[i][j]==0)\n\t\t\t{\n\t\t\t\tlong long s=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i+1][j],ans[i][j+1]));\n\t\t\t\tans[i][j]=s+1;\n\t\t\t\twhile(p[ans[i][j]])\n\t\t\t\t\tans[i][j]+=s;\n\t\t\t\tp[ans[i][j]]=1;\n\t\t\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 1000; \nconst long long INF = 0x3f3f3f3f; \n\nint cnt, idx, n; \nlong long ans[550][550], elm[Maxv], max = -INF; \nlong long x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void pre_Opt() {\n    int num; \n    for (int i = 2;; i++) {\n        for (num = 2; num * num <= i; num++) {\n            if (i % num == 0) break; \n        }\n\n        if (num * num > i) elm[++cnt] = i; \n        if (cnt >= Maxv) break; \n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    pre_Opt(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", elm[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = elm[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= elm[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep3(i,m,n) for(int (i)=m;(i)<=(n);(i)++)\n#define rep3rev(i,m,n) for(int (i)=m;(i)>=(n);(i)--)\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing P = pair<int, int>;\n\nconst int mx = 10000;\nconst int sz = 500;\nvector<bool> isprime(mx+1, true); \nvll prime;\nll ans[sz][sz];\nint di[] = {0, 1, 0, -1};\nint dj[] = {-1, 0, 1, 0};\n\nvoid Eratosthenes(int n){\n    isprime[0] = false;\n    isprime[1] = false;\n    for(int i = 2; i * i <= n; i++){\n        for(int j = 2 * i; j <= n; j += i){\n            isprime[j] = false;\n        }\n    }\n}\n\nvoid Solve(){\n    rep(i, sz){\n        rep(j, sz){\n            if((i + j) % 2 == 0) continue;\n            int wa = j + i; // 1, 3, 5, 7, 9, ..., 999\n            int sa = j - i; // -499, -497, ..., 497, 499\n            ans[i][j] = prime[wa/2] * prime[(sa+sz)/2 + sz];\n        }\n    }\n    rep(i, sz){\n        rep(j, sz){\n            if((i + j) % 2) continue;\n            ans[i][j] = 1;\n            int wa1 = j + i + 1;\n            int wa2 = j + i - 1;\n            int sa1 = j - i + 1;\n            int sa2 = j - i - 1;\n            if(0 < wa1 || wa1 < 2 * sz){\n                ans[i][j] *= prime[wa1/2];\n            } \n            if(0 < wa2 || wa2 < 2 * sz){\n                ans[i][j] *= prime[wa2/2];\n            } \n            if(-sz < sa1 || sa1 < sz){\n                ans[i][j] *= prime[(sa1+sz)/2 + sz];                \n            }\n            if(-sz < sa2 || sa2 < sz){\n                ans[i][j] *= prime[(sa2+sz)/2 + sz];\n            }\n            ans[i][j]++;\n        }        \n    }\n}\n\nvoid Main(){\n    Eratosthenes(mx);\n    rep(i, mx) if(isprime[i]) prime.pb(i);\n    Solve();\n    int n; cin >> n;\n    rep(i, n) {\n        rep(j, n) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n    return;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nll gcd(ll x, ll y){\n\tif(y==0)return x;\n\treturn gcd(y,x%y);\n}\n\nll lcm(ll x, ll y){\n\treturn x/gcd(x,y)*y;\n}\n\nvoid _main(istream &inp){\n\tint n;\n\tinp >> n;\n\tconst int M = 1000;\n\tvvl ret(n, vl(n));\n//\tdebug(n);\n//\tdebug(ret);\n\tset<ll> u;\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==0){\n\t\t\tll tt = (x/2+800)*((x+y)/2+800);\n\t\t\tll t = tt;\n\t\t\twhile(exist(u,t))t+=tt;\n\t\t\tu.insert(t);\n\t\t\tret[x][y]=t;\n\t\t}\n\t}\n\tll maxi = 0;\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==1){\n\t\t\tll z = 1;\n\t\t\tif(x>0)z=lcm(z,ret[x-1][y]);\n\t\t\tif(y>0)z=lcm(z,ret[x][y-1]);\n\t\t\tif(x+1<n)z=lcm(z,ret[x+1][y]);\n\t\t\tif(y+1<n)z=lcm(z,ret[x][y+1]);\n\t\t\tll val = z+1;\n\t\t\twhile(exist(u,val))val+=z;\n\t\t\tu.insert(val);\n\t\t\tmaxi = max(maxi, val);\n\t\t\tret[x][y]=val;\n\t\t}\n\t}\n\tdebug(1.0*maxi/1e15);\n\tassert(maxi<1e15);\n\t//debug(n);\n\t//debug(ret);\n\tset<ll> check;\n\trep(x,n) rep(y,n) check.insert(ret[x][y]);\n\tassert(check.size()==n*n);\n\trep(x,n) rep(y,n-1){\n\t\tll a = ret[x][y];\n\t\tll b = ret[x][y+1];\n\t\tassert(max(a,b)%min(a,b)==1);\n\t}\n\trep(x,n-1) rep(y,n){\n\t\tll a = ret[x][y];\n\t\tll b = ret[x+1][y];\n\t\tassert(max(a,b)%min(a,b)==1);\n\t}\n\t//return;\n\trep(x,n){\n\t\trep(y,n){\n\t\t\tcout << ret[x][y];\n\t\t\tif(y!=n-1)cout << \" \";\n\t\t\telse cout << endl;\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nlong long lcm(long long a, long long b) {\n  return a / __gcd(a, b) * b;\n}\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int real_n;\n  cin >> real_n;\n  int n = 500;\n  vector<int> primes;\n  int x = 2;\n  while ((int) primes.size() < 2 * n + 5) {\n    int prime = 1;\n    for (int i = 2; i * i <= x; i++) {\n      if (x % i == 0) {\n        prime = 0;\n        break;\n      }\n    }\n    if (prime) {\n      primes.push_back(x);\n    }\n    x++;\n  }\n  vector<vector<long long>> a(n, vector<long long>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 0) {\n        a[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + n + n / 2 + 2];\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) {\n        a[i][j] = 1;\n        if (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n        if (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n        if (i < n - 1) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n        if (j < n - 1) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n        assert(a[i][j] <= (long long) 1e15);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n - 1; j++) {\n      assert(max(a[i][j], a[i][j + 1]) % min(a[i][j], a[i][j + 1]) == 0);\n      assert(max(a[j][i], a[j + 1][i]) % min(a[j][i], a[j + 1][i]) == 0);\n    }\n  }\n  set<long long> all;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      all.insert(a[i][j]);\n    }\n  }\n  assert((int) all.size() == n * n);\n  for (int i = 0; i < real_n; i++) {\n    for (int j = 0; j < real_n; j++) {\n      if (j > 0) {\n        cout << \" \";\n      }\n      cout << a[i][j];\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll a[510][510];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nint main(){\n   int n; cin>>n;\n   bitset<101010> isp;\n   rep(i,2,100000)isp[i]=1;\n   queue<int> ps;\n   rep(i,2,100000)if(isp[i]){\n      for(ll j=1LL*i*i;j<100000;j+=i)isp[j]=0;\n   }\n   rep(i,2,100000)if(isp[i])ps.push(i);\n   rep(i,0,n)rep(j,0,n)if((i+j)&1){\n      a[i][j]=ps.front(); ps.pop();\n   }\n   rep(i,0,n)rep(j,0,n)if(((i+j)&1)==0){\n      a[i][j]=1;\n      rep(k,0,4){\n         int tx=i+dx[k],ty=j+dy[k];\n         if(tx<0 or tx>=n or ty<0 or ty>=n)continue;\n         a[i][j]*=a[tx][ty];\n      }\n      a[i][j]++;\n   }\n   rep(i,0,n){\n      rep(j,0,n)printf(\"%lld \",a[i][j]);\n      putchar('\\n');\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nlong long LCM(long long a , long long b){return (__int128)a * b / __gcd(a , b);}\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1)\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = LCM(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n\tcin >> N;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= N ; ++j) cout << arr[i][j] << \" \\n\"[j == M];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 540;\n\nint n;\nint pn = 0, c[7930], p[1054];\nll a[N][N];\n\nvoid sieve(int n) {\n\tint i, j, v;\n\tmemset(c, -1, sizeof c);\n\tfor (i = 2; i <= n; ++i) {\n\t\tif (!~c[i]) p[pn] = i, c[i] = pn++;\n\t\tfor (j = 0; (v = i * p[j]) <= n && j <= c[i]; ++j) c[v] = j;\n\t}\n}\n\nint main() {\n\tint i, j, *q;\n\tscanf(\"%d\", &n), sieve(7929);\n\tq = p + (n - 1);\n\tfor (i = 0; i < n; ++i) for (j = 0; j < n; ++j) if ((i ^ j) & 1)\n\t\ta[i][j] = p[(i + j - 1) / 2] * q[(j - i + n - 1) / 2];\n\tfor (i = 0; i < n; ++i) for (j = 0; j < n; ++j) if (!((i ^ j) & 1)) {\n\t\tll &s = a[i][j]; s = 1;\n\t\tif (i          || j         ) s *= p[(i + j - 2) / 2];\n\t\tif (i != n - 1 || j != n - 1) s *= p[(i + j) / 2];\n\t\tif (i          || j != n - 1) s *= q[(j - i + n) / 2];\n\t\tif (i != n - 1 || j         ) s *= q[(j - i + n - 2) / 2];\n\t\t++s;\n\t}\n\tif (n == 2) a[1][1] = a[1][1] * 2 - 1;\n\tfor (i = 0; i < n; ++i) for (j = 0; j < n; ++j)\n\t\tprintf(\"%lld%c\", a[i][j], j == n - 1 ? 10 : 32);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 233333;\nint notp[N], pri[N], pc = 0;\n\nint main() {\n  notp[1] = 1;\n  for (int i = 2; i < N; i++) {\n    if (!notp[i]) {\n      pri[++pc] = i;\n    }\n    for (int j = 1; j <= pc && i * pri[j] < N; j++) {\n      notp[i * pri[j]] = 1;\n      if (!(i % pri[j])) break;\n    }\n  }\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if ((i + j) & 1) {\n        printf(\"%lld \", (long long) pri[(i - j + n + 3) / 2] * pri[(i + j + n * 2 + 3) / 2]);\n      } else {\n        long long x = 1;\n        if (i > 1 || j > 1) x *= pri[(i + j - 1 + n * 2 + 3) / 2];\n        if (i < n || j < n) x *= pri[(i + j + 1 + n * 2 + 3) / 2];\n        if (i > 1 || j < n) x *= pri[(i - j - 1 + n + 3) / 2];\n        if (i < n || j > 1) x *= pri[(i - j + 1 + n + 3) / 2];\n        if (n == 2 && i == 1 && j == 1) x <<= 1;\n        printf(\"%lld \", x + 1);\n      }\n    }\n    puts(\"\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <map>\n#include <ctime>\n\nusing namespace std;\n\nlong long n;\nlong long a[510][510];\nlong long p[120000] , prime[120000] , tot;\nmap < long long , long long > m;\nlong long cnt;\nlong long lcm ( long long a , long long b , long long c , long long d ) {\n\tlong long t = a / __gcd ( a , b ) * b;\n\tt = t / __gcd ( t , c ) * c;\n\tt = t / __gcd ( t , d ) * d;\n\treturn t;\n}\nvoid work () {\n\tlong long i , j , t , l;\n\tscanf ( \"%lld\" , &n );\n\tfor ( i = 2 ; i <= 100000 ; i++ ) {\n\t\tif ( !p[i] ) {\n\t\t\tprime[++tot] = i;\n\t\t}\n\t\tfor ( j = 1 ; j <= tot ; j++ ) {\n\t\t\tif ( i * prime[j] > 100000 ) break;\n\t\t\tp[i*prime[j]] = 1;\n\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t}\n\t}\n\tfor ( i = 0 ; i <= n + 1 ; i++ ) {\n\t\tfor ( j = 0 ; j <= n + 1 ; j++ ) {\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\tt = l = 0;\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tfor ( j = 1 ; j <= n ; j++ ) {\n\t\t\tif ( (i+j) % 2 == 0 ) {\n\t\t\t\ta[i][j] = a[i][j] * prime[(i+j)/2];\n\t\t\t\ta[i][j] = a[i][j] * prime[n*2-i+j];\n\t\t\t}\n\t\t}\n\t}\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tfor ( j = 1 ; j <= n ; j++ ) {\n\t\t\tif ( (i+j) % 2 == 1 ) {\n\t\t\t\tl = lcm ( a[i-1][j] , a[i+1][j] , a[i][j-1] , a[i][j+1] );\n\t\t\t\tt = l + 1;\n\t\t\t\twhile ( m[t] == 1 ) {\n\t\t\t\t\tt += l;\n\t\t\t\t}\n\t\t\t\ta[i][j] = t;\n\t\t\t\tm[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor ( i = 1 ; i <= n ; i++ , printf ( \"\\n\" ) )\n\t\tfor ( j = 1 ; j <= n ; j++ ) printf ( \"%lld \" , a[i][j] );\n\t//for ( i = 1 ; i <= n ; i++ )\n\t//\tfor ( j = 1 ; j <= n ; j++ ) if ( a[i][j]<0)printf ( \"%lld \" , a[i][j] );\n\t\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 20000\nusing namespace std;\nll a[505][505];\nll prime[1005];\nint cnt,p[20005],n;\n\nvoid print(ll x){\n\tif(x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\n\nll lcm(ll x,ll y){\n\treturn x/__gcd(x,y)*y;\n}\n\nint main(){\n\tfor(int i=2;i<=maxn;i++){\n\t\tif(p[i]==0) prime[++cnt]=i;\n\t\tif(cnt==1000) break;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<=maxn;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tprint(4),putchar(' '),print(7);puts(\"\");\n\t\tprint(23),putchar(' '),print(10);puts(\"\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!((i&1)^(j&1))) a[i][j]=prime[(i+j)/2]*prime[n+(n+1+i-j)/2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)^(j&1)){\n\t\t\t\ta[i][j]=1;\n\t\t\t\tif(i>1) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\t\tif(i<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\t\tif(j>1) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\t\tif(j<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) print(a[i][j]),putchar(' ');\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n#define rep(i, j, k) for (int i = (j); i <= (k); i++)\n#define per(i, j, k) for (int i = (j); i >= (k); i--)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nconst int N = 503;\nint n,pr[1500],v[10003],tot,cnt;\nll ans[N][N];\nmap<PII,ll> ch;\n\nvoid init(){\n    for(int i = 2; i <= 10000; i++){\n        if(!v[i]){\n            pr[++tot]=i;\n            v[i]=i;\n        }\n        for(int j = 1; j <= tot && i*pr[j] <= 10000; j++){\n            v[pr[j]*i]=pr[j];\n            if(v[i]==pr[j]) break;\n        }\n    }\n}\nll getval(int x,int y){\n    ll ret=1;\n    int stx[4]={1,-1,0,0},sty[4]={0,0,1,-1};\n    auto valid=[&](int x,int y){\n        return 1<=x&&x<=n&&1<=y&&y<=n;\n    };\n    for(int i = 0; i < 4; i ++){\n        int nx=x+stx[i],ny=y+sty[i];\n        if(!valid(nx,ny)) continue;\n        ret=ret/__gcd(ret,ans[nx][ny])*ans[nx][ny];\n    }\n    return ret+1;\n}\nint main(){\n    freopen(\"my.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n    init();\n    for(int i = 2; i <= n+n; i+=2) ch[Mp(i,0)]=pr[++cnt];\n    for(int i = 0,j = 0; i < n; i+=2,j-=2) ch[Mp(i,1)]=pr[++cnt],ch[Mp(j,1)]=pr[++cnt];\n    //puts(\"1\");\n    //for(auto it:ch) printf(\"%d %d %d\\n\",it.fi.fi,it.fi.se,it.se);\n    rep(i,1,n) rep(j,1,n) if((i+j)%2==0){\n        ans[i][j]=ch[Mp(i+j,0)]*ch[Mp(i-j,1)];\n    }\n    //rep(i,1,n) rep(j,1,n) printf(\"%lld%c\",ans[i][j],j==n?'\\n':' ');\n    rep(i,1,n) rep(j,1,n) if((i+j)%2==1){\n        ans[i][j]=getval(i,j);\n    }\n    // printf(\"%d\\n\",n);\n    rep(i,1,n) rep(j,1,n) printf(\"%lld%c\",ans[i][j],j==n?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 512\n#define ll long long\nint n;\nll a[maxn][maxn];\nbool vis[10240];\nll prim[10240],cnt;\nvoid getprim()\n{\n\tfor(int i=2;i<10240;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tprim[cnt]=i;\n\t\t}\n\t\tfor(int j=1;j<=cnt&&i*prim[j]<10240;j++)\n\t\t{\n\t\t\tvis[i*prim[j]]=1;\n\t\t\tif(i%prim[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nll gcd(ll a,ll b)\n{\n\tif(!b)\n\t{\n\t\treturn a;\n\t}else\n\t{\n\t\treturn gcd(b,a%b);\n\t}\n}\nll lcm(ll a,ll b)\n{\n\tif(a==0||b==0)\n\t{\n\t\treturn a+b;\n\t}else\n\t{\n\t\treturn a/gcd(a,b)*b;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tgetprim();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n\t\t{\n\t\t\ta[i][j]=prim[(i+j)/2]*prim[n+(i-j)/2+(n+1)/2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t{\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define v vector\n#define ALL(x) x.begin(),x.end()\n#define rALL(x) x.rbegin(),x.rend()\n#define DEBUG\n\ntemplate<typename T> void DBG(const char* name, T&& H) {\n\tcerr << name << \" = \" << H << ')' << endl;\n}\n\ntemplate<typename T, typename... Args> void DBG(const char* names, T&& H, Args&&... args) {\n\tconst char* NEXT = strchr(names+1, ',');\n\tcerr.write(names, NEXT-names) << \" = \" << H << \" |\";\n\tDBG(NEXT+1, args...);\n}\n\n#ifdef DEBUG\n\t#define dbg(...) cerr << __FUNCTION__ << ' ' <<__LINE__ << \" : (\", DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n\t#define dbg(...)\n#endif\n\nusing ll = long long;\nusing ld = long double;\n\nconst long long mod = 1e9+7;\nconst long double PI = acos(-1.0);\nconst long long INF = 1e18;\nconst int maxN = 2e5+1;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nbool can(int x, int y) {\n\treturn ((x >= 0) && (y >= 0) && (x < 500) && (y < 500));\n}\n\nvector<long long> Sieve(int N) {\n\tvector<long long> primes;\n\tvector<bool> isPrime(N+1, 0);\n\tfor(int i = 2; i < N+1; i ++) {\n\t\tif(isPrime[i] == 0) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor(int j = i+i; j < N+1; j += i) {\n\t\t\t\tisPrime[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn primes; \n}\n\nvoid Solve() {\n\tvector<long long> p = Sieve(int(1e5));\n\tvector<vector<long long>> mat(500, vector<long long>(500, 1));\n\tvector<pair<int, int>> start;\n\tint ptr = -1;\n\tfor(int i = 0; i < 500; i += 2) {\n\t\tptr ++;\n\t\tint x = 0, y = i;\n\t\twhile((x < 500) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx ++, y ++;\n\t\t}\n\t\tif(i == 0) continue;\n\t\tptr ++;\n\t\tx = i, y = 0;\n\t\twhile((x < 500) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx ++, y ++;\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i += 2) {\n\t\tptr ++;\n\t\tint x = i, y = 0;\n\t\twhile((x >= 0) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx --, y ++;\n\t\t}\n\t\tptr ++;\n\t\tx = 499, y = i+1;\n\t\twhile((x >= 0) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx --, y ++;\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i ++) {\n\t\tfor(int j = 0; j < 500; j ++) {\n\t\t\tif(mat[i][j] != 1) continue;\n\t\t\tlong long LCM = 1;\n\t\t\tfor(int k = 0; k < 4; k ++) {\n\t\t\t\tint x = i+dx[k], y = j+dy[k];\n\t\t\t\tif(can(x, y)) {\n\t\t\t\t\tlong long other = mat[x][y];\n\t\t\t\t\tlong long GCD = __gcd(LCM, other);\n\t\t\t\t\tother /= GCD;\n\t\t\t\t\tLCM *= other;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmat[i][j] = LCM+1;\n\t\t}\n\t}\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N; i ++) {\n\t\tfor(int j = 0; j < N; j ++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint tt = 1; \n\tfor(int i = 1; i <= tt; i ++) {\n\t\tSolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nbool P(int x){for(int i=2;i*i<=x;i++)if(x%i==0)return false;return true;}\n\nint p[1111],p1[1111],p2[1111],tot,n;\n\nLL a[555][555];\n\nint main()\n{\n\tfor(int i=2;i<=10000&&tot<1002;i++)if(P(i))p[++tot]=i;\n\tfor(int i=1;i<=501;i++)p1[i*2-1]=p[i];\n\tfor(int i=1;i<=501;i++)p2[i*2-1]=p[i+501];\n\tfor(int i=1;i<=501;i++)for(int j=1;j<=501;j++)\n\t{\n\t\tint k1=i+j-1,k2=i-j+501;\n\t\ta[i][j]=1;\n\t\tif(k1%2==1)a[i][j]*=p1[k1];else a[i][j]*=p1[k1-1]*p1[k1+1];\n\t\tif(k2%2==1)a[i][j]*=p2[k2];else a[i][j]*=p2[k2-1]*p2[k2+1];\n\t\tif(k1%2==0)a[i][j]++;\n\t}\n\t\n\tget1(n);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)printf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=505;\nint n,p[MAXN*MAXN],cnt;\nbool v[MAXN*MAXN];\nvoid sieve(int n=500*500){\n\tfor(int i=2;i<=n;++i){\n\t\tif(!v[i])p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;++j){\n\t\t\tv[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll a[MAXN][MAXN];\nll lcm(ll x,ll y){return x/__gcd(x,y)*y;}\nint main() {\n\tn=read();if(n==2)return puts(\"4 7\\n23 10\\n\"),0;\n\tsieve();\n\tint t=0;\n\tfor(int s=2;s<=n+n;++s){\n\t\t++t;\n\t\tfor(int i=1;i<=n;++i)if(s-i>=1&&s-i<=n&&((i+s-i)&1))a[i][s-i]=p[t];\n\t}\n\tfor(int d=-(n-1);d<=(n-1);++d){\n\t\t++t;\n\t\tfor(int i=1;i<=n;++i)if(i-d>=1&&i-d<=n&&((i+i-d)&1))a[i][i-d]*=p[t];\n\t}\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if(!((i+j)&1)){\n\t\tll l=1;\n\t\tfor(int k=0;k<4;++k){\n\t\t\tint ii=i+dx[k],jj=j+dy[k];\n\t\t\tif(ii<1||ii>n||jj<1||jj>n)continue;\n\t\t\tassert((ii+jj)&1);\n\t\t\tl=lcm(l,a[ii][jj]);\n\t\t}\n\t\ta[i][j]=l+1;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)cout<<a[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<cctype> \n#include<cstring> \n#include<algorithm> \n#define gc getchar() \n#define pc putchar\n#define LL long long\ninline int read() { \n    int x = 0,f = 1; \n    char c = getchar(); \n    while(c < '0' || c > '9') c = gc; \n    while(c <= '9' && c >= '0') x = x * 10 + c - '0',c = getchar(); \n    return x * f; \n}\nvoid print(LL x) { \n    if(x < 0) { \n        pc('-'); \n        x = -x; \n    } \n    if(x >= 10) print(x / 10); \n    pc(x % 10 + '0'); \n} \nconst int maxn = 20007; \nint n; \nint prime[maxn]; \nbool vis[maxn]; \nvoid pre(int lim = 10000) {  \n    for(int cnt = 0,i = 2;i <= lim;++ i) { \n        if(!vis[i]) prime[++ cnt] = i; \n        for(int j = 1;j <= cnt && prime[j] * i <= lim;++ j) { \n            vis[i * prime[j]] = 1; \n            if(i % prime[j] == 0) break; \n        } \n    } \n} \nLL a[507][507]; \nLL gcd(LL x,LL y) { \n    return y == 0 ? x : gcd(y,x % y); \n} \nLL lcm(LL x,LL y) {\n    return x / gcd(x,y) * y; \n} \nint main() { \n    n = read(); \n    pre(); \n    if(n == 2) {\n        pc('4');pc(' ');pc('7');pc('\\n'); \n        print(23);pc(' '); print(10); pc('\\n'); \n        return 0;  \n    } \n    for(int i = 0;i <= n + 1;++ i) \n        for(int j = 0;j <= n + 1;++ j) \n                a[i][j] = 1; \n    for(int i = 1;i <= n;++ i) \n        for(int j = 1;j <= n;++ j) { \n            if((j & 1) == (i & 1)) { \n                a[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n];  \n                a[i + 1][j] = lcm(a[i + 1][j],a[i][j]); \n                a[i - 1][j] = lcm(a[i - 1][j],a[i][j]); \n                a[i][j + 1] = lcm(a[i][j + 1],a[i][j]); \n                a[i][j - 1] = lcm(a[i][j - 1],a[i][j]); \n            } \n        } \n    for(int i = 1;i <= n;++ i) \n        for(int j = 1;j <= n;++ j) \n            if((i & 1) == (j & 1)); \n            else a[i][j] ++; \n    for(int i = 1;i <= n;++ i,pc('\\n')) \n        for(int j = 1;j <= n;++ j) \n            print(a[i][j]),pc(' '); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define INF 2147483647\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\n#define _ 0\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nnamespace Mymath{\n\tLL qp(LL x,LL p,LL mod){\n\t\tLL ans=1;\n\t\twhile (p){\n\t\t\tif (p&1) ans=ans*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tp>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tLL inv(LL x,LL mod){\n\t\treturn qp(x,mod-2,mod);\n\t}\n\tLL C(LL N,LL K,LL fact[],LL mod){\n\t\treturn fact[N]*inv(fact[K],mod)%mod*inv(fact[N-K],mod)%mod;\n\t}\n\ttemplate <typename Tp> Tp gcd(Tp A,Tp B){\n\t\tif (B==0) return A;\n\t\treturn gcd(B,A%B);\n\t}\n\ttemplate <typename Tp> Tp lcm(Tp A,Tp B){\n\t\treturn A*B/gcd(A,B);\n\t}\n};\nnamespace fwt{\n\tusing namespace Mymath;\n\tvoid FWT(int a[],int n,LL mod)\n\t{\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;\n\t                //xor:a[i+j]=x+y,a[i+j+d]=x-y;\n\t                //and:a[i+j]=x+y;\n\t                //or:a[i+j+d]=x+y;\n\t            }\n\t}\n\n\tvoid UFWT(int a[],int n,LL mod)\n\t{\n\t\tLL rev=inv(2,mod);\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;\n\t                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n\t                //and:a[i+j]=x-y;\n\t                //or:a[i+j+d]=y-x;\n\t            }\n\t}\n\tvoid solve(int a[],int b[],int n,LL mod)\n\t{\n\t    FWT(a,n,mod);\n\t    FWT(b,n,mod);\n\t    for(int i=0;i<n;i++) a[i]=1LL*a[i]*b[i]%mod;\n\t    UFWT(a,n,mod);\n\t}\n};\nnamespace Maxflow{\n\tconst int Maxn=1005;\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tedge(int _to,int _rev,int _cap){\n\t\t\tto=_to,rev=_rev,cap=_cap;\n\t\t}\n\t};\n\tint src=1002,snk=1003;\n\tvector<edge> G[Maxn];\n\tint dist[Maxn],seen[Maxn];\n\tint n;\n\tvoid Clear(){\n\t\tfor (int i=0;i<Maxn;i++) G[i].clear();\n\t}\n\tvoid bfs(int s){\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=-1;\n\t\tdist[s]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()){\n\t\t\tint x=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tedge &e=G[x][i];\n\t\t\t\tif (e.cap && dist[e.to]==-1){\n\t\t\t\t\tdist[e.to]=dist[x]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int now,int dest,int fl){\n\t\tif (now==dest) return fl;\n\t\tfor (int &i=seen[now];i<G[now].size();i++){\n\t\t\tedge &ed=G[now][i];\n\t\t\tif (ed.cap && dist[ed.to]==dist[now]+1){\n\t\t\t\tint f=dfs(ed.to,dest,min(fl,ed.cap));\n\t\t\t\tif (f){\n\t\t\t\t\ted.cap-=f;\n\t\t\t\t\tG[ed.to][ed.rev].cap+=f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dinic(int s=src,int t=snk){\n\t\tint ret=0;\n\t\twhile (1){\n\t\t\tmemset(seen,0,sizeof(seen));\n\t\t\tbfs(s);\n\t\t\tif (dist[t]==-1) return ret;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\twhile(f){\n\t\t\t\tret+=f;\n\t\t\t\tf=dfs(s,t,INF);\n\t\t\t}\n\t\t}\n\t}\n};\nnamespace Geometry{\n\tstruct iP{\n\t\tLL x,y;\n\t\tiP(LL _x,LL _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tiP(){\n\t\t\tx=y=0;\n\t\t}\n\t\tiP operator +(iP p){\n\t\t\treturn iP(x+p.x,y+p.y);\n\t\t}\n\t\tiP operator -(iP p){\n\t\t\treturn iP(x-p.x,y-p.y);\n\t\t}\n\t\tiP operator *(LL k){\n\t\t\treturn iP(x*k,y*k);\n\t\t}\n\t\tLL det(iP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tLL dot(iP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tLL dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const iP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tstruct dP{\n\t\tdouble x,y;\n\t\tdP(double _x,double _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tdP(){\n\t\t\tx=y=0.0;\n\t\t}\n\t\tdP operator +(dP p){\n\t\t\treturn dP(x+p.x,y+p.y);\n\t\t}\n\t\tdP operator -(dP p){\n\t\t\treturn dP(x-p.x,y-p.y);\n\t\t}\n\t\tdP operator *(double k){\n\t\t\treturn dP(x*k,y*k);\n\t\t}\n\t\tdouble det(dP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tdouble dot(dP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tdouble dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const dP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tvector<iP> convex_hull(iP X[],int l){\n\t\t#define sz ret.size()\n\t\tvector<iP> ret;\n\t\tsort(X+1,X+1+l);\n\t\tret.pb(X[1]);\n\t\tfor (int i=2;i<=l;i++){\n\t\t\twhile (sz>=2 && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\tint rs=ret.size()+1;\n\t\tfor (int i=l-1;i>=1;i--){\n\t\t\twhile (sz>=rs && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst int Maxn=505;\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\nvector<int> p;\nint n;\nLL ans[Maxn][Maxn];\nmap<int,int> xmy,xay;\nint main(){\n\tn=read();\n\tn+=2;\n\tfor (int i=2;i<10000;i++){\n\t\tbool flag=true;\n\t\tfor (int j=2;j*j<=i;j++){\n\t\t\tif (i%j==0) flag=false;\n\t\t}\n\t\tif (flag) p.pb(i);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\txmy[i-j]=0;xay[i+j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (map<int,int>::iterator it=xmy.begin();it!=xmy.end();it++){\n\t\tit->second=p[cnt++];\n\t}\n\tfor (map<int,int>::iterator it=xay.begin();it!=xay.end();it++){\n\t\tit->second=p[cnt++];\n\t}\n//\tcout<<cnt<<endl;\n\t//return 0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tans[i][j]=xmy[i-j]*xay[i+j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1){\n\t\t\t\tans[i][j]=1;\n\t\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\t\t\tif (ni && nj && ni<=n && nj<=n){\n\t\t\t\t\t\tLL tmp=__gcd(ans[i][j],ans[ni][nj]);\n\t\t\t\t\t\tans[i][j]/=tmp;\n\t\t\t\t\t\tans[i][j]*=ans[ni][nj];\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=2;i<=n-1;i++){\n\t\tfor (int j=2;j<=n-1;j++){\n\t\t\t//assert(ans[i][j]<=1000000000000000LL);\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn ~~(0^_^0);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[501+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X((i+j)/2)*Y((i-j)/2);\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2)+1;\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1005;\nint a[N][N],flag[N*10],P[N*10],tot,n; \nint check1(int x,int y){\n\treturn (x+y)/2;\n}\nint check2(int x,int y){\n\treturn (x-y+n+1)/2;\n}\nint Lcm(int x,int y){\n\tif (!x||!y)return x+y;\n\treturn x/__gcd(x,y)*y;\n} \nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])for (int j=2*i;j<=10000;j++)flag[j]=1;\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])P[++tot]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1)a[i][j]=check1(i,j)*check2(i,j);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=Lcm(Lcm(a[i+1][j],a[i-1][j]),Lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n            cout << second_matrix[i][j] << ' ';\n        cout << '\\n';\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\nusing namespace std;\n\n#define NMAX 502\n#define DIM 7920\n\nint d[DIM], p[DIM];\nlong long sol[NMAX][NMAX];\n\nvoid ciur(int n) {\n    for (int i = 2; i <= n; i++) {\n        if (d[i] == 0) {\n            p[++p[0]] = i;\n            for (int j = i + i; j <= n; j += i) {\n                d[j] = 1;\n            }\n        }\n    }\n}\n\n__int128 gcd(__int128 a, __int128 b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n__int128 lcm(vector <long long>& v) {\n    __int128 l = 1;\n    for (const long long x : v) {\n        if (x == 0)\n            continue;\n        __int128 d = gcd(l, (__int128)x);\n        l = l * x / d;\n\n    }\n    return (long long)l;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << \"4 7\\n23 10\\n\";\n        return 0;\n    }\n    ciur(DIM - 1);\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            sol[i][j] = 1;\n        }\n    }\n\n    int cnt = 1;\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col > n)\n                break;\n            sol[i][col] *= p[cnt];\n            col++;\n        }\n        cnt++;\n    }\n\n    for (int i = 3; i <= n; i += 2) {\n        int lin = i;\n        for (int j = 1; j <= n; j++) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col <= 0)\n                break;\n            sol[i][col] *= p[cnt];\n            col--;\n        }\n        cnt++;\n    }\n\n    for (int i = n; i > 1; i -= 2) {\n        int lin = i;\n        for (int j = n; j >= 1; j--) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) % 2 == 0)\n                continue;\n            vector <long long> v = {sol[i - 1][j], sol[i + 1][j], sol[i][j - 1], sol[i][j + 1]};\n            sol[i][j] = lcm(v) + 1;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << sol[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[1100],na,n;\nbool p(int x){for (int i=2;i<x;i++)if (x%i==0)return 0;return 1;}\nint main(){\n\tfor (int i=2;i<=8000;i++)if (p(i))a[++na]=i;\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)cout<<a[(i+j)/2]*a[(i-j+n)/2+n+1]<<' ';\n\t\t\telse cout<<a[(i+j)/2]*a[(i-j+n)/2+n+1]*a[(i+j+1)/2]*a[(i-j+n+1)/2+n+1]+1<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lor(a,b,c) for(register int a=b;a<=c;++a)\n#define ror(a,b,c) for(register int a=c;a>=b;--a)\ntypedef long long ll;\n\nconst int MAXN=505,MAXD=7919;\nconst int movx[4]={-1,0,1,0},movy[4]={0,1,0,-1};\n\nint n;\nll p1[MAXN][MAXN],p2[MAXN][MAXN];\nbool vis[MAXD]; ll prime[MAXN<<1];\n\ninline ll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t// freopen(\"test.in\",\"r\",stdin);\n\t#endif\n\n\tscanf(\"%d\",&n);\n\n\tif(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\n\tint d=1;\n\tlor(i,2,MAXD){\n\t\tif(!vis[i]) prime[++prime[0]]=i;\n\t\tfor(register int j=1;j<=prime[0]&&i*prime[j]<=MAXD;++j) vis[i*prime[j]]=true;\n\t}\n\t\n\tint x,y,cnt=0;\n\tx=n-!(n&1); y=1;\n\tdo{\n\t\tint nx=x,ny=y; ++cnt;\n\t\twhile(nx<=n&&ny<=n){\n\t\t\tp1[nx][ny]=prime[cnt]; nx++; ny++;\n\t\t}\n\t\tif(x>=3) x-=2; else y+=2;\n\t\tif(x>=3) x-=2; else y+=2;\n\t}while(x>=1&&y<=n);\n\n\tx=1; y=1;\n\tdo{\n\t\tint nx=x,ny=y; ++cnt;\n\t\twhile(nx>=1&&ny<=n){\n\t\t\tp2[nx][ny]=prime[cnt]; nx--; ny++;\n\t\t}\n\t\tif(x+2<=n) x+=2; else y+=2;\n\t\tif(x+2<=n) x+=2; else y+=2;\n\t}while(x<=n&&y<=n);\n\n\tx=n; y=n; if(!(y&1)) --y;\n\tif(y-2>=1) y-=2; else x-=2;\n\twhile(x>=1&&y>=1){\n\t\tint nx=x,ny=y; ++cnt;\n\t\twhile(nx>=1&&ny<=n){\n\t\t\tp2[nx][ny]=prime[cnt]; nx--; ny++;\n\t\t}\n\t\tif(y-2>=1) y-=2; else x-=2;\n\t\tif(y-2>=1) y-=2; else x-=2;\n\t}\n\n\tx=1; y=n; if(!(y&1)) y--;\n\tif(y-2>=1) y-=2; else x+=2;\n\twhile(x<=n&&y>=1){\n\t\tint nx=x,ny=y; ++cnt;\n\t\twhile(nx<=n&&ny<=n){\n\t\t\tp1[nx][ny]=prime[cnt]; nx++; ny++;\n\t\t}\n\t\tif(y-2>=1) y-=2; else x+=2;\n\t\tif(y-2>=1) y-=2; else x+=2;\n\t}\n\n\tlor(i,1,n){\n\t\tlor(j,1,n){\n\t\t\tif(p1[i][j]||p2[i][j]){\n\t\t\t\tprintf(\"%lld \",(p1[i][j]?p1[i][j]:1)*(p2[i][j]?p2[i][j]:1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll tmp=1ll;\n\t\t\t\tlor(k,0,3){\n\t\t\t\t\tint nx=i+movx[k],ny=j+movy[k]; if(nx<1||nx>n||ny<1||ny>n) continue;\n\t\t\t\t\tll res=(p1[nx][ny]?p1[nx][ny]:1)*(p2[nx][ny]?p2[nx][ny]:1);\n\t\t\t\t\ttmp=tmp*res/gcd(tmp,res);\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld \",tmp+1);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,pri[10010],tot=0;\nbool nopri[10010];\nll ans[510][510];\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;}\n\nvoid sieve(int n)\n{\n    rep(i,2,n)\n    {\n        if (!nopri[i]) pri[++tot]=i;\n        for (int j=1;j<=tot && i*pri[j]<=n;j++)\n        {\n            nopri[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\n\nint main()\n{\n    sieve(10000);\n    n=read();\n    if (n==2)\n    {\n        puts(\"4 7\\n23 10\");return 0;\n    }\n    rep(i,1,20) cout << pri[i] << \" \";cout << endl;\n    rep(i,0,n+1) ans[0][i]=ans[n+1][i]=ans[i][0]=ans[i][n+1]=1;\n    int now=0;\n    rep(i,1,n)\n    {\n        int st;\n        if (i&1) st=1;else st=2;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=pri[(i+j)>>1]*pri[(i-j+n+1)/2+n];\n        }\n    }\n    rep(i,1,n) \n    {\n        int st;\n        if (i&1) st=2;else st=1;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]))+1;\n        }\n    }\n    rep(i,1,n)\n    {\n        rep(j,1,n) printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 510\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 998244353\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nll a[maxn][maxn];\nconst int S = 20050;\nbool bpr[S];\nmap<int, int> r[2];\nll gcd(ll a, ll b) {\n\tif (!b) return a;\n\treturn gcd(b, a % b);\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\t\nint main() {\n\tvi pr;\n\tfor (int i = 0; i < S; i++)\n\t\tbpr[i] = 1;\n\tfor (int i = 2; i < S; i++) {\n\t\tif (!bpr[i]) continue;\n\t\tpr.pb(i);\n\t\tfor (int j = 2; j * i < S; j++)\n\t\t\tbpr[i * j] = 0;\n\t}\n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n\t\tcout << 4 << ' ' << 7 << endl << 23 << ' ' << 10 << endl;\n\t\treturn 0;\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= 2 * n; i += 2)\n\t\tr[0][i] = pr[cnt++];\n\tfor (int i = -n - 1; i <= n + 1; i++)\n\t\tif (i % 2)\n\t\t\tr[1][i] = pr[cnt++];\n \tfor (int i = 1; i <= n; i++) {\n \t\tfor (int j = 1; j <= n; j++) {\n \t\t\tif ((i + j) % 2 == 0) {\n\t \t\t\tll ns = 1ll * max(1, r[1][i - j + 1]) * max(1, r[1][i - j - 1]) * max(1, r[0][i + j + 1]) * max(1, r[0][i + j - 1]);\n\t \t\t\ta[i][j] = ns + 1;\n\t\t\t}\n\t\t\telse a[i][j] = r[0][i + j] * r[1][i - j];\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\t/*random_shuffle(vec1.begin(), vec1.end());\n\trandom_shuffle(vec2.begin(), vec2.end());*/\n\n\tqueue<pair<ll, ll>> q;\n\tq.push({ 0, 0 });\n\n\tused[0][0] = 1;\n\tvector<pair<ll, ll>> dir1 = { {2, 0}, {0, 2} };\n\twhile (!q.empty()) {\n\t\tpair<ll, ll> v = q.front();\n\t\tq.pop();\n\n\t\tans[v.first][v.second] = vec1.front();\n\t\tvec1.pop_front();\n\n\t\tfor (auto cur : dir1) {\n\t\t\tif (!used[v.first + cur.first][v.second + cur.second] && v.first + cur.first < n && v.second + cur.second < n) {\n\t\t\t\tq.push({v.first + cur.first, v.second + cur.second});\n\t\t\t\tused[v.first + cur.first][v.second + cur.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 2 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 0;\n\t\t\t\tif (i > 0) ml = gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = gcd(ml, ans[i][j - 1]);\n\t\t\t\tif (i < n - 1) ml = gcd(ml, ans[i + 1][j]);\n\t\t\t\tif (j < n - 1) ml = gcd(ml, ans[i][j + 1]);\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MaxN = 5e2 + 17;\nlong long arr[MaxN][MaxN];\nlong long prime[2 * MaxN];\nlong long second_matrix[MaxN][MaxN];\nint x[] = {-1, 1, 0, 0};\nint y[] = {0, 0, -1, 1};\nint n;\n\nlong long lcm(long long a, long long b)\n{\n    return (a * b) / __gcd(a, b);\n}\n\nvoid erich()\n{\n    const int MaxS = 1e4 + 17;\n    bool isPrime[MaxS];\n\n    for(int i = 1; i < 2 * MaxN; ++i)\n        isPrime[i] = 1;\n\n    int next = 1;\n\n    for(int i = 2; i <= MaxS; ++i)\n    {\n        if(isPrime[i])\n        {\n            prime[next++] = i;\n\n            for(int j = i + i; j <= MaxS; j += i)\n                isPrime[j] = 0;\n\n        }\n    }\n}\n\nvoid fill_sec()\n{\n    for(int i = n - !(n % 2), j = 1; i >= 1; i -= 2, ++j)\n    {\n        int x = i;\n        int y = 1;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + j];\n            ++x;\n            ++y;\n        }\n    }\n\n    for(int i = 3, j = 1; i <= n; i += 2, ++j)\n    {\n        int x = 1;\n        int y = i;\n\n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + n / 2 +  n % 2 + j];\n            ++x;\n            ++y;\n        }\n    }\n}\n\nvoid fill_matrix()\n{\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if(!((i + j) & 1))\n                arr[i][j] = prime[(i + j) / 2] * second_matrix[i][j];\n\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if((i + j) & 1)\n            {\n                arr[i][j] = 1;\n\n                for(int k = 0; k < 4; ++k)\n                {\n                    int xx = i + x[k];\n                    int yy = j + y[k];\n\n                    if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                        arr[i][j] = lcm(arr[i][j], arr[xx][yy]);\n                }\n            }\n\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n\n    erich();\n    fill_sec();\n    fill_matrix();\n\n\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n            cout << arr[i][j] << ' ';\n        cout << '\\n';\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 510\nll a[N][N];\nvector<ll> pri;\n#define D 3000010\nbool p[D];\nvoid Pre(){\n    lol(i,D)p[i]=1;\n    for(ll i=2;i<D;i++){\n\tif(p[i]==1){\n\t    for(ll j=i*2;j<D;j+=i)p[j]=0;\n\t    pri.push_back(i);\n\t}\n    }\n}\nll gcd(ll x,ll y){\n    if(x<y)swap(x,y);\n    x%=y;\n    if(x==0)return y;\n    return gcd(x,y);\n}\nll lcm(ll x,ll y){\n    return x*y/gcd(x,y);\n}\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint main(){\n    Pre();\n    lol(i,N)lol(j,N)a[i][j]=-1;\n    int pnt=10;\n    for(int i=0;i<N;i+=4){\n\tfor(int j=0;j<N;j+=4){\n\t    ll s[4]={1,2,3,6};\n\t    lol(r,4){\n\t\tint xx=i+dx[r],yy=j+dy[r];\n\t\tif(xx<0||yy<0||xx==N||yy==N)continue;\n\t\ta[xx][yy]=s[r]*pri[pnt];\n\t    }\n\t    pnt++;\n\t    lol(r,4){\n\t\tint xx=2+i+dx[r],yy=2+j+dy[r];\n\t\tif(xx<0||yy<0||xx==N||yy==N)continue;\n\t\ta[xx][yy]=s[r]*pri[pnt];\n\t    }\n\t    pnt++;\n\t}\n    }\n    unordered_set<ll> st;\n    lol(i,N)lol(j,N)st.insert(a[i][j]);\n    lol(i,N)lol(j,N){\n\tif(a[i][j]==-1){\n\t    ll res=1;\n\t    lol(r,4){\n\t\tint xx=i+dx[r],yy=j+dy[r];\n\t\tif(xx<0||yy<0||xx==N||yy==N)continue;\n\t\tres=lcm(res,a[xx][yy]);\n\t    }\n\t    res++;\n\t    ll r=res;\n\t    while(st.find(r)!=st.end())r+=res;\n\t    st.insert(r);\n\t    a[i][j]=r;\n\t}\n    }\n    int n;cin>>n;\n    lol(i,n){\n\tlol(j,n){\n\t    if(j>0)cout<<\" \";\n\t    cout<<a[i][j];\n\t}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[555][555];\nint b[555][555];\nint ans[555][555];\nvector<int> p;\nsigned main(){\n\tic(n)\n\trep(2,i,10000)if(prime(i))p.pb(i);\n\trep(0,i,555)rep(0,j,555){\n\t\tif((i+j)%2==0){\n\t\t\ta[i][j]=p[(i+j)/2];\n\t\t\tb[i][j]=p[(i+1662-j)/2];\n\t\t\tans[i][j]=a[i][j]*b[i][j];\n\t\t}\n\t}\n\trep(0,i,555)rep(0,j,555)if(ans[i][j]==0&&i>0&&i<554)ans[i][j]=ans[i-1][j]*ans[i+1][j];\n\trep(0,i,n)rep(0,j,n)cout<<ans[i+1][j+1]<<\" \";\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int N = 505, P = 10005;\nint p[P], pc = 0;\nbool np[P];\nvoid prime_sieve(int n) {\n  for (int i = 2; i <= n; ++i) {\n    if (!np[i]) p[pc++] = i;\n    for (int j = 0; j < pc && i * p[j] <= n; ++j) {\n      np[i * p[j]] = true;\n      if (i % p[j] == 0) break;\n    }\n  }\n}\n\nll a[N][N];\n\nll lcm(ll x, ll y) {\n  if (!x || !y) return x | y;\n  return x / __gcd(x, y) * y;\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint n;\nint border(int x, int y) {\n  return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nint main() {\n  prime_sieve(10000);\n  read(n);\n  if (n == 2) {\n    write(4, 7), endl();\n    write(23, 10), endl();\n  }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) {\n      if (((i ^ j) & 1) == 0) {\n        int l1 = (i + j) / 2;\n        int l2 = n + ((i - j) / 2) + (n - 1) / 2;\n        a[i][j] = p[l1] * p[l2];\n      }\n    }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (!a[i][j]) {\n        a[i][j] = 1;\n        for (int d = 0; d < 4; ++d)\n          if (border(i + dx[d], j + dy[d]))\n            a[i][j] = lcm(a[i][j], a[i + dx[d]][j + dy[d]]);\n      }\n      write(a[i][j]), space();\n    }\n    endl();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) ((int) x.size())\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAX = 2e6;\nconst int MAXN = 505;\n\nbool bio[MAX];\nvector <int> prime;\nint n;\nll a[MAXN][MAXN];\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n        prime.pb(i);\n        for(int j = i; j < MAX; j += i)\n            bio[j] = true;\n    }\n}\n\nll d1[2 * MAXN], d2[2 * MAXN];\n\nint main(){\n    sito();\n\n    int idx = 0;\n\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    int X = 2 * n - 1;\n    cout << (ll)prime[1000] * prime[999] * prime[998] * prime[997];\n\n    REP(i, n)\n        REP(j, n){\n            if(i % 2 == 0 && j % 2 == 0){\n                a[i][j] = prime[i + j] * prime[i - j + 2 * n];\n            }\n            else if(i % 2 && j % 2){\n                a[i][j] = prime[i + j] * prime[i - j + 2 * n];\n            }\n        }\n\n    set<ll> S;\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j] == 0){\n                ll sol = 0;\n                if(i > 0) sol = a[i - 1][j];\n                if(j > 0) sol = sol == 0 ? a[i][j - 1] : sol * a[i][j - 1];\n                if(i != n - 1) sol = sol == 0 ? a[i + 1][j] : sol * a[i + 1][j];\n                if(j != n - 1) sol = sol == 0 ? a[i][j + 1] : sol * a[i][j + 1];\n                a[i][j] = sol + 1;\n            }\n        }\n\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n            //S.insert(a[i][j]);\n        }\n        cout << \"\\n\";\n    }\n    //cout << sz(S) _ n * n << \"\\n\";\n    //assert(sz(S) == n * n);\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <stdio.h>\n    #include <string>\n    #include <math.h>\n    #include<algorithm>\n    #include <numeric>\n    using namespace std;\n \n    int main(){\n      long long N;\n      cin >> N;\n      long long a[N+1][N+1]={};\n      a[1][1]=2;\n      for(int i=1;i<N;i++){\n       a[i+1][1]=4*i-1;\n        a[1][i+1]=4*i+1;\n      }\n      for(int i=2;i<=N;i++){\n       for(int j=2;j<=N;j++){\n        a[i][j]=(a[i-1][j])*(a[i][j-1])+1; \n       }\n      }\n      for(int i=1;i<=N;i++){\n       for(int j=1;j<=N;j++){\n        cout << a[i][j];\n         if(j==N){\n          cout << endl; \n         }else{\n          cout << ' '; \n         }\n       }\n      }\n      return 0;}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 1000) t++;\n    rep(i, n) p.eb(P[t++]);\n    shuffle(p);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    vll even, odd;\n    rep(i, 125) {\n        even.eb(i * 2 + 2);\n        even.eb(500 - i * 2);\n        odd.eb(i * 2 + 3);\n        odd.eb(501 - i * 2);\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * even[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * even[i / 2 - 1];\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * odd[i / 2] + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * odd[i / 2 - 1];\n        }\n    }\n    INT(N);\n    map<ll, pii> s;\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        // rep(j, N) { s[a[i][j]] = {i, j}; }\n        cout << endl;\n    }\n    // cout << (--s.end())->first << endl;\n    // cout << s.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 500\n#define MX 5000\nint u[MX+5],p[MX+5],pn;\nll a[MN+5][MN+5];\nmap<ll,int> mp;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nint main()\n{\n\tint n,i,j,k,x,y;\n\tfor(i=2;i<=MX;++i)\n\t{\n\t\tif(!u[i])p[++pn]=i;\n\t\tfor(j=1;i*p[j]<=MX;++j)if(u[i*p[j]]=1,i%p[j]==0)break;\n\t}\n\tfor(i=2;i<=MN+MN;i+=2)for(j=-MN;j<=MN;j+=2)\n\t{\n\t\tx=(i+j)/2;y=(i-j)/2;\n\t\tif(x<1||x>MN||y<1||y>MN)continue;\n\t\tfor(k=1;mp[2*p[i/2]*p[(j+MN)/2]*k]++;++k);\n\t\ta[x][y]=2*p[i/2]*p[(j+MN)/2]*k;\n\t}\n\tfor(i=1;i<=MN;++i)for(j=1;j<=MN;++j)if(!a[i][j])\n\t{\n\t\tll x=1;\n\t\tif(i>1)x=x/gcd(x,a[i-1][j])*a[i-1][j];\n\t\tif(i<MN)x=x/gcd(x,a[i+1][j])*a[i+1][j];\n\t\tif(j>1)x=x/gcd(x,a[i][j-1])*a[i][j-1];\n\t\tif(j<MN)x=x/gcd(x,a[i][j+1])*a[i][j+1];\n\t\tfor(k=1;mp[x*k+1]++;++k);\n\t\ta[i][j]=x*k+1;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i,puts(\"\"))for(j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define v vector\n#define ALL(x) x.begin(),x.end()\n#define rALL(x) x.rbegin(),x.rend()\n#define DEBUG\n\ntemplate<typename T> void DBG(const char* name, T&& H) {\n\tcerr << name << \" = \" << H << ')' << endl;\n}\n\ntemplate<typename T, typename... Args> void DBG(const char* names, T&& H, Args&&... args) {\n\tconst char* NEXT = strchr(names+1, ',');\n\tcerr.write(names, NEXT-names) << \" = \" << H << \" |\";\n\tDBG(NEXT+1, args...);\n}\n\n#ifdef DEBUG\n\t#define dbg(...) cerr << __FUNCTION__ << ' ' <<__LINE__ << \" : (\", DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n\t#define dbg(...)\n#endif\n\nusing ll = long long;\nusing ld = long double;\n\nconst long long mod = 1e9+7;\nconst long double PI = acos(-1.0);\nconst long long INF = 1e18;\nconst int maxN = 2e5+1;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nbool can(int x, int y) {\n\treturn ((x >= 0) && (y >= 0) && (x < 500) && (y < 500));\n}\n\nvector<long long> Sieve(int N) {\n\tvector<long long> primes;\n\tvector<bool> isPrime(N+1, 0);\n\tfor(int i = 2; i < N+1; i ++) {\n\t\tif(isPrime[i] == 0) {\n\t\t\tprimes.push_back(i);\n\t\t\tfor(int j = i+i; j < N+1; j += i) {\n\t\t\t\tisPrime[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn primes; \n}\n\nvoid Solve() {\n\tvector<long long> p = Sieve(int(1e5));\n\tvector<vector<long long>> mat(500, vector<long long>(500, 1));\n\tvector<pair<int, int>> start;\n\tint ptr = -1;\n\tfor(int i = 0; i < 500; i += 2) {\n\t\tptr ++;\n\t\tint x = 0, y = i;\n\t\twhile((x < 500) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx ++, y ++;\n\t\t}\n\t\tif(i == 0) continue;\n\t\tptr ++;\n\t\tx = i, y = 0;\n\t\twhile((x < 500) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx ++, y ++;\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i += 2) {\n\t\tptr ++;\n\t\tint x = i, y = 0;\n\t\twhile((x >= 0) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx --, y ++;\n\t\t}\n\t\tptr ++;\n\t\tx = 499, y = i+1;\n\t\twhile((x >= 0) && (y < 500)) {\n\t\t\tmat[x][y] *= p[ptr];\n\t\t\tx --, y ++;\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i ++) {\n\t\tfor(int j = 0; j < 500; j ++) {\n\t\t\tif(mat[i][j] != 1) continue;\n\t\t\tlong long LCM = 1;\n\t\t\tfor(int k = 0; k < 4; k ++) {\n\t\t\t\tint x = i+dx[k], y = j+dy[k];\n\t\t\t\tif(can(x, y)) {\n\t\t\t\t\tlong long other = mat[x][y];\n\t\t\t\t\tlong long GCD = __gcd(LCM, other);\n\t\t\t\t\tother /= GCD;\n\t\t\t\t\tLCM *= other;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmat[i][j] = LCM;\n\t\t}\n\t}\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N; i ++) {\n\t\tfor(int j = 0; j < N; j ++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint tt = 1; \n\tfor(int i = 1; i <= tt; i ++) {\n\t\tSolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 20000\nusing namespace std;\nll a[505][505];\nll prime[1005];\nint cnt,p[20005],n;\n\nvoid print(ll x){\n\tif(x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\n\nll lcm(ll x,ll y){\n\treturn x/__gcd(x,y)*y;\n}\n\nint main(){\n\tfor(int i=2;i<=maxn;i++){\n\t\tif(p[i]==0) prime[++cnt]=i;\n\t\tif(cnt==1000) break;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<=maxn;j++){\n\t\t\tp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tprint(4),putchar(' '),print(7);puts(\"\");\n\t\tprint(23),putchar(' '),print(10);puts(\"\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!((i&1)^(j&1))) a[i][j]=prime[(i+j)/2]*prime[n+(n+1+i-j)/2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)^(j&1)){\n\t\t\t\ta[i][j]=1;\n\t\t\t\tif(i>1) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\t\tif(i<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\t\tif(j>1) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\t\tif(j<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) print(a[i][j]),putchar(' ');\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nusing std::__gcd;\nint n,prime[10100000],a[5100][5100],len;\nbool isPrime[10001000];\nint LCM(int a,int b,int c,int d){\n\tb=a*b/__gcd(a,b);\n\tc=b*c/__gcd(b,c);\n\td=c*d/__gcd(c,d);\n\treturn d;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t} \n\tfor(int i=2;i<=1000000;i++)\n\t\tisPrime[i]=true;\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!isPrime[i])continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i)\n\t\t\tisPrime[j]=false;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tif(isPrime[i])prime[++len]=i;\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\ta[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1)continue;\n\t\t\tint x=(i+j)/2,y=(i-j)/2+n+(n-1)/2+1;\n\t\t\ta[i][j]=prime[x]*prime[y];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)continue;\n\t\t\ta[i][j]=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld\",a[i][j]);\n\t\t\tif(j==n)puts(\"\");\n\t\t\telse putchar(' ');\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define lor(a,b,c) for(register int a=b;a<=c;++a)\n#define ror(a,b,c) for(register int a=c;a>=b;--a)\ntypedef long long ll;\n\nconst int MAXN=505,MAXD=7919;\nconst int movx[4]={-1,0,1,0},movy[4]={0,1,0,-1};\n\nint n; ll a[MAXN][MAXN];\nbool vis[MAXD]; ll prime[MAXN<<1];\n\ninline ll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\n\ninline ll lcm(ll a,ll b){\n\tif(!a||!b) return a|b;\n\treturn a/gcd(a,b)*b;\n}\n\ninline void judge(){\n\tint x,a[505][505];\n\tscanf(\"%d\",&x); lor(i,1,x) lor(j,1,x) scanf(\"%d\",&a[i][j]);\n\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\n\tif(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\n\tlor(i,2,MAXD){\n\t\tif(!vis[i]) prime[++prime[0]]=i;\n\t\tfor(register int j=1;j<=prime[0]&&i*prime[j]<=MAXD;++j) vis[i*prime[j]]=true;\n\t}\n\n\tlor(i,1,n) lor(j,1,n) if(!((i+j)&1)){\n\t\ta[i][j]=prime[(i+j)>>1]*prime[n+(n+1)/2+(i-j)/2];\n\t}\n\tlor(i,1,n) lor(j,1,n) if((i+j)&1){\n\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t}\n\tlor(i,1,n){\n\t\tlor(j,1,n) printf(\"%lld \",a[i][j]); printf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 500001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nint solve(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\tif (b == 1) { return 1; }\n\treturn a % b;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvel prime(0);\n\tint mod = 510;\n\tfor (int i = 1000; i < 10000; i++) {\n\t\tif (is_prime(i)) { prime.push_back(i); }\n\t}\n\tvvel ans(n, vel(n,1));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tint x = (i + j) / 2;\n\t\t\t\tint y = per((i - j) / 2, mod);\n\t\t\t\tans[i][j] = prime[x] * prime[y];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tj--;\n\t\t\t\tint x = (i + j) / 2;\n\t\t\t\tint y = per((i - j) / 2, mod);\n\t\t\t\tans[i][j+1] = prime[x] * prime[y];\n\t\t\t\tj += 2;\n\t\t\t\tx = (i + j) / 2;\n\t\t\t\ty = per((i - j) / 2, mod);\n\t\t\t\tans[i][j-1] *= prime[x] * prime[y];\n\t\t\t\tj--;\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t\tcout << ans[i][j];\n\t\t\tif (j == n - 1) { cout << endl; }\n\t\t\telse { cout << \" \"; }\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(int x){\n\tif(x <= 1) return false;\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 500;\nlong long r[maxn][maxn], p[2][4 * maxn];\nlong long gcd(long long a, long long b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nint main(){\n\tvector<int> primes;\n\tfor(int i = 1; primes.size() < 2000; i++) if(is_prime(i)) primes.push_back(i);\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) r[i][j] = 1;\n\tint stk = 0;\n\tfor(int i = 0; i < maxn + maxn; i += 2){\n\t\tp[0][i] = stk++;\n\t\tp[1][i] = stk++;\n\t}\n\treverse(p[1], p[1] + maxn);\n\tassert(stk <= primes.size());\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) {\n\t\tint x = i - j + maxn;\n\t\tint y = i + j;\n\t\tif(x % 2 == 0){\n\t\t\tr[i][j] *= primes[p[0][x]] * primes[p[1][y]];\n\t\t}\n\t}\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++){\n\t\tint x = i - j + maxn;\n\t\tif(x % 2 == 1){\n\t\t\tvector<long long> cand;\n\t\t\tif(i) cand.push_back(r[i - 1][j]);\n\t\t\tif(j) cand.push_back(r[i][j - 1]);\n\t\t\tif(i + 1 < maxn) cand.push_back(r[i + 1][j]);\n\t\t\tif(j + 1 < maxn) cand.push_back(r[i][j + 1]);\n\t\t\tlong long lc = cand[0] / gcd(cand[0], cand[1]) * cand[1];\n\t\t\tfor(int j = 2; j < cand.size(); j++) lc = lc / gcd(lc, cand[j]) * cand[j];\n\t\t\tr[i][j] = lc + 1;\n\t\t}\n\t}\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[i][j], mx = r[i][j + 1];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 1);\n\t\t}\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[j][i], mx = r[j + 1][i];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tcout << r[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define forn(i, a, n) for(ll i = a; i < n; i++)\n\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <map>\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\nll a[597][507];\nset<ll> was;\nll n;\n\nll gcd(ll a, ll b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b%a, a);\n}\nint main()\n{\n\t/*\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen (\"output.txt\", \"w\", stdout);\n\t*/\n\tcin >> n;\n\tll co = 1;\n\tforn(i, 0, n)\n\t{\n\t\tforn(j, 0, n)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t\ta[i][j] = co++*2;\n\t\t\twas.insert(a[i][j]);\n\t\t}\n\t}\n\tforn(i, 0, n)\n\t{\n\t\tforn(j, 0, n)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tll le, ri, up, down;\n\t\t\t\tle = j > 0 ? a[i][j - 1] : 1;\n\t\t\t\tri = j < n - 1 ? a[i][j + 1] : 1;\n\t\t\t\tup = i > 0 ? a[i - 1][j] : 1;\n\t\t\t\tdown = i < n - 1 ? a[i + 1][j] : 1;\n\t\t\t\tll mid = le;\n\t\t\t\tmid = mid*ri / gcd(mid, ri);\n\t\t\t\tmid = mid*up / gcd(mid, up);\n\t\t\t\tmid = mid*down / gcd(mid, down);\n\t\t\t\twhile (was.find(mid+1) != was.end())\n\t\t\t\t{\n\t\t\t\t\tmid <<= 1;\n\t\t\t\t}\n\t\t\t\tmid++;\n\t\t\t\ta[i][j] = mid;\n\t\t\t\twas.insert(mid);\n\t\t\t}\n\t\t}\n\t}\n\tforn(i, 0, n)\n\t{\n\t\tforn(j, 0, n)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,tot;\nconst int N=1005;\nLL a[N][N],zhi[N<<1],vis[10010];\nLL GCD(LL a,LL b){return b?GCD(b,a%b):a;}\nLL LCM(LL a,LL b){return a&b?a/GCD(a,b)*b:a+b;}\nvoid YYCH()\n{\n\tvis[1]=1;\n\tfor(int i=2;i<=10000;++i)\n\t{\n\t\tif(!vis[i])zhi[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*zhi[j]<=10000;++j)\n\t\t{\n\t\t\tvis[i*zhi[j]]=1;\n\t\t\tif(!(i%zhi[j]))break;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;if(n==2)return printf(\"4 7\\n23 10\\n\")==233;\n\tYYCH();\n\t for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = zhi[(i + j) / 2] * zhi[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = LCM(LCM(a[i - 1][j], a[i][j - 1]),\n                          LCM(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);/*\n    for(int i=1;i<=n;++i)\n    \tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n    \t\ta[i][j]=zhi[(i+j)/2]*zhi[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n    \tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t\ta[i][j]=LCM(LCM(a[i-1][j],a[i][j-1]),LCM(a[i+1][j],a[i][j+1]))+1;\n    for(int i=1;i<=n;++i,puts(\"\"))\n    \tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);*/\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  constexpr int n = 500;\n  VV<lint> a(n, V<lint>(n));\n  set<int> se;\n  int x = 10;\n  for (int k = 1; k < 2 * n - 1; k += 2) {\n    for (int i = 0; i < n; ++i) {\n      int j = k - i;\n      if (j < 0 or j >= n) continue;\n      if (~i & 1) {\n        a[i][j] = x;\n        se.insert(x);\n      } else {\n        a[i][j] = 2 * x;\n        se.insert(2 * x);\n        while (se.count(x)) ++x;\n      }\n    }\n  }\n  V<> di{1, -1, 0, 0};\n  V<> dj{0, 0, 1, -1};\n  for (int k = 0; k < 2 * n - 1; k += 2) {\n    for (int i = 0; i < n; ++i) {\n      int j = k - i;\n      if (j < 0 or j >= n) continue;\n      lint x = 1;\n      for (int d = 0; d < 4; ++d) {\n        int ni = i + di[d];\n        int nj = j + dj[d];\n        if (ni < 0 or ni >= n) continue;\n        if (nj < 0 or nj >= n) continue;\n        x *= a[ni][nj];\n      }\n      while (x < 1e14) x *= 2;\n      a[i][j] = x + 1;\n    }\n  }\n  int N; cin >> N;\n  for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) {\n    cout << a[i][j] << \" \\n\"[j == N - 1];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=1;i<=n;i++)for(ll j=(i+1&1)+1;j<=n;j+=2)a[i][j]=p[i+j>>1]*p[n+(i-j>>1)+(n+1)>>1];\n\tfor(ll i=1;i<=n;i++)for(ll j=1;j<=n;j++)if((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=400 +117;\nconst int MM=10000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL ans[NN][NN]={};\nLL lcm(LL a,LL b){\n\treturn a/__gcd(a,b)*b;\n}\nint pr[MM]={},psiz=0;\nint np[MM]={};\nvoid getprime(int n){\n\tnp[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(!np[i]){\n\t\t\tpr[psiz++]=i;\n\t\t}\n\t\tfor(int j=0;pr[j]*i<=n;++j){\n\t\t\tnp[pr[j]*i]=1;\n\t\t\tif(!(i%pr[j]))break;\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tif(n==2){\n\t\tprintf(\"2 5\\n\");\n\t\tprintf(\"7 36\\n\")\n\t\treturn 0;\n\t}\n\tgetprime(10000);\n\tint mn=(1-n)/2,mx=(n-1)/2;\n\tmx-=mn;\n\tfor(int i=0;i<=n+1;++i){\n\t\tfor(int j=0;j<=n+1;++j){\n\t\t\tans[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif((i+j)&1)continue;\n\t\t\tint c=(i-j)/2;\n\t\t\tint d=(i+j)/2;\n\t\t\tLL res=pr[c-mn]*pr[mx+d];\n\t\t\tans[i][j]=res;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif((i+j)&1){\n\t\t\t\tLL now=1;\n\t\t\t\tnow=lcm(now,ans[i][j-1]);\n\t\t\t\tnow=lcm(now,ans[i][j+1]);\n\t\t\t\tnow=lcm(now,ans[i-1][j]);\n\t\t\t\tnow=lcm(now,ans[i+1][j]);\n\t\t\t\tans[i][j]=now+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cassert>\nusing namespace std;\nlong long gcd(long long a,long long b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint n;\nmap<long long,bool>mp;\nlong long a[510][510];\nbool used[250050];\nint p[250050],cnt;\nlong long calc(int i,int j)\n{\n\tlong long res=1,s;\n\tif(i>1)res=res/gcd(res,a[i-1][j])*a[i-1][j];\n\tif(i<500)res=res/gcd(res,a[i+1][j])*a[i+1][j];\n\tif(j>1)res=res/gcd(res,a[i][j-1])*a[i][j-1];\n\tif(j<500)res=res/gcd(res,a[i][j+1])*a[i][j+1];\n\ts=res;\n\twhile(mp[s])s+=res;\n\tmp[s]=1;\n\tif(s>1e15)assert(0);\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=62500;++i)\n\t{\n\t\tp[++cnt]=2*i+1;\n\t\tp[++cnt]=4*i+2;\n\t\tmp[2*i+1]=1,mp[4*i+2]=1;\n\t}\n\tint st=1,ed=125000;\n\tfor(int i=1;i<=499;i+=2)\n\t\tfor(int j=1;j<=499;j+=2)\n\t\t{\n\t\t\tif((i+j)&3)a[i][j+1]=p[st++],a[i+1][j]=p[st++];\n\t\t\telse a[i][j+1]=p[ed--],a[i+1][j]=p[ed--];\n\t\t}\n\tfor(int i=1;i<=500;++i)\n\t\tfor(int j=2-(i&1);j<=500;j+=2)a[i][j]=calc(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<list>\n#include<deque>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1000)\nvector<int>prim;\n\nvoid prim_make(int k){\n\tif (k >= 2)prim.push_back(2);\n\tif (k >= 3)prim.push_back(3);\n\tif (k >= 5)prim.push_back(5);\n\tint x = 7;\n\tbool v;\n\twhile (x <= k){\n\t\tv = true;\n\t\tfor (int i = 2; prim[i] * prim[i] <= x; i++){\n\t\t\tif (x%prim[i] == 0){\n\t\t\t\tv = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v)prim.push_back(x);\n\t\tif (x % 6 == 1)x += 4;\n\t\telse x += 2;\n\t}\n\treturn;\n}\n\n\n\n\n\n\nint main(){\n\tlong long a[N][N];\n\tset<long long>s;\n\tvector<int>ve1,ve2;\n\tint n;\n\tlong long k, x, y, z;\n\tlong long ans;\n\tbool v1, v2;\n\tprim_make(100000);\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tx = 9000;\n\twhile(x>0){\n\t\tve1.push_back(x);\n\t\tx -= 2;\n\t}\n\tx = 9002;\n\twhile (x<18002){\n\t\tve2.push_back(x);\n\t\tx += 2;\n\t}\n\tx = 3;\n\twhile (x<12000){\n\t\tve1.push_back(x);\n\t\tx += 6;\n\t}\n\tx = 23997;\n\twhile (x > 12000){\n\t\tve2.push_back(x);\n\t\tx -= 6;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tf(i, n){\n\t\tf(j, n)a[i][j] = -1;\n\t}\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif ((i + j) % 4 == 0){\n\t\t\t\ta[i][j] = ve1[x];\n\t\t\t\ts.insert(ve1[x]);\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ((i + j) % 4 == 2){\n\t\t\t\ta[i][j] = ve2[y];\n\t\t\t\ts.insert(ve2[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\tf(i,n){\n\t\tf(j,n){\n\t\t\tif (a[i][j] == -1){\n\t\t\t\tans = 1;\n\t\t\t\tv1 = true;\n\t\t\t\tv2 = true;\n\t\t\t\tx = 0;\n\t\t\t\tif (i > 0){\n\t\t\t\t\tans = ans*a[i - 1][j];\n\t\t\t\t\tif (a[i - 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i - 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (i < (n - 1)){\n\t\t\t\t\tans = ans*a[i + 1][j];\n\t\t\t\t\tif (a[i + 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i + 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j > 0){\n\t\t\t\t\tans = ans*a[i][j - 1];\n\t\t\t\t\tif (a[i][j-1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j-1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j < (n - 1)){\n\t\t\t\t\tans = ans*a[i][j + 1];\n\t\t\t\t\tif (a[i][j + 1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j + 1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (v1){\n\t\t\t\t\tf(ii, x-1)ans = ans / 2;\n\t\t\t\t}\n\t\t\t\tif (v2){\n\t\t\t\t\tf(ii, x-1)ans = ans / 3;\n\t\t\t\t}\n\t\t\t\tx = 2;\n\t\t\t\ta[i][j] = ans + 1;\n\t\t\t\ts.insert((ans + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < (n - 1))printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define ll long long\nusing namespace std;\nconst int N=505,M=10000;\nint n,p[M+5],ps,w=251;\nll a[N][N];\nbool b[M+5];\nint main(){\n\tcin>>n;\n\tfo(i,2,M){\n\t\tif(!b[i])p[++ps]=i;\n\t\tfor(int j=1,u;(u=i*p[j])<=M;++j){\n\t\t\tb[u]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tfo(i,1,250)a[1][i*2-1]=p[i],a[1][i*2]=p[i]*p[i+1];\n\tfo(i,2,500)fo(j,1,500)a[i][j]=a[i-1][j];\n\tfo(i,1,250){\n\t\tint a1=p[w+i],a2=p[w+i]*p[w+i+1];\n\t\tfo(j,1,500)a[i*2-1][j]*=a1,a[i*2][j]*=a2;\n\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ff first\n#define ss second\n#define ll long long\nusing namespace std;\ntypedef pair<char,int> pii;\nset<ll>mapa;\nconst int maxv=2300000;\nint n,pos[maxv+10],br;\nll primes[maxv],rows[1010],cols[1010],aa[519][510];\nvector<ll>a[510][510];\nvoid check(){\n\nll maxx=LONG_MIN;\nll minn=LONG_MAX;\nset<ll>mapa2;\n    for(int i=1;i<=n;i++){\n\n        for(int j=1;j<=n;j++){\n\n            if(i<n){\n                mapa.insert(max(aa[i][j],aa[i+1][j])%min(aa[i][j],aa[i+1][j]));\n            }\n            if(j<n){\n                mapa.insert(max(aa[i][j],aa[i][j+1])%min(aa[i][j],aa[i][j+1]));\n            }\n\n            maxx=max(maxx,aa[i][j]);\n            minn=min(minn,aa[i][j]);\n            mapa2.insert(aa[i][j]);\n        }\n\n    }\nprintf(\"%d %d %lld %lld\\n\",mapa.size(),mapa2.size(),maxx,minn);\n}\nvoid sito(){\n\n    for(int i=2;i<=maxv;i++){\n        if(pos[i])continue;\n        primes[++br]=i;\n        for(int j=i;j<=maxv;j+=i)pos[j]=1;\n    }\n\n}\nll lcm(ll a,ll b){\n  return (a/__gcd(a,b))*b;\n}\nvoid fix(int x,int y){\n\n    ll lc=1;\n\n    if(aa[x+1][y]!=0){lc=lcm(lc,aa[x+1][y]);}\n    if(aa[x-1][y]!=0){lc=lcm(lc,aa[x-1][y]);}\n    if(aa[x][y+1]!=0){lc=lcm(lc,aa[x][y+1]);}\n    if(aa[x][y-1]!=0){lc=lcm(lc,aa[x][y-1]);}\n\n    aa[x][y]=lc+1;\n}\nint dist(int x,int y,int x1,int y1){\n   return abs(x-x1)+abs(y-y1);\n}\nint main(){\n\n    ///freopen(\"test.txt\",\"r\",stdin);\n\n    scanf(\"%d\",&n);\n\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n\n    sito();\n\n    int curr=0;\n    for(int i=0;i<n;i++)\n        rows[i*2]=primes[++curr];\n\n    for(int i=0;i<n;i++)\n        cols[i*2]=primes[++curr];\n\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n\n            if(dist(1,1,i,j)%2==0){\n                a[i][j].pb(rows[dist(1,1,i,j)]);\n                aa[i][j]=rows[dist(1,1,i,j)];\n            }\n\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n\n            if(n%2){\n               if(dist(n,1,i,j)%2==0){\n                a[i][j].pb(cols[dist(n,1,i,j)]);\n                aa[i][j]*=cols[dist(n,1,i,j)];\n               }\n            }\n            else{\n                if(dist(n,1,i,j)%2==1){\n                    a[i][j].pb(cols[dist(n,1,i,j)-1]);\n                    aa[i][j]*=cols[dist(n,1,i,j)-1];\n                }\n            }\n\n        }\n    }\n\n\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if((i+j)%2)fix(i,j);\n            printf(\"%lld \",aa[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nbool notp[MAXN*MAXN];\nint prm[MAXN*MAXN],pn;\nvoid euler(int n)\n{\n\tnotp[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(!notp[i])prm[++pn]=i;\n\t\tfor(int j=1;j<=pn && i*prm[j]<=n;++j)\n\t\t{\n\t\t\tnotp[i*prm[j]]=1;\n\t\t\tif(!(i%prm[j]))break;\n\t\t}\n\t}\n}\nll a[MAXN][MAXN];\ninline ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nunordered_set<ll> s;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\teuler(n*500);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!((i+j)&1))\n\t\t\t{\n\t\t\t\ta[i][j]=prm[(i+j)/2]*prm[(i-j+n+1)/2+n];\n\t\t\t\ts.insert(a[i][j]);\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))continue;\n\t\t\ta[i][j]=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\ta[i][j]=lcm(a[i][j],a[x][y]);\n\t\t\t}\n\t\t\tll x=a[i][j];\n\t\t\t++a[i][j];\n\t\t\twhile(s.count(a[i][j]))a[i][j]+=x;\n\t\t\ts.insert(a[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[514][514];\nint b[514][514];\nint ans[514][514];\nvector<int> p;\nsigned main(){\n\tic(n)\n\trep(2,i,3700)if(prime(i))p.pb(i);\n\trep(0,i,501)rep(0,j,501){\n\t\tif((i+j)%2==0){\n\t\t\ta[i][j]=p[(i+j)/2];\n\t\t\tb[i][j]=p[(i+500-j)/2];\n\t\t\tans[i][j]=a[i][j]*b[i][j];\n\t\t}\n\t}\n\trep(0,i,501)rep(0,j,501){\n\t\tif((i+j)%2==1){\n\t\t\tif(i==0||i==500){\n\t\t\t\tans[i][j]=a[i][j-1]*b[i][j-1]*a[i][j+1]*b[i][j+1]+1;\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tans[i][j]=a[i-1][j]*b[i-1][j]*a[i+1][j]*b[i+1][j]+1;\n\t\t\t}\t\n\t\t}\n\t}\n\trep(0,i,n){\n\t\trep(0,j,n)cout<<ans[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 5e2 + 10,Lim = 1e4 + 10;\n\nint dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\nint prime[Lim],vis[Lim],cnt = 0;\nll res[N][N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline ll Lcm(ll a,ll b) {\n\treturn a * b / __gcd(a,b);\n}\n\ninline void init(int n) {\n\tFor(i,2,n) {\n\t\tif(!vis[i]) prime[++cnt] = i;\n\t\tfor(int j = 1;j <= cnt && i * prime[j] <= n;j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"AGC027D.in\",\"r\",stdin);\n\tfreopen(\"AGC027D.out\",\"w\",stdout);\n#endif\n\n\tint n = read();\n\tif(n == 2) { puts(\"4 7\\n23 10\");return 0; }\n\tinit(1e4);\n\tFor(i,1,n) For(j,1,n) if((i + j) % 2 == 0)\n\t\tres[i][j] = prime[(i + j) / 2];\n\tFor(i,1,n) For(j,1,n) if((i + j) % 2 == 0)\n\t\tres[i][j] *= prime[n + (n - i + 1 + j) / 2];\n\tFor(i,1,n) For(j,1,n) if(!res[i][j]) {\n\t\tll Prod = 1;\n\t\tFor(k,0,3) {\n\t\t\tint x = i + dir[k][0],y = j + dir[k][1];\n\t\t\tif(x <= 0 || y <= 0 || x > n || y > n) continue;\n\t\t\tProd = Lcm(Prod,res[i + dir[k][0]][j + dir[k][1]]);\n\t\t}\n\t\tres[i][j] = Prod + 1;\n\t}\n\tFor(i,1,n) For(j,1,n) printf(\"%lld%c\",res[i][j],j == n ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n\treturn y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n\treturn x / GCD(x, y) * y;\n}\nvoid sieve() {\n\tfor(int i=2;i<=MAXM;i++) {\n\t\tif( !vis[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;i*prm[j]<=MAXM;j++) {\n\t\t\tvis[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n\tsieve(); int N;\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tMat[i][j] = 1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) == (j & 1) ) {\n\t\t\t\tMat[i][j] = prm[(i + j) / 2] * prm[(i+N+1-j)/2 + N];\n\t\t\t\tMat[i+1][j] = LCM(Mat[i+1][j], Mat[i][j]);\n\t\t\t\tMat[i-1][j] = LCM(Mat[i-1][j], Mat[i][j]);\n\t\t\t\tMat[i][j+1] = LCM(Mat[i][j+1], Mat[i][j]);\n\t\t\t\tMat[i][j-1] = LCM(Mat[i][j-1], Mat[i][j]);\n\t\t\t}\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) != (j & 1) )\n\t\t\t\tMat[i][j]++;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<N;j++)\n\t\t\tprintf(\"%lld \", Mat[i][j]);\n\t\tprintf(\"%lld\\n\", Mat[i][N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b){ return a%b ? gcd(b, a%b) : b; }\nlong long lcm(long long a, long long b){ return a/gcd(a, b)*b; }\n\nint main(){\n    deque<int> prime;\n    prime.push_back(2);\n    prime.push_back(3);\n    for(int i=5;prime.size()<1000;i+=2){\n        bool ok = true;\n        for(auto& t : prime) if(i%t == 0) ok = false;\n        if(ok) prime.push_back(i);\n    }\n    vector<int> p1, p2;\n    for(int i=0;i<250;i++){\n        p1.push_back(prime.front());\n        prime.pop_front();\n        p1.push_back(prime.back());\n        prime.pop_back();\n        p2.push_back(prime.front());\n        prime.pop_front();\n        p2.push_back(prime.back());\n        prime.pop_back();\n    }\n    vector<vector<long long>> m(500, vector<long long>(500, 1));\n    int v = 0;\n    for(int i=0;i<500;i++){\n        for(int j=0;j<500;j++){\n            if((i+j)%2) continue;\n            m[i][j] = p1[(i+j)/2] * p2[(j-i+498)/2];\n            v = max(v, (i+j)/2);\n            v = max(v, (j-i+498)/2);\n        }\n    }\n    for(int i=0;i<500;i++){\n        for(int j=0;j<500;j++){\n            if((i+j)%2 == 0) continue;\n            int dx[] = {-1, 0, 1, 0};\n            int dy[] = {0, -1, 0, 1};\n            for(int d=0;d<4;d++){\n                int nx = i+dx[d];\n                int ny = j+dy[d];\n                if(nx < 0 || 500 <= nx || ny < 0 || 500 <= ny) continue;\n                m[i][j] = lcm(m[i][j], m[nx][ny]);\n            }\n            ++m[i][j];\n        }\n    }\n    int N; cin >> N;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++) cout << m[i][j] << \" \";\n        cout << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 501;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tinc(i, n) {\n\tinc(j, n) {\n\t\tcout << i + j + 2 << (j == n - 1 ? \"\\n\" : \" \");\n\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\nconst int maxn = 250000 + 10;\nconst int maxl = 500 + 10;\ntypedef long long ll;\nbool notprime[maxn];\nll prime[maxn], primecnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxn;i++){\n\t\tif(!notprime[i]) prime[primecnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxn && j < primecnt;j++){\n\t\t\tll t = i * prime[j];\n\t\t\tnotprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\nmap<ll ,bool> used;\nll a[maxl][maxl];\nvoid solve(int n){\n\tfor(int i = 0;i <= n + 1;i++) for(int j = 0;j <= n + 1;j++) a[i][j] = 1; \n\tint cnt = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 == 1) a[i][j] = prime[cnt++]; \n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\tll x = a[i][j - 1] * a[i][j + 1] * a[i - 1][j] * a[i + 1][j];\n\t\t\t\twhile(used[x + 1]) x = x * a[i - 1][j];\n\t\t\t\ta[i][j] = x + 1;\n\t\t\t\tused[x + 1] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tsieve();\n\tint n;\n\tscanf(\"%d\",&n);\n\tsolve(n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%lld%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 510\nll a[N][N];\nvector<ll> pri;\n#define D 5000010\nbool p[D];\nvoid Pre(){\n    lol(i,D)p[i]=1;\n    for(ll i=2;i<D;i++){\n\tif(p[i]==1){\n\t    for(ll j=i*2;j<D;j+=i)p[j]=0;\n\t    pri.push_back(i);\n\t}\n    }\n}\nll gcd(ll x,ll y){\n    if(x<y)swap(x,y);\n    x%=y;\n    if(x==0)return y;\n    return gcd(x,y);\n}\nll lcm(ll x,ll y){\n    return x*y/gcd(x,y);\n}\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint main(){\n    Pre();\n    lol(i,N)lol(j,N)a[i][j]=-1;\n    int pnt=10;\n    for(int i=0;i<N;i+=4){\n\tfor(int j=0;j<N;j+=4){\n\t    ll s[4]={1,2,3,6};\n\t    lol(r,4){\n\t\tint xx=i+dx[r],yy=j+dy[r];\n\t\tif(xx<0||yy<0||xx==N||yy==N)continue;\n\t\ta[xx][yy]=s[r]*pri[pnt];\n\t    }\n\t    pnt++;\n\t    lol(r,4){\n\t\tint xx=2+i+dx[r],yy=2+j+dy[r];\n\t\tif(xx<0||yy<0||xx==N||yy==N)continue;\n\t\ta[xx][yy]=s[r]*pri[pnt];\n\t    }\n\t    pnt++;\n\t}\n    }\n    unordered_set<ll> st;\n    lol(i,N)lol(j,N)st.insert(a[i][j]);\n    lol(i,N)lol(j,N){\n\tif(a[i][j]==-1){\n\t    ll res=1;\n\t    lol(r,4){\n\t\tint xx=i+dx[r],yy=j+dy[r];\n\t\tif(xx<0||yy<0||xx==N||yy==N)continue;\n\t\tres=lcm(res,a[xx][yy]);\n\t    }\n\t    res++;\n\t    ll r=res;\n\t    while(st.find(r)!=st.end())r+=res;\n\t    st.insert(r);\n\t    a[i][j]=r;\n\t}\n    }\n    int n;cin>>n;\n    lol(i,n){\n\tlol(j,n){\n\t    if(j>0)cout<<\" \";\n\t    cout<<a[i][j];\n\t}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n\nvector<int> makePrimeLst(int N)\n{\n    if (N < 2) return vector<int>();\n    if (N == 2) return vector<int>{2};\n    vector<int> ans;\n    vector<int> alive(N+1, 1);\n    for (int i=2; (long long)i*i<=(long long)N; i++)\n    {\n        if (alive[i]) ans.push_back(i);\n        for (int t = i; t<=N; t += i) alive[t] = 0;\n    }\n    for (int i=ans.back()+1; i<=N; i++) if (alive[i]) ans.push_back(i);\n    return ans;\n}\n\nconstexpr int Nmax = 501;\nlint ans[Nmax][Nmax];\n\nint main()\n{\n    vector<int> info = makePrimeLst(10000);\n\n    vector<lint> p, q;\n    int now = 2;\n    while (p.size() < Nmax + 1)\n    {\n        p.insert(p.begin(), info[now++]);\n        q.insert(q.begin(), info[now++]);\n        p.push_back(info[now++]);\n        q.push_back(info[now++]);\n    }\n\n    int N;\n    cin >> N;\n    REP(i, N) REP(j, N)\n    {\n        int u = (i + j) / 2, v = (i + (Nmax - 1 - j)) / 2;\n        cout << (((i + j) & 1) ? p[u + 1] * q[v + 1] : p[u] * p[u + 1] * q[v] * q[v + 1] + 3) << (j == N - 1 ? \"\\n\" : \" \");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nmap<__int128,int> mp;\n__int128 lcm(__int128 x,__int128 y){\n\tif (!(x&&y)) return x^y;\n\treturn (__int128)x*y/__gcd(x,y);\n}\nconst int N=600;\nconst long long INF=1e18;\nlong long z[N][N];\nint n,a[N*N];\nint main(){\n\tscanf(\"%d\",&n);\n\tint tot=((n*n)+1)/2;\n\tfor (int i=1; i<=tot; ++i) a[i]=i*2;\n\t//random_shuffle(a+1,a+tot+1);\n\tint d=0;\n\tfor (int i=2; i<=n; i+=2)\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=a[++d];\n\tfor (int i=(n%2==0?n-1:n); i>=1; i-=2){\n\t\tstack<int> s;\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\ts.push(a[++d]);\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=s.top(),s.pop();\n\t}\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n   \tcerr<<\"tot\"<<tot<<endl;\n\tgetchar(); getchar();*/\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?2:1); j<=n; j+=2){\n\t\t\t__int128 k=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t__int128 zz=k;\n\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\tif (zz+C>INF){\n\t\t\t\tswap(z[i+1][j],z[i+3][j]);\n\t\t\t\tk=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t\tzz=k;\n\t\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\t}\n\t\t\tif (zz+C>INF){\n\t\t\t\tswap(z[i+1][j],z[i+3][j]);\n\t\t\t\tswap(z[i][j+1],z[i][j+3]);\n\t\t\t\tk=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t\tzz=k;\n\t\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\t}\n\t\t\tif (zz+C>INF){\n\t\t\t\tswap(z[i+1][j],z[i+3][j]);\n\t\t\t\tk=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t\tzz=k;\n\t\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\t}\n            //cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<(long long)zz<<\" \"<<(long long)k<<\" \"<<z[i-1][j]<<\" \"<<z[i][j-1]<<\" \"<<z[i+1][j]<<\" \"<<z[i][j+1]<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\t//assert(zz+C<=INF);\n\t\t\t//getchar();\n\t\t\tz[i][j]=zz+C;\n\t\t\tmp[zz+C]=1;\n\t\t}\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%lld \",z[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 3000; \nconst long long INF = 0x3f3f3f3f; \n\nint cnt, idx, n; \nlong long ans[550][550], prime[Maxv], max = -INF; \nlong long x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \nbool notPrime[Maxv]; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void Sieve() {\n    for (int i = 2; i <= Maxv; i++) {\n        if (!notPrime[i]) {\n            prime[++cnt] = i; \n        }\n\n        for (int j = 1; j <= cnt && i * prime[j] <= Maxv; j++) {\n            int num = i * prime[j]; \n            notPrime[num] = true; \n\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    Sieve(); \n\n    /*for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", prime[i]); \n    }*/\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = prime[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= prime[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Author: hotaruijika\n * Created: 2018.09.15 23:58:01\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n;\nlong long f[11111], a[500 * 500 + 10], color[500 * 500 + 10];\nmap <int, int> id;\nvector <long long> prime;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 2; i <= 1e4 + 10; ++i) {\n\t\tif (!f[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tf[i] = i;\n\t\t}\n\t\tfor (int j = 0; j < (int) prime.size() && i * prime[j] <= 1e4 && prime[j] <= f[i]; ++j) \n\t\t\tf[i * prime[j]] = prime[j];\n\t}\n\tfor (int i = 1; i <= n * n; ++i) {\n\t\tint x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tif ((x + y) % 2) {\n\t\t\ta[i] = prime[(x + y) / 2 - 1] * prime[2 * n - x + y - 1];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n * n; ++i) {\n\t\tint x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tif ((x + y) % 2 == 0) {\n\t\t\tlong long lcm = 1;\n\t\t\tfor (int k = 0; k < 4; ++k) if (x + dx[k] > 0 && x + dx[k] <= n && y + dy[k] > 0 && y + dy[k] <= n) {\n\t\t\t\tif (a[(x + dx[k] - 1) * n + y + dy[k]])\n\t\t\t\tlcm = a[(x + dx[k] - 1) * n + y + dy[k]] / __gcd(a[(x + dx[k] - 1) * n + y + dy[k]], lcm) * lcm;\n\t\t\t}\n\t\t\ta[i] = lcm + 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n * n; ++i) cout << a[i] << (i % n ? \" \" : \"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 10010;\n\ninline ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint tot;\nint pri[MAXN];\nint chk[MAXN];\nll a[1010][1010];\n\ninline void Sieve(int n) {\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(!chk[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot; j++) {\n\t\t\tif(i * pri[j] > n) break;\n\t\t\tchk[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\n\nunordered_map<int, int>id1, id2;\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tSieve(10000);\n\tint n = ri + 1, N = 0;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\ta[i][j] = 1;\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) {\n\t\t\t\tif(!id1[i + j]) id1[i + j] = ++N;\n\t\t\t\tif(!id2[i - j]) id2[i - j] = ++N;\n\t\t\t\ta[i][j] = pri[id1[i + j]] * pri[id2[i - j]];\n\t\t\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tfor(int j = 1; j < n; j++)\n\t\t\tif((i + j) & 1) printf(\"%lld \", a[i][j]);\n\t\t\telse printf(\"%lld \", lcm(lcm(a[i + 1][j], a[i - 1][j]), lcm(a[i][j + 1], a[i][j - 1])) + 1);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 200010;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst int INF = 1000000010;\n\nint n;\nint b[MAXN], tot, p[MAXN];\nll a[555][555];\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a%b) : a;\n}\n\nll lcm(ll a)\n{\n\treturn a;\n}\n\ntemplate<class A, class... B>\nll lcm(A a, B... b)\n{\n\tauto c = lcm(b...);\n\treturn c ? (a ? a*c/gcd(a, c) : c) : a;\n}\n\nint main()\n{\n\t\n\tfor (int i = 2; i <= 200000; ++ i)\n\t\tif (!b[i])\n\t\t{\n\t\t\tp[++ tot] = i;\n\t\t\tfor (int j = i+i; j <= 200000; j += i)\n\t\t\t\tb[j] = 1;\n\t\t}\n\tfor (int i = 1; i <= 500; ++ i)\n\t\tfor (int j = 1; j <= 500; ++ j)\n\t\t{\n\t\t\tif ((i+j)%2 == 1) continue;\n\t\t\ta[i][j] = (ll)p[(i+j)/2]*p[(i-j)/2+750];\n\t\t}\n\t\n\tfor (int i = 1; i <= 500; ++ i)\n\t\tfor (int j = 1; j <= 500; ++ j)\n\t\t{\n\t\t\tif ((i+j)%2 == 0) continue;\n\t\t\ta[i][j] = lcm(a[i-1][j], a[i][j-1], a[i][j+1], a[i+1][j])+1;\n\t\t}\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 510\nll a[N][N];\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    return b?gcd(a%b,b):a;\n}\nll gce(ll a,ll b){return a/gcd(a,b)*b;}\nint main(){\n    vector<ll> p;\n    for(ll i=2;p.size()<N*2;i++){\n\tbool ok=1;for(auto x:p)ok&=i%x>0;\n\tif(ok)p.push_back(i);\n    }\n    lol(i,N)lol(j,N){\n\tif((i+j)%2==0)a[i][j]=p[i]*p[j+N];\n    }\n    lol(i,N)lol(j,N){\n\tif((i+j)%2==1){\n\t    ll p=1,dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\t    lol(r,4){\n\t\tll xx=j+dx[r],yy=i+dy[r];\n\t\tif(xx<0||xx==N||yy<0||yy==N)continue;\n\t\tp=gce(p,a[yy][xx]);\n\t    }\n\t    a[i][j]=p+1;\n\t}\n    }\n    ll n;cin>>n;\n    lol(i,n){\n\tlol(j,n){if(j)cout<<\" \";\n\t    cout<<a[i+1][j+1];\n\t}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint ch[100000];\ndeque<int> pr;\nllong P1[500];\nllong P2[500];\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tfor (int i = 3; i < 100000; i += 2) {\n        if (ch[i]) continue;\n        pr.push_back(i);\n        for (llong j = (llong)i * i; j < 100000; j += i + i) ch[j] = 1;\n\t}\n        \n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n\t}\n\tfor (int i = 0; i <= ((n + n - 2) >> 1); ++i) {\n        P1[i] = pr.front();\n        pr.pop_front();\n        P2[i] = pr.front();\n        pr.pop_front();\n\t}\n\tfor (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) & 1) {\n                int x = (i + j), y = (i - j + (n - 1));\n                llong ret = 1;\n                if (x > 0) ret *= P1[x - 1 >> 1];\n                if (x + 1 <= n + n - 2) ret *= P1[x + 1 >> 1];\n                if (y > 0) ret *= P2[y - 1 >> 1];\n                if (y + 1 <= n + n - 2) ret *= P2[y + 1 >> 1];\n                printf(\"%lld\", ret + 1);\n            }\n            else {\n                printf(\"%lld\", P1[i + j >> 1] * P2[i - j + (n - 1) >> 1]);\n            }\n            if (j + 1 < n) printf(\" \");\n            else printf(\"\\n\");\n        }\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat;\nint n,p[10005],vis[10005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint nex(int x){\n\tif (!mat[x])mat[x]=p[p[0]--];\n\treturn mat[x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=p[0]/2;i++)swap(p[i],p[p[0]-i+1]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=nex(i+j);\n\tmat.clear();\n\tfor(int i=n;i;i--)\n\t\tfor(int j=n;j;j--)\n\t\t\tif ((i+j)%2==0)a[i][j]*=nex(i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=lcm(a[i-1][j],lcm(a[i][j-1],lcm(a[i+1][j],a[i][j+1])))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=505;\n\nint n,p[N<<1],len;\nLL a[N][N];\nbool b[10005];\nLL gcd(LL x,LL y) { \n    return y == 0 ? x : gcd(y,x % y); \n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t}\n\tfor(int i=0;i<=n+1;i++)\n\tfor(int j=0;j<=n+1;j++)\n\t\ta[i][j]=1LL;\n\tfor(int i=2;len<2*n;i++){\n\t\tif(!b[i])p[++len]=i;\n\t\tfor(int j=1;j<=len&&p[j]*i<=10000;j++){\n\t\t\tb[p[j]*i]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)a[i][j]*=p[(i+j)>>1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)a[i][j]*=p[((i-j+n+1)>>1)+n];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2){\n\t\t\t\tLL u=a[i+1][j]/gcd(a[i+1][j],a[i][j+1])*a[i][j+1];\n\t\t\t\tLL v=a[i-1][j]/gcd(a[i-1][j],a[i][j-1])*a[i][j-1];\n\t\t\t\ta[i][j]=u/gcd(u,v)*v+1LL;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 3e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\tfor (int i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tcout << \"2\";\n\treturn 0;\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\ntemplate <size_t N>\nclass sieve_of_eratosthenes {\n    std::bitset<N> is_prime_;\n\n  public:\n    constexpr sieve_of_eratosthenes(){\n      is_prime_ = ~is_prime_;\n      is_prime_.reset(0), is_prime_.reset(1);\n      for (size_t p = 2; p < N; p++) {\n        if (!is_prime_.test(p)) continue;\n        for (size_t j = 2; j * p < N; j++) {\n          is_prime_.reset(p * j);\n        }\n      }\n    }\n\n    // Return the bitset testing if a number is prime.\n    constexpr const auto& is_prime() const {return is_prime_;}\n\n    // Returns the vector of prime numbers.\n    template <typename T>\n    auto primes() const {\n      std::vector<T> primes{}; \n      for (size_t i = 0; i < N; i++) {\n        if (is_prime_.test(i)) primes.push_back(i);\n      }\n      return primes;\n    }\n};\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  auto primes = sieve_of_eratosthenes<4000>{}.primes<int>();\n  int n; std::cin >> n;\n  auto ans = std::vector<std::vector<long long>>(n, std::vector<long long>(n, 0));\n  auto pop = [&] {\n    static int i = 0;\n    assert(i < n);\n    return primes.at(i++);\n  };\n  for (int i = 0; i < n; i += 2) {\n    auto p = pop();\n    for (int j = 0; j < n; j += 2) {\n      ans.at(i).at(j) = p;\n    }\n  }\n  for (int j = 1; j < n; j += 2) {\n    auto p = pop();\n    for (int i = 1; i < n; i += 2) {\n      ans.at(i).at(j) = p;\n    }\n  }\n  auto put = [&] (int i, int j) {\n    constexpr std::array<int, 4> di = {-1, +1, 0, 0};\n    constexpr std::array<int, 4> dj = {0, 0, -1, +1};\n    auto& here = ans.at(i).at(j) = 1;\n    for (int k = 0; k < 4; k++) {\n      auto nxi = i + di.at(k);\n      auto nxj = j + dj.at(k);\n      if (nxi < 0 || n <= nxi || nxj < 0 || n <= nxj) continue;\n      auto x = ans.at(nxi).at(nxj);\n      assert(x > 1);\n      here *= x;\n    }\n    here++;\n  };\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) put(i, j);\n    }\n  }\n  for (auto&& v : ans) {\n    for (int i = 0; i < n; i++) {\n      std::cout << (i > 0 ? \" \" : \"\") << v.at(i);\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll gcd(ll a, ll b){\n  if(b == 0){\n    return a;\n  }\n  else{\n    return gcd(b,(a%b));\n  }\n}\nll lcm(ll a,ll b){\n  return a/gcd(a,b)*b;\n}\n\nint main() {\n  int n;\n  cin>>n;\n  ll vec[n][n];\n  map<ll,int> ma;\n  ll z;\n  if(n%2==0){\n    z=(n*n)/2;\n  }\n  else{\n    z=(n/2)*((n+1)/2)*2;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      vec[i][j]=1;\n    }\n  }\n  ll a=2,b=z+1;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if((i+j)%2==1){\n        if(i%2==0){\n          vec[i][j]=b;\n          ma[b]++;\n          b--;\n        }\n        else{\n          vec[i][j]=a;\n          ma[a]++;\n          a++;\n        }\n      }\n    }\n  }\n  ll c;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if((i+j)%2==0){\n        if(i>0){\n          vec[i][j]=lcm(vec[i][j],vec[i-1][j]);\n        }\n        if(i<n-1){\n          vec[i][j]=lcm(vec[i][j],vec[i+1][j]);\n        }\n        if(j>0){\n          vec[i][j]=lcm(vec[i][j],vec[i][j-1]);\n        }\n        if(j<n-1){\n          vec[i][j]=lcm(vec[i][j],vec[i][j+1]);\n        }\n        c=vec[i][j];\n        while(ma[vec[i][j]+1]>0){\n          vec[i][j]+=c;\n        }\n        vec[i][j]++;\n        ma[vec[i][j]]++;\n      }\n    }\n  }        \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      cout<<vec[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nll lcm(ll a, ll b) {\n    return a / __gcd(a, b) * b; \n}\n\nvoid solve() {\n    int N;\n    cin >> N;\n\n    vector<int> isprime(10001, 1);\n    isprime[0] = isprime[1] = 0;\n    for(int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            for(int j = i + i; j < 10001; j += i) {\n                isprime[j] = 0;\n            }\n        }\n    }\n    vector<ll> primes;\n    for (int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    vector<vector<ll>> P1(N, vector<ll>(N)), P2(N, vector<ll>(N));\n    vector<vector<ll>> ans(N, vector<ll>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                ll p1 = primes[(i + j) / 2];\n                ll p2 = primes[primes.size() - 1 - (i - j + N) / 2];\n                ans[i][j] = p1 * p2;\n            }\n        }\n    }\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, -1, 0, 1};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 1) {\n                ll l = 1;\n                for(int k = 0; k < 4; k++) {\n                    int di = i + dy[k];\n                    int dj = j + dx[k];\n                    if (di < 0 || di >= N || dj < 0 || dj >= N) continue;\n                    l = lcm(l, ans[di][dj]);\n                }\n                ans[i][j] = l + 1;\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long mat[505][505];\n\nlong long gcd(long long a,long long b)\n{\n\treturn b ? gcd(b,a % b) : a;\n}\n\nlong long lcm(long long a,long long b)\n{\n\tif(!b || !a) return a + b;\n\treturn a / gcd(a,b) * b;\n}\n\nint primes[1050];\n\nvoid sieve()\n{\n\tint cnt = 0;\n\tfor(int i = 2;cnt <= 1020; ++ i)\n\t{\n\t\tint flg = 0;\n\t\tfor(int j = 2;j * j <= i; ++ j)\n\t\t\tif(i % j == 0)\n\t\t\t{\n\t\t\t\tflg = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(!flg) primes[++ cnt] = i;\n\t}\n}\n\nint main()\n{\n\tsieve();\n\tint n; scanf(\"%d\",&n);\n\tfor(int i = 0;i <= n + 1; ++ i)\n\t\tfor(int j = 0;j <= n + 1; ++ j)\n\t\t\tmat[i][j] = 1;\n\tfor(int i = 0;i <= n + 1; ++ i)\n\t\tfor(int j = 0;j <= n + 1; ++ j)\n\t\t\tif((i + j) % 2 == 0)\n\t\t\t\tmat[i][j] *= primes[(i + j) / 2 + 1],mat[i][j] *= primes[(i + (n - j + 1)) / 2 + (n + 1)];\n//\tlong long maxn = 0;\n\tfor(int i = 1;i <= n; ++ i,printf(\"\\n\"))\n\t\tfor(int j = 1;j <= n; ++ j)\n\t\t{\n\t\t\tif((i + j) % 2 == 1)\n\t\t\t\tmat[i][j] = 1 + lcm(lcm(mat[i - 1][j],mat[i][j - 1]),lcm(mat[i + 1][j],mat[i][j + 1]));\n\t\t\tprintf(\"%lld \",mat[i][j]);\n\t\t//\tmaxn = max(maxn,mat[i][j]);\n\t\t}\n//\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=1e3+10;\nint n;\nll a[maxn][maxn];\nset<ll> s;\nvector<int> v;\n\ninline ll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\ninline ll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\nconst int xx=1e6;\nint pcnt,p[xx];\nbool prm[xx];\nmap<int,int> mp1,mp2;\n\nint main(){\n\tfor(int i=2;i<xx;++i){\n\t\tif(!prm[i])\n\t\t\tp[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt&&(ll)i*p[j]<xx;++j){\n\t\t\tprm[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<=n+1;++i)\n\t\tfor(int j=0;j<=n+1;++j)\n\t\t\ta[i][j]=1;\n\t{\n\t\tint cnt=0;\n\t\tfor(int i=2;i<=2*n;++i)\n\t\t\tif(i&1)\n\t\t\t\tmp1[i]=p[++cnt];\n\t\tfor(int i=1-n;i<=n-1;++i)\n\t\t\tif(i&1)\n\t\t\t\tmp2[i]=p[++cnt];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1,cnt=1;j<=n;++j)\n\t\t\tif(i+j&1){\n\t\t\t\tll now=mp1[i+j]*mp2[i-j];\n\t\t\t\ta[i][j]=now;\n\t\t\t\ts.insert(now);\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i+j&1^1){\n\t\t\t\tll tmp=lcm(a[i-1][j],a[i][j-1]);\n\t\t\t\ttmp=lcm(tmp,a[i][j+1]);\n\t\t\t\ttmp=lcm(tmp,a[i+1][j]);\n\t\t\t\tll now=tmp+1;\n\t\t\t\twhile(s.count(now))\n\t\t\t\t\tnow+=tmp;\n\t\t\t\ta[i][j]=now;\n\t\t\t\ts.insert(now);\n\t\t\t}\n\tfor(int i=1;i<=n;++i,puts(\"\"))\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tcout<<a[i][j]<<' ';\n\t//\t\tif(a[i][j]>1e15)\n\t//\t\t\tcerr<<\"#\";\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst long long MaxN = 5e2 + 17;\nlong long arr[MaxN][MaxN];\nlong long prime[4 * MaxN];\nlong long second_matrix[MaxN][MaxN];\nint x[] = {-1, 1, 0, 0};\nint y[] = {0, 0, -1, 1};\nint n = 502;\nmap<long long, bool> mp;\n \nlong long lcm(long long a, long long b)\n{\n    return (a / __gcd(a, b)) * b;\n}\n \nvoid erich()\n{\n    const int MaxS = 2e4 + 17;\n    bool isPrime[MaxS];\n \n    for(int i = 2; i < MaxS; ++i)\n        isPrime[i] = 1;\n \n    int next = 1;\n \n    for(int i = 2; i < MaxS; ++i)\n    {\n        if(isPrime[i])\n        {\n            prime[next++] = i;\n \n            for(int j = i + i; j < MaxS; j += i)\n                isPrime[j] = 0;\n \n        }\n    }\n}\n \nvoid fill_sec()\n{\n    for(int i = n - !(n % 2), j = 1; i >= 1; i -= 2, ++j)\n    {\n        int x = i;\n        int y = 1;\n \n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + j];\n            ++x;\n            ++y;\n        }\n    }\n \n    for(int i = 3, j = 1; i <= n; i += 2, ++j)\n    {\n        int x = 1;\n        int y = i;\n \n        while(x <= n && y <= n)\n        {\n            second_matrix[x][y] = prime[n + n / 2 +  n % 2 + j];\n            ++x;\n            ++y;\n        }\n    }\n}\n \nvoid fill_matrix()\n{\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if(!((i + j) & 1))\n                arr[i][j] = prime[(i + j) / 2] * second_matrix[i][j];\n \n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            if((i + j) & 1)\n            {\n                arr[i][j] = 1;\n \n                for(int k = 0; k < 4; ++k)\n                {\n                    int xx = i + x[k];\n                    int yy = j + y[k];\n \n                    if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                        arr[i][j] = lcm(arr[i][j], arr[xx][yy]);\n                }\n \n                ++arr[i][j];\n            }\n \n}\nbool check(long long a, long long b)\n{\n    if((max(a, b) % min(a, b)) != 1)\n    {\n        cout << a << ' ' << b << ' ' << (max(a, b) % min(a, b)) <<  '\\n';\n        exit(0);\n    }\n \n    return (max(a, b) % min(a, b)) == 1;\n}\nbool check()\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            assert(arr[i][j] <= 1e15);\n \n            for(int k = 0; k < 4; ++k)\n            {\n                int xx = i + x[k];\n                int yy = j + y[k];\n \n                if(xx >= 1 && xx <= n && yy >= 1 && yy <= n)\n                    assert(check(arr[i][j], arr[xx][yy]));\n \n            }\n        }\n    }\n \n    return true;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n \n    erich();\n    fill_sec();\n    fill_matrix();\n \n   /* for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            if(!((i + j) & 1))\n                cout << prime[(i + j) / 2] << ' ';\n            else\n                cout << 0 << ' ';\n        }\n \n        cout << '\\n';\n    }\n \n    cout << '\\n';\n \n     for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n            cout << second_matrix[i][j] << ' ';\n        cout << '\\n';\n    }*/\n \n    check();\n \n    int m;\n    cin >> m;\n \n \n \n    for(int i = 1; i <= m; ++i)\n    {\n        for(int j = 1; j <= m; ++j)\n            cout << arr[i][j] << ' ';\n        cout << '\\n';\n    }\n \n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e4+10;\nint p[N],lim=10000,p1;\nint flag[N];\nint q[N],q1;\nll a[505][505];\nmap<int,int> px,py;\nint n;\nvoid prep(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!flag[i])p[++p1]=i;\n\t\tfor (int j=1;j<=p1;j++){\n\t\t\tint x=i*p[j];\n\t\t\tif (x>n)break;\n\t\t\tflag[x]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\nll lcm(ll a,ll b){\n\tif (!a||!b)return a+b;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tcin>>n;\n\tif (n==2){\n\t\tcout<<\"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tprep(lim);\n\tp1=0;p[0]=1;\n\tfor (int i=0,j=999;i<j;i++,j--)\n\t\tq[++q1]=p[i],q[++q1]=p[j];\n\tp1=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1)continue;\n\t\t\tif (!px[i+j])px[i+j]=q[++p1];\n//\t\t\tif (!py[i-j])py[i-j]=q[++p1];\n//\t\t\ta[i][j]=px[i+j]*py[i-j];\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1)continue;\n\t\t\tif (!py[i-j])py[i-j]=q[++p1];\n\t\t\ta[i][j]=px[i+j]*py[i-j];\n\t\t}\n\t}\n//\tcout<<q[p1]<<endl;\n\tll mx=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1);else continue;\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t\t\tmx=max(mx,a[i][j]);\n\t\t\tif (a[i][j]>1e15){\n\t\t\t\tcout<<px[i+j-1]<<' '<<px[i+j+1]<<endl;\n\t\t\t\tcout<<py[i-j-1]<<' '<<py[i-j+1]<<endl;\n\t\t\t\tcout<<i<<' '<<j<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//\tcout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long x,long long y) {\n\tif (x<y) swap(x,y);\n\tif (y == 0) return x;\n\treturn gcd(y,x%y);\n}\n\nlong long a[600][600];\n\nint main() {\n\tint n;;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i&1) {\n\t\t\tfor (int j = 1; j <= n; j++) if (i==1) a[i][j] = 2*j+1;\n\t\t\telse {\n\t\t\t\tif (j == 1) a[i][j] = a[i-1][j]+2;\n\t\t\t\telse {\n\t\t\t\t\tlong long g = gcd(a[i-1][j],a[i][j-1]);\n\t\t\t\t\ta[i][j] = a[i-1][j]/g*a[i][j-1]+2;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = n; j > 0; j--) \n\t\t\t\tif (j == n) a[i][j] = a[i-1][j]+2;\n\t\t\t\telse {\n\t\t\t\t\tlong long g = gcd(a[i-1][j],a[i][j+1]);\n\t\t\t\t\ta[i][j] = a[i-1][j]/g*a[i][j+1]+2;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\n\t}\n\tfor (int i = 1; i<= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) cout << a[i][j] << \" \";\n\t\tcout << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nint N;\nint p[MAXN], pn;\nbool np[MAXN];\n\ninline void init(int n) {\n\tregister int i, j;\n\tnp[1] = 1;\n\tfor(i = 2; i <= n; ++i) {\n\t\tif(!np[i])\n\t\t\tp[++pn] = i;\n\t\tfor(j = 1; j <= pn && i * p[j] <= n; ++j) {\n\t\t\tnp[i * p[j]] = 1;\n\t\t\tif(i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tregister int i, j; init(1e4);\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; ++i) {\n\t\tfor(j = 0; j < N; ++j) {\n\t\t\tint s = (i + j) >> 1, d = (i - j) >> 1;\n\t\t\tif((i ^ j) & 1) printf(\"%lld \", 1ll * p[s + 1] * p[d + N + (N >> 1) + 1]);\n\t\t\telse printf(\"%lld \", 1ll * p[s + 1] * p[s] * p[d + N + (N >> 1) + 1] * p[d + N + (N >> 1)] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\nnamespace MATH\n{\n\tconst int n = (int) 1e7;\n\n\tint p[n + 5], pri[n + 5], pri_cnt = 0;\n\n\tinline void init()\n\t{\n\t\tp[1] = 1;\n\t\tfor(int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif(!p[i]) p[i] = i, pri[++pri_cnt] = i;\n\t\t\tfor(int j = 1; j <= pri_cnt && i * pri[j] <= n; ++j)\n\t\t\t{\n\t\t\t\tp[i * pri[j]] = pri[j];\n\t\t\t\tif(i % pri[j] == 0) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAXN = 500;\n\nint n;\n\ninline void input()\n{\n\tn = read<int>();\n}\n\ninline void solve()\n{\n\tif(n == 2) { puts(\"4 7\\n23 10\"); return; }\n\n\tstatic int col[MAXN + 5][MAXN + 5];\n\tstatic LL a[MAXN + 5][MAXN + 5];\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) col[i][j] = (i + j) & 1;\n\tfor(int i = 0; i <= n + 1; ++i) for(int j = 0; j <= n + 1; ++j) a[i][j] = 1;\n\n\tstatic unordered_map<int, int> id0, id1;\n\tint cnt = 0;\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 0)\n\t{\n\t\tif(!id0.count(i + j)) id0[i + j] = ++cnt;\n\t\tif(!id1.count(i - j)) id1[i - j] = ++cnt;\n\t\ta[i][j] *= MATH::pri[id0[i + j]];\n\t\ta[i][j] *= MATH::pri[id1[i - j]];\n\t}\n\n\tauto lcm = [] (LL x, LL y) { return x * y / __gcd(x, y); };\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 1)\n\t{\n\t\ta[i][j] = lcm(a[i][j], a[i - 1][j]);\n\t\ta[i][j] = lcm(a[i][j], a[i + 1][j]);\n\t\ta[i][j] = lcm(a[i][j], a[i][j - 1]);\n\t\ta[i][j] = lcm(a[i][j], a[i][j + 1]);\n\t\t++a[i][j];\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld%c\", a[i][j], j == n ? '\\n' : ' ');\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int int\n#define ii pair<int, int>\n#define vi vector<int>\n#define pb emplace_back\n#define sz(x) (int)x.size()\n#define all(v) v.begin(), v.end()\n#define x first\n#define y second\n#define rep(i, j, k) for(i=j; i<k; i++)\n#define sep(i, j, k) for(i=j; i>k; i--)\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nconst int inf = 1e9+7;\nconst int N = 2e3+5;\nint n, k, id=0;\nint A[N], dp[N][N];\n\nbool solve()\n{\n\tint i, j, a=0, b=0, ans = 1, x;\n\tcin>>n;\n\trep(i, 1, n+1){\n\t\trep(j, 1, n+1){\n\t\t\tif((i+j)&1) cout<<2<<\" \";\n\t\t\telse cout<<3<<\" \";\n\t\t}\n\t\tcout<<\"\\n\";\n\t}\n}\n\nsigned main()\n{\n\tios\n\tint i, t=1, j, x;\n\t// cin>>t;\n\twhile(t--) \n\t\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) ((int) x.size())\n#define pb(x) push_back(x)\n\ntypedef unsigned long long ll;\ntypedef pair<int, int> point;\n\nconst int MAX = 2e6;\nconst int MAXN = 505;\n\nbool bio[MAX];\nvector <int> prime;\nint n;\nll a[MAXN][MAXN];\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n        prime.pb(i);\n        for(int j = i; j < MAX; j += i)\n            bio[j] = true;\n    }\n}\n\nll gcm(ll a, ll b){\n    return a * b / __gcd(a, b);\n}\n\nint main(){\n    sito();\n\n    int idx1 = 0;\n    int idx2 = 125000;\n\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    REP(i, n)\n        REP(j, n){\n            if(i % 2 == 0 && j % 2 == 0){\n                a[i][j] = prime[idx1 ++];\n            }\n            else if(i % 2 && j % 2){\n                a[i][j] = prime[idx2 --];\n            }\n        }\n\n    set<ll> S;\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j] == 0){\n                ll sol = 0;\n                if(i > 0) sol = a[i - 1][j];\n                if(j > 0) sol = sol == 0 ? a[i][j - 1] : gcm(sol, a[i][j - 1]);\n                if(i != n - 1) sol = sol == 0 ? a[i + 1][j] : gcm(sol, a[i + 1][j]);\n                if(j != n - 1) sol = sol == 0 ? a[i][j + 1] : gcm(sol, a[i][j + 1]);\n                a[i][j] = sol + 1;\n            }\n        }\n\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        //    S.insert(a[i][j]);\n        }\n        cout << \"\\n\";\n    }\n    //cout << sz(S) _ n * n << \"\\n\";\n    //assert(sz(S) == n * n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) ((int) x.size())\n#define pb(x) push_back(x)\n\ntypedef unsigned long long ll;\ntypedef pair<int, int> point;\n\nconst int MAX = 2e6;\nconst int MAXN = 505;\n\nbool bio[MAX];\nvector <int> prime;\nint n;\nll a[MAXN][MAXN];\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n        prime.pb(i);\n        for(int j = i; j < MAX; j += i)\n            bio[j] = true;\n    }\n}\n\nll d1[2 * MAXN], d2[2 * MAXN];\n\nint main(){\n    sito();\n\n    int idx = 0;\n\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    REP(i, 2 * n)\n        d1[i] = prime[idx ++];\n    REP(i, 2 * n)\n        d2[i] = prime[idx ++];\n\n    REP(i, n)\n        REP(j, n){\n            if(i % 2 == 0 && j % 2 == 0){\n                a[i][j] = d1[i + j] * d2[i - j + n];\n            }\n            else if(i % 2 && j % 2){\n                a[i][j] = d1[i + j] * d2[i - j + n];\n            }\n        }\n\n    set<ll> S;\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j] == 0){\n                ll sol = 0;\n                if(i > 0) sol = a[i - 1][j];\n                if(j > 0) sol = sol == 0 ? a[i][j - 1] : sol * a[i][j - 1];\n                if(i != n - 1) sol = sol == 0 ? a[i + 1][j] : sol * a[i + 1][j];\n                if(j != n - 1) sol = sol == 0 ? a[i][j + 1] : sol * a[i][j + 1];\n                a[i][j] = sol + 1;\n            }\n        }\n\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n            //S.insert(a[i][j]);\n        }\n        cout << \"\\n\";\n    }\n    //cout << sz(S) _ n * n << \"\\n\";\n    //assert(sz(S) == n * n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nbool Isprime[233333];\nll prime[233333];\nvoid init(int T){\n\tmem(Isprime,true);*prime = 0;\n\tfor(int i=2;i<=T;i++){\n\t\tif(Isprime[i]){\n\t\t\tprime[++*prime] = i;\n\t\t}\n\t\tfor(int j=1;j<=*prime && i * prime[j] <= T;++j){\n\t\t\tIsprime[i*prime[j]] = false;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nll mp1[233333],mp2[233333];\nmap<ll,ll> mp3;\nll ans[505][505],n;\nint main(){\n\tinit(8000);\n\tn = rd();\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tmp3.clear();\n\tll wzp = 0;\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp1[i+j]) mp1[i+j] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n)\n\t\t\tif(((i+j)&1) && !mp2[i-j+n]) mp2[i-j+n] = prime[wzp++];\n\tRep(i,1,n)Rep(j,1,n){\n\t\tif((i+j)&1){\n\t\t\tans[i][j] = (ll)mp1[i+j]*mp2[i-j+n];\n\t\t\twhile(mp3[ans[i][j]]) ans[i][j]+=(ll)mp1[i+j]*mp2[i-j+n];\n\t\t\t//printf(\"{%d %d}\\n\",i,j);\n\t\t\tmp3[ans[i][j]]++;\n\t\t}\n\t}\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tll tmp = 1;\n\t\tif(1<=i-1) tmp = tmp * ans[i-1][j] / __gcd(tmp,ans[i-1][j]);\n\t\tif(1<=j-1) tmp = tmp * ans[i][j-1] / __gcd(tmp,ans[i][j-1]);\n\t\tif(i+1<=n) tmp = tmp * ans[i+1][j] / __gcd(tmp,ans[i+1][j]);\n\t\tif(j+1<=n) tmp = tmp * ans[i][j+1] / __gcd(tmp,ans[i][j+1]);\n\t\tans[i][j] = tmp+1;\n\t\twhile(mp3[ans[i][j]]) ans[i][j]+=tmp;\n\t\tmp3[ans[i][j]++];\n\t}\n\tRep(i,1,n){\n\t\tRep(j,1,n)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pii PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst int M = 500;\n\nLL A[M][M];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nvoid Check() {\n  set<LL> used;\n  rep(i, M) {\n    rep(j, M) {\n      assert(!used.count(A[i][j]));\n      used.insert(A[i][j]);\n      rep(k, 4) {\n        int ni = i + dy[k];\n        int nj = j + dx[k];\n        if (ni < 0 || M <= ni) continue;\n        if (nj < 0 || M <= nj) continue;\n        LL x = A[i][j];\n        LL y = A[ni][nj];\n        assert(max(x, y)%min(x, y) == 1);\n      }\n    }\n  }\n}\n\nusing Fact = vector<pii>;\nconst LL INF = 1e16;\nbool queued[M][M];\nFact F[M][M];\n\nLL DeFact(Fact &fs) {\n  LL ret = 1;\n  for (pii &p : fs) {\n    rep(i, p.YY) {\n      if (INF/p.XX <= ret) return INF;\n      ret *= p.XX;\n    }\n  }\n  return ret;\n}\n\nFact GcdFact(Fact a, Fact b) {\n  Fact ret;\n  while (a.size() && b.size()) {\n    int x = a.back().XX;\n    int y = b.back().XX;\n    if (x > y) a.pop_back();\n    else if (x < y) b.pop_back();\n    else {\n      assert(x == y);\n      ret.eb(pii(x, min(a.back().YY, b.back().YY)));\n      a.pop_back();\n      b.pop_back();\n    }\n  }\n  reverse(all(ret));\n  return ret;\n}\n\nset<Fact> qued;\nvector<Fact> as = {{pii(2, 6), pii(3, 4), pii(5, 2), pii(7, 1), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(29, 1), pii(31, 1)},\n  {pii(2, 8), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(29, 1)},\n  {pii(2, 8), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(31, 1)},\n  {pii(2, 8), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 1), pii(13, 1), pii(17, 1), pii(19, 1), pii(23, 1), pii(37, 1)},\n  {pii(2, 6), pii(3, 4), pii(5, 2), pii(7, 2), pii(11, 2), pii(13, 2), pii(17, 1), pii(19, 1), pii(23, 1)},\n  {pii(2, 3), pii(3, 4), pii(5, 2), pii(7, 3), pii(11, 2), pii(13, 2), pii(17, 1), pii(19, 1), pii(23, 1)},\n  {pii(2, 0), pii(3, 6), pii(5, 2), pii(7, 3), pii(11, 2), pii(13, 2), pii(17, 1), pii(19, 1), pii(23, 1)},\n};\n\nFact FindUnused(Fact v) {\n  if (!qued.count(v)) return v;\n\n  set<Fact> watched;\n  queue<Fact> que;\n  que.push(v);\n  watched.insert(v);\n  while (!que.empty()) {\n    Fact fs = que.front(); que.pop();\n    int n = fs.size();\n    rrep(i, n) {\n      if (fs[i].YY == 0) continue;\n      fs[i].YY--;\n      if (!watched.count(fs)) {\n        if (!qued.count(fs)) return fs;\n        que.push(fs);\n        watched.insert(fs);\n      }\n      fs[i].YY++;\n    }\n  }\n  return Fact();\n}\n\nint cnt = 0;\nvoid FillByLeast(int i, int j) {\n  LL l = 1;\n  rep(k, 4) {\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if (ni < 0 || M <= ni) continue;\n    if (nj < 0 || M <= nj) continue;\n    assert(A[ni][nj] > 0);\n    LL g = __gcd(A[ni][nj], l);\n    l /= g;\n    assert(INF/l > A[ni][nj]);\n    l *= A[ni][nj];\n  }\n  A[i][j] = l+1;\n  cnt += l <= LL(1e15);\n}\n\nbool is_composite[114514];\nvector<LL> primes;\n\nvoid Fill() {\n  reps(i, 2, 114514) {\n    if (is_composite[i]) continue;\n    primes.eb(i);\n    for (LL j=LL(i)*i; j<114514; j+=i) {\n      is_composite[j] = 1;\n    }\n  }\n\n  vector<int> xs, ys;\n  rep(i, M) {\n    rep(j, M) {\n      if (i%2 != j%2) continue;\n      xs.eb(i+j);\n      ys.eb(i-j);\n    }\n  }\n  sort(all(xs));\n  xs.erase(unique(all(xs)), xs.end());\n  sort(all(ys));\n  ys.erase(unique(all(ys)), ys.end());\n\n  primes.resize(xs.size() + ys.size());\n  deque<LL> X, Y;\n  \n  int k = 0;\n  while (k < primes.size()) {\n    if (X.size() < xs.size()) X.eb(primes[k++]);\n    if (Y.size() < ys.size()) Y.eb(primes[k++]);\n  }\n  deque<LL> nX, nY;\n  while (X.size()) {\n    LL t;\n    if (X.size()%2) t = X.back(), X.pop_back();\n    else t = X.front(), X.pop_front();\n    nX.eb(t);\n  }\n  while (Y.size()) {\n    LL t;\n    if (Y.size()%2) t = Y.back(), Y.pop_back();\n    else t = Y.front(), Y.pop_front();\n    nY.eb(t);\n  }\n  nX.swap(X);\n  nY.swap(Y);\n  //random_shuffle(all(X));\n  //random_shuffle(all(Y));\n  rep(i, M) {\n    rep(j, M) {\n      if (i%2 != j%2) continue;\n      int xidx = lower_bound(all(xs), i+j) - xs.begin();\n      assert(xidx < X.size());\n      int yidx = lower_bound(all(ys), i-j) - ys.begin();\n      assert(yidx < Y.size());\n      A[i][j] = X[xidx] * Y[yidx];\n    }\n  }\n  rep(i, M) {\n    rep(j, M) {\n      if (i%2 == j%2) continue;\n      FillByLeast(i, j);\n    }\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  Fill();\n  //cout << cnt << endl;\n  Check();\n  int N;\n  cin >> N;\n  rep(i, N) {\n    rep(j, N) {\n      if (j) cout << \" \";\n      cout << A[i][j];\n    }\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 507;\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint n;\nLL tab[N][N];\nvector <int> primes;\n\nLL nwd(LL a, LL b){\n\tif(b == 0)\n\t\treturn a;\n\treturn nwd(b, a%b);\n}\n\nLL get(LL a, LL b, LL c, LL d){\n\tLL ret = a / nwd(a, b) * b;\n\tret = ret / nwd(ret, c) * c;\n\tret = ret / nwd(ret, d) * d;\n\treturn ret;\n}\n\nbool ok(int a){\n\tfor(int i = 2; i * i <= a; ++i)\n\t\tif(a%i == 0)\n\t\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tif(n == 2){\n\t\tputs(\"2 3\\n5 4\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 2; primes.size() < n + n; ++i)\n\t\tif(ok(i))\n\t\t\tprimes.push_back(i);\n\t\n\tfor(int i = 0; i <= n + 1; ++i)\n\t\tfor(int j = 0; j <= n + 1; ++j)\n\t\t\ttab[i][j] = 1;\n\t\n\tint sx = n - 1 + (n & 1), sy = 1;\n\tfor(int i = 1; i <= n - 1 + (n & 1); ++i){\n\t\tint cx = sx, cy = sy;\n\t\twhile(cx <= n && cy <= n){\n\t\t\ttab[cx][cy] *= primes.back();\n\t\t\t++cx, ++cy;\n\t\t}\n\t\t\n\t\tif(sx > 2)\n\t\t\tsx -= 2;\n\t\telse{\n\t\t\tif(sy == 1 && sx == 2)\n\t\t\t\tsx = 1, sy++;\n\t\t\telse\n\t\t\t\tsy += 2;\n\t\t}\n\t\t\n\t\tprimes.pop_back();\n\t}\n\t\n\tsx = 1, sy = 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tint cx = sx, cy = sy;\n\t\twhile(cx <= n && cy >= 1){\n\t\t\ttab[cx][cy] *= primes.back();\n\t\t\t++cx, --cy;\n\t\t}\n\t\t\n\t\tif(sy + 1 < n)\n\t\t\tsy += 2;\n\t\telse{\n\t\t\tif(sx == 1 && sy + 1 == n)\n\t\t\t\tsy = n, ++sx;\n\t\t\telse\n\t\t\t\tsx += 2;\n\t\t}\n\t\t\n\t\tprimes.pop_back();\n\t}\n\t\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif((i + j) & 1)\n\t\t\t\ttab[i][j] = get(tab[i - 1][j], tab[i][j - 1], tab[i + 1][j], tab[i][j + 1]) + 1;\n\t\t\tprintf(\"%lld \", tab[i][j]);\n\t\t}\n\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tif (n % 2 == 0) {\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j & 1) cout << \"3 \";\n\t\t\t\telse cout << \"5 \";\n\t\t\tcout << endl;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j & 1) cout << \"5 \";\n\t\t\t\telse cout << \"3 \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i += 3) {\n\t\t\tif (i == n - 1) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (j % 3 == 0) cout << \"5 \";\n\t\t\t\t\telse if (j % 3 == 1) cout << \"17 \";\n\t\t\t\t\telse cout << \"3 \";\n\t\t\t\tcout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j % 3 == 0) cout << \"3 \";\n\t\t\t\telse if (j % 3 == 1) cout << \"5 \";\n\t\t\t\telse cout << \"17 \";\n\t\t\tcout << endl;\n\t\t\tif (i + 1 >= n) break;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j % 3 == 0) cout << \"5 \";\n\t\t\t\telse if (j % 3 == 1) cout << \"17 \";\n\t\t\t\telse cout << \"3 \";\n\t\t\tcout << endl;\n\t\t\tif (i + 2 >= n) break;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j % 3 == 0) cout << \"17 \";\n\t\t\t\telse if (j % 3 == 1) cout << \"3 \";\n\t\t\t\telse cout << \"5 \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 510\nll a[N][N];\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    return b?gcd(a%b,b):a;\n}\nll gce(ll a,ll b){return a/gcd(a,b)*b;}\nint main(){\n    vector<ll> p;\n    for(ll i=2;p.size()<N*3;i++){\n\tbool ok=1;for(auto x:p)ok&=i%x>0;\n\tif(ok)p.push_back(i);\n    }\n    lol(i,N)lol(j,N){\n\tif((i+j)%2==0)a[i][j]=p[(i+j)/2]*p[(i-j)/2+2*N];\n    }\n    lol(i,N)lol(j,N){\n\tif((i+j)%2==1){\n\t    ll p=1,dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\t    lol(r,4){\n\t\tll xx=j+dx[r],yy=i+dy[r];\n\t\tif(xx<0||xx==N||yy<0||yy==N)continue;\n\t\tp=gce(p,a[yy][xx]);\n\t    }\n\t    a[i][j]=p+1;\n\t}\n    }\n    ll maxi=0;\n    lol(i,N)lol(j,N)maxi=max(maxi,a[i][j]);\n    //cout<<maxi<<endl;\n    ll n;cin>>n;\n    lol(i,n){\n\tlol(j,n){if(j)cout<<\" \";\n\t    cout<<a[i+1][j+1];\n\t}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=505;\n\nint n,p[N<<1],len;\nLL a[N][N];\nbool b[10005];\nLL gcd(LL x,LL y) { \n    return y == 0 ? x : gcd(y,x % y); \n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=n+1;i++)\n\tfor(int j=0;j<=n+1;j++)\n\t\ta[i][j]=1LL;\n\tfor(int i=2;len<2*n;i++){\n\t\tif(!b[i])p[++len]=i;\n\t\tfor(int j=1;j<=len&&p[j]*i<=10000;j++){\n\t\t\tb[p[j]*i]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)a[i][j]*=p[(i+j)>>1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==0)a[i][j]*=p[((i-j+n+1)>>1)+n];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2){\n\t\t\t\tLL u=a[i+1][j]/gcd(a[i+1][j],a[i][j+1])*a[i][j+1];\n\t\t\t\tLL v=a[i-1][j]/gcd(a[i-1][j],a[i][j-1])*a[i][j-1];\n\t\t\t\ta[i][j]=u/gcd(u,v)*v+1LL;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b; \n}\n\nvoid solve() {\n    int N;\n    cin >> N;\n\n    vector<int> isprime(10001, 1);\n    isprime[0] = isprime[1] = 0;\n    for(int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            for(int j = i + i; j < 10001; j += i) {\n                isprime[j] = 0;\n            }\n        }\n    }\n    vector<ll> primes;\n    for (int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    vector<vector<ll>> P1(N, vector<ll>(N)), P2(N, vector<ll>(N));\n    vector<vector<ll>> ans(N, vector<ll>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                ll p1 = primes[(i + j) / 2];\n                ll p2 = primes[primes.size() - 1 - (i - j + N) / 2];\n                ans[i][j] = p1 * p2;\n            }\n        }\n    }\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, -1, 0, 1};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 1) {\n                ll l = 1;\n                for(int k = 0; k < 4; k++) {\n                    int di = i + dy[k];\n                    int dj = j + dx[k];\n                    if (di < 0 || di >= N || dj < 0 || dj >= N) continue;\n                    l = lcm(l, ans[di][dj]);\n                }\n                ans[i][j] = l + 1;\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b){\n    return b ? gcd(b, a % b): a;\n}\n\nlong long lcm(long long a, long long b){\n    return a * b / gcd(a, b);\n}\n\nint main(){\n    int N;\n    cin >> N;\n\n    long long a[500][500];\n\n    for(int j = 0; j < N; j++){\n        a[0][j] = j + 2;\n    }\n\n    for(int i = 1; i < N; i++){\n        if(i % 2 == 0){\n            a[i][0] = a[i - 1][0] + 1;\n            for(int j = 1; j < N; j++){\n                a[i][j] = lcm(a[i][j - 1], a[i - 1][j]) + 1;\n            }\n        } else {\n            a[i][N - 1] = a[i - 1][N - 1] + 1;\n            for(int j = N - 2; j >= 0; j--){\n                a[i][j] = lcm(a[i][j + 1], a[i - 1][j]) + 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tfor(ll i=0;i<=n+1;i++)for(ll j=0;j<=n+1;j++)a[i][j]=1;\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\tfor(ll j=1;j<=n;j++)\n\tif((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nunsigned long long  a[550][550], c[550][550];\nusing namespace std;\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0; i <= n+2; i++){for(int j = 0; j <= n+2; j++){a[i][j] = c[i][j] = 1;}}\n    \n    vector<unsigned long long > primes;\n    vector<bool> visited(100000, 0);\n    for(int i = 2; i < 10000; i++){\n        if(!visited[i]){\n            primes.push_back(i);\n            for(int j = i; j < 100000; j+= i){\n                visited[j] = 1;\n            }\n        }\n    }\n    int cnt = 0;\n    for(int i = 0 ; i <= n; i+=2){\n        a[0][i] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 0; i <= n; i+=2){\n        a[i][0] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            a[i][j] = a[i-1][j-1];\n        }\n    }\n    \n    for(int i = n+1; i > 0; i-=2){\n        c[0][i] = primes[cnt];\n        cnt++;\n    }\n    for(int i = n+1; i > 0; i-=2){\n        c[i][n+1] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            c[i][j] = c[i-1][j+1];\n            a[i][j] *= c[i][j];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            if((i+j)%2){\n                a[i][j] = a[i][j-1]*a[i][j+1]*a[i-1][j] * a[i+1][j]  + 1;\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 505, LIM = 20000;\n\nint is_p[LIM];\n\nvi divs[LIM];\n\nvi pp;\n\nll diag1[2 * MAXN], diag2[2 * MAXN];\n\nll ans[MAXN][MAXN];\n\nint n;\n\npii get_ind(int i, int j) {\n\treturn mp((i + j) / 2, (n + i - j) / 2 + 1);\n}\n\nint di[4] = {1, 0, -1, 0};\nint dj[4] = {0, 1, 0, -1};\n\nconst ll MAXVAL = 1e15;\n\nll lcm(ll a, ll b) {\n\treturn b / gcd(a, b) * a;\n}\n\nvoid solve(){\n\tREP(i, 2, LIM) {\n\t\tif (!is_p[i]) {\n\t\t\t/*for(int j = i; j < LIM; j += i) {\n\t\t\t\tdivs[j].pb(i);\n\t\t\t\tif (j > i) {\n\t\t\t\t\tis_p[j] = 1;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tif (i > 1000) {\n\t\t\t\tpp.pb(i);\n\t\t\t}\n\t\t\tfor(int j = i * i; j < LIM; j += i) {\n\t\t\t\tis_p[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*REP(i, 2, LIM) {\n\t\tif (SZ(divs[i]) == 1) {\n\t\t\tpp.pb(i);\n\t\t}\n\t}*/\n\t\n\t/*printf(\"%d\\n\", SZ(pp));\n\tREP(i, 0, SZ(pp)) {\n\t\tprintf(\"%d\\n\", pp[i]);\n\t}*/\n\t\n\tscanf(\"%d\", &n);\n\t\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\t\n\tREPN(i, 1, 2 * n + 1) {\n\t\tdiag1[i] = i;\n\t\tdiag2[i] = pp[i - 1];\n\t}\n\t\n\tREPN(i, 1, n) {\n\t\tREPN(j, 1, n) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tint ind1 = get_ind(i, j)._1;\n\t\t\t\tint ind2 = get_ind(i, j)._2;\n\t\t\t\tans[i][j] = diag1[ind1] * diag2[ind2];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREPN(i, 1, n) {\n\t\tREPN(j, 1, n) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tans[i][j] = 1ll;\n\t\t\t\tREP(k, 0, 4) {\n\t\t\t\t\tint i1 = i + di[k], j1 = j + dj[k];\n\t\t\t\t\tif (i1 > 0 && i1 <= n && j1 > 0 && j1 <= n) {\n\t\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i1][j1]);\n\t\t\t\t\t\t//printf(\"# %d %d %d %d %lld %lld\\n\", i, j, i1, j1, ans[i][j], ans[i1][j1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREPN(i, 1, n) {\n\t\tREPN(j, 1, n) {\n\t\t\tassert(ans[i][j] < MAXVAL);\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tmap<ll, ll> bal;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (bal.find(j - i) != bal.end()) {\n\t\t\t\t\tans[i][j] = bal[j - i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = d.front();\n\t\t\t\t\tbal[j - i] = d.front();\n\t\t\t\t\td.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbal.clear();\n\tfor (int i =  n - 1; i >= 0; i--) {\n\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (bal.find(j + i) != bal.end()) {\n\t\t\t\t\tans[i][j] *= bal[j + i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] *= d.front();\n\t\t\t\t\tbal[j + i] = d.front();\n\t\t\t\t\td.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = ml * (ans[i][j - 1] / gcd(ml, ans[i][j - 1]));\n\t\t\t\tif (i < n - 1) ml = ml * (ans[i + 1][j] / gcd(ml, ans[i + 1][j]));\n\t\t\t\tif (j < n - 1) ml = ml * (ans[i][j + 1] / gcd(ml, ans[i][j + 1]));\n\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nll T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    n = 500;\n    vector<vector<ll>> m(n + 2, vector<ll>(n + 2, 1));\n    set<ll> used;\n    ll c = 2;\n    for(int i=1;i<=n;i+=2) {\n        REPS(j, n) {\n            used.insert(c);\n            m[i][j] = c ++;\n        }\n    }\n\n    for(int i=2;i<=n;i+=2) {\n        for(int j=1;j<=n;j+=2) {\n            ll x = m[i-1][j] * m[i+1][j] / __gcd(m[i-1][j], m[i+1][j]);\n            ll y = x;\n            while(used.count(y + 1)) y += x;\n            m[i][j] = y + 1;\n            used.insert(y + 1);\n        }\n    }\n\n    for(int i=2;i<=n;i+=2) {\n        for(int j=2;j<=n;j+=2) {\n            ll x = m[i-1][j] * m[i+1][j] / __gcd(m[i-1][j], m[i+1][j]);\n            x = x * m[i][j-1] / __gcd(x, m[i][j-1]);\n            x = x * m[i][j+1] / __gcd(x, m[i][j+1]);\n            ll y = x;\n            while(used.count(y + 1)) y += x;\n            m[i][j] = y + 1;\n            used.insert(y + 1);\n        }\n    }\n\n    assert(*used.rend() <= 1000000000000000ll);\n    assert(used.size() == n * n);\n\n    cin >> n;\n    REPS(i, n) {\n        REPS(j, n) {\n            cout << m[i][j] << \" \\n\"[j == n];\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint pri[101000], tot = 0;\nbool is[101000];\n\nvoid init()\n{\n\tfor(int i = 2; i <= 100000; i++)\n\t{\n\t\tif(!is[i]) pri[++tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= 100000; j++)\n\t\t{\n\t\t\tis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nlong long m[1010][1010];\n\nlong long gcd(long long a, long long b) {return b == 0 ? a : gcd(b, a % b);} \nvoid lcm(long long &a, long long b)\n{\n\ta = a / gcd(a, b) * b; \n}\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tif(n == 2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tinit();\n\tint j = 2;\n\tfor(int i = 2; i <= 2 * n; i += 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i - k >= 1 && i - k <= n) m[k + 1][i - k] = pri[j];\n\t\t}\n\t\tj++;\n\t}\n\t\n\tfor(int i = (n / 2 * 2); i >= - n; i -= 2)\n\t{\n\t\tfor(int k = 0; k <= n; k++)\n\t\t{\n\t\t\tif(k + 1 >= 1 && k + 1 <= n && i + k >= 1 && i + k <= n) m[k + 1][i + k] *= pri[j];\n\t\t}\n\t\tj++;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(!m[i][j])\n\t\t\t{\n\t\t\t\tm[i][j] = 1;\n\t\t\t\tif(i != 1) lcm(m[i][j], m[i - 1][j]);\n\t\t\t\tif(j != 1) lcm(m[i][j], m[i][j - 1]);\n\t\t\t\tif(i != n) lcm(m[i][j], m[i + 1][j]);\n\t\t\t\tif(j != n) lcm(m[i][j], m[i][j + 1]);\n\t\t\t\tm[i][j]++;\n\t\t\t}\n\t\t}\n\tfor(int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \",m[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll __int128\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=500+10,MAXM=1000000+10;\nint n,vis[MAXM],prime[MAXM],cnt,p;\nll G[MAXN][MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void init()\n{\n\tmemset(vis,1,sizeof(vis));\n\tvis[0]=vis[1]=0;\n\tREP(i,2,MAXM-1)\n\t{\n\t\tif(vis[i])prime[++cnt]=i;\n\t\tfor(register int j=1;j<=cnt&&i*prime[j]<MAXM;++j)\n\t\t{\n\t\t\tvis[i*prime[j]]=0;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\ninline bool check(int x,int y)\n{\n\tif(G[x][y]%G[x-1][y]!=1)return false;\n\tif(G[x][y]%G[x+1][y]!=1)return false;\n\tif(G[x][y]%G[x][y-1]!=1)return false;\n\tif(G[x][y]%G[x][y+1]!=1)return false;\n\treturn true;\n}\nint main()\n{\n\tread(n);init();int x,y;\n\tREP(i,0,n+1)REP(j,0,n+1)G[i][j]=1;\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y>=0)G[x][y]*=prime[p],x++,y--;\n\t}\n\tREP(i,1,n+1)if(i%2==n%2)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y<=n+1)G[x][y]*=prime[p],x--,y++;\n\t}\n\tREP(i,0,n+1)if(i%2==n%2)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y>=0)G[x][y]*=prime[p],x--,y--;\n\t}\n\tREP(i,1,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y<=n+1)G[x][y]*=prime[p],x++,y++;\n\t}\n\tREP(i,1,n)REP(j,1,n)if((i+j)%2==0)\n\t{\n\t\tG[i][j]=G[i-1][j]*G[i+1][j]+1,assert(check(i,j));\n\t}\n\tREP(i,1,n)\n\t{\n\t\tREP(j,1,n)assert(G[i][j]<=1e15),write(G[i][j],' ');puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < (int)(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nint lcm(int a, int b) {\n    return a / __gcd(a, b) * b;\n}\n\nint lcm(vi vec) {\n    if (vec.empty())\n        return 1;\n    int ret = vec[0];\n    for (int i = 1; i < SZ(vec); ++i)\n        ret = lcm(ret, vec[i]);\n    return ret;\n}\n\nvi di = {0, 0, -1, 1};\nvi dj = {-1, 1, 0, 0};\n\nvoid smain() {\n    int n;\n    cin >> n;\n    vvl a(n, vl(n, 0));\n    int cur = 1;\n    set<int> used;\n    fori (i, n) {\n        fori (j, n) {\n            if ((i ^ j) & 1) {\n                a[i][j] = cur++;\n                used.insert(a[i][j]);\n            }\n        }\n    }\n\n    fori (i, n) {\n        fori (j, n) if (a[i][j] == 0) {\n            vi vec;\n\n            fori (dir, SZ(di)) {\n                int ii = i + di[dir];\n                int jj = j + dj[dir];\n                if (ii >= 0 && ii < n && jj >= 0 && jj < n) {\n                    vec.push_back(a[ii][jj] + 1);\n                }\n            }\n            int x = lcm(vec);\n            int cur = x;\n            while (used.count(cur))\n                cur += x;\n            a[i][j] = cur;\n            used.insert(a[i][j]);\n        }\n    }\n\n    fori (i, n) {\n        fori (j, n) {\n            cout << a[i][j] * 2 + 2 << ' ';\n        }\n        cout << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int C=1;\nmap<__int128,int> mp;\n__int128 lcm(__int128 x,__int128 y){\n\tif (!(x&&y)) return x^y;\n\treturn (__int128)x*y/__gcd(x,y);\n}\nconst int N=600;\nconst long long INF=1e18;\nlong long z[N][N];\nint n,a[N*N];\nint main(){\n\tscanf(\"%d\",&n);\n\tint tot=((n*n)+1)/2;\n\tfor (int i=1; i<=tot; ++i) a[i]=i*2;\n\t//random_shuffle(a+1,a+tot+1);\n\tint d=0;\n\tfor (int i=2; i<=n; i+=2)\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=a[++d];\n\tfor (int i=(n%2==0?n-1:n); i>=1; i-=2){\n\t\tstack<int> s;\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\ts.push(a[++d]);\n\t\tfor (int j=((i&1)?1:2); j<=n; j+=2)\n\t\t\tz[i][j]=s.top(),s.pop();\n\t}\n\t/*for (int i=1; i<=n; ++i,putchar('\\n'))\n\t\t\tfor (int j=1; j<=n; ++j) printf(\"%d \",z[i][j]);\n   \tcerr<<\"tot\"<<tot<<endl;\n\tgetchar(); getchar();*/\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=((i&1)?2:1); j<=n; j+=2){\n\t\t\t__int128 k=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t__int128 zz=k;\n\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\tif (zz+C>INF){\n\t\t\t\tswap(z[i+1][j],z[i+2][j]);\n\t\t\t\tk=lcm(z[i-1][j],lcm(z[i][j-1],lcm(z[i+1][j],z[i][j+1])));\n\t\t\t\tzz=k;\n\t\t\t\twhile (mp.find(zz+C)!=mp.end()) zz+=k;\n\t\t\t}\n            //cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<(long long)zz<<\" \"<<(long long)k<<\" \"<<z[i-1][j]<<\" \"<<z[i][j-1]<<\" \"<<z[i+1][j]<<\" \"<<z[i][j+1]<<\" \"<<i<<\" \"<<j<<endl;\n\t\t\t//assert(zz+C<=INF);\n\t\t\t//getchar();\n\t\t\tz[i][j]=zz+C;\n\t\t\tmp[zz+C]=1;\n\t\t}\n\tfor (int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor (int j=1; j<=n; ++j) printf(\"%lld \",z[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint N;\nint a[501][501], vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= 10000); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> N;\n\tif(N == 2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= N; i++) \n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!((i + j) & 1)) a[i][j] = prime[(i + j) / 2] * prime[N + (i - j) / 2 + (N + 1) / 2];\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!a[i][j]) \n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint p[1010],b[10010],t,n;\nint main(){\n\tp[0]=1;p[t+1]=1;\n\tfor(int i=2;i<=7919;++i){\n\t\tif(!b[i])p[++t]=i;\n\t\tif(t==500)p[++t]=1;\n\t\tfor(int j=1;j<=t&&i*p[j]<=7919;++j)if(j^501){\n\t\t\tb[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i+j&1){\n\t\t\t\tprintf(\"%lld\",5ll*p[i+j>>1]*p[i+j+1>>1]*p[501+(n+2-j+i>>1)]*p[501+(n-j+i>>1)]+1);\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\",p[i+j>>1]*p[501+(n+1-j+i>>1)]);\n\t\t\t}\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\n\nint x[501];\nint y[501];\nint so[100000]={0};\nvector<int> ve1,ve2,ve;\nint ans[501][501]={0};\nint ban[1010][1010]={0};\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nrandom_device seed_gen;\n  \t\n mt19937 engine(seed_gen());\n  \tfor(int i=2;i<100000;i++)if(so[i]==0){\n  \t\tif(ve1.size()<500)ve1.pb(i);\n  \t\telse ve2.pb(i);\n  \t\tif(ve2.size()==500) break;\n  \t\tfor(int j=i;j<100000;j+=i)so[j]=1;\n  \t}\n  //\tcout<<ve2.back()<<endl;\n  \tint cnt=0;\n  \twhile(1){\n  \t\tshuffle(ve1.begin(), ve1.end(),engine);\n  \t\tshuffle(ve2.begin(), ve2.end(),engine);\n  \t\tcnt++;\n  //\t\tcout<<cnt<<endl;\n  \t\tve.clear();\n  \t\tfor(int i=0;i<500;i++){\n  \t\t\tve.pb(ve1[i]);\n  \t\t\tve.pb(ve2[i]);\n  \t\t}\n  \t\tfor(int i=0;i<=498;i++)for(int j=500;j<=998;j++){\n  \t\t\tif(ve[i]*ve[i+1]*ve[j]*ve[j+1]>1000000000000000ll){\n  \t\t//\tcout<<i<<\" \"<<j-500<<endl;\n  \t\t\t\tgoto lll;\n  \t\t\t}\n  \t\t\t}\n  \t\t\n  \t\tbreak;\n  \t\tlll:;\n  \t}\n  //\tfor(auto v:ve)cout<<v<<endl;\n  \n  \tfor(int i=0;i<=500;i++){\n  \t\tif(i==0) x[i]=ve[i];\n  \t\telse if(i==500) x[i]=ve[i-1];\n  \t\telse{\n  \t\t\tx[i]=ve[i]*ve[i-1];\n  \t\t}\n  \t}\n  \n  \tfor(int j=0;j<=500;j++){\n  \t\tif(j==0) y[j]=ve[500+j];\n  \t\telse if(j==500)y[j]=ve[j-1+500];\n  \t\telse{\n  \t\t\ty[j]=ve[j+500]*ve[j-1+500];\n  \t\t}\n  \t}\n  //  return 0;\n  \tint n;\n  \tcin>>n;\t\n  \t\n    for(int i=0;i<=500;i++)for(int j=0;j<=500;j++){\n  \t\tban[2*i][2*j]=x[i]*y[j];\n  \t//\tassert(x[2*i]*y[2*j]<=1000000000000000ll);\n  \t}\n  \t\n  \t\n  \t\n  \tfor(int i=0;i<=499;i++)for(int j=0;j<=499;j++){\n  \t\tint g=ban[2*i][2*j];\n  \t\tg=gcd(g,ban[2*i+2][2*j]);\n  \t\tg=gcd(g,ban[2*i][2*j+2]);\n // \t\tg=gcd(g,ban[i+1][j]);\n  \t\tg=gcd(g,ban[2*i+2][2*j+2]);\n  \t\tban[2*i+1][2*j+1]=g;\n  //\t\tcout<<g<<\" \"<<se.size()<<endl;\n  \t//\tassert(se.count(g)==0);\n  //\t\tse.insert(g);\n  \t}\n  \t\n  \tset<int> se;\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++){\n  \t\t\n  \t\tint s=(i+j);\n  \t\tint t=(i-j)+500;\n  \t\tif(ban[s][t]<=0){\n  \t\t\tcout<<i<<\" \"<<j<<endl;\n  \t\t}\n  \t\tassert(ban[s][t]>0);\n  \t\tassert(se.count(ban[s][t])==0);\n  \t\tse.insert(ban[s][t]);\n  \t\t\n  \t\tans[i][j]=ban[s][t];\n  \t}\n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++)if((i+j)%2){\n  \t\t\n  \t\tint g;\n  \t\tif(i==0) g=ban[i+1][j];\n  \t\telse g=ban[i-1][j];\n  \t\t\n  \t\tif(i!=499)g=gcd(g,ban[i+1][j]);\n  \t\tif(i>0)g=gcd(g,ban[i-1][j]);\n  \t\tif(j!=499)g=gcd(g,ban[i][j+1]);\n  \t\tif(j)g=gcd(g,ban[i][j-1]);\n  \t\tans[i][j]=g;\n  \t}\n  \n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt gcd(Int a, Int b){\n  if(a==0)return b;\n  return gcd(b%a, a);\n}\nInt lca(Int a, Int b){\n  return a / gcd(a,b)* b;\n}\nbool isPrime[1080000];\nvector<Int> primes;\nvoid init(){\n  fill(isPrime, isPrime + 1080000, true);\n  isPrime[0] = isPrime[1] = false;\n  for(Int i = 2;i < 1080000;i++){\n    if(!isPrime[i])continue;\n    primes.push_back(i);\n    for(Int j = i * i;j < 1080000;j += i)isPrime[j] = false;\n  }\n}\n\nset<Int> used;\nInt n, A[540][540], p = 2;\nint main(){\n  init();\n  cin >> n;\n  for(Int i = 0;i < n;i++){\n    for(Int j = 0;j < n;j++){\n      if((i+j)%2){\n\tint k = (i+j)/2;\n\tInt pk, pl;\n\tif(k%2)pk = primes[k/2];\n\telse pk = primes[n-1-k/2];\n\tint l = (i+n-1-j)/2;\n\tif(l%2) pl = primes[l/2 + n];\n\telse pl = primes[n-1-l/2 + n];\n\tA[i][j] = pk*pl;\n      }\n    }\n  }\n  \n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < n;j++){\n      if((i + j) % 2 == 0){\n\tInt prod = 1;\n\tif(i)prod = lca(prod, A[i-1][j]);\n\tif(j)prod = lca(prod, A[i][j-1]);\n\tif(i<n-1)prod = lca(A[i+1][j], prod);\n\tif(j<n-1)prod = lca(A[i][j+1], prod);\n\tA[i][j] = prod+1;\n\twhile(used.count(A[i][j]))A[i][j] += prod;\n\tused.insert(A[i][j]);\n      }\n    }\n  }\n  for(int i = 0;i < n;i++){\n    for(int j = 0;j < n;j++){\n      cout<< A[i][j] << \"  \";\n    }cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cassert>\nusing namespace std;\nlong long gcd(long long a,long long b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint n,nn;\nmap<long long,bool>mp;\nlong long a[510][510];\nbool used[250050];\nint p[250050],cnt;\nlong long calc(int i,int j)\n{\n\tlong long res=1,s;\n\tif(i>1)res=res*a[i-1][j]/gcd(res,a[i-1][j]);\n\tif(i<n)res=res*a[i+1][j]/gcd(res,a[i+1][j]);\n\tif(j>1)res=res*a[i][j-1]/gcd(res,a[i][j-1]);\n\tif(j<n)res=res*a[i][j+1]/gcd(res,a[i][j+1]);\n\ts=res;\n\twhile(mp[s+1])s+=res;\n\tmp[s+1]=1;\n\tif(s+1>1e15)assert(0);\n\treturn s+1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n&1)nn=n+1;\n\telse nn=n;\n\tint lim1=nn*nn/2+1;\n//\tfor(int i=3-(n&1);i<=n;i+=4)a[n][i]=lim1--,i!=n?a[i][n]=lim1--:0;\n//\tint ps=3-(n&1)+2;\n//\twhile(ps+4<=n)ps+=4;\n//\tfor(int i=ps;i;i-=4)a[n][i]=lim1--,i!=n?a[i][n]=lim1--:0;\n//\tfor(int i=2;i<=n;i+=2)a[1][i]=lim1--,a[i][1]=lim1--;\n\tfor(int i=1;2*i<=lim1;++i)\n\t{\n\t\tp[++cnt]=2*i+1;\n\t\tp[++cnt]=4*i+2;\n\t}\n//\tif(lim1&1)p[++cnt]=2;\n//\tfor(int c=2;c<=lim1/2;++c)\n//\t\tfor(int i=2;i<=lim1/c;++i)\n//\t\t\tif(3*i>=lim1&&!used[i]&&!used[c*i])\n//\t\t\t{\n//\t\t\t\tused[i]=used[c*i]=1;\n//\t\t\t\tp[++cnt]=i,p[++cnt]=c*i;\n//\t\t\t}\n//\tprintf(\"!!!\\n\");\n/*\tint l=2,r=lim1;\n\twhile(l<r)\n\t{\n\t\twhile(used[l])++l;\n\t\twhile(used[r])--r;\n\t\tp[++cnt]=l;\n\t\tif(l!=r)p[++cnt]=r;\n\t\tused[l]=1,used[r]=1;\n\t}*/\n\tint st=1,ed=lim1-(lim1&1);\n\tfor(int i=1;i<=nn-1;i+=2)\n\t\tfor(int j=1;j<=nn-1;j+=2)\n\t\t{\n\t\t\tif((i+j)&3)a[i][j+1]=p[st++],a[i+1][j]=p[st++];\n\t\t\telse a[i][j+1]=p[ed--],a[i+1][j]=p[ed--];\n\t\t}\n/*\tint l=2,r=n*n/2+1;\n\tfor(int i=1;i<=n;i+=4)p1[++len1]=i;\n\tfor(int i=2;i<=n;i+=4)p2[++len2]=i;\n\tfor(int i=3;i<=n;i+=4)p3[++len3]=i;\n\tfor(int i=4;i<=n;i+=4)p4[++len4]=i;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tfor(int j=1;j<=len2;++j)a[i][p2[j]]=r--;\n\t\t\tfor(int j=len4;j;--j)a[i][p4[j]]=r--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=len1;++j)a[i][p1[j]]=l++;\n\t\t\tfor(int j=len3;j;--j)a[i][p3[j]]=l++;\n\t\t}\n\t}*/\n/*\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%3lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=2-(i&1);j<=n;j+=2)a[i][j]=calc(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef unsigned long long ll;\nusing namespace std;\nconst int MN=80000;\nint n,pri[2001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tif(n==2)return 0*puts(\"4 7\\n23 10\");\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+((i-j+n)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tprintf(\"%llu \",a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nlong long ans[501][501];\nlong long prime[501];\nvoid initprime() {\n\tint pn=0;\n\tlong long base=2;\n\tfor (int i=0; i<500;) {\n\t\tauto isprime = [&](long long a) {\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tif (a%prime[k] == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\t\t// cout<<i<<\" \"<<base<<endl;\n\t\tif (isprime(base))\n\t\t\tprime[i++] = base++;\n\t\telse\n\t\t\tbase++;\n\t}\n}\nint main() {\n\tinitprime();\n\tint n; cin>>n;\n\tif (n==2) {\n\t\tcout<<\"4 7\\n23 10\"<<endl;\n\t\treturn 0;\n\t}\n\tauto idx = [&] (int x, int y) -> int {\n\t\tint t = (x+y)/2; // t=0,1,2,3,4,5 when n==6;\n\t\treturn t%2?(n-1-t/2):t/2; };\n\n\t//prime[k] for (i,j) with k=(i+j)/2;\n\tint pcnt[500]; memset(pcnt, 0, sizeof(pcnt));\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=i%2; j<n; j+=2)\n\t\t\tans[i][j] = prime[idx(i,j)]*(i+1);\n\t\n\t// for (int i=0; i<500; i++)\n\t// \tcout<<pcnt[i]<<\" \";\n\t// cout<<endl;\n\tauto w = [&] (int x, int y) -> long long{\n\t\tif (x<0 || x>=n || y<0 || y>=n)\n\t\t\treturn 1;\n\t\treturn ans[x][y] / prime[idx(x,y)];\n\t};\n\tlong long tmax=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=(i+1)%2; j<n; j+=2) {\n\t\t\tans[i][j] = w(i,j+1) * w(i-1,j) * w(i+1,j) * prime[idx(i,j-1)] * prime[idx(i,j+1)];\n\t\t\ttmax = max(tmax, ans[i][j]);\n\t\t}\n\t// cout<<tmax<<endl;\n\tfor (int i=0; i<n; i++, cout<<endl)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tcout<<ans[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int N = 100010;\nll mp[520][520];\nint p[N], pnum;\nbool use[N];\nint n;\nvoid prep(int n){\n\tuse[1] = true;\n\tfor (int i = 2; i <= n; i++){\n\t\tif (use[i] == false) p[++pnum] = i;\n\t\tfor (int j = 1; 1ll * i * p[j] <= n && j <= pnum; j++){\n\t\t\tuse[p[j] * i] = true;\n\t\t\tif (i % p[j] == 0) break;\n\t\t}\n\t}\n}\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read();\n\tprep(100000);\n\tfor (int i = 1; i <= n + 2; i++)\n\t\tfor (int j = 1; j <= n + 2; j++)\n\t\t\tif ((i + j) % 2 == 0){\n\t\t\t\tint p1 = (i + j) / 2, p2 = (i - j) / 2 + 760;\n\t\t\t\tmp[i][j] = p[p1] * p[p2];\n\t\t\t} \n\tfor (int i = 2; i <= n + 1; i++)\n\t\tfor (int j = 2; j <= n + 1; j++)\n\t\t\tif ((i + j) % 2 == 1){\n\t\t\t\tmp[i][j] = mp[i - 1][j] * mp[i + 1][j];\n\t\t\t\tmp[i][j] += 1;\n\t\t\t}\n\tfor (int i = 2; i <= n + 1; i++)\n\t\tfor (int j = 2; j <= n + 1; j++)\n\t\t\tprintf(\"%lld%c\", mp[i][j], (j == n + 1) ? '\\n' : ' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ll MOD = 1e9 + 7, INF = 1e18 + 1;\n \nusing namespace std;\n\nll er[1000001], p[1000000], ptr, n, d[1000][1000];\n\nll gcd (ll a, ll b)\n{\n\tif (!b) return a;\n\telse return gcd (b, a % b);\n}\n\nint main ()\n{\n\tfor (ll i = 2; i <= 1000000; i++)\n\t\tif (!er[i])\n\t\t{\n\t\t\tp[ptr++] = i;\n\t\t\tfor (ll j = i * i; j <= 1000000; j += i)\n\t\t\t\ter[j] = 1;\n\t\t}\n\n\tcin >> n;\n\n\tfor (int i = 0; i < 2 * n; i += 2)\n\t\tfor (int j = 0; i + j < 2 * n; j++)\n\t\t\td[j][i + j] = p[i / 2];\n\n\n\tfor (int i = 2; i < 2 * n; i += 2)\n\t\tfor (int j = 0; i + j < 2 * n; j++)\n\t\t\td[i + j][j] = p[i / 2 + (n + 1) / 2 - 1];\n\n\n\tfor (int i = 0; i < 2 * n; i += 2)\n\t\tfor (int j = 0; i >= j; j++)\n\t\t\td[i - j][j] *= p[i / 2 + n];\n\n\tll mx = 0;\n\n\tif (n == 2)\n\t{\n\t\tprintf (\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (!d[i][j])\n\t\t\t{\n\t\t\t\tll lcm = 1;\n\t\t\t\tif (j) lcm = lcm / gcd (lcm, d[i][j-1]) * d[i][j-1];\n\t\t\t\tif (j < n - 1) lcm = lcm / gcd (lcm, d[i][j+1]) * d[i][j+1];\n\t\t\t\tif (i) lcm = lcm / gcd (lcm, d[i-1][j]) * d[i-1][j];\n\t\t\t\tif (i < n - 1) lcm = lcm / gcd (lcm, d[i+1][j]) * d[i+1][j];\n\n\t\t\t\td[i][j] = lcm + 1;\n\t\t\t}\n\n\t\t\tprintf (\"%lld \", d[i][j]);\n\t\t}\n\t\tputchar ('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nStranger than the comet as it streaks across the sky\nStranger than the truth I know before my open eyes\nI have dealt in mysteries and trickery, of light to entertain\nLooked into the abyss, called it by its name\n\nI have plundered time itself, put the world inside it\nAnd the mysteries, day and night, divide it\nA plague of wonders, on your knees beside me\nKnow the secrets, you shall not deride us\n\nMy dreams of empire for my frozen queen\nWill come to pass\nKnow me, the Magus\nI am Dr. Dee\nAnd this is my house\n\nI am the master of the tides\nI shame the mirror in my sight\nWhat random music of the spheres across the years\n\nKnow this I will return to this land\nRebuild where the ruins did stand\nChain of the demons set free\nStrange alchemy\n\nGather round the aimless and the feckless and the lame\nHear the master summon up the spirits by their names\nI curse you Edward Kelly your betrayal for eternity is damned\nKnow you speak with demons you cannot command\n\nEven as I looked into the glass then I was blinded\nBurning by the Mortlake shore my house my books inside it\nYou have taken up my wife and lain beside her\nNow the black rain on my house, the timbers burning\n\nMy dreams of empire for my frozen queen\nWill come to pass\nKnow me, the Magus\nI am Dr. Dee\nAnd this was my house\n\nI was the keeper of the books\nI had the knowledge of the scrolls\nBut now through ignorance and fear\nI cast a shadow through the years\n\nKnow this I will return to this land\nRebuild where the ruins did stand\nChain of the demons set free\nStrange alchemy\n\nKnow this\nI will return to this land\nRebuild where the ruins did stand\nChain of the demons set free\nStrange alchemy\n\nKnow this\nI will return to this land\nRebuild where the ruins did stand\nRestore the knowledge memory\nStrange alchemy\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600000;\n\nint n;\nvector<pair<int,int> > order;\nint pi,pj;\nlong long ans[1031][1031];\n\nmap<long long,int> used;\n\nlong long gcd(long long a,long long b){\n\twhile (a&&b)a>b?a%=b:b%=a;\n\treturn a+b;\n}\n\nlong long lcm(long long a,long long b){\n\treturn a/gcd(a,b)*b;\n}\n\nvector<int> ordr;\n\nint mx_prime(int x){\n\tint res=1;\n\tfor (int i=2;i*i<=x;i++){\n\t\tif (x==1)\n\t\t\tbreak;\n\t\twhile (x%i==0){\n\t\t\tx/=i;\n\t\t\tres=i;\n\t\t}\n\t}\n\tif (x>1)\n\t\tres=max(res,x);\n\treturn res;\n}\n\nvector<int> primes;\n\nvoid backtrack(long long prod,int ps){\n\tif (prod>1e6)\n\t\treturn;\n\tif (prod>1)\n\t\tordr.push_back(prod);\n\tfor (int i=ps;i<primes.size();i++){\n\t\tbacktrack(prod*primes[i],i);\n\t}\n}\n\nint pr[N];\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tn=500;\n\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (i%2==j%2)\n\t\t\t\torder.push_back(make_pair(i,j));\n\t\t}\n\t}\n\n\tprimes.clear();\n\tfor (int i=2;i<=100000;i++){\n\t\tif (pr[i]==0){\n\t\t\tfor (int j=i*2;j<=100000;j+=i)\n\t\t\t{\n\t\t\t\tpr[j]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i=3;;i++){\n\t\tif (pr[i]==0){\n\t\t\tprimes.push_back(i);\n\t\t\tif (primes.size()==2000)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n//\tcout<<primes.back()<<endl;\n\n\tfor (int i=0;i<order.size();i++){\n\t\tpi=order[i].first;\n\t\tpj=order[i].second;\n\t\tint si=pi+pj;\n\t\tsi/=2;\n\t\tint sj=pi-pj+n;\n\t\tsj/=2;\n\t\t//cout<<pi<<\" \"<<pj<<\" \"<<si<<\" \"<<sj<<endl;\n\t\t//cout<<\"@\"<<i<<\" \"<<pi<<\" \"<<pj<<endl;\n\t\tlong long here=primes[si-1]*primes[sj-1];\n\t\tif (si>sj)\n\t\t\there*=2;\n\t\tans[pi][pj]=here;\n\t\tused[here]=1;\n\t}\n\n\t/*for (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tcout<<ans[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tlong long mx=0;\n\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (i%2!=j%2){\n\t\t\t\tlong long L=1;\n\t\t\t\tfor (int di=-1;di<=1;di++){\n\t\t\t\t\tfor (int dj=-1;dj<=1;dj++){\n\t\t\t\t\t\tif (abs(di)+abs(dj)!=1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (i+di<1||i+di>n||j+dj<1||j+dj>n)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tL=lcm(L,ans[i+di][j+dj]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong long Q=L;\n\t\t\t\twhile (used[Q+1])\n\t\t\t\t\tQ+=L;\n\t\t\t\tans[i][j]=Q+1;\n\t\t\t\tused[Q+1]=1;\n\t\t\t\tmx=max(mx,Q+1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcin>>n;\n\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (j>1)\n\t\t\t\tcout<<\" \";\n\t\t\tcout<<ans[i][j];//<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\t/*cout<<mx<<\" \"<<log10(mx)<<endl;\n\n\tvector<pair<long long,pair<int,int> > > A;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tA.push_back(make_pair(ans[i][j],make_pair(i,j)));\n\t\t}\n\t}\n\tsort(A.begin(),A.end());\n\tfor (int i=1;i<A.size();i++){\n\t\tif (A[i].first==A[i-1].first){\n\t\t\tcout<<\"SHIT!\"<<\" \"<<A[i].second.first<<\" \"<<A[i].second.second<<\" \"<<A[i-1].second.first<<\" \"<<A[i-1].second.second<<endl;\n\t\t}\n\t}\n\tcout<<\"OK\"<<endl;\n*/\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define pii pair<int , int>\n#define mp make_pair\n#define fi first\n#define se second\n\nconst int MAXN = 2e5 + 10;\nint pc;\nint pr[MAXN] , f[MAXN];\nLL A[MAXN] , B[MAXN];\n\ntemplate <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }\ntemplate <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }\ntemplate <typename T> inline void read(T &x) {\n    T f = 1; x = 0;\n    char c = getchar();\n    for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n    x *= f;\n}\n\ninline void G(int n) {\n\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\t\tif (!f[i]) f[i] = pr[++pc] = i;\n\t\t\t\tfor (int j = 1; j <= pc && i * pr[j] <= n; ++j) {\n\t\t\t\t\t\tf[i * pr[j]] = pr[j];\n\t\t\t\t\t\tif (i % pr[j] == 0) break;\n\t\t\t\t}\n\t\t}\n}\nint main() {\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\" , &n); G(10000);\n\t\tfor (int i = 1; i <= n; ++i) A[i] = pr[i & 1 ? i / 2 + 1 : n + n - i / 2 + 1];\n\t\tfor (int i = 1; i <= n; ++i) B[i] = pr[(i & 1 ? n - i / 2 : n + i / 2) + (n & 1)];\n\t\tA[0] = A[n + 1] = B[0] = B[n + 1] = 1;\n\t\tfor (int i = 1; i <= n; ++i , printf(\"\\n\")) \n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\tif ((i + j) & 1) printf(\"%lld \" , (LL) A[(i + j) / 2] * A[(i + j) / 2 + 1] * B[(n + i - j + (n & 1)) / 2] * B[(n + i - j + (n & 1)) / 2 + 1] + 1);\n\t\t\t\telse printf(\"%lld \" , A[(i + j) / 2] * B[(n + i - j + (n & 1)) / 2]); \n\t  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned long;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    vector<ULL> P;\n\n    void Primes() {\n        bool Table[10000] = {};\n        Table[0] = Table[1] = true;\n        Table[2] = true;\n        for (UL i = 2; i <= 100; i++) {\n            if (Table[i]) continue;\n            for (UL j = i * i; j < 10000; j += i) Table[j] = true;\n        }\n        for (UL i = 1; P.size() < 1000; i++) if (!Table[i]) P.push_back(i);\n    }\n\n    ULL ans[502][502];\n\n    void Solve() {\n        Primes();\n        rep(i, 501) rep(j, 501) ans[i][j] = 1;\n        rep(i, 500) rep(j, 500) {\n            if ((i ^ j) & 1) continue;\n            ULL tmp = P[i + j] * P[i + 499 - j];\n            ans[i + 1][j + 2] = ans[i + 2][j + 1] = ans[i + 1][j + 1] = tmp;\n            ans[i][j + 1] *= tmp; ans[i + 1][j] *= tmp;\n        }\n        rep(i, 500) rep(j, 500) if ((i ^ j) & 1) ans[i + 1][j + 1]++;\n\n        UL N; cin >> N;\n        rep(i, N) {\n            rep(j, N) {\n                if (j) cout << \" \";\n                cout << ans[i + 1][j + 1];\n            } cout << endl;\n        }\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\nll a[1005][1005];\nint n;\nint pri[10005],tot;\nbool mk[10005];\nll lcm(ll a,ll b) {\n\tif((!a)||(!b)) return a+b;\n\treturn 1ll*a/__gcd(a,b)*b;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=10000;i++) {\n\t\tif(!mk[i]) { pri[++tot]=i; }\n\t\tif(tot==1000) break;\n\t\tfor(int j=1;j<=tot&&1ll*pri[j]*i<=10000;j++) {\n\t\t\tint k = pri[j] * i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==0) a[i][j] = pri[(i + j) / 2] * pri[n+((i-j)/2+(n+1)/2)];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==1) a[i][j] = lcm( lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]) ) + 1;\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n\nll N;\nll prm[101010];\nll prmn;\nll ans[1010][1010];\nll i, j, k;\nll gcd(ll a,ll b){\n    if(b==0)\n        return a;\n    return gcd(b, a % b);\n}\nint main(){\n    scanf(\"%lld\",&N);\n    if(N==2){\n        printf(\"4 7\\n23 10\");\n        return 0;\n    }\n    i = 3;\n    prm[0] = 2;\n    prmn = 1;\n    while(prmn<=N*2){\n        fornum(k,1,prmn){\n            if(i%prm[k]==0){\n                break;\n            }\n        }\n        if(k==prmn){\n            prm[prmn] = i;\n            prmn++;\n            //printf(\"%lld,%lldd\\n\", i, prmn);\n        }\n        i += 2;\n    }\n    \n    fornum(i,0,N){\n        ans[i+10][N+10\n        ] =ans[N+10][i+10] = ans[i+10][9] =ans[9][i+10] = 1;\n        fornum(j,0,N){\n            if((i+j)%2)\n                continue;\n            //printf(\"%lld,%lld:%lld,%lld\\n\", i, j,(i-j+N)/2,(i+j)/2+N);\n            ans[i + 10][j + 10] = prm[(i - j + N) / 2] * prm[(i + j) / 2 + N];\n        }\n    }\n    ll mx = 0;\n    fornum(i,0,N){\n        fornum(j,0,N){\n            if((i+j)%2){\n                ll d1 = ans[i + 9][j + 10]/gcd(ans[i + 9][j + 10] , ans[i + 10][j + 9]) * ans[i + 10][j + 9];\n                ll d2 = ans[i + 11][j + 10]/gcd(ans[i + 11][j + 10] , ans[i + 10][j + 11]) * ans[i + 10][j + 11];\n                ll d = d1 / gcd(d1, d2) * d2;\n                ans[i + 10][j + 10] = d + 1;\n            }\n            if(mx<ans[i+10][j+10]){\n                mx = ans[i + 10][j + 10];\n            }\n            printf(\"%lld \", ans[i + 10][j + 10]);\n        }\n        printf(\"\\n\");\n    }\n    //printf(\"%lld\\n\",mx);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 3000, M = 100010;\nLL a[N][N], prime[M], tot;\nbool vis[M];\n\nvoid init(int n) {\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (int j = 1; j <= tot && prime[j] * i <= n; ++ j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nLL lcm(LL x, LL y) {\n\tif (!x || !y) return x | y;\n\tLL o = std::__gcd(x, y);\n\treturn x / o * y;\n}\n\nsigned main() {\n\tinit(M - 1);\n\tint n = read();\n\tif (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\nnamespace MATH\n{\n\tconst int n = (int) 1e7;\n\n\tint p[n + 5], pri[n + 5], pri_cnt = 0;\n\n\tinline void init()\n\t{\n\t\tp[1] = 1;\n\t\tfor(int i = 2; i <= n; ++i)\n\t\t{\n\t\t\tif(!p[i]) p[i] = i, pri[++pri_cnt] = i;\n\t\t\tfor(int j = 1; j <= pri_cnt && i * pri[j] <= n; ++j)\n\t\t\t{\n\t\t\t\tp[i * pri[j]] = pri[j];\n\t\t\t\tif(i % pri[j] == 0) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAXN = 500;\n\nint n;\n\ninline void input()\n{\n\tn = read<int>();\n}\n\ninline void solve()\n{\n\tif(n == 2) { puts(\"4 7\\n23 10\"); return; }\n\n\tstatic int col[MAXN + 5][MAXN + 5];\n\tstatic LL a[MAXN + 5][MAXN + 5];\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) col[i][j] = (i + j) & 1;\n\tfor(int i = 0; i <= n + 1; ++i) for(int j = 0; j <= n + 1; ++j) a[i][j] = 1;\n\n\tstatic unordered_map<int, int> id0, id1;\n\tint cnt = 0;\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 0)\n\t{\n\t\tif(!id0.count(i + j)) id0[i + j] = ++cnt;\n\t\tif(!id1.count(i - j)) id1[i - j] = ++cnt;\n\t\ta[i][j] *= MATH::pri[id0[i + j]];\n\t\ta[i][j] *= MATH::pri[id1[i - j]];\n\t}\n\n\tauto lcm = [] (LL x, LL y) { return x / __gcd(x, y) * y; };\n\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) if(col[i][j] == 1)\n\t{\n\t\ta[i][j] = lcm(a[i][j], a[i - 1][j]);\n\t\ta[i][j] = lcm(a[i][j], a[i + 1][j]);\n\t\ta[i][j] = lcm(a[i][j], a[i][j - 1]);\n\t\ta[i][j] = lcm(a[i][j], a[i][j + 1]);\n\t\t++a[i][j];\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld%c\", a[i][j], j == n ? '\\n' : ' ');\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[510][510],c[510][501],ans[510][510],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n//\t\t\tif ((i+j)%2==0)\n//\t\t\t{\n//\t\t\t\tans[i][j]=zs[(i+j)/2]*zs[n+(i-j)/2+(n+1)/2];\n//\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 2000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint pri[N],p[N],tot;\ninline void sieve(int n)\n{\tfor(rint i=2;i<=n;i++)\n\t{\tif(!pri[i]) p[++tot]=i;\n\t\tfor(rint j=1;j<=tot&&i*p[j]<=n;j++)\n\t\t{\tpri[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll a[666][666]; int mov[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\ninline ll lcm(ll x,ll y){return x*y/__gcd(x,y);}\nint main()\n{\tint n,cur=1; cin>>n; sieve(1e6);\n\tfor(rint i=0;i<=n+1;i++)\n\tfor(rint j=0;j<=n+1;j++) a[i][j]=1;\n\tfor(rint i=3;i<=n+n;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i-j&&i-j<=n) a[j][i-j]*=p[cur];\n\tfor(rint i=1;i<=n-1;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=-1;i>=1-n;i-=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=1;i<=n;i++)\n\tfor(rint j=1;j<=n;j++)\n\tif((i+j)%2==0)\n\t{\tfor(rint k=0;k<4;k++) a[i][j]=lcm(a[i][j],a[i+mov[k][0]][j+mov[k][1]]);\n\t\ta[i][j]++;\n\t}\n\tfor(rint i=1;i<=n;i++,cout<<\"\\n\")\n\tfor(rint j=1;j<=n;j++) cout<<a[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nint64 p[1503];\nint pn;\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint i = 2;\n\twhile(pn < 1500) {\n\t\tfor(int j = 2;j * j <= i;++j) if(i % j == 0) goto isp;\n\t\tp[pn++] = i;\n\t\tisp:\n\t\t++i;\n\t}\n\tfor(int i = 0;i < n;++i) {\n\t\tfor(int j = 0;j < n;++j) {\n\t\t\tint64 val;\n\t\t\tif(((i+j)&1) == 1) {\n\t\t\t\tval = p[(i+j-1)/2] * p[(i+j+1)/2] * p[(i-j-1)/2+2*n] * p[(i-j+n+1)/2+2*n] + 1;\n\t\t\t} else {\n\t\t\t\tval = p[(i+j)/2] * p[(i-j+n)/2+2*n];\n\t\t\t}\n\t\t\tprintf(\"%lld \", val);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nint p[10010],mn[10010];\nll a[510][510];\nint n,tot;\nvoid euler(int n)\n{\n\ttot=0;\n\tfor(int i=2;i<=n;i++){\n\t\tif(!mn[i])p[++tot]=i,mn[i]=tot;\n\t\tfor(int j=1;j<=mn[i]&&i*p[j]<=n;j++)\n\t\t\tmn[i*p[j]]=j;\n\t}\n}\nint gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nint main()\n{\n\tn=read();\n\teuler(10000);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1){\n\t\t\t\tint x=(i-j+n+1)/2,y=(i+j+1)/2;\n\t\t\t\ta[i][j]=p[x]*p[n+y];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!((i+j)&1)){\n\t\t\t\tll cur=1;\n\t\t\t\tif(i>1)cur=cur/gcd(cur,a[i-1][j])*a[i-1][j];\n\t\t\t\tif(j>1)cur=cur/gcd(cur,a[i][j-1])*a[i][j-1];\n\t\t\t\tif(i<n)cur=cur/gcd(cur,a[i+1][j])*a[i+1][j];\n\t\t\t\tif(j<n)cur=cur/gcd(cur,a[i][j+1])*a[i][j+1];\n\t\t\t\ta[i][j]=cur+1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\twritesp(a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    vi primes;\n\n    const int MAXV = 10000;\n    vi sieve(MAXV);\n    for (int p = 2; p < MAXV; p++) {\n        if (sieve[p]) continue;\n        primes.push_back(p);\n        for (int q = p; q < MAXV; q += p) {\n            sieve[q] = p;\n        }\n    }\n\n    int tail = 0;\n    map<int, ll> sdiag, ddiag;;\n    auto get = [&primes, &tail](map<int, ll>& m, int i) {\n        if (m.count(i)) return m[i];\n        return m[i] = primes[tail++];\n    };\n\n    auto lcm = [](ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    };\n\n    int N;\n    cin >> N;\n\n    vvll res(N, vll(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i+j)&1) continue;\n            res[i][j] = get(sdiag, i+j) * get(ddiag, i-j);\n        }\n    }\n\n    int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (((i+j)&1) == 0) continue;\n            res[i][j] = 1;\n\n            for (int d = 0; d < 4; d++) {\n                int dx = dir[d][0], dy = dir[d][1];\n                res[i][j] = lcm(res[i][j], get(sdiag, i+j+dx+dy) * get(ddiag, i-j+dx-dy));\n            }\n            res[i][j]++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << res[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<random>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll gcd(ll a, ll b) {\t\t// ユークリッドの互除法\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll N;\nvector<vector<ll>> ans;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>N;\n\tans.resize(N,vector<ll>(N));\n\tvector<bool> used(10000000,false);\n\tvector<ll> tmp;\n\tfor(ll i=2;i<=10000000;i++) {\n\t\tif(!used[i]) {\n\t\t\tfor(ll j=i;j<=10000000; j*=2) {\n\t\t\t\tif(used[j]) break;\n\t\t\t\tused[j]=true;\n\t\t\t\ttmp.pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tll pos=0;\n\tREP(i,N) REP(j,N) {\n\t\tif((i+j)%2==0) {\n\t\t\tans[i][j]=tmp[pos];\n\t\t\tpos++;\n\t\t}\n\t}\n\tREP(i,N) REP(j,N) {\n\t\tif((i+j)%2==1) {\n\t\t\tvector<ll> maw;\n\t\t\tif(i>0) maw.pb(ans[i-1][j]);\n\t\t\tif(i<N-1) maw.pb(ans[i+1][j]);\n\t\t\tif(j>0) maw.pb(ans[i][j-1]);\n\t\t\tif(j<N-1) maw.pb(ans[i][j+1]);\n\t\t\tll g=maw[0];\n\t\t\tFOR(k,1,maw.size()) g=gcd(g,maw[k]);\n\t\t\tll hoge=g;\n\t\t\tREP(k,maw.size()) hoge*=maw[k]/g;\n\t\t\tans[i][j]=hoge;\n\t\t}\n\t}\n\tREP(i,N) DUMP(ans[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<9, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define lcm(x, y) (((x)/__gcd(x, y))*(y))\n\nbool prime(int a) {\n\tfor(int d = 2; d*d <= a; d++) if(a%d == 0) return 0;\n\treturn 1;\n}\n\nint n;\nll mat[maxn][maxn];\nvoid check() {\n\tll m = max(mat[0][0], mat[0][1]) % min(mat[0][0], mat[0][1]);\n\tfor(int i = 0; i + 1 < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(max(mat[i][j], mat[i + 1][j]) % min(mat[i][j], mat[i + 1][j]) != m) cerr << i << \" \" << j << \" \" << \"d\\n\";\n\tfor(int j = 0; j + 1 < n; j++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(max(mat[i][j], mat[i][j + 1]) % min(mat[i][j], mat[i][j + 1]) != m) cerr << i << \" \" << j << \" \" << \"f\\n\";\n\tll mcnt = 0;\n\tmap<ll, ll> cnt;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tmcnt = max(mcnt, ++cnt[mat[i][j]]);\n\tif(mcnt > 1)cerr << \"BAD\\n\";\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\nll on = n; n = 502;\n\tvi a, b;\n\tfor(int i = 2; b.size() < n; i++) {\n\t\tif(!prime(i)) continue;\n\t\tif(a.size() < n/2) {\n\t\t\tif(a.size()) {\n\t\t\t\ta.pb(a.back()*i);\n\t\t\t}\n\t\t\ta.pb(i);\n\t\t} else {\n\t\t\tif(b.size()) {\n\t\t\t\tb.pb(b.back()*i);\n\t\t\t}\n\t\t\tb.pb(i);\n\t\t}\n\t}\n\tset<ll> pf;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = (i&1)^1; j < n; j+=2) {\n\t\t\tmat[i][j] = a[i/2] * b[j/2];\n\t\t\twhile(pf.count(mat[i][j])) mat[i][j] *= 2;\n\t\t\tpf.insert(mat[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = 1;\n\t\t\tif(i) g = lcm(g, mat[i-1][j]);\n\t\t\tif(i+1 < n) g = lcm(g, mat[i+1][j]);\n\t\t\tif(j) g = lcm(g, mat[i][j-1]);\n\t\t\tif(j+1 < n) g = lcm(g, mat[i][j+1]);\n\t\t\tmat[i][j] = g + 1;\n\t\t}\n\tset<ll> found = pf;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = mat[i][j]-1;\n\t\t\twhile(found.count(mat[i][j])) mat[i][j] += g;\n\t\t\tfound.insert(mat[i][j]);\n\t\t}\n\tn=on;\n\tll mx = 0;\n\tfor(int i = 0; i < n; i++, cout << '\\n')\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\tcheck();\n\t//if(mx > 1e15) exit(-1);\n}\n//\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define llong long long\nint n;\nllong a[550][550];\nllong pri[2020],tot;\nbool isprime(int x)\n{\n    for(int i=1;i<=tot&&pri[i]*pri[i]<=x;++i)\n        if(x%pri[i]==0)return 0;\n    return 1;\n}\nllong calc(int x,int y){return pri[(x+y)/2]*pri[(x-y+n+1)/2+(n+n)/2];}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=2;tot<=1200;++i)\n        if(isprime(i))pri[++tot]=i;\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=1;j<=n;++j)\n            if((i+j)&1)printf(\"%lld \",calc(i-1,j)*calc(i+1,j)+1);\n            else printf(\"%lld \",calc(i,j));\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat gcd(cat x, cat y) {\n\tif(x > y) swap(x, y);\n\treturn (x == 0) ? y : gcd(y%x, x);\n}\n\ncat lcm(cat x, cat y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< vector<cat> > A(N, vector<cat>(N, 1));\n\tvector<int> P;\n\tfor(int p = 3; ; p++) {\n\t\tbool is_prime = true;\n\t\tfor(int i = 2; i*i <= p; i++) is_prime &= (p%i != 0);\n\t\tif(!is_prime) continue;\n\t\tP.push_back(p);\n\t\tif((int)P.size() == N+10) break;\n\t}\n\tfor(int i = 0; i < N; i += 2) for(int j = 0; j < N; j += 2) A[i][j] = P[i/2] * P[N/2+1+j/2];\n\tfor(int i = 1; i < N; i += 2) for(int j = 1; j < N; j += 2) A[i][j] = 2 * A[i-1][j-1];\n\tfor(int i = 0; i < N; i++) for(int j = 1-(i&1); j < N; j += 2) {\n\t\tif(i > 0) A[i][j] = lcm(A[i][j], A[i-1][j]);\n\t\tif(j > 0) A[i][j] = lcm(A[i][j], A[i][j-1]);\n\t\tif(i+1 < N) A[i][j] = lcm(A[i][j], A[i+1][j]);\n\t\tif(j+1 < N) A[i][j] = lcm(A[i][j], A[i][j+1]);\n\t\tif(i&1) A[i][j]++;\n\t\telse A[i][j] += 2;\n\t}\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N; j++) cout << A[i][j] << ((j == N-1) ? \"\\n\" : \" \");\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconstexpr int maxn = 10010;\ntypedef long long ll;\nint mnp[maxn], p[maxn], cnt;\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (!mnp[i]) mnp[i] = i, p[cnt++] = i;\n\t\tfor (int j = 0; j < cnt && p[j] * i <= n; ++j) {\n\t\t\tmnp[p[j] * i] = p[j];\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n; ll a[600][600];\ninline int get1(int x, int y) {\n\tif (x + y < 0 || (x + y) >> 1 >= n) return 1;\n\treturn p[(x + y) >> 1];\n}\ninline int get2(int x, int y) {\n\tif ((y + n - x) >> 1 < 0 || (y + n - x) >> 1 >= n) return 1;\n\treturn p[((y + n - x) >> 1) + n];\n}\nint main() {\n\tsieve(10000);\n\tstd::cin >> n;\n\tif (n == 2) {\n\t\tstd::cout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tstd::cout << ((i + j) % 2 == 0 ? 1ll * get1(i, j) * get2(i, j) : 1ll * get1(i, j - 1) * get1(i, j + 1) * get2(i, j - 1) * get2(i, j + 1) + 1) << \"\\n \"[j != n - 1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 10;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    ll cur = 2;\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            a[i][j] = cur++;\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            a[i][j] = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    a[i][j] = LCM(a[i][j], a[ni][nj]);\n                }\n            }\n            a[i][j]++;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x << \" = \" << x << endl\n#define fori(i, ini, lim) for(int i = int(ini); i < int(lim); i++)\n#define ford(i, ini, lim) for(int i = int(ini); i >= int(lim); i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\n\nconst int MAX = 1000 + 5;\nll mat[MAX][MAX];\nvector<int> primes;\nint n;\n\nvoid sieve() {\n    for(int i = 2; (int) primes.size() < MAX; i++) {\n        bool is_prime = true;\n        fori(j, 2, i) {\n            if(i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime) {\n            primes.push_back(i);\n        }\n    }\n}\n\nll gcd(ll a, ll b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n    return (a * (b / (gcd(a, b))));\n}\n\nbool construct() {\n    random_shuffle(primes.begin(), primes.end()); \n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            mat[i][j] = 1;\n        }\n    }\n    int k = 0;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == 1) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj <= n; ni++, nj++) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == n) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj >= 1; ni++, nj--) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    const vector<ii> dir {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i + j) % 2 == 0) {\n                ll l = 1;\n                for(auto &each : dir) {\n                    int ni = i + each.first;\n                    int nj = j + each.second;\n                    if(ni >= 1 && ni <= n && nj >= 1 && nj <= n) {\n                        l = lcm(l, mat[ni][nj]);\n                    }\n                }\n                mat[i][j] = l + 1;\n            }\n        }\n    }\n    return true;\n    set<ll> all;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            all.insert(mat[i][j]);\n            assert(mat[i][j] > 0);\n        }\n    }\n    return (int) all.size() == n * n;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    srand(time(nullptr));\n    cin >> n;\n    if(n == 2) {\n        cout << \"4 7\" << '\\n';\n        cout << \"23 10\" << '\\n';\n        return 0;\n    }\n    sieve();\n    while(!construct());\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if(j > 1) {\n                cout << \" \";\n            }\n            cout << mat[i][j];\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n3\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nbool isp[maxn];\nvector<int> p;\n\nll g[maxn][maxn];\n\nvector<int> a,b;\n\nll lcm(ll a,ll b){\n\tif(a==0||b==0) return a+b;\n\treturn a*b/__gcd(a,b);\n}\n\nint main()\n{\n\tIOS;\n\tint N=500;\n\n\tfor(int i=2;i<maxn;i++){\n\t\tif(!isp[i]) p.pb(i);\n\t\tfor(int j=0;i*p[j]<maxn;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tREP(i,500) a.pb(p[i]);\n\tREP(i,500) b.pb(p[i+500]);\n\n\tREP(i,500) REP(j,500) if((i+j)%2==0){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j)/2];\n\t\tg[i][j]*=b[(i-j+499)/2];\n\t}\n\n\tREP(i,500) REP(j,500) if((i+j)%2){\n\t\tg[i][j]=0;\n\n\t\tif(i+1<500) g[i][j]=lcm(g[i][j],g[i+1][j]);\n\t\tif(j+1<500) g[i][j]=lcm(g[i][j],g[i][j+1]);\n\t\tif(i) g[i][j]=lcm(g[i][j],g[i-1][j]);\n\t\tif(j) g[i][j]=lcm(g[i][j],g[i][j-1]);\n\t\tg[i][j]++;\n\t\tassert(g[i][j]<1e15);\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<g[i][j]<<\" \\n\"[j==n-1];\n\n\tREP(i,n) REP(j,n-1) assert(max(g[i][j],g[i][j+1])%min(g[i][j],g[i][j+1])==1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 510\nll a[N][N];\nint main(){\n    vector<ll> p;\n    for(ll i=2;p.size()<N*2;i++){\n\tbool ok=1;for(auto x:p)ok&=i%x>0;\n\tif(ok)p.push_back(i);\n    }\n    lol(i,N)lol(j,N){\n\tif((i+j)%2==0)a[i][j]=p[i]*p[j+N];\n\telse{\n\t    a[i][j]=p[i+1]*p[j+N+1];\n\t    if(i>0)a[i][j]*=p[i-1];\n\t    if(j>0)a[i][j]*=p[j+N-1];\n\t    a[i][j]++;\n\t}\n    }\n    ll n;cin>>n;\n    lol(i,n){\n\tlol(j,n){if(j)cout<<\" \";cout<<a[i][j];}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\nusing namespace std;\ntypedef long long ll;\nint pr[101010];\nll ans[555][555];\nll gcd(ll a, ll b)\n{\n\tfor (;;)\n\t{\n\t\tif (a < b)swap(a, b);\n\t\ta %= b;\n\t\tif (a == 0)return b;\n\t}\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0 || b == 0)return max(a, b);\n\treturn a*b / gcd(a, b);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tdeque<ll>v;\n\tfor (int i = 2; i <= 10000; i++)\n\t{\n\t\tif (pr[i] == 0)\n\t\t{\n\t\t\tfor (int j = i + i; j <= 10000; j += i)pr[j] = -1;\n\t\t\tif (i >= 30 && v.size() < num * 2 + 100)v.push_back(i);\n\t\t}\n\t}\n\tdeque<ll>x, y;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i % 4 == 0)x.push_back(v[i]);\n\t\tif (i % 4 == 1)x.push_front(v[i]);\n\t\tif (i % 4 == 2)y.push_back(v[i]);\n\t\tif (i % 4 == 3)y.push_front(v[i]);\n\t}\n\tfor (int i = 0; i < num + 5; i++)\n\t{\n\t\tfor (int j = 0; j < num + 5; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tans[i][j] = x[(i + j) / 2] * y[(i - j + num + 7) / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tfor (int j = 1; j <= num; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 != 0)\n\t\t\t{\n\t\t\t\tll t = x[(i + j - 1) / 2] * y[(i - j + num + 7 - 1) / 2] * x[(i + j + 1) / 2] * y[(i - j + num + 7 + 1) / 2];\n\t\t\t\tans[i + 1][j + 1] = t + 1;\n\t\t\t}\n\t\t\tif (ans[i + 1][j + 1]>1000000000000000LL)abort();\n\t\t\tprintf(\"%lld \", ans[i + 1][j + 1]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 507\n#define MAX_M 1000007\n\nint pri[MAX_M], tot;\nbool check[MAX_M];\n\nvoid sieve() {\n    int MX = 1000000;\n    rep(i, 2, MX) {\n        if (!check[i]) pri[++tot] = i;\n        if (tot > 1000) break;\n        rep(j, 1, tot) {\n            if (i * pri[j] > MX) break;\n            check[i * pri[j]] = true;\n            if (i % pri[j] == 0) break;\n        }\n    }\n}\n\nint N;\nll ans[MAX_N * 2][MAX_N * 2], num1[MAX_N * 2], num2[MAX_N * 2];\nvoid solve() {\n    if (N == 2) {\n        puts(\"4 7\");\n        puts(\"23 10\");\n        return;\n    }\n    int cur = 0;\n    Rep(i, N) num1[1 - i + N] = pri[++cur];\n    rep(i, 2, N) num1[i - 1 + N] = pri[++cur];\n    rep(i, 2, N + N) num2[i] = pri[++cur];\n    // rep(i, 1, N * 2 - 1) printf(\"%d \", num1[i]);\n    // puts(\"\");\n    rep(i, 0, N + 1) {\n        rep(j, 0, N + 1) if (i + j & 1) {\n            ans[i][j] =\n                std::max(1LL, num1[i - j + N]) * std::max(1LL, num2[i + j]);\n        }\n    }\n    Rep(i, N) {\n        Rep(j, N) if (!(i + j & 1)) {\n            ans[i][j] = ans[i - 1][j] * ans[i + 1][j] + 1;\n        }\n    }\n    Rep(i, N) {\n        Rep(j, N) printf(\"%lld \", ans[i][j]);\n        puts(\"\");\n    }\n}\n\nint main() {\n    sieve();\n    read(N);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, cnt = 2;\nlong long res[507][507];\nmap<int, int>a, b;\nint nxt()\n{\n\twhile (1)\n\t{\n\t\tbool ok = 1;\n\t\tfor (int i = 2; i * i <= cnt && ok; i++)\n\t\t\tif (cnt % i == 0)ok = 0;\n\t\tif (ok)return cnt++;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\nlong long gcd(long long a, long long b)\n{\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nlong long lcm(long long a, long long b)\n{\n\tif (!a || !b)return 0;\n\treturn a / gcd(a, b) * b;\n}\nint main()\n{\n\tcin >> n;\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (((i + j) & 1) && !a[i + j])\n\t\t\t\ta[i + j] = nxt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (((i + j) & 1) && !b[i - j])\n\t\t\t\tb[i - j] = nxt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tres[i][j] = 1LL * a[i + j] * b[i - j];\n\t\t\t\tres[i - 1][j] = lcm(res[i - 1][j], res[i][j]);\n\t\t\t\tres[i][j - 1] = lcm(res[i][j - 1], res[i][j]);\n\t\t\t\tres[i + 1][j] = lcm(res[i + 1][j], res[i][j]);\n\t\t\t\tres[i][j + 1] = lcm(res[i][j + 1], res[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tres[i][j]++;\n\tfor (int i = 1; i <= n; i++, putchar('\\n'))\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tprintf(\"%lld \", res[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 1000; \nconst int INF = 0x3f3f3f3f; \n\nint ans[550][550], elm[Maxv], cnt, idx, max = -INF, n; \nint x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \n\ninline int gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void pre_Opt() {\n    for (int i = 2, num;; i++) {\n        for (num = 2; num * num <= i; num++) {\n            if (i % num == 0) break; \n        }\n\n        if (num * num > i) elm[++cnt] = i; \n        if (cnt >= Maxv) break; \n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    pre_Opt(); \n\n    for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%d\\n\", elm[i]); \n    }\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = elm[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= elm[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                int res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%d \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL gcd(LL a,LL b){\n\treturn b?gcd(b,a%b):a;\n}\nLL lcm(LL a,LL b){\n\tif(!a)return b;\n\tif(!b)return a;\n\tLL g=gcd(a,b);\n\treturn a/g*b;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\tif(n==2){\n\t\tcout<<\"4 7\\n23 10\\n\";\n\t\treturn 0;\t\n\t}\n\tvector<LL>P;P.PB(0);\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=7919;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t\t//cout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(i%2!=j%2){\n\t\tg[i][j]+=lcm(lcm(g[i-1][j],g[i][j-1]),lcm(g[i+1][j],g[i][j+1]));\n\t}\n\t\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 500;\nconst int MAX2 = 10000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 2 << \" \" << 9 << endl << 4 << \" \" << 17;\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX2];\n\tfor (int i = 0;i < MAX2;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX2 - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tstatic int64_t a[MAX][MAX];\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\ta[i][j] = prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積+1\n\t\t\t\tif (i == 0 && j == N - 1) a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t\telse if (i == N - 1 && j == 0) a[i][j] = (int64_t)prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t\telse a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tvector<int64_t> chk;\n\tfor (int i = 0;i < N;++ i) { // 要らないけど、整合性チェック\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tint d[] = {0, 1, 0, -1, 0};\n\t\t\tint check[] = {-1, -1, -1, -1};\n\t\t\tfor (int k = 0;k < 4;++ k) {\n\t\t\t\tif (i + d[k] >= 0 && i + d[k] < N && j + d[k + 1] >= 0 && j + d[k + 1] < N) {\n\t\t\t\t\tcheck[k] = max(a[i][j], a[i + d[k]][j + d[k + 1]]) % min(a[i][j], a[i + d[k]][j + d[k + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(check, check+4);\n\t\t\tfor (int i = 0;i < 3;i ++) {\n\t\t\t\tif (check[i] >= 0 && check[i] != check[i + 1]) {\n\t\t\t\t\tcerr << \"err\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i][j] >= 1000000000000000) cerr << \"err\" << endl;\n\t\t\tchk.push_back(a[i][j]);\n\t\t}\n\t}\n\tsort(chk.begin(), chk.end());\n\tfor (int i = 1;i < chk.size();++ i) {\n\t\tif (chk[i] == chk[i - 1]) cerr << \"err\" << endl;\n\t}\n\tcerr << chk[chk.size() - 1] << endl;\n\t*/\n\t\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数+1にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは1だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "  #include <bits/stdc++.h>\n  template <size_t N>\n  class sieve_of_eratosthenes {\n    std::bitset<N> is_prime_;\n\n  public:\n    constexpr sieve_of_eratosthenes(){\n      is_prime_ = ~is_prime_;\n      is_prime_.reset(0), is_prime_.reset(1);\n      for (size_t p = 2; p < N; p++) {\n        if (!is_prime_.test(p)) continue;\n        for (size_t j = 2; j * p < N; j++) {\n          is_prime_.reset(p * j);\n        }\n      }\n    }\n\n    // Return the bitset testing if a number is prime.\n    constexpr const auto& is_prime() const {return is_prime_;}\n\n    // Returns the vector of prime numbers.\n    template <typename T>\n    auto primes() const {\n      std::vector<T> primes{}; \n      for (size_t i = 0; i < N; i++) {\n        if (is_prime_.test(i)) primes.push_back(i);\n      }\n      return primes;\n    }\n  };\n  int main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  auto primes = sieve_of_eratosthenes<10000000>{}.primes<long long>();\n  auto make = [&] (int n) {\n    auto ans = std::vector<std::vector<long long>>(n, std::vector<long long>(n, 0));\n    auto anti_diag = [&] (int i, int j) {\n      assert((i + j) % 2 == 0);\n      return (i + j) / 2;\n    };\n    auto diag = [&] (int i, int j) {\n      assert((i + j) % 2 == 0);\n      return (i + n - 2 - j) / 2;\n    };\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if ((i + j) % 2 == 0) {\n          ans.at(i).at(j) =\n            primes.at(anti_diag(i, j)) *\n            primes.at(n + diag(i, j));\n        } else {\n          ans.at(i).at(j) =\n            primes.at(anti_diag(i - 1, j)) *\n            primes.at(anti_diag(i + 1, j)) *\n            primes.at(n +  diag(i - 1, j)) *\n            primes.at(n +  diag(i + 1, j)) + 1;\n        }\n      }\n    }\n    return ans;\n  };\n  int n; std::cin >> n;\n  auto large = make(500);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      std::cout << (j > 0 ? \" \" : \"\") << large.at(i).at(j);\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst double eps = 1e-8;\n\nconst ll INF = 1e15;\n\nll BIG = 5000000;\n\nint main(){\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\tvector<int> isprime(BIG, 1);\n\tvector<ll> primes;\n\tfor (ll base = 2;primes.size() < N*N / 2 + 10;base++) {\n\t\tif (!isprime[base])\n\t\t\tcontinue;\n\t\tprimes.push_back(base);\n\t\tfor (ll mult = 2;mult*base < isprime.size();mult++)\n\t\t\tisprime[mult*base] = false;\n\t}\n\tvector<vector<ll>> ans(N+2, vector<ll>(N+2, 1));\n\tfor (int y = 1;y <= N;y++) {\n\t\tif ((y + 1) % 2) {\n\t\t\tans[y][1] = primes.back();\n\t\t\tprimes.pop_back();\n\t\t}\n\t\tif ((y + N) % 2) {\n\t\t\tans[y][N] = primes.back();\n\t\t\tprimes.pop_back();\n\t\t}\n\t}\n\tfor (int x = 1;x <= N;x++) {\n\t\tif ((x + 1) % 2) {\n\t\t\tans[1][x] = primes.back();\n\t\t\tprimes.pop_back();\n\t\t}\n\t\tif ((x + N) % 2) {\n\t\t\tans[N][x] = primes.back();\n\t\t\tprimes.pop_back();\n\t\t}\n\t}\n\n\tll cnt = 0;\n\tfor (int y = 2;y < N;y++)\n\t\tfor (int x = 2;x < N;x++) {\n\t\t\tif ((y + x) % 2) {\n\t\t\t\tll check = cnt % 2 ? (ll)primes.size() - cnt / 2 : cnt/2;\n\t\t\t\tans[y][x] = primes[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\tfor (int y = 1;y <= N;y++)\n\t\tfor (int x = 1;x <= N;x++) {\n\t\t\tif ((y + x) % 2 == 0) {\n\t\t\t\tans[y][x] = ans[y + 1][x] * ans[y - 1][x] * ans[y][x + 1] * ans[y][x - 1] + 1;\n\t\t\t}\n\t\t}\n\tint dx[] = { -1, 0, 1, 0 };\n\tint dy[] = { 0, -1, 0, 1 };\n\tset<ll> st;\n\tfor (int y = 1;y <= N;y++)\n\t\tfor (int x = 1;x <= N;x++) {\n\t\t\tfor (int k = 0;k < 4;k++) {\n\t\t\t\tint nx = x + dx[k];\n\t\t\t\tint ny = y + dy[k];\n\t\t\t\tst.insert(ans[y][x]);\n\t\t\t\tif (nx <= 0 || nx > N || ny <= 0 || ny > N)\n\t\t\t\t\tcontinue;\n\t\t\t\tassert(max(ans[y][x], ans[ny][nx]) % min(ans[y][x], ans[ny][nx]) == 1);\n\t\t\t}\n\t\t}\n\tassert(st.size() == N * N);\n\tfor (int y = 1;y <= N;y++)\n\t\tfor (int x = 1;x <= N;x++) {\n\t\t\tcout << ans[y][x];\n\t\t\tif (x == N)\n\t\t\t\tcout << endl;\n\t\t\telse\n\t\t\t\tcout << \" \";\n\t\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef unsigned __int128 ll;\nusing namespace std;\nconst int MN=8000;\nint n,pri[1001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+(abs(i-j)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",(long long)a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(int x){\n\tif(x <= 1) return false;\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 500;\nlong long r[maxn][maxn], p[2][4 * maxn];\nlong long gcd(long long a, long long b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nint main(){\n\tvector<int> primes;\n\tfor(int i = 1; primes.size() < 2000; i++) if(is_prime(i)) primes.push_back(i);\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) r[i][j] = 1;\n\tint stk = 0;\n\tfor(int i = 0; i < maxn + maxn; i += 2){\n\t\tp[0][i] = stk++;\n\t\tp[1][i] = stk++;\n\t}\n\tassert(stk <= primes.size());\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) {\n\t\tint x = i - j + maxn;\n\t\tint y = i + j;\n\t\tif(x % 2 == 0){\n\t\t\tr[i][j] *= primes[p[0][x]] * primes[p[1][y]];\n\t\t}\n\t}\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++){\n\t\tint x = i - j + maxn;\n\t\tif(x % 2 == 1){\n\t\t\tvector<long long> cand;\n\t\t\tif(i) cand.push_back(r[i - 1][j]);\n\t\t\tif(j) cand.push_back(r[i][j - 1]);\n\t\t\tif(i + 1 < maxn) cand.push_back(r[i + 1][j]);\n\t\t\tif(j + 1 < maxn) cand.push_back(r[i][j + 1]);\n\t\t\tlong long lc = cand[0] / gcd(cand[0], cand[1]) * cand[1];\n\t\t\tfor(int j = 2; j < cand.size(); j++) lc = lc / gcd(lc, cand[j]) * cand[j];\n\t\t\tr[i][j] = lc;\n\t\t}\n\t}\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[i][j], mx = r[i][j + 1];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 0);\n\t\t}\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[j][i], mx = r[j + 1][i];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 0);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tcout << r[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,a[505][505],p[30005],vis[30005];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=30000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=30000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=p[i-j+n/2*2+1]*p[(i+j)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cassert>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nlong gcd(long a, long b) {\n    while (b > 0) {\n        long c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nlong lcm(long a, long b) {\n    long d = gcd(a, b);\n    return a / d * b;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n\n    vector<bool> pm(100000, 1);\n    vector<int> p;\n\n    for (int i = 2; p.size() < 1005; i++) {\n        if (pm[i]) {\n            p.push_back(i);\n//            cout << p.size() << \" \" << i << \"\\n\";\n            for (int j = 2 * i; j < pm.size(); j += i) {\n                pm[j] = false;\n            }\n        }\n    }\n\n    int n;\n    cin >> n;\n\n    vector<long> d1(n);\n    for (int i = 0; i < n; i++) {\n        d1[i] = p[i];\n    }\n    vector<long> d2(n);\n    for (int i = 0; i < n; i++) {\n        d2[i] = p[n + i];\n    }\n\n    vector<vector<long>> a(n, vector<long>(n));\n\n    set<long> used;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0) {\n                a[i][j] = d1[(i + j) / 2] * d2[(i - j) / 2 + n / 2];\n//                cout << d1[(i + j) / 2] << \"*\" << d2[(i - j) / 2 + n / 2] << \" \";\n                used.insert(a[i][j]);\n            }\n        }\n//        cout << \"\\n\";\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 1) {\n                a[i][j] = 1;\n                if (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n                if (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n                if (i < n - 1) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n                if (j < n - 1) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n                int x = a[i][j];\n                a[i][j]++;\n                while (used.find(a[i][j]) != used.end()) {\n                    a[i][j] += x;\n                    assert(a[i][j] <= 1000000000000000L);\n                }\n                used.insert(a[i][j]);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << a[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll __int128\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=500+10,MAXM=1000000+10;\nint n,vis[MAXM],prime[MAXM],cnt,p;\nll G[MAXN][MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void init()\n{\n\tmemset(vis,1,sizeof(vis));\n\tvis[0]=vis[1]=0;\n\tREP(i,2,MAXM-1)\n\t{\n\t\tif(vis[i])prime[++cnt]=i;\n\t\tfor(register int j=1;j<=cnt&&i*prime[j]<MAXM;++j)\n\t\t{\n\t\t\tvis[i*prime[j]]=0;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\ninline bool check(int x,int y)\n{\n\tif(G[x][y]%G[x-1][y]!=1)return false;\n\tif(G[x][y]%G[x+1][y]!=1)return false;\n\tif(G[x][y]%G[x][y-1]!=1)return false;\n\tif(G[x][y]%G[x][y+1]!=1)return false;\n\treturn true;\n}\nint main()\n\n\tread(n);init();int x,y;\n\tREP(i,0,n+1)REP(j,0,n+1)G[i][j]=1;\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y>=0)G[x][y]*=prime[p],x++,y--;\n\t}\n\tREP(i,n+1,0)if(i%2==0)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y<=n+1)G[x][y]*=prime[p],x--,y++;\n\t}\n\tREP(i,0,n+1)if(i%2==0)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y>=0)G[x][y]*=prime[p],x--,y--;\n\t}\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y<=n+1)G[x][y]*=prime[p],x++,y++;\n\t}\n\tREP(i,1,n)REP(j,1,n)if((i+j)%2==0)\n\t{\n\t\tG[i][j]=G[i-1][j]*G[i+1][j]+1,assert(check(i,j));\n\t}\n\tREP(i,1,n)\n\t{\n\t\tREP(j,1,n)assert(G[i][j]<=1e15),write(G[i][j],' ');puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 505;\n\nll v[MAXN][MAXN];\nbool not_prime[2000005];\nvector<int> p;\n\nll gcd(ll x, ll y) {\n  return y ? gcd(y, x % y) : x;\n}\n\nll lcm(ll x, ll y) {\n  return x / gcd(x, y) * y;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  if(n == 2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n  not_prime[1] = 1;\n  for(int i = 2; i <= 2000000; i++) {\n    if(!not_prime[i]) {\n      p.push_back(i);\n      for(int j = i + i; j <= 2000000; j += i) {\n        not_prime[j] = 1;\n      }\n    }\n  }\n  for(int i = 0; i <= n + 1; i++) {\n    for(int j = 0; j <= n + 1; j++) {\n      v[i][j] = 1;\n    }\n  }\n  vector<int> id1, id2;\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if((i + j) % 2 == 1) {\n        id1.push_back(i - j);\n        id2.push_back(i + j);\n      }\n    }\n  }\n  sort(id1.begin(), id1.end());\n  sort(id2.begin(), id2.end());\n  id1.erase(unique(id1.begin(), id1.end()), id1.end());\n  id2.erase(unique(id2.begin(), id2.end()), id2.end());\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if((i + j) % 2 == 1) {\n        v[i][j] *= p[lower_bound(id1.begin(), id1.end(), i - j) - id1.begin()];\n        v[i][j] *= p[id1.size() + lower_bound(id2.begin(), id2.end(), i + j) - id2.begin()];\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if((i + j) % 2 == 0) {\n        v[i][j] = lcm(lcm(v[i - 1][j], v[i][j - 1]), lcm(v[i + 1][j], v[i][j + 1])) + 1;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      printf(\"%lld \", v[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nbool np[SZ];\nint n,ps[SZ],pn;\nll a[555][555];\nset<ll> sw;\nll lcm(ll a,ll b)\n{return a/__gcd(a,b)*b;}\nint main()\n{\n\tfor(int i=2;i<SZ;++i) if(!np[i])\n\t{\n\t\tps[++pn]=i;\n\t\tfor(int j=i;j<SZ;j+=i) np[j]=1;\n\t}\n\tcin>>n; \n\tfor(int i=0;i<=n+1;++i)\n\t\tfor(int j=0;j<=n+1;++j) a[i][j]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif((i+j)%2==0)\n\t\t\t{\n\t\t\t\ta[i][j]=ps[(i+1)/2+1]*(ll)ps[(j+1)/2+(n+1)/2+1]*(1+(i%2));\n\t\t\t\tsw.insert(a[i][j]);\n\t\t\t}\n\tfor(int i=n;i>=1;--i)\n\t\tfor(int j=n;j>=1;--j)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tll u=\n\t\t\t\tlcm(\n\t\t\t\tlcm(a[i][j+1],a[i][j-1]),\n\t\t\t\tlcm(a[i-1][j],a[i+1][j])\n\t\t\t\t),uu=u;\n\t\t\t\twhile(sw.count(uu+1)) uu+=u;\n\t\t\t\tsw.insert(a[i][j]=uu+1);\n\t\t\t}\n\tfor(int i=1;i<=n;++i,puts(\"\"))\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int M=500,N=8000;\nll num[M+5][M+5],prm[N+5];\nbool avoid[N+5];\nint n,m;\nvoid Prepare_Prime(){\n\tfor(int i=2;i<=N;i++){\n\t\tif(!avoid[i]) prm[++prm[0]]=i;\n\t\tfor(int j=1;j<=prm[0];j++){\n\t\t\tif(i*prm[j]>N) break;\n\t\t\tavoid[prm[j]*i]=true;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\nll GCD(ll a,ll b){return b? a:GCD(b,a%b);}\nll LCM(ll a,ll b){return a/GCD(a,b)*b;}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tPrepare_Prime();\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tnum[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\tnum[i][j]=prm[(i+j)/2]*prm[1000-(i-j)/2-(n+1)/2+1];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2)\n\t\t\t\tnum[i][j]=LCM(LCM(num[i-1][j],num[i][j-1]),LCM(num[i+1][j],num[i][j+1]));\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<n;j++)\n\t\t\tprintf(\"%lld \",num[i][j]);\n\t\tprintf(\"%lld\\n\",num[i][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,s,n) for(int i = s; i < n; i++)\nconst int maxn = 505;\nll ans[maxn][maxn];\nll n;\n\nint main(){\n\tcin>>n;\n\tans[0][0] = 4;\n\trep(i,1,n) ans[0][i] = ans[0][i-1]+1;\n\trep(i,1,n){\n\t\tans[i][0] = (ans[i-1][n-1]/4+1)*4+1;\n\t\trep(j,1,n){\n\t\t\tint x = ans[i-1][j]; int y = ans[i][j-1];\n\t\t\tans[i][j] = x*y/__gcd(x,y)+1;\n\t\t}\n\n\t}\n\trep(i,0,n){\n\t\trep(j,0,n){\n\t\t\tprintf(\"%I64d \", ans[i][j]);\n\t\t}\n\t\tcout<<endl;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pw(x) (1LL << (x))\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\nconst int INF = 1.01e9;\n\nvector<vector<ll>> solve(int n) {\n    int N = 1e6;\n    vector<vector<int>> e(N);\n    for (int i = 1; i < N; i++) {\n        for (int j = i + i; j < N; j += i) {\n            e[i].push_back(j);\n            e[j].push_back(i);\n        }\n    }\n\n    vector<int> used(N, 0);\n\n    auto bad = [&](int v) {\n        int cnt = 0;\n        for (int to : e[v]) {\n            cnt += used[to] == 0;\n            if (cnt > 1) return 0;\n        }\n        return 1;\n    };\n\n    vector<vector<int>> res;\n    for (int ii = 0; ii < 2; ii++) {\n        vector<int> vct;\n        int v = 1;\n        while (used[v] != 0) v++;\n\n        vct.push_back(v);\n        while (vct.size() < 500) {\n            static int iter = 0;\n            if (iter++ % 1000 == 0) cerr << ii << \", \" << iter << \": \" << vct.size() << endl;\n\n            int v = vct.back();\n\n            random_shuffle(e[v].begin(), e[v].end());\n            int found = -1;\n            for (int to : e[v]) {\n                if (used[to] == 0 && !bad(to)) {\n                    found = to;\n                    break;\n                }\n            }\n            if (found != -1) {\n                used[found] = 1;\n                vct.push_back(found);\n                continue;\n            }\n            for (int to : e[v]) {\n                if (used[to] != -1 && !bad(to)) {\n                    found = to;\n                    break;\n                }\n            }\n            assert(found != -1);\n            int pos = 0;\n            while (vct[pos] != found) pos++;\n            reverse(vct.begin() + pos + 1, vct.end());\n        }\n        res.push_back(vct);\n        for (int x : vct) used[x] = 1;\n    }\n\n    vector<vector<ll>> ans(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            ans[i][j] = 1LL * res[0][i] * res[1][j];\n        }\n    }\n    return ans;\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n\n    int n;\n    while (cin >> n) {\n        auto a = solve(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cout << a[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n#ifdef HOME\n    cerr << \"time = \" << (clock() * 1. / CLOCKS_PER_SEC) << \"\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 502;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,p[30005],vis[30005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=30000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=30000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=p[(i-j+n+1)/2]*p[(i+j)/2+n];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << '\\n';\n#else\n\t#define DBG(X)\n#endif\n \nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline void goodbye(const T& val) { cout << val << endl; exit(0); }\n\nconst int MAXN     = 543;\n\nll GCD(ll x, ll y) {\n\treturn (x == 0 ? y : GCD(y % x, x));\n}\n\nll LCM(ll x, ll y) {\n\treturn (x / GCD(x, y)) * y;\n}\n\nll answ[MAXN][MAXN];\nint n;\n\nconst int NDIRS = 4;\nconst int di[] = {0, 0, -1, 1};\nconst int dj[] = {-1, 1, 0, 0};\n\nint valid(int i, int j) {\n\treturn (i >= 0 && j >= 0 && i < n && j < n);\n}\n\nvoid solve() {\n\tcin >> n;\n\tset<ll> setik;\n\n\tconst ll m = 2;\n\tll last = m + 1;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tint t = (i + j) & 1;\n\n\t\t\tif(t == 0) {\n\t\t\t\tansw[i][j] = last++;\n\t\t\t\tsetik.insert(answ[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tint t = (i + j) & 1;\n\n\t\t\tif(t == 1) {\n\t\t\t\tvector<ll> neighbors;\n\n\t\t\t\tfor(int dir = 0; dir < NDIRS; ++dir) {\n\t\t\t\t\tint i2 = i + di[dir], j2 = j + dj[dir];\n\n\t\t\t\t\tif(valid(i2, j2)) {\n\t\t\t\t\t\tneighbors.push_back(answ[i2][j2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tll l = neighbors.front();\n\n\t\t\t\tfor(auto& elem: neighbors) {\n\t\t\t\t\tl = LCM(l, elem);\n\t\t\t\t}\n\n\t\t\t\tll cur = l + m;\n\n\t\t\t\twhile(setik.count(cur)) {\n\t\t\t\t\tcur += l;\n\t\t\t\t}\n\n\t\t\t\tansw[i][j] = cur;\n\t\t\t\tsetik.insert(answ[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tcout << answ[i][j] << ' ';\n\t\t}\n\n\t\tcout << '\\n';\n\t}\n\n#ifdef __LOCAL\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tfor(int dir = 0; dir < NDIRS; ++dir) {\n\t\t\t\tint i2 = i + di[dir], j2 = j + dj[dir];\n\n\t\t\t\tif(valid(i2, j2)) {\n\t\t\t\t\tll mx = answ[i][j];\n\t\t\t\t\tll mn = answ[i2][j2];\n\n\t\t\t\t\tif(mx < mn) {\n\t\t\t\t\t\tswap(mx, mn);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(mx % mn != m) {\n\t\t\t\t\t\tcout << \"BAD: \" << i << ' ' << j << ' ' << i2 << ' ' << j2 << '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=3583;\nint i,j,M,n,m,cnt,c[505];bool bz[N+5];\nll a[505][505],p;\nint main(){\n\tc[0]=1;\n\tfo(i,2,N)if (!bz[i]) {\n\t\tc[++cnt]=i;\n\t\tfor(j=i<<1;j<=N;j+=i) bz[j]=1;\n\t}\n\tscanf(\"%d\",&n);\n\tM=n/2+1;\n\tfo(i,1,n){\n\t\tp=i&1?c[i/2+1]:c[i/2]*2;\n\t\tfor(j=2-(i&1),m=M+1;j<=n;j+=2,m++) a[i][j]=p*c[m];\n\t}\n\tfo(i,1,n){\n\t\tp=(i&1?2:4)*c[i/2]*c[i/2+1];\n\t\tif (!(i&1)) a[i][j=1]=p*c[M+1],m=M+1;else\n\t\ta[i][j=2]=p*c[M+1]*c[M+2],m=M+2;\n\t\tfor(j+=2;j<=n;j+=2,m++) a[i][j]=p*c[m]*c[m+1];\n\t}\n\tfo(i,1,n)\n\tfo(j,1,n) printf(\"%lld%c\",a[i][j],j<n?' ':'\\n') ;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,a[505][505],p[30005],vis[30005];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=30000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=30000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=p[(i-j+n+1)/2]*p[(i+j)/2+n];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define res register ll\n#define ll long long \n#define N 1005\nusing namespace std;\nll a[N][N],p[N],n,tot,cnt=2e9;\nbool ispri[N*100];\ninline ll read(){\n\tres w=0,X=0;register char ch=getchar();\n\twhile(!isdigit(ch)){w|=ch=='-';ch=getchar();}\n\twhile(isdigit(ch)){X=(X<<1)+(X<<3)+(ch^48);ch=getchar();}\n\treturn w?-X:X;\n}\nint main(){\n\tn=read();\n\tfor(res i=0;i<N;i++)\n\t  for(res j=0;j<N;j++)\n\t    a[i][j]=1;\n\tfor(res i=2;p[0]<N-1;i++){\n\t\tif(!ispri[i]) p[++p[0]]=i;\n\t\tfor(res j=1;j<=p[0]&&i*p[j]<N*100;j++){\n\t\t\tispri[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tputs(\"1\");\n\tfor(res i=1;i<=n;i++)\n\t  for(res j=1;j<=n;j++)\n\t    if((i+j)%2==0){\n\t      a[i][j]=p[(i+j)>>1];\n\t      tot=max(tot,i+j>>1);\n\t    }\n\tfor(res i=1;i<=n;i++)\n\t  for(res j=1;j<=n;j++)\n\t    if((i-j)%2==0)\n\t      cnt=min(cnt,(i-j)/2);\n\tcnt=-cnt;\n\tfor(res i=1;i<=n;i++)\n\t  for(res j=1;j<=n;j++)\n\t    if((i-j)%2==0)\n\t      a[i][j]*=p[cnt+tot+(i-j>>1)+1];\n\tfor(res i=1;i<=n;i++)\n\t  for(res j=1;j<=n;j++)\n\t    if((i+j)&1)\n\t      a[i][j]=a[i-1][j]*a[i][j-1]*a[i+1][j]*a[i][j+1]+1;\n\tfor(res i=1;i<=n;i++,puts(\"\"))\n\t  for(res j=1;j<=n;j++)\n\t    printf(\"%lld \",a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = ml * (ans[i][j - 1] / gcd(ml, ans[i][j - 1]));\n\t\t\t\tif (i < n - 1) ml = ml * (ans[i + 1][j] / gcd(ml, ans[i + 1][j]));\n\t\t\t\tif (j < n - 1) ml = ml * (ans[i][j + 1] / gcd(ml, ans[i][j + 1]));\n\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 633;\nint n,w=150000,s[N],len;ll a[633][633];\nmap<ll,bool>used;\nll gcd(ll a, ll b){return !b?a:gcd(b,a%b);}\nll lcm(ll a, ll b){return min(a,b)==0?max(a,b):a/gcd(a,b)*b;}//WA\nbool isprime(int x){\n\trep(i,2,x-1)if(x%i==0)return 0;return 1;\n}\nint main() {\n\tread(n);int dfn=0;\n\tfor(int i=2;len<n;i++)if(isprime(i))s[++len]=i;\n\trep(i,1,n)rep(j,1,n)if((i+j)&1){//(1,i)\n\t\tif(i-1>=1&&j+1<=n)continue;dfn++;\n\t\tll v=0;int x=i,y=j;\n\t\twhile(x<=n&&y>=1){\n\t\t\tv+=s[dfn];while(used[v])v+=s[dfn];used[v]=1;a[x][y]=v;x++;y--;\n\t\t//\tassert(v<=3e7);\n\t\t}\n\t}\n\trep(i,0,n)a[0][i]=a[i][0]=a[i][n+1]=a[n+1][i]=0;\n\trep(i,1,n)rep(j,1,n)if((i+j)%2==0){\n\t//\tprintf(\"%d %d %lld %lld\\n\",a[i][j-1],a[i][j+1],gcd(a[i][j-1],a[i][j+1]),lcm(a[i][j-1],a[i][j+1]));\n\t\tll val=lcm(lcm(a[i][j-1],a[i][j+1]),lcm(a[i-1][j],a[i+1][j]));if(val==0)val=R();\n\t//\tprintf(\"val = %lld %d %d %d %d (%d,%d)\\n\",val,a[i][j-1],a[i][j+1],a[i-1][j],a[i+1][j],i,j);\n\t\tll v=val;while(used[v+1])v+=val;used[v+1]=1;a[i][j]=v+1;//WA\n\t//\tif(v>1e15)printf(\"%lld %lld\\n\",val,v);\n\t}\n\tset<ll>Q;\n\trep(i,1,n)rep(j,1,n){\n\t\tif(j+1<=n)assert(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1])==1);\n\t\tif(i+1<=n)assert(max(a[i][j],a[i+1][j])%min(a[i][j],a[i+1][j])==1);\n\t\tassert(a[i][j]<=1e15);assert(!Q.count(a[i][j]));Q.insert(a[i][j]);\n\t}\n\trep(i,1,n){rep(j,1,n)printf(\"%lld \",a[i][j]);puts(\"\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs int N = 1e3 + 50, M = 5e3;\nint n, a[N], b[N]; bool isp[M];\nll mp[N][N]; int prm[M], pc;\nvoid Sieve(){\n\tfor(int i=2; i<M&&pc<n+n; i++){\n\t\tif(!isp[i]) prm[++pc]=i;\n\t\tfor(int j=1; j<=pc; j++){\n\t\t\tif(prm[j]*i>=M) break;\n\t\t\tisp[prm[j]*i]=true; if(i%prm[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y){ return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y){\n\tif(!x||!y) return x+y; \n\treturn x / gcd(x,y) * y;\n}\nint main(){\n\tscanf(\"%d\",&n); Sieve();\n\tif(n==2) return cout<<\"4 7\\n23 10\",0;\n\tint l=1, r=pc; \n\tfor(int i=1; i<=n; i++)\n\ta[i]=(i&1)?prm[l++]:prm[r--];\n\tfor(int i=1; i<=n; i++)\n\tb[i]=(i&1)?prm[l++]:prm[r--];\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) if((i+j)&1^1){\n\t\tint x=(i+j)>>1, y=(j+(n-i+1))>>1;\n\t\tmp[i][j]=(ll)a[x]*b[y];\n\t} for(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) if((i+j)&1){\n\t\tll x=lcm(mp[i][j-1],mp[i-1][j]);\n\t\tll y=lcm(mp[i+1][j],mp[i][j+1]); \n\t\tmp[i][j]=lcm(x,y)+1;\n\t} for(int i=1; i<=n; i++,puts(\"\"))\n\tfor(int j=1; j<=n; j++) cout<<mp[i][j]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n    int f=1,sum=0;\n    char x=getchar();\n    for(;(x<'0'||x>'9');x=getchar()) if(x=='-') f=-1;\n    for(;x>='0'&&x<='9';x=getchar()) sum=sum*10+x-'0';\n    return f*sum;\n}\n\n#define M 505\n#define N 8000\nint n;\nll a[M][M];\nint prime[N+5];\nbool notprime[N+5];\n\nmap <ll,bool> cc;\n\nvoid get_prime() {\n    for1(2,N,i) {\n        if(!notprime[i]) prime[++prime[0]]=i;\n        for1(1,prime[0],j) {\n            if(i*prime[j]>N) break;\n            notprime[i*prime[j]]=1;\n            if(!(i%prime[j])) break;\n        }\n    }\n}\n\ninline ll gcd(ll x,ll y) {return y?gcd(y,x%y):x;}\ninline ll Lcm(ll x,ll y) {return x/gcd(x,y)*y;}\n\nint main () {\n    //freopen(\"a.in\",\"r\",stdin);\n    n=read();\n    if(n==2) {\n        puts(\"4 7\");\n        puts(\"23 10\");\n        return 0;\n    }\n    get_prime();\n    for1(0,n+1,i) for1(0,n+1,j) a[i][j]=1;\n    for1(1,n,i) for1(1,n,j) if(!(i+j&1)) a[i][j]=prime[(i+j)/2]*prime[1000-(i-j)/2-(n+1)/2+1];\n    for1(1,n,i) for1(1,n,j) if(i+j&1) a[i][j]=Lcm(Lcm(a[i-1][j],a[i][j-1]),Lcm(a[i][j+1],a[i+1][j]))+1;\n    for1(1,n,i) {\n        for1(1,n,j) printf(\"%lld \",a[i][j]);\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll gcd(ll a,ll b){\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\n\nconst int M=500,L=10000;\nll a[M+2][M+2],n;\nbool b[L];\nvl p;\nset<ll> st;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n;\n\tfill(b,b+L,1);\n\tfor(int i=0;i<M+2;i++) fill(a[i],a[i]+M+2,1);\n\tfor(int i=2;i<L;i++) if(b[i]){\n\t\tp.push_back(i);\n\t\tfor(int j=i;j<L;j+=i) b[j]=0;\n\t}\n\tfor(int i=1;i<=M;i++) for(int j=1;j<=M;j++) if((i+j)%2==0){\n\t\tll t=p[(j-i)/2+249]*p[(i+j)/2+498];\n\t\ta[i][j]=t;st.insert(t);\n\t}\n\tfor(int i=1;i<=M;i++) for(int j=1;j<=M;j++) if((i+j)%2==1){\n\t\tll x=1;\n\t\tfor(int k=0;k<4;k++) x=lcm(x,a[i+dx[k]][j+dy[k]]);\n\t\ta[i][j]=x+1;st.insert(x+1);\n\t}\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cout<<a[i][j]<<\" \\n\"[j==n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nlong long gcd(re long long a,re long long b){return b?gcd(b,a%b):a;}\nlong long lcm(re long long a,re long long b){return a/gcd(a,b)*b;}\nlong long a[510][510],pri[1010],cnt;\nbool vis[100100];\nint main()\n{\n\tre int n;\n\tscanf(\"%d\",&n);\n\tfor(re int i=2;cnt<=1000;i++)\n\t{\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tfor(re int j=1;j<=cnt&&i*pri[j]<=100000;j++)\n\t\t{\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(re int i=-n+1+(!(n&1)),i1=1;i<n;i+=2,i1++)\n\t{\n\t\tfor(re int j=1;j<=n&&i+j<=n;j++)if(i+j>0)a[j][i+j]=pri[i1];\n\t}\n\tfor(re int i=2,i1=n+1;i<=2*n;i+=2,i1++)\n\t{\n\t\tfor(re int j=1;j<=n&&i-j>0;j++)a[j][i-j]*=pri[i1];\n\t}\n\tfor(re int i=1;i<=n;i++)a[i][0]=a[0][i]=a[i][n+1]=a[n+1][i]=1;\n\tfor(re int i=1;i<=n;i++,puts(\"\"))for(re int j=1;j<=n;j++)\n\t{\n\t\tif(!a[i][j])a[i][j]=lcm(lcm(a[i+1][j],a[i-1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\t\tprintf(\"%lld \",a[i][j]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\t\nusing namespace std;\n\ntypedef double db;\ntypedef long long LL;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 505;\nconst int L = 1e5+5;\n\nint n;\nbool bz[L];\nint pri[L],k;\nint a[N][N];\nset<LL>s;\n\nLL gcd(LL x,LL y){return !y?x:gcd(y,x%y);}\n\nLL lcm(LL x,LL y){\n\treturn x/gcd(x,y)*y;\n}\n\nint main(){\n\tn=get();\n\tfo(i,2,1e5)\n\tif(!bz[i]){\n\t\tpri[++k]=i;\n\t\tfo(j,1,1e5/i)bz[i*j]=1;\n\t}\n\tfo(i,1,n)fo(j,1,n)a[i][j]=1;\n\tint w=1;\n\tfo(i,1,n){\n\t\tint st=(i&1)?1:2;\n\t\tfor(int j=st;j<=n;j+=2)a[i][j]=pri[w];\n\t\tw++;\n\t}\n\tfo(j,1,n){\n\t\tint st=(j&1)?1:2;\n\t\tfor(int i=st;i<=n;i+=2)a[i][j]=a[i][j]*pri[w]*2;\n\t\tw++;\n\t}\n\ts.clear();\n\tfo(i,1,n)fo(j,1,n)if((i+j)%2==0)s.insert(a[i][j]);\n\tfo(i,1,n)\n\t\tfo(j,1,n)\n\t\tif ((i+j)%2==1){\n\t\t\tLL v=1;\n\t\t\tif (i>1) v=lcm(v,a[i-1][j]);\n\t\t\tif (i<n)v=lcm(v,a[i+1][j]);\n\t\t\tif (j>1)v=lcm(v,a[i][j-1]);\n\t\t\tif (j<n)v=lcm(v,a[i][j+1]);\n\t\t\tLL now=v;\n\t\t\twhile(s.find(now)!=s.end())now=now+v;\n\t\t\ts.insert(now);\n\t\t\ta[i][j]=now+1;\n\t\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)printf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nll mat[502][502];\nint np[1000001],pr[1000001],p=0,pp=0;\nint n;\nll gcd(ll a,ll b){\n\tif(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tnp[1]=1;\n\tfor(int i=0;i<=500;i++){\n\t\tfor(int j=0;j<=500;j++){\n\t\t\tmat[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=1000000;i++){\n\t\tfor(int j=i*2;j<=1000000;j+=i){\n\t\t\tnp[j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(!np[i]) pr[++p]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)==(j&1)) mat[i][j]=pr[++pp];\n\t\t\t//printf(\"%d %d %d\\n\",i,j,pr[pp]);\n\t\t\tif((i&1)==(j&1)){\n\t\t\t\tmat[i][j-1]=lcm(mat[i][j],mat[i][j-1]);\n\t\t\t\tmat[i][j+1]=lcm(mat[i][j],mat[i][j+1]);\n\t\t\t\tmat[i-1][j]=lcm(mat[i][j],mat[i-1][j]);\n\t\t\t\tmat[i+1][j]=lcm(mat[i][j],mat[i+1][j]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)!=(j&1)) mat[i][j]++;\n\t\t\tprintf(\"%lld \",mat[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN + 5)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e3 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, tot, vis[1000005], pri[1000005], a[N][N];\nvoid init(int n) {\n\tfor(int i = 2; i <= n; ++ i) {\n\t\tif(vis[i] == 0) pri[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * pri[j] <= n; ++ j) {\n\t\t\tvis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nint gcd(int x, int y) {return y == 0 ? x : gcd(y, x % y);}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / gcd(x, y) * y;\n}\nsigned main() {\n\tn = read(); init(1e4);\n\tif(n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = pri[(i + j) / 2] * pri[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i, puts(\"\")) for(int j = 1; j <= n; ++ j) printf(\"%lld \", a[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\n\nint not_prime(int x)\n{\n    for (int i = 2; i < x; i++) if (x % i == 0) return 1;\n    return 0;\n}\n\nint ok(int i, int j)\n{\n    return (0 <= i && i < 500 && 0 <= j && j < 500);\n}\n\nvector<ll> nums[600][600];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n;\n    int p = 2;\n    for (int si = 1; si <= 1000; si += 2)\n    {\n        while (not_prime(p)) p++;\n        for (int i = 0; i <= 500; i++)\n        {\n            for (int j = 0; j <= 500; j++)\n            {\n                if (i + j == si)\n                {\n                    nums[i][j].push_back(p);\n                }\n            }\n        }\n        p++;\n    }\n    for (int dif = -499; dif <= 499; dif += 2)\n    {\n        while (not_prime(p)) p++;\n        for (int i = 0; i <= 500; i++)\n        {\n            for (int j = 0; j <= 500; j++)\n            {\n                if (i - j == dif)\n                {\n                    nums[i][j].push_back(p);\n                }\n            }\n        }\n        p++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (i % 2 != j % 2)\n            {\n                ll k = 1;\n                for (auto e : nums[i][j]) k *= e;\n                cout << k << \" \";\n            }\n            else\n            {\n                vector<ll> p;\n                for (int k = 0; k < 4; k++)\n                {\n                    if (ok(i + cx[k], j + cy[k]))\n                    {\n                        p.push_back(nums[i + cx[k]][j + cy[k]][0]);\n                        p.push_back(nums[i + cx[k]][j + cy[k]][1]);\n                    }\n                }\n                uniq(p);\n                ll k = 1;\n                for (auto e : p) k *= e;\n                cout << k + 1 << \" \";\n            }\n        }\n        cout << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n    return y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n    return x / GCD(x, y) * y;\n}\nvoid sieve() {\n    for(int i=2;i<=MAXM;i++) {\n        if( !vis[i] ) prm[++pcnt] = i;\n        for(int j=1;i*prm[j]<=MAXM;j++) {\n            vis[i*prm[j]] = true;\n            if( i % prm[j] == 0 ) break;\n        }\n    }\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n    sieve(); int N;\n    scanf(\"%d\", &N);\n    if( N == 2 ) {\n        printf(\"10 31\\n31 15\\n\");\n        return 0;\n    }\n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++)\n            Mat[i][j] = 1;\n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++)\n            if( (i & 1) == (j & 1) ) {\n                Mat[i][j] = prm[(i + j) / 2] * prm[(i+N+1-j)/2 + N];\n                Mat[i+1][j] = LCM(Mat[i+1][j], Mat[i][j]);\n                Mat[i-1][j] = LCM(Mat[i-1][j], Mat[i][j]);\n                Mat[i][j+1] = LCM(Mat[i][j+1], Mat[i][j]);\n                Mat[i][j-1] = LCM(Mat[i][j-1], Mat[i][j]);\n            }\n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++)\n            if( (i & 1) != (j & 1) )\n                Mat[i][j]++;\n    for(int i=1;i<=N;i++) {\n        for(int j=1;j<N;j++)\n            printf(\"%lld \", Mat[i][j]);\n        printf(\"%lld\\n\", Mat[i][N]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nll a[MAXN][MAXN];\nunordered_set<ll> vis;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\tint cur=0;\n\tfor(int i=1;i<=n;i+=2)\n\t\tfor(int j=1;j<=n;j+=2)\n\t\t{\n\t\t\ta[i][j]=++cur;\n\t\t\tvis.insert(cur);\n\t\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\tif(i&1)continue;\n\t\tfor(int j=n;j;--j)\n\t\t{\n\t\t\tif(j&1)continue;\n\t\t\ta[i][j]=++cur;\n\t\t\tvis.insert(cur);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i^j)&1))continue;\n\t\t\tll p=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\tp*=a[x][y];\n\t\t\t}\n\t\t\tll q=p;\n\t\t\twhile(vis.count(q))q+=p;\n\t\t\ta[i][j]=q;\n\t\t\tvis.insert(q);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = (i + j) / 2 + 1;\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<cctype> \n#include<cstring> \n#include<algorithm> \n#define gc getchar() \n#define pc putchar\n#define LL long long\ninline int read() { \n    int x = 0,f = 1; \n    char c = getchar(); \n    while(c < '0' || c > '9') c = gc; \n    while(c <= '9' && c >= '0') x = x * 10 + c - '0',c = getchar(); \n    return x * f; \n}\nvoid print(LL x) { \n    if(x < 0) { \n        pc('-'); \n        x = -x; \n    } \n    if(x >= 10) print(x / 10); \n    pc(x % 10 + '0'); \n} \nconst int maxn = 20007; \nint n; \nint prime[maxn]; \nbool vis[maxn]; \nvoid pre(int lim = 10000) {  \n    for(int cnt = 0,i = 2;i <= lim;++ i) { \n        if(!vis[i]) prime[++ cnt] = i; \n        for(int j = 1;j <= cnt && prime[j] * i <= lim;++ j) { \n            vis[i * prime[j]] = 1; \n            if(i % prime[j] == 0) break; \n        } \n    } \n} \nLL a[507][507]; \nLL gcd(LL x,LL y) { \n    return y == 0 ? x : gcd(y,x % y); \n} \nLL lcm(LL x,LL y) {\n    return x / gcd(x,y) * y; \n} \nint main() { \n    n = read(); \n    pre(); \n    if(n == 2) {\n        pc('4');pc(' ');pc('7');pc('\\n'); \n        print(23);pc(' '); print(10); pc('\\n'); \n        return 0;  \n    } \n    for(int i = 0;i <= n + 1;++ i) \n        for(int j = 0;j <= n + 1;++ j) \n                a[i][j] = 1; \n    for(int i = 1;i <= n;++ i) \n        for(int j = 1;j <= n;++ j) { \n            if((j & 1) == (i & 1)) { \n                a[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n];  \n                a[i + 1][j] = lcm(a[i + 1][j],a[i][j]); \n                a[i - 1][j] = lcm(a[i - 1][j],a[i][j]); \n                a[i][j + 1] = lcm(a[i][j + 1],a[i][j]); \n                a[i][j - 1] = lcm(a[i][j - 1],a[i][j]); \n            } \n        } \n    for(int i = 1;i <= n;++ i) \n        for(int j = 1;j <= n;++ j) \n            if((i & 1) == (j & 1)); \n            else a[i][j] ++; \n    for(int i = 1;i <= n;++ i,pc('\\n')) \n        for(int j = 1;j <= n;++ j) \n            print(a[i][j]),pc(' '); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    //int_fast64_t mn, mx;\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n        //size_t j(i & 1 ? i / 2 : 999 - i / 2);\n        //return j < 250 ? j : j >= 750 ? j : 999 - j;\n    }\n    constexpr Ans() : ans()/*, mn(numeric_limits<int_fast64_t>::max()), mx(0)*/{\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                //mn = min(mn, ans[i][j]);\n                //mx = max(mx, ans[i][j]);\n                if(i < 500 && j < 500){\n                    ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n                    //mn = min(mn, ans[i + 1][j + 1]);\n                    //mx = max(mx, ans[i + 1][j + 1]);\n                }\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE=1<<17, INT_LEN=24, FLT_LEN=400;\n    static constexpr char FLT_FMT[]=\"%.16f\";\n    static char buf[BUF_SIZE|1]={}, *pos=buf, *endbuf=pos+BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos-buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len=std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len=std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template <class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    inline void print(const double out) {\n        char minibuf[FLT_LEN];\n        size_t len=std::snprintf(minibuf, FLT_LEN, FLT_FMT, out);\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minibuf, len);\n        pos += len;\n    }\n\n    inline void print(const bool out) {\n        print(out? \"true\":\"false\");\n    }\n\n    template <class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos=minibuf+INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void)(print(\"128\"));\n                    case 2:\n                        return (void)(print(\"32768\"));\n                    case 3:\n                        return (void)(print(\"8388608\"));\n                    case 4:\n                        return (void)(print(\"2147483648\"));\n                    case 8:\n                        return (void)(print(\"9223372036854775808\"));\n                    case 16:\n                        return (void)(print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_=out;\n        do {\n            *--minipos = '0' + out_%10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len=(minibuf+INT_LEN)-minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout=stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template <class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template <class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template <class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 633;\nint n,w=150000,s[N],len;ll a[633][633];\nmap<ll,bool>used;\nll gcd(ll a, ll b){return !b?a:gcd(b,a%b);}\nll lcm(ll a, ll b){return min(a,b)==0?max(a,b):a/gcd(a,b)*b;}\nbool isprime(int x){\n\trep(i,2,x-1)if(x%i==0)return 0;return 1;\n}\nint main() {\n\tread(n);int dfn=0;\n\tfor(int i=2;len<n;i++)if(isprime(i))s[++len]=i;\n\trep(i,1,n)rep(j,1,n)if((i+j)&1){//(1,i)\n\t\tif(i-1>=1&&j+1<=n)continue;dfn++;\n\t\tll v=0;int x=i,y=j;\n\t\twhile(x<=n&&y>=1){\n\t\t\tv+=s[dfn];while(used[v])v+=s[dfn];used[v]=1;a[x][y]=v;x++;y--;\n\t\t//\tassert(v<=3e7);\n\t\t}\n\t}\n\trep(i,0,n)a[0][i]=a[i][0]=a[i][n+1]=a[n+1][i]=0;\n\trep(i,1,n)rep(j,1,n)if((i+j)%2==0){\n\t//\tprintf(\"%d %d %lld %lld\\n\",a[i][j-1],a[i][j+1],gcd(a[i][j-1],a[i][j+1]),lcm(a[i][j-1],a[i][j+1]));\n\t\tll val=lcm(lcm(a[i][j-1],a[i][j+1]),lcm(a[i-1][j],a[i+1][j]));if(val==0)val=R();\n\t//\tprintf(\"val = %lld %d %d %d %d (%d,%d)\\n\",val,a[i][j-1],a[i][j+1],a[i-1][j],a[i+1][j],i,j);\n\t\tll v=val;while(used[v])v+=val;used[v]=1;a[i][j]=v+1;\n\t//\tif(v>1e15)printf(\"%lld %lld\\n\",val,v);\n\t//\tassert(v<=1e15);\n\t}\n\trep(i,1,n){rep(j,1,n)printf(\"%lld \",a[i][j]);puts(\"\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tfor(ll i=0;i<=n+1;i++)for(ll j=0;j<=n+1;j++)a[i][j]=1;\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=1;st<=n;st+=2){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=2){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\tfor(ll j=1;j<=n;j++)\n\tif((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i < 499 ? 997 - 2 * i : 2 * i - 996;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 1;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool prime[1000005];\nll ans[501][501];\nvector<ll> vec;\n\nll gcd(ll a,ll b){\n\tif(b==0LL)return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\tll g=gcd(a,b);\n\ta/=g;\n\treturn a*b;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tmemset(prime,true,sizeof(prime));\n\tfor(ll i=2;i<1000005;i++){\n\t\tif(prime[i]){\n\t\t\tvec.push_back(i);\n\t\t\tif(vec.size()>=n*2)break;\n\t\t\tfor(ll j=2LL*i;j<1000005;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tdeque<ll> x,y;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(i%4==0){\n\t\t\tx.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==1){\n\t\t\ty.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==2){\n\t\t\tx.push_back(vec[i]);\n\t\t}\n\t\tif(i%4==3){\n\t\t\ty.push_back(vec[i]);\n\t\t}\n\t}\n\t//printf(\"%d %d\\n\",(int)x.size(),(int)y.size());\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==0){\n\t\t\t\t\n\t\t\t\tint diff=(i-j)/2;\n\t\t\t\t//printf(\"%d %d\\n\",(i+j)/2,diff+n/2);\n\t\t\t\tans[i][j]=x[(i+j)/2];\n\t\t\t\tans[i][j]*=y[diff+n/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tans[i][j]=1;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\t\tans[i][j]=lcm(ans[i][j],ans[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tprintf(\"%lld%c\",ans[i][j],j+1==n?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntemplate<typename Elem>\nElem gcd(Elem a,Elem b){\n\tif(b==0){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\ntemplate<typename Elem>\nElem lcm(Elem a,Elem b){\n\tif(a==0||b==0){\n\t\treturn a+b;\n\t}\n\treturn a/gcd(a,b)*b;\n}\ntypedef long long ll;\nconst int Maxn=500;\nconst int Maxv=10000;\nconst int d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nint n;\nll a[Maxn+5][Maxn+5];\nbool np[Maxv+5];\nint p[Maxv+5],p_len;\nvoid init(){\n\tnp[0]=np[1]=1;\n\tfor(int i=2;i<=Maxv;i++){\n\t\tif(!np[i]){\n\t\t\tp[++p_len]=i;\n\t\t\tfor(int j=i*i;j<=Maxv;j+=i){\n\t\t\t\tnp[j]=1;\n\t\t\t}\n\t\t}\n\t}\n}\nint val_1[Maxn<<1|5],val_2[Maxn<<1|5];\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tint id_tot=0;\n\tfor(int i=2;i<=(n<<1);i+=2){\n\t\tval_1[i]=p[++id_tot];\n\t}\n\tint m;\n\tif(n&1){\n\t\tm=n+1;\n\t\tfor(int i=(n<<1);i>0;i-=2){\n\t\t\tval_2[i]=p[++id_tot];\n\t\t}\n\t}\n\telse{\n\t\tm=n;\n\t\tfor(int i=(n<<1)-2;i>0;i-=2){\n\t\t\tval_2[i]=p[++id_tot];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j]=1ll*val_1[i+j]*val_2[j-i+m];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!((i+j)&1)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint nx=i+d[k][0],ny=j+d[k][1];\n\t\t\t\tif(nx<1||ny<1||nx>n||ny>n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ta[i][j]=lcm(a[i][j],a[nx][ny]);\n\t\t\t}\n\t\t\ta[i][j]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nlong long a[550][550], c[550][550];\nusing namespace std;\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0; i <= n+2; i++){for(int j = 0; j <= n+2; j++){a[i][j] = c[i][j] = 1;}}\n    \n    vector<long long> primes;\n    vector<bool> visited(100000, 0);\n    for(int i = 2; i < 10000; i++){\n        if(!visited[i]){\n            primes.push_back(i);\n            for(int j = i; j < 100000; j+= i){\n                visited[j] = 1;\n            }\n        }\n    }\n    int cnt = 0;\n    for(int i = 0 ; i <= n; i+=2){\n        a[0][i] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 0; i <= n; i+=2){\n        a[i][0] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            a[i][j] = a[i-1][j-1];\n        }\n    }\n    \n    for(int i = n+1; i > 0; i-=2){\n        c[0][i] = primes[cnt];\n        cnt++;\n    }\n    for(int i = n+1; i > 0; i-=2){\n        c[i][n+1] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            c[i][j] = c[i-1][j+1];\n            a[i][j] *= c[i][j];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            if((i+j)%2){\n                a[i][j] = a[i][j-1]*a[i][j+1]*a[i-1][j] * a[i+1][j]  + 1;\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nint n;\nbool pr[101010];\nint ps[101010], k;\nlong long ans[500][500];\n\nlong long gcd(long long x, long long y) {\n  while (y != 0) {\n    long long tmp = x;\n    x = y;\n    y = tmp % x;\n  }\n  return x;\n}\n\nlong long lcm(long long x, long long y) {\n  return x / gcd(x, y) * y;\n}\n\nint main() {\n  for (int i = 2; i < 101010; i++) {\n    if (!pr[i]) {\n      ps[k++] = i;\n      for (int j = i * 2; j < 101010; j += i) {\n        pr[j] = true;\n      }\n    }\n  }\n\n  scanf(\"%d\", &n);\n\n  if (n == 2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      ans[i][j] = 1;\n    }\n  }\n\n  int l = 0;\n  for (int i = 0; i < n * 2; i += 2) {\n    for (int j = 0; j <= i; j++) {\n      if (i - j < n && j < n) {\n        ans[i - j][j] *= ps[l];\n      }\n    }\n    l++;\n  }\n  for (int i = 0; i < n; i += 2) {\n    for (int j = 0; i + j < n; j++) {\n      ans[i + j][j] *= ps[l];\n    }\n    l++;\n  }\n  for (int j = 2; j < n; j += 2) {\n    for (int i = 0; i + j < n; i++) {\n      ans[i][i + j] *= ps[l];\n    }\n    l++;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) {\n        if (i - 1 >= 0) ans[i][j] = lcm(ans[i][j], ans[i - 1][j]);\n        if (i + 1 < n) ans[i][j] = lcm(ans[i][j], ans[i + 1][j]);\n        if (j - 1 >= 0) ans[i][j] = lcm(ans[i][j], ans[i][j - 1]);\n        if (j + 1 < n) ans[i][j] = lcm(ans[i][j], ans[i][j + 1]);\n        ans[i][j]++;\n      }\n      printf(\"%lld \", ans[i][j]);\n    }\n    putchar('\\n');\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<random>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll gcd(ll a, ll b) {\t\t// ユークリッドの互除法\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll N;\nvector<vector<ll>> ans;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>N;\n\tans.resize(N,vector<ll>(N));\n\tvector<bool> used(10000000,false);\n\tvector<ll> tmp;\n\tfor(ll i=1;i<=10000000;i++) {\n\t\tif(!used[i]) {\n\t\t\tfor(ll j=i;j<=10000000; j*=2) {\n\t\t\t\tif(used[j]) break;\n\t\t\t\tused[j]=true;\n\t\t\t\ttmp.pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tll pos=0;\n\tREP(i,N) REP(j,N) {\n\t\tif((i+j)%2==0) {\n\t\t\tans[i][j]=tmp[pos];\n\t\t\tpos++;\n\t\t}\n\t}\n\tREP(i,N) REP(j,N) {\n\t\tif((i+j)%2==1) {\n\t\t\tvector<ll> maw;\n\t\t\tif(i>0) maw.pb(ans[i-1][j]);\n\t\t\tif(i<N-1) maw.pb(ans[i+1][j]);\n\t\t\tif(j>0) maw.pb(ans[i][j-1]);\n\t\t\tif(j<N-1) maw.pb(ans[i][j+1]);\n\t\t\tll g=maw[0];\n\t\t\tFOR(k,1,maw.size()) g=gcd(g,maw[k]);\n\t\t\tll hoge=g;\n\t\t\tREP(k,maw.size()) hoge*=maw[k]/g;\n\t\t\tans[i][j]=maw;\n\t\t}\n\t}\n\tREP(i,N) DUMP(ans[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nlong long a[500][500];\n\nlong long gcd(long long x, long long y) {\n    if (x % y == 0) {\n        return y;\n    } else {\n        return gcd(y, x % y);\n    }\n}\n\nlong long lcm(long long x, long long y) {\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    int n, i, j, k;\n    vector <long long> v;\n    set <long long> s;\n    \n    for (i = 2; v.size() < 1000; i++) {\n        for (j = 2; j * j <= i; j++) {\n            if (i % j == 0) break;\n        }\n        \n        if (j * j > i) v.push_back(i);\n    }\n    \n    for (i = 0; i < 500; i++) {\n        for (j = 0; j < 500; j++) {\n            if ((i + j) % 2 == 1) continue;\n            \n            a[i][j] = v[(i + j) / 2] * v[(i - j) / 2 + 750];\n        }\n    }\n    \n    for (i = 0; i < 500; i++) {\n        for (j = 0; j < 500; j++) {\n            long long l = 1;\n            \n            if ((i + j) % 2 == 0) continue;\n            \n            for (k = 0; k < 4; k++) {\n                int x = i + dx[k];\n                int y = j + dy[k];\n                \n                if (x < 0 || x >= 500 || y < 0 || y >= 500) continue;\n                \n                l = lcm(l, a[x][y]);\n            }\n            \n            for (k = 1; ; k++) {\n                if (!s.count(l * k + 1)) break;\n            }\n            \n            s.insert(l * k + 1);\n            a[i][j] = l * k + 1;\n        }\n    }\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            printf(\"%lld \", a[i][j]);\n        }\n        puts(\"\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) v.begin(), v.end()\n#define MOD 1000000007\n#define MAX 510000\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n//cout << fixed << setprecision(10);//\n//最小公倍数//\nll gcd(ll x, ll y) {\n\tif (x == 0) return y;\n\treturn gcd(y%x, x);\n}\nll lcm(ll x, ll y) { return x * y / gcd(x, y); }\n\n//逆元mod(mを法とするaの逆元)//\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//Cmonp//\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nll COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n////////////////////////////////////////////////////////////////////\n\nll l2(ll m){\n\tll k=0;\nif(m>=2){\nm/=2;\nk++;\n}\nelse{\n\treturn k;\n}\n\n}\n\n\nint main() {\nll n;\ncin>>n;\nll a[501][501];\n\n\nfor(int i=0;i<=500;i++){\n\tfor(int j=0;j<=500;j++){\n\t\ta[i][j]=0;\n\t}\n}\n\nll pow2[50];\npow2[0]=1;\nfor(int i=1;i<=49;i++){\npow2[i]=pow2[i-1]*2;\n}\n\nll m;\nll r;\n\nm=1000000000000;\nr=1;\n\n\n\nfor(int i=1;i<=500;i++){\n\t\nif(i==1){\n\ta[i][1]=m;\n\tcontinue;\n}\nfor(int j=1;j<=49;j++){\n\tif(i==pow2[j]){\n\t\tif(j==1){\n\t\t\ta[i][1]=2*m+r;\n\t\t}\n\t\telse{\n\t\ta[i][1]=pow2[j]*m+pow(2,j*2-2)*r+r;}\n\n\t\tbreak;\n\t\t}\n\t\t\n}\n\nif(a[i][1]==0)\na[i][1]=a[i-1][1]+r;\n\n\n\n\n\t}\n\nfor(int i=1;i<=500;i++){\n\tfor(int j=2;j<=500;j++){\na[i][j]=a[i][j-1]+pow(2,l2(i))*r;\n\n\t}\n}\n\nfor(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t\tif(j<=n-1){\n\t\tcout<<a[i][j]<<\" \";}\n\t\telse{\n\t\t\tcout<<a[i][j]<<endl;}\n\t\t\n\t}\n\t\n}\n\nreturn 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n < MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\nll a[1005][1005];\nint n;\nint pri[10005],tot;\nbool mk[10005];\nll lcm(ll a,ll b) {\n\tif((!a)||(!b)) return a+b;\n\treturn 1ll*a/__gcd(a,b)*b;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tif(n==2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t}\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=10000;i++) {\n\t\tif(!mk[i]) { pri[++tot]=i; }\n\t\tif(tot==1000) break;\n\t\tfor(int j=1;j<=tot&&1ll*pri[j]*i<=10000;j++) {\n\t\t\tint k = pri[j] * i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==0) a[i][j] = pri[(i + j) / 2] * pri[n+((i-j)/2+(n+1)/2)];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==1) a[i][j] = lcm( lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]) ) + 1;\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\n#define int long long\n\nint gcd(int x, int y) {\n\treturn (!y) ? x : gcd(y, x % y);\n}\n\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint n, A[N][N], pr[N], cnt;\nbitset <100005> isp;\n\nvoid prework(int tot) {\n\tfor(int i = 1; i < 100005; ++ i) isp[i] = 1;\n\tisp[1] = 0;\n\tfor(int i = 1; cnt < tot; ++ i) {\n\t\tif(isp[i]) pr[++ cnt] = i;\n\t\tfor(int j = 1; j <= cnt && pr[j] * i <= 100000; ++ j) {\n\t\t\tisp[i * pr[j]] = 0;\n\t\t\tif(i % pr[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain() {\n\tisp = 0;\n\tcin >> n;\n\tn += 2;\n\tprework(n * 2 + 2);\n\t//for(int i =1; i <= cnt; ++ i) cerr << pr[i] << \" \";\n\t//puts(\"\");\n\tfor(int i = 0; i <= n + 1; ++ i) {\n\t\tfor(int j = 0; j <= n + 1; ++ j) {\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i = 1; i <= n; i += 2) {\n\t\tint nx = i, ny = 1;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 3; i <= n; i += 2) {\n\t\tint nx = 1, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n; i >= 1; i -= 2) {\n\t\tint nx = n, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n - ((n & 1) ^ 1); i >= 1; i -= 2) {\n\t\tint nx = i, ny = 1;\n\t\tif(i == n) continue;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\t//cerr << i <<\" \" << j << endl;\n\t\t\t\t//cerr << A[i][j - 1] <<\" \" << A[i - 1][j] <<\" \" << A[i + 1][j] <<\" \" << A[i][j + 1] << endl;\n\t\t\t\tA[i][j] = lcm(lcm(A[i][j - 1], A[i - 1][j]), lcm(A[i + 1][j], A[i][j + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2; i <= n - 1; ++ i) {\n\t\tfor(int j = 2; j <= n - 1; ++ j) {\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t\tassert(max(A[i][j], A[i - 1][j]) % min(A[i][j], A[i - 1][j]) == 0);\n\t\t\tassert(max(A[i][j], A[i][j - 1]) % min(A[i][j], A[i][j - 1]) == 0);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nll a[MAXN][MAXN];\nunordered_set<ll> vis;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\tint cur=1;\n\tvis.insert(1);\n\tfor(int i=1;i<=n;i+=2)\n\t\tfor(int j=1;j<=n;j+=2)\n\t\t{\n\t\t\ta[i][j]=++cur;\n\t\t\tvis.insert(cur);\n\t\t}\n\tfor(int i=n;i;--i)\n\t{\n\t\tif(i&1)continue;\n\t\tfor(int j=n;j;--j)\n\t\t{\n\t\t\tif(j&1)continue;\n\t\t\ta[i][j]=++cur;\n\t\t\tvis.insert(cur);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i^j)&1))continue;\n\t\t\tll p=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\tp*=a[x][y];\n\t\t\t}\n\t\t\tll q=p+1;\n\t\t\twhile(vis.count(q))q+=p;\n\t\t\ta[i][j]=q;\n\t\t\tvis.insert(q);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 505;\nconst int MP = 10005;\n\nint n, pnum;\nll x[MX][MX], prm[MP];\nbool vis[MP];\n\nll lcm(ll x, ll y)\n{\n\treturn x*y/__gcd(x, y);\n}\n\nvoid sieve()\n{\n\tfor(int i=2; i<MP; i++)\n\t{\n\t\tif(!vis[i]) prm[++pnum] = i;\n\t\tfor(int j=1; j<=pnum; j++)\n\t\t{\n\t\t\tif(prm[j]*i >= MP) break;\n\t\t\tvis[prm[j]*i] = 1;\n\t\t\tif(i%prm[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsieve();\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<=n+1; i++) x[i][0] = x[i][n+1] = x[0][i] = x[n+1][i] = 1;\n\tint t = 0;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif((i&1) ^ (j&1))\n\t\t\t\tx[i][j] = prm[i] * prm[n+j];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(!x[i][j])\n\t\t\t\tx[i][j] = x[i-1][j] * x[i+1][j] + 1;\n\tll mxv = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tprintf(\"%lld \", x[i][j]), mxv = max(mxv, x[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=505;\nint n;\nvector <int> vp;\nLL g[N][N];\nLL gcd(LL x,LL y){\n\treturn y?gcd(y,x%y):x;\n}\nLL lcm(LL x,LL y){\n\tif (!x||!y)\n\t\treturn x+y;\n\treturn x/gcd(x,y)*y;\n}\nint check(int n){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nmap <int,int> mp1,mp2;\nint g1(int x){\n\tif (!mp1[x])\n\t\tmp1[x]=vp.back(),vp.pop_back();\n\treturn mp1[x];\n}\nint g2(int x){\n\tif (!mp2[x])\n\t\tmp2[x]=vp.back(),vp.pop_back();\n\treturn mp2[x];\n}\nint main(){\n\tn=read();\n\tif (n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;vp.size()<n*2;i++)\n\t\tif (check(i))\n\t\t\tvp.push_back(i);\n\treverse(vp.begin(),vp.end());\n\tmp1.clear(),mp2.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]=g1(i+j)*g2(i-j);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1){\n\t\t\t\tg[i][j]=lcm(g[i-1][j],lcm(g[i+1][j],lcm(g[i][j-1],g[i][j+1])))+1;\n\t\t\t\tassert(g[i][j]<=1000000000000000LL);\n\t\t\t}\n\tfor (int i=1;i<=n;i++,puts(\"\"))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",g[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long N, A[509][509], B1[509], B2[509], cnt;\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) B1[i] = i;\n\tfor (int i = N + 1; i <= 200000; i++) {\n\t\tbool prime = true;\n\t\tfor (int j = 2; j*j <= i; j++) {\n\t\t\tif (i%j == 0) prime = false;\n\t\t}\n\t\tif (prime == true) { cnt++; B2[cnt] = i; }\n\t\tif (cnt == N) break;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif ((i + j) % 2 == 1) continue;\n\t\t\tA[i][j] = B1[i] * B2[j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (A[i][j] >= 1) continue;\n\t\t\tlong long ret = 1; int dx[4] = { 0,-1,0,1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint fx = i + dx[k], fy = j + dy[k];\n\t\t\t\tif (fx <= 0 || fy <= 0 || fx > N || fy > N) continue;\n\t\t\t\tret = ret / gcd(ret, A[fx][fy])*A[fx][fy];\n\t\t\t}\n\t\t\tA[i][j] = ret + 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (j >= 2) cout << \" \"; \n\t\t\tcout << A[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=505,DIR[4][2]={1,0,0,1,0,-1,-1,0};\n\nint n;\nbool notp[MAXN*MAXN];\nint prm[MAXN*MAXN],pn;\nvoid euler(int n)\n{\n\tnotp[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tif(!notp[i])prm[++pn]=i;\n\t\tfor(int j=1;j<=pn && i*prm[j]<=n;++j)\n\t\t{\n\t\t\tnotp[i*prm[j]]=1;\n\t\t\tif(!(i%prm[j]))break;\n\t\t}\n\t}\n}\nll a[MAXN][MAXN];\ninline ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nunordered_set<ll> s;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n//\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);\n\teuler(n*500);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!((i+j)&1))\n\t\t\t{\n\t\t\t\ta[i][j]=prm[(i+j)/2]*prm[(i-j+n+1)/2+n];\n\t\t\t\ts.insert(a[i][j]);\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))continue;\n\t\t\ta[i][j]=1;\n\t\t\tfor(int t=0;t<4;++t)\n\t\t\t{\n\t\t\t\tint x=i+DIR[t][0],y=j+DIR[t][1];\n\t\t\t\tif(!x || !y || x>n || y>n)continue;\n\t\t\t\ta[i][j]=lcm(a[i][j],a[x][y]);\n\t\t\t}\n\t\t\tll x=a[i][j];\n\t\t\t++a[i][j];\n\t\t\twhile(s.count(a[i][j]))a[i][j]+=x;\n\t\t\ts.insert(a[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) v.begin(), v.end()\n#define MOD 1000000007\n#define MAX 510000\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n//cout << fixed << setprecision(10);//\n//最小公倍数//\nll gcd(ll x, ll y) {\n\tif (x == 0) return y;\n\treturn gcd(y%x, x);\n}\nll lcm(ll x, ll y) { return x * y / gcd(x, y); }\n\n//逆元mod(mを法とするaの逆元)//\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//Cmonp//\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nll COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n////////////////////////////////////////////////////////////////////\n\nll l2(ll m){\n\tll k=0;\nif(m>=2){\nm/=2;\nk++;\n}\nelse{\n\treturn k;\n}\n\n}\n\n\nint main() {\nll n;\ncin>>n;\nll a[501][501];\n\n\nfor(int i=0;i<=500;i++){\n\tfor(int j=0;j<=500;j++){\n\t\ta[i][j]=0;\n\t}\n}\n\nll pow2[50];\npow2[0]=1;\nfor(int i=1;i<=49;i++){\npow2[i]=pow2[i-1]*2;\n}\n\nll m;\nll r;\n\nm=1000000000000;\nr=1;\n\ncout<<pow2[1]<<endl;\n\nfor(int i=1;i<=500;i++){\n\t\nif(i==1){\n\ta[i][1]=m;\n\tcontinue;\n}\nfor(int j=1;j<=49;j++){\n\tif(i==pow2[j]){\n\t\tif(j==1){\n\t\t\ta[i][1]=2*m+r;\n\t\t}\n\t\telse{\n\t\ta[i][1]=pow2[j]*m+pow(2,j*2-2)*r+r;}\n\n\t\tbreak;\n\t\t}\n\t\t\n}\n\nif(a[i][1]==0)\na[i][1]=a[i-1][1]+r;\n\n\n\n\n\t}\n\nfor(int i=1;i<=500;i++){\n\tfor(int j=2;j<=500;j++){\na[i][j]=a[i][j-1]+pow(2,l2(i))*r;\n\n\t}\n}\n\nfor(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t\tif(j<=n-1){\n\t\tcout<<a[i][j]<<\" \";}\n\t\telse{\n\t\t\tcout<<a[i][j]<<endl;}\n\t\t\n\t}\n\t\n}\n\nreturn 0;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>//\tTはintかll\nT gcd(T a, T b) {//\t最大公約数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tif (a < b) {\n\t\treturn gcd(a, b % a);\n\t}\n\treturn gcd(b, a % b);\n}\ntemplate <typename T>//\tTはintかll\nT gcd(int size, T* a) {//\t配列の最大公約数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tT c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = gcd(c, a[i]);\n\t\tif (c == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate <typename T>//\tTはintかll\nll lcm(T a, T b) {//\t最小公倍数\n\tif (a < 0) { a = -a; }\n\tif (b < 0) { b = -b; }\n\tif (a == 0) { return b; }\n\tif (b == 0) { return a; }\n\tll x = a;\n\tx /= gcd(a, b);\n\tx *= b;\n\treturn x;\n}\ntemplate <typename T>//\tTはintかll\nll lcm(int size, T* a) {//\t配列の最小公倍数\n\tif (size <= 0 || a == NULL) { return 0; }\n\tll c = abs(a[0]);\n\tfor (int i = 1; i < size; i++) {\n\t\tc = lcm(c, (ll)a[i]);\n\t}\n\treturn c;\n}\n\nbool f[20000] = {};\n\nint main() {\n\tf[0] = false;\n\tf[1] = false;\n\tf[2] = true;\n\tfor (int i = 3; i < 20000; i++) {\n\t\tf[i] = (i % 2 == 1);\n\t}\n\tfor (int i = 3; i < 20000; i++) {\n\t\tif (f[i] == false) { continue; }\n\t\tfor (int j = i * 2; j < 20000; j += i) {\n\t\t\tf[j] = false;\n\t\t}\n\t}\n\tvector<ll> v;\n\tfor (int i = 0; i < 20000; i++) {\n\t\tif (f[i] == true) {\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\n\tint N = 500;\n\tll** ans = new ll * [N];\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = new ll[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tans[i][j] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = v[abs(1000 - 2 * (i + j))] * v[abs(2 * (i - j) + 1)];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tll c = 1;\n\t\t\t\tif (i > 0) { c = lcm(c, ans[i - 1][j]); }\n\t\t\t\tif (j > 0) { c = lcm(c, ans[i][j - 1]); }\n\t\t\t\tif (i < N - 1) { c = lcm(c, ans[i + 1][j]); }\n\t\t\t\tif (j < N - 1) { c = lcm(c, ans[i][j + 1]); }\n\n\t\t\t\tans[i][j] += c;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define MOD 1000000007\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\ntypedef unsigned long long int ull;\ntypedef long long lint;\n\nlint LCM(lint a,lint b){\n  if(a==0 || b==0) return 0;\n  lint tmp,r,x;\n  x=a*b;\n  if(a<b) tmp=a,a=b,b=tmp;\n  r=a%b;\n  while(r!=0) a=b,b=r,r=a%b;\n  x=x/b;\n  return x;\n}\n\nlint GCD(lint a,lint b){\n  if(a==0 || b==0) return max(a,b);\n  else return (a*b)/LCM(a,b);\n}\n\nvector<bool> prime;\nvoid primeinit(int N){\n    if(N+1>prime.size()){\n        prime.resize(N+1,true);\n    } \n    prime[0] = false;\n    prime[1] = false;\n    for(int i=2; i*i<=N;i++) if(prime[i]) for(int j=2; i*j<=N;j++) prime[i*j]=false;\n}\n\n\nint main(void){\n    primeinit(1000000);\n    int N;\n    cin >> N;\n    lint primeno[1000];\n    lint ans[N][N];\n    rep(i,N) rep(j,N) ans[i][j]=1;\n    lint now=0;\n    rep(i,1000){\n        while(!prime[now]) now++;\n        primeno[i]=now;\n        now++;\n    }\n    int no=0;\n    for(int i=0;i<N;i+=2){\n        int x=i,y=0;\n        while(x<N && y<N){\n            ans[x][y]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n        x=i,y=0;\n        while(x>=0 && y<N){\n            ans[x][y]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    for(int i=2;i<N;i++){\n        int x=0,y=i;\n        while(x<N && y<N){\n            ans[x][y]*=primeno[no];\n            x++,y++;\n        }\n        no++;\n        x=0,y=i;\n        while(x>=0 && y<N){\n            ans[x][y]*=primeno[no];\n            x--,y++;\n        }\n        no++;\n    }\n    rep(i,N) rep(j,N){\n        if(ans[i][j]==1){\n            lint in=1;\n            if(i!=0) in=LCM(in,ans[i-1][j]);\n            if(i!=N-1) in=LCM(in,ans[i+1][j]);\n            if(j!=0) in=LCM(in,ans[i][j-1]);\n            if(j!=N-1) in=LCM(in,ans[i][j+1]);\n            ans[i][j]=in+1;\n        }\n    }\n    rep(i,N){\n        rep(j,N) cout << ans[i][j] << \" \";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <cstdio>\n# include <iostream>\n# define R register int\n# define ll long long\n\nusing namespace std;\n\nconst int N=1003;\nint n,h,vis[10004],pri[10004];\nll a[N][N];\n\nvoid pre()\n{\n    for (R i=2;i<=10000;++i)\n    {\n        if(!vis[i]) pri[++h]=i;\n        for (R j=1;j<=h&&i*pri[j]<=10000;++j)\n        {\n            vis[ i*pri[j] ]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\n\nll gcd (ll a,ll b)\n{\n    return b?gcd(b,a%b):a;\n}\n\nll lcm (ll a,ll b)\n{\n    if(!a||!b) return a+b;\n    return a/gcd(a,b)*b;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    if(n==2)\n    {\n        puts(\"2 5\");\n        puts(\"9 4\");\n        return 0;\n    }\n    pre();\n    for (R i=1;i<=n;++i)\n        for (R j=(i&1)?1:2;j<=n;j+=2)\n            a[i][j]=pri[ (i+j)/2 ]*pri[ (j-i)/2+n/2+n+1 ];\n    for (R i=1;i<=n;++i)\n        for (R j=1;j<=n;++j)\n        {\n            if(a[i][j]) continue;\n            a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n        }\n    for (R i=1;i<=n;++i)\n    {\n        for (R j=1;j<=n;++j)\n            printf(\"%lld \",a[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    vi primes;\n\n    const int MAXV = 10000;\n    vi sieve(MAXV);\n    for (int p = 2; p < MAXV; p++) {\n        if (sieve[p]) continue;\n        primes.push_back(p);\n        for (int q = p; q < MAXV; q += p) {\n            sieve[q] = p;\n        }\n    }\n\n    int tail = 0;\n    map<int, ll> sdiag, ddiag;;\n    auto get = [&primes, &tail](map<int, ll>& m, int i) {\n        if (m.count(i)) return m[i];\n        return m[i] = primes[tail++];\n    };\n\n    auto lcm = [](ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    };\n\n    int N;\n    cin >> N;\n\n    for (int s = 0; s < 2 * N; s += 2)\n        get(sdiag, s);\n    for (int d = -N+1; d < N; d++) {\n        if (d % 2 == 0)\n            get(ddiag, d);\n    }\n\n    vvll res(N, vll(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i+j)&1) continue;\n            res[i][j] = get(sdiag, i+j) * get(ddiag, i-j);\n        }\n    }\n\n    int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (((i+j)&1) == 0) continue;\n            res[i][j] = 1;\n\n            for (int d = 0; d < 4; d++) {\n                int dx = dir[d][0], dy = dir[d][1];\n                res[i][j] = lcm(res[i][j], get(sdiag, i+j+dx+dy) * get(ddiag, i-j+dx-dy));\n            }\n            res[i][j]++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << res[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, cnt = 2;\nlong long res[507][507];\nmap<int, int>a, b;\nint nxt()\n{\n\twhile (1)\n\t{\n\t\tbool ok = 1;\n\t\tfor (int i = 2; i * i <= cnt && ok; i++)\n\t\t\tif (cnt % i == 0)ok = 0;\n\t\tif (ok)return cnt++;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\nlong long gcd(long long a, long long b)\n{\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nlong long lcm(long long a, long long b)\n{\n\tif (!a || !b)return 0;\n\treturn a / gcd(a, b) * b;\n}\nint main()\n{\n\tcin >> n;\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (((i + j) & 1) && !a[i + j])\n\t\t\t\ta[i + j] = nxt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (((i + j) & 1) && !b[i - j])\n\t\t\t\tb[i - j] = nxt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tres[i][j] = 1LL * a[i + j] * b[i - j];\n\t\t\t\tres[i - 1][j] = lcm(res[i - 1][j], res[i][j]);\n\t\t\t\tres[i][j - 1] = lcm(res[i][j - 1], res[i][j]);\n\t\t\t\tres[i + 1][j] = lcm(res[i + 1][j], res[i][j]);\n\t\t\t\tres[i][j + 1] = lcm(res[i][j + 1], res[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tres[i][j]++;\n\tfor (int i = 1; i <= n; i++, putchar('\\n'))\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tprintf(\"%lld \", res[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nint n;\nll a[505][505];\nstd::set<ll> s;\n\ninline bool chk(int x) {\n    for(int i = 2; (ll)i*i <= x; ++i) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    vector<int> v;\n    for(int i = 2; ; ++i) {\n        if(chk(i)) { v.pb(i); }\n        if(v.size() == 1002) break;\n    }\n\n    read(n);\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)%2==0) {\n                a[i][j] = 1ll * v[(i+j)/2] * v[(i-j)/2+750];\n                s.insert(a[i][j]);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)&1) {\n                ll lcm = 1;\n                if(i>1) lcm = a[i-1][j] / std::__gcd(lcm, a[i-1][j]) * lcm;\n                if(i<n) lcm = a[i+1][j] / std::__gcd(lcm, a[i+1][j]) * lcm;\n                if(j>1) lcm = a[i][j-1] / std::__gcd(lcm, a[i][j-1]) * lcm;\n                if(j<n) lcm = a[i][j+1] / std::__gcd(lcm, a[i][j+1]) * lcm;\n\n                a[i][j] = lcm + 1;\n                s.insert(a[i][j]);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            printf(\"%lld \", a[i][j]);\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nvector<int> makePrimes(int n) { // [2,n]\n    vector<int> res, pr(n + 1, 1);\n    pr[0] = pr[1] = 0;\n    rep(p, 2, sqrt(n) + 2) if (pr[p]) for (int x = p * 2; x <= n; x += p) pr[x] = 0;\n    rep(p, 2, n + 1) if (pr[p]) res.push_back(p);\n    return res;\n}\nll gcd(ll a, ll b) { return a ? gcd(b%a, a) : b; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N;\nll ans[505][505];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    auto vp = makePrimes(51010);\n    cin >> N;\n\n    rep(y, 0, N) rep(x, 0, N) if ((x + y) % 2 == 0) {\n        int u = x + y;\n        int v = x - y + N;\n\n        ans[y][x] = 1LL * vp[u] * vp[v + 2 * N];\n    }\n\n    rep(y, 0, N) rep(x, 0, N) if ((x + y) % 2 == 1) {\n        ll c = 1;\n        if (0 <= y - 1) c = lcm(c, ans[y - 1][x]);\n        if (y + 1 < N) c = lcm(c, ans[y + 1][x]);\n        if (0 <= x - 1) c = lcm(c, ans[y][x - 1]);\n        if (x + 1 < N) c = lcm(c, ans[y][x + 1]);\n        ans[y][x] = c + 1;\n    }\n\n    rep(y, 0, N) {\n        rep(x, 0, N) {\n            if (x) printf(\" \");\n            printf(\"%lld\", ans[y][x]);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long x,long long y) {\n\tif (x<y) swap(x,y);\n\tif (y == 0) return x;\n\treturn (y,x%y);\n}\n\nlong long a[600][600];\n\nint main() {\n\tint n;;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i&1) {\n\t\t\tfor (int j = 1; j <= n; j++) if (i==1) a[i][j] = 2*j+1;\n\t\t\telse {\n\t\t\t\tif (j == 1) a[i][j] = a[i-1][j]+2;\n\t\t\t\telse {\n\t\t\t\t\tlong long g = gcd(a[i-1][j],a[i][j-1]);\n\t\t\t\t\ta[i][j] = a[i-1][j]/g*a[i][j-1]+2;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = n; j > 0; j--) \n\t\t\t\tif (j == n) a[i][j] = a[i-1][j]+2;\n\t\t\t\telse {\n\t\t\t\t\tlong long g = gcd(a[i-1][j],a[i][j+1]);\n\t\t\t\t\ta[i][j] = a[i-1][j]/g*a[i][j+1]+2;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\n\t}\n\tfor (int i = 1; i<= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) cout << a[i][j] << \" \";\n\t\tcout << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>prime;\nvector<int>prime_;\nbool used[1000005];\nll x[505][505];\nll gcd(ll a,ll b){\n    if(a<b) swap(a,b);\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\nint n;\nint main(){\n\tfor(int i=2;;i++){\n\t\tif(!used[i] && i > 1001){\n\t\t    prime.pb(i);\n\t\t    if(prime.size() == 1000) break;\n\t\t}\n\t\tfor(int j=2;i*j<=100000;j++) used[i*j] = 1;\n\t}\n\tint beg = 2,en = 1001;\n\tfor(int j=0;j<1000;j++){\n\t    if(j%2 == 0) prime_.pb(beg++);\n\t    else prime_.pb(en--);\n\t}\n\tbeg = 0,en = 1000;\n\tfor(int j=0;j<1000;j++){\n\t    if(j%2 == 0) prime_.pb(prime[beg++]);\n\t    else prime_.pb(prime[en--]);\n\t}\n\tprime = prime_;\n\tfor(int i=0;i<500;i++){\n\t\tfor(int j=0;j<500;j++){\n\t\t\tif(i%2 != j%2) continue;\n\t\t\tint f = i-j+499;\n\t\t\tint g = i+j;\n\t\t\tx[i][j] = 1LL * prime[f] * prime[1000+g];\n\t\t}\n\t}\n\tll mxx = -1;\n\tll mnn = 1e18;\n\tset<ll>S;\n\tfor(int i=0;i<500;i++){\n\t\tfor(int j=0;j<500;j++){\n\t\t\tif(i%2 != j%2) continue;\n\t\t\tS.insert(x[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<500;i++){\n\t\tfor(int j=0;j<500;j++){\n\t\t\tif(i%2 == j%2) continue;\n\t\t\tll gcdd = 1;\n\t\t\t\tint dx[4]={0,1,0,-1};\n\t\t\t\tint dy[4]={1,0,-1,0};\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = i+dx[k],ny = j+dy[k];\n\t\t\t\t\tif(0<=nx&&nx<500 && 0<=ny&&ny<500){\n\t\t\t\t\t\tgcdd = gcdd / gcd(gcdd,x[nx][ny]) * x[nx][ny];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx[i][j] = gcdd+1;\n\t\t\t\twhile(S.find(x[i][j]) != S.end()){\n\t\t\t\t    x[i][j] += gcdd;\n\t\t\t\t}\n\t\t\t\tS.insert(x[i][j]);\n\t\t\t\tmxx = max(mxx,x[i][j]);\n\t\t\t\tmnn = min(mnn,x[i][j]);\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++) printf(\"%lld \",x[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nll a[510][510];\n\nvector<int> primes;\n\nll lcm(ll a,ll b){\n\treturn a/__gcd(a,b) * b;\n}\n\nint main(void){\n\tint n = 500;\n\n\trep(i,n)rep(j,n) a[i][j] = 1LL;\n\n\tfor(int i = 2; primes.size() < 3010 ;++i){\n\t\tbool isprime = true;\n\t\tfor(int j = 2; j*j <=i; ++j){\n\t\t\tif(i % j == 0){\n\t\t\t\tisprime = false;\n\t\t\t}\n\t\t}\n\t\tif(isprime) primes.push_back(i);\n\t}\n\n\tint idx = 0;\n\trep(val,2*n+1){\n\t\tif(val % 2 == 1) continue;\n\t\trep(i,n){\n\t\t\tconst int j = val - i;\n\t\t\tif((i + j) % 2 == 1) continue;\n\t\t\tif(j < 0 or n <= j) continue;\n\t\t\ta[i][j] *= primes[idx];\n\t\t}\n\t\tidx++;\n\t}\n\n\trep(val,-n,n+1){\n\t\tif(val % 2 == 1) continue;\n\t\trep(i,n){\n\t\t\tconst int j = val + i;\n\t\t\tif((i + j) % 2 == 1) continue;\n\t\t\tif(j < 0 or n <= j) continue;\n\t\t\ta[i][j] *= primes[idx];\n\t\t}\n\t\tidx++;\n\t}\n\n\trep(i,n)rep(j,n){\n\t\tif((i + j) % 2 == 0) continue;\n\t\tll val = 1LL;\n\t\tif(i-1>=0) val = lcm(val,a[i-1][j]);\n\t\tif(j-1>=0) val = lcm(val,a[i][j-1]);\n\t\tif(j+1< n) val = lcm(val,a[i][j+1]);\n\t\tif(i+1< n) val = lcm(val,a[i+1][j]);\n\t\ta[i][j] = val + 1LL;\n\t}\n\n\tcin >> n;\n\trep(i,n){\n\t\trep(j,n) cout << (j?\" \":\"\") << a[i][j];\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > >\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=505,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\ninline int getp(){\n\tstatic int now=500;\n\twhile(1){\n\t\tnow++;\n\t\tbool isok=1;\n\t\tfor(int i=2;i*i<=now;i++)\n\t\t\tif(now%i==0){isok=0;break;}\n\t\tif(isok) return now;\n\t}\n\tassert(0);\n}\n\nint n,b[N];\nll a[N][N];\ninline ll lcm(ll x,ll y){\n\tif(!x||!y) return x|y;\n\treturn x/__gcd(x,y)*y;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d\",&n);\n\tint l=1,r=n;\n\tfor(int i=(n+1)/2,j=1;i;i--,j+=2)\n\t\tb[i]=j;\n\tfor(int i=(n+1)/2+1,j=2;i<=n;i++,j+=2)\n\t\tb[i]=j;\n\tmap<ll,bool> vis;\n\tfor(int i=0;i<=n;i+=2,l++,r--){\n\t\tint p=getp();\n\t\tfor(int x=1,j=l;x<=n;x++){\n\t\t\tint y=x+i;\n\t\t\tif(y<1||y>n) continue;\n\t\t\ta[x][y]=p*b[j];j++;\n\t\t\tvis[a[x][y]]=1;\n\t\t}\n\t\tif(!i) continue;\n\t\tp=getp();\n\t\tfor(int x=1,j=l;x<=n;x++){\n\t\t\tint y=x-i;\n\t\t\tif(y<1||y>n) continue;\n\t\t\ta[x][y]=p*b[j];j++;\n\t\t\tvis[a[x][y]]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!a[i][j]){\n\t\t\t\tll k=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])));\n\t\t\t\ta[i][j]=k+1;\n\t\t\t\twhile(vis[a[i][j]]) a[i][j]+=k;\n\t\t\t\tvis[a[i][j]]=1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<n;j++)\n\t\t\tassert(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1])==1);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tassert(max(a[i+1][j],a[i][j])%min(a[i+1][j],a[i][j])==1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 200005\n#define mo 994711\n//#define ivorysi\nusing namespace std;\ntypedef unsigned long long int64;\ntypedef long double db;\ntypedef unsigned int u32;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 + c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nint N;\nint64 a[505][505];\nbool nonprime[50005];\nint prime[50005],tot;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nmap<int64,pii > mmm;\nint64 gcd(int64 a,int64 b) {\n    return b == 0 ? a : gcd(b,a % b);\n}\nint64 Calc(int x,int y) {\n    int64 res = 1;\n    for(int k = 0 ; k <= 3 ; ++k) {\n\tint tx = x + dx[k],ty = y + dy[k];\n\tif(tx < 1 || tx > N || ty < 1 || ty > N) continue;\n\tres = res / gcd(res,a[tx][ty]) * a[tx][ty];\n    }\n    return res + 1;\n}\nvoid Solve() {\n    read(N);\n    if(N == 2) {\n\tputs(\"4 7\");\n\tputs(\"23 10\");\n\treturn;\n    }\n    for(int i = 2 ; i <= 50000 ; ++i) {\n\tif(!nonprime[i]) {\n\t    prime[++tot] = i; \n\t}\n\tfor(int j = 1 ; j <= tot ; ++j) {\n\t    if(prime[j] > 50000 / i) break;\n\t    nonprime[i * prime[j]] = 1;\n\t    if(i % prime[j] == 0) break;\n\t}\n    }\n    int st = 1;\n    for(int s = 2 ; s <= N + N ; s += 2) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = s - i;\n\t    if(j < 1 || j > N) continue;\n\t    a[i][j] = prime[st];\n\t}\n\t++st;\n    }\n    int k = N & 1 ? 1 - N : 2 - N;\n    for(int s = k ; s <= N ; s += 2) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = i - s;\n\t    if(j < 1 || j > N) continue;\n\t    a[i][j] = a[i][j] * prime[st];\n\t}\n\t++st;\n    } \n    for(int s = 3 ; s <= N + N ; s += 2) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = s - i;\n\t    if(j < 1 || j > N) continue;\n\t    if(i == 409 && j == 101) {\n\t\tputs(\"QAQ\");\n\t    }\n\t    a[i][j] = Calc(i,j);\n\t    \n\t}\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tfor(int j = 1 ; j <= N ; ++j) {\n\t    out(a[i][j]);\n\t    j == N ? 0 : space;\n\t}\n\tenter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\n#define int long long\n\nint gcd(int x, int y) {\n\treturn (!y) ? x : gcd(y, x % y);\n}\n\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint n, A[N][N], pr[N], cnt;\nbitset <100005> isp;\n\nvoid prework(int tot) {\n\tfor(int i = 1; i < 100005; ++ i) isp[i] = 1;\n\tisp[1] = 0;\n\tfor(int i = 1; cnt < tot; ++ i) {\n\t\tif(isp[i]) pr[++ cnt] = i;\n\t\tfor(int j = 1; j <= cnt && pr[j] * i <= 100000; ++ j) {\n\t\t\tisp[i * pr[j]] = 0;\n\t\t\tif(i % pr[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain() {\n\tisp = 0;\n\tcin >> n;\n\tn += 2;\n\tprework(n * 2 + 2);\n\t//for(int i =1; i <= cnt; ++ i) cerr << pr[i] << \" \";\n\t//puts(\"\");\n\tfor(int i = 0; i <= n + 1; ++ i) {\n\t\tfor(int j = 0; j <= n + 1; ++ j) {\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i = 1; i <= n; i += 2) {\n\t\tint nx = i, ny = 1;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 3; i <= n; i += 2) {\n\t\tint nx = 1, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n; i >= 1; i -= 2) {\n\t\tint nx = n, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n - ((n & 1) ^ 1); i >= 1; i -= 2) {\n\t\tint nx = i, ny = 1;\n\t\tif(i == n) continue;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\t//cerr << i <<\" \" << j << endl;\n\t\t\t\t//cerr << A[i][j - 1] <<\" \" << A[i - 1][j] <<\" \" << A[i + 1][j] <<\" \" << A[i][j + 1] << endl;\n\t\t\t\tA[i][j] = lcm(lcm(A[i][j - 1], A[i - 1][j]), lcm(A[i + 1][j], A[i][j + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2; i <= n - 1; ++ i) {\n\t\tfor(int j = 2; j <= n - 1; ++ j) {\n\t\t\tprintf(\"%lld\", A[i][j]);\n\t\t\tif(j != n - 1) putchar(' ');\n\t\t\tassert(max(A[i][j], A[i - 1][j]) % min(A[i][j], A[i - 1][j]) == 0);\n\t\t\tassert(max(A[i][j], A[i][j - 1]) % min(A[i][j], A[i][j - 1]) == 0);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=5e2+5;\nconst int M=5e5+5;\nint n,cnt,prime[M],vis[M];\nll a[N][N];\n\nll gcd(ll x,ll y) {return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y) {if(!x||!y) return x+y;return 1ll*x/gcd(x,y)*y;}\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nint main() {\n\tIN(n);\n    if(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tfor(int i=2;i<M;++i) {\n\t\tif(!vis[i]) prime[++cnt]=i;\n\t\tfor(int j=1;i*prime[j]<M&&j<=cnt;++j) {\n\t\t\tvis[i*prime[j]]=1;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n    for(int i=1;i<=n;++i)\n        for(int j=(i+1&1)+1;j<=n;j+=2)\n            a[i][j]=prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n        for(int j=(i&1)+1;j<=n;j+=2)\n            a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;++i) {\n        for(int j=1;j<=n;++j) printf(\"%lld \",a[i][j]);\n        puts(\"\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong funcp(long a, long b) {\n\tlong x = max(a, b);\n\tlong y = min(a, b);\n\tif (x%y == 0) return y;\n\treturn funcp(y, x%y);\n}\nlong func(long a, long b) {\n\treturn a * b / funcp(a, b);\n}\n\n\n\nint main() {\n\tint N, amari;\n\tlong a[505];\n\tlong b[505];\n\tcin >> N;\n\tamari = 2;\n\ta[0] = amari + 1;\n\tcout << a[0] << \" \";\n\n\tfor (int i = 1; i < N; ++i) {\n\t\ta[i] = a[i - 1] + amari;\n\t\tcout << a[i] << \" \";\n\t}\n\tcout << endl;\n\n\n\tfor (int j = 1; j < N; ++j) {\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tif (i == 1) {\n\t\t\t\tb[N - 1] = a[N - 1] + amari;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[N - i] = func(a[N - i], b[N - i + 1]) + amari;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcout << b[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\n\n\t\tj++;\n\t\tif (j >= N) break;\n\n\n\t\ta[0] = b[0] + amari;\n\t\tcout << a[0] << \" \";\n\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\ta[i] = func(a[i - 1], b[i]) + amari;\n\t\t\tcout << a[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nint_fast64_t N, ans[502][502];\nvector<size_t> v(800), w(800);\n\nint_fast64_t lcm(int_fast64_t a, int_fast64_t b) {\n    return a / __gcd(a, b) * b;\n}\n\nint_fast64_t lcm(initializer_list<int_fast64_t> a){\n    int_fast64_t ret = 1;\n    for(auto i : a)\n        ret = lcm(ret, i);\n    return ret;\n}\n\nint main(){\n    for(int i = 0; i < 501; ++i){\n        ans[i][0] = 1;\n        ans[501][i] = 1;\n        ans[i + 1][501] = 1;\n        ans[0][i + 1] = 1;\n    }\n    iota(v.begin(), v.end(), 1);\n    iota(w.begin(), w.end(), 1);\n    random_device rdv;\n    mt19937 mt(rdv());\n    shuffle(v.begin(), v.end(), mt);\n    shuffle(w.begin(), w.end(), mt);\n    for(int i = 1; i <= 500; i += 2)\n        for(int j = 1; j <= 500; j += 2){\n            ans[i][j] = p[v[(i + j) / 2]] * p[w[(500 + i - j) / 2]];\n            ans[i + 1][j + 1] = p[v[(i + j + 2) / 2]] * p[w[(500 + i - j) / 2]];\n        }\n    for(int i = 1; i <= 500; i += 2)\n        for(int j = 1; j <= 500; j += 2){\n            ans[i + 1][j] = lcm({ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]}) + 1;\n            ans[i][j + 1] = lcm({ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]}) + 1;\n        }\n    scanf(\"%lld\", &N);\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j)printf(\"%lld \", ans[i + 1][j + 1]);\n        puts(\"\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N;\nbool prime[1000005];\nvector<llint> pvec;\nllint ans[505][505];\nconst llint di[] = {1, 0, -1, 0}, dj[] = {0, -1, 0, 1};\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tfor(int i = 2; i < 1005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j += i) prime[j] = true;\n\t}\n\t/*for(int i = 3; i < 500005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\tvector<llint> vec;\n\tfor(int i = 0; i < pvec.size(); i++){\n\t\tfor(int j = 0; j < 8; j++) vec.push_back(pvec[i] << j);\n\t}\n\tsort(vec.begin(), vec.end());\n\tpvec = vec;*/\n\t\n\tfor(int i = 3; i < 1000005; i+=2) pvec.push_back(i);\n\t\n\tllint pos = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(ans[i][j]) continue;\n\t\t\tllint tmp = 1;\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif(ni > N || nj < 1 || nj > N) continue;\n\t\t\t\tif(ni < 1) tmp *= 2;\n\t\t\t\telse tmp *= ans[ni][nj];\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long \n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint n,pri[maxn],tot,vis[maxn],a[550][550];\n\nvoid gen() {\n    for(int i=2;tot<=n*2;i++) {\n        if(!vis[i]) vis[i]=1,pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=10000;j++) {\n            vis[i*pri[j]]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\n\nint lcm(int a,int b) {return !min(a,b)?max(a,b):a/__gcd(a,b)*b;}\n\nsigned main() {\n    read(n);gen();int p=1;\n    if(n==2) return puts(\"4 7\\n23 10\"),0;\n    for(int x=n&1?n-1:n-2;x>=-n+1;x-=2) {\n        for(int i=1;i<=n;i++) {\n            int j=i+x;\n            if(j>n||j<1) continue;\n            a[i][j]=pri[p];\n        }\n        p++;\n    }\n    for(int x=2;x<=n*2;x+=2) {\n        for(int i=1;i<=n;i++) {\n            int j=-i+x;\n            if(j>n||j<1) continue;\n            a[i][j]*=pri[p];\n        }\n        p++;\n    }\n    for(int i=1;i<=n;i++,puts(\"\")) \n        for(int j=1;j<=n;j++) {\n            if(!a[i][j]) {\n                a[i][j]=lcm(a[i][j-1],a[i][j+1]);\n                a[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),a[i][j])+1;\n            }\n            printf(\"%lld \",a[i][j]);\n        }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N_MAX 500\n#define M_MAX 2000\ntypedef long long lnt;\ninline lnt gcd(lnt a, lnt b)\n{\n\tif (!b)\n\t\treturn a;\n\tfor (register lnt r = a % b; r; r = a % b)\n\t\ta = b, b = r;\n\treturn b;\n}\ninline lnt lcm(lnt a, lnt b)\n{\n\treturn a / gcd(a, b) * b;\n}\nconst int dx[4] = {-1, 0, +1, 0}, dy[4] = {0, -1, 0, +1};\nint n, m, i, j, k, pn, p[M_MAX];\nbool np[M_MAX + 1];\nlnt a[N_MAX][N_MAX];\ninline bool chk(int i) { return i >= 0 && i < n; }\nint main()\n{\n\tm = M_MAX;\n\tfor (i = 2; i <= m; ++i)\n\t{\n\t\tif (!np[i])\n\t\t\tp[pn++] = i;\n\t\tfor (k = 0; (j = i * p[k]) <= m; ++k)\n\t\t{\n\t\t\tnp[j] = true;\n\t\t\tif (i % p[k] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tif (n == 2)\n\t\tputs(\"4 7\\n23 10\");\n\telse\n\t{\n\t\tk = 0;\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = i & 1; j < n; j += 2)\n\t\t\t\tif (!i && !j)\n\t\t\t\t\ta[i][j] = 2;\n\t\t\t\telse\n\t\t\t\t\ta[i][j] = 2 * p[i / 2 + 1] * p[j / 2 + 1] * (1 + (i < j));\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = (i & 1) ^ 1; j < n; j += 2)\n\t\t\t{\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor (k = 0; k < 4; ++k)\n\t\t\t\t\tif (chk(i + dx[k]) && chk(j + dy[k]))\n\t\t\t\t\t\ta[i][j] = lcm(a[i][j], a[i + dx[k]][j + dy[k]]);\n\t\t\t\t++a[i][j];\n\t\t\t}\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%lld%c\", a[i][j], j < n - 1 ? ' ' : '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll gcd(ll x,ll y){return (y==0?x:gcd(y,x%y));}\n\nll a[510][510];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nbitset<10101> isp; vector<int> ps;\nvoid init(){\n   rep(i,2,10000)isp[i]=1;\n   rep(i,2,10000)if(isp[i]){\n      ps.push_back(i);\n      for(int j=i*i;j<10000;j+=i)isp[j]=0;\n   }\n}\n\nint main(){\n   int n; cin>>n;\n   if(n==2){\n      cout<<\"4 7\"<<endl;\n      cout<<\"23 10\"<<endl;\n      return 0;\n   }\n   int idx=0;\n   rep(i,0,n)rep(j,0,n)a[i][j]=1;\n   init();\n   for(int d=-n+(n&1);d<n;d+=2){\n      rep(x,0,n)if(x+d>=0 and x+d<n){\n         a[x][x+d]*=ps[idx];\n      } idx++;\n   }\n   for(int d=0;d<=n*2-2;d+=2){\n      rep(x,0,n)if(d-x>=0 and d-x<n){\n         a[x][d-x]*=ps[idx];\n      } idx++;\n   }\n   rep(i,0,n)rep(j,0,n)if((i+j)&1){\n      a[i][j]=1;\n      rep(k,0,4){\n         int tx=i+dx[k],ty=j+dy[k];\n         if(tx<0 or tx>=n or ty<0 or ty>=n)continue;\n         a[i][j]=a[i][j]/gcd(a[i][j],a[tx][ty])*a[tx][ty];\n      } a[i][j]++;\n   }\n   rep(i,0,n){\n      rep(j,0,n)cout<<a[i][j]<<(j==n-1?'\\n':' ');\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\nT gcd(T a, T b) {\n    if (a < b) std::swap(a, b);\n    if (a % b == 0) return b;\n    else return gcd(b, a % b);\n}\n\ntemplate <class T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\nint main() {\n    long long n;\n    std::vector<std::vector<long long>> v(500, std::vector<long long>(500, 1));\n    std::vector<long long> lp(10000), pr(1010);\n    auto prit = pr.begin();\n    // linear sieve\n    for (int i = 2; i < 10000 && prit != pr.end(); i++) {\n        if (!lp[i]) {\n            lp[i] = i;\n            *prit = i;\n            prit++;\n        }\n        for (auto it = pr.begin(); *it <= lp[i] && *it * i < 10000 && it != prit; it++) lp[*it * i] = *it;\n    }\n\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if ((i + j) % 2) {\n                v[i][499 - j] *= pr[500 + (i + j - 1) / 2];\n            } else {\n                v[i][j] *= pr[(i + j) / 2];\n            }\n        }\n    }\n\n    for (int i = 0; i < 500; i++) {\n        for (int j = 0; j < 500; j++) {\n            if (v[i][j] > 1) continue;\n            auto num = 1ll;\n            if (i > 0) num = lcm(num, v[i - 1][j]);\n            if (i != 499) num = lcm(num, v[i + 1][j]);\n            if (j > 0) num = lcm(num, v[i][j - 1]);\n            if (j != 499) num = lcm(num, v[i][j + 1]);\n            v[i][j] = num + 1;\n        }\n    }\n\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) std::cout << v[i][j] << \" \";\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,pri[10010],tot=0;\nbool nopri[10010];\nll ans[510][510];\n\nll lcm(ll x,ll y) {return x*y/__gcd(x,y);}\n\nvoid sieve(int n)\n{\n    rep(i,2,n)\n    {\n        if (!nopri[i]) pri[++tot]=i;\n        for (int j=1;j<=tot && i*pri[j]<=n;j++)\n        {\n            nopri[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\n\nint main()\n{\n    sieve(10000);\n    n=read();\n    if (n==2)\n    {\n        puts(\"4 7\\n23 10\");return 0;\n    }\n    //rep(i,1,20) cout << pri[i] << \" \";cout << endl;\n    rep(i,0,n+1) ans[0][i]=ans[n+1][i]=ans[i][0]=ans[i][n+1]=1;\n    int now=0;\n    rep(i,1,n)\n    {\n        int st;\n        if (i&1) st=1;else st=2;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=pri[(i+j)>>1]*pri[(i-j+n+1)/2+n];\n        }\n    }\n    rep(i,1,n) \n    {\n        int st;\n        if (i&1) st=2;else st=1;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]))+1;\n        }\n    }\n    rep(i,1,n)\n    {\n        rep(j,1,n) printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10010;\n\ntypedef long long LL;\n\nint flag[N], prime[N], pcnt;\n\ninline void sieve() {\n\tfor (int i = 2; i <= N - 10; i++) {\n\t\tif (!flag[i]) prime[++pcnt] = i;\n\t\tfor (int j = 1; j <= pcnt && i * prime[j] <= N - 10; j++) {\n\t\t\tflag[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nLL G[510][510];\n\nLL gcd(LL a, LL b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\ninline LL lcm(LL a, LL b) {\n\treturn a / gcd(a, b) * b;\n}\n\ntemplate<typename... T>\ninline LL lcm(LL a, T... b) {\n\tLL t = lcm(b...);\n\treturn a / gcd(a, t) * t;\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n), sieve();\n\tif (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\tfor (int j = 0; j <= n + 1; j++) G[i][j] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if ((i + j) & 1) {\n\t\t\tint a = i + j, b = i - j; a = (a - 1) / 2, b = (b + n + 1) / 2;\n\t\t\tG[i][j] = (LL)prime[a] * prime[b + n - 1];\n\t\t}\n\tfor (int i = 1; i <= n; i++, puts(\"\"))\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (!((i + j) & 1)) G[i][j] = (LL)lcm(G[i - 1][j], G[i][j - 1], G[i + 1][j], G[i][j + 1]) + 1;\n\t\t\tprintf(\"%lld \", G[i][j]);\n\t\t}\n}//"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\tfor (int i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(a) begin(a), end(a)\n\nconst ll maxn = 501;\nll arr[maxn][maxn], cur, n;\n\nint main()\n{\n    ll d = 1e10;\n    cin >> n;\n    for (ll i = 0; i < n; ++i)\n    {\n        for (ll j = 0; j < n; ++j)\n        {\n            cur = i * maxn + j + 1;\n            if ((i ^ j) % 2)\n            {\n                cout << cur << ' ';\n            }\n            else\n            {\n                cout << cur + d << ' ';\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int N=20005;\nset<ll> st;\nint n,i,j,k,p[N],l,w1[N],w2[N];\nbool v[N];\nll a[505][505];\nll gcd(ll a,ll b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nll LCM(ll a,ll b,ll c,ll d)\n{\n\tll rtn=a/gcd(a,b)*b;\n\trtn=rtn/gcd(rtn,c)*c;\n\trtn=rtn/gcd(rtn,d)*d;\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=2;i<=20000;++i)\n\t{\n\t\tif(!v[i])\n\t\t\tp[++l]=i;\n\t\tfor(j=1;j<=l&&p[j]*i<=20000;++j)\n\t\t{\n\t\t\tv[p[j]*i]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tw1[i]=p[i];\n\tfor(i=1;i<=n;++i)\n\t\tw2[i]=p[n+i];\n\trandom_shuffle(w1+1,w1+1+n);\n\trandom_shuffle(w2+1,w2+1+n);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif((i+j)%2==0)\n\t\t\t\ta[i][j]=w1[(i+j)/2]*w2[(i-j+n+1)/2];\n\tfor(i=0;i<=n+1;++i)\n\t\ta[0][i]=a[n+1][i]=a[i][0]=a[i][n+1]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\ta[i][j]=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n\t\t\t\twhile(st.count(a[i][j]))\n\t\t\t\t\ta[i][j]+=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]);\n\t\t\t\tst.insert(a[i][j]);\n\t\t\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nmap <ll, bool> hsh;\n\nll X[555][555];\n\nbool vis[55555555];\n\nint gcd(int a, int b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n    return a / gcd(a, b) * b;\n}\n\nsigned main() {\n    int n;\n    scanf(\"%lld\", &n);\n    for(int i = 0; i <= n + 1; i++)\n        for(int j = 0; j <= n + 1; j++)\n            X[i][j] = 1;\n    for(int i = 1; i <= n; i += 2) {\n        int cnt = 1;\n        for(int j = 1; i + j - 1 <= n; j++) {\n            while(vis[cnt * (i + 1)]) cnt++;\n            X[j][i + j - 1] = cnt * (i + 1);\n            vis[cnt * (i + 1)] = 1;\n            hsh[cnt * (i + 1)] = 1;\n        }\n    }\n    for(int j = 3; j <= n; j += 2) {\n        int cnt = 1;\n        for(int i = 1; i + j - 1 <= n; i++) {\n            while(vis[cnt * (j)]) cnt++;\n            X[i + j - 1][i] = cnt * (j);\n            vis[cnt * j] = 1;\n            hsh[cnt * j] = 1;\n            \n        }\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            if((i + j) % 2) {\n                X[i][j] = lcm(X[i + 1][j], X[i][j + 1]) * lcm(X[i - 1][j], X[i][j - 1]);\n                for(int k = 1; ; k++) if(!hsh[X[i][j] * k]) {\n                    X[i][j] *= k;\n                    hsh[X[i][j]] = 1;\n                    break;\n                }\n            }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) printf(\"%lld \", X[i][j]);\n        putchar('\\n');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 500001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nint solve(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\tif (b == 1) { return 1; }\n\treturn a % b;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvel prime(0);\n\tint mod = 510;\n\tfor (int i = 1000; i < 10000; i++) {\n\t\tif (is_prime(i)) { prime.push_back(i); }\n\t}\n\tvvel ans(n, vel(n,1));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tint x = (i + j) / 2;\n\t\t\t\tint y = per((i - j) / 2, mod);\n\t\t\t\tans[i][j] = prime[x] * prime[y];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tj--;\n\t\t\t\tint x = (i + j) / 2;\n\t\t\t\tint y = per((i - j) / 2, mod);\n\t\t\t\tans[i][j+1] = prime[x] * prime[y];\n\t\t\t\tj += 2;\n\t\t\t\tx = (i + j) / 2;\n\t\t\t\ty = per((i - j) / 2, mod);\n\t\t\t\tans[i][j-1] *= prime[x] * prime[y];\n\t\t\t\tj--;\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t\tcout << ans[i][j];\n\t\t\tif (j == n - 1) { cout << endl; }\n\t\t\telse { cout << \" \"; }\n\t\t}\n\t}\n\tcout << \"START\" << endl;\n\tvel lis(n*n);\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tlis[n*i + j] = ans[i][j];\n\t\t}\n\t}\n\tsor(lis);\n\tuni(lis);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=500+5,M=1e4+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n;\nint vis[M],l[M];\nvoid input()\n{\n\tn=read<int>();\n}\nvoid init(int Max)\n{\n\tFor(i,2,Max)\n\t{\n\t\tif(!vis[i])l[++l[0]]=i;\n\t\tfor(int j=1;j<=l[0]&&i*l[j]<=Max;j++)\n\t\t{\n\t\t\tvis[l[j]*i]=1;\n\t\t\tif(i%l[j]==0)break;\n\t\t}\n\t}\n}\nll mp[N][N];\nint x[N<<1],y[N<<1];\nll lcm(ll x,ll y)\n{\n\tif(!x||!y)return x|y;\n\treturn x/__gcd(x,y)*y;\n}\nvoid work()\n{\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\tint now1=0,now2=0;\n\tFor(i,1,n)For(j,1,n)if((i+j)&1)\n\t{\n\t\tif(!x[j-i+n])x[j-i+n]=l[++now1];\n\t\tif(!y[i+j])y[i+j]=l[++now2];\n\t\tmp[i][j]=x[j-i+n]*y[i+j];\n\t}\n\tFor(i,1,n)For(j,1,n)if(!mp[i][j])\n\t{\n\t\tmp[i][j]=lcm(mp[i][j],mp[i-1][j]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i+1][j]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i][j-1]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i][j+1]);\n\t\tmp[i][j]++;\n\t}\n\tFor(i,1,n)For(j,1,n)\n\t{\n\t\t//cerr<<mp[i][j]<<endl;\n\t\tassert(mp[i][j]<=1e15);\n\t\tif(j>1)assert(max(mp[i][j],mp[i][j-1])%min(mp[i][j],mp[i][j-1])==1);\n\t\tif(i>1)assert(max(mp[i][j],mp[i-1][j])%min(mp[i][j],mp[i-1][j])==1);\n\t}\n\tFor(i,1,n)For(j,1,n)write(mp[i][j],j==n?'\\n':' ');\n}\nint main()\n{\n//\tfile();\n\tinput();\n\tinit(1e4);\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 500, M = 10000000;\nint p[M / 10], p2[10000], sz;\nll an[N][N];\nbool pr[M];\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\nint main(){\n\tfor (int i = 2; i * i < M; ++i)if (!pr[i])for (int j = i * i; j < M; j += i)pr[j] = true;\n\tf(i, 2, M)if (!pr[i])p[sz++] = i;\n\tint kk = 0;\n\tfor (int i = 1999; i > 0; i -= 3){\n\t\tp2[kk++] = p[i];\n\t\tp2[kk++] = p[i - 1];\n\t\tp2[kk++] = p[i - 2];\n\t\tp2[kk++] = p[(1999-i) / 3];\n\t\tif (kk == 2000)break;\n\t}\n\tint n;\n\tscanf(\"%d\", &n);\n\tif (n == 2) { printf(\"4 7\\n23 10\\n\"); return 0; }\n\tf(i, 0, n)f(j, 0, n)an[i][j] = 1;\n\tkk = 0;\n\tfor (int i = 0; i < n; i += 2, ++kk)for (int j = 0, z = i; j < n && z < n; ++j, ++z)an[z][j] *= p[kk];\n\tfor (int j = 2; j < n; j += 2, ++kk)for (int i = 0, z = j; i < n && z < n; ++i, ++z)an[i][z] *= p[kk];\n\tfor (int i = 0; i < 2*n - 1; i += 2, ++kk)for (int j = i < n ? 0 : i - n + 1, z = i < n ? i : n - 1; j < n && z >= 0; ++j, --z)an[z][j] *= p[kk];\n\tf(i, 0, n)for (int j = i + 1 & 1; j < n; j += 2)an[i][j] = 1 + lcm(i ? an[i - 1][j] : 1, lcm(i + 1 < n ? an[i + 1][j] : 1, lcm(j ? an[i][j - 1] : 1, j + 1 < n ? an[i][j + 1] : 1)));\n\tf(i, 0, n){\n\t\tprintf(\"%lld\", an[i][0]);\n\t\tf(j, 1, n)printf(\" %lld\", an[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int) (x).size()\n\nconst int maxn = 505;\nll a[maxn][maxn];\nint n;\n\nconst int maxm = 1e4 + 5;\nbool vis[maxm];\n\nmap<int, int> zhu, fu;\n\nll gcd(ll x, ll y){\n    return y == 0 ? x : gcd(y, x % y);\n}\n\nll lcm(ll x, ll y){\n    return x / gcd(x, y) * y;\n}\n\nvoid solve(){\n    memset(vis, 0, sizeof(vis));\n    vector<int> prime;\n    vis[1] = 1;\n    for(int i = 2;i < maxm;i++){\n        if(!vis[i]){\n            prime.push_back(i);\n            for(int j = 2 * i;j < maxm;j += i){\n                vis[j] = 1;\n            }\n        }\n    }\n    int front = 0, rear = n - 1;\n    for(int i = 2;i <= 2 * n;i += 2){\n        int k = i / 2;\n        if(k & 1){\n            zhu[i] = prime[front++];\n        }else{\n            zhu[i] = prime[rear--];\n        }\n    }\n    int k;\n    if(n & 1)\n        k = n;\n    else\n        k = n - 1;\n    front = n, rear = n + k - 1;\n    for(int i = 1 - k, odd = 1;i <= k - 1;i += 2, odd++){\n        if(odd & 1){\n            fu[i] = prime[front++];\n        }else{\n            fu[i] = prime[rear--];\n        }\n    }\n    for(int i = 1;i <= n;i++){\n        int st;\n        if(i & 1){\n            st = 1;\n        }else{\n            st = 2;\n        }\n        for(int j = st;j <= n;j += 2){\n            int id1 = zhu[i + j];\n            int id2 = fu[i - j]; \n            a[i][j] = 1LL * id1 * id2;\n            //cout << a[i][j] << endl;\n        }\n    }\n    for(int i = 1;i <= n;i++){\n        int st;\n        if(i & 1){\n            st = 2;\n        }else{\n            st = 1;\n        }\n        for(int j = st;j <= n;j += 2){\n            a[i][j] = 1;\n            if(j > 1){\n                a[i][j] = lcm(a[i][j], a[i][j - 1]);\n            }\n            if(j < n){\n                a[i][j] = lcm(a[i][j], a[i][j + 1]);\n            }\n            if(i > 1){\n                a[i][j] = lcm(a[i][j], a[i - 1][j]);\n            }\n            if(i < n){\n                a[i][j] = lcm(a[i][j], a[i + 1][j]);\n            }\n        }\n    }\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            cout << a[i][j] << ((j == n) ? '\\n' : ' ');\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace FastOut {\n    static constexpr size_t BUF_SIZE = 1 << 17, INT_LEN = 24;\n    static char buf[BUF_SIZE | 1] = {}, *pos = buf, *endbuf = pos + BUF_SIZE;\n    FILE *fout;\n\n    inline void flush() {\n        std::fwrite(buf, 1, pos - buf, fout);\n        pos = buf;\n    }\n\n    inline void print(const char out) {\n        if (pos == endbuf) {\n            flush();\n        }\n        *pos++ = out;\n    }\n\n    inline void print(const char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n    inline void print(char *out) {\n        size_t len = std::strlen(out);\n        if (pos + len >= endbuf) {\n            flush();\n            if (len >= BUF_SIZE) {\n                std::fwrite(out, 1, len, fout);\n                return;\n            }\n        }\n        std::memcpy(pos, out, len);\n        pos += len;\n    }\n\n\n    template<class Char, size_t Len>\n    inline void print(const Char (&out)[Len]) {\n        print(&out[0]);\n    }\n\n    template<class Int>\n    inline void print(Int out) {\n        static_assert(std::is_integral<Int>::value, \"For integers only\");\n\n        if (out == 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '0';\n            return;\n        }\n\n        char minibuf[INT_LEN], *minipos = minibuf + INT_LEN;\n        if (std::is_signed<Int>::value && out < 0) {\n            if (pos == endbuf) {\n                flush();\n            }\n            *pos++ = '-';\n            if (out == std::numeric_limits<Int>::min() && Int(-1) == ~Int(0)) {\n                // In two's complement representation, we could not represent the\n                // absolute value of minimum (maximum-magnitude negative) value.\n                // Without this branch, we would overflow (undefined behavior) by\n                // the value.  If we know the input is never the value, we can\n                // remove this branch and save (nanoseconds-order) time.\n                switch (sizeof out) {\n                    case 1:\n                        return (void) (print(\"128\"));\n                    case 2:\n                        return (void) (print(\"32768\"));\n                    case 3:\n                        return (void) (print(\"8388608\"));\n                    case 4:\n                        return (void) (print(\"2147483648\"));\n                    case 8:\n                        return (void) (print(\"9223372036854775808\"));\n                    case 16:\n                        return (void) (print(\"170141183460469231731687303715884105728\"));\n                    default:\n                        // Regardless of the number of its bytes, lowest (decimal) digit\n                        // is always eight, but other digits depend on it.\n                        *--minipos = '8';\n                        out /= -10;\n                }\n            } else {\n                out = -out;\n            }\n        }\n\n        // We know the division is too slow; we wish we could avoid using them\n        // TWICE PER LOOP!  ...Now, we notice that compilers are so smart that\n        // can replace it by shift operations...  The division-compatible\n        //instructions for unsigned are shorter than ones for signed.\n        typename std::make_unsigned<Int>::type out_ = out;\n        do {\n            *--minipos = '0' + out_ % 10;\n            out_ /= 10;\n        } while (out_ > 0);\n\n        size_t len = (minibuf + INT_LEN) - minipos;\n        if (pos + len >= endbuf) {\n            flush();\n        }\n        std::memcpy(pos, minipos, len);\n        pos += len;\n    }\n\n    class Printer {\n        inline void flush() {\n            FastOut::flush();\n        }\n\n    public:\n        Printer(FILE *fout = stdout) {\n            FastOut::fout = fout;\n        }\n\n        ~Printer() {\n            flush();\n        }\n\n        template<class T>\n        inline void print(const T out) {\n            FastOut::print(out);\n        }\n\n        template<class First, class... Rest>\n        inline void print(const First &out, const Rest &...outs) {\n            FastOut::print(out);\n            Printer::print(outs...);\n        }\n\n        template<class T>\n        inline void println(const T out) {\n            FastOut::print(out);\n            FastOut::print('\\n');\n        }\n    };\n}\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i < 499 ? 996 - 2 * i : 2 * i - 997;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v(i + j - 2)] * p[v(499 + i - j)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v(i + j)] * p[v(499 + i - j)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(lcm(ans[i][j], ans[i + 2][j]), lcm(ans[i + 1][j + 1], ans[i + 1][j - 1])) + 1;\n                ans[i][j + 1] = lcm(lcm(ans[i][j], ans[i][j + 2]), lcm(ans[i + 1][j + 1], ans[i - 1][j + 1])) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nFastOut::Printer out;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)out.print(a.at(i, j), ' ');\n        out.println(a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<list>\n#include<deque>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1000)\nvector<int>prim;\n\nvoid prim_make(int k){\n\tif (k >= 2)prim.push_back(2);\n\tif (k >= 3)prim.push_back(3);\n\tif (k >= 5)prim.push_back(5);\n\tint x = 7;\n\tbool v;\n\twhile (x <= k){\n\t\tv = true;\n\t\tfor (int i = 2; prim[i] * prim[i] <= x; i++){\n\t\t\tif (x%prim[i] == 0){\n\t\t\t\tv = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v)prim.push_back(x);\n\t\tif (x % 6 == 1)x += 4;\n\t\telse x += 2;\n\t}\n\treturn;\n}\n\n\n\n\n\n\nint main(){\n\tlong long a[N][N];\n\tset<long long>s;\n\tvector<int>ve1,ve2;\n\tint n;\n\tlong long k, x, y, z;\n\tlong long ans;\n\tbool v1, v2;\n\tprim_make(100000);\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tx = 9000;\n\twhile(x>0){\n\t\tve1.push_back(x);\n\t\tx -= 2;\n\t}\n\tx = 9002;\n\twhile (x<18002){\n\t\tve2.push_back(x);\n\t\tx += 2;\n\t}\n\tx = 3;\n\twhile (x<12000){\n\t\tve1.push_back(x);\n\t\tx += 6;\n\t}\n\tx = 23997;\n\twhile (x > 12000){\n\t\tve2.push_back(x);\n\t\tx -= 6;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tf(i, n){\n\t\tf(j, n)a[i][j] = -1;\n\t}\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif ((i + j) % 4 == 0){\n\t\t\t\ta[i][j] = ve1[x];\n\t\t\t\ts.insert(ve1[x]);\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ((i + j) % 4 == 2){\n\t\t\t\ta[i][j] = ve2[y];\n\t\t\t\ts.insert(ve2[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\tf(i,n){\n\t\tf(j,n){\n\t\t\tif (a[i][j] == -1){\n\t\t\t\tans = 1;\n\t\t\t\tv1 = true;\n\t\t\t\tv2 = true;\n\t\t\t\tx = 0;\n\t\t\t\tif (i > 0){\n\t\t\t\t\tans = ans*a[i - 1][j];\n\t\t\t\t\tif (a[i - 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i - 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (i < (n - 1)){\n\t\t\t\t\tans = ans*a[i + 1][j];\n\t\t\t\t\tif (a[i + 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i + 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j > 0){\n\t\t\t\t\tans = ans*a[i][j - 1];\n\t\t\t\t\tif (a[i][j-1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j-1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j < (n - 1)){\n\t\t\t\t\tans = ans*a[i][j + 1];\n\t\t\t\t\tif (a[i][j + 1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j + 1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (v1){\n\t\t\t\t\tf(ii, x-1)ans = ans / 2;\n\t\t\t\t}\n\t\t\t\tif (v2){\n\t\t\t\t\tf(ii, x-1)ans = ans / 3;\n\t\t\t\t}\n\t\t\t\tx = 2;\n              if(s.count(ans+1)==1)ans=ans*5;\n              if(s.count(ans+1)==1){\nans=ans/5;  \n                ans=ans*7;\n              }\n\t\t\t\ta[i][j] = ans + 1;\n\t\t\t\ts.insert((ans + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < (n - 1))printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#define ll long long\nusing namespace std;\nconst int N=510,MX=1e6;\nint p[2510];\nint vis[MX];\nll rec[N][N];\nint n,m,cnt;\nvoid prework(int n){\n\tvis[1]=false;\n\tint cnt=0;\n\tfor (int i=2;cnt<n;++i){\n\t\tif (!vis[i])\n\t\t\tp[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<MX;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){\n\tif (!x||!y) return x+y;\n\treturn x/gcd(x,y)*y;\n}\nvoid solve(){\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\trec[i][j]=1LL*p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif (!rec[i][j])\n\t\t\t\trec[i][j]=lcm(lcm(rec[i-1][j],rec[i][j+1]),lcm(rec[i+1][j],rec[i][j-1]))+1;\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tll tmp;\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"%d %d\\n%d %d\\n\",4,7,23,10);\n\t\treturn 0;\n\t}\n\tprework(n*n);\n\tsolve();\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",rec[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nlong long pow(long long x,long long k){\n\tif(k == 0)return 1;\n\treturn pow(x,k-1)*x;\n}\n\nlong long gcd(long long x,long long y){\n\tif(y == 0)return x;\n\treturn gcd(y,x%y);\n}\n\nlong long lcm(long long x,long long y){\n\tx /= gcd(x,y);\n\tx *= y;\n\treturn x;\n}\n\nvoid f(long long x, long long y){\n\tif(max(x,y)%min(x,y) != 1){\n\t\tputs(\"No\");\n\t\texit(1);\n\t}\n}\n\nint main(){\n\tvector<long long> p;\n\tint t = 5;\n\twhile(p.size() < 100){\n\t\tbool b = true;\n\t\tfor(int i = 2 ; i*i <= t ; i ++){\n\t\t\tif(t%i == 0){\n\t\t\t\tb = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b)p.push_back(t);\n\t\tt ++;\n\t}\n\tlong long k[10] = {1,2,5,6,7,8,9,10,3,4};\n\t\n\tlong long x[502],y[502];\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tx[i] = p[i/10]*pow(2,k[i%10]);\n\t\ty[i] = p[i/10+50]*pow(3,k[i%10]);\n\t}\n\t\n\tset<long long> S;\n\tlong long m = 0;\n\tlong long a[502][502] = {};\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tfor(int j = 0 ; j < 500 ; j ++){\n\t\t\tif((i+j)&1){\n\t\t\t\ta[i][j] = x[i]*y[j];\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t\tm = max( m , a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t//cout << S.size() << endl;\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tfor(int j = 0 ; j < 500 ; j ++){\n\t\t\tif((i+j)&1){}\n\t\t\telse {\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tif(i > 0)a[i][j] = lcm(a[i][j],a[i-1][j]);\n\t\t\t\tif(i+1 < 500)a[i][j] = lcm(a[i][j],a[i+1][j]);\n\t\t\t\tif(j > 0)a[i][j] = lcm(a[i][j],a[i][j-1]);\n\t\t\t\tif(j+1 < 500)a[i][j] = lcm(a[i][j],a[i][j+1]);\n\t\t\t\tlong long d = a[i][j];\n\t\t\t\ta[i][j] += 1;\n\t\t\t\twhile(S.find(a[i][j]) != S.end())a[i][j] += d;\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tset<long long> T;\n\tlong long M;\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tfor(int j = 0 ; j < 500 ; j ++){\n\t\t\tT.insert(a[i][j]);\n\t\t\tif(a[i][j] <= 0 || a[i][j] > 1000000000000000)puts(\"No\");\n\t\t\tif(j+1 < 500)f(a[i][j],a[i][j+1]);\n\t\t\tif(i+1 < 500)f(a[i][j],a[i+1][j]);\n\t\t\tM = max(M,a[i][j]);\n\t\t}\n\t}\n\t//cout << T.size() << endl;\n\t//cout << m << \" \" << M << endl;\n\t//puts(\"Yes\");\n\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tfor(int j = 0 ; j < n ; j ++){\n\t\t\tprintf(\"%lld%c\",a[i][j],(j==n-1)?'\\n':' ');\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nset<ll> presents;\nll gg1[2 * MAXN], gg2[2 * MAXN];\nll f1[8] = {1, 2, 3, 4, 6, 8, 9, 12}, f2[8] = {12, 6, 4, 3, 2, 8, 9, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn gg1[x];\n\t// return (primes[x] < 4000 ? primes[x] : primes[x] / 2);\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn gg2[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p >= MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i <= 2 * N; i++)\n\t\t{\n\t\t\tgg1[i] = primes[i / 8 + 3] * f1[i % 8];\n\t\t\tgg2[i] = primes[i / 8 + 3] * f2[i % 8];\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[i][j] = lcm(mind(i - j), plud(i + j));\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j]) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j] + 1) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\t// cerr << \"set\\n\"\n\t\tif(*(presents.rbegin()) < 100000000000000ll) break;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tpresents.clear();\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\ntypedef  long long ll;\nint gcd(int f , int s){if(s==0)return f;else return gcd(s,f%s);}\nint const N = 1000006;\nll const M = 998244353;\nlong double const ep = .000000000000000001;\nll arr[521][512];\nmap<ll , bool> vis;\nint main() {\n\t\n\tint n;\n\tcin >> n;\n\tint counter = 2 ;\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 0){\n\t\t\t\tvis[counter] = 1;\n\t\t\t\tarr[i][j]=counter++;\n\t\t\t}\n\t\t}\n\t}\t\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tif((i + j)%2== 1){\n\t\t\t\tll num = 1 , g = -1;\n\t\t\t\tif(i != 0){\n\t\t\t\t\tg = arr[i-1][j];\n\t\t\t\t\tnum = arr[i-1][j];\n\t\t\t\t}\n\t\t\t\tif(i != n-1){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i+1][j]);\n\t\t\t\t\telse g = arr[i+1][j];\n\t\t\t\t\tnum *= arr[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(j != 0){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i][j-1]);\n\t\t\t\t\telse g = arr[i][j-1];\n\t\t\t\t\tnum *= arr[i][j-1];\n\t\t\t\t}\n\t\t\t\tif(j != n-1){\n\t\t\t\t\tif(g != -1)\n\t\t\t\t\t\tg = gcd(g , arr[i][j+1]);\n\t\t\t\t\telse g = arr[i][j+1];\n\t\t\t\t\tnum *= arr[i][j+1];\n\t\t\t\t}\n\t\t\t\tll lol = num / g + 1;\n\t\t\t\twhile(vis[lol] != 0){\n\t\t\t\t\tlol *= lol;\n\t\t\t\t}\n\t\t\t\tvis[lol] = 1;\n\t\t\t\tarr[i][j] = lol;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i< n ; i++){\n\t\tfor(int j=0 ; j< n ; j++){\n\t\t\tcout << arr[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n\n    for ( int i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n\n}\n\n\nlong long cmmdc ( long long a , long long b ){\n\n    while ( b ){\n        long long t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\nlong long calcLCM ( long long a , long long b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int i = 0 ; i <= 2 * noLin ; i+=1 ){\n        diagPrin [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i <= 2 * noLin ; i+=2 ){\n        diagSec [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < noLin ; i+=1 ){\n        for ( int j = 0 ; j < noLin ; j+=1 ){\n            int crPrin = j - i + noLin - 1 ;\n            int crSec = 2*noLin - i - j - 1 ;\n\n            mat [ i ][ j ] = diagPrin [ crPrin ] * diagSec [ crSec ];\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n\n            long long  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            printf(\"%d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define MAX 505\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,prime[MAX<<1],vst[10005];\nvoid pre(int up)\n{\n\tfor(int i=2;;i++)\n\t{\n\t\tif(!vst[i])\n\t\t{\n\t\t\tprime[++prime[0]]=i;\n\t\t\tif(prime[0]==up) break;\n\t\t}\n\t\tfor(int j=1;j<=prime[0];j++)\n\t\t{\n\t\t\tif(i*prime[j]>10000) break;\n\t\t\tvst[i*prime[j]]=1;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n}\nlong long gcd(long long a,long long b)\n{\n\tif(a<b) swap(a,b);\n\twhile(b)\n\t{\n\t\ta%=b;\n\t\tswap(a,b);\n\t}\n\treturn a;\n}\nlong long lcm(long long a,long long b)\n{\n\tif(!a||!b) return a|b;\n\treturn a/gcd(a,b)*b;\n}\nlong long a[MAX][MAX];\nint main()\n{\n\tn=read();\n\tpre((n&1)?n*2:n*2-1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!((i+j)&1))\n\t\t\t\ta[i][j]=1ll*prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nset<ll> presents;\nll gg1[2 * MAXN], gg2[2 * MAXN];\nll f1[8] = {1, 2, 3, 4, 6, 8, 9, 12}, f2[8] = {9, 6, 2, 12, 4, 8, 3, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn gg1[x];\n\t// return (primes[x] < 4000 ? primes[x] : primes[x] / 2);\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn gg2[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p >= MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i <= 2 * N; i++)\n\t\t{\n\t\t\tgg1[i] = primes[i / 8 + 3] * f1[i % 8];\n\t\t\tgg2[i] = primes[i / 8 + 3] * f2[i % 8];\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[i][j] = lcm(mind(i - j), plud(i + j));\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j]) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif ((i + j) % 2)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t{\n\t\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll rec = ans[i][j];\n\t\t\t\twhile(presents.find(ans[i][j] + 1) != presents.end())\n\t\t\t\t{\n\t\t\t\t\tans[i][j] += rec;\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\tif (i != 0 && j != 0 && i != N - 1 && j != N - 1) presents.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t\t// cerr << \"set\\n\"\n\t\tif(*(presents.rbegin()) < 100000000000000ll) break;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tpresents.clear();\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=505;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\treturn !y?x:gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=0;i<=n+1;i++)for(ll j=0;j<=n+1;j++)a[i][j]=1;\n\tfor(ll st=1;st<=n;st+=4){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=st,y=1;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=5;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y<=n)a[x][y]*=p[tot],x++,y++;\n\t}\n\tfor(ll st=1;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=1,y=st;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=3;st<=n;st+=4){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll st=5;st<=n;st+=4){\n\t\tll x=st,y=n;tot++;\n\t\twhile(x<=n&&y>=1)a[x][y]*=p[tot],x++,y--;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\tfor(ll j=1;j<=n;j++)\n\tif((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=924844033;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcout<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,i,j;cin>>n;\n\tvector<llint>usa;\n\tusa.reserve(n+n+10);\n\tfor(i=2;;i++){\n\t\tbool ok=1;\n\t\tfor(j=2;j*j<=i;j++){\n\t\t\tif(i%j==0){ok=0;break;}\n\t\t}\n\t\tif(ok){usa.pub(i);if(usa.size()>=n+n+10){break;}}\n\t}\n\tint m=n;\n\tif(n%2==1){m++;}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif((i+j)%2==0){//大\n\t\t\t\tllint ans=1;\n\t\t\t\tint x=(i+j)/2;\n\t\t\t\t//xとx+1\n\t\t\t\tans*=usa[x];\n\t\t\t\tans*=usa[x+1];\n\t\t\t\tint y=(i+m-j)/2 +2;\n\t\t\t\tans*=usa[n+5+y];\n\t\t\t\tans*=usa[n+6+y];\n\t\t\t\tcout<<ans<<\" \";\n\t\t\t}else{\n\t\t\t\tllint ans=1;\n\t\t\t\tint x=(i+j)/2;\n\t\t\t\t//xとx+1\n\t\t\t\tans*=usa[x+1];\n\t\t\t\tint y=(i+m-j)/2 +2;\n\t\t\t\tans*=usa[n+6+y];\n\t\t\t\tcout<<ans<<\" \";\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long \n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint n,pri[maxn],tot,vis[maxn],a[550][550];\n\nvoid gen() {\n    for(int i=2;tot<=n*2;i++) {\n        if(!vis[i]) vis[i]=1,pri[++tot]=i;\n        for(int j=1;j<=tot&&i*pri[j]<=10000;j++) {\n            vis[i*pri[j]]=1;\n            if(i%pri[j]==0) break;\n        }\n    }\n}\n\nint lcm(int a,int b) {return !min(a,b)?max(a,b):a/__gcd(a,b)*b;}\n\nsigned main() {\n    read(n);gen();int p=1;\n    if(n==2) return puts(\"4 7\\n23 10\"),0;\n    for(int x=n&1?n-1:n-2;x>=-n+1;x-=2) {\n        for(int i=1;i<=n;i++) {\n            int j=i+x;\n            if(j>n||j<1) continue;\n            a[i][j]=pri[p];\n        }\n        p++;\n    }\n    for(int x=2;x<=n*2;x+=2) {\n        for(int i=1;i<=n;i++) {\n            int j=-i+x;\n            if(j>n||j<1) continue;\n            a[i][j]*=pri[p];\n        }\n        p++;\n    }\n    for(int i=1;i<=n;i++,puts(\"\")) \n        for(int j=1;j<=n;j++) {\n            if(!a[i][j]) {\n                a[i][j]=lcm(a[i][j-1],a[i][j+1]);\n                a[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),a[i][j]);\n            }\n            printf(\"%lld \",a[i][j]);\n        }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[555][555];\nint b[555][555];\nint ans[555][555];\nvector<int> p;\nsigned main(){\n\tic(n)\n\trep(2,i,10000)if(prime(i))p.pb(i);\n\trep(0,i,555)rep(0,j,555){\n\t\tif((i+j)%2==0){\n\t\t\ta[i][j]=p[(i+j)/2];\n\t\t\tb[i][j]=p[(i+1662-j)/2];\n\t\t\tans[i][j]=a[i][j]*b[i][j];\n\t\t}\n\t}\n\trep(0,i,555)rep(0,j,555)if(ans[i][j]==0&&i>0&&i<554)ans[i][j]=ans[i-1][j]*ans[i+1][j]+1;\n\trep(0,i,n)rep(0,j,n)cout<<ans[i+1][j+1]<<\" \";\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define mcpy(des,sor) memcpy(des,sor,sizeof(sor))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll mod = 1e9+7;\nconst db eps = 1e-8;\n\nchar io[1<<15],*is=io,*ie=io+1;\n#define rd if(++is==ie)ie=(is=io)+fread(io,1,sizeof(io),stdin)\ntemplate<class T>\ninline bool Cin(T &a){\n\ta=0;bool s=0;\n\tif(is==ie)return 0;\n\tdo{rd;if(*is=='-')s=1;}while(!isdigit(*is)&&is!=ie);\n\tif(is==ie)return 0;\n\tdo{(a*=10)+=*is&15;rd;}while(isdigit(*is)&&is!=ie);\n\tif(s)a=-a;;return 1;}\n\ninline int Gets(char a[]){\n\tint p=0;\n\tif(is==ie)return 0;\n\tdo rd; while(!isgraph(*is)&&is!=ie);\n\tif(is==ie)return 0;\n\tdo {a[p++]=*is;rd;}while(isgraph(*is)&&is!=ie);\n\ta[p]=0;return p;}\n\n#define maxn 10005\n\nvector<int> p;\nbool isp[maxn];\nll a[502][502];\n\nll lcm(ll x,ll y){return x/__gcd(x,y)*y;}\n\nint main()\n{\n\tint n;\n\tCin(n);\n\tif(n==2)return !printf(\"4 7\\n23 10\\n\");\n\tmst(isp,0);p.clear();\n\tfor(int i=2;sz(p)<2000;++i)\n\t{\n\t\tif(!isp[i])p.pb(i);\n\t\tfor(int j=0;j<sz(p)&&p[j]*i<maxn;++j)\n\t\t{\n\t\t\tisp[p[j]*i]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\trepb(i,0,n+1)a[0][i]=a[n+1][i]=a[i][0]=a[i][n+1]=1;\n\n\trepb(i,1,n)repb(j,1,n)if((i+j)%2==0)\n\t\ta[i][j]=p[(i+j)/2-1]*p[n+(i+n-j)/2-1];\n\t\n\trepb(i,1,n)repb(j,1,n)if((i+j)%2==1)\n\t\ta[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\t\n\trepb(i,1,n)repb(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 500\nll a[MN+5][MN+5];\nmap<ll,int> mp;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nint main()\n{\n\tint n,i,j,k,x,y;\n\tfor(i=2;i<=MN+MN;i+=2)for(j=-MN;j<=MN;j+=2)\n\t{\n\t\tx=(i+j)/2;y=(i-j)/2;\n\t\tif(x<1||x>MN||y<1||y>MN)continue;\n\t\tfor(k=1;mp[i*(j+MN)/2*k]++;++k);\n\t\ta[x][y]=i*(j+MN)/2;\n\t}\n\tfor(i=1;i<=MN;++i)for(j=1;j<=MN;++j)if(!a[i][j])\n\t{\n\t\tll x=1;\n\t\tif(i>1)x=x/gcd(x,a[i-1][j])*a[i-1][j];\n\t\tif(i<MN)x=x/gcd(x,a[i+1][j])*a[i+1][j];\n\t\tif(j>1)x=x/gcd(x,a[i][j-1])*a[i][j-1];\n\t\tif(j<MN)x=x/gcd(x,a[i][j+1])*a[i][j+1];\n\t\tfor(k=1;mp[x*k+1]++;++k);\n\t\ta[i][j]=x*k+1;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i,puts(\"\"))for(j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N_MAX 500\n#define M_MAX 2000\ntypedef long long lnt;\ninline lnt gcd(lnt a, lnt b)\n{\n\tif (!b)\n\t\treturn a;\n\tfor (register lnt r = a % b; r; r = a % b)\n\t\ta = b, b = r;\n\treturn b;\n}\ninline lnt lcm(lnt a, lnt b)\n{\n\treturn a / gcd(a, b) * b;\n}\nconst int dx[4] = {-1, 0, +1, 0}, dy[4] = {0, -1, 0, +1};\nint n, m, i, j, k, pn, p[M_MAX];\nbool np[M_MAX + 1];\nlnt a[N_MAX][N_MAX];\ninline bool chk(int i) { return i >= 0 && i < n; }\nint main()\n{\n\tm = M_MAX;\n\tfor (i = 2; i <= m; ++i)\n\t{\n\t\tif (!np[i])\n\t\t\tp[pn++] = i;\n\t\tfor (k = 0; (j = i * p[k]) <= m; ++k)\n\t\t{\n\t\t\tnp[j] = true;\n\t\t\tif (i % p[k] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tscanf(\"%d\", &n);\n\tif (n == 2)\n\t\tputs(\"4 7\\n23 10\");\n\telse\n\t{\n\t\tk = 0;\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = i & 1; j < n; j += 2)\n\t\t\t\ta[i][j] = p[k++];\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = (i & 1) ^ 1; j < n; j += 2)\n\t\t\t{\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor (k = 0; k < 4; ++k)\n\t\t\t\t\tif (chk(i + dx[k]) && chk(j + dy[k]))\n\t\t\t\t\t\ta[i][j] *= a[i + dx[k]][j + dy[k]];\n\t\t\t}\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t\tprintf(\"%lld%c\", a[i][j] * 2 + ((i ^ j) & 1), j < n - 1 ? ' ' : '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=550;\nconst int M=1LL<<30;\nconst int inf=1e9+7;\nconst LL INF=1e18;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//for(int mask=i;mask>0;mask=(mask-1)&i)\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){int s=0;while(x){s+=BIT[x];x-=x&-x;}return s;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a,LL b){LL t=1;for(;b;b>>=1,a=a*a%M)b&1?t=t*a%M:0;return t;}\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//cout<<fixed<<setprecision(12)<<ans<<endl;\n//__builtin_popcount(mask)\n\nint n,m;\nint p[8000];//prime\nLL g[N][N];\nint dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\nLL lcm(LL a,LL b){\n\treturn a*b/__gcd(a,b);\n}\nLL adj(int x,int y){\n\tLL cur=1;\n\tREP(k,4){\n\t\tint nx=x+dw[k][0],ny=y+dw[k][1];\n\t\tif(g[nx][ny]){\n\t\t\tcur=lcm(cur,g[nx][ny]);\n\t\t}\n\t}\n\treturn cur;\n}\nint main(){Accel\n\tcin>>n;m=n;\n\t\n\tvector<LL>P;\n\tfor(int i=2;i<=7919;i++)\n\t\tif(!p[i]){\n\t\t\tP.PB(i);\n\t\t\tfor(int j=i+i;j<=N;j+=i)p[j]=1;\n\t\t}\n\t//for(auto x:P)\n\t//\tcout<<x<<\" \";\n\tFOR(i,1,n)FOR(j,1,m)g[i][j]=1;\n\t\n\tFOR(i,1,n)FOR(j,1,m){\n\t\tif(i%2==j%2){\n\t\t\tg[i][j]*=P[(i+j)/2];\n\t\t\t\n\t\t\tg[i][j]*=P[(i-j+n)/2+n+1];\n\t\t}\n\t}\n\t//FOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n\tFOR(i,1,n)FOR(j,1,m)if(g[i][j]==1)g[i][j]+=adj(i,j);\n\tFOR(i,1,n){FOR(j,1,m)cout<<g[i][j]<<\" \";cout<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nvoid Fill(int i, int j) {\n\tll tmp = pri[min(min(n - i + 1, n - j + 1), min(i, j))];\n\tans[i][j] = tmp;\n\twhile (used.count(ans[i][j]))\n\t\tans[i][j] += tmp;\n\tused.insert(ans[i][j]);\n}\nstruct Node {\n\tint r, c;\n\tint Cal() const { return min(min(n - r + 1, n - c + 1), min(r, c)); }\n\tbool operator < (const Node &d) const { return Cal() < d.Cal(); }\n} todo[N * N];\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\ttodo[++tail] = (Node){i, j};\n\t\t\t}\n\tsort(todo + 1, todo + tail + 1);\n\tfor (int i = 1; i <= tail; ++i)\n\t\tFill(todo[i].r, todo[i].c);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n54ms\t4992KB\n\n*/\n#include <cstdio>\n#include <algorithm>\ntypedef long long LL;\nconst int N=505,M=8100;\n\nint P[1005];\nLL A[N][N];\n\nvoid Init()\n{\n\tstatic bool notP[M];\n\tfor(int cnt=0,i=2; cnt<1000; ++i)\n\t{\n\t\tif(!notP[i]) P[++cnt]=i;\n\t\tfor(int j=1,v; j<=cnt&&(v=i*P[j])<M; ++j)\n\t\t{\n\t\t\tnotP[v]=1;\n\t\t\tif(!(i%P[j])) break;\n\t\t}\n\t}\n}\ninline LL LCM(LL x,LL y)//longlong\n{\n\treturn x/std::__gcd(x,y)*y;\n}\n\nint main()\n{\n\tInit();\n\tint n; scanf(\"%d\",&n);\n\tif(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tfor(int i=0; i<=n+1; ++i) A[0][i]=1, A[n+1][i]=1, A[i][n+1]=A[i][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=i&1?1:2; j<=n; j+=2)\n\t\t\t/*if(!(i+j&1))*/ A[i][j]=P[i+j>>1]*P[(i-j+n+1)/2+n];\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=i&1?2:1; j<=n; j+=2)\n\t\t\t/*if(i+j&1)*/ A[i][j]=LCM(LCM(A[i-1][j],A[i][j-1]),LCM(A[i+1][j],A[i][j+1]))+1;\n\tfor(int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor(int j=1; j<=n; ++j) printf(\"%lld \",A[i][j]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long grid[1000][1000];\nint main() {\n#define int long long\n\tvector<int> sosuu;\n\tfor (int i = 2; i <= 10000; ++i) {\n\t\tint ok = 1;\n\t\tfor (int q = 2; q <= sqrt(i); ++q) {\n\t\t\tif (i % q == 0) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok == 1) continue;\n\t\tsosuu.push_back(i);\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tgrid[i][q] = 1;\n\t\t}\n\t}\n\tint now_itr = 0;\n\tfor (int i = 0; i < 1000; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i - q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tfor (int i = -1000; i < 500; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i + q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tif ((i + q) % 2 == 0) continue;\n\t\t\tint now_lcm = 1;\n\t\t\tint xe[4] = { 1,-1,0,0 };\n\t\t\tint ye[4] = { 0,0,-1,1 };\n\t\t\tREP(j, 4) {\n\t\t\t\tint x = xe[j] + i;\n\t\t\t\tint y = ye[j] + q;\n\t\t\t\tif (x >= 0 && x < 500 && y >= 0 && y < 500) {\n\t\t\t\t\tint hoge = gcd(now_lcm, grid[x][y]);\n\t\t\t\t\tnow_lcm /= hoge;\n\t\t\t\t\tnow_lcm *= grid[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid[i][q] = now_lcm + 1;\n\t\t\tassert(now_lcm <= 1e15);\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tREP(q, n) {\n\t\t\tif (q != 0) cout << \" \";\n\t\t\tcout << grid[i][q];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2018 Mstdream\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=505;\nint n,is[N*N],pr[N*N],cnt;\nLL a[N][N];\nmap<int,int>x,y;\nint main(){\n\tfor(int i=2;i<=100000;i++){\n\t\tif(!is[i]){\n\t\t\tpr[++cnt]=i;\n\t\t\tfor(int j=i+i;j<=100000;j+=i)is[j]=1;\n\t\t}\n\t}\n\tcin>>n;\n\tcnt=0;\n\tfor(int i=0;i<=n+n+2;i+=2)x[i]=pr[++cnt];\n\tint sta=-n-1,end=n+1;\n\tif(end&1)sta--,end++;\n\tfor(int i=sta;i<=end;i+=2)y[i]=pr[++cnt];\n\tfor(int i=0;i<=n+1;i++){\n\t\tfor(int j=0;j<=n+1;j++){\n\t\t\tif((i+j)%2==0)a[i][j]=x[i+j]*y[i-j];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1)a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n\t\t\tprintf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=505;\nconst int M=4*N;\nconst int S=10000;\nint pr[M],psz;\nbool sieve[S];\nll val[N][N];\nvector<pair<int,int> > id;\nint Find(pair<int,int> x){ return lower_bound(id.begin(),id.end(),x)-id.begin()+1;}\nint main()\n{\n\tint i,j;\n\tfor(i=2;i<S;i++) if(!sieve[i]){ pr[++psz]=i;for(j=i;j<S;j+=i) sieve[j]=1;}\n\tint n;\n\tscanf(\"%i\",&n);\n\tif(n==2) return 0*printf(\"4 7\\n23 10\\n\");\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n\t\tint a=i+j,b=i-j;\n\t\tid.pb(mp(1,a));\n\t\tid.pb(mp(2,b));\n\t}\n\tsort(id.begin(),id.end());\n\tid.erase(unique(id.begin(),id.end()),id.end());\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n        int a=Find(mp(1,i+j));\n        int b=Find(mp(2,i-j));\n        val[i][j]=(ll)pr[a]*pr[b];\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if(!((i+j)&1))\n\t{\n\t\tval[i][j]=1;\n\t\tif(i-1>0 || j+1<=n) val[i][j]*=pr[Find(mp(1,i-j-1))];\n\t\tif(i+1<=n || j-1>0) val[i][j]*=pr[Find(mp(1,i-j+1))];\n\t\tif(i-1>0 || j-1>0) val[i][j]*=pr[Find(mp(2,i+j-1))];\n\t\tif(i+1<=n && j+1<=n) val[i][j]*=pr[Find(mp(2,i+j+1))];\n\t\tval[i][j]++;\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) printf(\"%lld%c\",val[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\ntemplate <typename T> void shuffle(vector<T> &v) {\n    rep3(i, v.size() - 1, 1) { swap(v[i], v[rnd(i)]); }\n}\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 700) t++;\n    rep(i, n) p.eb(P[t++]);\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * (i + 1) / (i - 1 ? i - 1 : 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * i;\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * (i + 2) / i + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i + 1);\n        }\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nbool np[10010]; int pri[5010],cnt;\nvoid getprime(int n)\n{\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!np[i])\tpri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=n;j++)\n\t\t{\n\t\t\tnp[pri[j]*i]=1;\n\t\t\tif(i%pri[j]==0)\tbreak;\n\t\t}\n\t}\n}\n#define N 510\nll a[N][N];\nll lcm(ll x,ll y){if(!x||!y)return x+y;return x/__gcd(x,y)*y;}\nint main()\n{\n\tgetprime(1e4); int n=read();\n\tif(n==2)\treturn puts(\"4 7\\n23 10\"),0;\n\tfor(int i=1;i<=n;i++)\tfor(int j=1;j<=n;j++)\n\t\tif(!((i+j)&1))\ta[i][j]=1ll*pri[i+j>>1]*pri[n+(i-j>>1)+(n+1>>1)];\n\tfor(int i=1;i<=n;i++)\tfor(int j=1;j<=n;j++)\n\t\tif((i+j)&1)\ta[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++,puts(\"\"))\tfor(int j=1;j<=n;j++)\n\t\tprintf(\"%lld \",a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\nusing namespace std;\n\n#define NMAX 502\n#define DIM 7920\n\nint d[DIM], p[DIM];\nlong long sol[NMAX][NMAX];\n\nvoid ciur(int n) {\n    for (int i = 2; i <= n; i++) {\n        if (d[i] == 0) {\n            p[++p[0]] = i;\n            for (int j = i + i; j <= n; j += i) {\n                d[j] = 1;\n            }\n        }\n    }\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nlong long lcm(vector <long long>& v) {\n    long long l = 1;\n    for (const long long x : v) {\n        if (x == 0)\n            continue;\n        long long d = gcd(l, x);\n        l = l * x / d;\n\n    }\n    return l;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    if (n == 2) {\n        cout << \"4 7\\n23 10\\n\";\n        return 0;\n    }\n    ciur(DIM - 1);\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            sol[i][j] = 1;\n        }\n    }\n\n    int cnt = 1;\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col > n)\n                break;\n            sol[i][col] *= p[cnt];\n            col++;\n        }\n        cnt++;\n    }\n\n    for (int i = 3; i <= n; i += 2) {\n        int lin = i;\n        for (int j = 1; j <= n; j++) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int j = 1; j <= n; j += 2) {\n        int col = j;\n        for (int i = 1; i <= n; i++) {\n            if (col <= 0)\n                break;\n            sol[i][col] *= p[cnt];\n            col--;\n        }\n        cnt++;\n    }\n\n    for (int i = n; i > 1; i -= 2) {\n        int lin = i;\n        for (int j = n; j >= 1; j--) {\n            if (lin > n)\n                break;\n            sol[lin][j] *= p[cnt];\n            lin++;\n        }\n        cnt++;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) % 2 == 0)\n                continue;\n            vector <long long> v = {sol[i - 1][j], sol[i + 1][j], sol[i][j - 1], sol[i][j + 1]};\n            sol[i][j] = lcm(v) + 1;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << sol[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001];\nint vis[100005], prm[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] =\n                1ll * prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; ++j)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j]));\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nstd::vector<int> Eratosthenes(int n) {\n\tstd::vector<bool> num(n, true);\n\tstd::vector<int> prime;\n\tnum[0] = false;\n\tfor (int i = 0; i*i < n; ++i) {\n\t\tif (num[i]) {\n\t\t\tfor (int j = 2; (i + 1)*j <= n; ++j) {\n\t\t\t\tnum[(i + 1)*j - 1] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (num[i]) {\n\t\t\tprime.push_back(i + 1);\n\t\t}\n\t}\n\treturn prime;\n}\n\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a%b) : a;\n}\n\nconstexpr int N = 500;\nint a[N][N];\nint b[N][N];\nint c[N][N];\n\nint dy4[] = { -1, 0, 1, 0 };\nint dx4[] = { 0, 1, 0, -1 };\n\nsigned main() {\n\tINIT;\n\n\tauto pv(Eratosthenes(100000));\n\n\tint p = 0;\n\t{\n\t\t{\n\t\t\tint j = 0;\n\t\t\tRREP(i, N) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\ta[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tFOR(j, 1, N) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\ta[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\tFOR(i, 1, N) FOR(j, 1, N) a[i][j] = a[i - 1][j - 1];\n\t}\n\t{\n\t\t{\n\t\t\tint j = N - 1;\n\t\t\tRREP(i, N) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\tb[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tRREP(j, N - 1) {\n\t\t\t\tif ((i + j) & 1) continue;\n\t\t\t\tb[i][j] = pv[p++];\n\t\t\t}\n\t\t}\n\t\tFOR(i, 1, N) REP(j, N - 1) b[i][j] = b[i - 1][j + 1];\n\t\tREP(i, N) REP(j, N) c[i][j] = a[i][j] * b[i][j];\n\t}\n\n\tREP(i, N) REP(j, N) {\n\t\tif (a[i][j] != 0) continue;\n\t\tint t = 1;\n\t\tREP(d, 4) {\n\t\t\tint dy = i + dy4[d];\n\t\t\tint dx = j + dx4[d];\n\t\t\tif (!IN(0, dy, N) || !IN(0, dx, N)) continue;\n\t\t\tif (dy4[d] == 0) t *= a[dy][dx];\n\t\t\telse t *= b[dy][dx];\n\t\t}\n\t\tc[i][j] = t + 1;\n\t}\n\n\tVAR(int, n);\n\tstd::set<int> set;\n\tREP(i, n) REP(j, n) {\n\t\tassert(c[i][j] <= 1000000000000000);\n\t\tset.insert(c[i][j]);\n\t\tOUT(c[i][j])SPBR(j, n);\n\t}\n\tassert(set.size() == n * n);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// PRNG {{{\ntemplate<class T, T x1, T x2, T x3, int y1, int y2, int y3>\nstruct PRNG {\n    using S = typename make_signed<T>::type;\n    T s;\n    PRNG() {\n        s = 0;\n    }\n    PRNG(T _s) : s(_s) {}\n    T next() {\n        T z = (s += x1);\n        z = (z ^ (z >> y1)) * x2;\n        z = (z ^ (z >> y2)) * x3;\n        return z ^ (z >> y3);\n    }\n    T next(T n) { return next() % n; }\n    S next(S l, S r) { return l + next(r - l + 1); }\n    T operator()() { return next(); }\n    T operator()(T n) { return next(n); }\n    S operator()(S l, S r) { return next(l, r); }\n    static T gen(T s) { return PRNG(s)(); }\n    template<class U>\n    void shuffle(U first, U last) {\n        size_t n = last - first;\n        for (size_t i = 0; i < n; i++) swap(first[i], first[next(i + 1)]);\n    }\n};\n\nusing R32 = PRNG<uint32_t, 0x9E3779B1, 0x85EBCA6B, 0xC2B2AE35, 16, 13, 16>;\nR32 r32;\n\nusing R64 = PRNG<uint64_t, 0x9E3779B97F4A7C15, 0xBF58476D1CE4E5B9, 0x94D049BB133111EB, 30, 27, 31>;\nR64 r64;\n// }}}\n\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\ninline bool bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nVI ps;\nbool is_prime( int x ) {\n    for ( int i=2; i*i<=x; i++ ) if ( x%i==0 ) return 0;\n    return 1;\n}\n\nLL lcm( LL x, LL y ) {\n    assert(y!=0);\n    return x/__gcd(x,y)*y;\n}\n\nconst int N=500;\nconst LL U=1e15;\nLL a[N][N];\nvoid main() {\n    REP1(i,2,10000) if ( is_prime(i) ) ps.PB(i);\n    dump(SZ(ps));\n    set<LL> v;\n    auto add=[&]( LL x ) {\n        assert(!v.count(x));\n        v.insert(x);\n    };\n    // r64.s=chrono::high_resolution_clock::now().time_since_epoch().count() & numeric_limits<uint64_t>::max();\n    // r64.shuffle(ps.begin(),ps.begin()+2*N);\n    REP(i,N) {\n        REP(j,N) if ( (i+j)%2==0 ) {\n            LL x=1;\n            x*=ps[(i+j)/2+1];\n            x*=ps[(i-j+N)/2+1];\n            if ( i+j<i-j+N ) x*=2;\n            a[i][j]=x;\n            add(x);\n        }\n    }\n    REP(i,N) REP(j,N) if ( (i+j)%2==1 ) {\n        LL t=1;\n        REP(k,4) {\n            int x=i+dx[k];\n            int y=j+dy[k];\n            if ( x<0 || x>=N || y<0 || y>=N ) continue;\n            t=lcm(t,a[x][y]);\n        }\n        assert(t<=U);\n        // dump(i,j,t);\n        LL x=t+1;\n        while ( v.count(x) ) {\n            x+=t;\n            assert(x<=U);\n        }\n        add(x);\n        a[i][j]=x;\n    }\n    int n;\n    R(n);\n    REP(i,n) W(vector<LL>(a[i],a[i]+n));\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline ll lcm(ll x,ll y) {\n  return x/__gcd(x,y)*y;\n}\n\nint prime[10005];\nbool check[10005];\n\nvoid pre(int n) {\n  int tot=0;\n  for(int i=2;i<=n;i++) {\n  \tif (!check[i]) prime[++tot]=i;\n  \tfor(int j=1;j<=tot&&i*prime[j]<=n;j++) {\n  \t\tcheck[i*prime[j]]=1;\n  \t\tif (i%prime[j]==0) break;\n\t  }\n  }\n}\n\nll ans[505][505],val1[1005],val2[1005];\n\nint main() {\n  pre(1e4);\n  int n;\n  scanf(\"%d\",&n);\n  if (n==2) {\n  \tputs(\"4 7\");\n  \tputs(\"23 10\");\n  \treturn 0;\n  }\n  int cnt=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      if ((i+j)&1) {\n      \tif (!val1[i-j+n]) val1[i-j+n]=prime[++cnt];\n      \tans[i][j]=val1[i-j+n];\n\t  }\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      if ((i+j)&1) {\n      \tif (!val2[i+j]) val2[i+j]=prime[++cnt];\n      \tans[i][j]*=val2[i+j];\n\t  }\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      if (!((i+j)&1)) {\n      \tans[i][j]=1;\n      \tif (i>1) ans[i][j]=lcm(ans[i][j],ans[i-1][j]);\n      \tif (i<n) ans[i][j]=lcm(ans[i][j],ans[i+1][j]);\n      \tif (j>1) ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n      \tif (j<n) ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n      \tans[i][j]++;\n\t  }\n  for(int i=1;i<=n;i++) {\n    for(int j=1;j<=n;j++) printf(\"%lld \",ans[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint p[1010],b[10010],t,n;\nint main(){\n\tp[0]=1;p[t+1]=1;\n\tfor(int i=2;i<=7919;++i){\n\t\tif(!b[i])p[++t]=i;\n\t\tif(t==500)p[++t]=1;\n\t\tfor(int j=1;j<=p[0]&&i*p[j]<=7919;++j)if(j^501){\n\t\t\tb[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i+j&1){\n\t\t\t\tprintf(\"%lld\",1ll*p[i+j>>1]*p[i+j+1>>1]*p[501+(n+2-j+i>>1)]*p[501+(n-j+i>>1)]+1);\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\",p[i+j>>1]*p[501+(n+1-j+i>>1)]);\n\t\t\t}\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\ninline int read(){char ch=gc;int w=1,s=0;while(!isdigit(ch)){if(ch=='-') w=-1;ch=gc;};while(isdigit(ch)){s=s*10+ch-'0';ch=gc;} return w*s;}\nll ANS[550][550];\nll lcm(ll a,ll b){return (ll)((__int128)a*b/__gcd(a,b));}\nint N,np[101010],prime[100010],cnt;\nint Hang[100010],Lie[100001];\ninline void Init(int n)\n{\n\tnp[1]=1;\n\tfor(rint i=2;i<=n;++i){\n\t\tif(!np[i]) prime[++cnt]=i;\n\t\tfor(rint j=1;j<=cnt&&i*prime[j]<=n;++j){\n\t\t\tnp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}int dx[]={0,1,0,-1,0},dy[]={0,0,1,0,-1};\nint main()\n{\n\tN=read();N+=2;\n\tInit(100100);\n\tfor(rint i=1;i<=N;++i) Hang[i]=prime[i],Lie[i]=prime[2*N-i+1];\n\tfor(rint i=1;i<=N;++i)\n\t{\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))\n\t\t\tANS[i][j]=1ll*Hang[i]*Lie[j];\n\t\t}\n\t}\n\tfor(rint i=1;i<=N;++i){\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!ANS[i][j])\n\t\t\t{\n\t\t\t\tll res=1;\n\t\t\t\tfor(rint d=1;d<=4;++d)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni<1||nj<1||ni>N||nj>N) continue;\n\t\t\t\t\tres=lcm(ANS[ni][nj],res);\n\t\t\t\t}\n\t\t\t\tANS[i][j]=res+1;\n\t\t\t}\n\t\t\tif(i>1&&i<N&&j>1&&j<N)\n\t\t\tcout<<ANS[i][j]<<\" \";\n\t\t}\n\t\tif(i>1&&i<N)\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 500001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nV<pin> uni(V<pin> &v) {\n\tsor(v);\n\tV<pin> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tint n; cin >> n;\n\tvel prime(0);\n\tint mod = 510;\n\tfor (int i = 2; i < 10000; i++) {\n\t\tif (is_prime(i)) { prime.push_back(i); }\n\t}\n\tvvel ans(n, vel(n,1));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tint x = (i + j) / 2;\n\t\t\t\tint y = per((i - j) / 2, mod);\n\t\t\t\tans[i][j] = prime[x] * prime[y];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tj--;\n\t\t\t\tint x = (i + j) / 2;\n\t\t\t\tint y = per((i - j) / 2, mod);\n\t\t\t\tans[i][j+1] = prime[x] * prime[y];\n\t\t\t\tj += 2;\n\t\t\t\tx = (i + j) / 2;\n\t\t\t\ty = per((i - j) / 2, mod);\n\t\t\t\tans[i][j-1] *= prime[x] * prime[y];\n\t\t\t\tj--;\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t\tcout << ans[i][j];\n\t\t\tif (j < n - 1) { cout << \" \"; }\n\t\t\telse { cout << endl; }\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\t/*random_shuffle(vec1.begin(), vec1.end());\n\trandom_shuffle(vec2.begin(), vec2.end());*/\n\n\tqueue<pair<ll, ll>> q;\n\tq.push({ 0, 0 });\n\n\tused[0][0] = 1;\n\tvector<pair<ll, ll>> dir1 = { {2, 0}, {0, 2} };\n\twhile (!q.empty()) {\n\t\tpair<ll, ll> v = q.front();\n\t\tq.pop();\n\n\t\tans[v.first][v.second] = vec1.front();\n\t\tvec1.pop_front();\n\n\t\tfor (auto cur : dir1) {\n\t\t\tif (!used[v.first + cur.first][v.second + cur.second] && v.first + cur.first < n && v.second + cur.second < n) {\n\t\t\t\tq.push({v.first + cur.first, v.second + cur.second});\n\t\t\t\tused[v.first + cur.first][v.second + cur.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<ll, ll>> dir2 = { {2, 0}, {0, 2} };\n\tq.push({ 1, 1 });\n\tused[1][1] = 1;\n\twhile (!q.empty()) {\n\t\tpair<ll, ll> v = q.front();\n\t\tq.pop();\n\n\t\tans[v.first][v.second] = vec2.back();\n\t\tvec2.pop_back();\n\n\t\tfor (auto cur : dir2) {\n\t\t\tif (!used[v.first + cur.first][v.second + cur.second] && v.first + cur.first < n && v.second + cur.second < n) {\n\t\t\t\tq.push({ v.first + cur.first, v.second + cur.second });\n\t\t\t\tused[v.first + cur.first][v.second + cur.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include \"bits/stdc++.h\"\n\n#include <unordered_map>\n\n//#include <iostream>//POJ\n//#include <vector>\n//#include <string>\n//#include <iomanip>\n//#include <math.h>\n//#include <algorithm>\n//#include <cstring>\nusing namespace std;\n#define setc cin.tie(0);ios::sync_with_stdio(0)\n#define dd(n) cout<<fixed<<setprecision(n)\n#define inp(x) (cin>>x,x)\n#define repi(i,a,b) for(int i=(a), i##_len=(b); i<i##_len; ++i)\n#define rep(i,n) repi(i,0,n)\n#define repi_(i,a,b) for(int i=(a), i##_len=(b); i<=i##_len; ++i)\n#define rep_(i,n) repi_(i,0,n)\n#define repir(i,a,b) for(int i=(a)-1, i##_first=(b); i>=i##_first; --i)\n#define repr(i,n) repir(i,n,0)\n#define repir_(i,a,b) for(int i=(a), i##_first=(b); i>=i##_first; --i)\n#define repr_(i,n) repir_(i,n,0)\n#define all(x) (x).begin(),(x).end()\n#define vsort(v) sort((v).begin(), (v).end())\n#define gsort(v) tsort(v); reverse((v).begin(), (v).end())\n#define vrev(v) reverse((v).begin(), (v).end())\n//template<typename T> T vpop(vector<T> *v) {\n//\tT res = v->back();\n//\tv->pop_back();\n//\treturn res;\n//}\n//char vpop(string *v) {\n//\tchar res = v->back();\n//\tv->pop_back();\n//\treturn res;\n//}\n#define siz(v) ((int)(v).size())\n#define ers(v, n) (v).erase((v).begin() + n)\n#define cnt(v, n) count(all(v), n)\n#define vmin(v) *min_element(v.begin(), v.end())\n#define vmax(v) *max_element(v.begin(), v.end())\n#define contain(q) !q.empty()\n#define cont(q) !q.empty()\n//#define qpop(q, a, b) a=q.back().first;b=q.back().second;q.pop()\n//#define pqpop(p, a, b) a=q.top().first;b=q.top().second;q.pop()\n#define el \"\\n\"\n#define sp \" \"\n#define pi 3.14159265358979\n#define co(x) cout<<x<<el\n#define coc(c, a, b) if(c)co((a));else co((b))\n#define cosp(x) cout<<(x)<<' '\n#define YES(c) coc(c,\"YES\", \"NO\")\n#define Yes(c) coc(c,\"Yes\", \"No\")\n#define yes(c) coc(c,\"yes\", \"no\")\n#define POSSIBLE(c) coc(c, \"POSSIBLE\", \"IMPOSSIBLE\")\n#define Possible(c) coc(c, \"Possible\", \"Impossible\")\n#define possible(c) coc(c, \"possible\", \"impossible\")\n#define inf INT_MAX\n#define wildcard(T) numeric_limits<T>::min()\n\n#define pb push_back\n#define pq priority_queue\n#define np next_permutation\n\n#ifdef tqktmp_2\n#define gc() getchar(); getchar()\n#else\n#define gc() 1\n#endif\nconst unsigned int bf0 = (1 << 0);\nconst unsigned int bf1 = (1 << 1);\nconst unsigned int bf2 = (1 << 2);\nconst unsigned int bf3 = (1 << 3);\nconst unsigned int bf4 = (1 << 4);\nconst unsigned int bf5 = (1 << 5);\nconst unsigned int bf6 = (1 << 6);\nconst unsigned int bf7 = (1 << 7);\n\n//#define lint long long\ntypedef long long lint;\ntypedef vector<int> ivec; typedef vector<string> svec;\ntypedef vector<lint> livec;\ntypedef vector<vector<int>> ivvec;\ntypedef pair<int, int> P;\n\nconst int\ndx8[8] ={ 0,1,1,1,0,-1,-1,-1 },\ndy8[8] ={ 1,1,0,-1,-1,-1,0,1 },\ndx9[9] ={ 0,1,1,1,0,0,-1,-1,-1 },\ndy9[9] ={ 1,1,0,-1,0,-1,-1,0,1 },\ndx4[4] ={ 0,1,0,-1 },\ndy4[4] ={ 1,0,-1,0 };\n\ntemplate<class T>inline bool maxi(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>inline bool mini(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n#define mod(a,b) (a<0?a%b+abs(b):a%b)\n#define cl(a,b) (a+b-1/b)\n\nint main(){\n\tsetc;\n\n\tlint first=1;\n\tlint n;cin>>n;\n\trep(i, n){\n\t\trep(j, n){\n\t\t\tcout<<first+j<<sp;\n\t\t}cout<<el;\n\t\tfirst+=1001;\n\t}\n\tgc();\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[505][505],x[505],y[505];\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){\n\tif(!a)return b;\n\tif(!b)return a;\n\treturn a/gcd(a,b)*b;\n}\nint las=1;\nint next_p(){\n\twhile(++las){\n\t\tbool ok=1;\n\t\tfor(int i=2;i*i<=las;++i)if(!(las%i))ok=0;\n\t\tif(ok)return las;\n\t}\n\treturn 114514;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(n);\n\tfor(int i=1;i<=n;++i){\n\t\tx[i]=next_p();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ty[i]=next_p();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(!((i+j)&1)){\n\t\t\ta[i][j]=x[(i+j)>>1]*y[(i-j+n+1)>>1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i][j-1],lcm(a[i+1][j],a[i][j+1])));\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)write(a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\nll a[1005][1005];\nint n;\nint pri[10005],tot;\nbool mk[10005];\nint lcm(int a,int b) {\n\tif((!a)||(!b)) return a+b;\n\treturn 1ll*a*b/__gcd(a,b);\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=10000;i++) {\n\t\tif(!mk[i]) { pri[++tot]=i; }\n\t\tif(tot==1000) break;\n\t\tfor(int j=1;j<=tot&&1ll*pri[j]*i<=10000;j++) {\n\t\t\tint k = pri[j] * i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==0) a[i][j] = pri[(i + j) / 2] * pri[n+((i-j)/2+(n+1)/2)];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==1) a[i][j] = ( lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]) ) + 1;\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v((i + j - 2) / 2)] * p[v((1500 + i - j) / 2)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v((i + j) / 2)] * p[v((1500 + i - j) / 2)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    cin >> N;\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)cout << a.at(i, j) << \" \";\n        cout << a.at(i, N - 1) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nint ip(int x)\n{\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return 0;\n    return x>1;\n}\nconst int Q=1<<16,P=1<<9;\nint pn[Q];\nll als[P][P];\nll Lcm(ll a,ll b)\n{return (a==0||b==0)?a|b:a/__gcd(a,b)*b;}\nll h[Q],z[Q];\nint main()\n{\n    int tp=0,n;\n    for(int i=2;tp<1000;i++)\n        if(ip(i))pn[++tp]=i;\n    scanf(\"%d\",&n);\n    if(n==2)\n        return 0&printf(\"4 7\\n23 10\");\n    tp=0;\n    for(int i=1-n;i<=n-1;i++)\n        if(i&1^1)h[i+n]=pn[++tp];\n    for(int i=2;i<=(n<<1);i++)\n        if(i&1^1)z[i]=pn[++tp];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1^1)als[i][j]=h[j-i+n]*z[i+j];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1)als[i][j]=Lcm(Lcm(als[i+1][j],als[i-1][j]),Lcm(als[i][j+1],als[i][j-1]))+1LL;\n    ll mxx=0;\n    for(int i=1;i<=n;i++,puts(\"\"))\n        for(int j=1;j<=n;j++)\n            printf(\"%lld \",als[i][j]);\n    return 0;\n}\n/*\n412675878567959\n1000000000000000\n*/"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\nmt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector<ll>divisor_enum(ll n){\n  vector<ll>ret;\n  for(ll i=1;i*i<=n;i++){\n    if(n%i==0){\n      if(i*i==n)ret.PB(i);\n      else{\n        ret.PB(i);\n        ret.PB(n/i);\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  auto v=vec(n,n,0LL);\n  set<ll>st;\n  st.insert(0);\n  rep(i,0,2*n-1){\n    if(~i&1)continue;\n    ll cnt=1;\n    const ll sta=500;\n    ll k=i/2+sta;\n    if((i/2)&1)k=2*sta-(k-sta);\n    rep(j,0,n){\n      ll x,y;\n      if((i/2)&1)x=j;else x=n-j-1;\n      y=i-x;\n      if(x<0||x>=n||y<0||y>=n)continue;\n      while(st.count(cnt*k))cnt++;\n      v[x][y]=cnt*k;\n      st.insert(v[x][y]);\n    }\n  }\n  //cout<<*st.rbegin()<<endl;\n  //debug(v,n,n);\n  ll lim=1e15;\n  rep(i,0,n)rrep(j,0,n){\n    if((i+j)&1)continue;\n    ll t=1,tg=0;\n    rep(o,0,4){\n      ll x=i+dx[o],y=j+dy[o];\n      if(x<0||y<0||x>=n||y>=n)continue;\n      t=t/gcd(t,v[x][y])*v[x][y];\n      //tg=gcd(tg,v[x][y]);\n    }\n    rep(o,1,500){\n      //cout<<t spa o<<endl;\n      if(st.count(t*o))continue;\n      v[i][j]=t*o;\n      st.insert(v[i][j]);\n      //assert(v[i][j]);\n      break;\n    }\n  }\n  debug(v,n,n);\n  rep(i,0,n)rep(j,0,n){\n    chmax(res,v[i][j]);\n    //if(v[i][j]==0)cout<<i spa j<<endl;\n  }\n  //cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 1003, K = 10003, d[2][4] = {{0, 1, 0, -1}, {1, 0, -1, 0}};\nint n, pri[N << 1], tot;\nbool notp[K];\nLL a[N][N];\ninline void init(int m){\n\tnotp[0] = notp[1] = 1;\n\tfor(Rint i = 2;;i ++){\n\t\tif(!notp[i]){pri[++ tot] = i; if(tot == m) break;}\n\t\tfor(Rint j = 1;j <= tot && i * pri[j] <= 10000;j ++){\n\t\t\tnotp[i * pri[j]] = true;\n\t\t\tif(!(i % pri[j])) break;\n\t\t}\n\t}\n}\ninline LL gcd(LL a, LL b){return b ? gcd(b, a % b) : a;}\ninline LL lcm(LL a, LL b){return a / gcd(a, b) * b;}\nint main(){\n\tif(n == 2){\n\t\tputs(\"2 3\"); puts(\"5 4\"); return 0;\n\t}\n\tscanf(\"%d\", &n); init(2 * n);\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tfor(Rint j = 1;j <= n;j ++) if(!(i + j & 1))\n\t\t\ta[i][j] = pri[i + j >> 1] * pri[n + (n + i - j + 1 >> 1)];\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tfor(Rint j = 1;j <= n;j ++){\n\t\t\tif(!a[i][j]){\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor(Rint k = 0;k < 4;k ++){\n\t\t\t\t\tint dx = i + d[0][k], dy = j + d[1][k];\n\t\t\t\t\tif(dx >= 1 && dx <= n && dy >= 1 && dy <= n)\n\t\t\t\t\t\ta[i][j] = lcm(a[i][j], a[dx][dy]);\n\t\t\t\t}\n\t\t\t\t++ a[i][j];\n\t\t\t}\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN=1010,MAXSIZ=100100;\nint vis[MAXSIZ]={1,1},prime[MAXSIZ],cnt;\nint a[MAXN][MAXN],n;\ninline void GetPrime()\n{\n\tfor(int i=2;;i++)\n\t{\n\t\tif(!vis[i]) prime[++cnt]=i;\n\t\tif(cnt==1000) break;\n\t\tfor(int j=1;j<=cnt&&(i*prime[j]<=100000);j++)\n\t\t{\n\t\t\tvis[i*prime[j]]=1;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n\treturn;\n}\ninline int __lcm(int x,int y)\n{\n\tif(!(x&&y)) return x|y;\n\treturn x/__gcd(x,y)*y;\n}\nsigned main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tGetPrime();\n\tcin>>n;\n\tif(n==2) return cout<<\"4 7\\n 23 10\"<<endl,0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!((i+j)&1)) a[i][j]=prime[(i+j)>>1]*prime[n+(i-j)/2+((n+1)>>1)];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!a[i][j]) a[i][j]=__lcm(__lcm(a[i-1][j],a[i][j-1]),__lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) cout<<a[i][j]<<(j==n?\"\\n\":\" \");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=0;i<=n;i++){\ntot=n-i;\nfor(int j=i;j<=tot;j++)ans[i+j][j-i]*=prime[i+n+(n>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 505;\nconst int MP = 100005;\n\nint n, pnum;\nll x[MX][MX], prm[MP];\nbool vis[MP];\n\nll lcm(ll x, ll y)\n{\n\treturn x*y/__gcd(x, y);\n}\n\nvoid sieve()\n{\n\tprm[0] = 1;\n\tfor(int i=2; i<MP; i++)\n\t{\n\t\tif(!vis[i]) prm[++pnum] = i;\n\t\tfor(int j=1; j<=pnum; j++)\n\t\t{\n\t\t\tif(prm[j]*i >= MP) break;\n\t\t\tvis[prm[j]*i] = 1;\n\t\t\tif(i%prm[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsieve();\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<=n+1; i++) x[i][0] = x[i][n+1] = x[0][i] = x[n+1][i] = 1;\n\tint t = 0;\n\tfor(int i=0; i<=n+1; i++)\n\t\tfor(int j=0; j<=n+1; j++)\n\t\t\tif((i&1) == (j&1))\n\t\t\t\tx[i][j] = prm[(i+j)/2] * prm[(i-j)/2+n+5+(n+1)/2];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(!x[i][j])\n\t\t\t\tx[i][j] = x[i-1][j] * x[i+1][j] + 1;\n\tll mxv = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tprintf(\"%lld \", x[i][j]), mxv = max(mxv, x[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 505, MAXP = 10005;\nint vis[MAXP], p[MAXN], q[MAXN], n = 500;\nLL mp[MAXN][MAXN];\nvoid judge(LL x, LL y) {\n\tif (x < y) swap(x, y);\n\tassert(x % y == 1);\n}\n\nint main() {\n\tint R = 0, C = n;\n\tfor (int i = 2; i < MAXP; i++) if (!vis[i]) {\n\t\tif (R < n) p[R + 1] = p[R + 2] = i, R += 2;\n\t\telse if (C > 0) q[C] = q[C - 1] = i, C -= 2;\n\t\tfor (int j = i + i; j < MAXP; j += i) vis[j] = 1;\n\t}\n\tp[0] = q[0] = p[n + 1] = q[n + 1] = 1;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = 1; j <= n; j++) {\n\t\tLL cur = 0;\n\t\tif ((i + j) & 1) {\n\t\t\tcur = p[i] * q[j];\n\t\t\tif (~i & 1) cur <<= 1;\n\t\t} else {\n\t\t\tcur = (LL)p[i - 1] * p[i + 1] * q[j - 1] * q[j + 1] * 2;\n\t\t\tif (i & 1) cur <<= 1;\n\t\t\t++cur;\n\t\t}\n\t\tmp[i][j] = cur;\n\t\tassert(cur <= 1e15);\n\t\tif (i > 1) judge(mp[i][j], mp[i - 1][j]);\n\t\tif (j > 1) judge(mp[i][j], mp[i][j - 1]);\n\t}\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++, puts(\"\"))\n\tfor (int j = 1; j <= n; j++) printf(\"%lld \", mp[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n\nconst int maxn = 250000 + 10;\nconst int maxl = 500 + 10;\ntypedef long long ll;\nbool notprime[maxn];\nll prime[maxn], primecnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxn;i++){\n\t\tif(!notprime[i]) prime[primecnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxn && j < primecnt;j++){\n\t\t\tll t = i * prime[j];\n\t\t\tnotprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\nll a[maxl][maxl];\nvoid solve(int n){\n\tfor(int i = 0;i <= n + 1;i++) for(int j = 0;j <= n + 1;j++) a[i][j] = 1; \n\tint cnt = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 == 1) a[i][j] = prime[cnt++]; \n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\tll x = a[i][j - 1] * a[i][j + 1] * a[i - 1][j] * a[i + 1][j];\n\t\t\t\ta[i][j] = x;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tsieve();\n\tint n;\n\tscanf(\"%d\",&n);\n\tsolve(n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%lld%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fr(i, n) for (int i = 0; i < n; i++)\n#define pb push_back\n#define frab(i, a, b) for (int i = a; i < b; i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-9;\nconst int N = 1e3 + 10;\n\nll a[N][N];\n\nvector <ll> primes;\n\nbool prime(int x) {\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\nll f(int i, int j, int n) {\n    ll cur = 1;\n    if (i)\n        cur *= (a[i - 1][j]);\n    if (i + 1 < n)\n        cur *= (a[i + 1][j]);\n    if (j)\n        cur *= (a[i][j - 1]);\n    if (j + 1 < n)\n        cur *= (a[i][j + 1]);\n    return cur + 1;\n}\n\nint main() {\n    //freopen(\"a.in\", \"r\", stdin);\n    int n;\n    scanf(\"%d\", &n);\n    int i = 2;\n    while (primes.size() < 4 * n + 10)\n        if (prime(i++))\n            primes.pb(i - 1);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if ((i + j) % 2 == 0) {\n                a[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + n / 2 + n];\n            }\n    fr(i, n)\n        fr(j, n)\n            if ((i + j) % 2)\n                a[i][j] = f(i, j, n);\n    fr(i, n)\n        fr(j, n)\n            cout << a[i][j] << (j == n - 1 ? \"\\n\" : \" \");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <set>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 510;\nint n;\n\nll ans[N][N];\n\nset<ll> s;\n\nll gcd(ll x, ll y) {\n\twhile(y) {\n\t\tll t = y;\n\t\ty = x%y;\n\t\tx = t;\n\t}\n\treturn x;\n}\n\nll lcm(ll x, ll y) {\n\treturn x/gcd(x,y)*y;\n}\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\n\tll cur=2;\n\tfor(i=0; i<=n; i+=4) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\ti-=2; if(i>n) i-=4;\n\twhile(i>0) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t\ti-=4;\n\t}\n\n\tfor(int i=1; i<n; i+=2) {\n\t\tfor(int j=0; j<=n; j+=2) {\n\t\t\tll temp = lcm(ans[i-1][j], ans[i+1][j]);\n\t\t\tll t = temp+1;\n\t\t\twhile(s.count(t)) t+=temp;\n\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\n\t\tfor(int j=1; j<n; j+=2) {\n\t\t\tll temp = lcm(lcm(ans[i-1][j], ans[i+1][j]), lcm(ans[i][j-1], ans[i][j+1]));\n\t\t\tll t = temp+1;\n\n\t\t\twhile(s.count(t)) t+=temp;\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=0; j<n; j++) printf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define _ << \" \" <<\n#define sz(x) (int)x.size()\n#define pb(x) push_back(x)\n\ntypedef long long ll;\ntypedef pair<int, int> point;\n\nconst int MAXN = 505;\nconst int MAX = 5e5;\n\nll n;\nll a[MAXN][MAXN];\nvector <int> prime;\nbool bio[MAX];\n\nll gcm(ll a, ll b){\n    return a / __gcd(a, b) * b;\n}\n\nvoid sito(){\n    FOR(i, 2, MAX){\n        if(bio[i]) continue;\n\n        prime.pb(i);\n\n        for(int j = i; j < MAX; j += i){\n            bio[j] = true;\n        }\n    }\n}\n\nint cnt;\n\nvoid diagonala1(){\n    int x = 0, y = 0;\n\n    while(y < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] = prime[cnt];\n            nx ++; ny --;\n        }\n\n        y += 2; cnt ++;\n    }\n\n    x = 0, y = n - 1;\n    if(!a[0][n - 1])\n        x = 1;\n\n    while(x < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny >= 0){\n            a[nx][ny] = prime[cnt];\n            nx ++; ny --;\n        }\n\n        x += 2; cnt ++;\n    }\n}\n\nvoid diagonala2(){\n\n    int x = 0, y = 0;\n\n    while(y < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny < n){\n            a[nx][ny] *= prime[cnt];\n            nx ++; ny ++;\n        }\n\n        y += 2; cnt ++;\n    }\n\n    x = 0, y = 0;\n\n    while(x < n){\n        int nx = x, ny = y;\n\n        while(nx < n && ny < n){\n            a[nx][ny] *= prime[cnt];\n            nx ++; ny ++;\n        }\n\n        x += 2; cnt ++;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    sito();\n    cin >> n;\n\n    if(n == 2){\n        cout << 4 _ 7 << \"\\n\";\n        cout << 23 _ 10 << \"\\n\";\n        return 0;\n    }\n\n    diagonala1();\n    diagonala2();\n\n    set<ll> S;\n\n    REP(i, n)\n        REP(j, n){\n            if(a[i][j]){\n                //assert(a[i][j] < 1e16);\n                S.insert(a[i][j]);\n                continue;\n            }\n\n            ll sol = 1;\n            if(i > 0) sol = gcm(sol, a[i - 1][j]);\n            if(j > 0) sol = gcm(sol, a[i][j - 1]);\n            if(i < n - 1) sol = gcm(sol, a[i + 1][j]);\n            if(j < n - 1) sol = gcm(sol, a[i][j + 1]);\n\n            a[i][j] = sol + 1;\n            //assert(a[i][j] < 1e16);\n            S.insert(a[i][j]);\n        }\n\n    assert(n * n == sz(S));\n\n    REP(i, n){\n        REP(j, n)\n            cout << a[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i = a; i<n; i++)\n#define per(i,a,n) for (int i = n-1; i>=a; i--)\n#define pb push_back\n#define mp make_pair\n#define all(now) (now).begin(),(now).end()\n#define fi first\n#define se second\n#define SZ(now) ((int)(now).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod = 1000000007;\ninline int read(int &n){char c=getchar();int x=0,f=1;while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}return n = x*f;}\nll powmod(ll a,ll b,ll mod) {ll res = 1; a%=mod; assert(b>=0); for(;b; b>>=1){if(b&1)res = res*a%mod; a = a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\n// head\nconst int N = 5e2+7;\nconst int M = 1e4 + 7;\n\nint T,n,m,cnt;\n\nbool vis[M];\nint prime[M];\n\nvoid getPrime()\n{\n    cnt = 0;\n    rep(i,2,M-5){\n        if(!vis[i])\n            prime[++cnt] = i;\n        for (int j = 1; i * prime[j] < M - 5;j++){\n            vis[i * prime[j]] = 1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nll ans[M][M];\n\nint main()\n{\n    //ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    getPrime();\n    scanf(\"%d\", &n);\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n    rep(i, 1, n + 1) rep(j, 1, n + 1) ans[i][j] = 1;\n    rep(i,1,n+1){\n        rep(j,1,n+1){\n            if((i&1)==(j&1)){\n                ans[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n];\n                ans[i + 1][j] = lcm(ans[i + 1][j], ans[i][j]);\n                ans[i - 1][j] = lcm(ans[i - 1][j], ans[i][j]);\n                ans[i][j + 1] = lcm(ans[i][j + 1], ans[i][j]);\n                ans[i][j - 1] = lcm(ans[i][j - 1], ans[i][j]);\n            }\n        }\n    }\n    rep(i,1,n+1)rep(j,1,n+1){\n        if((i&1)==(j&1)){\n            printf(\"%lld\", ans[i][j] + 1);\n        }\n        else{\n            printf(\"%lld\", ans[i][j]);\n        }\n        printf(j == n ? \"\\n\" : \" \");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint N;\nint a[1001][1001], vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= 10000); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> N;\n\tif(N == 2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= N; i++) \n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!((i + j) & 1)) a[i][j] = prime[(i + j) / 2] * prime[N + (i - j) / 2 + (N + 1) / 2];\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!a[i][j]) \n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=5e2+5;\nconst int L=3e7;\nint n,pr[L+1], npr[L+1];\nLL a[N][N],b[N][N];\nmap <LL,bool> S;\ninline bool is_pr(int t) {\n\tfor(int i=2;(LL)i*i<=t;++i) if(!(t%i)) return false;\n\treturn true;\n}\ninline int nxt_prime() {\n\tstatic int hd=2;\n\twhile(!is_pr(hd)) ++hd;\n\treturn hd++;\n}\ninline LL lcm(LL x,LL y) {\n\treturn (!x || !y) ? (x+y) : (x*y/__gcd(x,y));\n}\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) \n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==((n+1)&1)) {\n\t\t\t\tif(i==1 || j==1) a[i][j]=nxt_prime();\n\t\t\t\telse a[i][j]=a[i-1][j-1];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==((n+1)&1)) {\n\t\t\t\tif(i==1 || j==n) b[i][j]=nxt_prime();\n\t\t\t\telse b[i][j]=b[i-1][j+1];\n\t\t\t\ta[i][j]*=b[i][j];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) if(!a[i][j]) {\n\t\t\tLL v=lcm(lcm(lcm(a[i-1][j],a[i+1][j]),a[i][j-1]),a[i][j+1]);\n\t\t\tLL nowval=v;\n\t\t\twhile(S[nowval]) nowval+=v;\n\t\t\ta[i][j]=nowval+1;  S[nowval]=1;\n\t\t}\n\tfor(int i=1;i<=n;cout<<'\\n',i++)\n\t\tfor(int j=1;j<=n;cout<<a[i][j++]<<' ');\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=505,MAXM=1e4+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,N,cnt,p[MAXM],vis[MAXM],v[MAXN*3];ll ans[MAXN][MAXN];\ninline void pre(int n=1e4){\n\tRep(i,2,n){\n\t\tif(!vis[i])p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}\n}ll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint main(){\n\tpre(),n=read();if(n==2){puts(\"4 7\\n23 10\");return 0;}N=1;\n\tRep(i,1,n)Rep(j,1,n)if((i+j)&1){if(!v[i-j+n])v[i-j+n]=p[++N];ans[i][j]=v[i-j+n];}\n\tmemset(v,0,sizeof(v));\n\tRep(i,1,n)Rep(j,1,n)if((i+j)&1){if(!v[i+j])v[i+j]=p[++N];ans[i][j]*=v[i+j];}\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tans[i][j]=1;\n\t\tif(i>1)ans[i][j]=lcm(ans[i][j],ans[i-1][j]);if(j>1)ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n\t\tif(i<n)ans[i][j]=lcm(ans[i][j],ans[i+1][j]);if(j<n)ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n\t\tans[i][j]++;\n\t}Rep(i,1,n){Rep(j,1,n)cout<<ans[i][j]<<' ';cout<<'\\n';}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nint max[505][505];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tprintf(\"%d \", i+j);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// AT027D: Modular Matrix\n\nint main(){\n    int n; cin >> n;\n    int N = 500;\n    int M = 100*N;\n\n    bool prime[M];\n    for(int i = 1; i < M; i++) prime[i] = true;\n    for(int i = 2; i < M; i++) if(prime[i])\n        for(int j = i + i; j < M; j += i) \n            prime[j] = false;\n\n    vector<int> p;\n    for(int i = 2; i < M; i++) if(prime[i]) p.push_back(i);\n\n\n    vector<long long> a(N+1);\n    for(int i = 0; i <= N; i += 4) a[i] = p[i/4];       \n    for(int i = 2; i <= N; i += 4) a[i] = p[N/2-i/4];\n    for(int i = 1; i < N; i += 2) a[i] = a[i-1] * a[i+1];\n\n    for(int i = 0; i < n; i++) {\n    \tfor(int j = 0; j < n; j++) cout << a[N-i] * a[j] * a[j] << \" \";\n    \tcout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nconst ll ccc=1000000;\nbool prime[ccc+1];\nvector<ll> pr;\nvoid makeprime(){\n\tll i,j;\n\tfor(i=2;i<=ccc;i++) prime[i]=true;\n\tfor(i=2;i*i<=ccc;i++) if(prime[i]) for(j=2;j*i<=ccc;j++) prime[j*i]=false;\n\tfor(i=2;i<=ccc;i++) if(prime[i]) pr.push_back(i);\n}\nint main(){\n\tmakeprime();\n\tconst int N = 500;\n\tvector<ll> a(N,1),b(N,1);\n\trep(i,N){\n\t\tif(i%2==0) a[i] = pr[i/2];\n\t\telse a[i] = pr[i/2] * pr[i/2+1];\n\t}\n\tint off = N/2+2;\n\trep(i,N){\n\t\tif(i%2==0) b[i] = pr[i/2+off];\n\t\telse b[i] = pr[i/2+off] * pr[i/2+1+off];\n\t}\n\trep(i,N) rep(j,N) assert(a[i]*b[j] <= 1000000000000000LL);\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,n) cout<<a[i]*b[j]<<\" \";\n\t\tputs(\"\");\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=505,M=1e4+5;\n\nint n,p[M],t;\nbool vis[M];\nll a[N][N];\n\nvoid pre(int N) {\n\tfo(i,2,N) {\n\t\tif (!vis[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0]) {\n\t\t\tint k=i*p[j];if (k>N) break;\n\t\t\tvis[k]=1;if (!(i%p[j])) break;\n\t\t}\n\t}\n}\n\nll lcm(ll a,ll b) {return a/__gcd(a,b)*b;}\n\nint main() {\n\tscanf(\"%d\",&n);pre(8e3);\n\tif (n==2) {\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfo(i,0,n-1) fo(j,0,n-1) a[i][j]=1;\n\tfo(i,0,n-1) fo(j,0,n-1) if (!((i+j)&1)) a[i][j]=a[i][j]*p[(i+j)/2+1];\n\tfo(i,0,n-1) fo(j,0,n-1) if (!((i+j)&1)) a[i][j]=a[i][j]*p[(i-j)/2+n/2+n];\n\tfo(i,0,n-1) fo(j,0,n-1)\n\t\tif ((i+j)&1) {\n\t\t\tif (i) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\tif (j) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\tif (i+1<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\tif (j+1<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\ta[i][j]++;\n\t\t}\n\tfo(i,0,n-1) {fo(j,0,n-1) printf(\"%lld \",a[i][j]);puts(\"\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 510, M = 1e4, K = 1024;\nint n, m, is[M], c, p[K];\nvoid pre_work() {\n    for (int i = 2; i < M; ++i) {\n        if (!is[i]) p[++c] = i; if (c >= m) break;\n        for (int j = 1; j <= c && p[j] * i < M; ++j) {\n            is[p[j] * i] = 1; if (i % p[j] == 0) break;\n        }\n    }\n}\nint x[K], y[K], res[N][N];\nint sx[4] = {1, 0, -1, 0}, sy[4] = {0, 1, 0, -1};\nint gcd (int x, int y) {\n    return y ? gcd (y, x % y) : x;\n}\nsigned main() {\n    scanf (\"%lld\", &n);\n    m = n << 1; pre_work();\n    int a = 1, b = c, k = 1;\n    // for (int i = 1; i <= c; ++i) printf (\"%lld \", p[i]); puts (\"\");\n    for (int i = 1; i <= n; ++i) {\n        if (k) x[i * 2] = p[a], ++a;\n        else x[i * 2] = p[b], --b; k ^= 1;\n    }\n    for (int i = 1; i <= n; i += 2) {\n        y[1 - i + n] = p[a], ++a;\n        if (k) y[1 - i + n] = p[a], ++a;\n        else y[1 - i + n] = p[b], --b; k ^= 1;\n    }\n    for (int i = 3; i <= n; i += 2) {\n        y[i - 1 + n] = p[a], ++a;\n        if (k) y[i - 1 + n] = p[a], ++a;\n        else y[i - 1 + n] = p[b], --b; k ^= 1;\n    }\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) % 2 == 0) res[i][j] = x[i + j] * y[i - j + n];\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) % 2) {\n            for (int k = 0; k < 4; ++k) {\n                int ii = i + sx[k], jj = j + sy[k];\n                if (ii < 1 || jj < 1 || ii > n || jj > n) continue;\n                if (res[i][j]) res[i][j] = res[i][j] * res[ii][jj] / gcd (res[i][j], res[ii][jj]);\n                else res[i][j] = res[ii][jj];\n            }\n            }\n        if (n == 2) res[2][1] = (res[2][1] - 1) * 2 + 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j)\n            printf (\"%lld \", res[i][j]); puts (\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int K = 1e6;\nbool pr[K];\nset<int> m[K];\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    for (int i=2; i < K; i++){\n        if (!pr[i]){\n            for (int j=i+i; j < K; j+=i){\n                pr[j] = true;\n                m[j].insert(i);\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    int a[n][n];\n    for (int i=0; i < n; i++) for (int j=0; j < n; j++) a[i][j] = 0;\n    int u = 2;\n    set<int> hh;\n    for (int i=0; i < n; i+=2){\n        for (int j=0; j < n; j++){\n            if ((i+j)%2!=0) continue;\n            while (u%2==0)u++;\n            a[i][j] = 2*u;\n            if (i+1 < n && j+1 < n) a[i+1][j+1] = u;\n            u++;\n        }\n    }\n    set<int> used;\n    for (int i=0; i < n; i++){\n        for (int j=0; j < n; j++){\n            if (a[i][j] != 0) continue;\n            vector<int> b;\n            if (i-1 >= 0) b.push_back(a[i-1][j]);\n            if (j+1 < n) b.push_back(a[i][j+1]);\n            if (i+1 < n) b.push_back(a[i+1][j]);\n            if (j-1>=0) b.push_back(a[i][j-1]);\n            set<int> gl;\n            for (int p=0; p < b.size(); p++) {\n                for (set<int>::iterator it = m[b[p]].begin(); it != m[b[p]].end(); it++){\n                    //cout << (*it) << endl;\n                    gl.insert(*it);\n                }\n            }\n            //cout << endl;\n            int R = 1;\n            for (set<int>::iterator it = gl.begin(); it != gl.end(); it++){\n                int num = *it;\n                int kf = 0;\n                for (int p=0; p < b.size(); p++){\n                    int s = 0;\n                    while (b[p] % num == 0){\n                        b[p] /= num;\n                        s++;\n                    }\n                    kf = max(kf, s);\n                }\n                for (int e=0;e<kf;e++) R *= num;\n            }\n            int rr = R+1;\n            while (used.count(rr)) rr += R;\n            R = rr;\n            if (R > 1e15){\n                cout << R << endl;\n                return 0;\n            }\n            a[i][j] = R;\n            used.insert(R);\n        }\n    }\n    for (int i=0;i<n;i++){\n        for (int j=0;j<n;j++) cout << a[i][j] << \" \";\n        cout << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100001\nusing namespace std;\nint n, prime[maxn], d[maxn], a[maxn], f[2001][2001], ans, cnt;\nint val1[maxn], val2[maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t \n\tfor(int i = 2; i <= 10000; i++){\n\t\tif(!d[i] && i != 2) prime[++cnt] = i;\n\t\tfor(int j = i; j <= 10000; j += i) d[j] = 1;\n\t}\n\tcin >> n; \n\tif (n==2) {\n  \t\tputs(\"4 7\");\n  \t\tputs(\"23 10\");\n  \t\treturn 0;\n  \t}\n\t  cnt = 0;\n\t for(int i = 1; i <= n ; i++)\n    for(int j = 1; j <= n; j++)\n      if (i + j & 1) {\n      \tif (!val1[i - j + n]) val1[i-j+n]=prime[++cnt];\n      \tf[i][j]=val1[i - j + n];\n\t  }\n  for(int i = 1; i <= n; i++)\n    for(int j = 1; j <= n ; j++)\n      if (i + j & 1) {\n      \tif (!val2[i + j]) val2[i + j]=prime[++cnt];\n      \tf[i][j]*=val2[i + j];\n\t  }\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(i + j & 1) continue; ans = 1;\n\t\t\tif(f[i - 1][j]) ans = ans / __gcd(f[i - 1][j], ans) * f[i - 1][j];\n\t\t\tif(f[i + 1][j]) ans = ans / __gcd(f[i + 1][j], ans) * f[i + 1][j];\n\t\t\tif(f[i][j + 1]) ans = ans / __gcd(f[i][j + 1], ans) * f[i][j + 1];\n\t\t\tif(f[i][j - 1]) ans = ans / __gcd(f[i][j - 1], ans) * f[i][j - 1];\n\t\t\tf[i][j] = ans + 1;\n\t\t}\n\tfor(int i  = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++) printf(\"%lld \", f[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint p[100010],pr[20100],t;\nll ad[101000],mi[101000],num[555][555];\nll mx;\nvector<pair<int,PII>> pp;\nint main() {\n\trep(i,2,20000) if (p[i]==0) {\n\t\tpr[t++]=i;\n\t\tfor (int j=i;j<=20000;j+=i) p[j]=1;\n\t}\n//\tprintf(\"%d\\n\",t);\n\tfor (int c=0;c<=998;c++) if (c%2==0) {\n\t\tpp.pb(mp(abs(c-499),mp(c,0)));\n\t}\n\n\tfor (int c=-499;c<=499;c++) if (c%2==0) {\n\t\tpp.pb(mp(abs(c),mp(c,1)));\n\t}\n\tsort(all(pp));\n\trep(i,0,SZ(pp)) {\n\t\tif (pp[i].se.se==0) ad[pp[i].se.fi]=pr[i];\n\t\telse mi[pp[i].se.fi+1000]=pr[i];\n\t}\n\trep(i,0,500) rep(j,0,500) {\n\t\tif ((i+j)%2==0) {\n\t\t\tll p1=ad[i+j];\n\t\t\tll p2=mi[i-j+1000];\n\t\t\tnum[i][j]=p1*p2;\n\t\t}\n\t}\n\tll mx=0;\n\trep(i,0,500) rep(j,0,500) {\n\t\tif ((i+j)%2==1) {\n\t\t\tnum[i][j]=1;\n\t\t\trep(k,0,4) {\n\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\tif (nx>=0&&nx<500&&ny>=0&&ny<500) {\n\t\t\t\t\tnum[i][j]=num[i][j]/gcd(num[i][j],num[nx][ny])*num[nx][ny];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx=max(mx,num[i][j]);\n\t\t}\n\t}\n\tset<ll> ss;\n\trep(i,0,500) rep(j,0,500) {\n\t\trep(k,0,4) {\n\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\tif (nx>=0&&nx<500&&ny>=0&&ny<500) {\n\t\t\t\tll c1=max(num[i][j],num[nx][ny]);\n\t\t\t\tll c2=min(num[i][j],num[nx][ny]);\n\t\t\t\tassert(c1%c2==0);\n\t\t\t}\n\t\t}\n\t\tss.insert(num[i][j]);\n\t\tassert(num[i][j]>=1&&num[i][j]<=1000000000000000ll);\n\t}\n\tassert(SZ(ss)==250000);\n\tint x=0;\n\tscanf(\"%d\",&x);\n\trep(i,0,x) {\n\t\trep(j,0,x) printf(\"%lld%c\",num[i][j],\" \\n\"[j==x-1]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 507;\nconst int MAXS = 2000007;\n\nint n;\nLL a[MAXN][MAXN];\nint p[MAXS];\nset < LL > s;\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nLL gcd ( LL x, LL y )\n{\n\treturn y ? gcd ( y, x%y ) : x;\n}\n\nLL lcm ( LL x, LL y )\n{\n\treturn ( ( ~x ) && ( ~y ) ) ? ( x / gcd ( x, y ) * y ) : ( ~x ) ? x : y;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d\", &n );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tint m = n * n / 4 + 1;\n\tlpi ( i, 1, m ) p[i] = i;\n\trandom_shuffle ( p+1, p+1+m );\n\t\n\tint pi = 0;\n\tfor ( int i = 1; i <= n; i += 2 ){\n\t\tfor ( int j = 1; j <= n; j += 2 ){\n\t\t\ta[i][j] = p[++pi] * 2 + 1;\n\t\t\ts.insert ( a[i][j] );\n\t\t\tif ( i < n && j < n ) a[i+1][j+1] = 2 * a[i][j], s.insert ( a[i+1][j+1] );\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tLL g = -1;\n\t\t\t\tif ( i > 1 ) g = lcm ( g, a[i-1][j] );\n\t\t\t\tif ( i < n ) g = lcm ( g, a[i+1][j] );\n\t\t\t\tif ( j > 1 ) g = lcm ( g, a[i][j-1] );\n\t\t\t\tif ( j < n ) g = lcm ( g, a[i][j+1] );\n\t\t\t\tLL cg = g + 1;\n\t\t\t\twhile ( s.find ( cg ) != s.end () ) cg += g;\n\t\t\t\ta[i][j] = cg;\n\t\t\t\ts.insert ( a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpi ( i, 1, n ){\n\t\tlpi ( j, 1, n ) printf ( \"%lld \", a[i][j] );\n\t\tputchar ( '\\n' );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nconst int maxp = 8000 + 10;\ntypedef long long ll;\n\nbool notprime[maxp];\nint prime[maxp] , prime_cnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxp;i++){\n\t\tif(!notprime[i]) prime[prime_cnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxp && j < prime_cnt;j++){\n\t\t\tll t = i * prime[j]; notprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nll gcd(ll a,ll b){ return b ? gcd(b,a % b) : a;}\nll lcm(ll a,ll b) { return a / gcd(a,b) * b;}\n\nconst int maxn = 500 + 10;\nll a[maxn][maxn];\nint cnt,n;\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&n);\n\tif(n == 2) return !printf(\"4 7\\n23 10\");\n\tfor(int i = 0;i <= n + 1;i++){\n\t\tfor(int j = 0;j <= n + 1;j++){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 ==  0){\n\t\t\t\ta[i][j] = prime[(i + j >> 1) - 1] * prime[(i - j) / 2 + n + n / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) & 1){\n\t\t\t\ta[i][j] = lcm(a[i][j - 1] , lcm(a[i][j + 1],lcm(a[i - 1][j],a[i + 1][j]))) + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%I64d%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,2,((N*N)/2)+1){\n            if(aa%2==1) prime.pb((aa/2)*4-3);\n            if(aa%2==0) prime.pb((aa/2)*4);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==0){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==1){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+2;\n/*                    a[i][j]=lcm(a[i-1][j],a[i+1][j]);\n                    a[i][j]=lcm(a[i][j],a[i][j-1]);\n                    a[i][j]=lcm(a[i][j],a[i][j+1]);\n                    a[i][j]++;*/\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\nll a[1005][1005];\nint n;\nint pri[10005],tot;\nbool mk[10005];\nll lcm(ll a,ll b) {\n\tif((!a)||(!b)) return a+b;\n\treturn 1ll*a*b/__gcd(a,b);\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tmk[1] = mk[0] = 1;\n\tfor(int i=2;i<=10000;i++) {\n\t\tif(!mk[i]) { pri[++tot]=i; }\n\t\tif(tot==1000) break;\n\t\tfor(int j=1;j<=tot&&1ll*pri[j]*i<=10000;j++) {\n\t\t\tint k = pri[j] * i;\n\t\t\tmk[k] = 1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==0) a[i][j] = pri[(i + j) / 2] * pri[n+((i-j)/2+(n+1)/2)];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\tif((i+j)%2==1) a[i][j] = ( lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]) ) + 1;\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 1003, K = 10003, d[2][4] = {{0, 1, 0, -1}, {1, 0, -1, 0}};\nint n, pri[N << 1], tot;\nbool notp[K];\nLL a[N][N];\ninline void init(int m){\n\tnotp[0] = notp[1] = 1;\n\tfor(Rint i = 2;;i ++){\n\t\tif(!notp[i]){pri[++ tot] = i; if(tot == m) break;}\n\t\tfor(Rint j = 1;j <= tot && i * pri[j] <= 10000;j ++){\n\t\t\tnotp[i * pri[j]] = true;\n\t\t\tif(!(i % pri[j])) break;\n\t\t}\n\t}\n}\ninline LL gcd(LL a, LL b){return b ? gcd(b, a % b) : a;}\ninline LL lcm(LL a, LL b){return a / gcd(a, b) * b;}\nint main(){\n\tscanf(\"%d\", &n);\n\tif(n == 2){\n\t\tputs(\"2 3\"); puts(\"5 4\"); return 0;\n\t} init(2 * n);\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tfor(Rint j = 1;j <= n;j ++) if(!(i + j & 1))\n\t\t\ta[i][j] = pri[i + j >> 1] * pri[n + (n + i - j + 1 >> 1)];\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tfor(Rint j = 1;j <= n;j ++){\n\t\t\tif(!a[i][j]){\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor(Rint k = 0;k < 4;k ++){\n\t\t\t\t\tint dx = i + d[0][k], dy = j + d[1][k];\n\t\t\t\t\tif(dx >= 1 && dx <= n && dy >= 1 && dy <= n)\n\t\t\t\t\t\ta[i][j] = lcm(a[i][j], a[dx][dy]);\n\t\t\t\t}\n\t\t\t\t++ a[i][j];\n\t\t\t}\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505;\nconst int dx[4]={0,0,-1,1};\nconst int dy[4]={-1,1,0,0};\nint n;\nll a[N][N],v1[N*2],v2[N*2];\nvector<int>pri;\nint vis[100005];\n\nvoid Init() {\n  for(int i=2;i<=100000;i++) {\n    if(vis[i]) continue;\n    vis[i]=1;\n    pri.push_back(i);\n    for(int j=0;j<(int)pri.size();j++) {\n      if((ll)i*pri[j]>100000) break;\n      vis[i*pri[j]]=1;\n    }\n  }\n}\n\nll Gcd(ll x,ll y) {\n  if(!y) return x;\n  return Gcd(y,x%y);\n}\n\nll Lcm(ll a,ll b) {\n  ll G=Gcd(a,b);\n  return a*b/G;\n}\n\nint Judge(int x,int y) {\n  if(x<1||x>n||y<1||y>n) return 0;\n  return 1;\n}\n\nint main() {\n  Init();\n  scanf(\"%d\",&n);\n  if(n==2) {\n    puts(\"2 7 \\n13 3\");\n    return 0;\n  }\n  int nw=0;\n  for(int i=1;i<=n;i++) v1[i]=pri[nw],nw++;\n  for(int i=1;i<=n;i++) v2[i]=pri[nw],nw++;\n  for(int i=1;i<=n;i++) {\n    int st=i&1?1:2;\n    for(int j=st;j<=n;j+=2) {\n      int A=(i+j)/2,B=(j-i+n+1)/2;\n      //printf(\"%d %d %d %d\\n\",i,j,A,B);\n      a[i][j]=v1[A]*v2[B];\n    }\n  }\n  //cerr<<\"GG\"<<endl;\n  /*\n  for(int i=1;i<=n;i++) {\n    for(int j=1;j<=n;j++) {\n      printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n    }\n  }\n  */\n  for(int i=1;i<=n;i++) {\n    int st=i&1?2:1;\n    for(int j=st;j<=n;j+=2) {\n      ll V=1;\n      for(int k=0;k<4;k++) {\n\tint nx=i+dx[k],ny=j+dy[k];\n\tif(Judge(nx,ny)) {\n\t  V=Lcm(V,a[nx][ny]);\n\t}\n      }\n      a[i][j]=V+1;\n    }\n  }\n  for(int i=1;i<=n;i++) {\n    for(int j=1;j<=n;j++) {\n      printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 504;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nlong long grid[1000][1000];\nint main() {\n#define int long long\n\tvector<int> sosuu;\n\tfor (int i = 2; i <= 10000; ++i) {\n\t\tint ok = 1;\n\t\tfor (int q = 2; q <= sqrt(i); ++q) {\n\t\t\tif (i % q == 0) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok == 1) continue;\n\t\tsosuu.push_back(i);\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tgrid[i][q] = 1;\n\t\t}\n\t}\n\tint now_itr = 0;\n\tfor (int i = 0; i < 1000; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i - q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tfor (int i = -1000; i < 500; i += 2) {\n\t\tint first_time = 0;\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tint y = q;\n\t\t\tint x = i + q;\n\t\t\tif (x >= 0 && x < 500) {\n\t\t\t\tgrid[x][y] *= sosuu[now_itr];\n\t\t\t\tfirst_time = 1;\n\t\t\t}\n\t\t}\n\t\tif (first_time == 1) now_itr++;\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int q = 0; q < 500; ++q) {\n\t\t\tif ((i + q) % 2 == 0) continue;\n\t\t\tint now_lcm = 1;\n\t\t\tint xe[4] = { 1,-1,0,0 };\n\t\t\tint ye[4] = { 0,0,-1,1 };\n\t\t\tREP(j, 4) {\n\t\t\t\tint x = xe[j] + i;\n\t\t\t\tint y = ye[j] + q;\n\t\t\t\tif (x >= 0 && x < 500 && y >= 0 && y < 500) {\n\t\t\t\t\tint hoge = gcd(now_lcm, grid[x][y]);\n\t\t\t\t\tnow_lcm /= hoge;\n\t\t\t\t\tnow_lcm *= grid[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrid[i][q] = now_lcm + 1;\n\t\t\tassert(now_lcm <= 1e15);\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tREP(q, n) {\n\t\t\tif (q != 0) cout << \" \";\n\t\t\tcout << grid[i][q];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\nconst int MN = 520;\nconst int MA = MN/2;\nconst int MP = 10000;\nvl pr;\nvl md;\nbitset<MP> bs;\nll mat[MN][MN];\nvoid pre() {\n\tfor(int i=2;i<MP;i++) {\n\t\tif(!bs[i]) {\n\t\t\tif(i >= MN) {\n\t\t\t\tpr.push_back(i);\n\t\t\t}\n\t\t\tfor(int j=2;j*i<MP;j++) {\n\t\t\t\tbs.set(i*j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<MN;i++) {\n\t\tmd.push_back(i+1);\n\t}\n\tfor(int i=0;i<500;i++) {\n\t\tfor(int j=0;j<500;j++) {\n\t\t\tll da = j-i;\n\t\t\tll db = j+i;\n\t\t\tda += MN;\n\t\t\tll go;\n\t\t\tif((db&1)) {\n\t\t\t\tgo = pr[da/2]*pr[(da+1)/2]*md[db/2]*md[(db+1)/2]*2+1;\n\t\t\t} else {\n\t\t\t\tgo = pr[da/2]*md[db/2]*2;\n\t\t\t}\n\t\t\tmat[i][j] = go;\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tpre();\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(j > 0) {cout << \" \";}\n\t\t\tcout << mat[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint prime[maxn],ptot,mark[maxn];\n\ninline void prepare()\n{\n\tREP(i,2,1e5)\n\t{\n\t\tif(!mark[i])prime[++ptot]=i;\n\t\tfor(int j=1,k;j<=ptot && i*prime[j]<=1e5;j++)\n\t\t{\n\t\t\tk=i*prime[j]; mark[k]=1;\n\t\t\tif(!(i%prime[j]))break;\n\t\t}\n\t}\n}\n\nint n;\nll a[520][520];\nint mpa[maxn],mpb[maxn];\n\ninline void init()\n{\n\tint now=0;\n\tn=read();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");exit(0);\n\t}\n\tREP(i,1,n)REP(j,1,n)if(~i+j&1)\n\t{\n\t\tif(!mpa[i+j])\n\t\t\tmpa[i+j]=prime[++now];\n\t}\n\n\tREP(i,1,n)REP(j,1,n)if(~i+j&1)\n\t{\n\t\tif(!mpb[i-j+n])\n\t\t\tmpb[i-j+n]=prime[++now];\n\t\ta[i][j]=1ll*mpa[i+j]*mpb[i-j+n];\n\t}\n\tREP(i,0,1e4)chkmax(mpa[i],1),chkmax(mpb[i],1);\n\tREP(i,1,n)REP(j,1,n)if(i+j&1)\n\t{\n\t\ta[i][j]=1ll*mpa[i+j-1]*mpa[i+j+1]*mpb[i-j-1+n]*mpb[i-j+1+n]+1;\n\t\t//if(a[i][j]>=(1e15))\n\t\t\t//\tprintf(\"%d %d %lld\",i,j,a[i][j]),puts(\"GG\"),exit(0);\n\t}\n\tREP(i,1,n)REP(j,1,n)printf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n}\n\ninline void doing()\n{\n\t\n}\n\nint main()\n{\n\tprepare();\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 502\nvector<long long>p;\nbool pri[200000];\n\nvoid p_m(void) {\n\tlong long x;\n\tf(i, 200000)pri[i] = true;\n\tfor (long long i = 2; i < 200000; i++) {\n\t\tif (pri[i]) {\n\t\t\tp.push_back(i);\n\t\t\tx = i;\n\t\t\twhile (x < 200000) {\n\t\t\t\tpri[x] = false;\n\t\t\t\tx += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n\n\nint main() {\n\tint n;\n\tint x, y, k;\n\tlong long a[N][N];\n\tscanf(\"%d\", &n);\n\tp_m();\n\tf(i, n) {\n\t\tf(j, n)a[i][j] = 1;\n\t}\n\tx = 0;\n\tk = 0;\n\twhile (x < (2 * n)) {\n\t\tf(i, n) {\n\t\t\ty = x - i - 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x - i;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x - i + 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t}\n\t\tx += 2;\n\t\tk++;\n\t}\n\tif (n % 2 == 0)x = - n;\n\telse x = 1 - n;\n\twhile (x <= n) {\n\t\tf(i, n) {\n\t\t\ty = x + i - 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x + i;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x + i + 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t}\n\t\tx += 2;\n\t\tk++;\n\t}\n\tf(i, n){\n\t\tf(j,n) {\n\t\t\tif ((i + j) % 2 == 1)a[i][j]++;\n}\n\t\t}\n\tf(i, n) {\n\t\tf(j, n) {\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < n - 1)printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cassert>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nconst int maxp = 8000 + 10;\ntypedef long long ll;\n\nbool notprime[maxp];\nll prime[maxp] , prime_cnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxp;i++){\n\t\tif(!notprime[i]) prime[prime_cnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxp && j < prime_cnt;j++){\n\t\t\tll t = i * prime[j]; notprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nll gcd(ll a,ll b){ return b ? gcd(b,a % b) : a;}\nll lcm(ll a,ll b) { return a / gcd(a,b) * b;}\n\nconst int maxn = 500 + 10;\nll a[maxn][maxn];\nint cnt,n;\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&n);\n\tif(n == 2) return !printf(\"4 7\\n23 10\");\n\tfor(int i = 0;i <= n + 1;i++){\n\t\tfor(int j = 0;j <= n + 1;j++){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 ==  0){\n\t\t\t\ta[i][j] = prime[(i + j >> 1) - 1] * prime[(i - j) / 2 + n / 2 + n];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) & 1){\n\t\t\t\ta[i][j] = lcm(a[i][j - 1] , lcm(a[i][j + 1],lcm(a[i - 1][j],a[i + 1][j]))) + 1;\n\t\t\t\tassert(a[i][j] <= 1e15);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%ll%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn primes[x];\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn primes[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tif (N == 2)\n\t{\n\t\tcout << \"4 7\\n23 10\\n\";\n\t}\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p > MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = mind(i - j) * plud(i + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair < int, int > PII;\ntypedef pair < LL, LL > PLL;\ntypedef pair < LD, LD > PDD;\n\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntemplate < typename _T > inline void _DBG(const char *s, _T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate < typename _T, typename... args > void _DBG(const char *s, _T x, args... a) { while(*s != ',') cerr << *s++; cerr << \" = \" << x << ','; _DBG(s + 1, a...); }\n\n#ifdef LOCAL\n#define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0) cout\n#endif\n\n// ********************** CODE ********************** //\n\nconst int N = 500;\n\nLL pri[] = {1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521};\n\nLL T[N][N];\nunordered_set < LL > S;\n\nLL nwd(LL a, LL b)\n{\n    if(b == 0) return a;\n    return nwd(b, a % b);\n}\n\nLL nww(LL a, LL b)\n{\n    return a / nwd(a, b) * b;\n}\n\nint main()\n{\n    _upgrade\n    srand(time(NULL) + getpid());  \n    for(int i = 0; i <= 2 * N; i += 2)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if(0 <= k && k < N)\n            {\n                T[j][k] = pri[i / 2];\n            }\n        }\n    }\n    LL st = 500;\n    for (int i = 0; i <= 2 * N; i += 2)\n    {\n        LL p = st;\n        for (int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if (0 <= k && k < N)\n            {\n                //DBG(j, k, T[j][k], p);\n                T[j][k] *= p;\n                S.insert(T[j][k]);\n                p++;\n            }\n        }\n        if(i + 1 < N)\n            st--;\n        else\n            st++;\n    }\n    LL lim = 1e15;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(T[i][j] != 0) continue;\n            vector < LL > v;\n            if(i > 0)\n                v.push_back(T[i - 1][j]);\n            if(j > 0)\n                v.push_back(T[i][j - 1]);\n            if(i + 1 < N)\n                v.push_back(T[i + 1][j]);\n            if(j + 1 < N)\n                v.push_back(T[i][j + 1]);\n            LL can = 0;\n            if(sz(v) == 1)\n            {\n                can = v[0];\n            }\n            else if(sz(v) == 2)\n            {\n                can = nww(v[0], v[1]);\n            }\n            else if(sz(v) == 3)\n            {\n                can = nww(v[0], nww(v[1], v[2]));\n            }\n            else\n            {\n                can = nww(v[0], nww(v[1], nww(v[2], v[3])));\n            }\n            //DBG(can, sz(v));\n            LL cp = can;\n            while(can + 1 <= lim && S.find(can + 1) != S.end())\n            {\n                //DBG(can + 1);\n                can += cp;\n            }\n            //DBG(i, j, T[i][j]);\n            if(can + 1 > lim)\n            {\n                //DBG(i, j, T[i][j]);\n                //for (auto u : v)\n                //    DBG(u);\n                //cout << \"KUPA\\n\";\n                //return 0;\n            }\n            S.insert(can + 1);\n            T[i][j] = can + 1;\n        }\n    }\n    /*\n    cout << \"{ \";\n    for(int i = 0; i < N; i++)\n    {\n        cout << \"{ \";\n        for(int j = 0; j < N; j++)\n        {\n            cout << T[i][j] << (j + 1 < N ? \", \" : \"\");\n        }\n        cout << \" }\" << (i + 1 < N ? \", \" : \"\");\n    }\n    cout << \" }\";\n    */\n    int n; cin >> n;\n    for(int  i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=1010;\nint n,tot,vis[maxn*10];\nll prime[maxn],ans[maxn][maxn];\nvoid init() {\n\tint tmp;\n\tfor (int i=2;i<=8000;i++) {\n\t\tif (!vis[i]) prime[++tot]=i;\n\t\tif (tot==1000) break;\n\t\tfor (int j=1;j<=tot;j++) {\n\t\t\ttmp=i*prime[j];\n\t\t\tif (tmp>=maxn*10) break;\n\t\t\tvis[tmp]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y) {\n\tif (!x||!y) return x+y;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y) {\n\treturn x/gcd(x,y)*y;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tinit();\n\tread(n);\n\tif (n==2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<=n+1;i++)\n\t\tans[0][i]=ans[i][0]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif ((i+j)%2==0)\n\t\t\tans[i][j]=prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif ((i+j)%2==1)\n\t\t\tans[i][j]=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i+1][j],ans[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,tot;\nconst int N=1005;\nLL a[N][N],zhi[N<<1],vis[10010];\n\nlong long GCD(long long x, long long y) \n{\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long LCM(long long x, long long y) \n{\n    if (!x || !y) return x + y;\n    return x / GCD(x, y) * y;\n}/*\nLL GCD(LL a,LL b){return b?GCD(b,a%b):a;}\nLL LCM(LL a,LL b){return a&b?a/GCD(a,b)*b:a+b;}*/\nvoid YYCH()\n{\n\tvis[1]=1;\n\tfor(int i=2;i<=10000;++i)\n\t{\n\t\tif(!vis[i])zhi[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*zhi[j]<=10000;++j)\n\t\t{\n\t\t\tvis[i*zhi[j]]=1;\n\t\t\tif(!(i%zhi[j]))break;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;if(n==2)return printf(\"4 7\\n23 10\\n\")==233;\n\tYYCH();\n\t for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = zhi[(i + j) / 2] * zhi[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = LCM(LCM(a[i - 1][j], a[i][j - 1]),\n                          LCM(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n\t/*\n    for(int i=1;i<=n;++i)\n    \tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n    \t\ta[i][j]=zhi[(i+j)/2]*zhi[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n    \tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t\ta[i][j]=LCM(LCM(a[i-1][j],a[i][j-1]),LCM(a[i+1][j],a[i][j+1]))+1;\n    for(int i=1;i<=n;++i,puts(\"\"))\n    \tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n\t*/\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=1010;\nint n,tot,vis[maxn*10];\nll prime[maxn],ans[maxn][maxn];\nvoid init() {\n\tint tmp;\n\tfor (int i=2;i<=8000;i++) {\n\t\tif (!vis[i]) prime[++tot]=i;\n\t\tif (tot==1000) break;\n\t\tfor (int j=1;j<=tot;j++) {\n\t\t\ttmp=i*prime[j];\n\t\t\tif (tmp>=maxn*10) break;\n\t\t\tvis[tmp]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y) {\n\tif (!x||!y) return x+y;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y) {\n\treturn x/gcd(x,y)*y;\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tinit();\n\tread(n);\n\tif (n==2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<=n+1;i++)\n\t\tans[0][i]=ans[i][0]=ans[n+1][i]=ans[i][n+1]=1;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif ((i+j)%2==0)\n\t\t\tans[i][j]=prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif ((i+j)%2==1)\n\t\t\tans[i][j]=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i+1][j],ans[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 500, dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};\nint n, m, mn;\nll s[maxn * maxn + 10], a[maxn + 10][maxn + 10];\n\nbool ispr(int x) {\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) return 0;\n\treturn 1;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, p = 1; i <= n * 2; ++i) {\n\t\tfor (++p; !ispr(p); ++p);\n\t\ts[i] = p;\n\t}\n\tmn = (1 - n) & 1 ? (2 - n) / 2 : (1 - n) / 2;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tint x = (i + j) / 2, y = (i - j) / 2 - mn + 1;\n\t\t\t\ta[i][j] = s[x] * s[y + n];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i + j) % 2) {\n\t\t\t\tll g = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint dx = i + dir[k][0], dy = j + dir[k][1];\n\t\t\t\t\tif (dx >= 1 && dx <= n && dy >= 1 && dy <= n)\n\t\t\t\t\t\tg = g / __gcd(g, a[dx][dy]) * a[dx][dy];\n\t\t\t\t}\n\t\t\t\ta[i][j] = g + 1;\n\t\t\t}\n\t\t\tprintf(\"%lld%c\", a[i][j],  \" \\n\"[j == n]);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,pri[10010],tot=0;\nbool nopri[10010];\nll ans[510][510];\n\nll lcm(ll x,ll y) {return x*y/__gcd(x,y);}\n\nvoid sieve(int n)\n{\n    rep(i,2,n)\n    {\n        if (!nopri[i]) pri[++tot]=i;\n        for (int j=1;j<=tot && i*pri[j]<=n;j++)\n        {\n            nopri[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\n\nint main()\n{\n    sieve(10000);\n    n=read();\n    if (n==2)\n    {\n        puts(\"4 7\\n23 10\");return 0;\n    }\n    rep(i,0,n+1) ans[0][i]=ans[n+1][i]=ans[i][0]=ans[i][n+1]=1;\n    int now=0;\n    rep(i,1,n)\n    {\n        int st;\n        if (i&1) st=1;else st=2;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=pri[(i+j)>>1]*pri[(i-j+n)/2+n];\n        }\n    }\n    rep(i,1,n) \n    {\n        int st;\n        if (i&1) st=2;else st=1;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]))+1;\n        }\n    }\n    rep(i,1,n)\n    {\n        rep(j,1,n) printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 500 + 20 , M = 3e4 + 20 ;\nint n , a[N][N] ;\nbool np[M] ;\nvector <int> vec ;\n\nint gcd (int a , int b) {\n\tif (!b) return a ;\n\treturn gcd(b , a % b) ;\n}\n\ninline void add (int &a , int b) {\n\ta = a / gcd(a , b) * b ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\" ;\n\t\treturn 0 ;\n\t}\n\n\tnp[0] = np[1] = 1 ;\n\tfor (int i = 2 ; i < M ; i ++) {\n\t\tif (np[i]) continue ;\n\n\t\tvec.push_back(i) ;\n\n\t\tfor (int j = 2 * i ; j < M ; j += i) np[j] = 1 ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 0) \n\t\t\t\ta[i][j] = vec[(i + j) >> 1] * vec[((i - j + n) >> 1) + n] ;\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 1) {\n\t\t\t\ta[i][j] = 1 ;\n\t\t\t\tif (i > 0) add(a[i][j] , a[i - 1][j]) ;\n\t\t\t\tif (i < n - 1) add(a[i][j] , a[i + 1][j]) ;\n\t\t\t\tif (j > 0) add(a[i][j] , a[i][j - 1]) ;\n\t\t\t\tif (j < n - 1) add(a[i][j] , a[i][j + 1]) ;\n\t\t\t\ta[i][j] += 1 ;\n\t\t\t}\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int j = 0 ; j < n ; j ++) cout << a[i][j] << ' ' ;\n\t\tcout << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=500+5,M=1e4+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n;\nint vis[M],l[M];\nvoid input()\n{\n\tn=read<int>();\n}\nvoid init(int Max)\n{\n\tFor(i,2,Max)\n\t{\n\t\tif(!vis[i])l[++l[0]]=i;\n\t\tfor(int j=1;j<=l[0]&&i*l[j]<=Max;j++)\n\t\t{\n\t\t\tvis[l[j]*i]=1;\n\t\t\tif(i%l[j]==0)break;\n\t\t}\n\t}\n}\nll mp[N][N];\nint x[N<<1],y[N<<1];\nll lcm(ll x,ll y)\n{\n\tif(!x||!y)return x|y;\n\treturn x/__gcd(x,y)*y;\n}\nvoid work()\n{\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\tint now=0;\n\tFor(i,1,n)For(j,1,n)if((i+j)&1)\n\t{\n\t\tif(!x[j-i+n])x[j-i+n]=l[++now];\n\t\tif(!y[i+j])y[i+j]=l[++now];\n\t\tmp[i][j]=x[j-i+n]*y[i+j];\n\t}\n\tFor(i,1,n)For(j,1,n)if(!mp[i][j])\n\t{\n\t\tmp[i][j]=lcm(mp[i][j],mp[i-1][j]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i+1][j]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i][j-1]);\n\t\tmp[i][j]=lcm(mp[i][j],mp[i][j+1]);\n\t\tmp[i][j]++;\n\t}\n\tFor(i,1,n)For(j,1,n)write(mp[i][j],j==n?'\\n':' ');\n}\nint main()\n{\n\t//file();\n\tinput();\n\tinit(1e4);\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nsigned main(){\n  vector<int> v;\n  int t=2;\n  while(v.size()<1000){\n    bool f=1;\n    for(int i=2;i*i<=t;i++)if(t%i==0)f=0;\n    if(f)v.push_back(t);\n    t++;\n  }\n  int d1[500][500],d2[500][500],c=0;\n  for(int i=-498;i<500;i+=2){\n    for(int j=-i;j+i<500;j++){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d1[j][j+i]=v[c];\n    }\n    c++;\n  }\n\n  for(int i=0;i<1000;i+=2){\n    for(int j=1000;i-j<500;j--){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d2[j][i-j]=v[c];\n    }\n    c++;\n  }\n  int n;\n  cin>>n;\n  \n  int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(j)cout<<\" \";\n      if((i+j)%2){\n\tint res=1;\n\tset<int> s;\n\tfor(int k=0;k<4;k++){\n\t  int nx=j+dx[k],ny=i+dy[k];\n\t  if(nx<0||ny<0||nx>=n||ny>=n)continue;\n\t  s.insert(d1[ny][nx]);\n\t  s.insert(d2[ny][nx]);\n\t}\n\tfor(auto z:s){res*=z;}\n\tcout<<res+1;\n      }\n      else cout<<d1[i][j]*d2[i][j];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for (register int i = l; i <= r; i++)\n#define ford(i, r, l) for (register int i = r; i >= l; i--)\n\ntypedef long long ll;\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\nll N, prime[20003], p_cnt, Need, a[505][505];\n\nint main() {\n  srand(time(0));\n  for (int i = 2; i <= 20000; i++) {\n    bool flag = true;\n    for (int j = 2; j * j <= i && flag; j++)\n      if (i % j == 0) flag = false;\n    if (flag) prime[++p_cnt] = i;\n  }\n  scanf(\"%lld\", &N), Need = N + N - 2;\n  if(N == 2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n  random_shuffle(prime + 1, prime + Need + 1);\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if (!((i + j) & 1)) continue;\n      int x = (i + j) >> 1;\n      int y = ((N - (N & 1)) - (j - i) + 1) >> 1;\n      a[i][j] = prime[x] * prime[N - 1 + y];\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= N; j++) {\n      if ((i + j) & 1) continue;\n      a[i][j] = 1;\n      if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n      if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n      if (i < N) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n      if (j < N) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n      a[i][j]++;\n    }\n  }\n  for (int i = 1; i <= N; i++)\n    for (int j = 1; j <= N; j++) printf(\"%lld%c\", a[i][j], \" \\n\"[j == N]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long \nll f[1050][1050];\nint n,t,p[10050],pri[10050];\nint gcd(int a,int b){\n\tif (!(a%b))return b;\n\treturn gcd(b,a%b);\n}\nll lcm(int x,int y){\n\tll ret=1;\n\tif (x>1)ret=ret*f[x-1][y]/gcd(f[x-1][y],ret);\n\tif (y>1)ret=ret*f[x][y-1]/gcd(f[x][y-1],ret);\n\tif (x<n)ret=ret*f[x+1][y]/gcd(f[x+1][y],ret);\n\tif (y<n)ret=ret*f[x][y+1]/gcd(f[x][y+1],ret);\n\treturn ret+1;\n}\nint main(){\n\tfor (int i=2;t<=1000;i++){\n\t\tif (!p[i])pri[++t]=i;\n\t\tfor (int j=1;j<=t&&i*1ll*pri[j]<=10000;j++){\n\t\t\tp[i*pri[j]]=1;\n\t\t\tif (!(i%pri[j]))break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tint tmp=1;\n\tfor (int i=2;i<=n;i+=2,tmp++)\n\t\tfor (int x=1,y=i;x<=n&&y<=n;x++,y++)f[x][y]=pri[tmp]; \n\tfor (int i=2;i<=n;i+=2,tmp++)\n\t\tfor (int y=1,x=i;x<=n&&y<=n;x++,y++)f[x][y]=pri[tmp];\n\tfor (int i=2;i<=n;i+=2,tmp++)\n\t\tfor (int x=1,y=i;x<=n&&y;x++,y--)f[x][y]*=pri[tmp];\n\tfor (int i=(n&1)?2:3;i<=n;i+=2,tmp++)\n\t\tfor (int y=n,x=i;x<=n&&y;x++,y--)f[x][y]*=pri[tmp];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)if (!f[i][j])f[i][j]=lcm(i,j);\n\tif (n==2)f[1][1]=61;\n\tfor (int i=1;i<=n;i++,printf(\"\\n\"))\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",f[i][j]); \n} "
  },
  {
    "language": "C++",
    "code": "//const int N = 5e5+5;\n//bool prime[N];\n//ll gcd(ll x, ll y){\n//    if(y == 0)\n//        return x;\n//    return gcd(y,x%y);\n//}\n//void alternate(vi &arr){\n//    vi ans;\n//    for(int i = 0; i < 250; ++i){\n//        ans.pb(arr[i]);\n//        ans.pb(arr[499-i]);\n//    }\n//    arr = ans;\n//}\n//void _(){\n//    fill(prime+2,prime+N,true);\n//    vector<int> primes;\n//    for(int i = 2; i < N; ++i)\n//        if(prime[i]){\n//            for(int j = 2*i; j < N; j += i)\n//                prime[j] = false;\n//            primes.push_back(i);\n//        }\n//    primes.resize(1000);\n//    vi p1;\n//    vi p2;\n//    for(int i = 0; i < 1000; ++i)\n//        if(i%2) \n//            p1.pb(primes[i]);\n//        else\n//            p2.pb(primes[i]);\n//    alternate(p1);\n//    alternate(p2);\n//    //print(p1);\n//    //print(p2);\n//    int n;\n//    cin >> n;\n//    if(n == 2){\n//        cout << \"4 7 \\n23 10\\n\";\n//        return;\n//    }\n//    vector<ll> arr;\n//    vvl grid(n,vl(n));\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 == j % 2){\n//                int d1 = (i+j)/2;\n//                int d2 = (i-j+n-1)/2;\n//                ll a = p1[d1];\n//                ll b = p2[d2];\n//                grid[i][j] = a*b;\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j){\n//            if(i % 2 != j % 2){\n//                vl neigh;\n//                if(i > 0) neigh.pb(grid[i-1][j]);\n//                if(i+1 < n) neigh.pb(grid[i+1][j]);\n//                if(j > 0) neigh.pb(grid[i][j-1]);\n//                if(j+1 < n) neigh.pb(grid[i][j+1]);\n//                ll ans = 1;\n//                for(ll x : neigh){\n//                    ans = ans*(x/gcd(ans,x));\n//                }\n//                grid[i][j] = ans+1;\n//                assert(grid[i][j] < 1e15);\n//                for(auto cur : neigh)\n//                    assert(grid[i][j]%cur == 1);\n//            }\n//        }\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            arr.push_back(grid[i][j]);\n//    for(int i = 0; i < n; ++i)\n//        for(int j = 0; j < n; ++j)\n//            cout << grid[i][j]  << \" \\n\"[j==n-1];\n//    sort(all(arr));\n//    arr.erase(unique(all(arr)),arr.end());\n//    assert(arr.size() == n*n);\n//    //cout << n*n << ' ' << arr.size() << '\\n';\n//}\n//\n// ================================================ \n// ^^^\tABOVE is what I wrote in my editor\t^^^\n// ------------------------------------------------ \n// vvv\tBELOW is automatically generated \tvvv\n// ================================================ \n#include <numeric>\n#include <set>\n#include <iomanip>\n#include <algorithm> \n#include <cassert>\n#include <vector>\n#include <iostream>\n#define pb push_back \n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<int> vi;\ntemplate<typename IT>\nostream &print(IT b, IT e, string sep = \" \", ostream &stream = cout){\n\tfor(IT it = b; it != e; ++it){\n\t\tstream << *it;\n\t\tif(it+1 != e) stream << sep;\n\t} \n\treturn stream;\n}\ntemplate<typename IT> istream &read(IT b, IT e, istream &stream = cin){\n\tfor(IT it = b; it != e; ++it) stream >> *it; return stream;\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> ostream &operator<<(ostream &stream, vector<T> &&t){\n\treturn print(all(t),\" \",stream);\n}\ntemplate<typename T> istream &operator>>(istream &stream, vector<T> &t){\n\treturn read(all(t),stream);\n}\ntemplate <typename T> \nvoid print(T x){\n\tcout << x << '\\n';\n}\ntemplate <typename t> \nvoid print(vector<t> arr,string sep=\" \"){\n    if(arr.empty())\n        return;\n\tprint(arr.begin(),arr.end(),sep);\n\tcout << '\\n';\n}\ntemplate <typename T> \nvoid print(vector<vector<T> > arr){\n\tfor(int i = 0; i < arr.size(); ++i){\n\t\tcout << \"[\" << arr[i] << \"]\";\n\t\tif(i+1 < arr.size())\n\t\t\tcout << \", \";\n\t}\n\tcout << '\\n';\n}\ntemplate<typename T>\nT _();\nconst ll INF = ll(2e18)+666;\nconst ll MOD = 1e9+7;\ntemplate<typename T>\nvector<T> operator+(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(lhs);\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] += rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator+=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs+rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nvector<T> operator-(const vector<T> &lhs, const vector<T> &rhs){\n\tvector<T> ans(all(lhs));\n\tassert(ans.size() == rhs.size());\n\tfor(int i = 0; i < rhs.size(); ++i)\n\t\tans[i] -= rhs[i];\n\treturn ans;\n}\ntemplate<typename T>\nvector<T> operator-=(vector<T> &lhs, const vector<T> &rhs){\n\treturn lhs = lhs-rhs;\n\t//vector<T> ans(lhs);\n\t//assert(ans.size() == rhs.size());\n\t//for(int i = 0; i < rhs.size(); ++i)\n\t\t//ans[i] += rhs[i];\n\t//return ans;\n}\ntemplate<typename T>\nT max(const vector<T> arr){\n\tassert(!arr.empty());\n\tT ans = arr[0];\n\tfor(auto &cur : arr)\n\t\tans = max(ans,cur);\n\treturn ans;\n}\ntemplate<typename T>\nT max(const set<T> s){\n\tassert(!s.empty());\n\treturn *--s.end();\n}\ntemplate<typename T, typename G>\nvector<T> set_max(vector<T> &base, const vector<G> &comp){\n\tassert(base.size() == comp.size());\n\tfor(int i = 0; i < (int)comp.size(); ++i)\n\t\tbase[i] = max(base[i],comp[i]);\n\treturn base;\n}\ntemplate <typename T>\nvector<T> unique(vector<T> &arr){\n    sort(all(arr));\n\tarr.erase(unique(all(arr)),arr.end());\n\treturn arr;\n}\nconst int N = 5e5+5;\nbool prime[N];\nll gcd(ll x, ll y){\n    if(y == 0)\n        return x;\n    return gcd(y,x%y);\n}\nvoid alternate(vi &arr){\n    vi ans;\n    for(int i = 0; i < 250; ++i){\n        ans.pb(arr[i]);\n        ans.pb(arr[499-i]);\n    }\n    arr = ans;\n}\nvoid _(){\n    fill(prime+2,prime+N,true);\n    vector<int> primes;\n    for(int i = 2; i < N; ++i)\n        if(prime[i]){\n            for(int j = 2*i; j < N; j += i)\n                prime[j] = false;\n            primes.push_back(i);\n        }\n    primes.resize(1000);\n    vi p1;\n    vi p2;\n    for(int i = 0; i < 1000; ++i)\n        if(i%2) \n            p1.pb(primes[i]);\n        else\n            p2.pb(primes[i]);\n    alternate(p1);\n    alternate(p2);\n    //print(p1);\n    //print(p2);\n    int n;\n    cin >> n;\n    if(n == 2){\n        cout << \"4 7 \\n23 10\\n\";\n        return;\n    }\n    vector<ll> arr;\n    vvl grid(n,vl(n));\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 == j % 2){\n                int d1 = (i+j)/2;\n                int d2 = (i-j+n-1)/2;\n                ll a = p1[d1];\n                ll b = p2[d2];\n                grid[i][j] = a*b;\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j){\n            if(i % 2 != j % 2){\n                vl neigh;\n                if(i > 0) neigh.pb(grid[i-1][j]);\n                if(i+1 < n) neigh.pb(grid[i+1][j]);\n                if(j > 0) neigh.pb(grid[i][j-1]);\n                if(j+1 < n) neigh.pb(grid[i][j+1]);\n                ll ans = 1;\n                for(ll x : neigh){\n                    ans = ans*(x/gcd(ans,x));\n                }\n                grid[i][j] = ans+1;\n                assert(grid[i][j] < 1e15);\n                for(auto cur : neigh)\n                    assert(grid[i][j]%cur == 1);\n            }\n        }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            arr.push_back(grid[i][j]);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            cout << grid[i][j]  << \" \\n\"[j==n-1];\n    sort(all(arr));\n    arr.erase(unique(all(arr)),arr.end());\n    assert(arr.size() == n*n);\n    //cout << n*n << ' ' << arr.size() << '\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcout << fixed << setprecision(12);\n\t_();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define ull unsigned long long\n#define ULL ull\n#define mp make_pair\n#define pii pair<int,int>\n#define piii pair<int, pii >\n#define pll pair <ll,ll>\n#define pb push_back\n#define big 20160116\n#define INF 2147483647\n#define pq priority_queue\n#define rank rk124232\n#define y1 y20160116\n#define y0 y20160110\n#define _ 0\nusing namespace std;\n#ifndef MY\n\t#define putchar IO::_putchar\n\t#define getchar IO::_getchar\n#endif\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read()\n{\n    int x=0,p=1;\n\tchar c=getchar();\n    while (c<'0' || c>'9'){\n    \tif (c=='-') p=-1;\n    \tc=getchar();\n\t}\n    while (c>='0' && c<='9') x=x*10+c-48,c=getchar();\n    return x*p;\n}\nnamespace Mymath{\n\tLL qp(LL x,LL p,LL mod){\n\t\tLL ans=1;\n\t\twhile (p){\n\t\t\tif (p&1) ans=ans*x%mod;\n\t\t\tx=x*x%mod;\n\t\t\tp>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tLL inv(LL x,LL mod){\n\t\treturn qp(x,mod-2,mod);\n\t}\n\tLL C(LL N,LL K,LL fact[],LL mod){\n\t\treturn fact[N]*inv(fact[K],mod)%mod*inv(fact[N-K],mod)%mod;\n\t}\n\ttemplate <typename Tp> Tp gcd(Tp A,Tp B){\n\t\tif (B==0) return A;\n\t\treturn gcd(B,A%B);\n\t}\n\ttemplate <typename Tp> Tp lcm(Tp A,Tp B){\n\t\treturn A*B/gcd(A,B);\n\t}\n};\nnamespace fwt{\n\tusing namespace Mymath;\n\tvoid FWT(int a[],int n,LL mod)\n\t{\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;\n\t                //xor:a[i+j]=x+y,a[i+j+d]=x-y;\n\t                //and:a[i+j]=x+y;\n\t                //or:a[i+j+d]=x+y;\n\t            }\n\t}\n\n\tvoid UFWT(int a[],int n,LL mod)\n\t{\n\t\tLL rev=inv(2,mod);\n\t    for(int d=1;d<n;d<<=1)\n\t        for(int m=d<<1,i=0;i<n;i+=m)\n\t            for(int j=0;j<d;j++)\n\t            {\n\t                int x=a[i+j],y=a[i+j+d];\n\t                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;\n\t                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;\n\t                //and:a[i+j]=x-y;\n\t                //or:a[i+j+d]=y-x;\n\t            }\n\t}\n\tvoid solve(int a[],int b[],int n,LL mod)\n\t{\n\t    FWT(a,n,mod);\n\t    FWT(b,n,mod);\n\t    for(int i=0;i<n;i++) a[i]=1LL*a[i]*b[i]%mod;\n\t    UFWT(a,n,mod);\n\t}\n};\nnamespace Maxflow{\n\tconst int Maxn=1005;\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tedge(int _to,int _rev,int _cap){\n\t\t\tto=_to,rev=_rev,cap=_cap;\n\t\t}\n\t};\n\tint src=1002,snk=1003;\n\tvector<edge> G[Maxn];\n\tint dist[Maxn],seen[Maxn];\n\tint n;\n\tvoid Clear(){\n\t\tfor (int i=0;i<Maxn;i++) G[i].clear();\n\t}\n\tvoid bfs(int s){\n\t\tfor (int i=0;i<Maxn;i++) dist[i]=-1;\n\t\tdist[s]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()){\n\t\t\tint x=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i=0;i<G[x].size();i++){\n\t\t\t\tedge &e=G[x][i];\n\t\t\t\tif (e.cap && dist[e.to]==-1){\n\t\t\t\t\tdist[e.to]=dist[x]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int now,int dest,int fl){\n\t\tif (now==dest) return fl;\n\t\tfor (int &i=seen[now];i<G[now].size();i++){\n\t\t\tedge &ed=G[now][i];\n\t\t\tif (ed.cap && dist[ed.to]==dist[now]+1){\n\t\t\t\tint f=dfs(ed.to,dest,min(fl,ed.cap));\n\t\t\t\tif (f){\n\t\t\t\t\ted.cap-=f;\n\t\t\t\t\tG[ed.to][ed.rev].cap+=f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dinic(int s=src,int t=snk){\n\t\tint ret=0;\n\t\twhile (1){\n\t\t\tmemset(seen,0,sizeof(seen));\n\t\t\tbfs(s);\n\t\t\tif (dist[t]==-1) return ret;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\twhile(f){\n\t\t\t\tret+=f;\n\t\t\t\tf=dfs(s,t,INF);\n\t\t\t}\n\t\t}\n\t}\n};\nnamespace Geometry{\n\tstruct iP{\n\t\tLL x,y;\n\t\tiP(LL _x,LL _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tiP(){\n\t\t\tx=y=0;\n\t\t}\n\t\tiP operator +(iP p){\n\t\t\treturn iP(x+p.x,y+p.y);\n\t\t}\n\t\tiP operator -(iP p){\n\t\t\treturn iP(x-p.x,y-p.y);\n\t\t}\n\t\tiP operator *(LL k){\n\t\t\treturn iP(x*k,y*k);\n\t\t}\n\t\tLL det(iP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tLL dot(iP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tLL dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const iP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tstruct dP{\n\t\tdouble x,y;\n\t\tdP(double _x,double _y){\n\t\t\tx=_x,y=_y;\n\t\t}\n\t\tdP(){\n\t\t\tx=y=0.0;\n\t\t}\n\t\tdP operator +(dP p){\n\t\t\treturn dP(x+p.x,y+p.y);\n\t\t}\n\t\tdP operator -(dP p){\n\t\t\treturn dP(x-p.x,y-p.y);\n\t\t}\n\t\tdP operator *(double k){\n\t\t\treturn dP(x*k,y*k);\n\t\t}\n\t\tdouble det(dP p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\tdouble dot(dP p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\tdouble dist(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tbool operator <(const dP &p)const{\n\t\t\tif (x!=p.x) return x<p.x;\n\t\t\treturn y<p.y;\n\t\t}\n\t};\n\tvector<iP> convex_hull(iP X[],int l){\n\t\t#define sz ret.size()\n\t\tvector<iP> ret;\n\t\tsort(X+1,X+1+l);\n\t\tret.pb(X[1]);\n\t\tfor (int i=2;i<=l;i++){\n\t\t\twhile (sz>=2 && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\tint rs=ret.size()+1;\n\t\tfor (int i=l-1;i>=1;i--){\n\t\t\twhile (sz>=rs && (ret[sz-2]-X[i]).det(ret[sz-1]-X[i])>=0){\n\t\t\t\tret.pop_back();\n\t\t\t}\n\t\t\tret.pb(X[i]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nconst int Maxn=505;\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\nvector<int> p;\nint n;\nLL ans[Maxn][Maxn];\nmap<int,int> xmy,xay;\nint main(){\n\tn=read();\n\tn+=2;\n\tfor (int i=2;i<10000;i++){\n\t\tbool flag=true;\n\t\tfor (int j=2;j*j<=i;j++){\n\t\t\tif (i%j==0) flag=false;\n\t\t}\n\t\tif (flag) p.pb(i);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\txmy[i-j]=0;xay[i+j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor (map<int,int>::iterator it=xmy.begin();it!=xmy.end();it++){\n\t\tit->second=p[cnt++];\n\t}\n\tfor (map<int,int>::iterator it=xay.begin();it!=xay.end();it++){\n\t\tit->second=p[cnt++];\n\t}\n\tcout<<cnt<<endl;\n\t//return 0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tans[i][j]=xmy[i-j]*xay[i+j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1){\n\t\t\t\tans[i][j]=1;\n\t\t\t\tfor (int k=0;k<4;k++){\n\t\t\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\t\t\tif (ni && nj && ni<=n && nj<=n){\n\t\t\t\t\t\tLL tmp=__gcd(ans[i][j],ans[ni][nj]);\n\t\t\t\t\t\tans[i][j]/=tmp;\n\t\t\t\t\t\tans[i][j]*=ans[ni][nj];\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=2;i<=n-1;i++){\n\t\tfor (int j=2;j<=n-1;j++){\n\t\t\t//assert(ans[i][j]<=1000000000000000LL);\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn ~~(0^_^0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nvector<ll> primes;\nvoid gen_primes(){\n    primes.push_back(2);\n    while((int) primes.size() < 2 * N){\n        ll cur = primes.back() + 1;\n        while(true){\n            bool ok = false;\n            for(ll p: primes){\n                if(cur % p == 0){\n                    ok = true;\n                    break;\n                }\n            }\n            if(!ok){\n                primes.push_back(cur);\n                break;\n            }\n            cur++;\n        }\n    }\n}\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    gen_primes();\n    random_shuffle(primes.begin(), primes.end());\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            int diag1 = (i + j) / 2, diag2 = (i - j) / 2 + N + N / 2;\n            assert(diag1 >= 0 && diag1 < N);\n            assert(diag2 >= N && diag2 < 2 * N);\n            a[i][j] = primes[diag1] * primes[diag2];\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            a[i][j] = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    a[i][j] *= a[ni][nj];\n                }\n            }\n            a[i][j]++;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll a[510][510];\n\nconst int dx[4] = {-1,1,0,0};\nconst int dy[4] = {0,0,-1,1};\n\nint main() {\n\tint N; cin >> N;\n\n\tvector<ll> vec;\n\tconst int MX = 100000;\n\tvector<int> pr(MX);\n\n\tfor (int i = 2; i < MX && vec.size() <= N * 3; ++i) {\n\t\tif (!pr[i]) {\n\t\t\tvec.pb(i);\n\t\t\tfor (int j = i * 2; j < MX; j += i) {\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif ((i + j) & 1) continue;\n\t\t\ta[i][j] = vec[(i+j)/2] * vec[(i-j+N)/2+N];\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tll t = 1;\n\t\t\t\trep(dir, 4) {\n\t\t\t\t\tint ni = i + dx[dir], nj = j + dy[dir];\n\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < N && nj < N) {\n\t\t\t\t\t\tll d = __gcd(t, a[ni][nj]);\n\t\t\t\t\t\tt = t / d * a[ni][nj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j] = t + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tcout << a[i][j] << (j == N-1 ? '\\n' : ' ');\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 2000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint pri[N],p[N],tot;\ninline void sieve(int n)\n{\tfor(rint i=2;i<=n;i++)\n\t{\tif(!pri[i]) p[++tot]=i;\n\t\tfor(rint j=1;j<=tot&&i*p[j]<=n;j++)\n\t\t{\tpri[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll a[666][666]; int mov[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\ninline ll lcm(ll x,ll y){return x*y/__gcd(x,y);}\nint main()\n{\tint n,cur=1; cin>>n; sieve(1e6);\n\tif(n==2) return !printf(\"4 7\\n23 10\");\n\tfor(rint i=0;i<=n+1;i++)\n\tfor(rint j=0;j<=n+1;j++) a[i][j]=1;\n\tfor(rint i=3;i<=n+n;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i-j&&i-j<=n) a[j][i-j]*=p[cur];\n\tfor(rint i=1;i<=n-1;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=-1;i>=1-n;i-=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=1;i<=n;i++)\n\tfor(rint j=1;j<=n;j++)\n\tif((i+j)%2==0)\n\t{\tfor(rint k=0;k<4;k++) a[i][j]=lcm(a[i][j],a[i+mov[k][0]][j+mov[k][1]]);\n\t\ta[i][j]++;\n\t}\n\tfor(rint i=1;i<=n;i++,cout<<\"\\n\")\n\tfor(rint j=1;j<=n;j++) cout<<a[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=505;\nint read(){\n\tint f=1,g=0;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n;\nll pr[N+N],a[N][N],b[N+N];\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return b?(a/gcd(a,b)*b):a;}\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tscanf(\"%d\",&n);n+=2;\n\tfor (int i=2;pr[0]<=n+n+2;i++){\n\t\tint fl=1;\n\t\tfor (int j=2;j*j<=i;j++)\n\t\tif (i%j==0){fl=0;break;}\n\t\tif (fl) pr[++pr[0]]=i;\n\t}\n\tint i=1,j=n+n+2;\n\twhile (i<j){\n\t\tb[++b[0]]=pr[i++];\n\t\tb[++b[0]]=pr[j--];\n\t}\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\tif (!((i+j)&1)){\n\t\tint x=(i+j)>>1,y=(n-i+1+j)>>1;\n\t\ta[i][j]=b[x]*b[y+n];\n\t}\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\tif ((i+j)&1){\n\t\ta[i][j]=1;\n\t\ta[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\ta[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\ta[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\ta[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\ta[i][j]++;\n\t}\n\tfor (int i=2;i<n;i++)\n\tfor (int j=2;j<n;j++)\n\tprintf(\"%lld%c\",a[i][j],(j==n-1) ? '\\n' : ' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    ll cur = 2;\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            a[i][j] = cur++;\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            a[i][j] = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    a[i][j] = LCM(a[i][j], a[ni][nj]);\n                }\n            }\n            a[i][j]++;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst double eps = 1e-8;\n\nconst ll INF = 1e15;\n\nll BIG = 5000000;\n\nint main(){\n\tll N;\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\tvector<int> isprime(BIG, 1);\n\tvector<ll> primes;\n\tfor (ll base = 2;primes.size() < N*N / 2 + 10;base++) {\n\t\tif (!isprime[base])\n\t\t\tcontinue;\n\t\tprimes.push_back(base);\n\t\tfor (ll mult = 2;mult*base < isprime.size();mult++)\n\t\t\tisprime[mult*base] = false;\n\t}\n\tll cnt = 0;\n\tvector<vector<ll>> ans(N+2, vector<ll>(N+2, 1));\n\tfor (int y = 1;y <= N;y++)\n\t\tfor (int x = 1;x <= N;x++) {\n\t\t\tif ((y + x) % 2) {\n\t\t\t\tans[y][x] = primes[cnt];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\tfor (int y = 1;y <= N;y++)\n\t\tfor (int x = 1;x <= N;x++) {\n\t\t\tif ((y + x) % 2 == 0) {\n\t\t\t\tans[y][x] = ans[y + 1][x] * ans[y - 1][x] * ans[y][x + 1] * ans[y][x - 1] + 1;\n\t\t\t}\n\t\t}\n\tfor (int y = 1;y <= N;y++)\n\t\tfor (int x = 1;x <= N;x++) {\n\t\t\tcout << ans[y][x];\n\t\t\tif (x == N)\n\t\t\t\tcout << endl;\n\t\t\telse\n\t\t\t\tcout << \" \";\n\t\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nmap<int,int> d1, d2;\n\nbool prime(int n) {\n    for (int d = 2; d*d <= n; d++) if (n%d == 0) return 0;\n    return 1;\n}\n\nll gcd(ll a, ll b) { return a ? gcd(b%a,a) : b; }\nll lcm(ll a, ll b) { return a / gcd(a,b) * b; }\n\nint main() {\n    int n; cin >> n;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i+j)%2) {\n            d1[i+j] = d2[i-j] = 0;\n        }\n\n    int need = d1.size() + d2.size();\n    vector<int> primes;\n    for (int p = 3; ; ++p) if (prime(p)) {\n        primes.push_back(p);\n        if (primes.size() == need) break;\n    }\n\n    for (auto &xy : d1) xy.second = primes.back(), primes.pop_back();\n    for (auto &xy : d2) xy.second = primes.back(), primes.pop_back();\n\n    static ll ans[505][505];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i+j)%2 == 1) {\n            ans[i][j] = (ll) d1[i+j] * d2[i-j];\n        }\n\n    map<ll,int> cnt;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i+j)%2 == 0) {\n            ll x = 1;\n            if (i) x = lcm(x, ans[i-1][j]);\n            if (j) x = lcm(x, ans[i][j-1]);\n            if (i+1 < n) x = lcm(x, ans[i+1][j]);\n            if (j+1 < n) x = lcm(x, ans[i][j+1]);\n            ans[i][j] = x+1;\n            while (cnt.count(ans[i][j])) ans[i][j] += x;\n            ++cnt[ans[i][j]];\n        }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)  \n            cout << ans[i][j] << ' ';\n        cout << '\\n';\n    }\n    return 0;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            assert(ans[i][j] <= ll(1e15));\n            assert(++cnt[ans[i][j]] < 2);\n            if ((i+j)%2 == 0)  {\n                for (int di = -1; di <= 1; di++)\n                    for (int dj = -1; dj <= 1; dj++) if (abs(di) + abs(dj) == 1) {\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            assert(ans[i][j] % ans[ni][nj] == 1);\n                        }\n                    }\n            }\n        }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nlong long ans[501][501];\nlong long prime[1001];\nvoid initprime() {\n\tint pn=0;\n\tlong long base=2;\n\tfor (int i=0; i<1000;) {\n\t\tauto isprime = [&](long long a) {\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tif (a%prime[k] == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\t\t// cout<<i<<\" \"<<base<<endl;\n\t\tif (isprime(base))\n\t\t\tprime[i++] = base++;\n\t\telse\n\t\t\tbase++;\n\t}\n}\nint main() {\n\tinitprime();\n\tint n; cin>>n;\n\t// diagonal from (0,0) to (n-1,n-1);\n\tauto idxA = [&] (int x, int y) -> int { return x<y?(y-x-1):(x-y); };\n\t// diagonal from (0,n-1) to (n-1,0);\n\tauto idxB = [&] (int x, int y) -> int { return 300 + ( (x+y<n)?(x+y):((n-(x+y)/2)*2-1) ); };\n\n\tauto isVaild = [&](int x, int y) {\n\t\tif (x<0 || x>=n || y<0 || y>=n)\n\t\t\treturn false;\n\t\treturn true;\n\t};\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=i%2; j<n; j+=2)\n\t\t\tans[i][j] = prime[idxA(i,j)]*prime[idxB(i,j)];\n\t\tfor (int j=(i+1)%2; j<n; j+=2) {\n\t\t\tans[i][j] = 1;\n\t\t\tif (isVaild(i,j+1) || isVaild(i+1,j)) // if ((i+j+1)/2 < n)\n\t\t\t\tans[i][j] *= prime[idxB(i,j+1)];\n\t\t\tif (isVaild(i-1,j) || isVaild(i,j-1)) // if (0 <= (i+j-1)/2)\n\t\t\t\tans[i][j] *= prime[idxB(i,j-1)];\n\t\t\tif (isVaild(i-1,j) || isVaild(i,j+1)) // if (-n+1 < x-y)\n\t\t\t\tans[i][j] *= prime[idxA(i-1,j)];\n\t\t\tif (isVaild(i,j-1) || isVaild(i+1,j)) // if (x-y < n-1)\n\t\t\t\tans[i][j] *= prime[idxA(i+1,j)];\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tlong long tmax=0;\n\tunordered_map<long long, pair<int,int> > hit;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<n; j++) {\n\t\t\ttmax = max(tmax, ans[i][j]);\n\t\t\tif (hit.find(ans[i][j]) != hit.end()) {\n\t\t\t\tcout<<\">>hit \"<<i<<\",\"<<j<<\" == \"<<ans[i][j]<<endl;\n\t\t\t\tcout<<\"\\t Collide : \"<<hit[ans[i][j]].first<<\", \"<<hit[ans[i][j]].second<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else\n\t\t\t\thit[ans[i][j]] = make_pair(i,j);\n\t\t}\n\t// cout<<tmax<<endl;\n\tfor (int i=0; i<n; i++, cout<<endl)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tcout<<ans[i][j]<<\"\\t\";\n\t// cout<<\"debug \"<<ans[258][147]<<\" \"<<ans[72][397]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\tscanf(\"%d\", &n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1)){\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0 ; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\t\t\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\t}\n\t\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) a[i][j] *= b[i][j];\n\t\n\t\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tfor (int d=0 ; d<4; ++d){\n\t\t\tint x= i+dx[d], y=j+dy[d];\n\t\t\tif ( x<0 || x>=n || y<0 || y>=n ) continue;\n\t\t\ts =(__int128)s*a[x][y]/__gcd(s, a[x][y]);\n\t\t}\n\t\ta[i][j] = s+1;\n\t}\n\tif( n==2) a[1][1] = 2*a[1][1]-1;\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint calc(int x){\n\tint c=0;\n//\tfor(int i=2;i<=x;++i)if(x%i==0)for(++c;x%i==0;x/=i);\n\tfor(int i=2;i<=x;++i)if(x%i==0)for(;x%i==0;++c,x/=i);\n\treturn c;\n}\nconst int N=505;\ntypedef long long ll;\nint a[N*2],aa[N*2],xb,i,j,n;ll b[N][N];\ninline ll lcm(ll a,ll b){\n\treturn a/std::__gcd(a,b)*b;\n}\ninline void spj(){\n\tunordered_set<ll>s;\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)s.insert(b[i][j]),\n\t\tassert(b[i][j]<=1e15);\n\tassert(s.size()==n*n);\n\tfor(i=1;i<=n;++i)for(j=1;j<n;++j)assert(max(b[i][j],b[i][j+1])%min(b[i][j],b[i][j+1])==1); \n\tfor(i=1;i<n;++i)for(j=1;j<=n;++j)assert(max(b[i+1][j],b[i][j])%min(b[i+1][j],b[i][j])==1); \n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tint l=0,r=n*2+1;\n\tfor(i=2;xb<n*2;++i)if(calc(i)<2)a[++xb]=i;\n\t\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j){\n\t\tint x=i+j,y=i-j+n;\n\t\tif(x&1)b[i][j]=a[x/2]*a[n+(y+1)/2];\n\t\tif(x%2==1 && abs(i-2)+abs(j-222)==1){\n\t\t\t++i,--i;\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)if((i+j)%2==0){\n\t\tll ans=1;\n\t\tif(i>1)ans=lcm(ans,b[i-1][j]);\n\t\tif(i<n)ans=lcm(ans,b[i+1][j]);\n\t\tif(j>1)ans=lcm(ans,b[i][j-1]);\n\t\tif(j<n)ans=lcm(ans,b[i][j+1]);\n\t\tif(ans>1ll*a[n*2]*a[n*2-1]*a[n]*a[n-1]) {\n\t\t\t++i,--i;\n\t\t}\n\t\tb[i][j]=ans+1;\n\t}\n\tspj();\n\tfor(i=1;i<=n;++i,puts(\"\"))for(j=1;j<=n;++j)printf(\"%lld \",b[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) FOR(i,0,n)\n#define ROF(i,a,b) for(ll i=a;i>=b;i--)\n#define per(i,a) ROF(i,a,0)\n#define pb push_back\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ch=char;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vP;\ntypedef vector<ch> vc;\ntypedef vector<vc> vvc;\nconst ll MOD=1000000007;\nconst ll MOD2=998244353;\nconst ld PI=acos(-1);\nconst ll INF=1e18;\nstruct edge{ll to,cost;};\nstruct edge2{ll from,to,cost;};\n\ntemplate <typename T>\nbool chmax(T &a, const T& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N;\n    cin >> N;\n    int MXN=500;\n    ll ans[MXN][MXN];\n    vector<bool> is_prime(10000,true);\n    is_prime[0]=is_prime[1]=false;\n    vl p;\n    FOR(i,2,10000){\n        if(is_prime[i]){\n            if(i>=500){\n                p.pb(i);\n            }\n            ll j=2*i;\n            while(j<10000){\n                is_prime[j]=false;\n                j+=i;\n            }\n        }\n    }\n    rep(i,MXN){\n        rep(j,MXN){\n            if(i%2==j%2){\n                ans[i][j]=p[i+j]*(250-(j-i)/2);\n            }\n            else{\n                ans[i][j]=1;\n            }\n        }\n    }\n    rep(i,MXN){\n        rep(j,MXN){\n            if((i+j)%2==1){\n                if(i!=0)ans[i][j]=lcm(ans[i][j],ans[i-1][j]);\n                if(j!=0)ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n                if(i!=MXN-1)ans[i][j]=lcm(ans[i][j],ans[i+1][j]);\n                if(j!=MXN-1)ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n                ans[i][j]++;\n            }\n        }\n    }\n    rep(i,N){\n        rep(j,N){\n            cout << ans[i][j] << ( j==N-1 ? '\\n' : ' ' );\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 5555555\n#define M 2020\nusing namespace std;\n\nint vis[N];\nvector<int> pri;\n\nvoid sieve(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (!vis[i]) pri.push_back(i);\n        for (int j : pri) {\n            if (1ll * i * j > n) break;\n            vis[i * j] = 1;\n            if (i % j == 0) break;\n        }\n    }\n}\n\nlong long a[M][M];\nint n, top, p[2][M << 2];\n\nlong long lcm(long long x, long long y) {\n    return x / __gcd(x, y) * y;\n}\n\nint get(int op, int x) {\n    if (op) x += n;\n    if (!p[op][x]) p[op][x] = pri[top++];\n    return p[op][x];\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    if (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\n    sieve(10000);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if ((i + j) & 1)\n                a[i][j] = 1ll * get(0, i + j) * get(1, i - j);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (!((i + j) & 1)) {\n                a[i][j] = 1;\n                if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n                if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n                if (i < n) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n                if (j < n) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n                ++a[i][j];\n            }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            printf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[505][505];\nint primes[1011];\nint tot = 0;\n\nlong long lcm(long long a,long long b) {\n\treturn a / __gcd(a, b) * b;\n}\nvoid build() {\n\tint ptr = 2;\n\twhile (tot < 1007) {\n\t\tbool prime = 1;\n\t\tfor (int i = 2; i * i <= ptr; ++i) {\n\t\t\tif (ptr % i == 0) {\n\t\t\t\tprime = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (prime) primes[tot++] = ptr;\n\t\tptr++;\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int j = 0; j < 500; ++j) {\n\t\t\tif (!(i + j & 1)) {\n\t\t\t\ta[i][j] = primes[(i + j) / 2] * primes[(i - j) / 2 + 752];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 500; ++i) {\n\t\tfor (int j = 0; j < 500; ++j) {\n\t\t\tif (i + j & 1) {\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tif (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n\t\t\t\tif (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n\t\t\t\tif (i < 499) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n\t\t\t\tif (j < 499) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tbuild();\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcout << a[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nmap<int,int> d1, d2;\n\nbool prime(int n) {\n    for (int d = 2; d*d <= n; d++) if (n%d == 0) return 0;\n    return 1;\n}\n\nll gcd(ll a, ll b) { return a ? gcd(b%a,a) : b; }\nll lcm(ll a, ll b) { return a / gcd(a,b) * b; }\n\nint main() {\n    int n; cin >> n;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i+j)%2) {\n            d1[i+j] = d2[i-j] = 0;\n        }\n\n    int need = d1.size() + d2.size();\n    vector<int> primes;\n    for (int p = 2; ; ++p) if (prime(p)) {\n        primes.push_back(p);\n        if (primes.size() == need) break;\n    }\n\n    for (auto &xy : d1) xy.second = primes.back(), primes.pop_back();\n    for (auto &xy : d2) xy.second = primes.back(), primes.pop_back();\n\n    static ll ans[505][505];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i+j)%2 == 1) {\n            ans[i][j] = (ll) d1[i+j] * d2[i-j];\n        }\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if ((i+j)%2 == 0) {\n            ll x = 1;\n            if (i) x = lcm(x, ans[i-1][j]);\n            if (j) x = lcm(x, ans[i][j-1]);\n            if (i+1 < n) x = lcm(x, ans[i+1][j]);\n            if (j+1 < n) x = lcm(x, ans[i][j+1]);\n            ans[i][j] = x+1;\n        }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)  \n            cout << ans[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    map<ll,int> cnt;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            assert(ans[i][j] <= ll(1e15));\n            assert(++cnt[ans[i][j]] < 2);\n            if ((i+j)%2 == 0)  {\n                for (int di = -1; di <= 1; di++)\n                    for (int dj = -1; dj <= 1; dj++) if (abs(di) + abs(dj) == 1) {\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            assert(ans[i][j] % ans[ni][nj] == 1);\n                        }\n                    }\n            }\n        }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ff first\n#define ss second\n#define ll long long\nusing namespace std;\ntypedef pair<char,int> pii;\nset<ll>mapa;\nconst int maxv=2300000;\nint n,pos[maxv+10],br;\nll primes[maxv],rows[1010],cols[1010],aa[519][510];\nvector<ll>a[510][510];\nvoid check(){\n\nll maxx=LONG_MIN;\nll minn=LONG_MAX;\nset<ll>mapa2;\n    for(int i=1;i<=n;i++){\n\n        for(int j=1;j<=n;j++){\n\n            if(i<n){\n                mapa.insert(max(aa[i][j],aa[i+1][j])%min(aa[i][j],aa[i+1][j]));\n            }\n            if(j<n){\n                mapa.insert(max(aa[i][j],aa[i][j+1])%min(aa[i][j],aa[i][j+1]));\n            }\n\n            maxx=max(maxx,aa[i][j]);\n            minn=min(minn,aa[i][j]);\n            mapa2.insert(aa[i][j]);\n        }\n\n    }\nprintf(\"%d %d %lld %lld\\n\",mapa.size(),mapa2.size(),maxx,minn);\n}\nvoid sito(){\n\n    for(int i=2;i<=maxv;i++){\n        if(pos[i])continue;\n        primes[++br]=i;\n        for(int j=i;j<=maxv;j+=i)pos[j]=1;\n    }\n\n}\nll lcm(ll a,ll b){\n  return (a*b)/__gcd(a,b);\n}\nvoid fix(int x,int y){\n\n    ll lc=1;\n    set<ll>mm;\n\n    if(aa[x+1][y]!=0)\n        for(int i=0;i<a[x+1][y].size();i++)mm.insert(a[x+1][y][i]);\n    if(aa[x-1][y]!=0)\n        for(int i=0;i<a[x-1][y].size();i++)mm.insert(a[x-1][y][i]);\n    if(aa[x][y+1]!=0)\n        for(int i=0;i<a[x][y+1].size();i++)mm.insert(a[x][y+1][i]);\n    if(aa[x][y-1]!=0)\n        for(int i=0;i<a[x][y-1].size();i++)mm.insert(a[x][y-1][i]);\n\n    for(set<ll>::iterator it=mm.begin();it!=mm.end();it++)lc*=*it;\n\n    if(lc>1e15){\n       /// printf(\"AAAA %lld %lld %lld %lld %lld\\n\",a[x+1][y],a[x-1][y],a[x][y+1],a[x][y-1],lc);\n    }\n\n    aa[x][y]=lc+1;\n}\nint dist(int x,int y,int x1,int y1){\n   return abs(x-x1)+abs(y-y1);\n}\nint main(){\n\n    ///freopen(\"test.txt\",\"r\",stdin);\n\n    scanf(\"%d\",&n);\n\n    if(n==2){\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n\n    sito();\n\n    int curr=0;\n    for(int i=0;i<n;i++){\n        rows[i*2]=primes[++curr];\n       /// printf(\"%d %lld AA ROWS\\n\",i,primes[curr]);\n    }\n    for(int i=0;i<n;i++){\n        cols[i*2]=primes[++curr];\n       /// printf(\"%d %lld AA COLS\\n\",i,primes[curr]);\n    }\n\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n\n            if(dist(1,1,i,j)%2==0){\n                a[i][j].pb(rows[dist(1,1,i,j)]);\n                aa[i][j]=rows[dist(1,1,i,j)];\n            }\n\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n\n            if(n%2){\n               if(dist(n,1,i,j)%2==0){\n                a[i][j].pb(cols[dist(n,1,i,j)]);\n                aa[i][j]*=cols[dist(n,1,i,j)];\n               }\n            }\n            else{\n                if(dist(n,1,i,j)%2==1){\n                    a[i][j].pb(cols[dist(n,1,i,j)-1]);\n                    aa[i][j]*=cols[dist(n,1,i,j)-1];\n                }\n            }\n\n        }\n    }\n\n\n    ///printf(\"%d %lld %lld %lld SUM\\n\",sum,cols[100],rows[100],cols[100]*rows[100]);\n\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if((i+j)%2){\n                    fix(i,j);\n                    printf(\"%lld \",aa[i][j]);\n            }\n\n            else printf(\"%lld \",aa[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n\n\n    ///check();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,zs[500010];\nint n,b[510][510],c[510][501],ans[510][510];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=i;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%d \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nlong long a[550][550], c[550][550];\nusing namespace std;\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0; i <= n+2; i++){for(int j = 0; j <= n+2; j++){a[i][j] = c[i][j] = 1;}}\n    \n    vector<long long> primes;\n    vector<bool> visited(100000, 0);\n    for(int i = 2; i < 10000; i++){\n        if(!visited[i]){\n            primes.push_back(i);\n            for(int j = i; j < 100000; j+= i){\n                visited[j] = 1;\n            }\n        }\n    }\n    int cnt = 0;\n    for(int i = 0 ; i <= n; i+=2){\n        a[0][i] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 0; i <= n; i+=2){\n        a[i][0] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            a[i][j] = a[i-1][j-1];\n        }\n    }\n    \n    for(int i = n+1; i > 0; i-=2){\n        c[0][i] = primes[cnt];\n        cnt++;\n    }\n    for(int i = n+1; i > 0; i-=2){\n        c[i][n+1] = primes[cnt];\n        cnt++;\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            c[i][j] = c[i-1][j+1];\n            a[i][j] *= c[i][j];\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            if((i+j)%2){\n                a[i][j] *= a[i-1][j] * a[i+1][j]  + 1;\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001];\nint vis[100005], prm[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] =\n                1ll * prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; ++j)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x << \" = \" << x << endl\n#define fori(i, ini, lim) for(int i = int(ini); i < int(lim); i++)\n#define ford(i, ini, lim) for(int i = int(ini); i >= int(lim); i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\n\nconst int MAX = 1000 + 5;\nll mat[MAX][MAX];\nvector<int> primes;\nint n;\n\nvoid sieve() {\n    for(int i = 2; (int) primes.size() < MAX; i++) {\n        bool is_prime = true;\n        fori(j, 2, i) {\n            if(i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime) {\n            primes.push_back(i);\n        }\n    }\n}\n\nll gcd(ll a, ll b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n    return (a * (b / (gcd(a, b))));\n}\n\nbool construct() {\n    random_shuffle(primes.begin(), primes.end()); \n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            mat[i][j] = 1;\n        }\n    }\n    int k = 0;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == 1) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj <= n; ni++, nj++) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i == 1 || j == n) && (i + j) % 2 == 1) {\n                for(int ni = i, nj = j; ni <= n && nj >= 1; ni++, nj--) {\n                    mat[ni][nj] *= primes[k];                                        \n                }\n                k++;\n            }\n        }\n    }\n    const vector<ii> dir {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if((i + j) % 2 == 0) {\n                ll l = 1;\n                for(auto &each : dir) {\n                    int ni = i + each.first;\n                    int nj = j + each.second;\n                    if(ni >= 1 && ni <= n && nj >= 1 && nj <= n) {\n                        l = lcm(l, mat[ni][nj]);\n                    }\n                }\n                mat[i][j] = l + 1;\n            }\n        }\n    }\n    set<ll> all;\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            all.insert(mat[i][j]);\n        }\n    }\n    return (int) all.size() == n * n;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    srand(time(nullptr));\n    cin >> n;\n    if(n == 2) {\n        cout << \"4 7\" << '\\n';\n        cout << \"23 10\" << '\\n';\n        return 0;\n    }\n    sieve();\n    while(!construct());\n    fori(i, 1, n + 1) {\n        fori(j, 1, n + 1) {\n            if(j > 1) {\n                cout << \" \";\n            }\n            cout << mat[i][j];\n        }\n        cout << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\n// ここから編集しろ\nlong long ans[510][510];\nint p[21000];\nvector<int>v;\nlong long gcd(long long a,long long b){\n\twhile(a){b%=a;swap(a,b);}return b;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tp[0]=p[1]=-1;\n\tfor(int i=2;i<21000;i++){\n\t\tif(p[i]!=-1){\n\t\t\tif(i>2)v.push_back(i);\n\t\t\tp[i]=1;\n\t\t\tfor(int j=i+i;j<21000;j+=i)p[j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif((i+j)%2)continue;\n\t\t\tint X=(i+j)/2;\n\t\t\tint Y=(i-j+500)/2+500;\n\t\t\tlong long ks=1;\n\t\t\tks*=v[X];\n\t\t\tks*=v[Y];\n\t\t\tans[i][j]=ks;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif((i+j)%2){\n\t\t\t\tlong long cur=1;\n\t\t\t\tif(i)cur=cur/gcd(cur,ans[i-1][j])*ans[i-1][j];\n\t\t\t\tif(j)cur=cur/gcd(cur,ans[i][j-1])*ans[i][j-1];\n\t\t\t\tif(i<a-1)cur=cur/gcd(cur,ans[i+1][j])*ans[i+1][j];\n\t\t\t\tif(j<a-1)cur=cur/gcd(cur,ans[i][j+1])*ans[i][j+1];\n\n\t\t\t\tcur++;\n\t\t\t\tans[i][j]=cur;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(j)printf(\" \");\n\t\t\tprintf(\"%lld\",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\ngod taekyu\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n;\nll A[505][505];\nint cieve[10000005];\nint p[1500000], pcnt;\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin>>n;\n    for(int i=2;i<=1700004;i++) {\n        if(cieve[i] == 0) {\n            p[pcnt++] = i;\n            for(int j=i*2;j<1700005;j+=i) {\n                cieve[j] = 1;\n            }\n        }\n    }\n    int cnt = 0;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                A[i][j] = p[cnt++];\n            }\n        }\n    }\n    for(int i=0;i<=n+1;i++) {\n        A[0][i] = A[i][0] = A[n+1][i] = A[i][n+1] = 1;\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2 == 0) {\n                A[i][j] = (ll)A[i-1][j] * A[i+1][j] * A[i][j-1] * A[i][j+1] + 1;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            cout<<A[i][j]<<' ';\n        }\n        cout<<'\\n';\n    }\n    return 0;\n}\n\n/*\ngod taekyu\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdint>\nusing namespace std;\n\nconst int MAX = 1000000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 4 << \" \" << 7 << endl << 23 << \" \" << 10; // サンプルケースですね\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX];\n\tfor (int i = 0;i < MAX;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\tcout << prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積\n\t\t\t\tif (i == 0 && j == N - 1) cout << (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t\telse if (i == N - 1 && j == 0) cout << (int64_t)prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t\telse cout << (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは0だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = min(min(n - i + 1, n - j + 1), min(i, j)) + 1;\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int N = 505, P = 10005;\nint p[P], pc = 0;\nbool np[P];\nvoid prime_sieve(int n) {\n  for (int i = 2; i <= n; ++i) {\n    if (!np[i]) p[pc++] = i;\n    for (int j = 0; j < pc && i * p[j] <= n; ++j) {\n      np[i * p[j]] = true;\n      if (i % p[j] == 0) break;\n    }\n  }\n}\n\nll a[N][N];\n\nll gcd(ll x, ll y) {\n  ll t;\n  while (y) t = x, x = y, y = t % y;\n  return x;\n}\nll lcm(ll x, ll y) {\n  if (!x || !y) return x | y;\n  return x / gcd(x, y) * y;\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint n;\nint border(int x, int y) {\n  return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nint main() {\n  prime_sieve(10000);\n  read(n);\n  if (n == 2) {\n    write(4, 7), endl();\n    write(23, 10), endl();\n    return 0;\n  }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) {\n      if (((i ^ j) & 1) == 0) {\n        int l1 = (i + j) / 2;\n        int l2 = n + ((i - j) / 2) + (n - 1) / 2;\n        a[i][j] = p[l1] * p[l2];\n      }\n    }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (!a[i][j]) {\n        a[i][j] = 1;\n        for (int d = 0; d < 4; ++d)\n          if (border(i + dx[d], j + dy[d]))\n            a[i][j] = lcm(a[i][j], a[i + dx[d]][j + dy[d]]);\n        ++a[i][j];\n      }\n      write(a[i][j]), space();\n    }\n    endl();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <set>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 510;\nint n;\n\nll ans[N][N];\n\nset<ll> s;\n\nll gcd(ll x, ll y) {\n\twhile(y) {\n\t\tll t = y;\n\t\ty = x%y;\n\t\tx = t;\n\t}\n\treturn x;\n}\n\nll lcm(ll x, ll y) {\n\treturn x/gcd(x,y)*y;\n}\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\n\tll cur=2;\n\tint i;\n\tfor(i=0; i<=n; i+=4) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\ti-=2; if(i>n) i-=4;\n\twhile(i>0) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tans[i][j] = cur;\n\t\t\ts.insert(cur);\n\t\t\tcur++;\n\t\t}\n\t\ti-=4;\n\t}\n\n\tfor(int i=1; i<n; i+=2) {\n\t\tfor(int j=0; j<=n; j+=2) {\n\t\t\tll temp = lcm(ans[i-1][j], ans[i+1][j]);\n\t\t\tll t = temp+1;\n\t\t\twhile(s.count(t)) t+=temp;\n\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\n\t\tfor(int j=1; j<n; j+=2) {\n\t\t\tll temp = lcm(lcm(ans[i-1][j], ans[i+1][j]), lcm(ans[i][j-1], ans[i][j+1]));\n\t\t\tll t = temp+1;\n\n\t\t\twhile(s.count(t)) t+=temp;\n\t\t\tans[i][j] = t;\n\t\t\ts.insert(t);\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=0; j<n; j++) printf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nbool prime[50000005];\nint ans[501][501];\nvector<ll> vec;\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tmemset(prime,true,sizeof(prime));\n\tfor(ll i=2;i<50000005;i++){\n\t\tif(prime[i]){\n\t\t\tvec.push_back(i);\n\t\t\tfor(ll j=2LL*i;j<50000005;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tprintf(\"%lld%c\",vec[i*n+j]*vec[n*n]+vec[n*n+1],j+1==n?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll ans[1010][1010],n;\nbool vis[10101];\nint tot,p[10101];\ninline void init(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!vis[i]) p[++tot]=i;\n\t\tfor (int j=1;j<=tot;j++){\n\t\t\tif (1ll*i*p[j]>n) break;\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\ninline ll lcm(ll a,ll b){\n\tif (a*b==0) return a+b;\n\treturn a/__gcd(a,b)*b;\n}\nsigned main(){\n\tn=read();\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit(10000);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2==0){\n\t\t\t\tans[i][j]=1ll*p[(i+j)/2+n]*p[(i-j)/2+n];\n\t\t\t}\t\t\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)%2){\n\t\t\t\tans[i][j]=1+lcm(ans[i-1][j],lcm(ans[i][j-1],lcm(ans[i+1][j],ans[i][j+1])));\n\t\t\t}\t\t\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\n#include<queue>\n#include<string.h>\nusing namespace std;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void read (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: print;\n\ntypedef long long int LL;\nconst int maxn = 20007; \nint n; \nint prime[maxn]; \nbool vis[maxn]; \nvoid pre(int lim = 10000) {  \n    for(int cnt = 0,i = 2;i <= lim;++ i) { \n        if(!vis[i]) prime[++ cnt] = i; \n        for(int j = 1;j <= cnt && prime[j] * i <= lim;++ j) { \n            vis[i * prime[j]] = 1; \n            if(i % prime[j] == 0) break; \n        } \n    } \n} \nLL a[507][507]; \nLL gcd(LL x,LL y) { \n    return y == 0 ? x : gcd(y,x % y); \n} \nLL lcm(LL x,LL y) {\n    return x / gcd(x,y) * y; \n} \nint main() { \n\tint i,j,k;\n    read(n);\n    pre(); \n    if(n == 2) {\n        putc('4');putc(' ');putc('7');putc('\\n'); \n        print(23);putc(' '); print(10); putc('\\n'); \n        return 0;  \n    } \n    for(i=0;i<=n+1;i++)\n    \tfor(j=0;j<=n+1;j++)\n    \t\ta[i][j]=1;\n    for(i = 1;i <= n;++ i) \n        for(j = 1;j <= n;++ j) { \n            if((j & 1) == (i & 1)) { \n                a[i][j] = prime[(i + j) / 2] * prime[(i + n + 1 - j) / 2 + n];  \n                a[i + 1][j] = lcm(a[i + 1][j],a[i][j]); \n                a[i - 1][j] = lcm(a[i - 1][j],a[i][j]); \n                a[i][j + 1] = lcm(a[i][j + 1],a[i][j]); \n                a[i][j - 1] = lcm(a[i][j - 1],a[i][j]); \n            } \n        } \n    for(i = 1;i <= n;++ i) \n        for(j = 1;j <= n;++ j) \n            if((i & 1) == (j & 1)); \n            else a[i][j] ++; \n    for(i = 1;i <= n;++ i) \n    {\n    \tfor(j = 1;j <= n;++ j) \n            print(a[i][j]),putc(' '); \n        putc('\\n');\n    }    \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n;\nll ans[555][555];\n\ndeque<int>pri;\nbool np[1001000];\n\nll lcm(ll x,ll y){\n    if (!x||!y) return x+y;\n    return x/__gcd(x,y)*y;\n}\n\nvoid prepri(int n){\n    for (int i=2;i<=n;++i){\n        if (np[i]) continue;\n        if (i!=2) pri.push_back(i);\n        for (int j=i+i;j<=n;j+=i)\n            np[j]=1;\n    }\n}\n\nmap<int,ll>ad, su;\n\nint main(){\n    prepri(1e4);\n    cin>>n;\n    for (int i=0;i<=n+1;++i)\n        for (int j=0;j<=n+1;++j)\n            if ((i+j)%2==0){\n                if (!ad[i+j]){\n                    if (i+j/2&1){\n                        ad[i+j]=pri.front();\n                        pri.pop_front();\n                    }else{\n                        ad[i+j]=pri.back();\n                        pri.pop_back();\n                    }\n                }\n                if (!su[i-j]){\n                    if (i-j/2&1){\n                        su[i-j]=pri.front();\n                        pri.pop_front();\n                    }else{\n                        su[i-j]=pri.back();\n                        pri.pop_back();\n                    }\n                }\n                ans[i][j]=ad[i+j]*su[i-j];\n            }\n    int dx[4]={0,0,1,-1};\n    int dy[4]={1,-1,0,0};\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            if ((i+j)%2==1){\n                ll l=1;\n                for (int d=0;d<4;++d)\n                    l=lcm(l,ans[i+dx[d]][j+dy[d]]);\n                ans[i][j]=l+1;\n            }\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j){\n            printf(\"%lld \",ans[i][j]);\n        }\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = ll(1E15);\nconst int MAXN = 100000;\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nbool nprm[MAXN + 5];\nint prm[MAXN + 5], pcnt;\nvoid init() {\n\tfor(int i=2;i<=MAXN;i++) {\n\t\tif( !nprm[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;i*prm[j]<=MAXN;j++) {\n\t\t\tnprm[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nll a[505][505], p[1005], q[1005];\nint main() {\n\tinit(); int N; scanf(\"%d\", &N);\n\tif( N == 2 ) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tint cnt = 0;\n\tfor(int i=1;i<=N;i+=2)\n\t\tp[i] = prm[++cnt], q[i] = prm[++cnt];\n\tfor(int i=N-(N&1);i>=0;i-=2)\n\t\tp[i] = prm[++cnt], q[i] = prm[++cnt];\n\t\t\n\t\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i + j) % 2 == 0 )\n\t\t\t\ta[i][j] = p[(i + j)/2] * q[(i + N - j + 1)/2];\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++) {\n\t\t\tif( (i + j) % 2 == 0 ) continue;\n\t\t\ta[i][j] = 1;\n\t\t\tfor(int o=0;o<4;o++) {\n\t\t\t\tint x1 = i + dx[o], y1 = j + dy[o];\n\t\t\t\tif( x1 < 1 || x1 > N || y1 < 1 || y1 > N ) continue;\n\t\t\t\ta[i][j] = a[i][j] / gcd(a[i][j], a[x1][y1]) * a[x1][y1];\n\t\t\t}\n\t\t\ta[i][j]++, assert(a[i][j] <= INF);\n\t\t}\n\t\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tprintf(\"%lld%c\", a[i][j], j == N ? '\\n' : ' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<list>\n#include<deque>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1000)\nvector<int>prim;\n\nvoid prim_make(int k){\n\tif (k >= 2)prim.push_back(2);\n\tif (k >= 3)prim.push_back(3);\n\tif (k >= 5)prim.push_back(5);\n\tint x = 7;\n\tbool v;\n\twhile (x <= k){\n\t\tv = true;\n\t\tfor (int i = 2; prim[i] * prim[i] <= x; i++){\n\t\t\tif (x%prim[i] == 0){\n\t\t\t\tv = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (v)prim.push_back(x);\n\t\tif (x % 6 == 1)x += 4;\n\t\telse x += 2;\n\t}\n\treturn;\n}\n\n\n\n\n\n\nint main(){\n\tlong long a[N][N];\n\tset<long long>s;\n\tvector<int>ve1,ve2;\n\tint n;\n\tlong long k, x, y, z;\n\tlong long ans;\n\tbool v1, v2;\n\tprim_make(100000);\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tx = 9000;\n\twhile(x>0){\n\t\tve1.push_back(x);\n\t\tx -= 2;\n\t}\n\tx = 9002;\n\twhile (x<18002){\n\t\tve2.push_back(x);\n\t\tx += 2;\n\t}\n\tx = 3;\n\twhile (x<12000){\n\t\tve1.push_back(x);\n\t\tx += 6;\n\t}\n\tx = 23997;\n\twhile (x > 12000){\n\t\tve2.push_back(x);\n\t\tx -= 6;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tf(i, n){\n\t\tf(j, n)a[i][j] = -1;\n\t}\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tif ((i + j) % 4 == 0){\n\t\t\t\ta[i][j] = ve1[x];\n\t\t\t\ts.insert(ve1[x]);\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ((i + j) % 4 == 2){\n\t\t\t\ta[i][j] = ve2[y];\n\t\t\t\ts.insert(ve2[y]);\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=n-1;j>=0;j--){\n\t\t\tif (a[i][j] == -1){\n\t\t\t\tans = 1;\n\t\t\t\tv1 = true;\n\t\t\t\tv2 = true;\n\t\t\t\tx = 0;\n\t\t\t\tif (i > 0){\n\t\t\t\t\tans = ans*a[i - 1][j];\n\t\t\t\t\tif (a[i - 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i - 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (i < (n - 1)){\n\t\t\t\t\tans = ans*a[i + 1][j];\n\t\t\t\t\tif (a[i + 1][j] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i + 1][j] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j > 0){\n\t\t\t\t\tans = ans*a[i][j - 1];\n\t\t\t\t\tif (a[i][j-1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j-1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (j < (n - 1)){\n\t\t\t\t\tans = ans*a[i][j + 1];\n\t\t\t\t\tif (a[i][j + 1] % 2 != 0)v1 = false;\n\t\t\t\t\tif (a[i][j + 1] % 3 != 0)v2 = false;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif (v1){\n\t\t\t\t\tf(ii, x)ans = ans / 2;\n\t\t\t\t}\n\t\t\t\tif (v2){\n\t\t\t\t\tf(ii, x)ans = ans / 3;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\twhile (s.count((ans + 1)) == 1){\n\t\t\t\t\tif (x > 0)ans = ans / prim[x - 1];\n\t\t\t\t\tans = ans*prim[x];\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\ta[i][j] = ans + 1;\n\t\t\t\ts.insert((ans + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tf(i, n){\n\t\tf(j, n){\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < (n - 1))printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"complex\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\n\nlong long int N, M, K, H, W, L, R;\n\nlist<int> Prime(int num) {\n\tlist<int>P;\n\tfor (int i = 5; i <= num; i += 6) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t\tflag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i + 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((i + 2) % j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i + 2);\n\t}\n\tP.push_front(3);\n\tP.push_front(2);\n\treturn P;\n}\n\ninline long long int gcd(long long int a, long long int b) {\n\tif (a < b)a ^= b ^= a ^= b;\n\twhile (b) {\n\t\ta %= b;\n\t\ta ^= b ^= a ^= b;\n\t}\n\treturn a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tauto P = Prime(10000);\n\tlist<int>p;\n\tP.pop_front();\n\twhile (p.size() < N + 1) {\n\t\tp.push_back(P.front());\n\t\tP.pop_front();\n\t}\n\tvector<int>tate((N+1)/2);\n\tvector<int>yoko((N+1)/2);\n\tfor (int i = 0; i < (N + 1) / 2; i++) {\n\t\tif (i % 2) {\n\t\t\ttate[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\ttate[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tfor (int i = 0; i < N/2; i++) {\n\t\tif (i % 2) {\n\t\t\tyoko[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\tyoko[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tvector<vector<long long int>>v(N, vector<long long int>(N));\n\tmap<long long int, int>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i^j) & 1) {\n\t\t\t\tv[i][j] = tate[i / 2] * yoko[j / 2] * 2;\n\t\t\t\tif (m[v[i][j]])v[i][j] *= 2;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dir[] = { 0,1,0,-1,0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (!v[i][j]) {\n\t\t\t\tv[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = i + dir[k];\n\t\t\t\t\tint nx = j + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)continue;\n\t\t\t\t\tv[i][j] = v[i][j] / gcd(v[i][j], v[ny][nx])*v[ny][nx];\n\t\t\t\t}\n\t\t\t\tv[i][j]++;\n\t\t\t\tif (m[v[i][j]])v[i][j] = v[i][j] * 2 - 1;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int mx = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j)cout << \" \";\n\t\t\tcout << v[i][j];\n\t\t\tmx = max(mx, v[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n//\tcout << mx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint v_size = v.size();\n\t\t\tREP(i,v_size){\n\t\t\t\t*this>>v[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\nconst int M = 500;\n\nvector<int> pdiv, primes;\n\n//{{{ eratosthenes\nvoid sieve_of_eratosthenes(int n) {\n\tpdiv.assign(n,0);\n\tfor (int i = 2; i < n; ++i)\n\t\tpdiv[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (pdiv[i]==i)\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tpdiv[j] = i;\n\tfor(int p=2;p<n;p++)if(pdiv[p]==p)primes.push_back(p);\n}\n\nbool is_prime(int n){\n\treturn n!=1 and pdiv[n]==n;\n}\n//}}}\n\nInt N;\n\nvoid check(const vector<vector<Int> > &a){\n\tREP(i,N-1)REP(j,N-1){\n\t\t{\n\t\t\tint i2 = i+1, j2 = j;\n\t\t\tif(a[i][j]<a[i2][j2])assert(a[i2][j2]%a[i][j]==1);\n\t\t\telse assert(a[i][j]%a[i2][j2]==1);\n\t\t}\n\t\t{\n\t\t\tint i2 = i, j2 = j + 1;\n\t\t\tif(a[i][j]<a[i2][j2])assert(a[i2][j2]%a[i][j]==1);\n\t\t\telse assert(a[i][j]%a[i2][j2]==1);\n\t\t}\n\t}\n\tset<Int> v;\n\tREP(i,N)REP(j,N)v.insert(a[i][j]),assert(1<=a[i][j] and a[i][j]<=1000000000000000ll);\n\tassert(v.size()==N*N);\n}\n\n\nInt type0(int i,int j){\n\tassert((i+j)%2==0);\n\tint a = (i-j)/2;\n\ta = (a%M+M)%M;\n\treturn primes[a];\n}\n\nInt type1(int i,int j){\n\tassert((i+j)%2==0);\n\tint a = (i+j)/2;\n\ta = (a%M+M)%M;\n\treturn primes[a+M];\n}\n\nInt calc(int i,int j){\n\tif((i+j)%2==0){\n\t\treturn type0(i,j)*type1(i,j);\n\t}else{\n\t\treturn type0(i-1,j)*type0(i+1,j)*type1(i-1,j)*type1(i+1,j)+1;\n\t}\n}\n\nvoid solve(){\n\tsieve_of_eratosthenes(100000);\n\tvector<vector<Int> > a(N,vector<Int>(N));\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\ta[i][j] = calc(i,j);\n\t\t}\n\t}\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\tfout<<a[i][j]<<\" \";\n\t\t}\n\t\tfout<<endl;\n\t}\n\tcheck(a);\n\treturn;\n}\n\n//{{{ main function\nint main(){\t\n\n\tfin >> N;\n\tsolve();\n\treturn 0;\n}\n//}}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!i & 1)\n\t\t\tswap(pri[i], pri[n - i + 1]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = 1ll * pri[(i + j) / 2] * i;\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n\treturn y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n\tif( x == 0 ) return y;\n\telse if( y == 0 ) return x;\n\telse return x / GCD(x, y) * y;\n}\nvoid sieve() {\n\tfor(int i=2;i<=MAXM;i++) {\n\t\tif( !vis[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;i*prm[j]<=MAXM;j++) {\n\t\t\tvis[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n\tsieve(); int N;\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) == (j & 1) )\n\t\t\t\tMat[i][j] = prm[(i + j) / 2] * prm[(i+N+1-j)/2 + N];\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) != (j & 1) )\n\t\t\t\tMat[i][j] = LCM(Mat[i-1][j], LCM(Mat[i+1][j], LCM(Mat[i][j-1], Mat[i][j+1]))) + 1;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<N;j++)\n\t\t\tprintf(\"%lld \", Mat[i][j]);\n\t\tprintf(\"%lld\\n\", Mat[i][N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MAX=30000;\nvector<ll> prime;\nbool isprime[MAX];\nvoid sieve(){\n\tfor(ll i=3; i<MAX; i+=2){\n\t\tisprime[i]=1;\n\t}\n\tisprime[2]=1;\n\tprime.push_back(2);\n\tfor(ll i=3; i<MAX; i++){\n\t\tif(isprime[i]){\n\t\t\tprime.push_back(i);\n\t\t\tfor(ll j=2*i; j<MAX; j+=i){\n\t\t\t\tisprime[j]=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tsieve();\n\tll x[1010];\n\tfor(int i=0; i<n; i++){\n\t\tx[i]=prime[i+1];\n\t}\n\tll a[505][505];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif((i+j)%2==0){\n\t\t\t\tif(j<n/2) a[i][j]=x[(n-1+i-j)/2]*x[(i+j)/2];\n\t\t\t\telse a[i][j]=2*x[(n-1+i-j)/2]*x[(i+j)/2];\n\t\t\t}else{\n\t\t\t\tif(j<n/2) a[i][j]=2*x[(n-1+i-j-1)/2]*x[(n-1+i-j+1)/2]*x[(i+j-1)/2]*x[(i+j+1)/2];\n\t\t\t\telse a[i][j]=4*x[(n-1+i-j-1)/2]*x[(n-1+i-j+1)/2]*x[(i+j-1)/2]*x[(i+j+1)/2];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcout<<a[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nlong long gcd(long long a, long long b) {\n  return (b ? gcd(b, a % b) : a);\n}\n\nlong long lcm(long long a, long long b) {\n  return a / gcd(a, b) * b;\n}\n\nconst int maxn = 505;\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  return true;\n}\n\nconst long long maxx = (long long) 1e15 + 1;\nconst int gox[] = {1, 0, -1, 0};\nconst int goy[] = {0, 1, 0, -1};\nlong long a[maxn][maxn];\n\nvoid solve() {\n  vector<int> prs;\n  for (int x = 2; sz(prs) < 1500; x++) {\n    bool ok = true;\n    for (int d = 2; d * d <= x; d++) {\n      if (!(x % d)) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      prs.push_back(x);\n    }\n  }\n  set<long long> used;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (!((i + j) & 1)) {\n        long long x = (long long) prs[maxn / 2 + i / 2] * prs[1 + j / 2];\n        if (used.count(x)) {\n          x *= 2;\n        }\n        assert(x < maxx);\n        assert(!used.count(x));\n        a[i][j] = x;\n        used.insert(x);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (!((i + j) & 1)) {\n        continue;\n      }\n      long long x = 1;\n      for (int dir = 0; dir < 4; dir++) {\n        int ni = i + gox[dir], nj = j + goy[dir];\n        if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n          continue;\n        }\n        x = lcm(x, a[ni][nj]);\n      }\n      long long y = x;\n      while (used.count(x + 1)) {\n        x += y;\n      }\n      x++;\n      eprintf(\"%d %d\\n\", i, j);\n      assert(x < maxx);\n      a[i][j] = x;\n      used.insert(x);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%lld \", a[i][j]);\n    }\n    printf(\"\\n\");\n  } \n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=8000;\nint n,pri[1001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);cin>>n;\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+(abs(i-j)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++){\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tcout<<a[i][j]<<' ';\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint p[1010],b[10010],t,n;\nint main(){\n\tp[0]=1;p[t+1]=1;\n\tfor(int i=2;i<=7919;++i){\n\t\tif(!b[i])p[++t]=i;\n\t\tif(t==500)p[++t]=1;\n\t\tfor(int j=1;j<=t&&i*p[j]<=7919;++j)if(j^501){\n\t\t\tb[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i+j&1){\n\t\t\t\tprintf(\"%lld\",p[i+j>>1]*p[i+j+1>>1]*p[501+(n+2-j+i>>1)]*p[501+(n-j+i>>1)]+1);\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\",p[i+j>>1]*p[501+(n+1-j+i>>1)]);\n\t\t\t}\n\t\t\tputchar(' ');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#define maxn 510\n#define ll long long\n\nusing namespace std;\n\nint n;\nll a[maxn][maxn], primes[2020];\nbool st[1000010];\nint cnt;\n\nvoid getprimes()\n{\n\tfor (int i = 2; i <= 10000; i ++ )\n\t{\n\t\tif (!st[i]) primes[++cnt] = i;\n\t\tfor (int j = 1; primes[j] * i <= 10000; j ++ )\n\t\t{\n\t\t\tst[primes[j] * i] = 1;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n}\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\tif (!a || !b) return a + b;\n\treturn a / gcd(a, b) * b;\n}\n\nint main()\n{\n\tgetprimes();\n\tscanf(\"%d\", &n);\n\t\n\tif (n == 2)\n\t{\n\t\tputs(\"2 6\");\n\t\tputs(\"12 3\");\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = ((i + 1) & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = primes[(i + j) / 2] * primes[n + (i - j) / 2 + (n + 1) / 2];\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t\tfor (int j = ((i & 1) + 1); j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i][j - 1], a[i - 1][j]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\t\n\tfor (int i = 1; i <= n; i ++ )\n\t{\n\t\tfor (int j = 1; j <= n; j ++ ) cout << a[i][j] << ' ';\n\t\tputs(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/priority_queue.hpp>\n#define priority_queue __gnu_pbds::priority_queue\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int ui;\ntypedef unsigned long long ul;\n#define ri register int\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mid ((l + r) >> 1)\n#define ls (i << 1)\n#define rs (i << 1 | 1)\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, LL> pil;\ntypedef pair<LL, int> pli;\n#define adde(x, y) { e[++z].v = y; e[z].nxt = h[x]; h[x] = &e[z]; }\n#define addrev(u, v) { adde(u, v); adde(v, u); }\n#define ae(x) for(node *p = h[x]; p; p = p->nxt)\n#define FO(x) { freopen(\"#x.in\", \"r\", stdin); freopen(\"#x.out\", \"w\", stdout); }\ninline int read() // ret >= 0\n{\n\tint ret = 0; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\n\t\tch = getchar();\n\tdo {\n\t\tret = ret * 10 + ch - '0';\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9');\n\treturn ret;\n}\ninline void write(int x) // x >= 0\n{\n\tif(x < 10)\n\t{\n\t\tputchar(x + '0');\n\t\treturn ;\n\t}\n\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\n#define maxn 510\nint n;\nbool zhi(int x)\n{\n\tfor(int i = 2; i <= sqrt(x); i ++)\n\t\tif(x % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nint ss[2 * maxn], tot;\nLL a[maxn][maxn];\ninline LL gcd(LL x, LL y)\n{\n\treturn x == 0 ? y : gcd(y % x, x);\n}\ninline LL lcm(LL x[])\n{\n\tLL ret = 0;\n\tfor(int i = 0; i < 4; i ++)\n\t\tif(x[i])\n\t\t\tret = ret == 0 ? x[i] : ret / gcd(ret, x[i]) * x[i];\n\treturn ret;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tif(n == 2)\n\t\treturn cout << \"4 7\\n23 10\" << endl, 0;\n\tfor(int i = 2; tot <= 2 * n + 10; i ++)\n\t\tif(zhi(i))\n\t\t\tss[++tot] = i;\n\tfor(int k = 2; k <= 2 * n; k += 2)\n\t\tfor(int i = max(1, k - n); i <= min(n, k - 1); i ++)\n\t\t\ta[i][k - i] = ss[k / 2];\n\tint u = n & 1 ? n - 1 : n - 2;\n\tint cur = n + 1;\n\tfor(int k = u; k >= -u; k -= 2, cur ++)\n\t\tfor(int i = max(1, 1 - k); i <= min(n, n - k); i ++)\n\t\t\ta[i][i + k] *= ss[cur];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(i + j & 1)\n\t\t\t{\n\t\t\t\tLL tmp[4] = {a[i - 1][j], a[i][j - 1], a[i + 1][j], a[i][j + 1]};\n\t\t\t\ta[i][j] = lcm(tmp) + 1;\n\t\t\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tcout << a[i][j] << ' ';\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst long long BOUND = 31622776LL;\n\nlong long val[500][500];\nconst long long prime[] = {7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71};\n\nint main () {\n  val[0][0] = 1; long long cur1 = 1, cur2 = 1;\n  for (int i = 1; i < 500; ++i) {\n    if (val[0][i - 1] * 2 * 5 <= BOUND)\n      val[0][i] = val[0][i - 1] * 2;\n    else {\n      if (cur1 * cur2 * 3 * 5 <= BOUND)\n        val[0][i] = val[0][i - 1] * 5, ++i, val[0][i] = cur1 * (cur2 *= 5);\n      else\n        val[0][i] = val[0][i - 1] * 3, ++i, cur2 = 1, val[0][i] = (cur1 *= 3);\n    }\n  }\n  long long cur[20]; std::fill (cur, cur + 20, 1);\n  const long long size = 10;\n  for (int i = 1; i < 500; ++i) {\n    if (val[i - 1][0] * 7 * prime[size - 1] <= BOUND)\n      val[i][0] = val[i - 1][0] * 7;\n    else {\n      long long mul = 1;\n      for (int j = 0; j < size; ++j) mul *= cur[j];\n      for (int j = size - 1; j >= 1; --j) if (mul * 7 * prime[j] <= BOUND) {\n        val[i][0] = val[i - 1][0] * prime[j];\n        ++i; cur[j] *= prime[j]; val[i][0] = mul * prime[j]; break;\n      } else mul /= cur[j], cur[j] = 1;\n    }\n  }\n  for (int i = 1; i < 500; ++i) for (int j = 1; j < 500; ++j) val[i][j] = val[i][0] * val[0][j];\n  for (int i = 0; i + 1 < 500; ++i) for (int j = 0; j < 500; ++j) while (std::max (val[i][j], val[i + 1][j]) % std::min (val[i][j], val[i + 1][j]) != 0);\n  for (int i = 0; i < 500; ++i) for (int j = 0; j + 1 < 500; ++j) while (std::max (val[i][j], val[i][j + 1]) % std::min (val[i][j], val[i][j + 1]) != 0);\n  std::ios::sync_with_stdio (0);\n  int N; std::cin >> N;\n  for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) std::cout << val[i][j] << \" \\n\"[j + 1 == N];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll __int128\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=500+10,MAXM=1000000+10;\nint n,vis[MAXM],prime[MAXM],cnt,p;\nll G[MAXN][MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void init()\n{\n\tmemset(vis,1,sizeof(vis));\n\tvis[0]=vis[1]=0;\n\tREP(i,2,MAXM-1)\n\t{\n\t\tif(vis[i])prime[++cnt]=i;\n\t\tfor(register int j=1;j<=cnt&&i*prime[j]<MAXM;++j)\n\t\t{\n\t\t\tvis[i*prime[j]]=0;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n}\nint main()\n{\n\tread(n);init();int x,y;\n\tREP(i,0,n+1)REP(j,0,n+1)G[i][j]=1;\n\tREP(i,0,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y>=0)G[x][y]*=prime[p],x++,y--;\n\t}\n\tREP(i,1,n+1)if(i%2==n%2)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y<=n+1)G[x][y]*=prime[p],x--,y++;\n\t}\n\tREP(i,0,n+1)if(i%2==n%2)\n\t{\n\t\tx=n+1,y=i,++p;\n\t\twhile(x>=0&&y>=0)G[x][y]*=prime[p],x--,y--;\n\t}\n\tREP(i,1,n+1)if(i&1)\n\t{\n\t\tx=0,y=i,++p;\n\t\twhile(x<=n+1&&y<=n+1)G[x][y]*=prime[p],x++,y++;\n\t}\n\tREP(i,1,n)REP(j,1,n)if((i+j)%2==0)\n\t\tG[i][j]=G[i-1][j]*G[i+1][j]+1;\n\tREP(i,1,n)\n\t{\n\t\tREP(j,1,n)write(G[i][j],' ');puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 502\nvector<long long>p;\nbool pri[200000];\n\nvoid p_m(void) {\n\tlong long x;\n\tf(i, 200000)pri[i] = true;\n\tfor (long long i = 2; i < 200000; i++) {\n\t\tif (pri[i]) {\n\t\t\tp.push_back(i);\n\t\t\tx = i;\n\t\t\twhile (x < 200000) {\n\t\t\t\tpri[x] = false;\n\t\t\t\tx += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n\n\nint main() {\n\tint n;\n\tint x, y, k;\n\tlong long a[N][N];\n\tscanf(\"%d\", &n);\n\tp_m();\n\tf(i, n) {\n\t\tf(j, n)a[i][j] = 1;\n\t}\n\tx = 0;\n\tk = 0;\n\twhile (x < (2 * n)) {\n\t\tf(i, n) {\n\t\t\ty = x - i - 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x - i;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x - i + 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t}\n\t\tx += 2;\n\t\tk++;\n\t}\n\tif (n % 2 == 0)x = 2 - n;\n\telse x = 1 - n;\n\twhile (x < n) {\n\t\tf(i, n) {\n\t\t\ty = x + i - 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x + i;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t\ty = x + i + 1;\n\t\t\tif (y >= 0 && y < n)a[i][y] *= p[k];\n\t\t}\n\t\tx += 2;\n\t\tk++;\n\t}\n\tf(i, n){\n\t\tf(j,n) {\n\t\t\tif ((i + j) % 2 == 1)a[i][j]++;\n}\n\t\t}\n\tf(i, n) {\n\t\tf(j, n) {\n\t\t\tprintf(\"%lld\", a[i][j]);\n\t\t\tif (j < n - 1)printf(\" \");\n\t\t\telse printf(\"\\n\");\n\t\t}\n\t}\n\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=10005;\nconst int MAXM=505;\nint pr[MAXN],is[MAXN],plen;\nvoid getpr()\n{\n\tfor(int i=2;i<MAXN;i++)\n\t{\n\t\tif(!is[i])pr[++plen]=i;\n\t\tfor(int j=1;j<=plen&&i*pr[j]<MAXN;j++)\n\t\t{\n\t\t\tis[i*pr[j]]=1;\n\t\t\tif(!(i%pr[j]))break;\n\t\t}\n\t}\n}\nint n,vis[MAXM][MAXM],now;LL a[MAXM][MAXM],b[MAXM][MAXM];\nLL gcd(LL a,LL b){return a==0?b:gcd(b%a,a);}\nvoid get1(int x,int y)\n{\n\tif(x>n||y>n)return ;\n\tvis[x][y]=1;a[x][y]*=pr[now];\n\tget1(x+1,y+1);\n}\nvoid get2(int x,int y)\n{\n\tif(x<1||x>n||y<1||y>n)return ;\n\tvis[x][y]=1;a[x][y]*=pr[now];\n\tget2(x+1,y-1);\n}\nbool in(int x,int y){return x>=1&&x<=n&&y>=1&&y<=n;}\nLL lcm(LL a,LL b){return a/gcd(a,b)*b;}\nint main()\n{\n\tgetpr();\t\n\tn=read();now=0;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)a[i][j]=1;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(((i+j-1)&1)&&!vis[i][j])\n\t\t++now,get1(i,j);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(((i+j-1)&1)&&!vis[i][j])\n\t\t++now,get2(i,j);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(!((i+j-1)&1))\n\t{\n\t\tif(in(i-1,j))a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\tif(in(i+1,j))a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\tif(in(i,j-1))a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\tif(in(i,j+1))a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t++a[i][j];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)pr1(a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1005,lim=N*10;\nint flag[lim],p[N],n,cnt;\n\nint main(){\n\tread(n),p[++cnt]=1;\n\tfor(int i=2;cnt<=n*2;i++)\n\t\tif(!flag[i]){\n\t\t\tp[++cnt]=i;\n\t\t\tfor(int j=i*i;j<lim;j+=i)\n\t\t\t\tflag[i]=1;\n\t\t}\n\trep(i,1,n){\n\t\trep(j,1,n)\n\t\t\tif((i+j)&1){\n\t\t\t\tll res=(ll)p[(i+j-1)/2]*p[(i+j+1)/2];\n\t\t\t\tres*=(ll)p[(i+3*n-j-1)/2]*p[(i+3*n-j+1)/2];\n\t\t\t\tprintf(\"%lld \",res+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll res=(ll)p[(i+j)/2]*p[(i-j+3*n)/2];\n\t\t\t\tprintf(\"%lld \",res);\n\t\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define REP(i, n) for (ll i = 0; i < (n); ++i)\n#define REPR(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define FOR(i, n, m) for (ll i = (n); i < (m); ++i)\n#define FORR(i, n, m) for (ll i = (m) - 1; i >= (n); --i) \n#define FORE(x, xs) for (auto &x: (xs))\n#define ALL(v) v.begin(), v.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n\nconst int INF = 1000000009;\nconst int MOD = 1000000007;\nconst double EPS = 1e-14;\nconst double PI = acos(-1);\n\nconst int MAX = 500;\n\nll A[MAX][MAX];\nint N;\n\nint main() {\n\n  cin >> N;\n  ll p = 99991;\n\n  REP (j, N) {\n    REP (i, N-1) {\n      cout << ((i+j)%N+1)*p+1 << \" \";\n    }\n    int i = N-1;\n    cout << ((i+j)%N+1)*p+1 << endl;\n  }\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[376+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X((i+j)/2)*Y((i-j)/2);\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2)+1;\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001], prm[2003];\nint vis[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\n#define ll long long\n//#define file\nusing namespace std;\n\nint d[250001],n,i,j,k,l,l1,l2,x,y,t;\nll a[501][501],mx,s;\nmap<ll,bool> mp;\nbool bz[1000001];\n\nll gcd(ll x,ll y) {ll r=x%y; while (r) x=y,y=r,r=x%y; return y;}\nll lcm(ll x,ll y) {ll s=gcd(x,y);return (x/s)*(y/s)*s;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc027d.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d\",&n),s=((n+1)/2)*((n+1)/2);\n\ti=2;\n\twhile (t<s)\n\t{\n\t\tif (!bz[i] && !bz[i*2]) d[++t]=i,bz[i]=bz[i*2]=1;\n\t\t++i;\n\t}\n\tl1=0,l2=t+1;\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tif ((i&1) && (j&1))\n\t\t{\n\t\t\tif (((i+j)/2)&1)\n\t\t\t{\n\t\t\t\t++l1;\n\t\t\t\ta[i][j]=d[l1];\n\t\t\t\tif (i<n && j<n)\n\t\t\t\ta[i+1][j+1]=d[l1]*2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--l2;\n\t\t\t\ta[i][j]=d[l2];\n\t\t\t\tif (i<n && j<n)\n\t\t\t\ta[i+1][j+1]=d[l2]*2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmx=0;\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tif (!a[i][j])\n\t\t{\n\t\t\ta[i][j]=1;\n\t\t\tif (i>1) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\tif (i<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\tif (j>1) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\tif (j<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\t\n\t\t\ts=a[i][j],++a[i][j];\n\t\t\twhile (mp[a[i][j]]) a[i][j]+=s;\n\t\t\tmp[a[i][j]]=1;\n\t\t\tmx=max(mx,a[i][j]);\n\t\t}\n\t}\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tprintf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 2000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint pri[N],p[N],tot;\ninline void sieve(int n)\n{\tfor(rint i=2;i<=n;i++)\n\t{\tif(!pri[i]) p[++tot]=i;\n\t\tfor(rint j=1;j<=tot&&i*p[j]<=n;j++)\n\t\t{\tpri[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\nll a[666][666]; int mov[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\ninline ll lcm(ll x,ll y){return x*y/__gcd(x,y);}\nint main()\n{\tint n,cur=1; cin>>n; sieve(1e6);\n\tfor(rint i=0;i<=n+1;i++)\n\tfor(rint j=0;j<=n+1;j++) a[i][j]=1;\n\tfor(rint i=3;i<=n+n;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i-j&&i-j<=n) a[j][i-j]*=p[cur];\n\tfor(rint i=1;i<=n-1;i+=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=-1;i>=1-n;i-=2,cur++)\n\tfor(rint j=1;j<=n;j++) if(1<=i+j&&i+j<=n) a[j][i+j]*=p[cur];\n\tfor(rint i=1;i<=n;i++)\n\tfor(rint j=1;j<=n;j++)\n\tif((i+j)%2==0)\n\t{\tfor(rint k=0;k<4;k++) a[i][j]=lcm(a[i][j],a[i+mov[k][0]][j+mov[k][1]]);\n\t\ta[i][j]--;\n\t}\n\tfor(rint i=1;i<=n;i++,cout<<\"\\n\")\n\tfor(rint j=1;j<=n;j++) cout<<a[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <climits>\n#include <algorithm>\n#include <random>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <bitset> \n#include <queue>\n#define inf 0x3f3f3f3f\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0);\n#define rep(i, a, n) for(register int i = a; i <= n; ++ i)\n#define per(i, a, n) for(register int i = n; i >= a; -- i)\n//#define ONLINE_JUDGE\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\ntemplate<typename T>void write(T x)\n{\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    if(x>9)\n    {\n        write(x/10);\n    }\n    putchar(x%10+'0');\n}\n \ntemplate<typename T> void read(T &x)\n{\n    x = 0;char ch = getchar();ll f = 1;\n    while(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n    while(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nll ksm(ll a,ll n){//看是否要mod \n\tll ans=1;\n\twhile(n){\n\t\tif(n&1) ans=(ans*a)%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn ans%mod;\n}\n//==============================================================\nconst int maxn=5e2+10;\nint mat[maxn][maxn];\nint n;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\t//===========================================================\n    read(n);\n\tmat[1][1]=2;\n    int x=1,y=2;\n    rep(i,2,n) mat[1][i]=mat[1][i-1]+1;\n    mat[2][n]=mat[1][n]+1;\n    x=2,y=n-1;\n    int dir=1;\n    while(true){\n        if(mat[x-1][y]!=0&&mat[x][y+dir]!=0)mat[x][y]=lcm(mat[x-1][y],mat[x][y+dir])+1;\n        else{\n            mat[x][y]=mat[x][y+dir]+mat[x-1][y]+1;\n        }\n        y-=dir;\n        if(y==0) dir=-1,x++,y=1;\n        if(y==n+1) dir=1,x++,y=n;\n        if(x>n) break;\n    }\n    rep(i,1,n){\n        rep(j,1,n){\n            if(j-1) putchar(' ');\n            write(mat[i][j]);\n        }\n        \n        putchar('\\n');\n    }\n\t//===========================================================\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nvoid solve() {\n    int N;\n    cin >> N;\n\n    vector<int> isprime(10001, 1);\n    isprime[0] = isprime[1] = 0;\n    for(int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            for(int j = i + i; j < 10001; j += i) {\n                isprime[j] = 0;\n            }\n        }\n    }\n    vector<ll> primes;\n    for (int i = 0; i < 10001; i++) {\n        if (isprime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    vector<vector<ll>> P1(N, vector<ll>(N)), P2(N, vector<ll>(N));\n    vector<vector<ll>> ans(N, vector<ll>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                ll p1 = primes[(i + j) / 2];\n                ll p2 = primes[primes.size() - 1 - (i - j + N) / 2];\n                ans[i][j] = p1 * p2;\n            }\n        }\n    }\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, -1, 0, 1};\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 1) {\n                ll l = 1;\n                for(int k = 0; k < 4; k++) {\n                    int di = i + dy[k];\n                    int dj = j + dx[k];\n                    if (di < 0 || di >= N || dj < 0 || dj >= N) continue;\n                    l = lcm(l, ans[di][dj]);\n                }\n                ans[i][j] = l + 1;\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 507\n#define MAX_M 1000007\n\nint pri[MAX_M], tot;\nbool check[MAX_M];\n\nvoid sieve() {\n    int MX = 1000000;\n    rep(i, 2, MX) {\n        if (!check[i]) pri[++tot] = i;\n        if (tot > 1000) break;\n        rep(j, 1, tot) {\n            if (i * pri[j] > MX) break;\n            check[i * pri[j]] = true;\n            if (i % pri[j] == 0) break;\n        }\n    }\n}\n\nint N;\nll ans[MAX_N * 2][MAX_N * 2], num1[MAX_N * 2], num2[MAX_N * 2];\nvoid solve() {\n    if (N == 2) {\n        puts(\"4 7\");\n        puts(\"23 10\");\n        return;\n    }\n    int cur = 0;\n    Rep(i, N) if (i + 1 & 1) num1[1 - i + N] = pri[++cur];\n    rep(i, 2, N) if (i + 1 & 1) num1[i - 1 + N] = pri[++cur];\n    rep(i, 2, N + N) if (i & 1) num2[i] = pri[++cur];\n    // rep(i, 1, N * 2 - 1) printf(\"%d \", num1[i]);\n    // puts(\"\");\n    rep(i, 0, N + 1) {\n        rep(j, 0, N + 1) if (i + j & 1) {\n            ans[i][j] =\n                std::max(1LL, num1[i - j + N]) * std::max(1LL, num2[i + j]);\n        }\n    }\n    Rep(i, N) {\n        Rep(j, N) if (!(i + j & 1)) {\n            ans[i][j] = ans[i - 1][j] * ans[i + 1][j] + 1;\n        }\n    }\n    Rep(i, N) {\n        Rep(j, N) {\n            if (ans[i][j] > 1e15) exit(1);\n            printf(\"%lld \", ans[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nint main() {\n    sieve();\n    read(N);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nlong long pow(long long x,long long k){\n\tif(k == 0)return 1;\n\treturn pow(x,k-1)*x;\n}\n\nlong long gcd(long long x,long long y){\n\tif(y == 0)return x;\n\treturn gcd(y,x%y);\n}\n\nlong long lcm(long long x,long long y){\n\tx /= gcd(x,y);\n\tx *= y;\n\treturn x;\n}\n\nvoid f(long long x, long long y){\n\tif(max(x,y)%min(x,y) != 1){\n\t\tputs(\"No\");\n\t\texit(1);\n\t}\n}\n\nint main(){\n\tvector<long long> p;\n\tint t = 5;\n\twhile(p.size() < 100){\n\t\tbool b = true;\n\t\tfor(int i = 2 ; i*i <= t ; i ++){\n\t\t\tif(t%i == 0){\n\t\t\t\tb = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(b)p.push_back(t);\n\t\tt ++;\n\t}\n\tlong long k[10] = {1,2,5,6,7,8,9,10,3,4};\n\t\n\tlong long x[502],y[502];\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tx[i] = p[i/10]*pow(2,k[i%10]);\n\t\ty[i] = p[i/10+50]*pow(3,k[i%10]);\n\t}\n\t\n\tset<long long> S;\n\tlong long m = 0;\n\tlong long a[502][502] = {};\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tfor(int j = 0 ; j < 500 ; j ++){\n\t\t\tif((i+j)&1){\n\t\t\t\ta[i][j] = x[i]*y[j];\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t\tm = max( m , a[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\t//cout << S.size() << endl;\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tfor(int j = 0 ; j < 500 ; j ++){\n\t\t\tif((i+j)&1){}\n\t\t\telse {\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tif(i > 0)a[i][j] = lcm(a[i][j],a[i-1][j]);\n\t\t\t\tif(i+1 < 500)a[i][j] = lcm(a[i][j],a[i+1][j]);\n\t\t\t\tif(j > 0)a[i][j] = lcm(a[i][j],a[i][j-1]);\n\t\t\t\tif(j+1 < 500)a[i][j] = lcm(a[i][j],a[i][j+1]);\n\t\t\t\tlong long d = a[i][j];\n\t\t\t\ta[i][j] += 1;\n\t\t\t\twhile(S.find(a[i][j]) != S.end())a[i][j] += d;\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long M;\n\tfor(int i = 0 ; i < 500 ; i ++){\n\t\tfor(int j = 0 ; j < 500 ; j ++){\n\t\t\tS.insert(a[i][j]);\n\t\t\tif(a[i][j] <= 0 || a[i][j] > 1000000000000000)puts(\"No\");\n\t\t\tif(j+1 < 500)f(a[i][j],a[i][j+1]);\n\t\t\tif(i+1 < 500)f(a[i][j],a[i+1][j]);\n\t\t\tM = max(M,a[i][j]);\n\t\t}\n\t}\n\t//cout << S.size() << endl;\n\t//cout << m << \" \" << M << endl;\n\t//puts(\"Yes\");\n\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tfor(int j = 0 ; j < n ; j ++){\n\t\t\tprintf(\"%d%c\",a[i][j],(j==n-1)?'\\n':' ');\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nlong long ans[503][503];\nint n,x;\nbool bo;\n\nbool check(int x)\n{\n\tfor (int i=2; i<x; i++)\n\t\tif (x%i==0) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tbo=0; scanf(\"%d\",&n); if (!(n&1)) n++,bo=1; int la=2;\n\tfor (int i=1; i<=n; i+=2)\n\t\tfor (int j=la; ; j++) \n\t\t\tif (check(j)) {ans[1][i]=j,la=j+1; break;}\n\tfor (int i=3; i<=n; i+=2)\n\t\tfor (int j=la; ; j++)\n\t\t\tif (check(j)) {ans[i][1]=j,la=j+1; break;}\n\tfor (int i=2; i<=n; i+=2) ans[1][i]=ans[1][i-1]*ans[1][i+1],ans[i][1]=ans[i-1][1]*ans[i+1][1];\n\tfor (int i=2; i<=n; i++)\n\t\tfor (int j=2; j<=n; j++) ans[i][j]=ans[1][j]*ans[i][1];\n\tfor (int i=1; i<=n; i++) ans[2][i]*=2ll;\n\tif (bo) n--;\n\tfor (int i=1; i<=n; i++,printf(\"\\n\"))\n\t\tfor (int j=1; j<=n; j++) printf(\"%lld \",ans[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=505;\nconst int M=4*N;\nconst int S=10000;\nint pr[M],psz;\nbool sieve[S];\nll val[N][N];\nvector<pair<int,int> > id;\nint Find(pair<int,int> x){ return lower_bound(id.begin(),id.end(),x)-id.begin()+1;}\nint main()\n{\n\tint i,j;\n\tfor(i=2;i<S;i++) if(!sieve[i]){ pr[++psz]=i;for(j=i;j<S;j+=i) sieve[j]=1;}\n\tint n;\n\tscanf(\"%i\",&n);\n\tif(n==2) return 0*printf(\"4 7\\n23 10\\n\");\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n\t\tint a=i+j,b=i-j;\n\t\tid.pb(mp(1,a));\n\t\tid.pb(mp(2,b));\n\t}\n\tsort(id.begin(),id.end());\n\tid.erase(unique(id.begin(),id.end()),id.end());\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if((i+j)&1)\n\t{\n        int a=Find(mp(1,i+j));\n        int b=Find(mp(2,i-j));\n        val[i][j]=(ll)pr[a]*pr[b];\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) if(!((i+j)&1))\n\t{\n\t\tval[i][j]=1;\n\t\tif(i-1>0 || j+1<=n) val[i][j]*=pr[Find(mp(2,i-j-1))];\n\t\tif(i+1<=n || j-1>0) val[i][j]*=pr[Find(mp(2,i-j+1))];\n\t\tif(i-1>0 || j-1>0) val[i][j]*=pr[Find(mp(1,i+j-1))];\n\t\tif(i+1<=n && j+1<=n) val[i][j]*=pr[Find(mp(1,i+j+1))];\n\t\tval[i][j]++;\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) printf(\"%lld%c\",val[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[510][510],c[510][501],ans[510][510],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tint op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<ll>> a(N, vector<ll>(N));\n\tint tmp = 2;\n\tunordered_set<ll> st;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 0) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\ta[i][j] = tmp++;\n\t\t\t\tst.insert(a[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[i][j] = a[i - 1][j - 1] * 2;\n\t\t\t}\n\t\t\tst.insert(a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) if ((i + j) % 2 == 1) {\n\t\t\tll g = 0;\n\t\t\tfor (int d = 0; d < 4; d++) {\n\t\t\t\tint ti = i + dx[d], tj = j + dy[d];\n\t\t\t\tif (0 <= ti && ti < N && 0 <= tj && tj < N) {\n\t\t\t\t\tll aa = g == 0 ? a[ti][tj] : a[ti][tj] / __gcd(a[ti][tj], g) * g;\n\t\t\t\t\tg = aa;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll t = g + 1;\n\t\t\twhile (st.count(t)) {\n\t\t\t\tt += g;\n\t\t\t}\n\t\t\ta[i][j] = t;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j + 1 == N];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <numeric>\nusing namespace std;\n#define lint long long\n#define ll long long\n#define pq priority_queue\nlong long INF = 1e10;\n#define pii pair<long long,long long>\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n\nll G[510][510];\n/*************** main ***************/\nint main(void) {\n\n\tint N; cin >> N;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tG[0][i] = 2 + i;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tG[i][N - 1] = N + 1 + i;\n\t}\n\t\n\tfor (int i = 1; i < N;i++) {\n\t\tfor (int j = N - 2; j >= 0;j--) {\n\t\t\tG[i][j] = max(G[i-1][j], G[i][j+1]) + 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << G[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i,begin,end) for(int i=(begin);i<(end);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint N, u, v;\n\nint main()\n{\n    constexpr array<lint, 502> p{7937,7907,7877,7841,7793,7753,7717,7687,7649,7607,7583,7559,7537,7507,7481,7451,7393,7333,7307,7247,7219,7193,7151,7109,7057,7019,6991,6967,6947,6899,6863,6829,6793,6763,6719,6691,6661,6619,6577,6553,6521,6469,6421,6373,6353,6323,6299,6269,6229,6203,6163,6131,6091,6067,6037,5987,5927,5881,5861,5843,5813,5783,5741,5701,5669,5651,5623,5569,5527,5503,5477,5441,5417,5393,5347,5303,5273,5231,5189,5153,5107,5081,5039,5009,4987,4957,4933,4903,4861,4801,4787,4733,4703,4663,4643,4603,4567,4523,4507,4463,4441,4397,4357,4327,4273,4253,4229,4201,4153,4127,4091,4051,4019,4001,3943,3919,3889,3853,3823,3793,3761,3719,3691,3659,3623,3593,3559,3539,3517,3469,3457,3407,3371,3343,3319,3299,3253,3217,3187,3163,3109,3067,3037,3001,2963,2927,2897,2857,2833,2797,2767,2731,2711,2689,2671,2647,2609,2557,2539,2477,2447,2417,2389,2371,2341,2309,2281,2251,2221,2179,2141,2113,2087,2063,2027,1999,1979,1933,1901,1873,1847,1801,1777,1741,1709,1669,1637,1613,1597,1567,1543,1499,1483,1453,1433,1409,1367,1319,1297,1279,1237,1217,1187,1153,1117,1093,1063,1039,1019,991,967,937,907,877,853,823,797,761,739,709,677,653,631,607,587,563,523,499,467,449,431,401,379,353,331,307,277,257,233,211,191,167,149,127,103,83,67,47,31,17,5,11,23,41,59,73,97,109,137,157,179,197,227,241,269,283,313,347,367,389,419,439,461,487,509,547,571,599,617,643,661,691,727,751,773,811,829,859,883,919,947,977,1009,1031,1051,1087,1103,1129,1171,1201,1229,1259,1289,1303,1327,1381,1427,1447,1471,1489,1523,1553,1579,1607,1621,1663,1697,1723,1753,1787,1823,1867,1879,1913,1951,1993,2011,2039,2081,2099,2131,2153,2207,2239,2269,2293,2333,2351,2381,2399,2437,2467,2521,2549,2591,2621,2659,2683,2699,2719,2749,2789,2803,2843,2879,2909,2953,2971,3019,3049,3083,3121,3169,3203,3229,3259,3307,3329,3359,3389,3433,3463,3499,3529,3547,3581,3613,3637,3673,3701,3733,3769,3803,3847,3877,3911,3929,3967,4007,4027,4073,4099,4133,4159,4217,4241,4261,4289,4339,4373,4421,4451,4483,4517,4549,4591,4637,4651,4679,4723,4759,4793,4817,4877,4919,4943,4969,4999,5021,5059,5099,5119,5171,5209,5237,5281,5323,5381,5407,5431,5449,5483,5519,5557,5581,5641,5657,5689,5717,5749,5801,5827,5851,5869,5903,5953,6011,6047,6079,6113,6143,6197,6217,6257,6277,6311,6337,6361,6389,6449,6481,6547,6569,6599,6653,6679,6703,6737,6781,6823,6841,6871,6911,6959,6977,7001,7039,7079,7127,7177,7211,7237,7283,7321,7351,7417,7459,7489,7523,7547,7573,7591,7639,7673,7699,7727,7759,7823,7867,7883,7927,7951};\n    constexpr array<lint, 502> q{7949,7919,7879,7853,7817,7757,7723,7691,7669,7621,7589,7561,7541,7517,7487,7457,7411,7349,7309,7253,7229,7207,7159,7121,7069,7027,6997,6971,6949,6907,6869,6833,6803,6779,6733,6701,6673,6637,6581,6563,6529,6473,6427,6379,6359,6329,6301,6271,6247,6211,6173,6133,6101,6073,6043,6007,5939,5897,5867,5849,5821,5791,5743,5711,5683,5653,5639,5573,5531,5507,5479,5443,5419,5399,5351,5309,5279,5233,5197,5167,5113,5087,5051,5011,4993,4967,4937,4909,4871,4813,4789,4751,4721,4673,4649,4621,4583,4547,4513,4481,4447,4409,4363,4337,4283,4259,4231,4211,4157,4129,4093,4057,4021,4003,3947,3923,3907,3863,3833,3797,3767,3727,3697,3671,3631,3607,3571,3541,3527,3491,3461,3413,3373,3347,3323,3301,3257,3221,3191,3167,3119,3079,3041,3011,2969,2939,2903,2861,2837,2801,2777,2741,2713,2693,2677,2657,2617,2579,2543,2503,2459,2423,2393,2377,2347,2311,2287,2267,2237,2203,2143,2129,2089,2069,2029,2003,1987,1949,1907,1877,1861,1811,1783,1747,1721,1693,1657,1619,1601,1571,1549,1511,1487,1459,1439,1423,1373,1321,1301,1283,1249,1223,1193,1163,1123,1097,1069,1049,1021,997,971,941,911,881,857,827,809,769,743,719,683,659,641,613,593,569,541,503,479,457,433,409,383,359,337,311,281,263,239,223,193,173,151,131,107,89,71,53,37,19,7,13,29,43,61,79,101,113,139,163,181,199,229,251,271,293,317,349,373,397,421,443,463,491,521,557,577,601,619,647,673,701,733,757,787,821,839,863,887,929,953,983,1013,1033,1061,1091,1109,1151,1181,1213,1231,1277,1291,1307,1361,1399,1429,1451,1481,1493,1531,1559,1583,1609,1627,1667,1699,1733,1759,1789,1831,1871,1889,1931,1973,1997,2017,2053,2083,2111,2137,2161,2213,2243,2273,2297,2339,2357,2383,2411,2441,2473,2531,2551,2593,2633,2663,2687,2707,2729,2753,2791,2819,2851,2887,2917,2957,2999,3023,3061,3089,3137,3181,3209,3251,3271,3313,3331,3361,3391,3449,3467,3511,3533,3557,3583,3617,3643,3677,3709,3739,3779,3821,3851,3881,3917,3931,3989,4013,4049,4079,4111,4139,4177,4219,4243,4271,4297,4349,4391,4423,4457,4493,4519,4561,4597,4639,4657,4691,4729,4783,4799,4831,4889,4931,4951,4973,5003,5023,5077,5101,5147,5179,5227,5261,5297,5333,5387,5413,5437,5471,5501,5521,5563,5591,5647,5659,5693,5737,5779,5807,5839,5857,5879,5923,5981,6029,6053,6089,6121,6151,6199,6221,6263,6287,6317,6343,6367,6397,6451,6491,6551,6571,6607,6659,6689,6709,6761,6791,6827,6857,6883,6917,6961,6983,7013,7043,7103,7129,7187,7213,7243,7297,7331,7369,7433,7477,7499,7529,7549,7577,7603,7643,7681,7703,7741,7789,7829,7873,7901,7933,7963};\n\n    cin >> N;\n    REP(i,N) REP(j,N)\n    {\n        u = (i + j) / 2, v = (i + (500 - j)) / 2;\n        cout << (((i + j) & 1) ? p[u + 1] * q[v + 1] : p[u] * p[u + 1] * q[v] * q[v + 1] + 3) << (j == N - 1 ? \"\\n\" : \" \");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=1e5+5;\nint p[N],vis[M];ll a[N][N];\nint n,m;\nvoid init(int n=1e5){\n\tfor(R int i=2;i<=n;++i){\n\t\tif(!vis[i])p[++m]=i;\n\t\tif(m==1000)return;\n\t\tfor(R int j=1;j<=m&&i*p[j]<=n;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\ninline ll lcm(R ll x,R ll y){return x||y?x/__gcd(x,y)*y:x+y;}\ninline ll calc(R int i,R int j){\n\treturn lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tinit();\n\tscanf(\"%d\",&n);\n\tif(n==2)return puts(\"4 7\\n23 10\\n\"),0;\n\tfp(i,1,n)fp(j,1,n)if((i+j)&1^1)a[i][j]=1ll*p[(i+j)>>1]*p[n-((i-j)>>1)+((n+1)>>1)];\n\tfp(i,1,n)fp(j,1,n)if(!a[i][j])a[i][j]=calc(i,j);\n\tfp(i,1,n)fp(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e4+10;\nint p[N],lim=10000,p1;\nint flag[N];\nint q[N],q1;\nll a[505][505];\nmap<int,int> px,py;\nint n;\nvoid prep(int n){\n\tfor (int i=2;i<=n;i++){\n\t\tif (!flag[i])p[++p1]=i;\n\t\tfor (int j=1;j<=p1;j++){\n\t\t\tint x=i*p[j];\n\t\t\tif (x>n)break;\n\t\t\tflag[x]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\nll lcm(ll a,ll b){\n\tif (!a||!b)return a+b;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tcin>>n;\n\tprep(lim);\n\tp1=0;p[0]=1;\n\tfor (int i=0,j=998;i<j;i++,j--)\n\t\tq[++q1]=p[i],q[++q1]=p[j];\n\tp1=1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1)continue;\n\t\t\tif (!px[i+j])px[i+j]=q[++p1];\n\t\t\tif (!py[i-j])py[i-j]=q[++p1];\n\t\t\ta[i][j]=px[i+j]*py[i-j];\n\t\t}\n\t}\n\tll mx=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif ((i+j)&1);else continue;\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t\t\tmx=max(mx,a[i][j]);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//\tcout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <list>\nusing namespace std;\n\nvector <int> construct(int x) {\n\tif (x == 0) {\n\t\tvector <int> X;\n\t\tX.push_back(x);\n\t\treturn X;\n\t}else {\n\t\tvector <int> vv = construct(x - 1);\n\t\tvector <int> X;\n\t\tfor (int i = 0; i < (int) vv.size(); i++)\n\t\t\tX.push_back(vv[i]);\n\t\tfor (int i = 0; i < (int) vv.size() - 1; i++)\n\t\t\tX.push_back(vv[vv.size() - 1 - i] + (1 << (x - 1)));\n\t\treturn X;\n\t}\n}\n\nint prime[11000];\nbool used[11000];\n\nint s1[1100], s2[1100];\nint len;\n\nlong long a[600][600];\nvector <long long> VV;\n\nvoid check(long long x, long long y) {\n\tassert(max(x, y) % min(x, y) == 0);\n}\n\nint main() {\n\tfor (int i = 2; i <= 10000; i++) {\n\t\tif (!used[i]) {\n\t\t\tprime[++len] = i;\n\t\t\tfor (int j = 2 * i; j <= 10000; j += i)\n\t\t\t\tused[j] = true;\n\t\t}\n\t}\n\tint base = 1;\n\tfor (int i = 1; i <= 500; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\ts1[i] = prime[base + i / 2];\n\t\t}else {\n\t\t\ts1[i] = prime[base + i / 2 - 1] * prime[base + i / 2];\n\t\t}\n\t}\n\n\tbase = 260;\n\n\tfor (int i = 1; i <= 500; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\ts2[i] = prime[base + i / 2];\n\t\t}else {\n\t\t\ts2[i] = prime[base + i / 2 - 1] * prime[base + i / 2];\n\t\t}\n\t}\n\n\t// printf(\"%d %d\\n%d %d\\n\", s1[1], s1[2], s2[1], s2[2]);\n\tfor (int i = 1; i <= 500; i++)\n\t\tfor (int j = 1; j <= 500; j++) {\n\t\t\ta[i][j] = 1LL * s1[i] * s2[j];\n\t\t\tassert(a[i][j] <= 1e15);\n\t\t\tVV.push_back(a[i][j]);\n\t\t}\n\tsort(VV.begin(), VV.end());\n\tfor (int i = 1; i < 250000; i++)\n\t\tassert(VV[i] != VV[i - 1]);\n\n\tfor (int i = 1; i <= 500; i++)\n\t\tfor (int j = 1; j <= 500; j++) {\n\t\t\tif (i > 1) check(a[i][j], a[i - 1][j]);\n\t\t\tif (i < 500) check(a[i][j], a[i + 1][j]);\n\t\t\tif (j > 1) check(a[i][j], a[i][j - 1]);\n\t\t\tif (j < 500) check(a[i][j], a[i][j + 1]);\n\t\t}\n\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++)\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int N=10000;\nint n,tot;\nll a[505][505];\nbool fl[10005];\nint prm[10005];\n\nll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}\nll lcm(ll x,ll y){return x==0?y:y==0?x:x/gcd(x,y)*y;}\n\nvoid getprime(){\n\tfl[1]=1;\n\tfor(int i=2;i<=N;i++){\n\t\tif(!fl[i]) prm[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*prm[j]<=N;j++){\n\t\t\tfl[i*prm[j]]=1;\n\t\t\tif(i%prm[j]==0) break;\n\t\t}\n\t}\n}\n\nint main(){\n\tgetprime();\n\tn=readint();\n\tif(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)&1) continue;\n\t\t\ta[i][j]=prm[(i+j)/2]*prm[n+(i-j+n+1)/2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!((i+j)&1)) continue;\n\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << x << std::endl\nusing ll = long long;\nconstexpr int N = 50;\nconstexpr int MAX = 16 * N;\nconstexpr int NUM = 2 * N;\nbool isprime[16 * N];\nll ans[N][N];\nint main()\n{\n    auto answer = [&]() {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                std::cout << ans[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }\n    };\n\n    std::fill(isprime, isprime + MAX, true);\n    std::vector<ll> prime;\n    for (int i = 2; i < MAX; i++) {\n        if (not isprime[i]) { continue; }\n        prime.push_back(i);\n        if (prime.size() == 2 * N) { break; }\n        for (int j = 2; i * j < MAX; j++) { isprime[i * j] = false; }\n    }\n    for (int i = 0; i < 2 * N; i += 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = i - y;\n            if (x < 0 or N <= x) { continue; }\n            ans[y][x] = prime[i / 2];\n        }\n    }\n    for (int i = N - 2; i >= -N + 2; i -= 2) {\n        for (int y = 0; y < N; y++) {\n            const int x = y + i;\n            if (x < 0 or N <= x) { continue; }\n            ans[y][x] *= prime[(i + N - 2) / 2 + N];\n        }\n    }\n    auto get = [&](const int y, const int x) { return y >= 0 and y < N and x >= 0 and x < N ? ans[y][x] : 1LL; };\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i % 2 == j % 2) { continue; }\n            ans[i][j] = get(i - 1, j) * get(i, j + 1) * get(i + 1, j) * get(i, j - 1) + 1;\n        }\n    }\n    answer();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n \nusing namespace std;\n \ntypedef long long LL;\n \nconst int inf = 1 << 30;\n \nint n;\nLL a[505][505];\n \nLL gcd(LL a,LL b){\n\treturn !b?a:gcd(b,a%b);\n}\nLL lcm(LL a,LL b){\n\tif(a==0)return b;\n\tif(b==0)return a;\n\treturn a/gcd(a,b)*b;\n}\n \nint notpm[100005],pm[100005],pcnt=0;\nvoid xxs(){\n\tnotpm[1]=1;\n\tfor(int i=2;i<=100000;i++){\n\t\tif(!notpm[i]){\n\t\t\tpm[++pcnt]=i;\n\t\t}\n\t\tfor(int j=1;pm[j]*i<=100000&&j<=pcnt;j++){\n\t\t\tnotpm[i*pm[j]]=1;\n\t\t\tif(i%pm[j]==0)break;\n\t\t}\n\t}\n}\n \nint main(){\n\tLL cnt=0;\n\tscanf(\"%d\",&n);\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\txxs();\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=(i%2==0)+1;j<=n;j+=2){\n\t\t\ta[i][j]=pm[(i+j)/2];\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=(i%2==0)+1;j<=n;j+=2){\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,n+(j-i+1)/2+2);\n\t\t\ta[i][j]*=pm[n+(j-i+((j-i)%2==0?0:1))/2+2];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!a[i][j]){\n\t\t\t\ta[i][j]=lcm(lcm(lcm(a[i-1][j],a[i][j-1]),a[i][j+1]),a[i+1][j])+1;\n\t\t\t}\n\t\t}\n\t}\n\tLL mx=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n//\t\t\tif(a[i][j]==9223216780099161841){\n//\t\t\t\tprintf(\"%d %d %lld %lld %lld %lld\\n\",i,j,a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]);\n//\t\t\t}\n//\t\t\tmx=max(mx,a[i][j]);\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n//\tprintf(\"%lld\\n\",mx);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n;\nll ans[555][555];\n\nqueue<int>pri;\nbool np[1001000];\n\nll lcm(ll x,ll y){\n    if (!x||!y) return x+y;\n    return x/__gcd(x,y)*y;\n}\n\nvoid prepri(int n){\n    for (int i=2;i<=n;++i){\n        if (np[i]) continue;\n        if (i!=2) pri.push(i);\n        for (int j=i+i;j<=n;j+=i)\n            np[j]=1;\n    }\n}\n\nmap<int,ll>ad, su;\n\nint main(){\n    prepri(1e5);\n    cin>>n;\n    for (int i=0;i<=n+1;++i)\n        for (int j=0;j<=n+1;++j)\n            if ((i+j)%2==0){\n                if (!ad[i+j]){\n                    ad[i+j]=pri.front();\n                    pri.pop();\n                }\n                if (!su[i-j]){\n                    su[i-j]=pri.front();\n                    pri.pop();\n                }\n                ans[i][j]=ad[i+j]*su[i-j];\n            }\n    int dx[4]={0,0,1,-1};\n    int dy[4]={1,-1,0,0};\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            if ((i+j)%2==1){\n                ll l=1;\n                for (int d=0;d<4;++d)\n                    l=lcm(l,ans[i+dx[d]][j+dy[d]]);\n                ans[i][j]=l+1;\n            }\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j)\n            printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// AT027D: Modular Matrix\n\nint main(){\n    int n; cin >> n;\n    int N = 500;\n    int M = 100*N;\n\n    bool prime[M];\n    for(int i = 1; i < M; i++) prime[i] = true;\n    for(int i = 2; i < M; i++) if(prime[i])\n        for(int j = i + i; j < M; j += i) \n            prime[j] = false;\n\n    vector<int> p;\n    for(int i = 2; i < M; i++) if(prime[i]) p.push_back(i);\n\n    vector<long long> a(N+1), b(N+1);\n    for(int i = 0; i <= N; i += 2) {\n        a[i] = p[i/2];\n        b[i] = p[N + i/2];\n    }\n    for(int i = 1; i < N; i += 2) {\n        a[i] = a[i-1] * a[i+1];\n        b[i] = b[i-1] * b[i+1];\n    }\n    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) for(int dx = -1; dx < 2; dx++) for(int dy = -1; dy < 2; dy++) if(abs(dx) + abs(dy) == 1) {\n        if(i + dx >= 0 && i + dx < n && j + dy >= 0 && j + dy < n) {\n            long long x = max(a[i] * b[j], a[i+dx] * b[j+dy]);\n            long long y = min(a[i] * b[j], a[i+dx] * b[j+dy]);\n            if(x % y != 0 || x > 1e15) {\n                while(true) {}\n            }\n        }\n    }\n    set<long long> S;\n    for(int i = 0; i < n; i++) {\n    \tfor(int j = 0; j < n; j++) {\n            if(S.count(a[i] * b[j])) {\n                while(true) {}\n            }\n            S.insert(a[i] * b[j]);\n            cout << a[i] * b[j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAXN = 500;\nconst int MAXM = 10000;\nbool vis[MAXM + 5];\nint prm[MAXM + 5], pcnt = 0;\nll GCD(ll x, ll y) {\n\treturn y == 0 ? x : GCD(y, x%y);\n}\nll LCM(ll x, ll y) {\n\treturn x / GCD(x, y) * y;\n}\nvoid sieve() {\n\tfor(int i=2;i<=MAXM;i++) {\n\t\tif( !vis[i] ) prm[++pcnt] = i;\n\t\tfor(int j=1;i*prm[j]<=MAXM;j++) {\n\t\t\tvis[i*prm[j]] = true;\n\t\t\tif( i % prm[j] == 0 ) break;\n\t\t}\n\t}\n}\nll Mat[MAXN + 5][MAXN + 5];\nint main() {\n\tsieve(); int N;\n\tscanf(\"%d\", &N);\n\tif( N == 2 ) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tMat[i][j] = 1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) == (j & 1) ) {\n\t\t\t\tMat[i][j] = prm[(i + j) / 2] * prm[(i+N+1-j)/2 + N];\n\t\t\t\tMat[i+1][j] = LCM(Mat[i+1][j], Mat[i][j]);\n\t\t\t\tMat[i-1][j] = LCM(Mat[i-1][j], Mat[i][j]);\n\t\t\t\tMat[i][j+1] = LCM(Mat[i][j+1], Mat[i][j]);\n\t\t\t\tMat[i][j-1] = LCM(Mat[i][j-1], Mat[i][j]);\n\t\t\t}\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tif( (i & 1) != (j & 1) )\n\t\t\t\tMat[i][j]++;\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<N;j++)\n\t\t\tprintf(\"%lld \", Mat[i][j]);\n\t\tprintf(\"%lld\\n\", Mat[i][N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 500;\nconst int MAX2 = 10000;\nint main() {\n\tint N;\n\tcin >> N;\n\tif (N == 2) { // 例外ケース\n\t\tcout << 4 << \" \" << 7 << endl << 23 << \" \" << 10;\n\t\treturn 0;\n\t}\n\tvector<int> prime;\n\tstatic bool num[MAX2];\n\tfor (int i = 0;i < MAX2;++ i) num[i] = true;\n\tfor (int i = 2, c = N << 1;c > 0;++ i) {\n\t\tif (num[i]) { // この数は素数！\n\t\t\tprime.push_back(i);\n\t\t\t-- c;\n\t\t\tfor (int j = i << 1, l = MAX2 - i;j < l;j += i) num[j] = false;\n\t\t}\n\t}\n\tstatic int64_t a[MAX][MAX];\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif ((i + j & 1) == 0) { // 素数\n\t\t\t\ta[i][j] = prime[N / 2 + (i - j) / 2] * prime[N + (i + j) / 2];\n\t\t\t} else { // 上下左右4つの素数の積+1\n\t\t\t\tif (i == 0 && j == N - 1) a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t\telse if (i == N - 1 && j == 0) a[i][j] = (int64_t)prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t\telse a[i][j] = (int64_t)prime[N / 2 + (i - j + 1) / 2] * prime[N + (i + j - 1) / 2] * prime[N / 2 + (i - j - 1) / 2] * prime[N + (i + j + 1) / 2] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tvector<int64_t> chk;\n\tfor (int i = 0;i < N;++ i) { // 要らないけど、整合性チェック\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tint d[] = {0, 1, 0, -1, 0};\n\t\t\tint check[] = {-1, -1, -1, -1};\n\t\t\tfor (int k = 0;k < 4;++ k) {\n\t\t\t\tif (i + d[k] >= 0 && i + d[k] < N && j + d[k + 1] >= 0 && j + d[k + 1] < N) {\n\t\t\t\t\tcheck[k] = max(a[i][j], a[i + d[k]][j + d[k + 1]]) % min(a[i][j], a[i + d[k]][j + d[k + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(check, check+4);\n\t\t\tfor (int i = 0;i < 3;i ++) {\n\t\t\t\tif (check[i] >= 0 && check[i] != check[i + 1]) {\n\t\t\t\t\tcerr << \"err\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i][j] >= 1000000000000000) cerr << \"err\" << endl;\n\t\t\tchk.push_back(a[i][j]);\n\t\t}\n\t}\n\tsort(chk.begin(), chk.end());\n\tfor (int i = 1;i < chk.size();++ i) {\n\t\tif (chk[i] == chk[i - 1]) cerr << \"err\" << endl;\n\t}\n\tcerr << chk[chk.size() - 1] << endl;\n\t*/\n\t\n\tfor (int i = 0;i < N;++ i) {\n\t\tfor (int j = 0;j < N;++ j) {\n\t\t\tif (j > 0) cout << \" \";\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\nまず、割った余りは……がヤバそうなので先にこれをどうにかする\nあるマスについて、常にその値を上下左右の値の最小公倍数+1にするものとしようか\nこの時、上下左右が相異なる素数ならば、最小公倍数は要するに4つの積なので常に相異なる\nそして、これの余りは1だからセーフ\n後は素数を配置だけど、500×500/2=12500……あれ、これはヤバい\n何がヤバいって12500番目の素数って値幾つだ、一度試してみよう\n試した結果、答えは1655131とのこと\nちなみに6250番目は780469\nこれ、そのまま4乗すると10^15を超えてしまう……でもある程度は行けそう……順番を調整してみよう\n解説でやってるような方法を取ってみようか\nここで、500番目の素数は3571で、4乗すると162614549665681=1.6*10^14はセーフ\nなら1と1000を、2と999を……のペアを作っていけばセーフっぽい\n\nさて、使う本数を考えていこう\nまず左上→右下への線の本数はN+(N&1)-1本\n次に右上→左下への線の本数はN本\n後はこれを、交差する数の素数番目の和が2Nを超えないようにしてみようか\nこれは簡単で、左上→右下に小さい数番目から配置する……とかで十分達成可能\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[555][555];\nint b[555][555];\nint ans[555][555];\nvector<int> p;\nsigned main(){\n\tic(n)\n\trep(2,i,10000)if(prime(i))p.pb(i);\n\trep(0,i,555)rep(0,j,555){\n\t\tif((i+j)%2==0){\n\t\t\ta[i][j]=p[(i+j)/2];\n\t\t\tb[i][j]=p[(i+1662-j)/2];\n\t\t\tans[i][j]=a[i][j]*b[i][j];\n\t\t}\n\t}\n\trep(0,i,555)rep(0,j,555)if(ans[i][j]==0&&i>0&&i<554)ans[i][j]=ans[i-1][j]*ans[i+1][j];\n\trep(0,i,n)rep(0,j,n)cout<<ans[i+1][j+1]<<\" \";\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {puts(\"4 7\\n23 10\"); return 0;} \n\tinit(10000);\n\tint ncnt=0;\n\tfor(int i=3;i<=(n<<1);i+=2) if(!val0[i]) val0[i]=prime[ncnt++];\n\tfor(int i=2*n;i>=0;--i) if((i-n)&1) val1[i]=prime[ncnt++];\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)&1) {\n\t\tan[i][j]=val0[i+j]*val1[i-j+n];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k],_y=y+dy[k];\n\t\t\tif(_x<1||_x>n||_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t}\n//\tmap<ll,bool> vis;\n//\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {\n//\t\tif(an[i][j]>1e15||an[i][j]<0||vis[an[i][j]]) {\n//\t\t\tdebug(\"%d %d %lld\\n\",i,j,an[i][j]);\n//\t\t\texit(-1);\n//\t\t}\n//\t\tvis[an[i][j]]=1;\n//\t}\n//\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {\n//\t\tif(j<n) if(max(an[i][j],an[i][j+1])%min(an[i][j],an[i][j+1])) return -1;\n//\t\tif(i<n) if(max(an[i][j],an[i+1][j])%min(an[i][j],an[i+1][j])) return -1;\n//\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nconst Int MAX = 510;\nconst Int MAX_A = 1e15;\nInt A[MAX][MAX];\nvoid check(Int n){\n  set<Int> ss;\n  for(Int i=1;i<=n;i++){\n    for(Int j=1;j<=n;j++){\n      ss.emplace(A[i][j]);\n      assert(1<=A[i][j]);\n      \n      //if(!(A[i][j]<=MAX_A)) cout<<A[i][j]<<endl;\n      assert(A[i][j]<=MAX_A);\n      if(i>1) assert(max(A[i][j],A[i-1][j])%min(A[i][j],A[i-1][j])==1);\n      if(j>1) assert(max(A[i][j],A[i][j-1])%min(A[i][j],A[i][j-1])==1);\n    }\n  }\n  assert((Int)ss.size()==n*n);\n}\n\nInt lcm(Int a,Int b){\n  return a/__gcd(a,b)*b;\n}\n\nconst Int MAX_N=1e5;\nInt th[MAX_N];\n\nsigned main(){\n  Int n;\n  cin>>n;\n\n  if(n==2){\n    cout<<\"4 7\"<<endl;\n    cout<<\"23 10\"<<endl;\n    return 0;\n  }\n\n  for(Int i=0;i<MAX;i++)\n    for(Int j=0;j<MAX;j++)\n      A[i][j]=1;\n\n  memset(th,0,sizeof(th));\n  for(Int i=2;i<MAX_N;i++)\n    if(!th[i]) for(Int j=i+i;j<MAX_N;j+=i) th[j]=1;\n  \n  vector<Int> vs;\n  for(Int i=3;i<MAX_N;i++)\n    if(!th[i]) vs.emplace_back(i);\n  \n  Int cnt=0;\n  auto nxt=[&](){return vs[cnt++];};\n  \n  for(Int i=2;i<=n;i+=2){\n    Int k=nxt();\n    for(Int j=0;i+j<=n;j++) A[i+j][j+1]*=k;\n    k=nxt();\n    for(Int j=0;i+j<=n;j++) A[j+1][i+j]*=k;\n  }\n  \n  for(Int i=2;i<=n;i+=2){\n    Int k=nxt();\n    for(Int j=0;(~n&1)+i+j<=n;j++) A[(~n&1)+i+j][n-j]*=k;\n    k=nxt();\n    for(Int j=0;i-j>=1;j++) A[j+1][i-j]*=k;\n  }\n  \n  Int di[]={0,0,1,-1};\n  Int dj[]={1,-1,0,0};\n  \n  for(Int i=1;i<=n;i++){\n    for(Int j=1;j<=n;j++){\n      if((i+j)&1) continue;\n      for(Int k=0;k<4;k++)\n\tA[i][j]=lcm(A[i][j],A[i+di[k]][j+dj[k]]);\n      A[i][j]++;\n    }\n  }\n  \n  for(Int i=1;i<=n;i++){\n    for(Int j=1;j<=n;j++){\n      if(j>1) cout<<\" \";\n      cout<<A[i][j];\n    }\n    cout<<endl;\n  }\n  \n  //check(n);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define lf '\\n'\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 507 , __ = 9999999;\nconst int go[2][4] = {{1,0,-1,0},{0,1,0,-1}};\n\ninline lint gcd(lint a,lint b){while(b)a%=b,swap(a,b);return a;}\ninline lint lcm(lint a,lint b){return a/gcd(a,b)*b;}\n\nint pri[__]={0},isnp[__]={0},pcnt=0;\n\ninline void shai(int n=__-1)\n{\n\tisnp[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!isnp[i])pri[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt && 1ll*i*pri[j]<=n;j++)\n\t\t{\n\t\t\tint a=i*pri[j];\n\t\t\tisnp[a]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n}\n\nint n;\nlint val[_][_];\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\t\n\tshai();\n\t\n\tn=ty();\n\tif(n==2){cout<<\"4 7\\n23 10\\n\";return 0;}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1,rk1,rk2;j<=n;j++)\n\t\t\tif((i+j)&1)rk1=(i+j+1)/2,rk2=(i-j+n+1)/2,val[i][j]=1ll*pri[rk1]*pri[rk2+n];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j+1)&1)\n\t\t\t{\n\t\t\t\tval[i][j]=1;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(val[i+go[0][k]][j+go[1][k]])val[i][j]=lcm(val[i][j],val[i+go[0][k]][j+go[1][k]]);\n\t\t\t\tval[i][j]++;\n\t\t\t}\n\n\tfor(int i=1;i<=n;i++,cout<<lf)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<val[i][j]<<' ';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF  = (1LL<<60);\n\nll mul(ll a,ll b){\n  if( a > INF/b )return INF;\n  else return a*b;\n}\n\nll lcm(ll a,ll b){\n  \n  return mul(a/__gcd(a,b),b);\n}\n\nll gcd(ll a,ll b){\n  return __gcd(a,b);\n}\n\nint N;\nll t[500][500];\n\nbool isPrime(ll x){\n  if(x<2)return false;\n  for(ll i=2;i*i<=x;i++)\n    if(x%i==0)return false;\n\n  return true;\n}\n\nint main(){\n  vector<ll> primes;\n  for(int i=3;i<10000;i++){\n    if(isPrime(i)){\n      primes.push_back(i);\n    }\n    \n  }\n\n  int cc=0;\n  cin>>N;\n\n  for(int i=0;i<500;i+=2){\n    int py=0, px=i;\n    for(int j=0;;j++){\n      t[py][px]=primes[cc];\n      py++;\n      px++;\n      if(py>=500 || px>=500)break;\n    }\n    cc++;\n  }\n\n  for(int i=2;i<500;i+=2){\n    int py=i, px=0;\n    for(int j=0;;j++){\n      t[py][px]=primes[cc];\n      py++;\n      px++;\n      if(py>=500 || px>=500)break;\n    }\n    cc++;\n  }\n\n  \n  //se  \n  for(int i=0;i<500;i+=2){\n    int py=0, px=i;\n    for(int j=0;;j++){\n      t[py][px]*=primes[cc];\n      py++;\n      px--;\n      if(py>=500 || px<0)break;\n    }\n    cc++;\n  }\n\n  for(int i=1;i<500;i+=2){\n    int py=i, px=499;\n    for(int j=0;;j++){\n      t[py][px]*=primes[cc];\n      py++;\n      px--;\n      if(py>=500 || px<0)break;\n    }\n    cc++;\n  }\n\n  ll maxm=0;\n  for(int i=0;i<500;i++){\n    for(int j=0;j<500;j++){\n      if(t[i][j]!=0)continue;\n      t[i][j]=1;\n      if(i>0)t[i][j]=lcm(t[i][j],t[i-1][j]);\n      if(j>0)t[i][j]=lcm(t[i][j],t[i][j-1]);\n      if(i+1<500)t[i][j]=lcm(t[i][j],t[i+1][j]);\n      if(j+1<500)t[i][j]=lcm(t[i][j],t[i][j+1]);\n      maxm=max(maxm,t[i][j]);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(j)cout<<' ';\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1005;\nint Notprime[MAXN * 100], Prime[MAXN * 100], tot;\nLL a[MAXN][MAXN];\n\nvoid Euler(int Max) {\n  for (RI i = 2; i <= Max; ++i) {\n    if (!Notprime[i]) Prime[++tot] = i;\n    for (RI j = 1; j <= tot && i * Prime[j] <= Max; ++j) {\n      Notprime[i * Prime[j]] = 1;\n      if (i % Prime[j] == 0) break;\n    }\n  }\n}\ninline LL lcm(LL x, LL y) {\n  if (!x || !y) return x | y;\n  return x / __gcd(x, y) * y;\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n; read(n);\n  Euler(100000);\n  if (n == 2) return puts(\"4 7\\n23 10\"), 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 1; j <= n; ++j)\n      if ((i + j) & 1)\n        a[i][j] = 1ll * Prime[(i + j) >> 1] * Prime[(i - j + n + 1) / 2 + n - 1];\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 1; j <= n; ++j)\n      if (!((i + j) & 1))\n        a[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1]));\n  for (RI i = 1; i <= n; ++i, puts(\"\"))\n    for (RI j = 1; j <= n; ++j)\n      printf(\"%lld \", a[i][j]);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=1010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst db eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\ninline ll gcd(ll x,ll y) { return y?gcd(y,x%y):x; }\ninline ll lcm(ll x,ll y) { return (!x||!y)?x+y:x*y/gcd(x,y); }\n\nint n;\nll a[N][N];\nint p1[N],p2[N]; // p1 ÎªÕý¶Ô½ÇÏß, p2 Îª·´¶Ô½ÇÏß \nint now1,now2;\ninline ll val(int x,int y) { return 1ll*p1[x-y+n]*p2[x+y]; }\n\nbool prime[M];\nint p[M],tot=0;\ninline void init(int n=1e5)\n{\n\tmem(prime,true);\n\tprime[1]=false;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(prime[i]) p[++tot]=i;\n\t\tfor(int j=1;j<=tot&&p[j]*i<=n;j++)\n\t\t{\n\t\t\tprime[p[j]*i]=false;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n}\n\n#ifdef FILE\nconst int RS=1<<20;\nchar buf[RS],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,RS,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tinit();\n\tn=read(),now1=1,now2=2*n-(n&1^1);\n\tif(n==2)\n\t{\n\t\tprintf(\"2 3\\n5 16\\n\");\n\t\treturn 0;\n\t}\n\tp1[0]=p2[0]=p1[2*n]=1;\n\tfor(int i=(n&1^1)+1,flag=0;i<2*n;i+=2,flag^=1)\n\t{\n\t\tif(flag) p1[i]=p[now1++];\n\t\telse p1[i]=p[now2--];\n\t}\n\tfor(int i=2,flag=0;i<=2*n;i+=2,flag^=1)\n\t{\n\t\tif(flag) p2[i]=p[now1++];\n\t\telse p2[i]=p[now2--];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i+j&1) printf(\"%lld \",1ll*p1[i-1-j+n]*p1[i+1-j+n]\n\t\t\t\t\t\t\t\t\t\t*p2[i-1+j]*p2[i+1+j]+1);\n\t\t\telse printf(\"%lld \",val(i,j));\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nint ip(int x)\n{\n    for(int i=2;i*i<=x;i++)\n        if(x%i==0)return 0;\n    return x>1;\n}\nconst int Q=1<<16,P=1<<9;\nint pn[Q];\nll als[P][P];\nll Lcm(ll a,ll b)\n{return (a==0||b==0)?a|b:a/__gcd(a,b)*b;}\nll h[Q],z[Q];\nint main()\n{\n    int tp=0,n;\n    for(int i=2;tp<1000;i++)\n        if(ip(i))pn[++tp]=i;\n    scanf(\"%d\",&n);\n    tp=0;\n    for(int i=1-n;i<=n-1;i++)\n        if(i&1^1)h[i+n]=pn[++tp];\n    for(int i=2;i<=(n<<1);i++)\n        if(i&1^1)z[i]=pn[++tp];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1^1)als[i][j]=h[j-i+n]*z[i+j];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)&1)als[i][j]=Lcm(Lcm(als[i+1][j],als[i-1][j]),Lcm(als[i][j+1],als[i][j-1]))+1LL;\n    ll mxx=0;\n    for(int i=1;i<=n;i++,puts(\"\"))\n        for(int j=1;j<=n;j++)\n            printf(\"%lld \",als[i][j]);\n    return 0;\n}\n/*\n412675878567959\n1000000000000000\n*/"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = ml * (ans[i][j - 1] / gcd(ml, ans[i][j - 1]));\n\t\t\t\tif (i < n - 1) ml = ml * (ans[i + 1][j] / gcd(ml, ans[i + 1][j]));\n\t\t\t\tif (j < n - 1) ml = ml * (ans[i][j + 1] / gcd(ml, ans[i][j + 1]));\n\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=505,M=1e4+5;\n\nint n,p[M],t;\nbool vis[M];\nll a[N][N];\n\nvoid pre(int N) {\n\tfo(i,2,N) {\n\t\tif (!vis[i]) p[++p[0]]=i;\n\t\tfo(j,1,p[0]) {\n\t\t\tint k=i*p[j];if (k>N) break;\n\t\t\tvis[k]=1;if (!(i%p[j])) break;\n\t\t}\n\t}\n}\n\nll lcm(ll a,ll b) {return a/__gcd(a,b)*b;}\n\nint main() {\n\tscanf(\"%d\",&n);pre(8e3);\n\tfo(i,0,n-1) fo(j,0,n-1) a[i][j]=1;\n\tfo(i,0,n-1) fo(j,0,n-1) if (!((i+j)&1)) a[i][j]=a[i][j]*p[(i+j)/2+1];\n\tfo(i,0,n-1) fo(j,0,n-1) if (!((i+j)&1)) a[i][j]=a[i][j]*p[(i-j)/2+n/2+n];\n\tfo(i,0,n-1) fo(j,0,n-1)\n\t\tif ((i+j)&1) {\n\t\t\tif (i) a[i][j]=lcm(a[i][j],a[i-1][j]);\n\t\t\tif (j) a[i][j]=lcm(a[i][j],a[i][j-1]);\n\t\t\tif (i+1<n) a[i][j]=lcm(a[i][j],a[i+1][j]);\n\t\t\tif (j+1<n) a[i][j]=lcm(a[i][j],a[i][j+1]);\n\t\t\ta[i][j]++;\n\t\t}\n\tfo(i,0,n-1) {fo(j,0,n-1) printf(\"%lld \",a[i][j]);puts(\"\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint N;\nint a[501][501], vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= 100000); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> N;\n\tif(N == 2) return printf(\"4 7\\n23 10\"), 0; \n\tfor(int i = 1; i <= N; i++) \n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!((i + j) & 1)) a[i][j] = prime[(i + j) / 2] * prime[N + (i - j) / 2 + (N + 1) / 2];\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!a[i][j]) \n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\ninline int read(){char ch=gc;int w=1,s=0;while(!isdigit(ch)){if(ch=='-') w=-1;ch=gc;};while(isdigit(ch)){s=s*10+ch-'0';ch=gc;} return w*s;}\nll ANS[550][550];\nll lcm(ll a,ll b){return a*b/__gcd(a,b);}\nint N,np[101010],prime[100010],cnt;\nint Hang[100010],Lie[100001];\ninline void Init(int n)\n{\n\tnp[1]=1;\n\tfor(rint i=2;i<=n;++i){\n\t\tif(!np[i]) prime[++cnt]=i;\n\t\tfor(rint j=1;j<=cnt&&i*prime[j]<=n;++j){\n\t\t\tnp[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}int dx[]={0,1,0,-1,0},dy[]={0,0,1,0,-1};\nint seq[1000010];\nint main()\n{\n\tN=read();N+=2;\n\tInit(100100);\n//\tfor(rint i=1;i<=N;++i) Hang[i]=prime[i],Lie[i]=prime[i+N];\n\tint a=1,b=(N<<1)+2;int tot=0;\n\twhile(a<b)\n\t{\n\t\tseq[++tot]=prime[a++];\n\t\tseq[++tot]=prime[b--]; \n\t} \n\tfor(rint i=1;i<=N;++i)\n\t{\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))\n\t\t\t{\n\t\t\t\tint mid1=(i+j)>>1;\n\t\t\t\tint mid2=(N-i+j+1)>>1;\n\t\t\t\tANS[i][j]=1ll*seq[mid1]*seq[mid2+N];\n\t\t\t}\n\t\t}\n\t}\n\tfor(rint i=1;i<=N;++i){\n\t\tfor(rint j=1;j<=N;++j)\n\t\t{\n\t\t\tif(!ANS[i][j])\n\t\t\t{\n\t\t\t\tll res=1;\n\t\t\t\tfor(rint d=1;d<=4;++d)\n\t\t\t\t{\n\t\t\t\t\tint ni=i+dx[d],nj=j+dy[d];\n\t\t\t\t\tif(ni<1||nj<1||ni>N||nj>N) continue;\n\t\t\t\t\tres=lcm(ANS[ni][nj],res);\n\t\t\t\t}\n\t\t\t\tANS[i][j]=res+1;\n\t\t\t}\n\t\t\tif(i>1&&i<N&&j>1&&j<N)\n\t\t\tcout<<ANS[i][j]<<\" \";\n\t\t}\n\t\tif(i>1&&i<N)\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\n//~ #warning bigger nax\nconst int nax = 1e6 + 5;\nbool is_prime[nax];\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nint main() {\n\tfor(int i = 2; i < nax; ++i) {\n\t\tis_prime[i] = true;\n\t}\n\tfor(int i = 2; i < nax; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tfor(int j = 2 * i; j < nax; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> primes;\n\tfor(int i = 2; i < nax; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t}\n\t}\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<ll>> grid(n, vector<ll>(n));\n\tint nxt = 5;\n\tvector<int> odd;\n\tfor(int i = 5; i <= 62751 + 20; i += 2) {\n\t\todd.push_back(i);\n\t}\n\t//~ random_shuffle(odd.begin(), odd.end());\n\tint z = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif((i + j) % 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst int M = 4;\n\t\t\tif(i % M == 0 || j == 0) {\n\t\t\t\tassert(!odd.empty());\n\t\t\t\tif(i % (2 * M) == 0) {\n\t\t\t\t\tgrid[i][j] = odd.back();\n\t\t\t\t\todd.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = odd[z++];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t\tgrid[i][j] = nxt; //primes[nxt++];\n\t\t\t\tnxt += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[i][j] = grid[i-1][j-1] * 2;\n\t\t\t\t//~ int dist = min(j, i - i / M * M);\n\t\t\t\t//~ grid[i][j] = grid[i-dist][j-dist] * (dist + 1);\n\t\t\t}\n\t\t}\n\t}\n\tauto inside = [&] (int a, int b) {\n\t\treturn 0 <= a && 0 <= b && a < n && b < n;\n\t};\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(grid[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgrid[i][j] = 1;\n\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\t\tint i2 = i + dx[dir];\n\t\t\t\tint j2 = j + dy[dir];\n\t\t\t\tif(inside(i2, j2)) {\n\t\t\t\t\tgrid[i][j] = grid[i][j] / __gcd(grid[i][j], grid[i2][j2]) * grid[i2][j2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0)for(int rep = 0; rep < 4; ++rep) {\n\t\t\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint i2 = i + dx[dir];\n\t\t\t\t\tint j2 = j + dy[dir];\n\t\t\t\t\tif(inside(i2, j2) && grid[i][j] == grid[i2][j2]) {\n\t\t\t\t\t\tgrid[i][j] *= 64;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset<ll> secik;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif((i + j) % 2 == 0) {\n\t\t\t\tassert(!secik.count(grid[i][j]));\n\t\t\t\tsecik.insert(grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\twhile((i + j) % 2 == 1 && secik.count(grid[i][j])) {\n\t\t\t\tgrid[i][j] *= 2;\n\t\t\t}\n\t\t\tprintf(\"%lld \", grid[i][j]);\n\t\t\t//~ fflush(stdout);\n\t\t\tif((i + j) % 2 == 1) {\n\t\t\t\tassert(!secik.count(grid[i][j]));\n\t\t\t\tsecik.insert(grid[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t\t//~ debug() << grid[i];\n\t}\n\tassert((int) secik.size() == n * n);\n\tll big = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tbig = max(big, grid[i][j]);\n\t\t}\n\t}\n\tcerr << \"big = \" << big << endl;\n\tdebug() << imie(big) imie(big / (ll) 1e12) imie(nxt) imie(primes.size());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <set>\n#include <list>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\n#define fi first\t\n#define se second\n#define long long long\ntypedef pair<int,int> ii;\n\nvector<long> vec;\nbool prime(int x)\n{\n\tfor(int i = 2; i <= sqrt(x); i++)\n\t{\n\t\tif(x%i == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\nlong MAXN = 500;\nlong A[503][503];\nlong gcd(long a, long b) {return (b)? gcd(b,a%b) : a;}\nlong lcm(long a, long b) \n{\n\tif(a == b && b == 0) return 0;\n\telse if(a == 0) return b;\n\telse if(b == 0) return a;\n\telse return a/gcd(a,b)*b;\n}\n\nint main()\n{\n\t// ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t// freopen(\"input.in\", \"r\", stdin);\n\n\tfor(int i = 2; i <= 10000; i++)\n\t\tif(prime(i))\n\t\t\tvec.push_back(i);\n\n\tint n; scanf(\"%d\", &n);\n\n\tint idx = 0;\n\tfor(int i = 1; i <= n; i+=2)\n\t{\n\t\tint x = 1, y = i;\n\t\twhile(y <= n)\n\t\t\tA[x++][y++] = vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = 3; i <= n; i+=2)\n\t{\n\t\tint x = i, y = 1;\n\t\twhile(x <= n)\n\t\t\tA[x++][y++] = vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = 1; i <= n; i+=2)\n\t{\n\t\tint x = 1, y = i;\n\t\twhile(y >= 1 && x <= n)\n\t\t\tA[x++][y--] *= vec[idx];\n\t\tidx++;\n\t}\n\tfor(int i = n; i >= 2; i-=2)\n\t{\n\t\tint x = i, y = n;\n\t\twhile(y >= 1 && x <= n)\n\t\t\tA[x++][y--] *= vec[idx];\n\t\tidx++;\n\t}\n\n\tlong mx = 0;\n\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(A[i][j] == 0) A[i][j] = lcm(lcm(A[i-1][j],A[i][j-1]),lcm(A[i+1][j],A[i][j+1]))+1;\n\t\t\t// mxnax(A[i][j],mx);\n\t\t\tprintf(\"%lld\", A[i][j]);\n\t\t\tif(j < n) printf(\" \");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t// printf(\"%lld\\n\", mx);\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\n//N以下の素数列挙。O(N log log N)\nint N = 100000;\nvector<int> primes;\nvector<bool> is_prime(N + 1, true);\nvoid init() {\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= N; i ++) {\n                if (is_prime[i]) {\n                        primes.push_back(i);\n                        for (int j = i + i; j <= N; j += i) is_prime[j] = false;\n                }\n        }\n}\n\nlong long gcd(long long a, long long b) {\n        while (b) {\n                a %= b;\n                swap(a, b);\n        }\n        return a;\n}\n\nlong long lcm(long long a, long long b) {\n        return a / gcd(a, b) * b;\n}\n\nint main() {\n        init();\n        const int n = 500;\n        vector<vector<long long>> s(n, vector<long long> (n));\n        rep(i, n) {\n                rep(j, n) {\n                        if ((i + j) & 1) {\n                                s[i][j] = primes[(j - i - 1) / 2 + n / 2] * primes[(j + i - 1) / 2 + n];\n                        }\n                }\n        }\n        /*\n                rep(i, n) {\n                        rep(j, n) cerr << s[i][j] << ' '; cerr << endl;\n                }\n        */\n        rep(i, n) {\n                rep(j, n) {\n                        if ((i + j) % 2 == 0) {\n                                long long g = 1;\n                                if (i > 0) g = lcm(g, s[i - 1][j]);\n                                if (j > 0) g = lcm(g, s[i][j - 1]);\n                                if (i < n - 1) g = lcm(g, s[i + 1][j]);\n                                if (j < n - 1) g = lcm(g, s[i][j + 1]);\n                                s[i][j] = g + 1;\n                        }\n                }\n        }\n        int p;\n        scanf(\"%d\", &p);\n        rep(i, p) {\n                rep(j, p) {\n                        printf(\"%lld%c\", s[i][j], (j == p - 1 ? '\\n' : ' '));\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505 ;\nconst int M = 10000;\n\nint noLin , noPrimes ;\nvector < int > allPrimes ;\nint isPrime[ M ] ;\nint diagPrin [ N ] , diagSec[ N ];\n\nlong long mat [ N ][ N ];\n\nvoid genCiur(){\n    int i ;\n\n    for ( i = 2 ; i * i < M ; i++ ){\n\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n\n        for ( int j = i*i ; j < M ; j+=i ){\n            isPrime [ j ] = 1 ;\n        }\n    }\n    for ( ;i < M ; i++ ){\n        if ( isPrime [ i ] == 0 ){\n            allPrimes.push_back( i );\n        }\n    }\n\n}\n\n\n__int128 cmmdc ( __int128 a , __int128 b ){\n\n    while ( b ){\n        __int128 t = a % b ;\n        a = b ;\n        b = t ;\n    }\n    return a ;\n\n}\n\n__int128 calcLCM ( __int128 a , __int128 b ){\n\n    return a * b / cmmdc ( a , b );\n\n}\n\nint main(){\n\n\n    scanf(\"%d\",&noLin);\n\n    noPrimes = 2 * noLin  + 1 ;\n\n    genCiur ();\n\n    vector<int>::iterator it = allPrimes.begin();\n\n    for ( int i = 0 ; i < 2 * noLin ; i+=1 ){\n        diagPrin [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < 2 * noLin ; i+=2 ){\n        diagSec [ i ] = *it ;\n        it++;\n    }\n    for ( int i = 0 ; i < noLin ; i+=1 ){\n        for ( int j = 0 ; j < noLin ; j+=1 ){\n            int crPrin = j - i + noLin - 1 ;\n            int crSec = 2*noLin - i - j - 1 ;\n\n            mat [ i ][ j ] = diagPrin [ crPrin ] * diagSec [ crSec ];\n        }\n    }\n\n    int jj = 0 ;\n    if ( noLin == 2 ){\n        int jj= 1 ;\n    }\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = jj ; j < noLin ; j++ ){\n\n            __int128  a = 1 , b = 1  ,c = 1 , d = 1 ;\n\n            if ( mat [ i ][ j ] == 0 ){\n                if ( i ) {\n                    a = mat [ i - 1 ][ j ];\n                }\n                if ( j ){\n                    b = mat [ i ][ j - 1 ];\n                }\n                if ( i < noLin - 1 ){\n                    c = mat [ i + 1 ][ j ];\n                }\n                if ( j < noLin - 1 ){\n                    d = mat [ i ][ j + 1 ];\n                }\n                a = calcLCM( a, b );\n                a = calcLCM( a, c );\n                a = calcLCM( a, d );\n                mat [ i ][ j ] = a + 1 ;\n            }\n\n\n        }\n    }\n\n\n    for ( int i = 0 ; i < noLin ; i++ ){\n        for ( int j = 0 ; j < noLin ; j++ ){\n            cout << mat [ i ][ j ] << \" \" ;\n//            printf(\"%I64d \",mat [ i ][ j ] );\n        }\n        printf(\"\\n\" );\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cassert>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nconst int maxp = 8000 + 10;\ntypedef long long ll;\n\nbool notprime[maxp];\nll prime[maxp] , prime_cnt;\nvoid sieve(){\n\tfor(int i = 2;i < maxp;i++){\n\t\tif(!notprime[i]) prime[prime_cnt++] = i;\n\t\tfor(int j = 0;i * prime[j] < maxp && j < prime_cnt;j++){\n\t\t\tll t = i * prime[j]; notprime[t] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\n\nll gcd(ll a,ll b){ return b ? gcd(b,a % b) : a;}\nll lcm(ll a,ll b) { return a / gcd(a,b) * b;}\n\nconst int maxn = 500 + 10;\nll a[maxn][maxn];\nint cnt,n;\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&n);\n\tif(n == 2) return !printf(\"4 7\\n23 10\");\n\tfor(int i = 0;i <= n + 1;i++){\n\t\tfor(int j = 0;j <= n + 1;j++){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) % 2 ==  0){\n\t\t\t\ta[i][j] = prime[(i + j >> 1) - 1] * prime[(i - j) / 2 + n / 2 + n];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif((i + j) & 1){\n\t\t\t\ta[i][j] = lcm(a[i][j - 1] , lcm(a[i][j + 1],lcm(a[i - 1][j],a[i + 1][j]))) + 1;\n\t\t\t\tassert(a[i][j] <= 1e15);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tprintf(\"%lld%c\",a[i][j],\" \\n\"[j == n]);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ios\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(nullptr);\n#define VEC(type, name, size)\\\n    V<type> name(size);\\\n    IN(name)\n#define VVEC(type, name, h, w)\\\n    VV<type> name(h, V<type>(w));\\\n    IN(name)\n#define INT(...)\\\n    int __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LL(...)\\\n    ll __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define STR(...)\\\n    string __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define CHAR(...)\\\n    char __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define DOUBLE(...)\\\n    DOUBLE __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LD(...)\\\n    LD __VA_ARGS__;\\\n    IN(__VA_ARGS__)\ntemplate <class T> void scan(T &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((ll)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T Roundup_div(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nconst ll INF = 1e18;\n#pragma endregion\n\nint N = 500;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ninline bool inside(int x, int y) {return x >= 0 and x < N and y >= 0 and y < N;}\n\nV<> pv;\nvector<bool> ip(10010, true);\nvoid er(){\n    ip[0] = ip[1] = 0;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) for(int j = 2 * i; j <= 10000; j += i) ip[j] = false;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) pv.pb(i);\n}\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;};\n\nint main(){\n    ios;\n    er();\n    INT(n);\n    VV<> res(N, V<>(N, 1));\n    REP(i, N) REP(j, N) if(!((i + j) % 2)) res[i][j] = pv[(i + j) / 2];\n    map<ll,ll> memo;\n    REP(i, N / 2){\n        int x = 0, y = i * 2;\n        while(x < N and y < N){\n            res[x][y] *= pv[i];\n            memo[res[x][y]]++;\n            x++; y++;\n        }\n    }\n    REP(i, N / 2 - 1){\n        int x = i * 2 + 2, y = 0;\n        while(x < N and y < N){\n            res[x][y] *= pv[N - i - 1];\n            memo[res[x][y]]++;\n            x++; y++;\n        } \n    }\n    REP(i, N) REP(j, N){\n        if(((i + j) % 2)){\n            REP(k, 4){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(inside(nx, ny)) res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n        }\n    }\n    REP(i, N) REP(j, N) if(((i + j) % 2)){\n        ll t = res[i][j];\n        res[i][j]++;\n        while(memo[res[i][j]]) res[i][j] += t;\n        memo[res[i][j]]++;\n    }\n    REP(i, n){  \n        REP(j, n) cout << res[i][j] << \" \"; cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\ntypedef long long ll;\nll a[501][501];\nint vis[501][501];\nint main()\n{\n    memset(vis,0,sizeof(vis));\n    cin>>n;\n    a[1][1]=2;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(i==j)\n            {\n                a[i][j+1]=a[i][j]*2+1;\n                vis[i][j+1]=1;\n                a[i+1][j]=a[i][j]+1;\n                vis[i+1][j]=1;\n                a[i+1][j+1]=a[i][j+1]*a[i+1][j]+1;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(i>j&&vis[i][j]==0)\n            {\n                a[i][j]=a[i-1][j]*a[i][j+1]+1;\n                vis[i][j]=1;\n            }\n            else if(i<j&&vis[i][j]==0)\n            {\n                a[i][j]=a[i][j-1]*a[i+1][j]+1;\n                vis[i][j]=1;\n            }\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N;\nbool prime[1000005];\nvector<llint> pvec;\nllint ans[505][505];\nconst llint di[] = {1, 0, -1, 0}, dj[] = {0, -1, 0, 1};\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tfor(int i = 2; i < 1005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j += i) prime[j] = true;\n\t}\n\tfor(int i = 3; i < 500005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\tvector<llint> vec;\n\tfor(int i = 0; i < pvec.size(); i++){\n\t\tfor(int j = 0; j < 8; j++) vec.push_back(pvec[i] << j);\n\t}\n\tsort(vec.begin(), vec.end());\n\tpvec = vec;\n\t\n\tllint pos = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(ans[i][j]) continue;\n\t\t\tllint tmp = 1;\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif(ni > N || nj < 1 || nj > N) continue;\n\t\t\t\tif(ni < 1) tmp *= 256;\n\t\t\t\telse tmp *= ans[ni][nj];\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\nusing namespace std;\n\nint n,tot,p[1030];\nbool b[10010];\n\nint main(){\n\tscanf(\"%d\",&n); p[0]=p[(n<<1)+1]=1;\n\tfor (int i=2; tot<(n<<1)+1; i++){\n\t\tif (!b[i]) p[++tot]=i;\n\t\tfor (int j=1; j<=tot && i*p[j]<=10000; j++){\n\t\t\tb[i*p[j]]=1;\n\t\t\tif (!(i%p[j])) break;\n\t\t}\n\t}\n\trep(x,0,n-1){\n\t\trep(y,0,n-1){\n\t\t\tint s=(x+y)>>1,d=(x-y)>>1;\n\t\t\tif ((x^y)&1) printf(\"%d \",p[s+1]*p[d+n+(n>>1)+1]);\n\t\t\t\telse printf(\"%lld \",1ll*p[s+1]*p[s]*p[d+n+(n>>1)+1]*p[d+n+(n>>1)]+1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ninline\nll getint(){\n    re ll num=0;\n    re char c;\n    while(!isdigit(c=gc()));\n    while(isdigit(c))num=(num<<1)+(num<<3)+(c^48),c=gc();\n    return num;\n}\n\ninline\nvoid outint(ll a){\n    static char ch[23];\n    if(a==0)pc('0');\n    while(a)ch[++ch[0]]=(a-a/10*10)^48,a/=10;\n    while(ch[0])pc(ch[ch[0]--]);\n}\nvector<ll> arr;\nll multi(ll a, ll b, ll p)\t//快速乘？ \n{\n\tll ans = 0;\n\twhile(b){\n\t\tif(b & 1LL)\tans = (ans+a)%p;\n\t\ta = (a+a)%p;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nll qpow(ll a, ll b, ll p)\n{\n\tll ans = 1;\n\twhile(b){\n\t\tif(b & 1LL)\tans = multi(ans, a, p);\n\t\ta = multi(a, a, p);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll x[10002];\n\nbool MR(ll n)\n{\n\tif(n == 2)\treturn true;\n\tint s = 20, i, t = 0;\n\tll u = n-1;\n\twhile(!(u&1)){\n\t\tt++;\n\t\tu >>= 1;\n\t}\n\twhile(s--){\n\t\tll a = rand()%(n-2)+2;\n\t\tx[0] = qpow(a, u, n);\n\t\tfor(i = 1; i <= t; i++){\n\t\t\tx[i] = multi(x[i-1], x[i-1], n);\n\t\t\tif(x[i] == 1 && x[i-1] != 1 && x[i-1] != n-1)\treturn false;\t\n\t\t}\n\t\tif(x[t] != 1)\treturn false;\n\t}\n\treturn true;\t\n}\n \nll gcd(ll a, ll b)\n{\n\tif(b == 0)\treturn a;\n\telse\treturn gcd(b, a%b);\n}\n \nll Pollard_Rho(ll n, int c)\n{\n\tll i = 1, k = 2, x = rand()%(n-1)+1, y = x;\n\twhile(1){\n\t\ti++;\n\t\tx = (multi(x, x, n)+c)%n;\n\t\tll p = gcd((y-x+n)%n, n);\n\t\tif(p != 1 && p != n)\treturn p;\n\t\tif(y == x)\treturn n;\n\t\tif(i == k){\n\t\t\ty = x;\n\t\t\tk <<= 1;\n\t\t}\t\n\t}\n}\n \nvoid find(ll n, int c)\n{\n\tif(n == 1)\treturn;\n\tif(MR(n)){\n\t\tarr.push_back(n);\n\t\treturn;\n\t}\n\tll p = n, k = c;\n\twhile(p >= n){\n\t\tp = Pollard_Rho(p, c--);\n\t}\n\tfind(p, k);\n\tfind(n/p, k);\n}\n\ninline\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\n\nset<ll> s;\nint N;\nll a[501][501];\n\nsigned main(){\n\tsrand(time(0));\n\tN=getint();\n\ta[1][1]=2;\n\ts.insert(2);\n\tfor(int re i=2;i<=N;++i)a[i][1]=i+1,s.insert(i+1);\n\tll cnt=N+2;\n\tif(cnt&1)--cnt;\n\t++cnt;\n\tfor(int re i=2;i<=N;++i){\n\t\ta[1][i]=cnt;\n\t\ts.insert(cnt);++cnt;\n\t}\n\tfor(int re i=2;i<=N;++i){\n\t\tfor(int re j=2;j<=N;++j){\n\t\t\tll g=gcd(a[i][j-1]-1,a[i-1][j]-1);\n\t\t\tif(g!=1){\n\t\t\t\tarr.clear();\n\t\t\t\tfind(g,107);\n\t\t\t\tbool flag=0;\n\t\t\t\tfor(int re i=0;i<arr.size();++i){\n\t\t\t\t\tif(s.find(arr[i])==s.end()){\n\t\t\t\t\t\tflag=true,a[i][j]=arr[i];\n\t\t\t\t\t\ts.insert(arr[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)continue;\n\t\t\t}\n\t\t\tll l=a[i][j-1]/gcd(a[i][j-1],a[i-1][j])*a[i-1][j];\n\t\t\tarr.clear();\n\t\t\tfind(l,107);\n\t\t\tll tmp=l+1;\n\t\t\twhile(s.find(tmp)!=s.end())tmp+=l;\n\t\t\ta[i][j]=tmp;\n\t\t\ts.insert(tmp);\n\t\t}\n\t}\n\tfor(int re i=1;i<=N;++i){\n\t\tfor(int re j=1;j<=N;++j){\n\t\t\toutint(a[i][j]),pc(' ');\n\t\t}\n\t\tpc('\\n');\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, K, A[509][509], B1[509], B2[509], cnt; vector<long long>vec, vec2, vec3;\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tcin >> K; N = 500;\n\tfor (int i = 1; i <= N; i++) vec.push_back(i);\n\tfor (int i = N + 1; i <= 200000; i++) {\n\t\tbool prime = true;\n\t\tfor (int j = 2; j*j <= i; j++) {\n\t\t\tif (i%j == 0) prime = false;\n\t\t}\n\t\tif (prime == true) { cnt++; vec2.push_back(i); }\n\t\tif (cnt * 2 >= N) break;\n\t}\n\tint L1 = 0, R1 = N - 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (i % 2 == 0) { B1[i] = vec[L1]; L1++; }\n\t\tif (i % 2 == 1) { B1[i] = vec[R1]; R1--; }\n\t}\n\tint L2 = 0, R2 = vec2.size() - 1;\n\tfor (int i = 0; i < (N + 1) / 2; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tB2[i * 2 + 1] = vec2[L2];\n\t\t\tB2[i * 2 + 2] = vec2[L2];\n\t\t\tL2++;\n\t\t}\n\t\tif (i % 2 == 1) {\n\t\t\tB2[i * 2 + 1] = vec2[R2];\n\t\t\tB2[i * 2 + 2] = vec2[R2];\n\t\t\tR2--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif ((i + j) % 2 == 1) continue;\n\t\t\tA[i][j] = B1[i] * B2[j];\n\t\t}\n\t}\n\tlong long maxn = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (A[i][j] >= 1) continue;\n\t\t\tlong long ret = 1; int dx[4] = { 0,-1,0,1 }, dy[4] = { 1,0,-1,0 };\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint fx = i + dx[k], fy = j + dy[k];\n\t\t\t\tif (fx <= 0 || fy <= 0 || fx > N || fy > N) continue;\n\t\t\t\tret = ret / gcd(ret, A[fx][fy])*A[fx][fy];\n\t\t\t}\n\t\t\tA[i][j] = ret + 1; maxn = max(maxn, A[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= K; i++) {\n\t\tfor (int j = 1; j <= K; j++) {\n\t\t\tif (j >= 2) cout << \" \"; \n\t\t\tcout << A[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint n ;cin>>n;\nfor(int i = 0;i<n;i++) for(int j=0;j<n;j++){\n\tcout<<10000000-i-j;\n  \tcout<<(j==n-1 ? \"\\n\": \" \" );}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = *this^(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n///////////////////////////\nbool prime(ll n) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return false; }\n\t}\n\treturn true;\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\tvector<ll> p;\n\n\trep(i, 10000) {\n\t\tif (i>2&&prime(i)) { p.push_back(i); }\n\t}\n\n\tll M = (N + 1) / 2+1;\n\n\tvvll a(N + 2, vll(N + 2, 1));\n\n\trep(i, N+2) {\n\t\trep(j, N+2) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\ta[i][j] = p[i / 2] * p[j / 2 + M];\n\t\t\t\tif (i % 2 == 0) { a[i][j] *= 2; }\n\t\t\t}\n\t\t}\n\t}\n\n\trepn(i, N)repn(j, N) {\n\t\tif ((i + j) % 2 == 0) {\n\t\t\ta[i][j] = lcm(a[i - 1][j], lcm(a[i + 1][j], lcm(a[i][j - 1], a[i][j + 1])))+1;\n\t\t}\n\t}\n\n\trepn(i, N) {\n\t\trepn(j, N) {\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v((i + j - 2) / 2)] * p[v((1500 + i - j) / 2)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v((i + j) / 2)] * p[v((1500 + i - j) / 2)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nsize_t N;\n\nint main(){\n    scanf(\"%lu\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N - 1; ++j)printf(\"%lld \", a.at(i, j));\n        printf(\"%lld\\n\", a.at(i, N - 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,j,book[8005],top,zhan[8005],a[505][505];\nlong long gcd(long long u,long long v){\n\tif(v==0) return u;\n\treturn gcd(v,u%v);\n}\nlong long lcm(long long u,long long v){\n\tif(u==0) return v;\n\tif(v==0) return u;\n\treturn u/gcd(u,v)*v;\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tfor(i=2;i<=8000;i++)\n\t\tif(book[i]==0){\n\t\t\ttop++;\n\t\t\tzhan[top]=i;\n\t\t\tfor(j=i*2;j<=8000;j+=i)\n\t\t\t\tbook[j]=1;\n\t\t}\n\tn=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(((i+j)&1)==0)\n\t\t\t\ta[i][j]=zhan[(i+j)/2]*zhan[(i-j)/2+n+(n+1)/2];\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]));\n  \tfor(i=1;i<=n;i++,cout<<endl)\n  \t\tfor(j=1;j<=n;j++)\n  \t\t\tpus(a[i][j],1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline ll gcd(ll a, ll b) {return b == 0 ? a : gcd(b, a % b);}\nll ans[510][510];\nint n;\nint prime[20010], cnt;\nint np[20010];\nint main() {\n    scanf(\"%d\", &n);\n    if (n == 2) return puts(\"4 7\\n23 10\"), 0;\n    for (int i = 0; i <= n + 1; i++) ans[0][i] = ans[i][0] = ans[n + 1][i] = ans[i][n + 1] = 1;\n    for (int i = 2; i <= 20000; i++) {\n        if (!np[i]) prime[++cnt] = i;\n        for (int j = 1; prime[j] * i <= 20000; j++) {\n            np[i * prime[j]] = 1;\n            if (i % prime[j] == 0) break;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if ((i + j) % 2 == 0) ans[i][j] = prime[(i + j) / 2] * prime[(i - j) / 2 + n + n];\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            if ((i + j) % 2 == 1) {\n                ans[i][j] = 1;\n                ans[i][j] *= ans[i - 1][j] / gcd(ans[i - 1][j], ans[i][j]);\n                ans[i][j] *= ans[i + 1][j] / gcd(ans[i + 1][j], ans[i][j]);\n                ans[i][j] *= ans[i][j - 1] / gcd(ans[i][j - 1], ans[i][j]);\n                ans[i][j] *= ans[i][j + 1] / gcd(ans[i][j + 1], ans[i][j]);\n                ans[i][j]++;\n            }\n    for (int i = 1; i <= n; i++, puts(\"\"))\n        for (int j = 1; j <= n; j++) printf(\"%lld \", ans[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nlong long LCM(long long a , long long b){return (__int128)a * b / __gcd(a , b);}\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1)\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = LCM(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n\tcin >> N;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= N ; ++j) cout << arr[i][j] << \" \\n\"[j == N];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\nint main(){\n    ll k=9699690;\n    vector<ll> a;\n    vector<ll> b;\n    for(ll i=2;i<=k;i++){\n        if(k%i==0){a.push_back(i);}\n    }\n    for(ll i=1;b.size()<a.size();i++){\n        b.push_back(i*k+1);\n    }\n    ll n;\n    cin>>n;\n    ll ac=0,bc=0;\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if((i+t)%2==0){\n                cout<<a[ac];\n                ac++;\n            }\n            else{\n                cout<<b[bc];\n            }\n            if(t!=n-1){cout<<\" \";}\n            else{cout<<endl;}\n        }\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=1e5+5;\nint p[N],vis[M];ll a[N][N];\nint n,m;\nvoid init(int n=1e5){\n\tfor(R int i=2;i<=n;++i){\n\t\tif(!vis[i])p[++m]=i;\n\t\tif(m==1000)return;\n\t\tfor(R int j=1;j<=m&&i*p[j]<=n;++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n}\ninline ll lcm(R ll x,R ll y){return x||y?x/__gcd(x,y)*y:x+y;}\ninline ll calc(R int i,R int j){\n\treturn lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tinit();\n\tscanf(\"%d\",&n);\n\tif(n==2)return puts(\"4 7\\n23 10\\n\"),0;\n\tfp(i,1,n)fp(j,1,n)if((i+j)&1^1)a[i][j]=1ll*p[(i+j)>>1]*p[n+((i-j)>>1)+((n+1)>>1)];\n\tfp(i,1,n)fp(j,1,n)if(!a[i][j])a[i][j]=calc(i,j);\n\tfp(i,1,n)fp(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n\n    vector<ll> prime;\n    for(ll i=2; prime.size()<2*n;++i) {\n        bool flag = true;\n        for(ll j=2; j*j<=i; ++j) {\n            if(i%j==0) flag = false;\n        }\n        if(flag) prime.push_back(i);\n    }\n\n    // cout << prime << endl;\n\n    bool turn = true;\n    ll idx1 = 0, idx2 = 2*n-1;\n    vector<vector<ll>> a(n, vector<ll>(n));\n    for(ll sx=1; sx<n; sx+=2) {\n        for(ll x=sx,y=0; x>=0&&y<n; x--,y++) {\n            if(turn) a[y][x] = prime[idx1];\n            else a[y][x] = prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n    }\n    for(ll sy=2; sy<n; sy+=2) {\n        for(ll x=n-1,y=sy; x>=0&&y<n; x--,y++) {\n            if(turn) a[y][x] = prime[idx1];\n            else a[y][x] = prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n    }\n    for(ll sx=n-1; sx>=0; sx-=2) {\n        for(ll x=sx,y=0; x<n&&y<n; x++,y++) {\n            if(turn) a[y][x] = prime[idx1];\n            else a[y][x] = prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n    }\n    for(ll sy=1; sy<n; sy+=2) {\n        for(ll x=0,y=sy; x<n&&y<n; x++,y++) {\n            if(turn) a[y][x] = prime[idx1];\n            else a[y][x] = prime[idx2];\n        }\n        if(turn) idx1++;\n        else idx2--;\n    }\n\n    REP(i, n) REP(j, n) {\n        if(a[i][j]) continue;\n        ll t = 1;\n        REP(k, 4) {\n            ll nx = j + dx[k], ny = i + dy[k];\n            if(!IN(0LL,n,nx) || !IN(0LL,n,ny)) continue;\n            t = t * a[ny][nx] / __gcd(t, a[ny][nx]);\n        }\n        a[i][j] = t + 1;\n    }\n\n\n    REP(i, n) REP(j, n) {\n        assert(a[i][j]<=1e15);\n        cout << a[i][j] << (j==n-1?'\\n':' ');\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nint N;\n\nlong long prime[1050],pri[7920];\nint tot;\nvoid sieve(){\n\tfor (int i=2;i<=7919;i++){\n\t\tif (!pri[i]){\n\t\t\tprime[++tot]=i;\n\t\t\tif (tot==1000) return;\n\t\t}\n\t\tfor (int j=1;i*prime[j]<=7919;j++){\n\t\t\tpri[i*prime[j]]=prime[j];\n\t\t\tif (!(i%prime[j])) break;\n\t\t}\n\t}\n}\n\nlong long ans[505][505];\n\nint main(){\n\tsieve();\n\tscanf(\"%d\",&N);\n\tfor (int i=1;i<=N;i++)\n\t\tfor (int j=1;j<=N;j++){\n\t\t\tif ((i^j)&1) ans[i][j]=prime[(i+j-1)>>1]*prime[(i+j+1)>>1]*prime[((i-j+N)>>1)+500]*prime[((i-j+N+2)>>1)+500]+1;\n\t\t\telse ans[i][j]=prime[(i+j)>>1]*prime[((i-j+N+1)>>1)+500];\n\t\t}\n\tfor (int i=1;i<=N;i++){\n\t\tfor (int j=1;j<=N;j++)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tputchar(10);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=505;\nint n;\nvector <int> vp;\nLL g[N][N];\nLL gcd(LL x,LL y){\n\treturn y?gcd(y,x%y):x;\n}\nLL lcm(LL x,LL y){\n\tif (!x||!y)\n\t\treturn x+y;\n\treturn x/gcd(x,y)*y;\n}\nint check(int n){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nmap <int,int> mp1,mp2;\nint g1(int x){\n\tif (!mp1[x])\n\t\tmp1[x]=vp.back(),vp.pop_back();\n\treturn mp1[x];\n}\nint g2(int x){\n\tif (!mp2[x])\n\t\tmp2[x]=vp.back(),vp.pop_back();\n\treturn mp2[x];\n}\nint main(){\n\tn=read();\n\tif (n==2){\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;vp.size()<n*2;i++)\n\t\tif (check(i))\n\t\t\tvp.push_back(i);\n\tsrand(233);\n\trandom_shuffle(vp.begin(),vp.end());\n\tmp1.clear(),mp2.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)\n\t\t\t\tg[i][j]=g1(i+j)*g2(i-j);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1){\n\t\t\t\tg[i][j]=lcm(g[i-1][j],lcm(g[i+1][j],lcm(g[i][j-1],g[i][j+1])))+1;\n\t\t\t\tassert(g[i][j]<=1000000000000000LL);\n\t\t\t}\n\tfor (int i=1;i<=n;i++,puts(\"\"))\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",g[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 500 + 20 , M = 3e4 + 20 ;\nint n , a[N][N] ;\nbool np[M] ;\nvector <int> vec ;\n\ninline void add (int &a , int b) {\n\ta = a / __gcd(a , b) * b ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\" ;\n\t\treturn 0 ;\n\t}\n\n\tnp[0] = np[1] = 1 ;\n\tfor (int i = 2 ; i < M ; i ++) {\n\t\tif (np[i]) continue ;\n\n\t\tvec.push_back(i) ;\n\n\t\tfor (int j = 2 * i ; j < M ; j += i) np[j] = 1 ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 0) \n\t\t\t\ta[i][j] = vec[(i + j) >> 1] * vec[((i - j + n) >> 1) + n] ;\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 1) {\n\t\t\t\ta[i][j] = 1 ;\n\t\t\t\tif (i > 0) add(a[i][j] , a[i - 1][j]) ;\n\t\t\t\tif (i < n - 1) add(a[i][j] , a[i + 1][j]) ;\n\t\t\t\tif (j > 0) add(a[i][j] , a[i][j - 1]) ;\n\t\t\t\tif (j < n - 1) add(a[i][j] , a[i][j + 1]) ;\n\t\t\t\ta[i][j] += 1 ;\n\t\t\t}\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int j = 0 ; j < n ; j ++) cout << a[i][j] << ' ' ;\n\t\tcout << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[505][505],x[505],y[505];\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){\n\tif(!a)return b;\n\tif(!b)return a;\n\treturn a/gcd(a,b)*b;\n}\nint las=1;\nint next_p(){\n\twhile(++las){\n\t\tbool ok=1;\n\t\tfor(int i=2;i*i<=las;++i)if(!(las%i))ok=0;\n\t\tif(ok)return las;\n\t}\n\treturn 114514;\n}\nint I(int x){\n\tint bas=1;\n\twhile(st.count(bas*x))++bas;\n\tst.insert(bas*x);\n\treturn bas*x;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(n);\n\tfor(int i=1;i<=n;++i){\n\t\tx[i]=next_p();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ty[i]=next_p();\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(!((i+j)&1)){\n\t\t\ta[i][j]=x[(i+j)>>1]*y[(i-j+n+1)>>1];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i][j-1],lcm(a[i+1][j],a[i][j+1])));\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)write(a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 5555555\n#define M 2020\nusing namespace std;\n\nint vis[N];\nvector<int> pri;\n\nvoid sieve(int n) {\n    for (int i = 2; i <= n; ++i) {\n        if (!vis[i]) pri.push_back(i);\n        for (int j : pri) {\n            if (1ll * i * j > n) break;\n            vis[i * j] = 1;\n            if (i % j == 0) break;\n        }\n    }\n}\n\nlong long a[M][M];\nint n, top, p[2][M << 2];\n\nlong long lcm(long long x, long long y) {\n    return x / __gcd(x, y) * y;\n}\n\nint get(int op, int x) {\n    if (op) x += n;\n    if (!p[op][x]) p[op][x] = pri[top++];\n    return p[op][x];\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    if (n == 1) return cout << 1 << endl, 0;\n\n    if (n == 2) return puts(\"1 4\\n16 2\"), 0;\n\n    sieve(10000);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) {\n            if ((i + j) & 1)\n                a[i][j] = 1ll * get(0, i + j) * get(1, i - j);\n        }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (!((i + j) & 1)) {\n                a[i][j] = 1;\n                if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n                if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n                if (i < n) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n                if (j < n) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n            }\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            printf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 500 + 20 , M = 3e4 + 20 ;\nint n , a[N][N] ;\nbool np[M] ;\nvector <int> vec ;\n\nint gcd (int a , int b) {\n\tif (!b) return a ;\n\treturn gcd(b , a % b) ;\n}\n\ninline void add (int &a , int b) {\n\ta = a / gcd(a , b) * b ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\\n\" ;\n\t\treturn 0 ;\n\t}\n\n\tnp[0] = np[1] = 1 ;\n\tfor (int i = 2 ; i < M ; i ++) {\n\t\tif (_sz(vec) == 2 * N) break ;\n\t\tif (np[i]) continue ;\n\n\t\tvec.push_back(i) ;\n\n\t\tfor (int j = 2 * i ; j < M ; j += i) np[j] = 1 ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 0) \n\t\t\t\ta[i][j] = vec[(i + j) >> 1] * vec[((i - j + n) >> 1) + n] ;\n\n\tfor (int i = 0 ; i < n ; i ++)\n\t\tfor (int j = 0 ; j < n ; j ++)\n\t\t\tif (((i + j) & 1) == 1) {\n\t\t\t\ta[i][j] = 1 ;\n\t\t\t\tif (i > 0) add(a[i][j] , a[i - 1][j]) ;\n\t\t\t\tif (i < n - 1) add(a[i][j] , a[i + 1][j]) ;\n\t\t\t\tif (j > 0) add(a[i][j] , a[i][j - 1]) ;\n\t\t\t\tif (j < n - 1) add(a[i][j] , a[i][j + 1]) ;\n\t\t\t}\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int j = 0 ; j < n ; j ++) cout << a[i][j] << ' ' ;\n\t\tcout << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool IsGood(int x, const vector<int>& d) {\n  for (int y : d) {\n    while (x % y == 0) x /= y;\n  }\n  return x == 1;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  if (n == 2) {\n    printf(\"4 7\\n23 10\\n\");\n    return 0;\n  }\n  const int BUBEN = 3e6;\n  vector<bool> p(BUBEN, true);\n  vector<ll> primes;\n  for (int i = 2; i < BUBEN; ++i) {\n    if (!p[i]) continue;\n    primes.push_back(i);\n    if (primes.size() >= 10000) break;\n    for (int j = i; j < BUBEN; j += i) p[j] = false;\n  }\n  vector<int> odd, even;\n  for (int i = 0; i < 2 * n; ++i) {\n    if (i % 2) odd.push_back(primes[i]); else even.push_back(primes[i]);\n  }\n  vector<ll> x, y;\n  for (int cur = 2; ; ++cur) {\n    if (x.size() == n && y.size() == n) break;\n    if (x.size() < n && IsGood(cur, odd)) {\n      x.push_back(cur);\n    } else if (y.size() < n && IsGood(cur, even)) {\n      y.push_back(cur);\n    }\n  }\n\n  vector<vector<vector<ll>>> mul(n, vector<vector<ll>>(n));\n  vector<vector<ll>> ans(n, vector<ll>(n, 1));\n\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    if ((i + j) % 2 == 1) continue;\n    mul[i][j].push_back(x[(i + j) / 2]);\n    ans[i][j] *= mul[i][j].back();\n  }\n\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    if ((i + j) % 2 == 1) continue;\n    mul[i][j].push_back(y[(i - j + n - 1) / 2]);\n    ans[i][j] *= mul[i][j].back();\n  }\n\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    if ((i + j) % 2 == 0) continue;\n    set<ll> cur;\n    for (int di = -1; di <= 1; ++di) for (int dj = -1; dj <= 1; ++dj) if (di * di + dj * dj == 1) {\n      int ii = i + di;\n      int jj = j + dj;\n      if (ii < 0 || ii >= n || jj < 0 || jj >= n) continue;\n      for (ll x : mul[ii][jj]) cur.insert(x);\n    }\n    for (ll x : cur) ans[i][j] *= x;\n    ans[i][j]++;\n  }\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (j) cout << \" \";\n      cout << ans[i][j];\n    }\n    cout << endl;\n  }\n\n\n  map<ll, vector<pair<int, int>>> mp;\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) mp[ans[i][j]].push_back(make_pair(i, j));\n  for (auto it : mp) {\n    if (it.second.size() > 1) {\n      cerr << \"BOTVA\\n\";\n      cerr << it.first << endl;\n      cerr << it.second[0].first << \" \" << it.second[0].second << endl;\n      cerr << it.second[1].first << \" \" << it.second[1].second << endl;\n      //return 0;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n    assert(ans[i][j] < 1e15);\n    for (int di = -1; di <= 1; ++di) for (int dj = -1; dj <= 1; ++dj) if (di * di + dj * dj == 1) {\n      int ii = i + di;\n      int jj = j + dj;\n      if (ii < 0 || ii >= n || jj < 0 || jj >= n) continue;\n      ll a = ans[i][j];\n      ll b = ans[ii][jj];\n\n      assert(max(a, b) % min(a, b) == 1);\n    }\n  }\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,tot;\nconst int N=1005;\nLL a[N][N],zhi[N<<1],vis[10010];\nLL GCD(LL a,LL b){return b?GCD(b,a%b):a;}\nLL LCM(LL a,LL b){if(!a||!b)return a+b;else return a/GCD(a,b)*b;}\nvoid YYCH()\n{\n\tvis[1]=1;\n\tfor(int i=2;i<=10000;++i)\n\t{\n\t\tif(!vis[i])zhi[++tot]=i;\n\t\tfor(int j=1;j<=tot&&i*zhi[j]<=10000;++j)\n\t\t{\n\t\t\tvis[i*zhi[j]]=1;\n\t\t\tif(!(i%zhi[j]))break;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;if(n==2)return printf(\"4 7\\n23 10\\n\")==233;\n\tYYCH();\n    for(int i=1;i<=n;++i)\n    \tfor(int j=((i+1)&1)+1;j<=n;j+=2)\n    \t\ta[i][j]=zhi[(i+j)/2]*zhi[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n    \tfor(int j=(i&1)+1;j<=n;j+=2)\n\t\t\ta[i][j]=LCM(LCM(a[i-1][j],a[i][j-1]),LCM(a[i+1][j],a[i][j+1]))+1;\n    for(int i=1;i<=n;++i,puts(\"\"))\n    \tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\t/*random_shuffle(vec1.begin(), vec1.end());\n\trandom_shuffle(vec2.begin(), vec2.end());*/\n\n\tqueue<pair<ll, ll>> q;\n\tq.push({ 0, 0 });\n\n\tused[0][0] = 1;\n\tvector<pair<ll, ll>> dir1 = { {2, 0}, {0, 2} };\n\twhile (!q.empty()) {\n\t\tpair<ll, ll> v = q.front();\n\t\tq.pop();\n\n\t\tans[v.first][v.second] = vec1.front();\n\t\tvec1.pop_front();\n\n\t\tfor (auto cur : dir1) {\n\t\t\tif (!used[v.first + cur.first][v.second + cur.second] && cur.first + cur.first < n && v.second + cur.second < n) {\n\t\t\t\tq.push({v.first + cur.first, v.second + cur.second});\n\t\t\t\tused[v.first + cur.first][v.second + cur.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nbool is[maxn];\nll pri[maxn],cnt,a[505][505],n;\n\ninline void pre()\n{\n\tfor(int i=2;i<=maxn-5;i++)\n\t{\n\t\tif(!is[i]) pri[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&pri[j]*i<=(maxn-5);j++)\n\t\t{\n\t\t\tis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0) break;\n\t\t}\n\t}\n}\n\ninline ll X(int x){return pri[x];}\ninline ll Y(int x){return pri[250+x];}\ninline ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}\n\nint main()\n{\n\tn=read(); pre();\n\trep(i,0,n+1) rep(j,0,n+1) a[i][j]=1;\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==0)\n\t{\n\t\ta[i][j]=X(i+j)*Y(abs(i-j));\n\t}\n\trep(i,1,n) rep(j,1,n) if((i+j)%2==1)\n\t{\n\t\tll p1=lcm(a[i-1][j],a[i][j-1]);\n\t\tll p2=lcm(a[i+1][j],a[i][j+1]); a[i][j]=lcm(p1,p2);\n\t}\n\trep(i,1,n)\n\t{\n\t\trep(j,1,n) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n*/\n#include <cstdio>\n#include <algorithm>\ntypedef long long LL;\nconst int N=505,M=8100;\n\nint P[1005];\nLL A[N][N];\n\nvoid Init()\n{\n\tstatic bool notP[M];\n\tfor(int cnt=0,i=2; cnt<1000; ++i)\n\t{\n\t\tif(!notP[i]) P[++cnt]=i;\n\t\tfor(int j=1,v; j<=cnt&&(v=i*P[j])<M; ++j)\n\t\t{\n\t\t\tnotP[v]=1;\n\t\t\tif(!(i%P[j])) break;\n\t\t}\n\t}\n}\ninline LL LCM(LL x,LL y)\n{\n\treturn x/std::__gcd(x,y)*y;\n}\n\nint main()\n{\n\tInit();\n\tint n; scanf(\"%d\",&n);\n\tif(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tfor(int i=0; i<=n+1; ++i) A[0][i]=1, A[n+1][i]=1, A[i][n+1]=A[i][0]=1;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=n; ++j)\n\t\t\tif(!(i+j&1)) A[i][j]=P[i+j>>1]*P[(i-j+n+1)/2+n];\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=n; ++j)\n\t\t\tif(i+j&1) A[i][j]=LCM(LCM(A[i-1][j],A[i][j-1]),LCM(A[i+1][j],A[i][j+1]))+1;\n\tfor(int i=1; i<=n; ++i,putchar('\\n'))\n\t\tfor(int j=1; j<=n; ++j) printf(\"%lld \",A[i][j]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  scanf(\"%d\", &n);\n  if (n == 2) {\n    puts(\"4 7\");\n    puts(\"23 10\");\n    return 0;\n  }\n\n  auto is_prime = [&](int p) {\n    for (int i = 2; i * i <= p; ++i) {\n      if (p % i == 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  auto lcm = [&](ll x, ll y) {\n    return x / __gcd(x, y) * y;\n  };\n\n  int p = 1;\n  vector<vector<ll>> a(n + 1, vector<ll> (n + 1, 1));\n  for (int i = 1; i <= n << 1; ++i) {\n    if (i & 1) {\n      ++p;\n      while (!is_prime(p)) {\n        ++p;\n      }\n      for (int j = 1; j < i; ++j) {\n        if (j <= n && i - j <= n) {\n          a[j][i - j] *= p;\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (i & 1) {\n      ++p;\n      while (!is_prime(p)) {\n        ++p;\n      }\n      for (int j = i; j <= n; ++j) {\n        a[j][j - i] *= p;\n      }\n      ++p;\n      while (!is_prime(p)) {\n        ++p;\n      }\n      for (int j = i; j <= n; ++j) {\n        a[j - i][j] *= p;\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      if (a[i][j] == 1) {\n        if (i > 1) {\n          a[i][j] = lcm(a[i][j], a[i - 1][j]);\n        }\n        if (j > 1) {\n          a[i][j] = lcm(a[i][j], a[i][j - 1]);\n        }\n        if (i < n) {\n          a[i][j] = lcm(a[i][j], a[i + 1][j]);\n        }\n        if (j < n) {\n          a[i][j] = lcm(a[i][j], a[i][j + 1]);\n        }\n        ++a[i][j];\n      }\n    }\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      printf(\"%lld%c\", a[i][j], j == n ? '\\n' : ' ');\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pir pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define pb push_back\nusing namespace std;\n\nconst int N=510,M=100010;\nint n,prime[M],cnt;\nll res[N][N];\nbool vis[M];\nvector<pir> v;\n\nvoid pre(int m) {\n    for(int i=2;i<=m;i++) {\n        if(!vis[i]) prime[++cnt]=i;\n        for(int j=1;j<=cnt;j++) {\n            int tmp=prime[j]*i;\n            if(tmp>m) break;\n            vis[tmp]=1;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n\nbool cmp1(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi+a.se<b.fi+b.se;\n    return a<b;\n}\n\nbool cmp2(pir a,pir b) {\n    if(a.fi+a.se!=b.fi+b.se) return a.fi-a.se<b.fi-b.se;\n    return a<b;\n}\n\nll lcm(ll a,ll b) {\n    return a/__gcd(a,b)*b;\n}\n\nint main() {\n    pre(100000);\n    scanf(\"%d\",&n);\n    if(n==2) return printf(\"2 3\\n5 4\\n\"),0;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2==0) v.pb({i,j});\n            res[i][j]=1;\n        }\n    }\n    sort(v.begin(),v.end(),cmp1);\n    pir pre={0,0};\n    int* ptr=prime;\n    for(auto p:v) {\n        if(p.fi+p.se!=pre.fi+pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    sort(v.begin(),v.end(),cmp2);\n    pre={0,0};\n    for(auto p:v) {\n        if(p.fi-p.se!=pre.fi-pre.se) ptr++;\n        res[p.fi][p.se]*=*ptr;pre=p;\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) {\n            if((i+j)%2) {\n                if(i>1) res[i][j]=lcm(res[i][j],res[i-1][j]);\n                if(j>1) res[i][j]=lcm(res[i][j],res[i][j-1]);\n                if(i<n) res[i][j]=lcm(res[i][j],res[i+1][j]);\n                if(j<n) res[i][j]=lcm(res[i][j],res[i][j+1]);\n                printf(\"%lld \",res[i][j]+1);\n            }\n            else printf(\"%lld \",res[i][j]);\n        }\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 3e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\tfor (int i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\ntypedef v(vl) vvl;\nconst int di[] = {-1,0,1,0}, dj[] = {0,-1,0,1}; //^<v>\n//const int di[] = {-1,0,1,-1,1,-1,0,1}, dj[] = {-1,-1,-1,0,0,1,1,1};\n\n#define bsf __builtin_ctzll\nll gcd(ll a, ll b) {\n  // a = abs(a); b = abs(b);\n  if (!a || !b) return a|b;\n  int t = bsf(a|b); a >>= bsf(a);\n  do { b >>= bsf(b); if (a > b) swap(a, b); b -= a;} while (b);\n  return a << t;\n}\nll lcm(ll x, ll y) { return x/gcd(x,y)*y;}\n// linear sieve\nvi ps, pf;\nvoid sieve(int mx) {\n  pf = vi(mx);\n  rep(i,mx) pf[i] = i;\n  for (int i = 2; i < mx; ++i) {\n    if (pf[i] == i) ps.pb(i);\n    for (int j = 0; j < sz(ps) && ps[j] <= pf[i]; ++j) {\n      int x = ps[j]*i;\n      if (x >= mx) break;\n      pf[x] = ps[j];\n    }\n  }\n}\ninline bool isp(int x) { return pf[x] == x && x >= 2;}\nvi factor(int x) { // asc\n  vi res;\n  while (x != 1) {\n    res.pb(pf[x]);\n    x /= pf[x];\n  }\n  return res;\n}\n//\n\n\n\nint main() {\n  int n = 500;\n  scanf(\"%d\",&n);\n  sieve(MX);\n  int xs = 0, ys = 0;\n  rep(i,n)rep(j,n) {\n    if (~(i+j)&1) continue;\n    int x = (j+(n-1-i))/2;\n    int y = (i+j)/2;\n    maxs(xs,x);\n    maxs(ys,y);\n  }\n  ++xs; ++ys;\n  vi px, py;\n  rep(i,xs) px.pb(ps[i*2]);\n  rep(i,ys) py.pb(ps[i*2+1]);\n  vi sx, sy;\n  while (sz(px)) {\n    sx.pb(px.back());\n    px.pop_back();\n    reverse(rng(px));\n  }\n  while (sz(py)) {\n    sy.pb(py.back());\n    py.pop_back();\n    reverse(rng(py));\n  }\n\n  vvl ans(n,vl(n,1));\n  rep(i,n)rep(j,n) {\n    if (~(i+j)&1) continue;\n    int x = (j+(n-1-i))/2;\n    int y = (i+j)/2;\n    ans[i][j] = sx[x]*sy[y];\n  }\n  // cerr<<ans<<endl;\n\n  ll mx = 0;\n  rep(i,n)rep(j,n) {\n    if ((i+j)&1) continue;\n    rep(v,4) {\n      int ni = i+di[v], nj = j+dj[v];\n      if (ni<0||nj<0||ni>=n||nj>=n) continue;\n      ans[i][j] = lcm(ans[i][j],ans[ni][nj]);\n    }\n    ans[i][j]++;\n    maxs(mx, ans[i][j]);\n  }\n  // cerr<<mx<<endl;\n  // cerr<<ll(1e15)<<endl;\n\n  // set<ll> st;\n  // rep(i,n)rep(j,n) st.insert(ans[i][j]); assert(sz(st) == n*n);\n\n  rep(i,n) cout<<ans[i]<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int K = 1e6;\nbool pr[K];\nset<int> m[K];\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    for (int i=2; i < K; i++){\n        if (!pr[i]){\n            m[i].insert(i);\n            for (int j=i+i; j < K; j+=i){\n                pr[j] = true;\n                m[j].insert(i);\n            }\n        }\n    }\n    int n=200;\n    int a[n][n];\n    for (int i=0; i < n; i++) for (int j=0; j < n; j++) a[i][j] = 0;\n    int u = 2;\n    set<int> hh;\n    for (int i=0; i < n; i+=2){\n        for (int j=0; j < n; j++){\n            if ((i+j)%2!=0) continue;\n            while (u%2==0)u++;\n            a[i][j] = u;\n            if (i+1 < n && j+1 < n) a[i+1][j+1] = 2*u;\n            u++;\n        }\n    }\n    set<int> used;\n    for (int i=0; i < n; i++){\n        for (int j=0; j < n; j++){\n            if (a[i][j] != 0) continue;\n            vector<int> b;\n            if (i-1 >= 0) b.push_back(a[i-1][j]);\n            if (j+1 < n) b.push_back(a[i][j+1]);\n            if (i+1 < n) b.push_back(a[i+1][j]);\n            if (j-1>=0) b.push_back(a[i][j-1]);\n            set<int> gl;\n            for (int p=0; p < b.size(); p++) {\n                for (set<int>::iterator it = m[b[p]].begin(); it != m[b[p]].end(); it++){\n                    //cout << (*it) << endl;\n                    gl.insert(*it);\n                }\n            }\n            //cout << endl;\n            int R = 1;\n            for (set<int>::iterator it = gl.begin(); it != gl.end(); it++){\n                int num = *it;\n                int kf = 0;\n                for (int p=0; p < b.size(); p++){\n                    int s = 0;\n                    while (b[p] % num == 0){\n                        b[p] /= num;\n                        s++;\n                    }\n                    kf = max(kf, s);\n                }\n                for (int e=0;e<kf;e++) R *= num;\n            }\n            int rr = R+1;\n            while (used.count(rr)) rr += R;\n            R = rr;\n            if (R > 1e15){\n                cout << R << endl;\n                return 0;\n            }\n            a[i][j] = R;\n            used.insert(R);\n        }\n    }\n    for (int i=0;i<n;i++){\n        for (int j=0;j<n;j++) cout << a[i][j] << \" \";\n        cout << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,pri[10010],tot=0;\nbool nopri[10010];\nll ans[510][510];\n\nll lcm(ll x,ll y) {return x*y/__gcd(x,y);}\n\nvoid sieve(int n)\n{\n    rep(i,2,n)\n    {\n        if (!nopri[i]) pri[++tot]=i;\n        for (int j=1;j<=tot && i*pri[j]<=n;j++)\n        {\n            nopri[i*pri[j]]=1;\n            if (i%pri[j]==0) break;\n        }\n    }\n}\n\nint main()\n{\n    sieve(10000);\n    n=read();\n    if (n==2)\n    {\n        puts(\"4 7\\n23 10\");return 0;\n    }\n    rep(i,0,n+1) ans[0][i]=ans[n+1][i]=ans[i][0]=ans[i][n+1]=1;\n    int now=0;\n    rep(i,1,n)\n    {\n        int st;\n        if (i&1) st=1;else st=2;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=pri[(i+j)>>1]*pri[(i-j+n+1)/2+n];\n        }\n    }\n    rep(i,1,n) \n    {\n        int st;\n        if (i&1) st=2;else st=1;\n        for (int j=st;j<=n;j+=2)\n        {\n            ans[i][j]=lcm(lcm(ans[i-1][j],ans[i+1][j]),lcm(ans[i][j-1],ans[i][j+1]))+1;\n        }\n    }\n    rep(i,1,n)\n    {\n        rep(j,1,n) printf(\"%lld \",ans[i][j]);\n        puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<9, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nbool prime(int a) {\n\tfor(int d = 2; d*d <= a; d++) if(a%d == 0) return 0;\n\treturn 1;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tvi a{1}, b{1};\n\tfor(int i = 2; b.size() < n; i++) {\n\t\tif(!prime(i)) continue;\n\t\tif(a.size() < n) {\n\t\t\ta.pb(a.back()*i);\n\t\t\ta.pb(i);\n\t\t} else {\n\t\t\tb.pb(a.back()*i);\n\t\t\tb.pb(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++, cout << '\\n')\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tcout << a[i]*b[j] << ' ';\n}\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\n#define int long long\n\nint gcd(int x, int y) {\n\treturn (!y) ? x : gcd(y, x % y);\n}\n\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint n, A[N][N], pr[N], cnt;\nbitset <100005> isp;\n\nvoid prework(int tot) {\n\tfor(int i = 1; i < 100005; ++ i) isp[i] = 1;\n\tisp[1] = 0;\n\tfor(int i = 1; cnt < tot; ++ i) {\n\t\tif(isp[i]) pr[++ cnt] = i;\n\t\tfor(int j = 1; j <= cnt && pr[j] * i <= 100000; ++ j) {\n\t\t\tisp[i * pr[j]] = 0;\n\t\t\tif(i % pr[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain() {\n\tisp = 0;\n\tcin >> n;\n\tn += 2;\n\tprework(n * 2 + 2);\n\t//for(int i =1; i <= cnt; ++ i) cerr << pr[i] << \" \";\n\t//puts(\"\");\n\tfor(int i = 0; i <= n + 1; ++ i) {\n\t\tfor(int j = 0; j <= n + 1; ++ j) {\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i = 1; i <= n; i += 2) {\n\t\tint nx = i, ny = 1;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 3; i <= n; i += 2) {\n\t\tint nx = 1, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n; i >= 1; i -= 2) {\n\t\tint nx = n, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n - ((n & 1) ^ 1); i >= 1; i -= 2) {\n\t\tint nx = i, ny = 1;\n\t\tif(i == n) continue;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\t//cerr << i <<\" \" << j << endl;\n\t\t\t\t//cerr << A[i][j - 1] <<\" \" << A[i - 1][j] <<\" \" << A[i + 1][j] <<\" \" << A[i][j + 1] << endl;\n\t\t\t\tA[i][j] = lcm(lcm(A[i][j - 1], A[i - 1][j]), lcm(A[i + 1][j], A[i][j + 1])) + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2; i <= n - 1; ++ i) {\n\t\tfor(int j = 2; j <= n - 1; ++ j) {\n\t\t\tprintf(\"%lld\", A[i][j]);\n\t\t\tif(j != n - 1) putchar(' ');\n\t\t\t//assert(max(A[i][j], A[i - 1][j]) % min(A[i][j], A[i - 1][j]) == 0);\n\t\t\t//assert(max(A[i][j], A[i][j - 1]) % min(A[i][j], A[i][j - 1]) == 0);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=503;\nusing namespace std;\ntypedef long long ll;\nll a[N][N];\nint n,p[N*2],tot;\nbool np[N*30];\ninline int F(int x){\n\treturn p[n+x/2];\n}\ninline int G(int x){\n\treturn p[(x+n/2*2)/2];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;tot<2*n;i++){\n\t\tif(!np[i])p[tot++]=i;\n\t\tfor(int j=i*i;j<N*30;j+=i)np[j]=1;\n\t}\n\tfor(int i=0;i<n;i++,puts(\"\"))\n\tfor(int j=0;j<n;j++)\n\tif(i+j&1){\n\t\tprintf(\"%lld \",1ll*F(i+j-1)*F(i+j+1)\n\t\t*G(i-j-1)*G(i-j+1)+1);\n\t}else printf(\"%d \",F(i+j)*G(i-j));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 510;\nbool flag[maxn * maxn] = {0};\nlong long p[maxn * maxn];\nint cnt = 0;\nvoid init(int n)\n{\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tif(!flag[i])\n\t\t{\n\t\t\tflag[i] = 1;\n\t\t\tp[++ cnt] = i;\n\t\t}\n\t\tfor(int j = 1; j <= cnt && p[j] * i <= n; j ++)\n\t\t{\n\t\t\tflag[p[j] * i] = 1;\n\t\t\tif(i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n;\nlong long v[maxn][maxn];\nlong long gcd(long long a, long long b)\n{\n\tif(b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nint dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\nbool in(int x, int y)\n{\n\treturn x > 0 && x <= n && y > 0 && y <= n;\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n;\n\tif(n == 2)\n\t{\n\t\tcout << \"4 7\" << endl;\n\t\tcout << \"23 10\" << endl;\n\t\treturn 0;\n\t}\n\tinit(500 * 500);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif((i + j) % 2 == 0)\n\t\t\t\tv[i][j] = p[(i + j) / 2];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif((i + j) % 2 == 0)\n\t\t\t\tv[i][j] *= p[(n - i + j + n * 2) / 2 + 1];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif((i + j) % 2 == 1)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < 4; k ++)\n\t\t\t\t{\n\t\t\t\t\tint x = i + dir[k][0], y = j + dir[k][1];\n\t\t\t\t\tif(in(x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(v[i][j] != 0)\n\t\t\t\t\t\t\tv[i][j] = v[i][j] * (v[x][y] / gcd(v[i][j], v[x][y]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tv[i][j] = v[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[i][j] ++;\n\t\t\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tcout << v[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e8, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nint64 p[1503];\nint pn;\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint i = 2;\n\twhile(pn < 1500) {\n\t\tfor(int j = 2;j * j <= i;++j) if(i % j == 0) goto isp;\n\t\tp[pn++] = i;\n\t\tisp:\n\t\t++i;\n\t}\n\tfor(int i = 0;i < n;++i) {\n\t\tfor(int j = 0;j < n;++j) {\n\t\t\tint64 val;\n\t\t\tif(((i+j)&1) == 1) {\n\t\t\t\tval = p[(i+j-1)/2] * p[(i+j+1)/2] * p[(i-j-1)/2+2*n] * p[(i-j+1)/2+2*n] + 1;\n\t\t\t} else {\n\t\t\t\tval = p[(i+j)/2] * p[(i-j)/2+2*n];\n\t\t\t}\n\t\t\tprintf(\"%lld \", val);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair < int, int > PII;\ntypedef pair < LL, LL > PLL;\ntypedef pair < LD, LD > PDD;\n\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntemplate < typename _T > inline void _DBG(const char *s, _T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate < typename _T, typename... args > void _DBG(const char *s, _T x, args... a) { while(*s != ',') cerr << *s++; cerr << \" = \" << x << ','; _DBG(s + 1, a...); }\n\n#ifdef LOCAL\n#define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0) cout\n#endif\n\n// ********************** CODE ********************** //\n\nconst int N = 500;\n\nLL pri[] = {1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901};\n\nLL T[N][N];\nunordered_set < LL > S;\n\nLL nwd(LL a, LL b)\n{\n    if(b == 0) return a;\n    return nwd(b, a % b);\n}\n\nLL nww(LL a, LL b)\n{\n    return a / nwd(a, b) * b;\n}\n\nint main()\n{\n    _upgrade\n    srand(time(NULL) + getpid()); \n    // random_shuffle(pri, pri + 1000);\n    int l = 0, r = 505; \n    for(int i = 0; i <= 2 * N; i += 2)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if(0 <= k && k < N)\n            {\n                T[j][k] = pri[(i & 1 ? r : l)];\n            }\n        }\n        if(i & 1)\n            l++;\n        else\n            r--;\n    }\n    LL st = 251;\n    for (int i = 0; i <= 2 * N; i += 2)\n    {\n        LL p = st;\n        for (int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if (0 <= k && k < N)\n            {\n                T[j][k] *= p;\n                if(p > 1300)\n                {\n                    DBG(j, k);\n                }\n                S.insert(T[j][k]);\n                p++;\n            }\n        }\n        if(i + 1 < N)\n            st--;\n        else\n            st++;\n    }\n    LL lim = 1e15;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(T[i][j] != 0) continue;\n            vector < LL > v;\n            if(i > 0)\n                v.push_back(T[i - 1][j]);\n            if(j > 0)\n                v.push_back(T[i][j - 1]);\n            if(i + 1 < N)\n                v.push_back(T[i + 1][j]);\n            if(j + 1 < N)\n                v.push_back(T[i][j + 1]);\n            LL can = 0;\n            if(sz(v) == 1)\n            {\n                can = v[0];\n            }\n            else if(sz(v) == 2)\n            {\n                can = nww(v[0], v[1]);\n            }\n            else if(sz(v) == 3)\n            {\n                can = nww(v[0], nww(v[1], v[2]));\n            }\n            else\n            {\n                can = nww(v[0], nww(v[1], nww(v[2], v[3])));\n            }\n            //DBG(can, sz(v));\n            LL cp = can;\n            while(can + 1 <= lim && S.find(can + 1) != S.end())\n            {\n                //DBG(can + 1);\n                can += cp;\n            }\n            //DBG(i, j, T[i][j]);\n            if(can + 1 > lim)\n            {\n                DBG(i, j, can + 1);\n                //for (auto u : v)\n                //    DBG(u);\n                //cout << \"KUPA\\n\";\n                return 0;\n            }\n            S.insert(can + 1);\n            T[i][j] = can + 1;\n        }\n    }\n    DBG(\"ok\");\n    /*\n    cout << \"{ \";\n    for(int i = 0; i < N; i++)\n    {\n        cout << \"{ \";\n        for(int j = 0; j < N; j++)\n        {\n            cout << T[i][j] << (j + 1 < N ? \", \" : \"\");\n        }\n        cout << \" }\" << (i + 1 < N ? \", \" : \"\");\n    }\n    cout << \" }\";\n    */\n    int n; cin >> n;\n    for(int  i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    vector<vector<ll>> a(500,vector<ll>(500,0));\n    vector<int> isPrime(2000,true);\n    vector<ll> primes;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            primes.push_back(i);\n            for(int j=2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n    set<ll> vs;\n    cerr<<primes.size()<<endl;\n    \n    for(int i=0;i<500;i++){\n        for(int j=i%2;j<500;j+=2){\n            a[i][j]=primes[i/2]*primes[j/2];\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    auto isRange=[](int x,int y){\n        return 0<=x && x<500 && 0<=y && y<500;\n    };\n    auto lcm=[](ll x,ll y){\n        return x*y/__gcd(x,y);\n    };\n    int dx[]={0,1,0,-1};\n    int dy[]={1,0,-1,0};\n\n    for(int i=0;i<500;i++){\n        for(int j=(i+1)%2;j<500;j+=2){\n            ll v=1;\n            for(int k=0;k<4;k++){\n                if(isRange(i+dx[k],j+dy[k])){\n                    v=lcm(v,a[i+dx[k]][j+dy[k]]);\n                }\n            }\n            a[i][j]=v;\n            int tmp=2;\n            while(vs.count(a[i][j])){\n                a[i][j]=a[i][j]/(tmp-1)*tmp;\n                tmp++;\n            }\n            vs.insert(a[i][j]);\n        }\n    }\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        for(int j=0;j+1<n;j++){\n            cout<<a[i][j]<<\" \";\n        }\n        cout<<a[i].back()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool prime[1000005];\nll ans[501][501];\n\nll gcd(ll a,ll b){\n\tif(b==0LL)return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\tll g=gcd(a,b);\n\ta/=g;\n\treturn a*b;\n}\n\nvoid solve(int n){\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn;\n\t}\n\tvector<ll> vec;\n\tmemset(prime,true,sizeof(prime));\n\tfor(ll i=2;i<1000005;i++){\n\t\tif(prime[i]){\n\t\t\tvec.push_back(i);\n\t\t\tif(vec.size()>=n*2)break;\n\t\t\tfor(ll j=2LL*i;j<1000005;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tdeque<ll> x,y;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(i%4==0){\n\t\t\tx.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==1){\n\t\t\ty.push_front(vec[i]);\n\t\t}\n\t\tif(i%4==2){\n\t\t\tx.push_back(vec[i]);\n\t\t}\n\t\tif(i%4==3){\n\t\t\ty.push_back(vec[i]);\n\t\t}\n\t}\n\t//printf(\"%d %d\\n\",(int)x.size(),(int)y.size());\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==0){\n\t\t\t\tint diff=(i-j)/2;\n\t\t\t\t//printf(\"%d %d\\n\",(i+j)/2,diff+n/2);\n\t\t\t\tans[i][j]=x[(i+j)/2];\n\t\t\t\tans[i][j]*=y[diff+n/2];\n\t\t\t}\n\t\t}\n\t}\n\tset<ll> s;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\tans[i][j]=1;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\tint ny=i+dy[k];\n\t\t\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<n){\n\t\t\t\t\t\tans[i][j]=lcm(ans[i][j],ans[ny][nx]);\n\t\t\t\t\t\tassert(ans[i][j]<1000000000000000LL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]++;\n\t\t\t\tassert(s.find(ans[i][j])==s.end());\n\t\t\t\ts.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tprintf(\"%lld%c\",ans[i][j],j+1==n?'\\n':' ');\n\t\t}\n\t}\n\treturn;\n} \n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tsolve(n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#include <cassert>\n#define SIZE 505\n#define MX 100005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll A[SIZE][SIZE];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nbool pr[MX];\nvector <int> all;\n\nvoid make()\n{\n\tfor(int i=2;i<MX;i++)\n\t{\n\t\tif(!pr[i])\n\t\t{\n\t\t\tall.push_back(i);\n\t\t\tfor(int j=2*i;j<MX;j+=i)\n\t\t\t{\n\t\t\t\tpr[j]=true;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tmake();\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"4 7\");\n\t\tputs(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tA[i][j]=1;\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int t=0;t<n;t++)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(abs(i+j-2*t)<=1)\n\t\t\t\t{\n\t\t\t\t\tA[i][j]*=all[sz];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsz++;\n\t}\n\tint L=0,R=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif((i+j)%2==0)\n\t\t\t{\n\t\t\t\tL=min(L,(i-j)/2);\n\t\t\t\tR=max(R,(i-j)/2);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int t=L;t<=R;t++)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(abs((i-j)-2*t)<=1)\n\t\t\t\t{\n\t\t\t\t\tA[i][j]*=all[sz];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsz++;\n\t}\n\t/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j+1<n;j++)\n\t\t{\n\t\t\tll a=A[i][j],b=A[i][j+1];\n\t\t\tif(a>b) swap(a,b);\n\t\t\tassert(b%a==0);\n\t\t}\n\t}\n\tfor(int i=0;i+1<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tll a=A[i][j],b=A[i+1][j];\n\t\t\tif(a>b) swap(a,b);\n\t\t\tassert(b%a==0);\n\t\t}\n\t}*/\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(j!=0) printf(\" \");\n\t\t\tprintf(\"%lld\",A[i][j]+(i+j)%2);\n\t\t\tassert(A[i][j]<=1000000000000000LL);\n\t\t}puts(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF  = (1LL<<60);\n\nll mul(ll a,ll b){\n  if( a > INF/b )return INF;\n  else return a*b;\n}\n\nll lcm(ll a,ll b){\n  \n  return mul(a/__gcd(a,b),b);\n}\n\nll gcd(ll a,ll b){\n  return __gcd(a,b);\n}\n\nint N;\nll t[500][500];\n\nbool isPrime(ll x){\n  if(x<2)return false;\n  for(ll i=2;i*i<=x;i++)\n    if(x%i==0)return false;\n\n  return true;\n}\n\nint main(){\n  vector<ll> primes;\n  for(int i=3;i<10000;i++){\n    if(isPrime(i)){\n      primes.push_back(i);\n    }\n    \n  }\n  cin>>N;\n  int copyn=N;\n  N=min(500,N+1);\n  \n  int cc=0;\n\n  for(int i=0;i<N;i+=2){\n    int py=0, px=i;\n    for(int j=0;;j++){\n      t[py][px]=primes[cc];\n      py++;\n      px++;\n      if(py>=N || px>=N)break;\n    }\n    cc++;\n  }\n\n  for(int i=2;i<N;i+=2){\n    int py=i, px=0;\n    for(int j=0;;j++){\n      t[py][px]=primes[cc];\n      py++;\n      px++;\n      if(py>=N || px>=N)break;\n    }\n    cc++;\n  }\n\n\n  for(int i=0;i<N;i+=2){\n    int py=0, px=i;\n    for(int j=0;;j++){\n      t[py][px]*=primes[cc];\n      py++;\n      px--;\n      if(py>=N || px<0)break;\n    }\n    cc++;\n  }\n\n  for(int i= (N%2==1?2:1) ;i<N;i+=2){\n    int py=i, px=N-1;\n    for(int j=0;;j++){\n\n      t[py][px]*=primes[cc];\n      py++;\n      px--;\n      if(py>=N || px<0)break;\n    }\n    cc++;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(t[i][j]!=0)continue;\n      t[i][j]=1;\n      if(i>0)t[i][j]=lcm(t[i][j],t[i-1][j]);\n      if(j>0)t[i][j]=lcm(t[i][j],t[i][j-1]);\n      if(i+1<N)t[i][j]=lcm(t[i][j],t[i+1][j]);\n      if(j+1<N)t[i][j]=lcm(t[i][j],t[i][j+1]);\n      t[i][j]++;\n    }\n  }\n\n  N=copyn;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(j)cout<<' ';\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n//    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    if(N>=3){\n/*        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }*/\n        vll prime;\n        FOR(aa,1,(N*N)/2){\n            prime.pb(aa*2);\n        }\n//        ll uf=2;\n        ll uf=0;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==1){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==0){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n/*                    a[i][j]=lcm(a[i-1][j],a[i+1][j]);\n                    a[i][j]=lcm(a[i][j],a[i][j-1]);\n                    a[i][j]=lcm(a[i][j],a[i][j+1]);\n                    a[i][j]++;*/\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30,maxn=2000005;\nint i,j,k,n,v[100000005];\nint f[maxn],prime[maxn],tot,e[100005];\nlong long ans[505][505],mx;\nmap<long long,int> p;\nvoid shai()\n{\n    tot=0;\n    for(int i=2;i<maxn;i++)\n    {\n        if(!f[i])\n            prime[tot++]=i;\n        for(int j=0;j<tot&&prime[j]*i<maxn;j++)\n        {\n            f[i*prime[j]]=1;\n            if(i%prime[j]==0)\n            {\n                break;\n            }\n        }\n    }\n}\nlong long gcd(long long a,long long b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nlong long lcm(long long a,long long b)\n{\n\tif(a==0)\n\t\treturn b;\n\tif(b==0)\n\t\treturn a;\n\treturn a/gcd(a,b)*b;\n}\nint main()\n{\n\tshai();\n\tscanf(\"%d\",&n);\n\tint m=0;\n\tfor(i=1;i<=499;i+=2)\n\t\te[i]=++m;\n\tfor(i=2;i<=499;i+=2)\n\t\te[i]=++m;\n\tfor(i=500;i>=1;--i)\n\t\tfor(j=500;j>=1;--j)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\tfor(k=prime[e[(i+j)/2]-1];v[k];k+=prime[e[(i+j)/2]-1]);\n\t\t\t\tans[i][j]=k;\n\t\t\t\tv[k]=1;\n\t\t\t\tp[k]=1;\n\t\t\t}\n\tfor(i=1;i<=500;++i)\n\t\tfor(j=1;j<=500;++j)\n\t\t\tif(ans[i][j]==0)\n\t\t\t{\n\t\t\t\tlong long s=lcm(lcm(ans[i-1][j],ans[i][j-1]),lcm(ans[i+1][j],ans[i][j+1]));\n\t\t\t\tans[i][j]=s+1;\n\t\t\t\twhile(p[ans[i][j]])\n\t\t\t\t\tans[i][j]+=s;\n\t\t\t\tp[ans[i][j]]=1;\n\t\t\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t\t//mx=max(mx,ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t//cout<<mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"complex\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\n\nlong long int N, M, K, H, W, L, R;\n\nlist<int> Prime(int num) {\n\tlist<int>P;\n\tfor (int i = 5; i <= num; i += 6) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t\tflag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i + 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((i + 2) % j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i + 2);\n\t}\n\tP.push_front(3);\n\tP.push_front(2);\n\treturn P;\n}\n\ninline long long int gcd(long long int a, long long int b) {\n\tif (a < b)a ^= b ^= a ^= b;\n\twhile (b) {\n\t\ta %= b;\n\t\ta ^= b ^= a ^= b;\n\t}\n\treturn a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tauto P = Prime(10000);\n\tlist<int>p;\n\tP.pop_front();\n\twhile (p.size() < N + 1) {\n\t\tp.push_back(P.front());\n\t\tP.pop_front();\n\t}\n\tvector<int>tate((N+1)/2);\n\tvector<int>yoko((N+1)/2);\n\tfor (int i = 0; i < (N + 1) / 2; i++) {\n\t\tif (i % 2) {\n\t\t\ttate[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\ttate[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tfor (int i = 0; i < N/2; i++) {\n\t\tif (i % 2) {\n\t\t\tyoko[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\tyoko[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tvector<vector<long long int>>v(N, vector<long long int>(N));\n\tlong long int mx = 0;\n\tmap<int, int>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i^j) & 1) {\n\t\t\t\tv[i][j] = tate[i / 2] * yoko[j / 2] * 2;\n\t\t\t\tif (m[v[i][j]])v[i][j] *= 2;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dir[] = { 0,1,0,-1,0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (!v[i][j]) {\n\t\t\t\tv[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = i + dir[k];\n\t\t\t\t\tint nx = j + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)continue;\n\t\t\t\t\tv[i][j] = v[i][j] / gcd(v[i][j], v[ny][nx])*v[ny][nx];\n\t\t\t\t}\n\t\t\t\tv[i][j]++;\n\t\t\t\tif (m[v[i][j]])v[i][j] = v[i][j] * 2 - 1;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j)cout << \" \";\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nvoid _main(istream &inp){\n\tint n;\n\tinp >> n;\n\tconst int M = 1000;\n\tvvl ret(n, vl(n));\n//\tdebug(n);\n//\tdebug(ret);\n\tset<ll> u;\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==0){\n\t\t\tll tt = (500+x)*(500+y);\n\t\t\tll t = tt;\n\t\t\twhile(exist(u,t))t+=tt;\n\t\t\tu.insert(t);\n\t\t\tret[x][y]=M+rnd.get()%M;\n\t\t}\n\t}\n\tll maxi = 0;\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==1){\n\t\t\tll z = 1;\n\t\t\tif(x>0)z*=ret[x-1][y];\n\t\t\tif(y>0)z*=ret[x][y-1];\n\t\t\tif(x+1<n)z*=ret[x+1][y];\n\t\t\tif(y+1<n)z*=ret[x][y+1];\n\t\t\tll val = z+1;\n\t\t\twhile(exist(u,val))val+=z;\n\t\t\tu.insert(val);\n\t\t\tmaxi = max(maxi, val);\n\t\t\tret[x][y]=val;\n\t\t}\n\t}\n\tdebug(maxi);\n\tassert(maxi<1e15);\n\t//debug(n);\n\t//debug(ret);\n\trep(x,n) rep(y,n-1){\n\t\tll a = ret[x][y];\n\t\tll b = ret[x][y+1];\n\t\tassert(max(a,b)%min(a,b)==1);\n\t}\n\trep(x,n-1) rep(y,n){\n\t\tll a = ret[x][y];\n\t\tll b = ret[x+1][y];\n\t\tassert(max(a,b)%min(a,b)==1);\n\t}\n\trep(x,n){\n\t\trep(y,n){\n\t\t\tcout << ret[x][y];\n\t\t\tif(y!=n-1)cout << \" \";\n\t\t\telse cout << endl;\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = min(min(n - i + 1, n - j + 1), min(i, j));\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\tint cnt = 0;\n\t\t\t\twhile (used.count(ans[i][j])) {\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 101000;\nint g[N],pri[N],tot;\nll f[1010][1010],p1[1010],p2[1010];\nvoid init(){\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!g[i]){pri[++tot]=i;g[i]=i;}\n\t\tfor(int j=1;pri[j]*i<=10000;j++){\n\t\t\tg[pri[j]*i]=pri[j];\n\t\t\tif(pri[j]==g[i]) break; \n\t\t}\n\t}\n\tint k1=0,k2=0;\n\tfor(int i=1;i<=1004;i++)\n\t\tif(i&1) p1[++k1]=pri[i];\n\t\telse p2[++k2]=pri[i];\n\tll p[1010],now=0;\n\tmemcpy(p,p1,sizeof(p1));\n\tfor(int i=1;i<=k1;i+=2)\n\t\tp1[i]=p[k1-now],p1[i+1]=p[++now];\n\tmemcpy(p,p2,sizeof(p));now=0;\n\tfor(int i=1;i<=k2;i+=2)\n\t\tp2[i]=p[k2-now],p2[i]=p[++now];\n}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tif(n==2){\n\t\tputs(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i+j&1){\n\t\t\t\tint k=i+j>>1;\n\t\t\t\tf[i][j]=p1[k];\n\t\t\t\tk=i+(n-j+1)>>1;\n\t\t\t\tf[i][j]*=p2[k];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(~(i+j)&1){\n\t\t\t\tf[i][j]=lcm(f[i][j-1],lcm(f[i][j+1],lcm(f[i-1][j],f[i+1][j])))+1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<f[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 520\n#define maxm 2020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nint prime[maxm],cnt,tag[maxm];\nint n,tag1[maxn][maxn],tag2[maxn][maxn],tot;\nll a[maxn][maxn];\n\nvoid init(){\n\trep(i,2,2000){\n\t\tif ( !tag[i] ) prime[++cnt] = i;\n\t\trep(j,1,cnt){\n\t\t\tif ( prime[j] * i > 2000 ) break;\n\t\t\ttag[prime[j] * i] = 1;\n\t\t\tif ( i % prime[j] == 0 ) break;\n\t\t}\n\t}\n}\nll gcd(ll a,ll b){\n\tif ( !b ) return a;\n\treturn gcd(b,a % b);\n}\ninline ll lcm(ll a,ll b){\n\tll d = gcd(a,b);\n\treturn a * b / d;\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1 ) ){\n\t\t\t\tif ( i > 1 && j > 1 && tag1[i - 1][j - 1] ) tag1[i][j] = tag1[i - 1][j - 1];\n\t\t\t\tif ( i < n && j < n && tag1[i + 1][j + 1] ) tag1[i][j] = tag1[i + 1][j + 1];\n\t\t\t\tif ( !tag1[i][j] ) tag1[i][j] = ++tot; \n\t\t\t\tif ( i > 1 && j < n && tag2[i - 1][j + 1] ) tag2[i][j] = tag2[i - 1][j + 1];\n\t\t\t\tif ( i < n && j > 1 && tag2[i + 1][j - 1] ) tag2[i][j] = tag2[i + 1][j - 1];\n\t\t\t\tif ( !tag2[i][j] ) tag2[i][j] = ++tot;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( ((i + j) & 1) ){\n\t\t\t\ta[i][j] = prime[tag1[i][j]] * prime[tag2[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tif ( !a[i][j] ){\n\t\t\t\tll cur = 1;\n\t\t\t\tif ( i > 1 ) cur = lcm(cur,a[i - 1][j]);\n\t\t\t\tif ( i < n ) cur = lcm(cur,a[i + 1][j]);\n\t\t\t\tif ( j > 1 ) cur = lcm(cur,a[i][j - 1]);\n\t\t\t\tif ( j < n ) cur = lcm(cur,a[i][j + 1]);\n\t\t\t\ta[i][j] = cur + 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n){\n\t\t\tcout<<a[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define mcpy(des,sor) memcpy(des,sor,sizeof(sor))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll mod = 1e9+7;\nconst db eps = 1e-8;\n\nchar io[1<<15],*is=io,*ie=io+1;\n#define rd if(++is==ie)ie=(is=io)+fread(io,1,sizeof(io),stdin)\ntemplate<class T>\ninline bool Cin(T &a){\n\ta=0;bool s=0;\n\tif(is==ie)return 0;\n\tdo{rd;if(*is=='-')s=1;}while(!isdigit(*is)&&is!=ie);\n\tif(is==ie)return 0;\n\tdo{(a*=10)+=*is&15;rd;}while(isdigit(*is)&&is!=ie);\n\tif(s)a=-a;;return 1;}\n\ninline int Gets(char a[]){\n\tint p=0;\n\tif(is==ie)return 0;\n\tdo rd; while(!isgraph(*is)&&is!=ie);\n\tif(is==ie)return 0;\n\tdo {a[p++]=*is;rd;}while(isgraph(*is)&&is!=ie);\n\ta[p]=0;return p;}\n\n#define maxn 10005\n\nvector<int> p;\nbool isp[maxn];\nll a[502][502];\n\nll lcm(ll x,ll y){return x/__gcd(x,y)*y;}\n\nint main()\n{\n\tint n;\n\tCin(n);\n\tif(n==2)return !printf(\"4 7\\n23 10\\n\");\n\tmst(isp,0);p.clear();\n\tfor(int i=2;sz(p)<2000;++i)\n\t{\n\t\tif(!isp[i])p.pb(i);\n\t\tfor(int j=0;j<sz(p)&&p[j]*i<maxn;++j)\n\t\t{\n\t\t\tisp[p[j]*i]=1;\n\t\t\tif(i%p[j]==0)break;\n\t\t}\n\t}\n\trepb(i,0,n+1)a[0][i]=a[n+1][i]=a[i][0]=a[i][n+1]=1;\n\n\trepb(i,1,n)repb(j,1,n)if((i+j)%2==0)\n\t\ta[i][j]=p[(i+j)/2-1]*p[n+(i+n+1-j)/2-1];\n\t\n\trepb(i,1,n)repb(j,1,n)if((i+j)%2==1)\n\t\ta[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\t\n\trepb(i,1,n)repb(j,1,n)printf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(MAX_N);\n    for (int i = 0; i < MAX_N; i++) {\n        ans[i].resize(MAX_N);\n    }\n\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = (i % 2); j < MAX_N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + MAX_N - 1) / 2;\n            ans[i][j] =\n                primes[(p % 2 == 0) ? (p / 2) : (MAX_N - 1 - p / 2)] *\n                primes[(q % 2 == 0) ? (q / 2) : (MAX_N - 1 - q / 2) + MAX_N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < MAX_N; i++) {\n        for (int j = 1 - (i % 2); j < MAX_N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < MAX_N && 0 <= j + dj[k] &&\n                    j + dj[k] < MAX_N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                }\n            }\n            ans[i][j]++;\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << ans[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 505;\nconst int P = 8005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, pr[P], pcnt, vis[P];\nLL a[N][N], mx;\n//set<LL> S;\n\nLL gcd(LL x, LL y) {\n\treturn (!y)? x : gcd(y, x % y);\n}\n\ninline LL lcm(LL x, LL y) {\n\tif (!x || !y) return x + y;\n\treturn x / gcd(x, y) * y;\n}\n\nvoid init() {\n\tread(n);\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 2; i <= 8000; ++i) {\n\t\tif (!vis[i]) {\n\t\t\tpr[++pcnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= pcnt && i * pr[j] <= 8000; ++j) {\n\t\t\tvis[i * pr[j]] = 1;\n\t\t\tif (i % pr[j]) continue;\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (!((i + j) & 1)) {\n\t\t\t\ta[i][j] = pr[(i + j) / 2] * pr[(n - i + 1 + j) / 2 + n / 2];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i + j) & 1) {\n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j - 1], a[i][j + 1])) + 1;\n\t\t\t}\n\t\t\tprintf(\"%lld \", a[i][j]);\n/*mx = max(mx, a[i][j]);\nif (S.find(a[i][j]) != S.end()) {\n\tprintf(\"error\\n\");\n}\nS.insert(a[i][j]);*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//printf(\"%lld\\n\", mx);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nll mat[502][502];\nint np[1000001],pr[1000001],p=0,pp=0;\nint n;\nll gcd(ll a,ll b){\n\tif(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tnp[1]=1;\n\tfor(int i=0;i<=500;i++){\n\t\tfor(int j=0;j<=500;j++){\n\t\t\tmat[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=1000000;i++){\n\t\tfor(int j=i*2;j<=1000000;j+=i){\n\t\t\tnp[j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(!np[i]) pr[++p]=i;\n\t}\n\t//printf(\"%d\\n\",p);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)==(j&1)) mat[i][j]=1ll*pr[++pp];\n\t\t\t//printf(\"%d %d %d\\n\",i,j,pr[pp]);\n\t\t\tif((i&1)==(j&1)){\n\t\t\t\tmat[i][j-1]=lcm(mat[i][j],mat[i][j-1]);\n\t\t\t\tmat[i][j+1]=lcm(mat[i][j],mat[i][j+1]);\n\t\t\t\tmat[i-1][j]=lcm(mat[i][j],mat[i-1][j]);\n\t\t\t\tmat[i+1][j]=lcm(mat[i][j],mat[i+1][j]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i&1)!=(j&1)) mat[i][j]++;\n\t\t\tprintf(\"%lld \",mat[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define ll long long\nusing namespace std;\nconst int N=50005;\nint n,p[N],vis[N],cnt,now; ll a[505][505],v1[N],v2[N];\nll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nvoid init(int n){\n\trep (i,2,n){\n\t\tif (!vis[i]) p[++cnt]=i;\n\t\tfor (int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0) break;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2) return puts(\"4 7\\n23 10\"),0;\n\tinit(10000);\n\trep (i,1,n) a[i][0]=a[i][n+1]=a[0][i]=a[n+1][i]=1;\n\tnow=1;\n\tfor (int i=1+1;i<=n+n;i+=2) v1[i]=p[now++];\n\tfor (int i=(n&1)?1-n:2-n;i<=n-1;i+=2) v2[i+n]=p[now++];\n\trep (i,1,n) rep (j,1,n) if (!((i+j)&1)) a[i][j]=v1[i+j]*v2[i-j+n];\n\trep (i,1,n) rep (j,1,n) if ((i+j)&1) a[i][j]=lcm(lcm(a[i][j-1],a[i][j+1]),lcm(a[i-1][j],a[i+1][j]))+1;\n\trep (i,1,n){rep (j,1,n) printf(\"%lld \",a[i][j]); puts(\"\");}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<tuple>\n#define rep(index,num) for(int index=0;index<num;index++)\n#define rep1(index,num) for(int index=1;index<=num;index++)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-15\n#define mp(a1,a2) make_pair(a1,a2)\n#define YMAX 250001\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=1e+18+1;\nint INF=1e+9+1;\nbool arr[10001];\nint Nmax=10001;\nvint sosu;\nvoid Eratosthenes(){\n\tfor(int i = 0; i < Nmax; i++){\n\t\tarr[i] = true;\n\t}\n\tarr[0]=false; arr[1]=false;\n\tfor(int i = 2; i < sqrt(Nmax); i++){\n\t\tif(arr[i]){\n\t\t\tfor(int j = 0; i * (j + 2) < Nmax; j++){\n\t\t\t\tarr[i *(j + 2)] = false;\n\t\t\t}\n\t\t}\n\t}\n\trep1(i,Nmax){\n\t\tif(arr[i]) sosu.push_back(i);\n\t}\n}\nll gcd(ll x,ll y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\nint main(){\n\tEratosthenes();\n\tint N;\n\tll a[502][502];\n\tll ichimatsu1[501][501],ichimatsu2[501][501];\n\tscan(N);\n\tint NMAX=500;\n\tint sosucount=0;\n\tfor(int kyori=0;kyori<=NMAX*2-2;kyori+=2){\n\t\tfor(int j=0;j<=NMAX-1;j++){\n\t\t\tint i=kyori-j;\n\t\t\tif(i<0||i>NMAX-1) continue;\n\t\t\t//printf(\"kyori:%d i:%d j:%d sosu:%d\\n\",kyori,i,j,sosu[sosucount]);\n\t\t\tichimatsu1[i][j]=sosu[sosucount];\n\t\t}\n\t\tsosucount++;\n\t}\n\tfor(int kyori=NMAX-1;kyori<=NMAX*2-2&&kyori>=0;kyori+=(kyori<=NMAX-1 ? 2*(NMAX-1-kyori)+2 : 2*(NMAX-1-kyori))){\n\t\tfor(int j=NMAX-1;j>=0;j--){\n\t\t\tint i=j-kyori+NMAX-1;\n\t\t\tif(i<0||i>NMAX-1) continue;\n\t\t\tichimatsu2[i][j]=sosu[sosucount];\n\t\t}\n\t\tsosucount++;\n\t}\n\t/*rep(i,N){\n\t\trep(j,N){\n\t\t\tif((i+j)%2==0) printf(\"%lld \",ichimatsu1[i][j]);\n\t\t\telse printf(\"-- \");\n\t\t}\n\t\tkaigyo;\n\t}\n\tkaigyo;\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tif((i+j)%2==0) printf(\"%lld \",ichimatsu2[i][j]);\n\t\t\telse printf(\"-- \");\n\t\t}\n\t\tkaigyo;\n\t}*/\n\trep(i,NMAX){\n\t\trep(j,NMAX){\n\t\t\tif((i+j)%2==0) a[i+1][j+1]=ichimatsu1[i][j]*ichimatsu2[i][j];\n\t\t}\n\t}\n\trep(i,NMAX+2){\n\t\ta[i][0]=1;\n\t\ta[i][NMAX+1]=1;\n\t}\n\trep(j,NMAX+2){\n\t\ta[0][j]=1;\n\t\ta[NMAX+1][j]=1;\n\t}\n\trep(i,NMAX){\n\t\trep(j,NMAX){\n\t\t\tif((i+j)%2==1) a[i+1][j+1]=lcm(lcm(a[i][j+1],a[i+2][j+1]),lcm(a[i+1][j],a[i+1][j+2]))+1;\n\t\t}\n\t}\n\trep1(i,N){\n\t\trep1(j,N){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tkaigyo;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\n\n#define int long long \n\nconst int LIM = 2e6 + 7;\nconst int N = 500;\n\nint pr[LIM];\nvector<int> primes;\n\n\nvoid init() {\n    fill(pr, pr + LIM, 1);\n    for (int i = 2; i < LIM; i++) {\n        if (pr[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j < LIM; j += i) {\n                pr[j] = 0;\n            }\n        }\n    }\n}\n\nint ans[N][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            ans[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) & 1) {\n                ans[i][j] *= primes[i + j];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i - j) % 2 != 0) {\n                ans[i][j] *= primes[(i - j) + N];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i + j) % 2 == 0) {\n                assert(ans[i][j] == 1);\n                if (i > 0) {\n                    ans[i][j] = __lcm(ans[i][j], ans[i - 1][j]);\n                }\n                if (j > 0) {\n                    ans[i][j] = __lcm(ans[i][j], ans[i][j - 1]);\n                }\n                if (i + 1 < N) {\n                    ans[i][j] = __lcm(ans[i][j], ans[i + 1][j]);\n                }\n                if (j + 1 < N) {\n                    ans[i][j] = __lcm(ans[i][j], ans[i][j + 1]);\n                }\n                // cerr << ans[i][j] << '\\n';\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << ans[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n\tc=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\nll a[555][555];\n\n// tot = sieve(n)\n// prime[1..tot] = {1<= prime <=n}\n// bo[i]==1, i is composite ; bo[i]==0, i==1 or prime\n\n//basic\n\nconst int SIEVE_MAXN=100000+5;\nint prime[SIEVE_MAXN>100000?SIEVE_MAXN/10:10000];bool bo[SIEVE_MAXN];\nint sieve(int n){\n\tint tot=0;\n\tfor (int i=2;i<=n;i++){\n\t\tif (!bo[i])prime[++tot]=i;\n\t\tfor (int j=1;j<=tot && prime[j]*i<=n;j++){\n\t\t\tbo[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\n\n/////\n\nmap<int,int> ma,mb;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nvoid gao(int n) {\n\t/*rep(i,1,3001) {\n\t\tprime[i]=3001+i;\n\t}*/\n\tint to=1;\n\tfor (int i=-498;i<=1000;i+=2) {\n\t\tma[i]=mb[i]=prime[++to];\n\t\t//mb[i]=prime[++to];\n\t}\n\tset<ll>se;\n\trep(i,1,n+1)\n\t\trep(j,1,n+1) {\n\t\t\tif((i+j)%2==0) {\n\t\t\t\ta[i][j] = 1ll*ma[i-j] *mb[i+j];\n\t\t\t\tif(se.count(a[i][j])>0) {\n\t\t\t\t\ta[i][j]*=2;\n\t\t\t\t}\n\t\t\t\tassert(se.count(a[i][j])==0);\n\t\t\t\tse.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\trep(i,1,n+1)\n\t\trep(j,1,n+1) {\n\t\t\tif((i+j)%2!=0) {\n\t\t\t\tll lm = 1;\n\t\t\t\trep(k,0,4){\n\t\t\t\t\tint ii=i+dx[k],jj=j+dy[k];\n\t\t\t\t\tif(ii<1 || jj<1 || ii>n || jj>n)continue;\n\t\t\t\t\tll b = a[ii][jj];\n\t\t\t\t\tlm = lm/gcd(lm,b)*b;\n\t\t\t\t}\n\t\t\t\tll fa=lm+1;\n\t\t\t\twhile(se.count(fa)>0)fa+=lm;\n\t\t\t\ta[i][j]=fa;\n\t\t\t\tse.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\n\tll ma = 0;\n\trep(i,1,n+1)rep(j,1,n+1)upmax(ma,a[i][j]);\n\t//assert(ma<1e15);\n\t//cout<<double(ma)<<endl;\n\n\t//rep(i,1,n+1)rep(j,1,n+1)se.insert(a[i][j]);\n\t//cout<<se.size()<<endl;\n\n\n\n}\nint main()\n{\n\tsieve(100000);\n\tgao(500);\n\tint n;\n\tgn(n);\n\trep(i,1,n+1) {\n\n\t\trep(j,1,n+1) {\n\t\t\tprintf(lld,a[i][j]);\n\t\t\tif(j==n)printf(\"\\n\");\n\t\t\telse printf(\" \");\n\t\t}\n\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= 100000; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x / gcd(x, y) * y); }\n//这个地方需要先除 gcd，在乘 y，否则 x * y会爆 long long \nint PA[N], PB[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tPA[i] = pri[i];\n\t\tPB[i] = pri[i + n];\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = 1ll * PA[(i + j) / 2] * PB[(i - j) / 2 + (n + 1) / 2];\n\t\t\t\tans[i][j] = tmp;\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=500+5;\nint n;\nLL a[maxn][maxn];\nbool isp[100005];\nvector<int>prime;\nvoid sieve(int ps){\n\tmemset(isp,1,sizeof(isp));isp[1]=0;\n\tfor(int i=2;prime.size()<=ps;i++){\n\t\tif(isp[i])prime.push_back(i);\n\t\tfor(int k=0;k<prime.size()&&i*prime[k]<=100000;k++){\n\t\t\tisp[i*prime[k]]=0;\n\t\t\tif(i%prime[k]==0)break;\n\t\t}\n\t}\n}\nLL lcm(LL x,LL y){return x*y/__gcd(x,y);}\nint main(){\n\tsieve(1200);\n\tscanf(\"%d\",&n);\n\tint nxt=n+(n-1)/2+1;\n\tfor(int i=1;i<=n;i++)a[0][i]=a[i][0]=1;\n\tfor(int i=1;i<=n+1;i++)\n\tfor(int j=1+!(i&1);j<=n+1;j+=2)\n\ta[i][j]=prime[(i+j)/2-1]*prime[(i-j)/2+nxt];\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1+(i&1);j<=n;j+=2)\n\ta[i][j]=lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%d \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int MAX = 10010;      // 素数判定する最大の数\nbool IsPrime[MAX];\nvector<int> Era(int n = MAX) {\n    vector<int> res;\n    IsPrime[0] = false; IsPrime[1] = false;\n    for (int i = 2; i < n; ++i) IsPrime[i] = true;\n    for (int i = 2; i < n; ++i) {\n        if (IsPrime[i]) {\n            res.push_back(i);\n            for (int j = i*2; j < n; j += i) IsPrime[j] = false;\n        }\n    }\n    return res;\n}\n\nlong long GCD(long long a, long long b) {\n    if (b == 0) return a;\n    else return GCD(b, a % b);\n}\n\nlong long LCM(long long a, long long b) {\n    long long g = GCD(a, b);\n    return a / g * b;\n}\n\nint main() {\n    int N; cin >> N;\n    vector<vector<long long> > res(N, vector<long long>(N, 0));\n    vector<int> primes = Era();\n    for (int wa = 0; wa <= N*2; wa += 2) {\n        for (int sa = -N/2*2; sa <= N/2*2; sa += 2) {\n            if ((wa + sa) & 1) continue;\n            int i = (wa + sa) / 2;\n            int j = (wa - sa) / 2;\n            if (i < 0 || i >= N || j < 0 || j >= N) continue;\n            if ((i + j) & 1) continue;\n            res[i][j] = primes[wa/2] * primes[(sa + N/2*2)/2 + N];\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if ((i + j) % 2 == 0) continue;\n            long long L = 1;\n            for (int k = 0; k < 4; ++k) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni < 0 || ni >= N || nj < 0 || nj >= N) continue;\n                L = LCM(L, res[ni][nj]);\n            }\n            res[i][j] = L + 1;\n        }\n    }\n    if (N == 2) res[0][1] = res[1][0]*2-1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cout << res[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll mp[555][555];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nvector<ll> v;\n\nll gcd(ll a,ll b){\n\tif(a < b)swap(a,b);\n\treturn b == 0 ? a : gcd(b,a%b);\n}\n\nvoid prime(){\n\tvector<bool> pri(100000);\n\tvector<ll> tmp;\n\tint cou = 0;\n\tfor(int i = 2;;i++){\n\t\tif(!pri[i]){\n\t\t\ttmp.PB(i);\n\t\t\tfor(int j = i;j < 100000;j+=i)pri[j] = true;\n\t\t\tcou++;\n\t\t}\n\t\tif(cou == 1010)break;\n\t}\n\tfor(int i = 0,j = tmp.size() - 1;i < j;i++,j--){\n\t\tv.PB(tmp[i]);\n\t\tv.PB(tmp[j]);\n\t}\n}\n\nvoid seica(){\n\tREP(i,555)REP(j,555)mp[i][j] = 1;\n\tREP(i,500){\n\t\tREP(j,500){\n\t\t\tif((i+j) % 2 == 0){\n\t\t\t\tmp[i][j] *= v[(i+j)/2];\n\t\t\t}\n\t\t\tif((i+499-j) % 2 == 1){\n\t\t\t\tmp[i][j] *= v[501+(i+499-j)/2];\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i,500){\n\t\tREP(j,500){\n\t\t\tif((i + j) % 2){\n\t\t\t\tll now = 1;\n\t\t\t\tREP(k,4){\n\t\t\t\t\tif(i+dy[k] >= 0 && i+dy[k] < 500 && j+dx[k] >= 0 && j+dx[k] < 500){\n\t\t\t\t\t\tll hoge = gcd(now, mp[i+dy[k]][j+dx[k]]);\n\t\t\t\t\t\tnow *= mp[i+dy[k]][j+dx[k]] / hoge;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmp[i][j] = now + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;cin >> n;\n\n\tprime();\n\tcout << v.size() << endl;\n\tseica();\n\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tcout << mp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nvector<int> makePrimes(int n) { // [2,n]\n    vector<int> res, pr(n + 1, 1);\n    pr[0] = pr[1] = 0;\n    rep(p, 2, sqrt(n) + 2) if (pr[p]) for (int x = p * 2; x <= n; x += p) pr[x] = 0;\n    rep(p, 2, n + 1) if (pr[p]) res.push_back(p);\n    return res;\n}\nll gcd(ll a, ll b) { return a ? gcd(b%a, a) : b; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N;\nll ans[505][505];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    auto vp = makePrimes(51010);\n    cin >> N;\n\n    if (N == 2) {\n        printf(\"4 7\\n23 10\\n\");\n        return;\n    }\n\n    rep(y, 0, N) rep(x, 0, N) if ((x + y) % 2 == 0) {\n        int u = (x + y) / 2;\n        int v = (x - y) / 2 + N / 2 + 1;\n\n        ans[y][x] = 1LL * vp[u] * vp[1010 - v];\n    }\n\n    rep(y, 0, N) rep(x, 0, N) if ((x + y) % 2 == 1) {\n        ll c = 1;\n        if (0 <= y - 1) c = lcm(c, ans[y - 1][x]);\n        if (y + 1 < N) c = lcm(c, ans[y + 1][x]);\n        if (0 <= x - 1) c = lcm(c, ans[y][x - 1]);\n        if (x + 1 < N) c = lcm(c, ans[y][x + 1]);\n        ans[y][x] = c + 1;\n    }\n\n    rep(y, 0, N) {\n        rep(x, 0, N) {\n            if (x) printf(\" \");\n            printf(\"%lld\", ans[y][x]);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst long long lim = 1000000000000000;\nconst int sublim = (int)sqrt(lim) / 3;\nconst vector<int> dx = { 1, 0, -1, 0 };\nconst vector<int> dy = { 0, 1, 0, -1 };\nbool valid(vector<int> v1, vector<int> v2) {\n\treturn (v1[0] >= v2[0] && v1[1] >= v2[1] && v1[2] >= v2[2] && v1[3] >= v2[3]) || (v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2] && v1[3] <= v2[3]);\n}\nvector<int> solve(int a, int b, int c, int d) {\n\tvector<vector<int> > v;\n\tint basemul = 1;\n\tint ret = 0;\n\tfor (int i = 0; basemul <= sublim; ++i) {\n\t\tint bmul = basemul;\n\t\tfor (int j = 0; bmul <= sublim; ++j) {\n\t\t\tint mul = bmul;\n\t\t\tfor (int k = 0; mul <= sublim; ++k) {\n\t\t\t\tint smul = mul;\n\t\t\t\tfor (int l = 0; smul <= sublim; ++l) {\n\t\t\t\t\t++ret;\n\t\t\t\t\tsmul *= d;\n\t\t\t\t\tv.push_back({ i, j, k, l });\n\t\t\t\t}\n\t\t\t\tmul *= c;\n\t\t\t}\n\t\t\tbmul *= b;\n\t\t}\n\t\tbasemul *= a;\n\t}\n\tsort(v.begin(), v.end());\n\tvector<bool> used(v.size());\n\tint cur = v.size() - 1;\n\tvector<vector<int> > seq;\n\twhile (true) {\n\t\tused[cur] = true;\n\t\tseq.push_back(v[cur]);\n\t\tint ncur = -1;\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tif (!used[i] && valid(v[cur], v[i])) {\n\t\t\t\tncur = i;\n\t\t\t}\n\t\t}\n\t\tif (ncur == -1) break;\n\t\tcur = ncur;\n\t}\n\tvector<int> ans;\n\tfor (vector<int> i : seq) {\n\t\tint mul = 1;\n\t\tfor (int j = 0; j < i[0]; ++j) mul *= a;\n\t\tfor (int j = 0; j < i[1]; ++j) mul *= b;\n\t\tfor (int j = 0; j < i[2]; ++j) mul *= c;\n\t\tfor (int j = 0; j < i[3]; ++j) mul *= d;\n\t\tans.push_back(mul);\n\t}\n\treturn ans;\n}\nlong long gcd(long long x, long long y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nlong long lcm(long long x, long long y) {\n\treturn x / gcd(x, y) * y;\n}\nint main() {\n\tvector<int> c1 = solve(2, 7, 17, 19);\n\tvector<int> c2 = solve(3, 5, 11, 13);\n\tint n;\n\tcin >> n;\n\tset<long long> s;\n\tvector<vector<long long> > v(n, vector<long long>(n));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tint a = i + j, b = i - j + ((n - 1) / 2) * 2;\n\t\t\tif (a % 2 == 0) {\n\t\t\t\tv[i][j] = 1LL * c1[a / 2] * c2[b / 2];\n\t\t\t\ts.insert(v[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif ((i + j) % 2 == 1) {\n\t\t\t\tlong long delta = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\t\tif (0 <= tx && tx < n && 0 <= ty && ty < n) {\n\t\t\t\t\t\tdelta = lcm(delta, v[tx][ty]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[i][j] = delta + 1;\n\t\t\t\twhile (s.count(v[i][j])) v[i][j] += delta;\n\t\t\t\ts.insert(v[i][j]);\n\t\t\t\tassert(v[i][j] <= lim);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j) cout << ' ';\n\t\t\tcout << v[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <stdint.h>\n#include <cassert>\n\nconst int L=100000;\nbool isprime[L];\n\nint64_t as[1005];\nint64_t bs[1005];\nint64_t mat[1005][1005];\n\nstd::set<int64_t> used;\n\nint main(){\n  int N;\n  scanf(\"%d\",&N);\n  for(int i=2;i<L;i++){\n    isprime[i]=true;\n  }\n  int a_max=0,b_max=0;\n  for(int i=2;i<L;i++){\n    if(isprime[i]){\n      for(int k=i*2;k<L;k+=i){\n\tisprime[k]=false;\n      }\n      if(a_max<=N){\n\tas[a_max++]=i;\n      }else if(b_max<=N){\n\tbs[b_max++]=i;\n      }\n    }\n  }\n  assert(a_max>N&&b_max>N);\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if((i+j)%2==0){\n\tmat[i][j]=as[(i+j)/2]*bs[(j-i+N)/2];\n\tused.insert(mat[i][j]);\n      }else{\n\tint64_t base=as[(i+j+1)/2]*as[(i+j-1)/2]*\n\t  bs[(j-i+1+N)/2]*bs[(j-i-1+N)/2];\n\tint64_t k=1;\n\twhile(used.count(base*k+1)){\n\t  k++;\n\t}\n\tmat[i][j]=base*k+1;\n\tused.insert(mat[i][j]);\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(j) printf(\" \");\n      printf(\"%ld\",mat[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nconst int maxn=1e7+10;\nll a[505][505];\nint prime[maxn],isprime[maxn],tmp;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvoid init(int n){\n\tREP(i,2,n){\n\t\tif(!isprime[i]) prime[++tmp]=i;\n\t\tREP(j,1,tmp){\n\t\t\tif((ll)i*prime[j]>n) break;\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll lcm(ll x,ll y){\n\treturn (x/__gcd(x,y))*y;\n}\nint main(){\n\tint n=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit(1e7);\n\tint l=1,r=n;\n\tfor(int i=2;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=i-j;\n\t\t\tif(k>=1 && k<=n) a[j][k]=u;\n\t\t}\n\t}\n\tl=n+1,r=n*2;\n\tfor(int i=(n&1)?2:3;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=n+1+j-i;\n\t\t\tif(k>=1 && k<=n) a[j][k]*=u;\n\t\t}\n\t}\n\tREP(i,1,n) REP(j,1,n) if((i+j)&1){\n\t\ta[i][j]=1;\n\t\tREP(k,0,3){\n\t\t\tint u=i+dir[k][0],v=j+dir[k][1];\n\t\t\tif(u>=1 && u<=n && v>=1 && v<=n) a[i][j]=lcm(a[i][j],a[u][v]);\n\t\t}\n\t\ta[i][j]++;\n\t}\n\tREP(i,1,n) REP(j,1,n) printf(\"%lld%c\",a[i][j],j==jend?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat gcd(cat x, cat y) {\n\tif(x > y) swap(x, y);\n\treturn (x == 0) ? y : gcd(y%x, x);\n}\n\ncat lcm(cat x, cat y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< vector<cat> > A(N, vector<cat>(N, 1));\n\tvector<int> P;\n\tfor(int p = 4; ; p++) {\n\t\tbool is_prime = true;\n\t\tfor(int i = 2; i*i <= p; i++) is_prime &= (p%i != 0);\n\t\tif(!is_prime) continue;\n\t\tP.push_back(p);\n\t\tif((int)P.size() == N+10) break;\n\t}\n\tfor(int i = 0; i < N; i += 2) for(int j = 0; j < N; j += 2) A[i][j] = P[i/2] * P[N/2+1+j/2];\n\tfor(int i = 1; i < N; i += 2) for(int j = 1; j < N; j += 2) A[i][j] = 3 * A[i-1][j-1];\n\tfor(int i = 0; i < N; i++) for(int j = 1-(i&1); j < N; j += 2) {\n\t\tif(i > 0) A[i][j] = lcm(A[i][j], A[i-1][j]);\n\t\tif(j > 0) A[i][j] = lcm(A[i][j], A[i][j-1]);\n\t\tif(i+1 < N) A[i][j] = lcm(A[i][j], A[i+1][j]);\n\t\tif(j+1 < N) A[i][j] = lcm(A[i][j], A[i][j+1]);\n\t\tif(j&1) A[i][j] *= 2;\n\t\tA[i][j]++;\n\t}\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N; j++) cout << A[i][j] << ((j == N-1) ? \"\\n\" : \" \");\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nconst int maxn=1e7+10;\nll a[505][505];\nint prime[maxn],isprime[maxn],tmp;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvoid init(int n){\n\tREP(i,2,n){\n\t\tif(!isprime[i]) prime[++tmp]=i;\n\t\tREP(j,1,tmp){\n\t\t\tif((ll)i*prime[j]>n) break;\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll lcm(ll x,ll y){\n\treturn (x/__gcd(x,y))*y;\n}\nint main(){\n\tint n=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit(1e7);\n\tint l=1,r=n;\n\tfor(int i=2;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=i-j;\n\t\t\tif(k>=1 && k<=n) a[j][k]=u;\n\t\t}\n\t}\n\tl=n+1,r=n*2;\n\tfor(int i=(n&1)?2:3;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=n+1+j-i;\n\t\t\tif(k>=1 && k<=n) a[j][k]*=u;\n\t\t}\n\t}\n\tREP(i,1,n) REP(j,1,n) if((i+j)&1){\n\t\ta[i][j]=1;\n\t\tREP(k,0,3){\n\t\t\tint u=i+dir[k][0],v=j+dir[k][1];\n\t\t\tif(u>=1 && u<=n && v>=1 && v<=n) a[i][j]=lcm(a[i][j],a[u][v]);\n\t\t}\n\t\ta[i][j]++;\n\t}\n\tREP(i,1,n) REP(j,1,n) printf(\"%lld%c\",a[i][j],j==jend?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=5e2+5;\nconst int M=5e5+5;\nint n,cnt,prime[M],vis[M];\nll a[N][N];\n\nll gcd(ll x,ll y) {return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y) {if(!x||!y) return x+y;return 1ll*x/gcd(x,y)*y;}\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nint main() {\n\tIN(n);\n    if(n==2) return printf(\"4 7\\n23 10\\n\"),0;\n\tfor(int i=2;i<M;++i) {\n\t\tif(!vis[i]) prime[++cnt]=i;\n\t\tfor(int j=1;i*prime[j]<M&&j<=cnt;++j) {\n\t\t\tvis[i*prime[j]]=1;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n    for(int i=1;i<=n;++i)\n        for(int j=(i+1&1)+1;j<=n;j+=2)\n            a[i][j]=prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n    for(int i=1;i<=n;++i)\n        for(int j=(i&1)+1;j<=n;j+=2)\n            a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;++i) {\n        for(int j=1;j<=n;++j) printf(\"%lld \",a[i][j]);\n        puts(\"\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 5e3 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nconst int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};\n\nll n;\n\nll f[maxn][maxn];\n\nll vis[1001000], prime[maxn << 1], tot;\n\nvoid init()\n{\n\trep(i, 2, 1000000)\n\t{\n\t\tif(vis[i]) continue;\n\t\tprime[++ tot] = i;\n\t\t// printf(\"prime : %lld\\n\", i);\n\t\tif(tot >= 10000) return;\n\t\trep(j, 2, 1000000)\n\t\t{\n\t\t\tif(i * j >= 1000000) break;\n\t\t\tvis[i * j] = 1;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\t// freopen(\"main.out\", \"w\", stdout);\n\tscanf(\"%lld\", &n);\n\tif(n == 2) return puts(\"1 2\\n4 8\"), 0;\n\tinit();\n\tll cnt = 0;\n\trep(i, 2, n << 1)\n\t{\n\t\t++ cnt;\n\t\trep(j, 1, i - 1) f[j][i - j] = prime[cnt];\n\t\t++ i;\n\t}\n\tll maxx = 0;\n\trep(i, - n / 2, n / 2)\n\t{\n\t\t++ cnt;\n\t\trep(j, max(1ll, - i * 2 + 1), min(n, n - i * 2)) f[j][j + i * 2] *= prime[cnt];\n\t}\n\trep(i, 1, n) rep(j, 1, n)\n\t{\n\t\tll tmp = 1;\n\t\tif(f[i][j]) goto end;\n\t\trep(k, 0, 3)\n\t\t{\n\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\tif(x <= 0 || y <= 0 || x > n || y > n) continue;\n\t\t\ttmp = tmp / __gcd(tmp, f[x][y]) * f[x][y];\n\t\t}\n\t\tf[i][j] = tmp + 1;\n\t\tend:;\n\t\tmaxx = max(maxx, f[i][j]);\n\t\tprintf(\"%lld%c\", f[i][j], \" \\n\"[j == n]);\n\t}\n\t// printf(\"%lld\\n\", maxx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  \n  int n = 500;\n  int val = n * n / 4;\n  vector<vector<ll>> ans(n + 2, vector<ll>(n + 2, 1));\n  int cnt = 0, l = 3, r = val * 2 + 1;\n  set<ll> st;\n  for (int i = 3; i <= n * 2; i += 2)\n    for (int x = max(1, i - n), y = i - x; x + 1 <= n && y - 1 > 0; x += 2, y -= 2) {\n      if (++cnt & 1) {\n        ans[x][y] = l;\n        ans[x + 1][y - 1] = l * 2;\n        st.insert(l); st.insert(l * 2);\n        l += 2;\n      } else {\n        ans[x][y] = r;\n        ans[x + 1][y - 1] = r * 2;\n        st.insert(r); st.insert(r * 2);\n        r -= 2;\n      } \n    }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j) {\n      if (ans[i][j] == 1) {\n        ll l = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n        ll v = 1;\n        while (st.count(v * l + 1)) ++v;\n        ans[i][j] += l * v;\n        st.insert(ans[i][j]);\n      }\n//      assert(ans[i][j] <= 1e15);\n    }\n  cin >> n;\n  for (int i = 1; i <= n; ++i)\n    cout << vector<ll>(ans[i].begin() + 1, ans[i].begin() + n + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\nint p[500][500], q[500][500];\nll A[500][500];\n\nconst int MAXN = 1000;\nint prime[MAXN];\nbool primeNumber(int n){\n    if(n < 2) return false;\n    else{\n        for(int i = 2; i * i <= n; i++){\n            if(n % i == 0) return false;\n        }\n        return true;\n    }\n}\n\nint main() {\n   int N;\n   cin >> N;\n   int cnt = 0;\n   for (int i = 2;; ++i) {\n      if (primeNumber(i)) {\n         prime[cnt] = i; \n         cnt++;\n      }\n      if (cnt >= MAXN) break; \n   }\n   int Uid = 0;\n   int Did = MAXN - 1;\n   for (int r = 1; r <= 500; r++) {\n      for (int c = 1; c <= 500; c++) {\n         int tmp = r + c;\n         if (tmp % 2 == 0) {\n            if (tmp % 4 == 0) {\n               p[r - 1][c - 1] = prime[Uid + tmp / 4 - 1];\n            } else {\n               p[r - 1][c - 1] = prime[Did - tmp / 4];\n            }\n         }\n      }\n   }\n   Uid += 250;\n   Did -= 250;\n\n   for (int r = 1; r <= 500; r++) {\n      for (int c = 1; c <= 500; c++) {\n         int tmp = r - c + 500;\n         if (tmp % 2 == 0) {\n            if (tmp % 4 == 0) {\n               q[r - 1][c - 1] = prime[Uid + tmp / 4 - 1];\n            } else {\n               q[r - 1][c - 1] = prime[Did - tmp / 4];\n            }\n         }\n      }\n   }\n\n   for (int r = 1; r <= 500; r++) {\n      for (int c = 1; c <= 500; c++) {\n         int tmp = r + c;\n         if (tmp % 2 == 0) {\n            A[r - 1][c - 1] = p[r - 1][c - 1] * q[r - 1][c - 1];\n         } else {\n            A[r - 1][c - 1] = 1;\n            if (r - 2 >= 0 && r - 2 < 500) A[r - 1][c - 1] *= p[r - 2][c -1];\n            if (r >= 0 && r < 500) A[r - 1][c - 1] *= p[r][c -1];\n            if (c - 2 >= 0 && c - 2 < 500) A[r - 1][c - 1] *= q[r - 1][c -2];\n            if (c >= 0 && c < 500) A[r - 1][c - 1] *= q[r - 1][c];\n            A[r - 1][c - 1] += 1;  \n         }\n      } \n   }\n\n   for (int r = 0; r < N; r++) {\n      for (int c = 0; c < N; c++) {\n         cout << A[r][c];\n         if (c != N - 1) cout << \" \";\n      }\n      cout << endl;\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint ncnt,val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[10005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {\n\t\tputs(\"4 7\"),puts(\"23 10\");\n\t\treturn 0;\n\t}\n\tinit(10000);\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if((i+j)&1) {\n\t\tif(!val0[i+j]) val0[i+j]=prime[ncnt++]; \n\t\tif(!val1[i-j+n]) val1[i-j+n]=prime[ncnt++];\n\t\tan[i][j]=val0[i+j]*val1[i-j+n];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k]; if(_x<1||_x>n) continue;\n\t\t\tint _y=y+dy[k]; if(_y<1||_y>n) continue;\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t\t++an[x][y];\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int lim = 4e4, Nmax = 505;\n\nint i, j, a[Nmax][Nmax];\nvector<int> primes;\nbool used[lim+2];\n\nvoid run_primes()\n{\n    int i;\n    for(i=2; i<=lim; ++i)\n        if(!used[i])\n        {\n            primes.push_back(i);\n            for(j=i*i; j<=lim; j+=i) used[j] = 1;\n        }\n}\n\nint main()\n{\n   // freopen(\"input\", \"r\", stdin);\n\n    run_primes();\n\n    int n, N;\n    cin >> N;\n    n = N + ((N&1)^1);\n\n    for(i=0; i<n; ++i)\n        for(j=0; j<n; ++j)\n            if(!((i+j)&1)) a[i][j] = primes[(i+j)/2] * primes[(i-j)/2 + n + 1];\n\n    for(i=0; i<n; ++i)\n        for(j=0; j<n; ++j)\n            if((i+j)&1)\n            {\n                if(j && j<n-1) a[i][j] = a[i][j-1] * a[i][j+1] + 1;\n                    else a[i][j] = a[i-1][j] * a[i+1][j] + 1;\n            }\n\n    for(i=0; i<N; ++i)\n        for(j=0; j<N; ++j)\n            cout << a[i][j] << \" \\n\"[j==N-1];\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 1000000007\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint a[514][514];\nint b[514][514];\nint ans[514][514];\nvector<int> p;\nsigned main(){\n\tic(n)\n\trep(2,i,10000)if(prime(i))p.pb(i);\n\trep(0,i,501)rep(0,j,501){\n\t\tif((i+j)%2==0){\n\t\t\ta[i][j]=p[(i+j)/2];\n\t\t\tb[i][j]=p[(i+500-j)/2+500];\n\t\t\tans[i][j]=a[i][j]*b[i][j];\n\t\t}\n\t}\n\trep(0,i,501)rep(0,j,501){\n\t\tif((i+j)%2==1){\n\t\t\tif(i==0||i==500){\n\t\t\t\tans[i][j]=a[i][j-1]*b[i][j-1]*a[i][j+1]*b[i][j+1]+1;\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tans[i][j]=a[i-1][j]*b[i-1][j]*a[i+1][j]*b[i+1][j]+1;\n\t\t\t}\t\n\t\t}\n\t}\n\trep(0,i,n){\n\t\trep(0,j,n)cout<<ans[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m int64_t\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nint main(){m n;cin>>n;m t=0,k=555;r(2,i,9999){bool a=true;r(2,j,i){if(i%j==0)a=false;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\n#define n_size 500\n\nvector<bool> prime_list(int MAX_N){\n\n    vector<bool> is_prime(MAX_N + 1, true);\n\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    FOR(i, 2, MAX_N + 1){\n        if(is_prime[i]){\n            int tmp = i * 2;\n            while(tmp <= MAX_N){\n                is_prime[tmp] = false;\n                tmp += i;\n            }\n        }\n    }\n\n    return is_prime;\n}\n\nint extgcd(int a, int b, int &x, int &y){\n    int d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nint lcm(int a, int b){\n    int x, y;\n    int g = extgcd(a, b, x, y);\n    a /= g;\n    return a * b;\n}\n\nint lcm_multi(vec a){\n    int p = a[0];\n    FOR(i, 1, a.size()) p = lcm(p, a[i]);\n    return p;\n}\n\nsigned main(){\n\n    vector<bool> is_prime = prime_list(100000);\n    vec primes(0);\n    FOR(i, n_size, is_prime.size()){\n        if(is_prime[i]){\n            primes.push_back(i);\n        }\n    }\n    //cout << primes.size() << endl; 9497\n\n    int ans[n_size][n_size];\n    set<int> s;\n\n    REP(i, n_size){\n        REP(j, n_size){\n            if((i - j) % 2 != 0) continue;\n            ans[i][j] = (min(i, j) + 1) * primes[(j - i + n_size) / 2];\n            s.insert(ans[i][j]);\n        }\n    }\n\n    //int maxv = 0;\n\n    REP(j, n_size){\n        REP(i, n_size){\n            if((i - j) % 2 == 0) continue;\n            vec a(0);\n            if(i > 0) a.push_back(ans[i - 1][j]);\n            if(j > 0) a.push_back(ans[i][j - 1]);\n            if(i < n_size - 1) a.push_back(ans[i + 1][j]);\n            if(j < n_size - 1) a.push_back(ans[i][j + 1]);\n            int p = lcm_multi(a);\n            int n = 1;\n            while(s.count(n * p + 1)) n++;\n            ans[i][j] = n * p + 1;\n            s.insert(ans[i][j]);\n            //maxv = max(maxv, ans[i][j]);\n        }\n    }\n\n    //cout << maxv << endl;\n\n\n    /*\n    set<int> s2;\n    REP(i, n_size){\n        REP(j, n_size){\n            if(s2.count(ans[i][j]) > 0) cout << ans[i][j] << endl;\n            s2.insert(ans[i][j]);\n        }\n    }\n    */\n\n   int N; cin >> N;\n   REP(i, N){\n       REP(j, N){\n           cout << ans[i][j] << \" \";\n           //if(ans[i][j] < 1 || ans[i][j] > 1000000000000000) cout << ans[i][j] << endl;\n       }\n       cout << endl;\n   }\n\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n#include <sys/time.h>\n#include <fstream>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define REP(i,n)  FOR(i,0,n)\n#define each(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define deb(x) cerr << #x << \" = \" << (x) << \" , \";\n#define debl cerr << \" (L\" << __LINE__ << \")\"<< endl;\n#define sz(s) (int)((s).size())\n\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(x,y) make_pair((x),(y))\n\ndouble pi=3.14159265358979323846;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){\n\tos << \"[ \";\n\tREP(i,z.size())os << z[i] << \", \" ;\n\treturn ( os << \"]\" << endl);\n}\n\ntemplate<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){\n\tos << \"set( \";\n\tEACH(p,z)os << (*p) << \", \" ;\n\treturn ( os << \")\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){\n\tos << \"{ \";\n\tEACH(p,z)os << (p->first) << \": \" << (p->second) << \", \" ;\n\treturn ( os << \"}\" << endl);\n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){\n\treturn ( os << \"(\" << z.first << \", \" << z.second << \",)\" );\n}\n\ndouble get_time(){\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec + tv.tv_usec*1e-6;\n}\n\ntypedef unsigned int uint32_t;\nstruct RND{\n\tuint32_t x;\n\tuint32_t y;\n\tuint32_t z;\n\tuint32_t w;\n\tRND(){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=88675123;\n\t}\n\tvoid init(int seed){\n\t\tx=123456789;\n\t\ty=362436069;\n\t\tz=521288629;\n\t\tw=seed+100;\n\t\tREP(i,10)get();\n\t}\n\tuint32_t get(){\n\t\tuint32_t t;\n\t\tt=x^(x<<11);\n\t\tx=y;y=z;z=w;\n\t\tw=(w^(w>>19))^(t^(t>>8));\n\t\treturn w;\n\t}\n};\nRND rnd;\n\nvoid _main(istream &inp){\n\tint n;\n\tinp >> n;\n\tconst int M = 1000;\n\tvvl ret(n, vl(n));\n//\tdebug(n);\n//\tdebug(ret);\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==0){\n\t\t\tret[x][y]=M+rnd.get()%M;\n\t\t}\n\t}\n\trep(x,n) rep(y,n){\n\t\tif((x+y)%2==1){\n\t\t\tll z = 1;\n\t\t\tif(x>0)z*=ret[x-1][y];\n\t\t\telse z*=2;\n\t\t\tif(y>0)z*=ret[x][y-1];\n\t\t\telse z*=3;\n\t\t\tif(x+1<n)z*=ret[x+1][y];\n\t\t\telse z*=4;\n\t\t\tif(y+1<n)z*=ret[x][y+1];\n\t\t\telse z*=5;\n\t\t\tret[x][y]=z+1;\n\t\t}\n\t}\n\t//debug(n);\n\t//debug(ret);\n\trep(x,n) rep(y,n-1){\n\t\tll a = ret[x][y];\n\t\tll b = ret[x][y+1];\n\t\tassert(max(a,b)%min(a,b)==1);\n\t}\n\trep(x,n-1) rep(y,n){\n\t\tll a = ret[x][y];\n\t\tll b = ret[x+1][y];\n\t\tassert(max(a,b)%min(a,b)==1);\n\t}\n\trep(x,n){\n\t\trep(y,n){\n\t\t\tcout << ret[x][y];\n\t\t\tif(y!=n-1)cout << \" \";\n\t\t\telse cout << endl;\n\t\t}\n\t}\n\n\n}\n\nint main(){\n\tif(0){\n\t\tifstream ifs(\"test.txt\");\n\t\t_main(ifs);\n\t}\n\telse{\n\t\t_main(cin);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\n\nint not_prime(int x)\n{\n    for (int i = 2; i < x; i++) if (x % i == 0) return 1;\n    return 0;\n}\n\nint ok(int i, int j)\n{\n    return (0 <= i && i < n && 0 <= j && j < n);\n}\n\nvector<ll> nums[600][600];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n;\n    int p = 2;\n    for (int si = 1; si <= 1000; si += 2)\n    {\n        while (not_prime(p)) p++;\n        for (int i = 0; i <= 500; i++)\n        {\n            for (int j = 0; j <= 500; j++)\n            {\n                if (i + j == si)\n                {\n                    nums[i][j].push_back(p);\n                }\n            }\n        }\n        p++;\n    }\n    for (int dif = -499; dif <= 499; dif += 2)\n    {\n        while (not_prime(p)) p++;\n        for (int i = 0; i <= 500; i++)\n        {\n            for (int j = 0; j <= 500; j++)\n            {\n                if (i - j == dif)\n                {\n                    nums[i][j].push_back(p);\n                }\n            }\n        }\n        p++;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (i % 2 != j % 2)\n            {\n                ll k = 1;\n                for (auto e : nums[i][j]) k *= e;\n                cout << k << \" \";\n            }\n            else\n            {\n                vector<ll> p;\n                for (int k = 0; k < 4; k++)\n                {\n                    if (ok(i + cx[k], j + cy[k]))\n                    {\n                        p.push_back(nums[i + cx[k]][j + cy[k]][0]);\n                        p.push_back(nums[i + cx[k]][j + cy[k]][1]);\n                    }\n                }\n                uniq(p);\n                ll k = 1;\n                for (auto e : p) k *= e;\n                cout << k + 1 << \" \";\n            }\n        }\n        cout << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 505\nint vl[N*3],n,ct,d[4][2]={-1,0,1,0,0,1,0,-1};\nlong long gcd(long long a,long long b){return b?gcd(b,a%b):a;}\nlong long as[N][N],mx;\nint main()\n{\n\tfor(int i=501;i<=10000;i++)\n\t{\n\t\tint fg=0;\n\t\tfor(int j=2;j<=100;j++)if(i%j==0)fg=1;\n\t\tif(!fg)vl[++ct]=i;\n\t}\n\tfor(int i=1;i<=500;i++)as[i][i]=vl[1]*i;\n\tint st=2;\n\tfor(int i=2;i<=500;i+=2){for(int j=1;i+j<=500;j++)as[i+j][j]=vl[st]*(j+i/2),as[j][i+j]=vl[st+1]*(j+i/2);st+=2;}\n\tfor(int i=1;i<=500;i++)\n\tfor(int j=1;j<=500;j++)\n\tif((i+j)&1)\n\t{\n\t\tlong long st=1;\n\t\tfor(int s=0;s<4;s++)\n\t\t{\n\t\t\tint vl=as[i+d[s][0]][j+d[s][1]];\n\t\t\tif(vl)st=st/gcd(st,vl)*vl;\n\t\t}\n\t\tas[i][j]=st+1;\n\t\tif(mx<st)\n\t\tmx=st;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++,printf(\"\\n\"))\n\tfor(int j=1;j<=n;j++)\n\tprintf(\"%lld \",as[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 502;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nlong long ans[501][501];\nint n,x;\nbool bo;\n\nbool check(int x)\n{\n\tfor (int i=2; i<x; i++)\n\t\tif (x%i==0) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tbo=0; scanf(\"%d\",&n); if (!(n&1)) n++,bo=1; int la=2;\n\tfor (int i=1; i<=n; i+=2)\n\t\tfor (int j=la; ; j++) \n\t\t\tif (check(j)) {ans[1][i]=j,la=j+1; break;}\n\tfor (int i=3; i<=n; i+=2)\n\t\tfor (int j=la; ; j++)\n\t\t\tif (check(j)) {ans[i][1]=j,la=j+1; break;}\n\tfor (int i=2; i<=n; i+=2) ans[1][i]=ans[1][i-1]*ans[1][i+1],ans[i][1]=ans[i-1][1]*ans[i+1][1];\n\tfor (int i=2; i<=n; i++)\n\t\tfor (int j=2; j<=n; j++) ans[i][j]=ans[1][j]*ans[i][1];\n\tfor (int i=1; i<=n; i++) ans[2][i]*=2ll;\n\tif (bo) n--;\n\tfor (int i=1; i<=n; i++,printf(\"\\n\"))\n\t\tfor (int j=1; j<=n; j++) printf(\"%lld \",ans[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<set>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x7fffffffffffffff;\nconst double eps=1e-10;\n\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline bool _cmp(const _Tp &a,const _Tp &b){return abs(a-b)<=eps;}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tregister char ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args)\n{\n\tread(t);read(args...);\n}\nFinline int read_str(char *s)\n{\n\tregister char ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tregister char *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=505;\nconst int MAXN=20005;\nFinline ll lcm(ll a,ll b)\n{\n\tif(!a||!b) return a|b;\n\treturn a/gcd(a,b)*b;\n}\nbool pr[MAXN];\nint p[MAXN],pos;\nint p1[MAXN],pos1;\nint p2[MAXN],pos2;\nint a1[N][N],a2[N][N];\nll a[N][N];\nstd::set<ll> S;\nvoid sieve()\n{\n\tfor(int i=2;i<MAXN;++i)\n\t{\n\t\tif(!pr[i])\n\t\t{\n\t\t\tp[++pos]=i;\n\t\t\tif(pos&1) p1[++pos1]=i;\n\t\t\telse p2[++pos2]=i;\n\t\t}\n\t\tfor(int j=1;j<=pos&&i*p[j]<MAXN;++j)\n\t\t{\n\t\t\tpr[i*p[j]]=true;\n\t\t\tif(!(i%p[j]))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tsieve();\n\tint n;\n\tread(n);\n\tint cur1=0,cur2=0;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tif(!(i&1))\n\t\t{\n\t\t\ta1[1][i]=++cur1;\n\t\t\ta2[1][i]=++cur2;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(!(i&1))\n\t\t{\n\t\t\ta1[i][1]=++cur1;\n\t\t}\n\t\tif((i+n)&1)\n\t\t{\n\t\t\ta2[i][n]=++cur2;\n\t\t}\n\t}\n\tfor(int i=1;i<=cur1;++i)\n\t{\n\t\tif(i<cur1-i+1&&(i&1))\n\t\t{\n\t\t\tstd::swap(p1[i],p1[cur1-i+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=cur2;++i)\n\t{\n\t\tif(i<cur2-i+1&&(i&1))\n\t\t{\n\t\t\tstd::swap(p2[i],p2[cur2-i+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(i==1||j==1) continue;\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\ta1[i][j]=a1[i-1][j-1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(i==1||j==n) continue;\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\ta2[i][j]=a2[i-1][j+1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\ta[i][j]=p1[a1[i][j]]*p2[a2[i][j]];\n\t\t\t\tS.insert(a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!((i+j)&1))\n\t\t\t{\n\t\t\t\tll tmp=lcm(lcm(a[i-1][j],a[i+1][j]),lcm(a[i][j-1],a[i][j+1]));\n\t\t\t\tll cur=tmp+1;\n\t\t\t\twhile(S.find(cur)!=S.end())\n\t\t\t\t{\n\t\t\t\t\tcur+=tmp;\n\t\t\t\t}\n\t\t\t\ta[i][j]=cur;\n\t\t\t\tS.insert(cur);\n\t\t\t}\n\t\t}\n\t}\n\tll maxx=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tchmax(maxx,a[i][j]);\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tfprintf(stderr,\"@ %lld\\n\",maxx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, cnt = 2;\nlong long res[507][507];\nmap<int, int>a, b;\nint nxt()\n{\n\twhile (1)\n\t{\n\t\tbool ok = 1;\n\t\tfor (int i = 2; i * i <= cnt && ok; i++)\n\t\t\tif (cnt % i == 0)ok = 0;\n\t\tif (ok)return cnt++;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\nlong long gcd(long long a, long long b)\n{\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nlong long lcm(long long a, long long b)\n{\n\tif (!a || !b)return 0;\n\treturn a / gcd(a, b) * b;\n}\nint main()\n{\n\tcin >> n;\n\tif (n == 2) {\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tfor (int i = 3; i < 2 * n; i += 2)a[i] = nxt();\n\tfor (int i = -n + 1; i < n; i += 2)b[i] = nxt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) & 1)\n\t\t\t{\n\t\t\t\tres[i][j] = 1LL * a[i + j] * b[i - j];\n\t\t\t\tres[i - 1][j] = lcm(res[i - 1][j], res[i][j]);\n\t\t\t\tres[i][j - 1] = lcm(res[i][j - 1], res[i][j]);\n\t\t\t\tres[i + 1][j] = lcm(res[i + 1][j], res[i][j]);\n\t\t\t\tres[i][j + 1] = lcm(res[i][j + 1], res[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (!((i + j) & 1))\n\t\t\t\tres[i][j]++;\n\tfor (int i = 1; i <= n; i++, putchar('\\n'))\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tprintf(\"%lld \", res[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=20005;\nint fl[N],pri[N];\nint v1[N],v2[N],n;\nvoid init(){\n\tFor(i,2,N-1) For(j,2,(N-1)/i) fl[i*j]=1;\n\tFor(i,2,N-1) if (!fl[i]&&*pri<=2*n+6) pri[++*pri]=i;\n\t//printf(\"%d %d\\n\",*pri,pri[*pri]);\n}\nint main(){\n\tscanf(\"%d\",&n); init();\n\tFor(i,0,n+n+2) v1[i]=v2[i]=1;\n\tFor(i,0,n+1){\n\t\tint v=i;\n\t\tif (v%2==0) v1[v]=pri[(*pri)--];\n\t\tif ((v+n+1)%2==0) v2[v]=pri[(*pri)--];\n\t\tv=n+n+2-i;\n\t\tif (v%2==0) v1[v]=pri[(*pri)--];\n\t\tif ((v+n+1)%2==0) v2[v]=pri[(*pri)--];\n\t}\n\t/*printf(\"%d %d %d\\n\",v1[n],v1[n+1],v1[n+2]);\n\tprintf(\"%d %d %d\\n\",v2[n],v2[n+1],v2[n+2]);\n\tprintf(\"%d\\n\",*pri);\n\treturn 0;*/\n\t//printf(\"%d\\n\",*pri);\n\tFor(i,1,n) For(j,1,n)\n\t\tif ((i+j)%2==0) printf(\"%lld%c\",1ll*v1[i+j]*v2[i+n-j+1],j==n?'\\n':' ');\n\t\telse printf(\"%lld%c\",1ll*v1[i+j-1]*v1[i+j+1]*v2[i+n-j]*v2[i+n-j+2]+1,j==n?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define M 505\n#define N 10000\nlong long gcd(long long x,long long y){return y?gcd(y,x%y):x;}\nlong long lcm(long long x,long long y){return x/gcd(x,y)*y;}\nint b[N],i,j,l,m,n,r,t;bool w[N];long long a[M][M];\nint main()\n{\n\tfor(int i=2;i<N;i++)\n\t{\n\t\tif(!w[i])w[b[t++]=i]=true;\n\t\tfor(j=0;i*b[j]<N;j++)\n\t\t{\n\t\t\tw[i*b[j]]=true;\n\t\t\tif(i%b[j]==0)break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)a[i][0]=a[0][i]=a[n+1][i]=a[i][n+1]=1;\n\tif(n==2)return 0*puts(\"4 7\\n23 10\");\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)if(~(i^j)&1)a[i][j]=b[i+j>>1]*b[(n-j+(~n&1)+i>>1)+n];\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)if(!a[i][j])a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i][j+1],a[i+1][j]))+1;\n\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)printf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nconst int N = 505;\nint n, tail;\nll ans[N][N];\nset<ll> used;\nint pri[N * N];\nbool isNot[N * N];\nvoid Sieve() {\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tif (!isNot[i])\n\t\t\tpri[++tail] = i;\n\t\tfor (int j = 1; j <= tail && pri[j] * i <= n * n; ++j) {\n\t\t\tisNot[pri[j] * i] = 1;\n\t\t\tif (i % pri[j] == 0)\n\t\t\t\tcontinue ;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y) { return (!x) ? (y) : gcd(y % x, x); }\nll lcm(ll x, ll y) { return (!x || !y) ? (x | y) : (x * y / gcd(x, y)); }\nint main() {\n\tscanf(\"%d\", &n);\n\tSieve();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i & 1) == (j & 1)) {\n\t\t\t\tll tmp = pri[min(min(n - i + 1, n - j + 1), min(i, j))];\n\t\t\t\tans[i][j] = tmp;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i & 1) != (j & 1)) {\n\t\t\t\tll tmp = lcm(lcm(ans[i - 1][j], ans[i + 1][j]), lcm(ans[i][j - 1], ans[i][j + 1]));\n\t\t\t\tans[i][j] = tmp + 1;\n\t\t\t\twhile (used.count(ans[i][j]))\n\t\t\t\t\tans[i][j] += tmp;\n\t\t\t\tused.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\t\t\tif (ans[i][j] > 1e15) {\n\t\t\t\tprintf(\"________________________\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int Maxv = 1000; \nconst long long INF = 0x3f3f3f3f; \n\nint cnt, idx, n; \nlong long ans[550][550], elm[Maxv], max = -INF; \nlong long x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1}; \n\ninline long long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a; \n}\n\ninline void pre_Opt() {\n    int num; \n    for (int i = 2;; i++) {\n        for (num = 2; num * num <= i; num++) {\n            if (i % num == 0) break; \n        }\n\n        if (num * num > i) elm[++cnt] = i; \n        if (cnt >= Maxv) break; \n    }\n}\n\nint main() {\n    scanf(\"%d\", &n); \n    pre_Opt(); \n\n    for (int i = 1; i <= cnt; i++) {\n        printf(\"--Satori--%lld\\n\", elm[i]); \n    }\n\n    for (int i = 3; i <= n + n; i += 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if (i - j < 1 || i - j > n) continue; \n            \n            ans[j][i - j] = elm[idx]; \n        }\n    }    \n\n    for (int i = ((n >> 1) << 1) + 2 - 1; i >= -n; i -= 2) {\n        idx++; \n\n        for (int j = 1; j <= n; j++) {\n            if(i + j < 1 || i + j > n) continue; \n\n            ans[j][i + j] *= elm[idx]; \n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (!((i + j) % 2)) {\n                long long res = 1; \n\n                for (int k = 0; k < 4; k++) {\n                    if (i + x[k] < 1 || i + x[k] > n || j + y[k] < 1 || j + y[k] > n) continue; \n\n                    //printf(\"--Satori--%d\\n\", gcd(res, ans[i + x[k]][j + y[k]])); \n                    res = res / gcd(res, ans[i + x[k]][j + y[k]]) * ans[i + x[k]][j + y[k]]; \n                }\n\n                max = std::max(max, res); \n                ans[i][j] = res + 1; \n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            printf(\"%lld \", ans[i][j]); \n        }\n\n        puts(\"\");\n    }\n\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n  while (b != 0) {\n    long long t = a % b;\n    a = b;\n    b = t;\n  }\n  return abs(a);\n}\n\nlong long lcm(long long a, long long b) {\n  return a / gcd(a, b) * b;\n}\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<vector<long long>> matrix(n, vector<long long>(n));\n  vector<bool> mark(10001);\n  vector<int> primes;\n\n  for (int i = 2; i <= 10000; i++) {\n    if (mark[i]) continue;\n    primes.push_back(i);\n    for (int j = i * i; j <= 10000; j += i) {\n      mark[j] = true;\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 1-i%2; j < n; j += 2) {\n      int diag1 = (i + j) / 2;\n      int diag2 = (i + (n-j-1)) / 2;\n      matrix[i][j] = primes[diag1] * primes[diag2 + 502];\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (((i + j)&1) == 0) {\n        long long l = 1;\n        if (i > 0) l = lcm(l, matrix[i - 1][j]);\n        if (j > 0) l = lcm(l, matrix[i][j - 1]);\n        if (i + 1 < n) l = lcm(l, matrix[i + 1][j]);\n        if (j + 1 < n) l = lcm(l, matrix[i][j + 1]);\n        if (l + 1 > 1'000'000'000'000'000ll) {\n          printf(\"Failed\\n\");\n          return 1;\n        }\n        matrix[i][j] = l + 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%lld%c\", matrix[i][j], \" \\n\"[j + 1 == n]);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 5e3 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nconst int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};\n\nll n;\n\nll f[maxn][maxn];\n\nll vis[1001000], prime[maxn << 1], tot;\n\nvoid init()\n{\n\trep(i, 2, 1000000)\n\t{\n\t\tif(vis[i]) continue;\n\t\tprime[++ tot] = i;\n\t\t// printf(\"prime : %lld\\n\", i);\n\t\tif(tot >= 10000) return;\n\t\trep(j, 2, 1000000)\n\t\t{\n\t\t\tif(i * j >= 1000000) break;\n\t\t\tvis[i * j] = 1;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\t// freopen(\"main.out\", \"w\", stdout);\n\tscanf(\"%lld\", &n);\n\tif(n == 2) return puts(\"2 3\\n9 4\"), 0;\n\tinit();\n\tll cnt = 0;\n\trep(i, 2, n << 1)\n\t{\n\t\t++ cnt;\n\t\trep(j, 1, i - 1) f[j][i - j] = prime[cnt];\n\t\t++ i;\n\t}\n\trep(i, - n / 2, n / 2)\n\t{\n\t\t++ cnt;\n\t\trep(j, max(1ll, - i * 2 + 1), min(n, n - i * 2)) f[j][j + i * 2] *= prime[cnt];\n\t}\n\trep(i, 1, n) rep(j, 1, n)\n\t{\n\t\tll tmp = 1;\n\t\tif(f[i][j]) goto end;\n\t\trep(k, 0, 3)\n\t\t{\n\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\tif(x <= 0 || y <= 0 || x > n || y > n) continue;\n\t\t\ttmp = tmp / __gcd(tmp, f[x][y]) * f[x][y];\n\t\t}\n\t\tf[i][j] = tmp + 1;\n\t\tend:;\n\t\tprintf(\"%lld%c\", f[i][j], \" \\n\"[j == n]);\n\t}\n\t// printf(\"%lld\\n\", maxx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair < int, int > PII;\ntypedef pair < LL, LL > PLL;\ntypedef pair < LD, LD > PDD;\n\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntemplate < typename _T > inline void _DBG(const char *s, _T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate < typename _T, typename... args > void _DBG(const char *s, _T x, args... a) { while(*s != ',') cerr << *s++; cerr << \" = \" << x << ','; _DBG(s + 1, a...); }\n\n#ifdef LOCAL\n#define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0) cout\n#endif\n\n// ********************** CODE ********************** //\n\nconst int N = 500;\n\nLL pri[] = {1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901};\n\nLL T[N][N];\nunordered_set < LL > S;\n\nLL nwd(LL a, LL b)\n{\n    if(b == 0) return a;\n    return nwd(b, a % b);\n}\n\nLL nww(LL a, LL b)\n{\n    return a / nwd(a, b) * b;\n}\n\nvoid print()\n{\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}\n\nint main()\n{\n    _upgrade\n    //random_shuffle(pri, pri + 1000);\n    int l = 0, r = 505; \n    for(int i = 0; i <= 2 * N; i += 2)\n    {\n        //DBG(pri[((i / 2) & 1 ? r : l)]);\n        for(int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if(0 <= k && k < N)\n            {\n                T[j][k] = pri[((i / 2) & 1 ? r : l)];\n            }\n        }\n        if((i / 2) & 1)\n            l++;\n        else\n            r--;\n    }\n    //print();\n    LL st = N / 2;\n    for (int i = 0; i <= 2 * N; i += 2)\n    {\n        LL p = st;\n        //DBG(i, st);\n        for (int j = 0; j < N; j++)\n        {\n            int k = i - j;\n            if (0 <= k && k < N)\n            {\n                T[j][k] *= p;\n                if(p > 1000)\n                {\n                    DBG(j, k);\n                }\n                S.insert(T[j][k]);\n                p++;\n            }\n        }\n        if(i + 2 < N)\n            st--;\n        else if(i + 2 > N)\n            st++;\n    }\n    //print();\n    LL lim = 1e15;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(T[i][j] != 0) continue;\n            vector < LL > v;\n            if(i > 0)\n                v.push_back(T[i - 1][j]);\n            if(j > 0)\n                v.push_back(T[i][j - 1]);\n            if(i + 1 < N)\n                v.push_back(T[i + 1][j]);\n            if(j + 1 < N)\n                v.push_back(T[i][j + 1]);\n            LL can = 0;\n            if(sz(v) == 1)\n            {\n                can = v[0];\n            }\n            else if(sz(v) == 2)\n            {\n                can = nww(v[0], v[1]);\n            }\n            else if(sz(v) == 3)\n            {\n                can = nww(v[0], nww(v[1], v[2]));\n            }\n            else\n            {\n                can = nww(v[0], nww(v[1], nww(v[2], v[3])));\n            }\n            //DBG(can, sz(v));\n            LL cp = can;\n            while(can + 1 <= lim && S.find(can + 1) != S.end())\n            {\n                //DBG(can + 1);\n                can += cp;\n            }\n            //DBG(i, j, T[i][j]);\n            if(can + 1 > lim)\n            {\n                DBG(i, j, can + 1);\n                //for (auto u : v)\n                //    DBG(u);\n                //cout << \"KUPA\\n\";\n                return 0;\n            }\n            S.insert(can + 1);\n            T[i][j] = can + 1;\n        }\n    }\n    DBG(\"ok\");\n    /*\n    cout << \"{ \";\n    for(int i = 0; i < N; i++)\n    {\n        cout << \"{ \";\n        for(int j = 0; j < N; j++)\n        {\n            cout << T[i][j] << (j + 1 < N ? \", \" : \"\");\n        }\n        cout << \" }\" << (i + 1 < N ? \", \" : \"\");\n    }\n    cout << \" }\";\n    */\n    int n; cin >> n;\n    for(int  i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            cout << T[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 10;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    set<int> used;\n    ll cur = 2;\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            a[i][j] = cur++;\n            used.insert(a[i][j]);\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            ll val = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    val = LCM(val, a[ni][nj]);\n                }\n            }\n            a[i][j] = val + 1;\n            while(used.count(a[i][j])) a[i][j] += val;\n        }\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,k,n) for(ll i= (ll) k;i< (ll) n;i++)\n#define all(v) (v).begin(), (v).end()\n#define SZ(v) (int)((v).size())\n#define pb push_back\n#define ft first\n#define sd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst long long INF = 1e18L + 1;\nconst int IINF = 1e9 + 1;\n\nusing namespace std;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define DBG(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define DBG(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int N = 500;\n\nll mat[N + 2][N + 2];\nint n;\n\nint main()\n{\n#ifndef LOCAL\n\tios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n\tcin >> n;\n\tif(n == 2){\n\t\tcout << 4 << \" \" << 7 << \"\\n\" << 23 << \" \" << 10 << \"\\n\";\n\t\treturn 0;\n\t}\n\tll cnt = 123;\n\trep(i, 0, n + 2){\n\t\trep(j, 0, n + 2){\n\t\t\tmat[i][j] = 1;\n\t\t}\n\t}\n\trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tif((i ^ j) & 1){\n\t\t\t\tmat[i][j] = cnt++;\t\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tif(!((i ^ j) & 1)){\n\t\t\t\tfor(auto x : {mat[i - 1][j], mat[i + 1][j], mat[i][j - 1], mat[i][j + 1]}){\n\t\t\t\t\tmat[i][j] = (mat[i][j] * x) / __gcd(mat[i][j], x);\n\t\t\t\t}\n\t\t\t\tmat[i][j]++;\n\t\t\t}\n\t\t}\n\t}\n  \trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tcout << mat[i][j] << \" \\n\"[j == n];\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n3\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=30005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll g[maxn][maxn];\n\nvector<int> a,b;\n\nll lcm(ll a,ll b){\n\tif(a==0||b==0) return a+b;\n\treturn a*b/__gcd(a,b);\n}\n\nint main()\n{\n\tIOS;\n\n\tbool isp[maxn]={0};\n\tvector<int> p;\n\n\tfor(int i=2;i<maxn;i++){\n\t\tif(!isp[i]) p.pb(i);\n\t\tfor(int j=0;i*p[j]<maxn;j++){\n\t\t\tisp[i*p[j]]=1;\n\t\t\tif(i%p[j]==0) break;\n\t\t}\n\t}\n\tREP(i,500) a.pb(p[i]);\n\tREP(i,500) b.pb(p[i+500]);\n\n\tREP(i,500) REP(j,500) if((i+j)%2==0){\n\t\tg[i][j]=1;\n\t\tg[i][j]*=a[(i+j)/2];\n\t\tg[i][j]*=b[(i-j+499)/2];\n\t}\n\n\tREP(i,500) REP(j,500) if((i+j)%2){\n\t\tg[i][j]=0;\n\n\t\tif(i+1<500) g[i][j]=lcm(g[i][j],g[i+1][j]);\n\t\tif(j+1<500) g[i][j]=lcm(g[i][j],g[i][j+1]);\n\t\tif(i) g[i][j]=lcm(g[i][j],g[i-1][j]);\n\t\tif(j) g[i][j]=lcm(g[i][j],g[i][j-1]);\n\t\tg[i][j]++;\n\t\tassert(g[i][j]<1e15);\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<g[i][j]<<\" \\n\"[j==n-1];\n\n\tREP(i,n) REP(j,n-1) assert(max(g[i][j],g[i][j+1])%min(g[i][j],g[i][j+1])==1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nlong long gcd(long long a, long long b) {\n  while (b != 0) {\n    long long t = a % b;\n    a = b;\n    b = t;\n  }\n  return abs(a);\n}\n\nlong long lcm(long long a, long long b) {\n  return a / gcd(a, b) * b;\n}\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  if (n == 2) {\n    printf(\"2 5\\n\");\n    printf(\"9 4\\n\");\n    return 0;\n  }\n  vector<vector<long long>> matrix(n, vector<long long>(n));\n  vector<bool> mark(10001);\n  vector<int> primes;\n\n  for (int i = 2; i <= 10000; i++) {\n    if (mark[i]) continue;\n    primes.push_back(i);\n    for (int j = i * i; j <= 10000; j += i) {\n      mark[j] = true;\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 1-i%2; j < n; j += 2) {\n      int diag1 = (i + j) / 2;\n      int diag2 = (i + (n-j-1)) / 2;\n      matrix[i][j] = primes[diag1] * primes[diag2 + 502];\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (((i + j)&1) == 0) {\n        long long l = 1;\n        if (i > 0) l = lcm(l, matrix[i - 1][j]);\n        if (j > 0) l = lcm(l, matrix[i][j - 1]);\n        if (i + 1 < n) l = lcm(l, matrix[i + 1][j]);\n        if (j + 1 < n) l = lcm(l, matrix[i][j + 1]);\n        if (l + 1 > 1'000'000'000'000'000ll) {\n          printf(\"Failed\\n\");\n          return 1;\n        }\n        matrix[i][j] = l + 1;\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%lld%c\", matrix[i][j], \" \\n\"[j + 1 == n]);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 260) t++;\n    rep(i, n) p.eb(P[t++]);\n    random_shuffle(all(p));\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * (i + 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * i ;\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] + a[x][y + 1] * (i+2) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i+1) + 1;\n        }\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n    cout << a[0][499] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long \nll f[1050][1050];\nint n,t,p[10050],pri[10050];\nll gcd(ll a,ll b){\n\tif (!(a%b))return b;\n\treturn gcd(b,a%b);\n}\nll lcm(int x,int y){\n\tll ret=1;\n\tif (x>1)ret=ret/gcd(f[x-1][y],ret)*f[x-1][y];\n\tif (y>1)ret=ret/gcd(f[x][y-1],ret)*f[x][y-1];\n\tif (x<n)ret=ret/gcd(f[x+1][y],ret)*f[x+1][y];\n\tif (y<n)ret=ret/gcd(f[x][y+1],ret)*f[x][y+1];\n\treturn ret+1;\n}\nint main(){\n\tfor (int i=2;t<=1050;i++){\n\t\tif (!p[i])pri[++t]=i;\n\t\tfor (int j=1;j<=t&&i*1ll*pri[j]<=10000;j++){\n\t\t\tp[i*pri[j]]=1;\n\t\t\tif (!(i%pri[j]))break;\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tint tmp=1;\n\tfor (int i=1;i<=n;i+=2,tmp++)\n\t\tfor (int x=1,y=i;x<=n&&y<=n;x++,y++)f[x][y]=pri[tmp]; \n\tfor (int i=3;i<=n;i+=2,tmp++)\n\t\tfor (int y=1,x=i;x<=n&&y<=n;x++,y++)f[x][y]=pri[tmp];\n\tfor (int i=1;i<=n;i+=2,tmp++)\n\t\tfor (int x=1,y=i;x<=n&&y;x++,y--)f[x][y]*=pri[tmp];\n\tfor (int i=(!(n&1)?2:3);i<=n;i+=2,tmp++)\n\t\tfor (int y=n,x=i;x<=n&&y;x++,y--)f[x][y]*=pri[tmp];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)if (!f[i][j])f[i][j]=lcm(i,j);\n\tif (n==2)f[2][1]=61;\n\tfor (int i=1;i<=n;i++,printf(\"\\n\"))\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",f[i][j]); \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint n,a[505][505],p[30005],vis[30005];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=30000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=30000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=p[i-j+n/2*2+1]*p[(i+j)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"complex\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\n\nlong long int N, M, K, H, W, L, R;\n\nlist<int> Prime(int num) {\n\tlist<int>P;\n\tfor (int i = 5; i <= num; i += 6) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t\tflag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (j*j > i + 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((i + 2) % j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)P.push_back(i + 2);\n\t}\n\tP.push_front(3);\n\tP.push_front(2);\n\treturn P;\n}\n\ninline long long int gcd(long long int a, long long int b) {\n\tif (a < b)a ^= b ^= a ^= b;\n\twhile (b) {\n\t\ta %= b;\n\t\ta ^= b ^= a ^= b;\n\t}\n\treturn a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tauto P = Prime(10000);\n\tlist<int>p;\n\tP.pop_front();\n\twhile (p.size() < N + 1) {\n\t\tp.push_back(P.front());\n\t\tP.pop_front();\n\t}\n\tvector<int>tate((N+1)/2);\n\tvector<int>yoko((N+1)/2);\n\tfor (int i = 0; i < (N + 1) / 2; i++) {\n\t\tif (i % 2) {\n\t\t\ttate[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\ttate[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tfor (int i = 0; i < N/2; i++) {\n\t\tif (i % 2) {\n\t\t\tyoko[i] = p.front();\n\t\t\tp.pop_front();\n\t\t}\n\t\telse {\n\t\t\tyoko[i] = p.back();\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\tvector<vector<long long int>>v(N, vector<long long int>(N));\n\tlong long int mx = 0;\n\tmap<int, int>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif ((i^j) & 1) {\n\t\t\t\tv[i][j] = tate[i / 2] * yoko[j / 2] * 2;\n\t\t\t\tif (m[v[i][j]])v[i][j] *= 2;\n\t\t\t\tm[v[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tint dir[] = { 0,1,0,-1,0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (!v[i][j]) {\n\t\t\t\tv[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = i + dir[k];\n\t\t\t\t\tint nx = j + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= N || nx >= N)continue;\n\t\t\t\t\tv[i][j] = v[i][j] / gcd(v[i][j], v[ny][nx])*v[ny][nx];\n\t\t\t\t\tv[i][j]++;\n\t\t\t\t\tif (m[v[i][j]])v[i][j] = v[i][j] * 2 - 1;\n\t\t\t\t\tm[v[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcout << v[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nlong long ans[501][501];\nlong long prime[501];\nvoid initprime() {\n\tint pn=0;\n\tlong long base=2;\n\tfor (int i=0; i<500;) {\n\t\tauto isprime = [&](long long a) {\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t\tif (a%prime[k] == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\t\t// cout<<i<<\" \"<<base<<endl;\n\t\tif (isprime(base))\n\t\t\tprime[i++] = base++;\n\t\telse\n\t\t\tbase++;\n\t}\n}\nint main() {\n\tinitprime();\n\tint n; cin>>n;\n\tif (n==2) {\n\t\tcout<<\"4 7\\n23 10\"<<endl;\n\t\treturn 0;\n\t}\n\tauto idx = [&] (int x, int y) -> int {\n\t\tint t = (x+y)/2; // t=0,1,2,3,4,5 when n==6;\n\t\treturn t%2?(n-1-t/2):t/2; };\n\n\t//prime[k] for (i,j) with k=(i+j)/2;\n\tint pcnt[500]; memset(pcnt, 0, sizeof(pcnt));\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=i%2; j<n; j+=2)\n\t\t\tans[i][j] = prime[idx(i,j)]*(i+1);\n\t\n\t// for (int i=0; i<500; i++)\n\t// \tcout<<pcnt[i]<<\" \";\n\t// cout<<endl;\n\tauto w = [&] (int x, int y) -> long long{\n\t\tif (x<0 || x>=n || y<0 || y>=n)\n\t\t\treturn 1;\n\t\treturn ans[x][y] / prime[idx(x,y)];\n\t};\n\tlong long tmax=0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=(i+1)%2; j<n; j+=2) {\n\t\t\tans[i][j] = w(i,j+1) * w(i-1,j) * w(i+1,j) * prime[idx(i,j-1)] * prime[idx(i,j+1)] + 1;\n\t\t\ttmax = max(tmax, ans[i][j]);\n\t\t}\n\t// cout<<tmax<<endl;\n\tfor (int i=0; i<n; i++, cout<<endl)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tcout<<ans[i][j]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=8000;\nint n,pri[1001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);cin>>n;\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+(abs(i-j)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tcout<<a[i][j]<<(j==n?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 260) t++;\n    rep(i, n) p.eb(P[t++]);\n    random_shuffle(all(p));\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * (i + 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * i ;\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] + a[x][y + 1] * (i+2) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i+1) + 1;\n        }\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n,now;\nint a[510][510];\nint main()\n{\n\tcin>>n;\n\tif(n&1)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++) \n\t\t\t\ta[i][j]=++now;\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i&1) for(int j=1;j<=n;j++) a[i][j]=++now;\n\t\t\telse for(int j=n;j>=1;j--) a[i][j]=++now;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) cout<<a[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nif(n==2){\nprintf(\"4 7\\n23 10\\n\");\nreturn 0;\n}\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=-((n-1)>>1);i<((n+1)>>1);i++){\ntot=min(n-i-1,n+i-1);\nfor(int j=max(i,-i);j<=tot;j++)ans[i+j][j-i]*=prime[i+n+((n-1)>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nmap<int,int>mat[2];\nint n,p[30005],vis[30005];\nll a[505][505];\nll gcd(ll x,ll y){\n\tif (!y)return x;\n\treturn gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif ((!x)||(!y))return x+y;\n\treturn x*y/gcd(x,y);\n}\nint nex(int t,int x){\n\tif (!mat[t][x])mat[t][x]=p[p[0]--];\n\treturn mat[t][x];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=10000;i++){\n\t\tif (!vis[i])p[++p[0]]=i;\n\t\tfor(int j=1;(j<=p[0])&&(i*p[j]<=10000);j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (i%p[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2)a[i][j]=nex(0,i+j)*nex(1,i-j);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nconst int maxn=1e7+10;\nll a[505][505];\nint prime[maxn],isprime[maxn],tmp;\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvoid init(int n){\n\tREP(i,2,n){\n\t\tif(!isprime[i]) prime[++tmp]=i;\n\t\tREP(j,1,tmp){\n\t\t\tif((ll)i*prime[j]>n) break;\n\t\t\tisprime[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll lcm(ll x,ll y){\n\treturn (x/__gcd(x,y))*y;\n}\nint main(){\n\tint n=read();\n\tif(n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tinit(1e7);\n\tint l=1,r=n;\n\tfor(int i=2;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=i-j;\n\t\t\tif(k>=1 && k<=n) a[j][k]=u;\n\t\t}\n\t}\n\tl=n+1,r=n*2;\n\tfor(int i=2;i<=2*n;i+=2){\n\t\tint u;\n\t\tif(i%4) u=prime[r--];\n\t\telse u=prime[l++];\n\t\tREP(j,1,n){\n\t\t\tint k=n+1+j-i;\n\t\t\tif(k>=1 && k<=n) a[j][k]*=u;\n\t\t}\n\t}\n\tREP(i,1,n) REP(j,1,n) if((i+j)&1){\n\t\ta[i][j]=1;\n\t\tREP(k,0,3){\n\t\t\tint u=i+dir[k][0],v=j+dir[k][1];\n\t\t\tif(u>=1 && u<=n && v>=1 && v<=n) a[i][j]=lcm(a[i][j],a[u][v]);\n\t\t}\n\t\ta[i][j]++;\n\t}\n\tREP(i,1,n) REP(j,1,n) printf(\"%lld%c\",a[i][j],j==jend?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ios\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(nullptr);\n#define VEC(type, name, size)\\\n    V<type> name(size);\\\n    IN(name)\n#define VVEC(type, name, h, w)\\\n    VV<type> name(h, V<type>(w));\\\n    IN(name)\n#define INT(...)\\\n    int __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LL(...)\\\n    ll __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define STR(...)\\\n    string __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define CHAR(...)\\\n    char __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define DOUBLE(...)\\\n    DOUBLE __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LD(...)\\\n    LD __VA_ARGS__;\\\n    IN(__VA_ARGS__)\ntemplate <class T> void scan(T &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((ll)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T Roundup_div(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nconst ll INF = 1e18;\n#pragma endregion\n\nint N = 500;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ninline bool inside(int x, int y) {return x >= 0 and x < N and y >= 0 and y < N;}\n\nV<> prime;\nvector<bool> ip(10010, true);\nvoid er(){\n    ip[0] = ip[1] = 0;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) for(int j = 2 * i; j <= 10000; j += i) ip[j] = false;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) prime.pb(i);\n}\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;};\n\nint main(){\n    ios;\n    er();\n    INT(n);\n    VV<> res(N, V<>(N, 1));\n    REP(i, N) REP(j, N) if(!((i + j) % 2)) res[i][j] = prime[(i + j) / 2];\n    map<ll,ll> exi;\n    REP(i, N / 2){\n        int x = 0, y = i * 2;\n        while(x < N and y < N){\n            res[x][y] *= prime[i];\n            exi[res[x][y]]++;\n            x++; y++;\n        }\n    }\n    REP(i, N / 2 - 1){\n        int x = i * 2 + 2, y = 0;\n        while(x < N and y < N){\n            res[x][y] *= prime[N - i - 1];\n            exi[res[x][y]]++;\n            x++; y++;\n        } \n    }\n    REP(i, N) REP(j, N){\n        if(((i + j) % 2)){\n            REP(k, 4){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(inside(nx, ny)) res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n        }\n    }\n    REP(i, N) REP(j, N) if(((i + j) % 2)){\n        ll t = res[i][j];\n        res[i][j]++;\n        while(exi[res[i][j]]) res[i][j] += t;\n        exi[res[i][j]]++;\n    }\n    REP(i, n){  \n        REP(j, n) cout << res[i][j] << \" \"; cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=400 +117;\nconst int MM=10000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL ans[NN][NN]={};\nLL lcm(LL a,LL b){\n\treturn a/__gcd(a,b)*b;\n}\nint pr[MM]={},psiz=0;\nint np[MM]={};\nvoid getprime(int n){\n\tnp[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(!np[i]){\n\t\t\tpr[psiz++]=i;\n\t\t}\n\t\tfor(int j=0;pr[j]*i<=n;++j){\n\t\t\tnp[pr[j]*i]=1;\n\t\t\tif(!(i%pr[j]))break;\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tif(n==2){\n\t\tprintf(\"2 5\\n\");\n\t\tprintf(\"7 36\\n\");\n\t\treturn 0;\n\t}\n\tgetprime(10000);\n\tint mn=(1-n)/2,mx=(n-1)/2;\n\tmx-=mn;\n\tfor(int i=0;i<=n+1;++i){\n\t\tfor(int j=0;j<=n+1;++j){\n\t\t\tans[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif((i+j)&1)continue;\n\t\t\tint c=(i-j)/2;\n\t\t\tint d=(i+j)/2;\n\t\t\tLL res=pr[c-mn]*pr[mx+d];\n\t\t\tans[i][j]=res;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif((i+j)&1){\n\t\t\t\tLL now=1;\n\t\t\t\tnow=lcm(now,ans[i][j-1]);\n\t\t\t\tnow=lcm(now,ans[i][j+1]);\n\t\t\t\tnow=lcm(now,ans[i-1][j]);\n\t\t\t\tnow=lcm(now,ans[i+1][j]);\n\t\t\t\tans[i][j]=now+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define INF (1ll<<60)\n\n\nlong long M = 1000000007;\n\nlong long gcd(long long x, long long y){\n    if(y==0)return x;\n    return gcd(y,x%y);\n}\n\nint main(int argc, char const *argv[]) {\n    int n;cin>>n;\n    set<long long> used;\n    n+=4;\n    vector<vector<long long>> res(n,vector<long long>(n,-1));\n    long long s = 2;\n    for(int i=1;i<n-1;++i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            // if((tmpi==0&tmpk==0)||(tmpi==0&tmpk==4)||(tmpi==4&tmpk==2)||(tmpi==4&tmpk==6)){\n            if((tmpi==0&tmpk==0)||(tmpi==4&tmpk==2)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                while(used.find(s)!=used.end())s+=1;\n            }\n        }\n    }\n    for(int i=n-2;i>0;--i){\n        for(int k=1;k<n-1;++k){\n            int tmpi = (i+k)%8,tmpk = (((i-k)%8)+8)%8;\n            if((tmpi==0&tmpk==4)||(tmpi==4&tmpk==6)){\n                long long ss = s;\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i-1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i+1][k] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k-1] = ss;\n                used.insert(ss);\n                while(used.find(ss)!=used.end())ss*=2;\n                res[i][k+1] = ss;\n                used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i-1][k] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i+1][k] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i][k-1] = ss;\n                // used.insert(ss);\n                // while(used.find(ss)!=used.end())ss+=s;\n                // res[i][k+1] = ss;\n                // used.insert(ss);\n                while(used.find(s)!=used.end())s+=1;\n            }\n        }\n    }\n    for(int i=2;i<n-2;++i){\n        for(int k=2;k<n-2;++k){\n            if((i+k)%2==0){\n                long long tmp = 1,tt;\n                tt = res[i+1][k];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i-1][k];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i][k+1];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = res[i][k-1];\n                if(tt!=-1)tmp=tmp*tt/gcd(tmp,tt);\n                tt = 1;\n                while(used.find(tt*tmp+1)!=used.end())tt++;\n                res[i][k] = tt*tmp+1;\n                used.insert(tt*tmp+1);\n            }\n        }\n    }\n    for(int i=2;i<n-2;++i){\n        for(int k=2;k<n-2;++k){\n            cout<<res[i][k]<<\" \";\n        }\n        cout<<endl;\n    }\n    auto itr = used.end();\n    itr--;\n    // cout<<*itr<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\nusing namespace std;\n#define m int64_t\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nmain(){m n;cin>>n;m t=0,k=555;r(2,i,1e4){bool a=1;r(2,j,i){if(i%j==0)a=0;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<9, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define lcm(x, y) (((x)/__gcd(x, y))*(y))\n\nbool prime(int a) {\n\tfor(int d = 2; d*d <= a; d++) if(a%d == 0) return 0;\n\treturn 1;\n}\n\nint n;\nll mat[maxn][maxn];\nvoid check() {\n\tll m = max(mat[0][0], mat[0][1]) % min(mat[0][0], mat[0][1]);\n\tfor(int i = 0; i + 1 < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(max(mat[i][j], mat[i + 1][j]) % min(mat[i][j], mat[i + 1][j]) != m) exit(-1); //cout << i << \" \" << j << \" \" << \"d\\n\";\n\tfor(int j = 0; j + 1 < n; j++)\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(max(mat[i][j], mat[i][j + 1]) % min(mat[i][j], mat[i][j + 1]) != m) exit(-1); //cout << i << \" \" << j << \" \" << \"f\\n\";\n\tll mcnt = 0;\n\tmap<ll, ll> cnt;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tmcnt = max(mcnt, ++cnt[mat[i][j]]);\n\tif(mcnt > 1) exit(-1); //cout << \"BAD\\n\";\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tn+=2;\n\tvi a, b;\n\tfor(int i = 2; b.size() < n; i++) {\n\t\tif(!prime(i)) continue;\n\t\tif(a.size() < n) {\n\t\t\tif(a.size()) {\n\t\t\t\ta.pb(a.back()*i);\n\t\t\t}\n\t\t\ta.pb(i);\n\t\t} else {\n\t\t\tif(b.size()) {\n\t\t\t\tb.pb(b.back()*i);\n\t\t\t}\n\t\t\tb.pb(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tmat[i][j] = a[i] * b[j/2];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = 1;\n\t\t\tif(i) g = lcm(g, mat[i-1][j]);\n\t\t\tif(i+1 < n) g = lcm(g, mat[i+1][j]);\n\t\t\tif(j) g = lcm(g, mat[i][j-1]);\n\t\t\tif(j+1 < n) g = lcm(g, mat[i][j+1]);\n\t\t\tmat[i][j] = g + 1;\n\t\t}\n\tset<ll> found;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = (i&1); j < n; j+=2) {\n\t\t\tll g = mat[i][j]-1;\n\t\t\twhile(found.count(mat[i][j])) mat[i][j] += g;\n\t\t\tfound.insert(mat[i][j]);\n\t\t}\n\tn-=2;\n\tll mx = 0;\n\tfor(int i = 0; i < n; i++, cout << '\\n')\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t\tmx = max(mx, mat[i][j]);\n\t\t}\n\tcheck();\n\tif(mx > 1e15) exit(-1);\n}\n//\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nint n;\nll a[505][505];\nstd::set<ll> s;\n\ninline bool chk(int x) {\n    for(int i = 2; i *i <= x; ++i) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    vector<int> v;\n    for(int i = 2; ; ++i) {\n        if(chk(i)) {\n            v.pb(i); \n        }\n        if(v.size() == 600) break;\n    }\n\n    read(n);\n    int cnt = 1;\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)&1) {\n                a[i][j] = v[i/2] * v[j/2+300];\n                s.insert(a[i][j]);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            if((i+j)%2==0) {\n                ll lcm = 1;\n                if(i>1) lcm = lcm * a[i-1][j] / std::__gcd(a[i-1][j], lcm);\n                if(i<n) lcm = lcm * a[i+1][j] / std::__gcd(a[i+1][j], lcm);\n                if(j>1) lcm = lcm * a[i][j-1] / std::__gcd(a[i][j-1], lcm);\n                if(j<n) lcm = lcm * a[i][j+1] / std::__gcd(a[i][j+1], lcm);\n\n                ll temp = lcm;\n                while(s.count(temp + 1)) temp += lcm;\n\n                assert(temp <= (ll)1e15);\n                a[i][j] = temp + 1;\n                s.insert(temp + 1);\n            }\n        }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) {\n            printf(\"%lld \", a[i][j]);\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=505,MAXM=1e4+5;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,N,cnt,p[MAXM],vis[MAXM],v[MAXN*3];ll ans[MAXN][MAXN];\ninline void pre(int n=1e4){\n\tRep(i,2,n){\n\t\tif(!vis[i])p[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}\n}ll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}\ninline ll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint main(){\n\tpre(),n=read();if(n==2){puts(\"4 7\\n23 10\");return 0;}N=1;\n\tRep(i,1,n)Rep(j,1,n)if((i+j)&1){if(!v[i-j+n])v[i-j+n]=p[++N];ans[i][j]=v[i-j+n];}\n\tmemset(v,0,sizeof(v));\n\tRep(i,1,n)Rep(j,1,n)if((i+j)&1){if(!v[i+j])v[i+j]=p[++N];ans[i][j]*=v[i+j];}\n\tRep(i,1,n)Rep(j,1,n)if(!((i+j)&1)){\n\t\tans[i][j]=1;\n\t\tif(i>1)ans[i][j]=lcm(ans[i][j],ans[i-1][j]);if(j>1)ans[i][j]=lcm(ans[i][j],ans[i][j-1]);\n\t\tif(i<n)ans[i][j]=lcm(ans[i][j],ans[i+1][j]);if(j<n)ans[i][j]=lcm(ans[i][j],ans[i][j+1]);\n\t}Rep(i,1,n){Rep(j,1,n)cout<<ans[i][j]<<' ';cout<<'\\n';}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cassert>\nusing namespace std;\nlong long gcd(long long a,long long b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint n;\nmap<long long,bool>mp;\nlong long a[510][510];\nbool used[250050];\nint p[250050],cnt;\nlong long calc(int i,int j)\n{\n\tlong long res=1,s;\n\tif(i>1)res=res/gcd(res,a[i-1][j])*a[i-1][j];\n\tif(i<500)res=res/gcd(res,a[i+1][j])*a[i+1][j];\n\tif(j>1)res=res/gcd(res,a[i][j-1])*a[i][j-1];\n\tif(j<500)res=res/gcd(res,a[i][j+1])*a[i][j+1];\n\ts=res;\n\twhile(mp[s+1])s+=res;\n\tmp[s+1]=1;\n\tif(s+1>1e15)assert(0);\n\treturn s+1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=62500;++i)\n\t{\n\t\tp[++cnt]=2*i+1;\n\t\tp[++cnt]=4*i+2;\n\t\tmp[2*i+1]=1,mp[4*i+2]=1;\n\t}\n\tint st=1,ed=125000;\n\tfor(int i=1;i<=499;i+=2)\n\t\tfor(int j=1;j<=499;j+=2)\n\t\t{\n\t\t\tif((i+j)&3)a[i][j+1]=p[st++],a[i+1][j]=p[st++];\n\t\t\telse a[i][j+1]=p[ed--],a[i+1][j]=p[ed--];\n\t\t}\n\tfor(int i=1;i<=500;++i)\n\t\tfor(int j=2-(i&1);j<=500;j+=2)a[i][j]=calc(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing LL = long long;\nconst int N = 50000;\nint n, sie[N], pr[N], pt, now;\nLL a[505][505];\nvoid sieve() {\n\tfor (int i = 2; i < N; i++) {\n\t\tif (!sie[i]) pr[++pt] = i;\n\t\tfor (int j = 1, t; j <= pt && (t = i * pr[j]) < N; j++) {\n\t\t\tsie[t] = 1;\n\t\t\tif (i % pr[j] == 0) break; \n\t\t}\n\t}\n}\nLL lcm(LL x, LL y) { if (x == 0) return y; if (y == 0) return x; return x / std::__gcd(x, y) * y; }\n#define P(number) namespace map##number {\\\nint vis[N];\\\nint map(int x) {\\\n\tstatic int *vis = map##number::vis + N / 2;\\\n\tif (vis[x]) return vis[x];\\\n\telse return vis[x] = pr[now++];\\\n}\\ \n}\nP(0) P(1)\nint main() {\n\tstd::scanf(\"%d\", &n);\n\tif (n == 2) { std::puts(\"2 3\\n5 4\\n\"); return 0; }\n\tsieve(); now = 2;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if (i + j & 1) {\n\t\t\ta[i][j] = map0::map(i + j >> 1) * map1::map(i - j >> 1);\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) if (!a[i][j]) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i + 1][j]), lcm(a[i][j + 1], a[i][j - 1])) + 1;\n\t\t}\n\tfor (int i = 1; i <= n; i++, std::puts(\"\"))\n\t\tfor (int j = 1; j <= n; j++) std::printf(\"%lld \", a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n,cnt,p[N],vis[N];\nll a[510][510];\nconst int dx[]={0,0,1,-1};\nconst int dy[]={-1,1,0,0};\nll _lcm(ll x, ll y) {\n\tif (!y) return x;\n\treturn x/gcd(x,y)*y;\n}\nint main() {\n\tREP(i,2,N-1) if (!vis[i]) for (int j=2*i; j<N; j+=i) vis[j] = 1;\n\tREP(i,2,N-1) if (!vis[i]) p[++cnt] = i;\n\tcin>>n;\n\tif (n==2) return puts(\"4 7\\n23 10\"),0;\n\tREP(i,1,n) REP(j,1,n) if (i+j&1) a[i][j] = p[(i+j)/2];\n\tREP(i,1,n) REP(j,1,n) if (i+j&1) a[i][j] *= p[(i-j+n-1)/2+n];\n\tREP(i,1,n) REP(j,1,n) if (!a[i][j]) {\n\t\tll x = 1;\n\t\tREP(d,0,3) {\n\t\t\tint ii=i+dx[d],jj=j+dy[d];\n\t\t\tx = _lcm(x,a[ii][jj]);\n\t\t}\n\t\ta[i][j] = x+1;\n\t}\n\tREP(i,1,n) {\n\t\tREP(j,1,n) cout<<a[i][j]<<' ';hr;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\treturn a * b / gcd(a, b);\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p > MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = primes[(i - j + N + 2)] * primes[i + j + 2 * N + 4];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\n#define int long long\n\nint gcd(int x, int y) {\n\treturn (!y) ? x : gcd(y, x % y);\n}\n\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint n, A[N][N], pr[N], cnt;\nbitset <100005> isp;\n\nvoid prework(int tot) {\n\tfor(int i = 1; i < 100005; ++ i) isp[i] = 1;\n\tisp[1] = 0;\n\tfor(int i = 1; cnt < tot; ++ i) {\n\t\tif(isp[i]) pr[++ cnt] = i;\n\t\tfor(int j = 1; j <= cnt && pr[j] * i <= 100000; ++ j) {\n\t\t\tisp[i * pr[j]] = 0;\n\t\t\tif(i % pr[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmain() {\n\tisp = 0;\n\tcin >> n;\n\tn += 2;\n\tprework(n * 2 + 2);\n\t//for(int i =1; i <= cnt; ++ i) cerr << pr[i] << \" \";\n\t//puts(\"\");\n\tfor(int i = 0; i <= n + 1; ++ i) {\n\t\tfor(int j = 0; j <= n + 1; ++ j) {\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i = 1; i <= n; i += 2) {\n\t\tint nx = i, ny = 1;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 3; i <= n; i += 2) {\n\t\tint nx = 1, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx <= n && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t++ nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n; i >= 1; i -= 2) {\n\t\tint nx = n, ny = i;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\t\n\tfor(int i = n - ((n & 1) ^ 1); i >= 1; i -= 2) {\n\t\tint nx = i, ny = 1;\n\t\tif(i == n) continue;\n\t\tint G = pr[++ now];\n\t\twhile(nx && ny <= n) {\n\t\t\tA[nx][ny] *= G;\n\t\t\t-- nx, ++ ny;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif((i + j) & 1) {\n\t\t\t\t//cerr << i <<\" \" << j << endl;\n\t\t\t\t//cerr << A[i][j - 1] <<\" \" << A[i - 1][j] <<\" \" << A[i + 1][j] <<\" \" << A[i][j + 1] << endl;\n\t\t\t\tA[i][j] = lcm(lcm(A[i][j - 1], A[i - 1][j]), lcm(A[i + 1][j], A[i][j + 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2; i <= n - 1; ++ i) {\n\t\tfor(int j = 2; j <= n - 1; ++ j) printf(\"%lld \", A[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define REP1(i,a) for(int i=1;i<=(a);i++)\n#define rREP(i,a) for(int i=(a-1);i>=0;i--)\n#define rREP1(i,a) for(int i=(a);i>0;i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a, ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a, ll b){return a/gcd(a,b)*b;}\n\nll sgn(ll n){\n    if(n==0) return 0;\n    else return n/abs(n);\n}\n\nll salv(vll v){\n  say(\"{\");\n  FOR(i,0,v.sz-1){\n    say(v[i]);\n    if(i!=v.sz-1) say(\",\");\n  }\n  sal(\"}\")\n}\n\nll DigS10(ll n){\n  ll m=0;\n  FOR(i,0,DigN10(n)-1){\n    m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n  }\n  return m;\n}\n\nll isP(ll n){\n  if(n<=1) return 0;\n  FOR(i,2,(ll)sqrt(n)){\n    if(n%i==0) return 0;\n  }\n  return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n  ll ans=1,x=(a%MOD);\n  FOR(i,0,DigN2(b)-1){\n    if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n    if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n  }\n  return ans;\n}\n\nvoid CFactM(ll n){\n  FOR(i,FactM.sz,n){\n    FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n  }\n  return;\n}\n\nvoid CFactMI(ll n){\n  CFactM(n);\n  if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n  if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n  rFOR(i,1,n-1){\n    if(FactMI[i]!=-1) break;\n    FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n  }\n  return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n  ll n,m,a[500][500],x,y;\n  cin >> n;\n  x=y=(n-1)/2;\n  a[x][y]=2;\n  REP(i,n-1){\n    if(i%2){\n      x--;\n      a[x][y]=a[x+1][y]+1;\n      REP(j,i){\n        y--;\n        a[x][y]=lcm(a[x][y+1],a[x+1][y])+1;\n      }\n      y--;\n      a[x][y]=a[x][y+1]+1;\n      REP(j,i+1){\n        x++;\n        a[x][y]=lcm(a[x][y+1],a[x-1][y])+1;\n      }\n    } else {\n      x++;\n      a[x][y]=a[x-1][y]+1;\n      REP(j,i){\n        y++;\n        a[x][y]=lcm(a[x][y-1],a[x-1][y])+1;\n      }\n      y++;\n      a[x][y]=a[x][y-1]+1;\n      REP(j,i+1){\n        x--;\n        a[x][y]=lcm(a[x][y-1],a[x+1][y])+1;\n      }\n    }\n  }\n  REP(i,n){\n    REP(j,n){\n      cout << a[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int maxn=500+5;\nconst int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint n;\nint ncnt,val0[maxn<<1],val1[maxn<<1];\nll an[maxn][maxn];\nbool mark[20005];\nvector<int> prime; \nll gcd(ll a,ll b) {return b==0?a:gcd(b,a%b);}\nvoid init(int n) {\n\tfor(int i=2;i<=n;++i) {\n\t\tif(!mark[i]) {\n\t\t\tprime.push_back(i);\n\t\t}\n\t\tfor(int j=0;j<prime.size();++j) {\n\t\t\tint x=i*prime[j]; if(x>n) break;\n\t\t\tmark[x]=1;\n\t\t\tif(i%prime[j]==0) break; \n\t\t}\n\t}\n}\nint main() {\n\trd(n);\n\tif(n==2) {\n\t\tputs(\"4 7\"),puts(\"23 10\");\n\t\treturn 0;\n\t}\n\tinit(20000);\n\tfor(int i=0;i<=n+1;++i) for(int j=0;j<=n+1;++j) {\n\t\tif(!val0[i+j]) val0[i+j]=prime[ncnt++];\n\t\tif(!val1[i-j+n+1]) val1[i-j+n+1]=prime[ncnt++];\n\t}\n\tfor(int i=0;i<=n+1;++i) for(int j=0;j<=n+1;++j) if((i+j)&1) {\n\t\tan[i][j]=val0[i+j]*val1[i-j+n+1];\n\t}\n\tfor(int x=1;x<=n;++x) for(int y=1;y<=n;++y) if(((x+y)^1)&1) {\n\t\tan[x][y]=1;\n\t\tfor(int k=0;k<4;++k) {\n\t\t\tint _x=x+dx[k],_y=y+dy[k];\n\t\t\tan[x][y]=an[x][y]/gcd(an[x][y],an[_x][_y])*an[_x][_y];\n\t\t}\n\t\t++an[x][y];\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(j!=1) printf(\" \");\n\t\t\tprintf(\"%lld\",an[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int N = 505, P = 10005;\nint p[P], pc = 0;\nbool np[P];\nvoid prime_sieve(int n) {\n  for (int i = 2; i <= n; ++i) {\n    if (!np[i]) p[pc++] = i;\n    for (int j = 0; j < pc && i * p[j] <= n; ++j) {\n      np[i * p[j]] = true;\n      if (i % p[j] == 0) break;\n    }\n  }\n}\n\nll a[N][N];\n\nll gcd(ll x, ll y) {\n  ll t;\n  while (y) t = x, x = y, y = t % y;\n  return x;\n}\nll lcm(ll x, ll y) {\n  if (!x || !y) return x | y;\n  return x / gcd(x, y) * y;\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint n;\nint border(int x, int y) {\n  return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nint main() {\n  prime_sieve(10000);\n  read(n);\n  if (n == 2) {\n    write(4, 7), endl();\n    write(23, 10), endl();\n    return 0;\n  }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) {\n      if (((i ^ j) & 1) == 0) {\n        int l1 = (i + j) / 2;\n        int l2 = n + ((i - j) / 2) + (n - 1) / 2;\n        a[i][j] = p[l1] * p[l2];\n      }\n    }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (!a[i][j]) {\n        a[i][j] = 1;\n        for (int d = 0; d < 4; ++d)\n          if (border(i + dx[d], j + dy[d]))\n            a[i][j] = lcm(a[i][j], a[i + dx[d]][j + dy[d]]) + 1;\n      }\n      write(a[i][j]), space();\n    }\n    endl();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll a[505][505];\nbool chk[23333333];\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nint nxtPrime(int&x){\n    auto chk=[&](int x){\n        if(x<2)return false;\n        for(int i=2;i*i<=x;i++)\n            if(x%i==0)\n                return false;\n        return true;\n    };\n    do x++;while(!chk(x));\n    ::chk[x]=true;\n    return x;\n}\nint main(){\n    int n,p=0;cin>>n;\n    if(n==2)return puts(\"4 7\\n23 10\"),0;\n    for(int i=1,j=n-(~n&1);i<=n;i++,j--)\n        if(!a[i][j]&&1<=j&&j<=n)\n            a[i][j]=nxtPrime(p);\n    for(int i=n,j=n;i>=1;i--,j--)\n        if(!a[i][j])\n            a[i][j]=nxtPrime(p);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)%2==0){\n                if(a[i][j])continue;\n                auto get=[&](int dx,int dy)->ll{\n                    int x=i,y=j;\n                    while(1<=x&&x<=n&&1<=y&&y<=n){\n                        if(chk[a[x][y]])return a[x][y];\n                        x+=dx,y+=dy;\n                    }\n                    return 1;\n                };\n                a[i][j]=get(+1,+1)*get(+1,-1)*get(-1,+1)*get(-1,-1);\n            }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if((i+j)%2==1){\n                auto upd=[&](int dx,int dy){\n                    if(a[i+dx][j+dy])\n                        a[i][j]=lcm(a[i][j],a[i+dx][j+dy]);\n                };\n                a[i][j]=1;\n                upd(+1,0);\n                upd(-1,0);\n                upd(0,+1);\n                upd(0,-1);\n                a[i][j]++;\n            }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cout<<a[i][j]<<\" \\n\"[j==n];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nint a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {-1, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15);\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 10000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\n\nll a[505][505];\nll gcd(ll a, ll b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> p;\n\tfor (int i = 2; p.size() < 2 * n; ++i)\n\t\tif (prime(i)) p.push_back(i);\n\tauto it = p.begin();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!(i + j & 1)) a[i][j] = 1;\n\tfor (int d = 2; d < 2 * n; d += 2, ++it)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (d - i >= 1 && d - i <= n)\n\t\t\t\ta[i][d - i] *= *it;\n\tfor (int d = n & 1; d < 2 * n; d += 2, ++it)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (d + i - n >= 1 && d + i - n <= n)\n\t\t\t\ta[i][d + i - n] *= *it;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (i + j & 1) {\n\t\t\t\tconst int D[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\t\t\ta[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint x = i + D[k][0], y = j + D[k][1];\n\t\t\t\t\tif (x >= 1 && x <= n && y >= 1 && y <= n)\n\t\t\t\t\t\ta[i][j] = a[i][j] / gcd(a[i][j], a[x][y]) * a[x][y];\n\t\t\t\t}\n\t\t\t\t++a[i][j];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld%c\", a[i][j], \" \\n\"[j == n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Author: hotaruijika\n * Created: 2018.09.15 23:58:01\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n;\nlong long f[11111], a[500 * 500 + 10], color[500 * 500 + 10];\nmap <int, int> id;\nvector <long long> prime;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 2; i <= 1e4 + 10; ++i) {\n\t\tif (!f[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tf[i] = i;\n\t\t}\n\t\tfor (int j = 0; j < (int) prime.size() && i * prime[j] <= 1e4 && prime[j] <= f[i]; ++j) \n\t\t\tf[i * prime[j]] = prime[j];\n\t}\n\tint cnt = 0; color[1] = 1;\n\tfor (int i = 2; i <= n * n; ++i) {\n\t\tint x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tfor (int k = 0; k < 4; ++k) if (x + dx[k] > 0 && x + dx[k] <= n && y + dy[k] > 0 && y + dy[k] <= n) {\n\t\t\tcolor[i] |= color[(x + dx[k] - 1) * n + y + dy[k]];\n\t\t\t//cerr << i << \" \" << (x + dx[i] - 1) * n + y + dy[i] << \"\\n\";\n\t\t}\n\t\tcolor[i] = 1 - color[i];\n\t\tif (color[i]) continue;\n\t\tif (!id.count(x + y)) id[x + y] = cnt++;\n\t\tif (!id.count(x - y)) id[x - y] = cnt++;\n\t\ta[i] = prime[id[x + y]] * prime[id[x - y]];\n\t}\n\t//for (int i = 1; i <= n * n; ++i) cerr << a[i] << (i % n == 0 ? \"\\n\" : \" \");\n\tfor (int i = 1; i <= n * n; ++i) if (color[i]) {\n\t\tlong long lcm = 1, x = i / n + !!(i % n), y = i - (x - 1) * n;\n\t\tfor (int k = 0; k < 4; ++k) if (x + dx[k] > 0 && x + dx[k] <= n && y + dy[k] > 0 && y + dy[k] <= n) {\n\t\t\tlcm = lcm / __gcd(a[(x + dx[k] - 1) * n + y + dy[k]], lcm) * a[(x + dx[k] - 1) * n + y + dy[k]];\n\t\t}\n\t\ta[i] = lcm + 1;\n\t}\n\tfor (int i = 1; i <= n * n; ++i) cout << a[i] << (i % n == 0 ? \"\\n\" : \" \");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<long long> pr;\n    for (int i=2; pr.size()<=1000; i++){\n        bool bre = false;\n        for (int j=0; j<pr.size(); j++){\n            if (i%pr[j]==0){\n                bre = true;\n                break;\n            }\n        }\n        if (bre) continue;\n        pr.push_back(i);\n    }\n    vector<long long> helper(n);\n    vector<vector<long long> > A(n, helper);\n    A[0][0] = 1;\n    for (int i=1; i<n; i++){\n        A[i][0] = pr[i-1];\n    }\n\n    for (int i=1; i<n; i++){\n        A[0][i] = pr[n+i-2];\n    }\n\n    for (int i=0; i<n; i++){\n        for (int j=0; j<n; j++){\n            cout << A[i][0]*A[0][j] << \" \";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,s,n) for(ll i = s; i < n; i++)\nconst ll maxn = 505;\nll ans[maxn][maxn];\nll integer[10005];\nvector<ll> p;\nll n;\nll dx[] = {0,0,1,-1};\nll dy[] = {1,-1,0,0};\n\nvoid generatingprimes(){\n\trep(i,2,10005){\n\t\twhile(integer[i])i++;\n\t\tp.push_back(i);\n\t\tfor(ll j = 2*i; j < 10000; j+=i){\n\t\t\tinteger[j] = 1;\n\t\t}\n\t}\n\t// for(auto prime:p)cout<<prime<<\" \";\n\treturn;\n}\n\ninline ll entry(ll a, ll b){\n\treturn p[(a+b)/2]*p[(a-b)/2+749];\n}\n\ninline ll lcm(ll a, ll b){\n\treturn a*(b/__gcd(a,b));\n}\n\nint main(){\n\tcin>>n;\n\tgeneratingprimes();\n\t// cout<<p[1000]<<endl;\n\trep(i,0,n){\n\t\tif(i%2==1)for(ll j = 1; j < n; j+=2){\n\t\t\tans[i][j] = entry(i,j);\n\t\t}else for(ll j = 0; j < n; j+=2){\n\t\t\tans[i][j] = entry(i,j);\n\t\t}\n\t}\n\trep(i,0,n){\n\t\tif(i%2==0) for(ll j = 1; j<n; j+=2){\n\t\t\tll tmp = 1;\n\t\t\trep(k,0,4){\n\t\t\t\tll nx = i+dx[k];ll ny =j+dy[k];\n\t\t\t\tif(nx>=n||nx<0||ny>=n||ny<0)continue;\n\t\t\t\ttmp = lcm(tmp,ans[nx][ny]);\n\t\t\t}\n\t\t\tans[i][j] = tmp+1;\n\t\t}else for(ll j = 0; j < n; j+=2){\n\t\t\tll tmp = 1;\n\t\t\trep(k,0,4){\n\t\t\t\tll nx = i+dx[k];ll ny =j+dy[k];\n\t\t\t\tif(nx>=n||nx<0||ny>=n||ny<0)continue;\n\t\t\t\ttmp = lcm(tmp,ans[nx][ny]);\n\t\t\t}\n\t\t\tans[i][j] = tmp+1;\n\t\t}\n\t}\n\tif(n==2)ans[0][1] = (ans[1][0]-1)*2+1;\n\trep(i,0,n){\n\t\trep(j,0,n){\n\t\t\tcout<<ans[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 5e6, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\tfor (int i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_front(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tans[i][j] = vec1.front();\n\t\t\t\t\tvec1.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[i][j] = vec2.back();\n\t\t\t\t\tvec2.pop_back();\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml *= ans[i - 1][j];\n\t\t\t\tif (j > 0) ml *= ans[i][j - 1];\n\t\t\t\tif (i < n - 1) ml *= ans[i + 1][j];\n\t\t\t\tif (j < n - 1) ml *= ans[i][j + 1];\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#undef NDEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\nusing ld = long double;\n\nvoid solve(bool);\n\n//#define YA\n\nint main() {\n#ifdef YA\n    auto s = clock();\n    assert(freopen(\"input.txt\", \"r\", stdin));\n#else\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    cout << fixed << setprecision(20);\n\n    solve(true);\n\n#ifdef YA1\n    while (true) solve(false);\n#endif\n\n#ifdef YA\n    cerr << endl << endl << \"time = \" << (clock() - s) / (double)CLOCKS_PER_SEC << endl;\n#endif\n\n    return 0;\n}\n\nconst int MX = (int)1e7;\n\nint p[MX + 5];\nvector <li> pr;\nint cnt = 8;\nint last = 0;\nli a[555][555];\n\nvoid solve(bool __attribute__((unused)) read) {\n    for (int i = 2; i <= MX; ++i) {\n        if (p[i])\n            continue;\n        if (i != 2)\n            pr.push_back(i);\n        for (li j = (li)i * i; j <= MX; j += i)\n            p[j] = 1;\n    }\n    int n;\n    cin >> n;\n    int u = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 0) {\n                if (last == cnt) {\n                    ++u;\n                    last = 0;\n                }\n                a[i][j] = (1ll << last) * pr[u];\n                ++last;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                vector <li> vc;\n                li z = 1;\n                for (int x = -1; x <= 1; ++x) {\n                    for (int y = -1; y <= 1; ++y) {\n                        if (abs(x) + abs(y) != 1 || i + x < 0 || i + x >= n || j + y < 0 || j + y >= n)\n                            continue;\n                        vc.push_back(a[i + x][j + y]);\n                        z = z * a[i + x][j + y] / __gcd(z, a[i + x][j + y]);\n                    }\n                }\n                a[i][j] = z;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long arr[503][503] , N , M; bool nprm[10003];\n\nlong long LCM(long long a , long long b){return a * b / __gcd(a , b);}\n\nint main(){\n\tint t = 0; bool flg = 0;\n\tfor(int i = 0 ; i <= 502 ; ++i)\n\t\tfor(int j = 0 ; j <= 502 ; ++j)\n\t\t\tarr[i][j] = 1;\n\tfor(int i = 2 ; i <= 1e4 ; ++i)\n\t\tif(!nprm[i]){\n\t\t\t++t;\n\t\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\t\tif(2 * t - j > 0 && 2 * t - j <= 501)\n\t\t\t\t\tarr[j][2 * t - j] *= i;\n\t\t\tif(t == 501)\n\t\t\t\tif(!flg){flg = 1; for(int i = 1 ; i <= 501 ; ++i) reverse(arr[i] + 1 , arr[i] + 502); t = 0;}\n\t\t\t\telse break;\n\t\t\tfor(int k = i ; k * i <= 1e4 ; ++k) nprm[i * k] = 1;\n\t\t}\n\tconst int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n\tfor(int i = 1 ; i <= 501 ; ++i)\n\t\tfor(int j = 1 ; j <= 501 ; ++j)\n\t\t\tif((i ^ j) & 1)\n\t\t\t\tfor(int k = 0 ; k < 4 ; ++k)\n\t\t\t\t\tarr[i][j] = LCM(arr[i][j] , arr[i + dir[k][0]][j + dir[k][1]]);\n\tcin >> N;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= N ; ++j) cout << arr[i][j] << \" \\n\"[j == N];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tif (n % 2 == 0) {\n\t\tfor (int i = 0; i < n; i += 2) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j & 1) cout << \"3 \";\n\t\t\t\telse cout << \"5 \";\n\t\t\tcout << endl;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j & 1) cout << \"5 \";\n\t\t\t\telse cout << \"3 \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < n; i += 3) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j % 3 == 0) cout << \"3 \";\n\t\t\t\telse if (j % 3 == 1) cout << \"5 \";\n\t\t\t\telse cout << \"17 \";\n\t\t\tcout << endl;\n\t\t\tif (i + 1 >= n) break;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j % 3 == 0) cout << \"5 \";\n\t\t\t\telse if (j % 3 == 1) cout << \"17 \";\n\t\t\t\telse cout << \"3 \";\n\t\t\tcout << endl;\n\t\t\tif (i + 2 >= n) break;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (j % 3 == 0) cout << \"17 \";\n\t\t\t\telse if (j % 3 == 1) cout << \"3 \";\n\t\t\t\telse cout << \"5 \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 500, M = 10000000;\nint p[M / 10], p2[10000], sz;\nll an[N][N];\nbool pr[M];\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\nint main(){\n\tfor (int i = 2; i * i < M; ++i)if (!pr[i])for (int j = i * i; j < M; j += i)pr[j] = true;\n\tf(i, 2, M)if (!pr[i])p[sz++] = i;\n\tint kk = 0;\n\tfor (int i = 1999; i > 0; i -= 3){\n\t\tp2[kk++] = p[i];\n\t\tp2[kk++] = p[i - 1];\n\t\tp2[kk++] = p[i - 2];\n\t\tp2[kk++] = p[(1999-i) / 3];\n\t\tif (kk == 2000)break;\n\t}\n\tint n;\n\tscanf(\"%d\", &n);\n\tif (n == 2) { printf(\"4 7\\n23 10\\n\"); return 0; }\n\tf(i, 0, n)f(j, 0, n)an[i][j] = 1;\n\tkk = 0;\n\tfor (int i = 0; i < n; i += 2, ++kk)for (int j = 0, z = i; j < n && z < n; ++j, ++z)an[z][j] *= p[kk];\n\tfor (int j = 2; j < n; j += 2, ++kk)for (int i = 0, z = j; i < n && z < n; ++i, ++z)an[i][z] *= p[kk];\n\tfor (int i = 0; i < 2*n - 1; i += 2, ++kk)for (int j = i < n ? 0 : i - n + 1, z = i < n ? i : n - 1; j < n && z >= 0; ++j, --z)an[z][j] *= p[kk];\n\tf(i, 0, n)for (int j = i + 1 & 1; j < n; j += 2)an[i][j] = lcm(i ? an[i - 1][j] : 1, lcm(i + 1 < n ? an[i + 1][j] : 1, lcm(j ? an[i][j - 1] : 1, j + 1 < n ? an[i][j + 1] : 1)));\n\tf(i, 0, n){\n\t\tprintf(\"%lld\", an[i][0]);\n\t\tf(j, 1, n)printf(\" %lld\", an[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint prime[maxn],ptot,mark[maxn];\n\ninline void prepare()\n{\n\tREP(i,2,1e5)\n\t{\n\t\tif(!mark[i])prime[++ptot]=i;\n\t\tfor(int j=1,k;j<=ptot && i*prime[j]<=1e5;j++)\n\t\t{\n\t\t\tk=i*prime[j]; mark[k]=1;\n\t\t\tif(!(i%prime[j]))break;\n\t\t}\n\t}\n}\n\nint n;\nll a[520][520];\nint mpa[maxn],mpb[maxn];\n\ninline void init()\n{\n\tint now=20;\n\tn=read();\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\\n\");exit(0);\n\t}\n\tREP(i,1,n)REP(j,1,n)if(i+j&1)\n\t{\n\t\tif(!mpa[i+j])\n\t\t\tmpa[i+j]=prime[++now];\n\t\tif(!mpb[i-j+n])\n\t\t\tmpb[i-j+n]=prime[++now];\n\t\ta[i][j]=1ll*mpa[i+j]*mpb[i-j+n];\n\t}\n\tREP(i,0,1e4)chkmax(mpa[i],1),chkmax(mpb[i],1);\n\tREP(i,1,n)REP(j,1,n)if(~i+j&1)\n\t{\n\t\ta[i][j]=1ll*mpa[i+j-1]*mpa[i+j+1]*mpb[i-j-1+n]*mpb[i-j+1+n]+1;\n\t}\n\tREP(i,1,n)REP(j,1,n)printf(\"%lld%c\",a[i][j],j==n?'\\n':' ');\n}\n\ninline void doing()\n{\n\t\n}\n\nint main()\n{\n\tprepare();\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cassert>\nusing namespace std;\nlong long gcd(long long a,long long b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nint n,nn;\nmap<long long,bool>mp;\nlong long a[510][510];\nbool used[250050];\nint p[250050],cnt;\nlong long calc(int i,int j)\n{\n\tlong long res=1,s;\n\tif(i>1)res=res*a[i-1][j]/gcd(res,a[i-1][j]);\n\tif(i<n)res=res*a[i+1][j]/gcd(res,a[i+1][j]);\n\tif(j>1)res=res*a[i][j-1]/gcd(res,a[i][j-1]);\n\tif(j<n)res=res*a[i][j+1]/gcd(res,a[i][j+1]);\n\ts=res;\n\twhile(mp[s+1])s+=res;\n\tmp[s+1]=1;\n\tif(s+1>1e15)assert(0);\n\treturn s+1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n&1)nn=n+1;\n\telse nn=n;\n\tint lim1=nn*nn/2+1;\n//\tfor(int i=3-(n&1);i<=n;i+=4)a[n][i]=lim1--,i!=n?a[i][n]=lim1--:0;\n//\tint ps=3-(n&1)+2;\n//\twhile(ps+4<=n)ps+=4;\n//\tfor(int i=ps;i;i-=4)a[n][i]=lim1--,i!=n?a[i][n]=lim1--:0;\n//\tfor(int i=2;i<=n;i+=2)a[1][i]=lim1--,a[i][1]=lim1--;\n\tfor(int i=1;2*i<=lim1;++i)\n\t{\n\t\tp[++cnt]=2*i+1;\n\t\tp[++cnt]=4*i+2;\n\t\tmp[2*i+1]=1,mp[4*i+2]=1;\n\t}\n//\tif(lim1&1)p[++cnt]=2;\n//\tfor(int c=2;c<=lim1/2;++c)\n//\t\tfor(int i=2;i<=lim1/c;++i)\n//\t\t\tif(3*i>=lim1&&!used[i]&&!used[c*i])\n//\t\t\t{\n//\t\t\t\tused[i]=used[c*i]=1;\n//\t\t\t\tp[++cnt]=i,p[++cnt]=c*i;\n//\t\t\t}\n//\tprintf(\"!!!\\n\");\n/*\tint l=2,r=lim1;\n\twhile(l<r)\n\t{\n\t\twhile(used[l])++l;\n\t\twhile(used[r])--r;\n\t\tp[++cnt]=l;\n\t\tif(l!=r)p[++cnt]=r;\n\t\tused[l]=1,used[r]=1;\n\t}*/\n\tint st=1,ed=lim1-(lim1&1);\n\tfor(int i=1;i<=nn-1;i+=2)\n\t\tfor(int j=1;j<=nn-1;j+=2)\n\t\t{\n\t\t\tif((i+j)&3)a[i][j+1]=p[st++],a[i+1][j]=p[st++];\n\t\t\telse a[i][j+1]=p[ed--],a[i+1][j]=p[ed--];\n\t\t}\n/*\tint l=2,r=n*n/2+1;\n\tfor(int i=1;i<=n;i+=4)p1[++len1]=i;\n\tfor(int i=2;i<=n;i+=4)p2[++len2]=i;\n\tfor(int i=3;i<=n;i+=4)p3[++len3]=i;\n\tfor(int i=4;i<=n;i+=4)p4[++len4]=i;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tfor(int j=1;j<=len2;++j)a[i][p2[j]]=r--;\n\t\t\tfor(int j=len4;j;--j)a[i][p4[j]]=r--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<=len1;++j)a[i][p1[j]]=l++;\n\t\t\tfor(int j=len3;j;--j)a[i][p3[j]]=l++;\n\t\t}\n\t}*/\n/*\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%3lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=2-(i&1);j<=n;j+=2)a[i][j]=calc(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=500 +10 , M= 2e6 + 10, dx[4] =  {1,-1,0,0}, dy[4]= {0,0,1,-1};\n\nbool vis[M];\nint n, m, prime[M],pn=0;\nLL a[N][N], b[N][N];\nvoid PrimeMap(){\n\tpn =0 ; int n = 2e6  , k = sqrt(1e5+0.5);\n\tmemset(vis, 0 , sizeof(vis));\n\tfor (int i=2; i <= k; ++i)\tif ( !vis[i] ) \n\t\tfor (int j=i+i; j<=n; j+=i) vis[j] = true;\n\t\n\tfor (int i=2; i<=n; ++i)\tif ( !vis[i] )\n\t\tprime[ pn++] = i;\n}\nset<LL> exi;\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tPrimeMap();\n\t\n\t\n\tscanf(\"%d\", &n);\n//\trandom_shuffle(prime, prime+n+n);\n\tint cur=0 ;\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( a[i][j]==0){\n\t\t\t\tfor (int x=i, y=j; x<n && y>=0 ; x++, y--)\n\t\t\t\t\ta[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\tfor (int i=0; i<n; ++i)\n\t\tfor (int j=0; j<n; ++j) if ( (i&1)^(j&1))\n\t\t\tif ( b[i][j]==0){\n\t\t\t\tfor (int x=i , y=j; x<n && y<n ; x++, y++)\n\t\t\t\t\tb[x][y] = prime[cur];\n\t\t\t\t++cur;\n\t\t\t}\n\t\n\t#ifdef che\n\tdebug(\"last = %d\\n\", prime[cur]);\n\t#endif\n\tfor (int i=0; i<n; ++i)\tfor (int j=0; j<n; ++j) if ( !a[i][j]){\n\t\tLL s=1;\n\t\tif ( i) s *= a[i-1][j];\n\t\tif ( i+1<n ) s*=a[i+1][j];\n\t\tif ( j) s*= b[i][j-1];\n\t\tif ( j+1<n ) s*=b[i][j+1];\n\t\t\n//\t\tassert(s <= LL(1e15)  );\n\t\ta[i][j] = s+1;\n\t}\n\tfor (int i=0; i<n; ++i) for (int j=0; j<n; ++j) if (b[i][j])\n\t\ta[i][j] *= b[i][j];\n\tif( n==2) a[1][1] = 2*a[1][1]-1;\n\tfor (int i=0; i<n; ++i){\n\t\tfor (int j=0 ; j<n; ++j) printf(\"%lld \", a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 250010\n#define N 1010\nusing namespace std;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint prime[maxn], tot_prime;\nll res[N][N];\nset<ll> S;\nll gcd(ll a, ll b)\n{\n\tll y = a % b;\n\twhile (y)\n\t{\n\t\ta = b;\n\t\tb = y;\n\t\ty = a % b;\n\t}\n\treturn b;\n}\nbool check(int x)\n{\n\tfor (int i = 2; i <= x - 1; i++)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tres[i][j] = 1;\n\tll T = 1e15;\n\tfor (int i = 2; i <= 10000; i++)\n\t\tif (check(i)) prime[++tot_prime] = i;\n\tint cur = 0;\n\tfor (int i = 2; i <= n + n; i += 2)\n\t{\n\t\tcur++;\n\t\tfor (int j = 1; j <= i && j <= n; j++)\n\t\t{\n\t\t\tint x = j, y = i - j;\n\t\t\tif (y <= n) res[x][y] *= prime[cur];\n\t\t}\n\t}\n\tint st = 1 - n;\n\tif (st % 2) st++;\n\tfor (int i = st; i <= n - 1; i += 2)\n\t{\n\t\tcur++;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tint x = j, y = x - i;\n\t\t\tif (x > 0 && y > 0 && x <= n && y <= n) res[x][y] *= prime[cur];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) % 2 == 0) S.insert(res[i][j]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t{\n\t\t\t\t\tint tx = i + dx[k], ty = j + dy[k];\n\t\t\t\t\tif (tx && ty && tx <= n && ty <= n) res[i][j] = res[i][j] / gcd(res[i][j], res[tx][ty]) * res[tx][ty];\n\t\t\t\t}\n\t\t\tll pre = res[i][j];\n\t\t\twhile (S.find(res[i][j]) != S.end()) res[i][j] += pre;\n\t\t\tS.insert(res[i][j]);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tprintf(\"%lld \", res[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint p[1010],b[10010],t,n;\nvoid OUT(long long v,int i,int j){\n\tprintf(\"%lld\",v);putchar(' ');\n}\nint main(){\n\tp[0]=1;\n\tfor(int i=2;i<=7919;++i){\n\t\tif(!b[i])p[++t]=i;\n\t\tif(t==500)p[++t]=1;\n\t\tfor(int j=1;j<=t&&i*p[j]<=7919;++j)if(j^501){\n\t\t\tb[i*p[j]]=1;if(i%p[j]==0)break;\n\t\t}\n\t}p[t+1]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i+j&1){\n\t\t\t\tOUT(1ll*p[i+j>>1]*p[i+j+1>>1]*p[501+(n+2-j+i>>1)]*p[501+(n-j+i>>1)]+1,i,j);\n\t\t\t}else{\n\t\t\t\tOUT(p[i+j>>1]*p[501+(n+1-j+i>>1)],i,j);\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n #ifndef PRIMES_H\n#define PRIMES_H\n\n\n\n\n#ifndef UTIL_H\n#define UTIL_H\n\n\n\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\nstruct \tUnionFind {\n\tUnionFind(size_t N) : P(N, -1), comp(N) {}\n\tint find(int x) { while (P[x]> 0){x = P[x]-1;}return x; }\n\tbool united(int x, int y) { return find(x) == find(y); }\n\tbool unite(int x, int y) { x=find(x);y=find(y);if(x==y){return false;}--comp;if(P[x]>P[y]){swap(x,y);}P[x]+=P[y];P[y]= x+1;return true;}\n\tinline ui size(int u) { return -P[find(u)]; }\n\tvector<int> P;\n\tsize_t comp;\n};\n\n/** Product of two 64-bit numbers modulo another. */\null mulull(ull a, ull z, ull mod) {\n#ifdef __SIZEOF_INT128__\n\t__int128 result = ((__int128) a * (__int128) z) % (__int128) mod;\n\treturn (ull) result;\n#else\n    // schrage method\n\tull q = mod / a, r = mod % a;\n\tull rzq = (r < q) ? r * (z/q) : mulull(r, z/q, mod);\n\tull azq = a * (z % q);\n\tif (azq >= rzq) return azq-rzq; else return azq-rzq+mod;\n#endif\n}\n\n/** Multiply two 64-bit unsigned integers to get a 128-bit unsigned integer (as a pair of ull) */\npair<ull,ull> mulull(ull a, ull b) {\n#ifdef __SIZEOF_INT128__\n\t__int128 result = (__int128) a * (__int128) b;\n\treturn {(ull) (result >> 64), (ull) result};\n#else\n\tull c = (ui)a, d = a>>32, e = (ui)b, f = b>>32, g = d*f, h = d*e, i = f*c, j = c*e, k = (j>>32)+(ui)h+(ui)i, l = g+(h>>32)+(i>>32)+(k>>32);\n\treturn {l, ((h+i) << 32) + j};\n#endif\n}\n\nbool fractionGreaterOrEqual(ll a, ll b, ll c, ll d) {\n\tif (b < 0) { b = -b; a = -a; }\n\tif (d < 0) { d = -d; c = -c; }\n\treturn a < 0 && c < 0 ? mulull(-a, d) <= mulull(-c, b) : (a >= 0) && (c < 0 || mulull(a, d) >= mulull(c, b));\n}\n\nbool fractionGreaterOrEqual(pair<ll, ll> a, pair<ll, ll> b) {\n\treturn fractionGreaterOrEqual(a.x, a.y, b.x, b.y);\n}\n\n\nbool fractionGreaterOrEqual(double a, double b, double c, double d) {\n\treturn a/b >= c/d;\n}\n\n// this is based on modulus, but it's 2-3 times slower than the former\n//bool fractionGreaterOrEqual(ll a, ll b, ll c, ll d) {\n//\tif (a<0 && c<0) return greaterOrEqual(-c,d,-a,b);\n//\tif (a<0) return false;\n//\tif (c<0) return true;\n//\tif (b==0) return true;\n//\tif (d==0) return false;\n//\tll ab = a/b, cd = c/d;\n//\tif (ab > cd) return true;\n//\tif (ab < cd) return false;\n//\treturn !greaterOrEqual(b, a%b, d, c%d);\n//}\n\n\n/** Computing lower and upper envelope. Useful for \"convex hull trick\". */\nnamespace Envelope {\n\ttemplate<typename T>\n\tstruct Line {\n\t\tT m, b; int id;\n\t\tmutable function<const Line<T> *()> succ;\n\n\t\tbool operator<(const Line &rhs) const {\n\t\t\tif (rhs.b != numeric_limits<T>::min()) return m < rhs.m;\n\t\t\tconst Line *s = succ();\n\t\t\tif (!s) return 0;\n\t\t\treturn b - s->b < (s->m - m) * rhs.m;\n\t\t}\n\t};\n\n\ttemplate<typename T>\n\tstruct Upper : public multiset<Envelope::Line<T>> {\n\t\tusing parent = multiset<Line<T>>;\n\n\t\tbool bad(typename parent::iterator y) {\n\t\t\tauto z = next(y);\n\t\t\tif (y == parent::begin()) {\n\t\t\t\treturn z != parent::end() && y->m == z->m && y->b <= z->b;\n\t\t\t} else {\n\t\t\t\tauto x = prev(y);\n\t\t\t\tif (z == parent::end()) {\n\t\t\t\t\treturn y->m == x->m && y->b <= x->b;\n\t\t\t\t} else {\n\t\t\t\t\treturn fractionGreaterOrEqual(x->b - y->b, y->m - x->m, y->b - z->b, z->m - y->m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid insert_line(T m, T b, int i = 0) {\n\t\t\tauto y = parent::insert({m, b, i});\n\t\t\ty->succ = [=] { return next(y) == parent::end() ? 0 : &*next(y); };\n\t\t\tif (bad(y)) { parent::erase(y); return; }\n\t\t\twhile (next(y) != parent::end() && bad(next(y))) parent::erase(next(y));\n\t\t\twhile (y != parent::begin() && bad(prev(y))) parent::erase(prev(y));\n\t\t}\n\n\t\tT operator[](T x) const {\n\t\t\tauto l = parent::lower_bound({x, numeric_limits<T>::min()});\n\t\t\treturn l == parent::end() ? numeric_limits<T>::min() : l->m * x + l->b;\n\t\t}\n\n\t\tint best(T x) const {\n\t\t\tauto l = parent::lower_bound({x, numeric_limits<T>::min()});\n\t\t\treturn l == parent::end() ? -1 : l->id;\n\t\t}\n\t};\n\n\t// Lower envelope. WARNING: the internal representation changes m & b.\n\ttemplate<typename T>\n\tstruct Lower : public Upper<T> {\n\t\tvoid insert_line(T m, T b, int i = 0) { Upper<T>::insert_line(-m, -b, i); }\n\t\tT operator[](T x) const { return -Upper<T>::operator[](x); }\n\t};\n}\n\n/* UpperEnvelope that with O(N) build and amortized O(1) query.\n * The updates need be sorted by (m,b), the queries need to be sorted by x, and\n * updates need to come before queries. */\nnamespace LinearEnvelope {\n\ttemplate<typename T> struct Line { T m, b; int id; };\n\n\ttemplate <typename T>\n\tstruct Upper : public vector<Line<T>> {\n\t\tusing parent = vector<Line<T>>;\n\t\tusing parent::at; using parent::back; using parent::size;\n\n\t\tT t; int i;\n\n\t\tUpper() : t(0), i(0) {}\n\n\t\tvoid clear() {\n\t\t    parent::clear();\n\t\t    i = 0;\n\t\t    t = 0;\n\t\t}\n\n\t\tvoid insert_line(T m, T b, int i = 0) {\n\t\t\tassert(t == 0);\n\t\t\tif (size() > 0 && back().m == m && back().b >= b) return;\n\t\t\twhile (size() > 0 && ((back().b < b) || (back().b == b && back().m < m))) parent::pop_back();\n\t\t\twhile (size() >= 2 && fractionGreaterOrEqual(at(size()-2).b - back().b, back().m - at(size()-2).m, back().b - b, m - back().m)) parent::pop_back();\n\t\t\tparent::push_back({m,b,i});\n\t\t}\n\n\t\tpair<T,int> advance(T x) {\n\t\t\tassert(x >= 0);\n\t\t\tt += x;\n\t\t\twhile (i+1 < size() && at(i).m * t + at(i).b < at(i+1).m * t + at(i+1).b) ++i;\n\t\t\treturn {at(i).m * t + at(i).b, at(i).id};\n\t\t}\n\t};};\n\n#endif\n\n// 213412837499898383\nstruct Sieve : public std::vector<bool> {\n    // ~10ns * n\n\texplicit Sieve(ui n) : vector<bool>(n+1, true), n(n) {\n\t\tat(0) = false;\n\t\tif (n!=0) at(1) = false;\n\t\tfor (ui i = 2; i*i <= n; ++i) {\n\t\t\tif (at(i)) for (int j = i*i; j <= n; j+=i) (*this)[j] = false;\n\t\t}\n\t}\n\n\tvector<int> primes() const {\n\t\tvector<int> ans;\n\t\tfor (int i=2; i<=n; ++i) if (at(i)) ans.push_back(i);\n\t\treturn ans;\n\t}\n\nprivate:\n\tint n;\n};\n\nstruct Moebius : public std::vector<std::pair<int, int>> {\n\texplicit Moebius(ui n) : Moebius(n, Sieve{n}.primes()) {}\n\n\tMoebius(ui n, const vector<int>& primes) {\n\t\tsearch(-1, 1, 1, n, primes);\n\t\tstd::sort(begin(), end());\n\t}\nprivate:\n\tvoid search(int i, int x, int y, int n, const vector<int>&primes) {\n\t\tpush_back({x,y});\n\t\twhile (++i < primes.size() && (ll)x * primes[i] <= n) search(i, x*primes[i], -y, n, primes);\n\t}\n};\n\n// 32-bit primes for hashing\nstruct LargePrimes : public vector<int> {\n\tLargePrimes():vector<int>{7,9,21,33,87,93,97,103,123,181,207,223,241,271,289,297,321,349,363,403,409,411,427,433,439,447,453,459,483,513,531,579,607,613,637,663,711,753,787,801,829,861,871,891,901,919,931,933,993,1011,1021,1053,1087,1099,1137,1161,1203,1213,1237,1263,1269,1273, 1279,1311,1329,1333,1351,1371,1393,1413,1447,1449,1491,1501,1531,1537,1539,1581,1617, 1621,1633,1647,1663,1677,1699,1759,1773,1789,1791,1801,1803,1819,1857,1887,1917,1927, 1957,1963,1969,2043,2089,2103,2139,2149,2161,2173,2187,2193,2233,2239,2277,2307,2359, 2361,2431,2449,2457,2499,2571,2581,2607,2631,2637,2649,2667,2727,2791,2803,2821,2823, 2827,2907,2937,2989,3009,3013,3051,3057,3097,3111,3133,3153,3157,3163,3211,3241,3247,3253,3267,3271,3273,3283,3309,3337,3351,3357,3373,3379,3397,3469,3471,3513,3519,3559,3577,3579,3601,3621,3643,3651,3663,3679,3709,3747,3751,3769,3777,3787,3793,3843,3853,3871,3889,3891,3909,3919,3931,3951,3957,3967,3987,3999,4023,4059,4099,4119,4123,4207,4233,4249,4251,4263,4321,4329,4381,4389,4437,4449,4459,4497,4507,4519,4539,4567,4569,4581,4609,4611,4627,4633,4647,4693,4699,4717,4771,4777,4783,4791,4807,4839,4843,4849,4857,4867,4869,4891,4893,4897,4927,4933,4977,4981,5001,5029,5053,5067,5103,5133,5187,5197,5203,5233,5277,5287,5299,5317,5329,5341,5353,5361,5403,5407,5437,5443,5449,5451,5469,5491,5527,5541,5547,5583,5631,5647,5683,5731,5737,5751,5763,5791,5823,5827,5833,5847,5863,5899,5907,5947,5953,5959,5971,5973,5991,5997,6019,6027,6037,6039,6061,6093,6099,6127,6129,6177,6193,6211,6223,6229,6307,6313,6331,6349,6379,6393,6417,6421,6457,6459,6477,6541,6571,6577,6583,6607,6621,6661,6663,6697,6717,6751,6781,6837,6867,6901,6957,6961,6967,6981,7003,7023,7027,7089,7117,7137,7147,7159,7191,7209,7237,7243,7257,7279,7321,7347,7383,7389,7417,7429,7447,7453,7467,7479,7497,7513,7521,7531,7537,7557,7633,7647,7651,7653,7681,7707,7719,7741,7759,7773,7803,7819,7837,7873,7887,7909,7923,7927,7929,7941,8041,8083,8089,8101,8109,8127,8173,8181,8223,8257,8259,8271,8277,8311,8313,8343,8349,8397,8403,8419,8431,8439,8487,8511,8557,8593,8617,8637,8649,8661,8671,8679,8719,8727,8761,8773,8791,8797,8803,8811,8829,8853,8899,8917,8937,8967,9009,9013,9063,9081,9093,9099,9123,9133,9163,9183,9211,9223,9259,9277,9279,9289,9301,9321,9331,9363,9399,9403,9421,9441,9457,9469,9487,9519,9529,9531,9541,9559,9561,9567,9573,9579,9597,9601,9609,9631,9651,9667,9679,9711,9733,9739,9757,9789,9831,9859,9867,9961,9999,10029,10051,10069,10101,10153,10173,10189,10197,10233,10243,10251,10267,10281,10303,10321,10327,10351,10357,10381,10449,10467,10483,10503,10513,10549,10593,10597,10611,10633,10659,10699,10707,10723,10747,10749,10761,10773,10777,10801,10833,10903,10953,10969,10971,10981,10987,11007,11011,11071,11083,11091,11107,11109,11137,11149,11161,11223,11239,11253,11269,11277,11283,11289,11301,11317,11329,11371,11377,11391,11421,11479,11487,11497,11517,11533,11539,11559,11583,11601,11619,11631,11659,11673,11679,11707,11763,11767,11769,11773,11799,11811,11821,11823,11847,11869,11967,11983,11989,12019,12037,12121,12157,12177,12187,12217,12219,12231,12241,12253,12297,12309,12333,12337,12339,12361,12367,12399,12411,12459,12463,12483,12501,12513,12523,12547,12553,12577,12609,12631,12649,12679,12681,12703,12723,12733,12747,12753,12759,12799,12847,12877,12891,12901,12903,12927,12939,12963,13011,13017,13029,13039,13081,13087,13089,13101,13107,13137,13141,13143,13153,13191,13207,13213,13237,13323,13369,13419,13437,13447,13477,13519,13537,13561,13563,13587,13591,13723,13741,13759,13789,13801,13857,13881,13897,13921,13923,13939,13999,14011,14073,14077,14083,14097,14121,14131,14143,14157,14161,14167,14181,14193,14209,14241,14259,14271,14293,14361,14391,14397,14437,14529,14551,14581,14583,14599,14607,14611,14643,14727,14761,14773,14779,14791,14823,14853,14881,14889,14901,14931,14937,14997,15031,15043,15057,15063,15069,15097,15103,15109,15117,15141,15147,15187,15199,15217,15231,15253,15271,15279,15283,15307,15339,15349,15351,15363,15369,15409,15427,15447,15477,15487,15553,15579,15591,15649,15651,15673,15693,15703,15717,15727,15747,15799,15811,15823,15859,15889,15963,15981,16009,16021,16029,16047,16063,16089,16093,16107,16153,16167,16191,16201,16231,16233,16261,16267,16273,16317,16323,16411,16419,16431,16489,16491,16513,16539,16617,16621,16623,16627,16651,16659,16671,16711} { for (int&i:*this)i+=1000000000; }\n};\n\nvector<int> SmallPrimes{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257};\n// 200ns-4us per call, depending on size\nbool isPrime(ll n) {\n    if (n==2) return true;\n    for (int p:SmallPrimes)\n        if (p<n&&n%p==0) return false;\n\tll d = n-1, r = 0;\n\twhile (d%2==0) { d/=2; r += 1; }\n\tauto composite = [=](int a) {\n\t\tll x = 1, p = a, e = d;\n\t\twhile(e>0) { if(e%2>0){x=mulull(x,p,n);} e/=2; p=mulull(p,p,n); }\n\t\tif (x == 1 || x == n-1) return false;\n        for (int i=1;i<r;++i) {\n            x=mulull(x,x,n);\n            if (x==1) return true;\n\t\t\tif (x==n-1) return false;\n\t\t}\n        return true;\n\t};\n\n\treturn !(composite(2))\n\t\t   && (n<2047 || !composite(3))\n\t\t   && (n<1373653 || !composite(5))\n\t\t   && (n<25326001 || !composite(7))\n\t\t   && (n<3215031751LL || !composite(11))\n\t\t   && (n<2152302898747LL || !composite(13))\n\t\t   && (n<3474749660383LL || !composite(17))\n\t\t   && (n<341550071728321LL || (!composite(19) && !composite(23)))\n\t\t   && (n<3825123056546413051LL || (!composite(29) && !composite(31) && !composite(37)));\n}\n\n\n#endif //PRIMES_H\n\n\nclass D {\npublic:\nvoid solve(istream& cin, ostream& cout) {\n    auto P = Sieve{10000}.primes();\n    int N; cin >> N;\n    vector<int> R(2*N+4);\n    for (int i = 0; i < N+2; ++i) {\n        R[2*i] = P[i];\n        R[2*i+1] = P[N+2+i];\n    }\n\n    int x = N%2;\n\n    vector2<ll> A(N, N, -1);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i%2 == j%2) {\n                A[i][j] = R[1+i+j] * R[N+i-j+x];\n            } else {\n                A[i][j] = 1LL * R[i+j] * R[i+j+2] * R[N+i-j-1+x] * R[N+i-j+1+x] + 1;\n            }\n        }\n    }\n\n//    ll mx = 0;\n//    for (auto&a:A) for (ll&aa:a) mx = max(mx, aa);\n///\n//    cout << mx;\n    for (auto&a:A) cout << a;\n}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 505\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nint n;\nint a[N][N];\n\nint main() {\n\tcin >> n;\n\tfor (int i = 2; i <= n << 1; ++i)\n\t\tfor (int x = 1; x <= n; ++x) {\n\t\t\tint y = i - x;\n\t\t\tif (y <= 0 || y > n) continue;\n\t\t\ta[x][y] = i - 1;\n\t\t}\n\n\tfor (int x = 1; x <= n; ++x) {\n\t\tfor (int y = 1; y < n; ++y) printf(\"%d \", a[x][y]);\n\t\tprintf(\"%d\\n\", a[x][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(int x){\n\tif(x <= 1) return false;\n\tfor(int i = 2; i * i <= x; i++) if(x % i == 0) return false;\n\treturn true;\n}\nconst int maxn = 500;\nlong long r[maxn][maxn], p[2][4 * maxn];\nlong long gcd(long long a, long long b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nint main(){\n\tvector<int> primes;\n\tfor(int i = 1; primes.size() < 2000; i++) if(is_prime(i)) primes.push_back(i);\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) r[i][j] = 1;\n\tint stk = 0;\n\tfor(int i = 0; i < maxn + maxn; i += 2){\n\t\tp[0][i] = stk++;\n\t\tp[1][i] = stk++;\n\t}\n\tassert(stk <= primes.size());\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++) {\n\t\tint x = i - j + maxn;\n\t\tint y = i + j;\n\t\tif(x % 2 == 0){\n\t\t\tr[i][j] *= primes[p[0][x]] * primes[p[1][y]];\n\t\t}\n\t}\n\tfor(int i = 0; i < maxn; i++) for(int j = 0; j < maxn; j++){\n\t\tint x = i - j + maxn;\n\t\tif(x % 2 == 1){\n\t\t\tvector<long long> cand;\n\t\t\tif(i) cand.push_back(r[i - 1][j]);\n\t\t\tif(j) cand.push_back(r[i][j - 1]);\n\t\t\tif(i + 1 < maxn) cand.push_back(r[i + 1][j]);\n\t\t\tif(j + 1 < maxn) cand.push_back(r[i][j + 1]);\n\t\t\tlong long lc = cand[0] / gcd(cand[0], cand[1]) * cand[1];\n\t\t\tfor(int j = 2; j < cand.size(); j++) lc = lc / gcd(lc, cand[j]) * cand[j];\n\t\t\tr[i][j] = lc + 1;\n\t\t}\n\t}\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[i][j], mx = r[i][j + 1];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 1);\n\t\t}\n\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\tlong long mn = r[j][i], mx = r[j + 1][i];\n\t\t\tif(mn > mx) swap(mn, mx);\n\t\t\tassert(mx % mn == 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tcout << r[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  const int MAX = 10010;\n  vector<int> is_prime(MAX, 1);\n  for (int i = 2; i * i < MAX; i++) {\n    if (is_prime[i]) {\n      for (int j = i * i; j < MAX; j += i) {\n        is_prime[j] = 0;\n      }\n    }\n  }\n  vector<int> primes;\n  for (int i = 2; i < MAX; i++) {\n    if (is_prime[i]) {\n      primes.push_back(i);\n    }\n  }\n  auto lcm = [&](long long a, long long b) {\n    return a / __gcd(a, b) * b; \n  };\n\n  int n;\n  cin >> n;\n  if (n == 2) {\n    cout << 4 << ' ' << 7 << '\\n';\n    cout << 23 << ' ' << 10 << '\\n';\n    return 0;\n  }\n  vector<vector<long long>> a(n, vector<long long>(n));\n  int shift = (n - 1) - (n % 2 == 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 0) {\n        int x = ((i - j) + shift) / 2;\n        int y = ((i + j) + 2 * shift + 2) / 2;\n        a[i][j]=  primes[x] * primes[y];\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if ((i + j) % 2 == 1) {\n        a[i][j] = 1;\n        if (i > 0) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n        if (i < n - 1) a[i][j] = lcm(a[i][j], a[i + 1][j]);\n        if (j > 0) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n        if (j < n - 1) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n        a[i][j]++;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%lld%c\", a[i][j], \" \\n\"[j == n - 1]);\n    }\n  }\n  return 0;  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX_N 500\n\nusing namespace std;\n\ntypedef long long lint;\n\nlint a[MAX_N + 1][MAX_N + 1];\n\nint n;\n\nint k;\nint v[(MAX_N << 1) + 1];\n\nconst int dl[] = {-1, 1, 0, 0};\nconst int dc[] = {0, 0, 1, -1};\n\nset <int> diff;\n\nint diagST[(MAX_N << 1) + 1];\nint diagDR[(MAX_N << 1) + 1];\n\nbool p[7920];\n\nvoid readFile()\n{\n    cin >> n;\n}\n\nvoid ciur()\n{\n    int n = 7919;\n\n    int i, j;\n    for(i = 4; i <= n; i += 2)\n        p[i] = 1;\n\n    for(i = 3; i * i <= n; i += 2)\n    {\n        if(p[i] == 0)\n        {\n            for(j = i * i; j <= n; j += (i * 2))\n                p[j] = 1;\n        }\n    }\n\n    v[++ k] = 2;\n    for(i = 3; i <= n; i += 2)\n    {\n        if(p[i] == 0)\n            v[++ k] = i;\n    }\n}\n\nvoid getDiags()\n{\n    int cr = 1;\n    for(int st = n; st >= 1; st -= 2)\n        diagST[st] = v[cr ++];\n\n    for(int st = n + 2; st <= (n << 1); st += 2)\n        diagST[st] = v[cr ++];\n\n    for(int dr = 1; dr <= (n << 1); dr += 2)\n        diagDR[dr] = v[cr ++];\n}\n\nvoid getBlacks()\n{\n    int i, j;\n    for(i = 1; i <= n; i ++)\n    {\n        for(j = 1; j <= n; j ++)\n        {\n            if(((i + j) & 1) == 0)\n            {\n               // cout << \"PE \" << i << \" \" << j << \" PUNEM \" << diagST[n + i - j] << \" sI \" << diagDR[i + j - 1] << \"\\n\";\n                a[i][j] = diagST[n + i - j] * diagDR[i + j - 1];\n            }\n        }\n    }\n}\n\nvoid getWhites()\n{\n    for(int i = 1; i <= n; i ++)\n    {\n        for(int j = 1; j <= n; j ++)\n        {\n            if(a[i][j] == 0)\n            {\n                diff.clear();\n                for(int dir = 0; dir < 4; dir ++)\n                {\n                    int nl = i + dl[dir];\n                    int nc = j + dc[dir];\n                    if(nl >= 1 && nl <= n && nc >= 1 && nc <= n)\n                    {\n                        diff.insert(diagST[n + nl - nc]);\n                        diff.insert(diagDR[nl + nc - 1]);\n                    }\n                }\n\n                lint rez = 1;\n                for(auto u : diff)\n                    rez = rez * u;\n\n                a[i][j] = rez + 1;\n            }\n        }\n    }\n}\n\nvoid solve()\n{\n    ciur();\n\n    getDiags();\n\n    getBlacks();\n\n    getWhites();\n}\n\nvoid printFile()\n{\n    for(int i = 1; i <= n; i ++)\n    {\n        for(int j = 1; j <= n; j ++)\n            cout << a[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n\nint main()\n{\n    readFile();\n  \n  \tif(n == 2)\n   {\n      cout << \"4 7\\n23 10\\n\";\n      return 0;\n    }\n\n    solve();\n\n    printFile();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=1e3+10;\nint n;\nll a[maxn][maxn];\nset<ll> s;\nvector<int> v;\n\ninline ll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\ninline ll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\nconst int xx=1e6;\nint pcnt,p[xx];\nbool prm[xx];\n\nint main(){\n\tfor(int i=2;i<xx;++i){\n\t\tif(!prm[i])\n\t\t\tp[++pcnt]=i;\n\t\tfor(int j=1;j<=pcnt&&i*p[j]<xx;++j){\n\t\t\tprm[i*p[j]]=1;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcin>>n;\n\tfor(int i=0;i<=n+1;++i)\n\t\tfor(int j=0;j<=n+1;++j)\n\t\t\ta[i][j]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1,cnt=1;j<=n;++j)\n\t\t\tif(i+j&1){\n\t\t\t\tll now=p[i]*p[j+n];\n\t\t\t\ta[i][j]=now;\n\t\t\t\ts.insert(now);\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i+j&1^1){\n\t\t\t\tll tmp=lcm(a[i-1][j],a[i][j-1]);\n\t\t\t\ttmp=lcm(tmp,a[i][j+1]);\n\t\t\t\ttmp=lcm(tmp,a[i+1][j]);\n\t\t\t\tll now=tmp+1;\n\t\t\t\twhile(s.count(now))\n\t\t\t\t\tnow+=tmp;\n\t\t\t\ta[i][j]=now;\n\t\t\t\ts.insert(now);\n\t\t\t}\n\tfor(int i=1;i<=n;++i,puts(\"\"))\n\t\tfor(int j=1;j<=n;++j){\n\t//\t\tif(a[i][j]>1e15)cerr<<\"#\";\n\t\t\tcout<<a[i][j]<<' ';\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n,cnt,p[N],vis[N];\nll a[510][510];\nconst int dx[]={0,0,1,-1};\nconst int dy[]={-1,1,0,0};\nll _lcm(ll x, ll y) {\n\tif (!y) return x;\n\treturn x/gcd(x,y)*y;\n}\nint main() {\n\tREP(i,2,N-1) if (!vis[i]) for (int j=2*i; j<N; j+=i) vis[j] = 1;\n\tREP(i,2,N-1) if (!vis[i]) p[++cnt] = i;\n\tcin>>n;\n\tREP(i,1,n) REP(j,1,n) if (i+j&1) a[i][j] = p[(i+j)/2];\n\tREP(i,1,n) REP(j,1,n) if (i+j&1) a[i][j] *= p[(i-j+n-1)/2+n];\n\tREP(i,1,n) REP(j,1,n) if (!a[i][j]) {\n\t\tll x = 1;\n\t\tREP(d,0,3) {\n\t\t\tint ii=i+dx[d],jj=j+dy[d];\n\t\t\tx = _lcm(x,a[ii][jj]);\n\t\t}\n\t\ta[i][j] = x+1;\n\t}\n\tREP(i,1,n) {\n\t\tREP(j,1,n) cout<<a[i][j]<<' ';hr;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define MAX 505\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,prime[MAX<<1],vst[10005];\nvoid pre(int up)\n{\n\tfor(int i=2;;i++)\n\t{\n\t\tif(!vst[i])\n\t\t{\n\t\t\tprime[++prime[0]]=i;\n\t\t\tif(prime[0]==up) break;\n\t\t}\n\t\tfor(int j=1;j<=prime[0];j++)\n\t\t{\n\t\t\tif(i*prime[j]>10000) break;\n\t\t\tvst[i*prime[j]]=1;\n\t\t\tif(!(i%prime[j])) break;\n\t\t}\n\t}\n}\nlong long gcd(long long a,long long b)\n{\n\tif(a<b) swap(a,b);\n\twhile(b)\n\t{\n\t\ta%=b;\n\t\tswap(a,b);\n\t}\n\treturn a;\n}\nlong long lcm(long long a,long long b)\n{\n\tif(!a||!b) return a|b;\n\treturn a/gcd(a,b)*b;\n}\nlong long a[MAX][MAX];\nint main()\n{\n\tn=read();\n\tif(n==2) return printf(\"4 7\\n23 10\"),0;\n\tpre((n&1)?n*2:n*2-1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!((i+j)&1))\n\t\t\t\ta[i][j]=1ll*prime[(i+j)/2]*prime[n+(i-j)/2+(n+1)/2];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)&1)\n\t\t\t\ta[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i+1][j],a[i][j+1]))+1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nvector<ll> primes;\nll factor[505];\nll field[505][505];\n\nint main() {\n    //cout.precision(10);\n    int N;\n    cin >> N;\n    for(ll i = 2; i <= 15000; i++) {\n        bool ok = true;\n        for(ll j = 2; j * j <= i; j++) {\n            if(i % j == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if(ok) primes.push_back(i);\n    }\n    int index = 1;\n    factor[1] = 1;\n    for(int i = 2; i <= N + 1; i++) {\n        factor[i] = primes[index];\n        index++;\n    }\n    for(int i = 1; i <= N + 1; i += 2) {\n        field[i][1] = primes[index];\n        index++;\n        field[1][i] = primes[index];\n        index++;\n        //cerr << i << \" \" << index << endl;\n        for(int j = 1; j + i - 1 <= N + 1; j++) {\n            field[j][i+j-1] = field[1][i] * factor[j];\n            field[i+j-1][j] = field[i][1] * factor[j];\n            //cerr << i << \" \" << j << endl;\n        }\n    }\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= N; j++) {\n            if(field[i][j] == 0) field[i][j] = field[i+1][j] * field[i][j+1] + 1;\n            cout << field[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    //cout << primes.size() << \" \" << primes[2] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\nint main(){\n    int N;\n    cin>>N;\n    for(int i=1;i<=N;i++){\n        if(i%2==0){\n            for(int k=1;k<=N;k++){\n                if(k%2==1)printf(\"4 \");\n                else printf(\"7 \");\n            }\n        }\n        else{\n            for(int k=1;k<=N;k++){\n                if(k%2==1)printf(\"23 \");\n                else printf(\"10 \");\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n2\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#ifdef leowang\n#define debug(...) do{\\\n\tfprintf(stderr,\"%s - %d : (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n\t_DO(__VA_ARGS__);\\\n}while(0)\ntemplate<typename I> void _DO(I&&x){cerr<<x<<endl;}\ntemplate<typename I,typename...T> void _DO(I&&x,T&&...tail){cerr<<x<<\", \";_DO(tail...);}\n#else\n#define debug(...)\n#endif\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tREP(i,n) REP(j,n) cout<<i+j+2<<\" \\n\"[j==n-1];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nsigned main(){\n  vector<int> v;\n  int t=2;\n  while(v.size()<1000){\n    bool f=1;\n    for(int i=2;i*i<=t;i++)if(t%i==0)f=0;\n    if(f)v.push_back(t);\n    t++;\n  }\n  int d1[500][500],d2[500][500],c=0;\n  for(int i=-498;i<500;i+=2){\n    for(int j=-i;j+i<500;j++){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d1[j][j+i]=v[c];\n    }\n    c++;\n  }\n\n  for(int i=0;i<1000;i+=2){\n    for(int j=1000;i-j<500;j--){\n      if(0<=j&&j<500&&0<=j+i&&j+i<500)d2[j][i-j]=v[c];\n    }\n    c++;\n  }\n  int n;\n  cin>>n;\n  \n  int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(j)cout<<\" \";\n      if((i+j)%2){\n\tint res=1;\n\tset<int> s;\n\tfor(int k=0;k<4;k++){\n\t  int nx=j+dx[k],ny=i+dy[k];\n\t  if(nx<0||ny<0||nx>=500||ny>=500)continue;\n\t  s.insert(d1[ny][nx]);\n\t  s.insert(d2[ny][nx]);\n\t}\n\tfor(auto z:s){res*=z;}\n\tcout<<res+1;\n      }\n      else cout<<d1[i][j]*d2[i][j];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=8000;\nint n,pri[1001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);cin>>n;\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++){\n\t\tfor(reg int j=1;j<=n;j++){\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+(abs(i-j)>>1)+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++,cout<<endl)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tcout<<a[i][j]<<' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint prime[2020],np;\nbool vis[10101];\nvoid findprime()\n{\n\tmemset(vis,0,sizeof(vis));\n\tnp=0;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(!vis[i])\n\t\t\tprime[++np]=i;\n\t\tfor(int j=1;j<=np&&i*prime[j]<=10000;j++)\n\t\t{\n\t\t\tvis[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nlong long ans[505][505];\nlong long gcd(long long x,long long y)\n{\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\n}\nlong long lcm(long long x,long long y)\n{\n\treturn x/gcd(x,y)*y;\n}\nint hx[4]={-1,1,0,0};\nint hy[4]={0,0,-1,1};\nint main()\n{\n\tint n;\n\tfindprime();\n\tscanf(\"%d\",&n);\n\tif(n==2)\n\t{\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tans[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==0)\n\t\t\t\tans[i][j]=prime[(i+j)/2]*prime[(n-j+1+i)/2+n];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((i+j)%2==1)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tans[i][j]=lcm(ans[i][j],ans[i+hx[k]][j+hy[k]]);\n\t\t\t\tans[i][j]++;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 505;\n\nll v[MAXN][MAXN];\nbool not_prime[2000005];\nvector<int> p;\n\nll gcd(ll x, ll y) {\n  return y ? gcd(y, x % y) : x;\n}\n\nll lcm(ll x, ll y) {\n  return x / gcd(x, y) * y;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  not_prime[1] = 1;\n  for(int i = 2; i <= 2000000; i++) {\n    if(!not_prime[i]) {\n      p.push_back(i);\n      for(int j = i + i; j <= 2000000; j += i) {\n        not_prime[j] = 1;\n      }\n    }\n  }\n  for(int i = 0; i <= n + 1; i++) {\n    for(int j = 0; j <= n + 1; j++) {\n      v[i][j] = 1;\n    }\n  }\n  vector<int> id1, id2;\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if((i + j) % 2 == 1) {\n        id1.push_back(i - j);\n        id2.push_back(i + j);\n      }\n    }\n  }\n  sort(id1.begin(), id1.end());\n  sort(id2.begin(), id2.end());\n  id1.erase(unique(id1.begin(), id1.end()), id1.end());\n  id2.erase(unique(id2.begin(), id2.end()), id2.end());\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if((i + j) % 2 == 1) {\n        v[i][j] *= p[lower_bound(id1.begin(), id1.end(), i - j) - id1.begin()];\n        v[i][j] *= p[lower_bound(id2.begin(), id2.end(), i + j) - id2.begin()];\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if((i + j) % 2 == 0) {\n        v[i][j] = lcm(lcm(v[i - 1][j], v[i][j - 1]), lcm(v[i + 1][j], v[i][j + 1])) + 1;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      printf(\"%lld \", v[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tULL ans[502][502];\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tvector<ULL> P;\n\t\tfor (ULL i = 3; P.size() < N + 10; i += 2) {\n\t\t\tbool ok = true;\n\t\t\trep(j, P.size()) if (i % P[j] == 0) { ok = false; break; }\n\t\t\tif (ok) P.push_back(i);\n\t\t}\n\t\trep(x, N + 1) rep(y, N + 2) {\n\t\t\tif ((x + y) & 1) continue;\n\t\t\tUL n = (y + (N + 2 - x)) >> 1;\n\t\t\tUL m = (y + x) >> 1;\n\t\t\tans[x][y] = P[n] * P[m];\n\t\t\tans[x + 1][y] = P[n - 1] * P[n] * P[m] * P[m + 1] + 1;\n\t\t}\n\t\trep(y, N) {\n\t\t\trep(x, N) {\n\t\t\t\tif (x) cout << \" \";\n\t\t\t\tcout << ans[x + 1][y + 1];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat gcd(cat x, cat y) {\n\tif(x > y) swap(x, y);\n\treturn (x == 0) ? y : gcd(y%x, x);\n}\n\ncat lcm(cat x, cat y) {\n\treturn x / gcd(x, y) * y;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< vector<cat> > A(N, vector<cat>(N, 1));\n\tvector<int> P;\n\tfor(int p = 3; ; p++) {\n\t\tbool is_prime = true;\n\t\tfor(int i = 2; i*i <= p; i++) is_prime &= (p%i != 0);\n\t\tif(!is_prime) continue;\n\t\tP.push_back(p);\n\t\tif((int)P.size() == N+10) break;\n\t}\n\tfor(int i = 0; i < N; i += 2) for(int j = 0; j < N; j += 2) A[i][j] = P[i/2] * P[N/2+1+j/2];\n\tfor(int i = 1; i < N; i += 2) for(int j = 1; j < N; j += 2) A[i][j] = 2 * A[i-1][j-1];\n\tfor(int i = 0; i < N; i++) for(int j = 1-(i&1); j < N; j += 2) {\n\t\tif(i > 0) A[i][j] = lcm(A[i][j], A[i-1][j]);\n\t\tif(j > 0) A[i][j] = lcm(A[i][j], A[i][j-1]);\n\t\tif(i+1 < N) A[i][j] = lcm(A[i][j], A[i+1][j]);\n\t\tif(j+1 < N) A[i][j] = lcm(A[i][j], A[i][j+1]);\n\t\tif(i&1) A[i][j]++;\n\t}\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N; j++) cout << A[i][j] << ((j == N-1) ? \"\\n\" : \" \");\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint p[100010],pr[20100],t;\nll ad[101000],mi[101000],num[555][555];\nll mx;\nvector<pair<int,PII>> pp;\nint main() {\n\trep(i,2,20000) if (p[i]==0) {\n\t\tpr[t++]=i;\n\t\tfor (int j=i;j<=20000;j+=i) p[j]=1;\n\t}\n//\tprintf(\"%d\\n\",t);\n\tfor (int c=0;c<=998;c++) if (c%2==0) {\n\t\tpp.pb(mp(abs(c-499),mp(c,0)));\n\t}\n\n\tfor (int c=-499;c<=499;c++) if (c%2==0) {\n\t\tpp.pb(mp(abs(c),mp(c,1)));\n\t}\n\tsort(all(pp));\n\trep(i,0,SZ(pp)) {\n\t\tif (pp[i].se.se==0) ad[pp[i].se.fi]=pr[i];\n\t\telse mi[pp[i].se.fi+1000]=pr[i];\n\t}\n\tset<ll> ss;\n\trep(i,0,500) rep(j,0,500) {\n\t\tif ((i+j)%2==0) {\n\t\t\tll p1=ad[i+j];\n\t\t\tll p2=mi[i-j+1000];\n\t\t\tnum[i][j]=p1*p2;\n\t\t\tss.insert(num[i][j]);\n\t\t}\n\t}\n\tll mx=0;\n\trep(i,0,500) rep(j,0,500) {\n\t\tif ((i+j)%2==1) {\n\t\t\tnum[i][j]=1;\n\t\t\trep(k,0,4) {\n\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\tif (nx>=0&&nx<500&&ny>=0&&ny<500) {\n\t\t\t\t\tnum[i][j]=num[i][j]/gcd(num[i][j],num[nx][ny])*num[nx][ny];\n\t\t\t\t}\n\t\t\t}\n\t\t\tll x=num[i][j]+1;\n\t\t\twhile (ss.count(x)) x+=num[i][j];\n\t\t\tnum[i][j]=x;\n\t\t\tss.insert(x);\n\t\t\tmx=max(mx,num[i][j]);\n\t\t}\n\t}\n\tss.clear();\n\trep(i,0,500) rep(j,0,500) {\n\t\trep(k,0,4) {\n\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\tif (nx>=0&&nx<500&&ny>=0&&ny<500) {\n\t\t\t\tll c1=max(num[i][j],num[nx][ny]);\n\t\t\t\tll c2=min(num[i][j],num[nx][ny]);\n\t\t\t\tassert(c1%c2==1);\n\t\t\t}\n\t\t}\n\t\tss.insert(num[i][j]);\n\t\tassert(num[i][j]>=1&&num[i][j]<=1000000000000000ll);\n\t}\n\tassert(SZ(ss)==250000);\n\tint x=0;\n\tscanf(\"%d\",&x);\n\trep(i,0,x) {\n\t\trep(j,0,x) printf(\"%lld%c\",num[i][j],\" \\n\"[j==x-1]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define foreach(c,it) for (__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\nusing namespace std;\nlong long n,i,j,p[100005],pc,np[100005],a[515][515];\nint main(){\n\tfor(i=2;i<=100000;i++){\n\t\tif(!np[i]){p[++pc]=i;}\n\t\trep(j,pc){if(i*p[j]>100000) break;\n\t\t\tnp[i*p[j]]=1;if(i%p[j]==0) break;\n\t\t}\n\t}\n\tcin>>n;;\n\trep(i,n+2)rep(j,n+2)if(!((i+j)&1)){\n\t\tint t1=(i+j)/2,t2=(i-j+n+2)/2+n+2;\n\t\ta[i][j]=p[t1]*p[t2];\n\t}\n\trep(i,n+2)rep(j,n+2)if((i+j)&1){\n\t\ta[i][j]=a[i][j-1]*a[i][j+1]+1;\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcout<<a[i+1][j+1]<<' ';\n\t\t}cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int N=20005;\nset<ll> st;\nint n,i,j,k,p[N],l,w1[N],w2[N];\nbool v[N];\nll a[505][505];\nll gcd(ll a,ll b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nll LCM(ll a,ll b,ll c,ll d)\n{\n\tll rtn=a/gcd(a,b)*b;\n\trtn=rtn/gcd(rtn,c)*c;\n\trtn=rtn/gcd(rtn,d)*d;\n\treturn rtn;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=2;i<=20000;++i)\n\t{\n\t\tif(!v[i])\n\t\t\tp[++l]=i;\n\t\tfor(j=1;j<=l&&p[j]*i<=20000;++j)\n\t\t{\n\t\t\tv[p[j]*i]=true;\n\t\t\tif(i%p[j]==0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tw1[i]=p[i];\n\tfor(i=1;i<=n;++i)\n\t\tw2[i]=p[n+i];\n\trandom_shuffle(w1+1,w1+1+n);\n\trandom_shuffle(w2+1,w2+1+n);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif((i+j)%2==0)\n\t\t\t\ta[i][j]=w1[(i+j)/2]*w2[(i-j+n)/2];\n\tfor(i=0;i<=n+1;++i)\n\t\ta[0][i]=a[n+1][i]=a[i][0]=a[i][n+1]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif((i+j)&1)\n\t\t\t{\n\t\t\t\ta[i][j]=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1])+1;\n\t\t\t\twhile(st.count(a[i][j]))\n\t\t\t\t\ta[i][j]+=LCM(a[i-1][j],a[i+1][j],a[i][j-1],a[i][j+1]);\n\t\t\t\tst.insert(a[i][j]);\n\t\t\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\ntemplate <typename T>\nvoid chkmax(T &dp, const T &val) {\n    if (val > dp) {\n        dp = val;\n    }\n}\n\nconst size_t N = 5E2 + 5;\nconst size_t M = 2E4 + 5;\n\nbool npr[M];\nmap<int, int> mp[N][N];\nLL a[N][N];\n\nvoid upd(map<int, int> &mp, const map<int, int> &dat) {\n    for (auto &pr : dat) {\n        int p = pr.first, e = pr.second;\n        chkmax(mp[p], e);\n    }\n}\n\nLL get_val(const map<int, int> &mp) {\n    LL ret = 1;\n    for (const auto &pr : mp) {\n        int p = pr.first, e = pr.second;\n        while (e--) {\n            ret *= p;\n        }\n    }\n    return ret;\n}\n\nLL calc(LL a, LL b) {\n    if (a < b) swap(a, b);\n    return a % b;\n}\n\nint main() {\n    vector<int> vc;\n    for (uint i = 2; i < M; ++i) {\n        if (!npr[i]) {\n            vc.emplace_back(i);\n            for (uint j = i << 1; j < M; j += i) {\n                npr[j] = true;\n            }\n        }\n    }\n\n    int n = read(), c = 0;\n    if (n == 2) {\n        puts(\"4 7\\n23 10\");\n        return 0;\n    }\n    for (int s = 2; s <= n + n; ++s) {\n        if (s & 1) continue;\n        for (int i = 1; i <= n; ++i) {\n            int j = s - i;\n            if (1 <= i && i <= n &&\n                1 <= j && j <= n) {\n                ++mp[i][j][vc[c]];\n            }\n        }\n        ++c;\n    }\n    for (int d = 1 - n; d <= n - 1; ++d) {\n        if (d & 1) continue;\n        for (int i = 1; i <= n; ++i) {\n            int j = d + i;\n            if (1 <= i && i <= n &&\n                1 <= j && j <= n) {\n                ++mp[i][j][vc[c]];\n            }\n        }\n        ++c;\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if ((i ^ j) & 1) {\n                upd(mp[i][j], mp[i - 1][j]);\n                upd(mp[i][j], mp[i][j - 1]);\n                upd(mp[i][j], mp[i][j + 1]);\n                upd(mp[i][j], mp[i + 1][j]);\n                a[i][j] = get_val(mp[i][j]) + 1;\n            } else {\n                a[i][j] = get_val(mp[i][j]);\n            }\n            printf(\"%lld%c\", a[i][j], \"\\n \"[j < n]);\n        }\n    }\n    set<LL> s1, s2;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (i < n) s1.emplace(calc(a[i][j], a[i + 1][j]));\n            if (j < n) s1.emplace(calc(a[i][j], a[i][j + 1]));\n            s2.emplace(a[i][j]);\n        }\n    }\n    assert(s1.size() == 1 && *s2.rbegin() <= (LL) 1E15 && s2.size() == n * n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 510\n#define LL long long \n#define INF 0x3f3f3f3f\n\nint n,m;\nLL G[maxn][maxn];\n\nLL gcd(LL x,LL y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\n\nint main(){\n\t//freopen(\"test.in\",\"r\",stdin);\n\t\n\tcin>>n;\n\tLL p=n*n,cha=n*n-1;\n\t\n\tfor(int i=1;i<2*n;i++){\n\t\tif(i%2){\n\t\t\tG[i/2+1][i/2+1]=p;\n\t\t}else{\n\t\t\tG[i/2][i/2+1]=p;\n\t\t}\n\t\tp+=cha;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(G[i][j]==0){\n\t\t\t\tLL x,y;\n\t\t\t\tif(i<j){\n\t\t\t\t\tx=G[i][i+1];\n\t\t\t\t\ty=G[j-1][j];\n\t\t\t\t}else{\n\t\t\t\t\tx=G[i][i];\n\t\t\t\t\ty=G[j][j];\n\t\t\t\t}\n\t\t\t\tG[i][j]=x*y/gcd(x,y)+cha;\n\t\t\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) cout<<G[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 500;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() < MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }               \n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint pri[N]; bool vis[N];\nvoid init (int n)\n{\n\tfor (int i=2; ; i++)\n\t{\n\t\tif (!vis[i]) pri[++pri[0]]=i;\n\t\tif (pri[0]==n) break;\n\t\tfor (int j=1; j<=pri[0]; j++)\n\t\t{\n\t\t\tint p=pri[j],k=i*p;\n\t\t\tif (k> 10000) break;\n\t\t\tvis[k]=1;\n\t\t\tif (i%p==0) break;\n\t\t}\n\t}\n}\nLL lcm (LL x,LL y) { return (!x||!y)?(x+y):(x*y/__gcd (x,y)); }\nint n; LL a[1010][1010];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n); init (n<<1);\n\tif (n==2) return puts(\"4 7\\n23 10\"),0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if ((i+j+1)&1)\n\t\t\ta[i][j]=pri[(i+j)/2]*pri[n+(i-j)/2+(n+1)/2];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if (!a[i][j])\n\t\t\ta[i][j]=lcm (lcm (a[i-1][j],a[i][j-1]),lcm (a[i+1][j],a[i][j+1]))+1;\n\tfor (int i=1; i<=n; i++,putchar('\\n'))\n\t\tfor (int j=1; j<=n; j++,putchar(' '))\n\t\t\tprint(a[i][j]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 100005;\n\nint n;\nbool p[100005];\nvi primes;\n\nvoid sieve() {\n\tMMS(p, 1);\n\tp[0] = p[1] = 0;\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i]) {\n\t\t\tfor (int j = 2 * i; j < N; j += i)\n\t\t\t\tp[j] = 0;\n\t\t}\n\t}\n\tfor (int i = 2; i < N; i++) {\n\t\tif (p[i])\n\t\t\tprimes.pb(i);\n\t}\n}\n\nll a[501][501];\n\nll setV(int i, int j) {\n\tint d0 = (i + j) >> 1;\n\tint d1 = n + ((i - j + n - 1) >> 1);\n\treturn primes[d0] * 1LL * primes[d1];\n}\n\nll getI(int i, int j) {\n\treturn primes[(i + j) >> 1];\n}\n\nll getJ(int i, int j) {\n\treturn primes[n + ((i - j + n - 1) >> 1)];\n}\n\nll calc(int i, int j) {\n\tll res = 1;\n\tset<ll> S;\n\tif (i + 1 >= 0 && i + 1 < n)\n\t\tS.insert(getI(i + 1, j));\n\tif (i - 1 >= 0 && i - 1 < n)\n\t\tS.insert(getI(i - 1, j));\n\tif (j + 1 >= 0 && j + 1 < n)\n\t\tS.insert(getJ(i, j + 1));\n\tif (j - 1 >= 0 && j - 1 < n)\n\t\tS.insert(getJ(i, j - 1));\n\tfor (auto x : S) {\n\t\tres = (res * x) / __gcd(res, x);\n\t}\n\treturn res + 1;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tsieve();\n\tcin >> n;\n\tll mx = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1) == 0) {\n\t\t\t\ta[i][j] = setV(i, j);\n\t\t\t\tmx = max(mx, a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (((i + j) & 1)) {\n\t\t\t\ta[i][j] = calc(i, j);\n\t\t\t\tmx = max(mx, a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif (n == 2) {\n\t\ta[1][0] *= 2;\n\t\ta[1][0]--;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << a[i][j] << \" \\n\"[j == n - 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nll a[MAXN][MAXN],prime[MAXN];\nbool check(int x)\n{\n\tfor (int i=2;1ll*i*i<=x;i++)\n\t\tif (x%i==0) return 0;\n\treturn 1;\n}\nll gcd(ll x,ll y) { return y==0?x:gcd(y,x%y); }\nint main()\n{\n\tint n=read(),num=0;\n\tif (n==2) { printf(\"4 7\\n23 10\\n\"); return 0; }\n\tfor (int i=2;i<=100000;i++)\n\t\tif (check(i))\n\t\t{\n\t\t\tprime[++num]=i;\n\t\t\tif (num==n<<1) break;\n\t\t}\n\tfor (int i=0;i<=n+1;i++)\n\t\tfor (int j=0;j<=n+1;j++) a[i][j]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i&1)^(j&1)) continue;\n\t\t\ta[i][j]=prime[(i+j)>>1]*prime[n+((i-j+n+1)>>1)];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i&1)^(j&1)) a[i][j]=max(a[i-1][j]*a[i+1][j],a[i][j-1]*a[i][j+1])+1;\n\tif ((n+1)&1)\n\t{\n\t\ta[n][1]=a[n-1][1]*a[n][2]/gcd(a[n-1][1],a[n][2])+1;\n\t\ta[1][n]=a[2][n]*a[1][n-1]/gcd(a[2][n],a[1][n-1])+1;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nll T, n, m;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    n = 500;\n    vector<vector<ll>> m(n + 2, vector<ll>(n + 2, 1));\n    set<ll> used;\n    ll c = 2;\n    for(int i=1;i<=n;i+=2) {\n        for(int j=1;j<=n;j+=4) {\n            while(used.count(c) + used.count(c * 2)) c++;\n            used.insert(c);\n            used.insert(c * 2);\n            m[i][j] = c;\n            m[i+1][j+1] = c*2;\n        }\n    }\n    for(int i=1;i<=n;i+=2) {\n        for(int j=3;j<=n;j+=4) {\n            while(used.count(c) + used.count(c * 2)) c++;\n            used.insert(c);\n            used.insert(c * 2);\n            m[i][j] = c;\n            m[i+1][j+1] = c*2;\n        }\n    }\n\n    for(int i=1;i<=n;i+=1) {\n        for(int j=1;j<=n;j+=1) {\n            if (m[i][j] != 1) {\n                continue;\n            }\n            ll x = m[i-1][j] / __gcd(m[i-1][j], m[i+1][j]) * m[i+1][j];\n            x = x / __gcd(x, m[i][j-1]) * m[i][j-1];\n            x = x / __gcd(x, m[i][j+1]) * m[i][j+1];\n            ll y = x;\n            while (used.count(y + 1)) y += x;\n            m[i][j] = y + 1;\n            used.insert(y + 1);\n        }\n    }\n\n//    assert(used.size() == n * n);\n//    ll mx = 0;\n//    REPS(i, n)REP(j, n) mx = max(mx, m[i][j]);\n//    cerr << \"MAX: \" << mx << endl;\n//    REPS(i, n) {\n//        REPS(j, n) {\n//            assert(0 < m[i][j] && m[i][j] <= 1000000000000000ll);\n//            if (i + 1 <= n) {\n//                ll x = max(m[i][j], m[i + 1][j]);\n//                ll y = min(m[i][j], m[i + 1][j]);\n//                if (x % y != 1) {\n//                    cout << i << \", \" << j << m[i][j] << \", \" << m[i + 1][j] << endl;\n//                }\n//                assert(x % y == 1);\n//            }\n//            if (j + 1 <= n) {\n//                ll x = max(m[i][j], m[i][j + 1]);\n//                ll y = min(m[i][j], m[i][j + 1]);\n//                assert(x % y == 1);\n//            }\n//        }\n//    }\n\n    cin >> n;\n    REPS(i, n) {\n        REPS(j, n) {\n            cout << m[i][j] << \" \\n\"[j == n];\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5, M = 1005;\nint n, a[M][M], prime[N], vis[N], tot;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid init(int n)\n{\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\tif(!vis[i]) prime[++ tot] = i;\n\t\tfor(int j = 1; j <= tot && i * prime[j] <= n; j ++)\n\t\t{\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n//int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\nint lcm(int a, int b) {return a / gcd(a, b) * b;}\n//\n//long long lcm(long long x, long long y) {\n//    if (!x || !y) return x + y;\n//    return x / gcd(x, y) * y;\n//}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tinit(10000); n = read();\n\tif(n == 2) {puts(\"4 7\\n23 10\\n\"); return 0;}\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = ((i + 1) & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = (i & 1) + 1; j <= n; j += 2)\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i + 1][j], a[i][j + 1])) + 1;\n\tfor(int i = 1; i <= n; i ++, printf(\"\\n\"))\n\t\tfor(int j = 1; j <= n; j ++, printf(\" \"))\n\t\t\tprintf(\"%lld\", a[i][j]);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#  define _GLIBCXX_DEBUG_PEDANTIC\n#endif\n\n#include \"bits/stdc++.h\"\n#define ff first\n#define ss second\n#define szof(_x) ((int) (_x).size())\n#define TASK_NAME \"\"\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\nconst ll INFL = 1e18 + 123;\nconst double PI = atan2(0, -1);\nmt19937 tw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(tw) % (y - x + 1) + x; }\n\nconst ll MAXV = 1000000000000000;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid solve() {\n\tint prime_cnt = 2;\n\tmap<pii, int> primes;\n\tauto get_prime = [&](pii p) {\n\t\tif (primes.count(p)) {\n\t\t\treturn primes[p];\n\t\t}\n\t\tif (p.ff == 0 && p.ss % 4 == 1) {\n\t\t\treturn primes[p] = 1;\n\t\t}\n\t\twhile (true) {\n\t\t\tbool fl = true;\n\t\t\tfor (int j = 2; j * j <= prime_cnt; ++j) {\n\t\t\t\tif (prime_cnt % j == 0) {\n\t\t\t\t\tfl = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fl) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++prime_cnt;\n\t\t}\n\t\treturn primes[p] = prime_cnt++;\n\t};\n\tint n;\n\tcin >> n;\n\tvector<vector<ll>> ans(n, vector<ll>(n));\n\t// int cnt = 2;\n\tset<ll> have;\n\tvector<pii> order;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif ((i + j) & 1) {\n\t\t\t\torder.push_back({i, j});\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto p : order) {\n\t\tint i, j;\n\t\ttie(i, j) = p;\n\t\tans[i][j] = get_prime({0, i + j}) * get_prime({1, i - j});\n\t\thave.insert(ans[i][j]);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (!((i + j) & 1)) {\n\t\t\t\tll res = 1;\n\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\tint nx = i + dx[d];\n\t\t\t\t\tint ny = j + dy[d];\n\t\t\t\t\tif (0 <= nx && nx < n && 0 <= ny && ny < n) {\n\t\t\t\t\t\tll tmp = __gcd(res, ans[nx][ny]);\n\t\t\t\t\t\tassert((double) res * ans[nx][ny] / tmp < 1e18);\n\t\t\t\t\t\tres = res / tmp * ans[nx][ny];\n\t\t\t\t\t\tif (res > MAXV) {\n\t\t\t\t\t\t\tcerr << i << \" \" << j << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(res <= MAXV);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint mult = 1;\n\t\t\t\twhile (have.count(res * mult + 1)) {\n\t\t\t\t\t++mult;\n\t\t\t\t\tassert(res * mult + 1 <= MAXV);\n\t\t\t\t}\n\t\t\t\tans[i][j] = res * mult + 1;\n\t\t\t\thave.insert(ans[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\tint nx = i + dx[d];\n\t\t\t\tint ny = j + dy[d];\n\t\t\t\tif (0 <= nx && nx < n && 0 <= ny && ny < n) {\n\t\t\t\t\tassert(max(ans[nx][ny], ans[i][j]) % min(ans[nx][ny], ans[i][j]) == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto& v : ans) {\n\t\tfor (auto num : v) {\n\t\t\tcout << num << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}\n\n\nint main() {\n\t//freopen(TASK_NAME \".in\", \"r\", stdin);\n\t//freopen(TASK_NAME \".out\", \"w\", stdout);\n\tcerr << fixed << setprecision(15);\n\tcout << fixed << setprecision(15);\n\tios::sync_with_stdio(false);\n\n\tint tests = 1;\n\t// cin >> tests;\n\tfor (int it = 1; it <= tests; ++it) {\n\t\tsolve();\n\t}\n\t\n\t#ifdef LOCAL\n\t\tcerr << \"time: \" << clock() << \" ms\\n\";\n\t#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N;\nbool prime[1000005];\nvector<llint> pvec;\nllint ans[505][505];\nconst llint di[] = {1, 0, -1, 0}, dj[] = {0, -1, 0, 1};\n\nint main(void)\n{\n\tcin >> N;\n\t\n\tfor(int i = 2; i < 1005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j += i) prime[j] = true;\n\t}\n\tfor(int i = 3; i < 1000005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\t/*vector<llint> vec;\n\tfor(int i = 0; i < pvec.size(); i++){\n\t\tfor(int j = 0; j < 16; j++) vec.push_back(pvec[i] << j);\n\t}\n\tsort(vec.begin(), vec.end());\n\tpvec = vec;*/\n\t\n\tllint pos = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0 && j % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2 && j % 2){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif((i+j)%2 && i % 2 == 0 && j%2==0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = N; i >= 1; i--){\n\t\tfor(int j = N; j >= 1; j--){\n\t\t\tif((i+j)%2 && i % 2 && j%2==0){\n\t\t\t\tans[i][j] = pvec[pos++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(ans[i][j]) continue;\n\t\t\tllint tmp = 1;\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif(ni > N || nj < 1 || nj > N) continue;\n\t\t\t\tif(ni < 1) tmp *= 2;\n\t\t\t\telse tmp *= ans[ni][nj];\n\t\t\t}\n\t\t\ttmp++;\n\t\t\tans[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t max_N, size_t prime_size>\nstruct Prime{\n    bool sieve[max_N];\n    int_fast64_t prime[prime_size];\n    size_t counter = 0;\n    constexpr Prime() : sieve(), prime() {\n        for(int_fast64_t i = 0; i < max_N; ++i)\n            sieve[i] = true;\n        sieve[0] = sieve[1] = false;\n        for(int_fast64_t i = 2; i < max_N; ++i){\n            if(sieve[i]){\n                prime[counter] = i;\n                ++counter;\n                if(counter >= prime_size)break;\n            }\n            for(int_fast64_t j = i * i; j < max_N; j += i)\n                sieve[j] = false;\n        }\n    }\n    constexpr int_fast64_t operator[](size_t i) const{\n        return i < counter ? prime[i] : prime[counter - 1];\n    }\n};\n\nconstexpr Prime<8831, 1000> p = Prime<8831, 1000>();\n\nconstexpr int_fast64_t gcd(int_fast64_t a, int_fast64_t b){\n    int_fast64_t t(0);\n    while(b){\n        t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b){\n    return a / gcd(a, b) * b;\n}\n\nconstexpr int_fast64_t lcm(int_fast64_t a, int_fast64_t b, int_fast64_t c, int_fast64_t d){\n    return lcm(lcm(a, b), lcm(c, d));\n}\n\nstruct Ans{\n    int_fast64_t ans[502][502];\n    constexpr size_t v(size_t i){\n        return i & 1 ? i / 2 : 999 - i / 2;\n    }\n    constexpr Ans() : ans(){\n        for(size_t i = 0; i < 501; ++i){\n            ans[i][0] = 1;\n            ans[501][i] = 1;\n            ans[i + 1][501] = 1;\n            ans[0][i + 1] = 1;\n        }\n        for(size_t i = 1; i <= 500; i += 2)\n            for(size_t j = 1; j <= 500; j += 2){\n                ans[i][j] = p[v((i + j - 2) / 2)] * p[v((1500 + i - j) / 2)];\n                if(i < 500 && j < 500)ans[i + 1][j + 1] = p[v((i + j) / 2)] * p[v((1500 + i - j) / 2)];\n            }\n        for(size_t i = 1; i < 500; i += 2)\n            for(size_t j = 1; j < 500; j += 2){\n                ans[i + 1][j] = lcm(ans[i][j], ans[i + 2][j], ans[i + 1][j + 1], ans[i + 1][j - 1]) + 1;\n                ans[i][j + 1] = lcm(ans[i][j], ans[i][j + 2], ans[i + 1][j + 1], ans[i - 1][j + 1]) + 1;\n            }\n    }\n    constexpr int_fast64_t at(size_t i, size_t j)const{\n        return ans[i + 1][j + 1];\n    }\n};\n\nconstexpr Ans a = Ans();\nint_fast64_t N;\n\nint main(){\n    scanf(\"%lld\", &N);\n    for(size_t i = 0; i < N; ++i){\n        for(size_t j = 0; j < N; ++j)printf(\"%lld \", a.at(i, j));\n        puts(\"\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define m long long\n#define r(s,i,n) for(m i=s;i<n;i++)\nm w[555][555],p[1234];\nint main(){m n;cin>>n;m t=0,k=555;r(2,i,9999){bool a=true;r(2,j,i){if(i%j==0)a=false;}if(a)p[t]=i,t++;}r(0,i,k)r(0,j,k)if(i%2==j%2)w[i][j]=p[(i+j)/2]*p[(i+k*3-j)/2];r(0,i,k)r(0,j,k)if(w[i][j]==0&&i>0&&i<554)w[i][j]=w[i-1][j]*w[i+1][j]+1;r(0,i,n)r(0,j,n)cout<<w[i+1][j+1]<<\" \";}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int MAXN = 1e6 + 10;\nint N;\nint a[501][501], vis[MAXN], prime[MAXN], tot;\nvoid GetPhi() {\n\tvis[1] = 1;\n\tfor(int i = 2; i; i++) {\n\t\tif(!vis[i]) prime[++tot] = i;\n\t\tif(tot == 1000) break; \n\t\tfor(int j = 1; j <= tot && (i * prime[j] <= 100000); j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(!(i % prime[j])) break;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tif(x == 0 || y == 0) return x + y;\n\treturn x / __gcd(x, y) * y;\n}\nmain() {\n\tGetPhi();\n\tcin >> N;\n\tif(N == 2) {\n\t\tprintf(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i <= N; i++) \n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!((i + j) & 1)) a[i][j] = prime[(i + j) / 2] * prime[N + (i - j) / 2 + (N + 1) / 2];\n\tfor(int i = 1; i <= N; i++)\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tif(!a[i][j]) \n\t\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]), lcm(a[i][j + 1], a[i + 1][j])) + 1;\n\tfor(int i = 1; i <= N; i++, puts(\"\"))\n\t\tfor(int j = 1; j <= N; j++)\n\t\t\tcout << a[i][j] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005;\nconst ll INF=1LL<<60;\n\nvector<int> prime;//i番目の素数\nbool is_prime[500003+1];\n\nvoid sieve(int n){\n    for(int i=0;i<=n;i++){\n        is_prime[i]=true;\n    }\n    \n    is_prime[0]=is_prime[1]=false;\n    \n    for(int i=2;i<=n;i++){\n        if(is_prime[i]){\n            prime.push_back(i);\n            prime.push_back(i);\n            for(int j=2*i;j<=n;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nll ans[MAX][MAX];\n\nll gcd(ll a,ll b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    sieve(500001);\n    \n    for(int j=0;j<MAX;j+=2){\n        ans[0][j]=prime[j];\n        //cout<<ans[0][j]<<endl;\n    }\n    \n    for(int j=1;j<MAX-1;j+=2){\n        ans[1][j]=ans[0][j-1]*ans[0][j+1];\n    }\n    \n    for(int i=2;i<MAX;i++){\n        for(int j=i;j<MAX-i;j+=2){\n            ll x=gcd(ans[i-1][j-1],ans[i-2][j]),y=gcd(ans[i-1][j+1],ans[i-2][j]);\n            ans[i][j]=(ans[i-1][j-1]/x)*(ans[i-1][j+1]/y);\n        }\n    }\n    \n    for(int i=1;i<MAX-1;i++){\n        for(int j=i+1;j<MAX-i-1;j+=2){\n            ans[i][j]=ans[i][j-1]*ans[i][j+1]+1;\n        }\n    }\n    \n    int N;cin>>N;\n    \n    for(int i=1;i<1+N;i++){\n        for(int j=501;j<501+N;j++){\n            cout<<ans[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<map>\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,ans;\nint ss[100010];bool pri[100010];\nvoid init(){\n\tfor(rt i=2;i<=100000;i++){\n\t\tif(!pri[i])ss[++cnt]=i;\n\t\tfor(rt j=1;j<=cnt&&i*ss[j]<=100000;j++){\n\t\t\tpri[i*ss[j]]=1;\n\t\t\tif(i%ss[j]==0)break;\n\t\t}\n\t}\n}\nll a[505][505];\nll lcm(ll x,ll y){\n\tif(!x)return y;if(!y)return x;\n\treturn x/__gcd(x,y)*y;\n}\nmap<ll,bool>s;\nint main(){\n\tn=r;\n\tif(n==2)return printf(\"10 31\\n61 15\"),0;\n\tinit();\n\tfor(rt i=1;i<=n;i++)\n\tfor(rt j=1;j<=n;j++)if(i+j&1^1){\n\t\ta[i][j]=1ll*ss[(i+j)/2]*ss[(i-j)/2+n+n/2+1];\n\t}\n\tfor(rt i=1;i<=n;i++)for(rt j=1;j<=n;j++)if(i+j&1){\n\t\ta[i][j]=lcm(lcm(a[i+1][j],a[i][j+1]),lcm(a[i-1][j],a[i][j-1]))+1;\n\t}\n\tfor(rt i=1;i<=n;i++)for(rt j=1;j<=n;j++)cout<<a[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconstexpr int maxn = 10010;\ntypedef long long ll;\nint mnp[maxn], p[maxn], cnt;\nvoid sieve(int n) {\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (!mnp[i]) mnp[i] = i, p[cnt++] = i;\n\t\tfor (int j = 0; j < cnt && p[j] * i <= n; ++j) {\n\t\t\tmnp[p[j] * i] = p[j];\n\t\t\tif (i % p[j] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nint n; ll a[600][600];\ninline int get1(int x, int y) {\n\tif (x + y < 0 || (x + y) >> 1 >= n) return 1;\n\treturn p[(x + y) >> 1];\n}\ninline int get2(int x, int y) {\n\tif ((x - y) >> 1 < 0 || (x + n - y) >> 1 >= n) return 1;\n\treturn p[((x - y) >> 1) + n];\n}\nint main() {\n\tsieve(10000);\n\tstd::cin >> n;\n\tif (n == 2) {\n\t\tstd::cout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tstd::cout << ((i + j) % 2 == 0 ? 1ll * get1(i, j) * get2(i, j) : 1ll * get1(i, j - 1) * get1(i, j + 1) * get2(i, j - 1) * get2(i, j + 1) + 1) << \"\\n \"[j != n - 1];\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-9-15 22:13:36\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint main()\n{\n  int N;\n  cin >> N;\n  for (auto i = 0; i < N; i++)\n  {\n    for (auto j = 0; j < N; j++)\n    {\n      cout << i + j + 2;\n      if (j < N - 1)\n      {\n        cout << \" \";\n      }\n      else\n      {\n        cout << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    vi primes;\n\n    const int MAXV = 10000;\n    vi sieve(MAXV);\n    for (int p = 2; p < MAXV; p++) {\n        if (sieve[p]) continue;\n        primes.push_back(p);\n        for (int q = p; q < MAXV; q += p) {\n            sieve[q] = p;\n        }\n    }\n\n    int tail = 0;\n    map<int, ll> sdiag, ddiag;;\n    auto get = [&primes, &tail](map<int, ll>& m, int i) {\n        if (m.count(i)) return m[i];\n        return m[i] = primes[tail++];\n    };\n\n    auto lcm = [](ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    };\n\n    int N;\n    cin >> N;\n\n    vvll res(N, vll(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if ((i+j)&1) continue;\n            res[i][j] = get(sdiag, i+j) * get(ddiag, i-j);\n        }\n    }\n\n    int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (((i+j)&1) == 0) continue;\n            res[i][j] = 1;\n            for (auto [dx, dy] : dir) {\n                res[i][j] = lcm(res[i][j], get(sdiag, i+j+dx+dy) * get(ddiag, i-j+dx-dy));\n            }\n            res[i][j]++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cout << res[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n[agc027] D - Modulo Matrix\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\n\nconst int MAX_N = 500;\nconst int MAX_PRIME = 10000;\n\nll gcd(ll a, ll b) {\n    while (b > 0) {\n        swap(a %= b, b);\n    }\n    return a;\n}\n\nll lcm(ll a, ll b) {\n    ll d = gcd(a, b);\n    return (a / d) * (b / d) * d;\n}\n\nint N;\nvector<int> primes;\n\nvoid eratos() {\n    vector<bool> is_prime(MAX_PRIME, true);\n    for (int i = 2; i < MAX_PRIME; i++) {\n        if (!is_prime[i]) {\n            continue;\n        }\n        primes.push_back(i);\n        for (int j = 2 * i; j < MAX_PRIME; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid solve(vector<vector<ll>>& ans) {\n    eratos();\n\n    ans.resize(N);\n    for (int i = 0; i < N; i++) {\n        ans[i].resize(N);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = (i % 2); j < N; j += 2) {\n            int p = (i + j) / 2;\n            int q = (i - j + N) / 2;\n            ans[i][j] = primes[(p % 2 == 0) ? (p / 2) : (N - 1 - p / 2)] *\n                        primes[(q % 2 == 0) ? (q / 2) : (N - 1 - q / 2) + N];\n        }\n    }\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {-1, 0, 1, 0};\n    for (int i = 0; i < N; i++) {\n        for (int j = 1 - (i % 2); j < N; j += 2) {\n            ans[i][j] = 1;\n            for (int k = 0; k < 4; k++) {\n                if (0 <= i + di[k] && i + di[k] < N && 0 <= j + dj[k] &&\n                    j + dj[k] < N) {\n                    ans[i][j] = lcm(ans[i][j], ans[i + di[k]][j + dj[k]]);\n                }\n            }\n            ans[i][j]++;\n        }\n    }\n}\n\nint main() {\n    cin >> N;\n\n    vector<vector<ll>> ans;\n    solve(ans);\n\n    for (auto& row : ans) {\n        for (ll a : row) {\n            cout << a << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\n#define M 1010\nusing namespace std;\nint a[M][M],vis[N],p[N],ptot;\nvoid init(){\n\tvis[1]=1;\n\tint i=2;\n\twhile (true){\n\t\tif (!vis[i]) p[++ptot]=i;\n\t\tif (ptot==1000) break;\n\t\tfor (int j=1;j<=ptot && (i*p[j]<=10000);++j){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif (!(i%p[j])) break;\n\t\t}\n\t\ti++;\n\t}\n}\nint lcm(int x,int y){\n\tif (x==0 || y==0) return x+y;\n\treturn x/__gcd(x,y)*y;\n}\nsigned main(){\n\tinit();\n\tint n;cin>>n;\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");return 0;\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (!((i+j)&1)) a[i][j]=p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (!a[i][j]) a[i][j]=lcm(lcm(a[i-1][j],a[i][j-1]),lcm(a[i][j+1],a[i+1][j]))+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tprintf(\"%lld \",a[i][j]);\n\t\t} \n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1005;\nint a[N][N],flag[N*10],P[N*10],tot,n; \nint check1(int x,int y){\n\treturn (x+y)/2;\n}\nint check2(int x,int y){\n\treturn (x-y+n+1)/2;\n}\nint Lcm(int x,int y){\n\tif (!x||!y)return x+y;\n\treturn x/__gcd(x,y)*y;\n} \nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])for (int j=2*i;j<=10000;j++)flag[j]=1;\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])P[++tot]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1)a[i][j]=P[check1(i,j)]*P[check2(i,j)+n+1];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=Lcm(Lcm(a[i+1][j],a[i-1][j]),Lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vll vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1e4+5;\nconst ll M=1005;\nll vis[N],p[N],tot,a[M][M],n;\nvoid init(ll n){\n\tfor(ll i=2;i<=n;i++){\n\t\tif(!vis[i])p[++p[0]]=i;\n\t\tfor(ll j=1;j<=p[0]&&i*p[j]<=n;j++){\n\t\t\tvis[i*p[j]]=1;\n\t\t\tif(!(i%p[j]))break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){\n\tif(y==0)return x;\n\telse return gcd(y,x%y);\n}\nll lcm(ll x,ll y){\n\tif(!x||!y)return x+y;\n\treturn x/gcd(x,y)*y;\n}\nsigned main(){\n\tn=read();init(1e4);\n\tif(n==2)return cout<<\"4 7\\n23 10\",signed();\n\tfor(ll i=1;i<=n;i++)for(ll j=(i+1&1)+1;j<=n;j+=2)a[i][j]=p[(i+j)/2]*p[n+(i-j)/2+(n+1)/2];\n\tfor(ll i=1;i<=n;i++)for(ll j=(i&1)+1;j<=n;j+=2)if((i+j)&1)a[i][j]=lcm(a[i-1][j],lcm(a[i+1][j],lcm(a[i][j-1],a[i][j+1])))+1;\n\tfor(ll i=1;i<=n;i++,cout<<'\\n')for(ll j=1;j<=n;j++,cout<<' ')cout<<a[i][j];\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\n\n/*******************************************************/\n\n// n = 1.5e6 -> size = 114155, 800 ms\nvll list_prime_until(int n) {\n\tif (n < 2) return{};\n\tvll ret;\n\tlist<ll> lists(n - 1);\n\tint x = 2;\n\tLoopitr(itr, lists) {\n\t\t*itr = x++;\n\t}\n\tauto begin_itr = lists.begin();\n\twhile (begin_itr != lists.end() && (*begin_itr) * (*begin_itr) < (ll)n) {\n\t\tauto itr = begin_itr;\n\t\titr++;\n\t\twhile (itr != lists.end()) {\n\t\t\tif (*itr % *begin_itr == 0) itr = lists.erase(itr);\n\t\t\telse itr++;\n\t\t}\n\t\tbegin_itr++;\n\t}\n\tLoopitr(itr, lists) {\n\t\tret.push_back(*itr);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvvll table1(n, vll(n, 0));\n\tvvll table2(n, vll(n, 0));\n\tvvll ans(n, vll(n, 1));\n\tif (n == 2) {\n\t\tans = { {2,3}, {5,16} };\n\t}\n\telse {\n\t\tvll primes = list_prime_until(10000);\n\t\tint p = 0;\n\t\tfor (int k = 0; k < n; k += 2) {\n\t\t\tint i, j;\n\t\t\ti = k;\n\t\t\tj = 0;\n\t\t\twhile (i < n) {\n\t\t\t\ttable1[i][j] = primes[p];\n\t\t\t\tans[i][j] *= primes[p];\n\t\t\t\t++i; ++j;\n\t\t\t}\n\t\t\t++p;\n\t\t\tif (k == 0) continue;\n\t\t\ti = 0;\n\t\t\tj = k;\n\t\t\twhile (j < n) {\n\t\t\t\ttable1[i][j] = primes[p];\n\t\t\t\tans[i][j] *= primes[p];\n\t\t\t\t++i; ++j;\n\t\t\t}\n\t\t\t++p;\n\t\t}\n\t\tp = 999;\n\t\tfor (int k = 0; k < n; k += 2) {\n\t\t\tint i, j;\n\t\t\ti = 0;\n\t\t\tj = k;\n\t\t\twhile (j >= 0) {\n\t\t\t\ttable2[i][j] = primes[p];\n\t\t\t\tans[i][j] *= primes[p];\n\t\t\t\t++i; --j;\n\t\t\t}\n\t\t\t--p;\n\t\t\tif (k == n - 1) continue;\n\t\t\ti = n - 1;\n\t\t\tj = n - 1 - k;\n\t\t\twhile (j < n) {\n\t\t\t\ttable2[i][j] = primes[p];\n\t\t\t\tans[i][j] *= primes[p];\n\t\t\t\t--i; ++j;\n\t\t\t}\n\t\t\t--p;\n\t\t}\n\t\tLoop(i, n) {\n\t\t\tLoop(j, n) {\n\t\t\t\tif (ans[i][j] == 1) {\n\t\t\t\t\tvll vals(4, 1);\n\t\t\t\t\tif (i - 1 >= 0) vals[0] = table1[i - 1][j];\n\t\t\t\t\tif (j + 1 < n) vals[0] = table1[i][j + 1];\n\t\t\t\t\tif (j - 1 >= 0) vals[1] = table1[i][j - 1];\n\t\t\t\t\tif (i + 1 < n) vals[1] = table1[i + 1][j];\n\t\t\t\t\tif (i - 1 >= 0) vals[2] = table2[i - 1][j];\n\t\t\t\t\tif (j - 1 >= 0) vals[2] = table2[i][j - 1];\n\t\t\t\t\tif (i + 1 < n) vals[3] = table2[i + 1][j];\n\t\t\t\t\tif (j + 1 < n) vals[3] = table2[i][j + 1];\n\t\t\t\t\tans[i][j] = vals[0] * vals[1] * vals[2] * vals[3] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintmx(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int MAXP = 10002;\nbool np[MAXP];\n\nvector<int> primes; \n\nvoid sieve() {\n    for (int i = 2; i < MAXP; ++i) {\n        if (!np[i]) {\n            primes.push_back(i);\n\n            for (ll j = i * i; j < MAXP; j += i) {\n                np[j] = true;\n            }\n        }\n    }\n}\n\nll gcd(ll a, ll b) {\n    while (b) {\n        ll c = a % b;\n        a = b;\n        b = c;\n    }\n\n    return a;\n}\n\nconst ll MAXV = 1e15 - 2;\n\nll lcm(ll a, ll b) {\n    ll ans = a / gcd(a, b) * b;\n    assert(ans <= MAXV);\n    return ans;\n}\n\nll a[502][502];\n\nint mx[] = { -1, 0, 1, 0 };\nint my[] = { 0, -1, 0, 1 };\n\nvoid precalc() {\n    sieve();\n    int n = 500;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 0) {\n                int x = (i + j) / 2;\n                int y = (i - j) / 2 + n / 2 + n;\n                a[i][j] = primes[x] * primes[y];\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                a[i][j] = 1;\n                if (i > 0) {\n                    a[i][j] = lcm(a[i][j], a[i - 1][j]);\n                }\n\n                if (i + 1 < n) {\n                    a[i][j] = lcm(a[i][j], a[i + 1][j]);\n                }\n\n                if (j > 0) {\n                    a[i][j] = lcm(a[i][j], a[i][j - 1]);\n                }\n\n                if (j + 1 < n) {\n                    a[i][j] = lcm(a[i][j], a[i][j + 1]);\n                }\n\n                ++a[i][j];\n            }\n        }\n    }\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    precalc();\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << a[i][j];\n            cout << \" \";\n        }\n        cout << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define fr(i,a,b) for (int i = b-1; i >= a; i--)\n#define pb push_back\n#define IN(i,a,b) (a<=i&&i<=b)\n\nint di[] = {0,0,1,-1};\nint dj[] = {1,-1,0,0};\n\nll gcd(ll a, ll b) {\n\treturn a?gcd(b%a,a):b;\n}\n \nll lcm(ll a, ll b) {\n\treturn a/gcd(a,b)*b;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tint n; cin>>n;\n\tif (n==2) {\n\t\tcout << \"4 7\" << endl << \"23 10\" << endl;\n\t} else {\n\t\tll a[n][n];\n\t\tint mxn = 1e5;\n\t\tint sieve[mxn];\n\t\tfill(sieve,sieve+mxn,0);\n\t\tvi primes;\n\t\tf(i,2,mxn) if (sieve[i] == 0) {\n\t\t\tprimes.pb(i);\n\t\t\tfor (int j = i; j <mxn; j+=i)\n\t\t\t\tsieve[j] = i;\n\t\t}\n\t\tll x[2*n],y[2*n];\n\t\tint t = 0;\n\t\tfor (int i = 0; i < 2*n; i+=2)\n\t\t\tx[i]=x[i+1]=primes[t++];\t\n\t\tfor (int j = 0; j < 2*n; j+=2)\n\t\t\ty[j]=y[j+1]=primes[t++];\n\t\tfr(i,0,n) y[i] = primes[t++];\n\t\tf(i,0,n) f(j,0,n) if (!((i+j)&1)) \t\n\t\t\ta[i][j] = x[n+i-j]*y[n+n-1-i-j];\n\t\tf(i,0,n) f(j,0,n) if ((i+j)&1) {\n\t\t\tll w = 1;\n\t\t\tf(k,0,4) {\n\t\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\t\tif (IN(ni,0,n-1) && IN(nj,0,n-1)) \n\t\t\t\t\tw = lcm(w,a[ni][nj]);\n\t\t\t}\n\t\t\ta[i][j] = w+1;\n\t\t}\n\t\tstringstream ss;\n\t\tf(i,0,n) f(j,0,n) ss << a[i][j] << \" \\n\"[j+1==n];\n\t\tcout << ss.str();\n\n\n\t}\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs int N = 1e3 + 50, M = 2e4;\nint n, a[N], b[N]; bool isp[M];\nll mp[N][N]; int prm[M], pc;\nvoid Sieve(){\n\tfor(int i=2; i<M&&pc<n+n; i++){\n\t\tif(!isp[i]) prm[++pc]=i;\n\t\tfor(int j=1; j<=pc; j++){\n\t\t\tif(prm[j]*i>=M) break;\n\t\t\tisp[prm[j]*i]=true; if(i%prm[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x, ll y){ return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y){\n\tif(!x||!y) return x+y; \n\treturn x / gcd(x,y) * y;\n}\nint main(){\n\tscanf(\"%d\",&n); Sieve();\n\tif(n==2) return cout<<\"4 7\\n23 10\",0;\n\tint l=1, r=pc; \n\tfor(int i=1; i<=n; i++)\n\ta[i]=(i&1)?prm[l++]:prm[r--];\n\tfor(int i=1; i<=n; i++)\n\tb[i]=(i&1)?prm[l++]:prm[r--];\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) if((i+j)&1^1){\n\t\tint x=(i+j)>>1, y=(j+(n-i+1))>>1;\n\t\tmp[i][j]=(ll)a[x]*b[y];\n\t} for(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) if((i+j)&1){\n\t\tll x=lcm(mp[i][j-1],mp[i-1][j]);\n\t\tll y=lcm(mp[i+1][j],mp[i][j+1]); \n\t\tmp[i][j]=lcm(x,y)+1; \n\t} \n\tfor(int i=1; i<=n; i++,puts(\"\"))\n\tfor(int j=1; j<=n; j++) cout<<mp[i][j]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N  = 5100;\nint n,tot; ll a[N][N];\nint vis[N * 20],pri[N];\nvoid init()\n{\n\tvis[1] = 1;\n\tfor(int i = 2;i <= 10000;i ++)\n\t{\n\t\tif(!vis[i]) pri[++ tot] = i;\n\t\tfor(int j = 1;j <= tot && pri[j] * i <= 10000;j ++)\n\t\t{\n\t\t\tvis[i * pri[j]] = 1;\n\t\t\tif(i % pri[j] == 0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){return y ? gcd(y,x % y) : x;}\nll lcm(ll x,ll y){if(!x || !y) return x | y; return x / gcd(x,y) * y;}\nint main()\n{\n\tn = read(); init();\n\tif(n == 2) {puts(\"4 7\\n23 10\"); return 0;}\n\tfor(int i = 1;i <= n;i ++) \n\t\tfor(int j = (i + 1 & 1) + 1;j <= n;j += 2) \n\t\t\ta[i][j] = pri[(i + j) / 2] * pri[n + (i - j) / 2 + (n + 1) / 2];\n\tfor(int i = 1;i <= n;i ++) \n\t\tfor(int j = (i & 1) + 1;j <= n;j += 2) \n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j],a[i][j - 1]),lcm(a[i][j + 1],a[i + 1][j])) + 1; \n\t\n\tfor(int i = 1;i <= n;i ++,cout << \"\\n\") for(int j = 1;j <= n;j ++) cout << a[i][j] << \" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"trapv\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e7, INF = 1e9 * 1e9 + 10, INF2 = 1e9 + 100;\n\nbool simp[SIZE];\nll ans[600][600];\nbool used[600][600];\n\nll gcd(ll a, ll b) {\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main() {\n\tfastInp;\n\n\tll n;\n\tcin >> n;\n\n\tif (n == 2) {\n\t\tcout << \"4 7\\n23 10\";\n\t\treturn 0;\n\t}\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) cnt++;\n\t\t}\n\t}\n\n\tdeque<ll> d;\n\tll c = 0;\n\n\tcnt += 3 * n;\n\tfor (ll i = 2; true; i++) {\n\t\tif (simp[i]) continue;\n\n\t\tc++;\n\t\t\n\t\td.push_back(i);\n\t\tif (c >= cnt) break;\n\t\tfor (ll j = (i * i); j < SIZE; j += i) {\n\t\t\tsimp[j] = 1;\n\t\t}\n\t}\n\n\tll c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<ll> vec1, vec2, al = d;\n\twhile (c1 && c2) {\n\t\tc1--;\n\t\tc2--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c1) {\n\t\tc1--;\n\t\tvec1.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\twhile (c2) {\n\t\tc2--;\n\t\tvec2.push_back(d.back());\n\t\td.pop_back();\n\t}\n\n\n\td = al;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tans[i][j] = d[j - i + n] * d[j + i + 3 * n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 != 0) {\n\t\t\t\tll ml = 1;\n\t\t\t\tif (i > 0) ml = (ml * ans[i - 1][j]) / gcd(ml, ans[i - 1][j]);\n\t\t\t\tif (j > 0) ml = ml * (ans[i][j - 1] / gcd(ml, ans[i][j - 1]));\n\t\t\t\tif (i < n - 1) ml = ml * (ans[i + 1][j] / gcd(ml, ans[i + 1][j]));\n\t\t\t\tif (j < n - 1) ml = ml * (ans[i][j + 1] / gcd(ml, ans[i][j + 1]));\n\n\t\t\t\tif (ml < 0) {\n\t\t\t\t\tcout << \"\";\n\t\t\t\t}\n\t\t\t\tans[i][j] = ml + 1;\n\t\t\t}\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 2010;\n\ntypedef __int128 LL;\n\nint n;\nLL A[N][N];\n\nint vis[N * 20], prm[N];\n\nvoid init(int m) {\n\tint c = 0;\n\tFor(i, 2, m) if (!vis[i]) {\n\t\tif (i != 2) prm[++c] = i;\n\t\tfor (int j = i * 2; j <= m; j += i) vis[j] = true;\n\t}\n}\n\nLL gcd(LL x, LL y) {\n\treturn !y ? x : gcd(y, x % y);\n}\n\nLL lcm(LL x, LL y) {\n\treturn x * y / gcd(x, y);\n}\n\nint main() {\n\n\tscanf(\"%d\", &n);\n\n\tif (n == 2) {\n\t\tputs(\"4 7\\n23 10\");\n\t\treturn 0;\n\t}\n\n\tinit(n * 20);\n\n\tint l = 1, r = n;\n\tfor (int s = 2; s <= n * 2; s += 2) {\n\t\tint cur = s % 4 == 0 ? prm[l++] : prm[r--];\n\t\tFor(i, 1, n) if (s - i >= 1 && s - i <= n)\n\t\t\tA[i][s - i] = cur;\n\t}\n\tl = n + 1, r = 2 * n;\n\tfor (int s = n % 2 ? 2 : 3; s <= n * 2; s += 2) {\n\t\tint cur = s % 4 < 2 ? prm[l++] : prm[r--];\n\t\tFor(i, 1, n) {\n\t\t\tint j = n + 1 + i - s;\n\t\t\tif (j >= 1 && j <= n) A[i][j] *= cur;\n\t\t}\n\t}\n\n\tFor(i, 1, n) For(j, 1, n) if ((i + j) % 2) {\n\t\tLL S = 1;\n\t\tif (i > 1) S = lcm(S, A[i - 1][j]);\n\t\tif (j > 1) S = lcm(S, A[i][j - 1]);\n\t\tif (i < n) S = lcm(S, A[i + 1][j]);\n\t\tif (j < n) S = lcm(S, A[i][j + 1]);\n\t\t++S;\n\t\tA[i][j] = S;\n\t}\n\n\tFor(i, 1, n) For(j, 1, n) printf(\"%lld%c\", (long long)A[i][j], j == n ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long long ll;\n#define X first\n#define Y second\n#define all(o) o.begin(), o.end()\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\nconst int maxn = 2e5 + 10;\nll a[maxn][maxn];\nint dx[] = {-1, +1, 0, 0};\nint dy[] = {0, 0, +1, -1};\nint n;\nset<ll> st;\nbool isin(int x,int y){\n\treturn (x >= 0 && x < n && y >= 0 && y < n);\n}\nvoid doo(int x,int y){\n\tif(a[x][y]) return;\n\tset<ll> s;\n\tfor(int i=0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(isin(nx, ny) && a[nx][ny] != 0)\n\t\t\ts.insert(a[nx][ny]);\n\t}\n\tint ans = 1;\n\tfor(auto x : s)\n\t\tans *= x;\n\tint cur = ans + 1;\n\twhile(1){\n\t\tif(st.find(cur) == st.end()){\n\t\t\ta[x][y] = cur;\n\t\t\tst.insert(cur);\n\t\t\tbreak;\n\t\t}\n\t\tcur += ans;\n\n\t}\n}\nint32_t main(){\n\tIOS;\n\t\n\t//int n;\n\tcin >> n;\n\tint cur = 2;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(i % 2 == j % 2){\n\t\t\t\ta[i][j] = cur;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<n; j++)\n\t\t\tdoo(i, j);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++)\n\t\t\tcout << a[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 510\nll a[N][N];\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    return b?gcd(a%b,b):a;\n}\nll gce(ll a,ll b){return a/gcd(a,b)*b;}\nint main(){\n    vector<ll> p;\n    for(ll i=2;p.size()<N*2;i++){\n\tbool ok=1;for(auto x:p)ok&=i%x>0;\n\tif(ok)p.push_back(i);\n    }\n    lol(i,N)lol(j,N){\n\tif((i+j)%2==0)a[i][j]=p[i]*p[j+N];\n    }\n    ll n;cin>>n;\n    lol(i,n){\n\tlol(j,n){if(j)cout<<\" \";\n\t    if((i+j)%2==1){\n\t\tll p=1,dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\t\tlol(r,4){\n\t\t    ll xx=j+dx[r],yy=i+dy[r];\n\t\t    if(xx<0||xx==n||yy<0||yy==n)continue;\n\t\t    p=gce(p,a[yy][xx]);\n\t\t}\n\t\ta[i][j]=p+1;\n\t    }\n\t    cout<<a[i][j];\n\t}\n\tcout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef unsigned long long ll;\nusing namespace std;\nconst int MN=80000;\nint n,pri[2001],cnt,vis[MN+5],id[501][501][2];\nll a[501][501];\ninline bool border(int i){return (i==1||i==n);}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(reg int i=2;i<=MN;i++){\n\t\tif(!vis[i])pri[++cnt]=i;\n\t\tif(cnt==1000)break;\n\t\tfor(reg int j=1;j<=cnt&&pri[j]*i<=MN;j++){\n\t\t\tvis[pri[j]*i]=1;\n\t\t\tif(!(i%pri[j]))break;\n\t\t}\n\t}\n\tif(n==2)return 0*puts(\"4 7\\n23 10\");\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\tid[i][j][0]=(i+j)>>1;\n\t\t\t\tid[i][j][1]=n+((i-j+n)>>1)+1;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif((~(i+j))&1){\n\t\t\t\ta[i][j]=1ll*pri[id[i][j][0]]*pri[id[i][j][1]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(border(i)&&border(j))\n\t\t\t\t\tif(i==1)a[i][j]=1ll*pri[id[2][n][0]]*pri[id[1][n-1][0]]*pri[id[1][n-1][1]];\n\t\t\t\t\telse a[i][j]=1ll*pri[id[n][2][0]]*pri[id[n-1][1][0]]*pri[id[n-1][1][1]];\n\t\t\t\telse if(border(i))\n\t\t\t\t\ta[i][j]=1ll*pri[id[i][j-1][0]]*pri[id[i][j+1][0]]*pri[id[i][j-1][1]]*pri[id[i][j+1][1]];\n\t\t\t\telse a[i][j]=1ll*pri[id[i-1][j][0]]*pri[id[i+1][j][0]]*pri[id[i-1][j][1]]*pri[id[i+1][j][1]];\n\t\t\t\ta[i][j]++;\n\t\t\t}\n\tfor(reg int i=1;i<=n;i++,puts(\"\"))\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tprintf(\"%llu \",a[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int K = 1e6;\nbool pr[K];\nset<int> m[K];\nsigned main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    for (int i=2; i < K; i++){\n        if (!pr[i]){\n            m[i].insert(i);\n            for (int j=i+i; j < K; j+=i){\n                pr[j] = true;\n                m[j].insert(i);\n            }\n        }\n    }\n    int n;\n    cin >> n;\n    int a[n][n];\n    for (int i=0; i < n; i++) for (int j=0; j < n; j++) a[i][j] = 0;\n    int u = 2;\n    set<int> hh;\n    for (int i=0; i < n; i+=2){\n        for (int j=0; j < n; j++){\n            if ((i+j)%2!=0) continue;\n            while (u%2==0)u++;\n            a[i][j] = u;\n            if (i+1 < n && j+1 < n) a[i+1][j+1] = 2*u;\n            u++;\n        }\n    }\n    set<int> used;\n    for (int i=0; i < n; i++){\n        for (int j=0; j < n; j++){\n            if (a[i][j] != 0) continue;\n            vector<int> b;\n            if (i-1 >= 0) b.push_back(a[i-1][j]);\n            if (j+1 < n) b.push_back(a[i][j+1]);\n            if (i+1 < n) b.push_back(a[i+1][j]);\n            if (j-1>=0) b.push_back(a[i][j-1]);\n            set<int> gl;\n            for (int p=0; p < b.size(); p++) {\n                for (set<int>::iterator it = m[b[p]].begin(); it != m[b[p]].end(); it++){\n                    //cout << (*it) << endl;\n                    gl.insert(*it);\n                }\n            }\n            //cout << endl;\n            int R = 1;\n            for (set<int>::iterator it = gl.begin(); it != gl.end(); it++){\n                int num = *it;\n                int kf = 0;\n                for (int p=0; p < b.size(); p++){\n                    int s = 0;\n                    while (b[p] % num == 0){\n                        b[p] /= num;\n                        s++;\n                    }\n                    kf = max(kf, s);\n                }\n                for (int e=0;e<kf;e++) R *= num;\n            }\n            int rr = R+1;\n            while (used.count(rr)) rr += R;\n            R = rr;\n            if (R > 1e15){\n                cout << R << endl;\n                return 0;\n            }\n            a[i][j] = R;\n            used.insert(R);\n        }\n    }\n    for (int i=0;i<n;i++){\n        for (int j=0;j<n;j++) cout << a[i][j] << \" \";\n        cout << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 500, dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};\nint n, m, mn;\nll s[maxn * maxn + 10], a[maxn + 10][maxn + 10];\n\nbool ispr(int x) {\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) return 0;\n\treturn 1;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tif (n == 2) {\n\t\tprintf(\"%d %d\\n%d %d\\n\", 4, 7, 23, 10);\n\t\treturn 0;\n\t}\n\tfor (int i = 1, p = 1; i <= n * 2; ++i) {\n\t\tfor (++p; !ispr(p); ++p);\n\t\ts[i] = p;\n\t}\n\tmn = (1 - n) & 1 ? (2 - n) / 2 : (1 - n) / 2;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\tint x = (i + j) / 2, y = (i - j) / 2 - mn + 1;\n\t\t\t\ta[i][j] = s[x] * s[y + n];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif ((i + j) % 2) {\n\t\t\t\tll g = 1;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint dx = i + dir[k][0], dy = j + dir[k][1];\n\t\t\t\t\tif (dx >= 1 && dx <= n && dy >= 1 && dy <= n)\n\t\t\t\t\t\tg = g / __gcd(g, a[dx][dy]) * a[dx][dy];\n\t\t\t\t}\n\t\t\t\ta[i][j] = g + 1;\n\t\t\t}\n\t\t\tprintf(\"%lld%c\", a[i][j],  \" \\n\"[j == n]);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned long;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    vector<ULL> P;\n\n    void Primes() {\n        bool Table[10000] = {};\n        Table[0] = Table[1] = true;\n        for (UL i = 2; i <= 100; i++) {\n            if (Table[i]) continue;\n            for (UL j = i * i; j < 10000; j += i) Table[j] = true;\n        }\n        Table[2] = true;\n        for (UL i = 1; P.size() < 1000; i++) if (!Table[i]) P.push_back(i);\n    }\n\n    ULL ans[502][502];\n\n    void Solve() {\n        Primes();\n        rep(i, 502) rep(j, 502) ans[i][j] = 1;\n        rep(i, 500) rep(j, 500) {\n            if ((i ^ j) & 1) continue;\n            ULL tmp = P[(i + j) >> 1] * P[((i + 499 - j) >> 1) + 500];\n            ans[i + 1][j + 1] = tmp;\n        }\n        rep(i, 500) rep(j, 500) if ((i ^ j) & 1) {\n            ans[i + 1][j + 1] = ans[i + 1][j] * ans[i + 1][j + 2];\n            if (j == 0 || j == 499) {\n                ans[i + 1][j + 1] = ans[i][j + 1] * ans[i + 2][j + 1];\n                if (i == 0 || i == 499) ans[i + 1][j + 1] *= ans[i + 1][j] * ans[i + 1][j + 2];\n            }\n            ans[i + 1][j + 1]++;\n        }\n\n        UL N; cin >> N;\n        rep(i, N) {\n            rep(j, N) {\n                if (j) cout << \" \";\n                cout << ans[i + 1][j + 1];\n            } cout << endl;\n        }\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 203050\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],n,b[505][505],mx,c,o,r;\nint p[maxn];\nvector<ll> h[maxn];\nbool vis[maxn];\nll lcm(ll x,ll y){\n    return x/__gcd(x,y)*y;\n}\nmap<ll,int> f;\n\nint main(){\n    cin >> n;\n    //for (int i=0;i<n*n/2;i++) a[c++]=i+1;\n    //for (int i=0;i<c;i++)cout<<a[i]<<' ';cout<<endl;\n    //random_shuffle(a,a+c);\n    o=3;\n    for (int i=1;i<=n;i+=4)\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n            o+=2;\n        }\n    int pos=3; while (pos+4<=n) pos+=4;\n    for (int i=pos;i>0;i-=4){\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o; o+=2;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n        }\n    }\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) f[b[i][j]]=1;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) if ((i+j)%2==1){\n            r=1;\n            if (i>1) r=lcm(r,b[i-1][j]);\n            if (i<n) r=lcm(r,b[i+1][j]);\n            if (j>1) r=lcm(r,b[i][j-1]);\n            if (j<n) r=lcm(r,b[i][j+1]);\n            long long s=1;\n            while (f[r*s+1]) s++;\n            b[i][j]=r*s+1; f[b[i][j]]=1;\n        }\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<n;j++){\n        ll x,y;\n        x=max(b[i][j],b[i][j+1]);\n        y=min(b[i][j],b[i][j+1]);\n        assert(x%y==1);\n    }\n    for (int i=1;i<n;i++)\n    for (int j=1;j<=n;j++){\n        ll x,y;\n        x=max(b[i][j],b[i+1][j]);\n        y=min(b[i][j],b[i+1][j]);\n        assert(x%y==1);\n    }\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) mx=max(mx,b[i][j]);\n    //cout<<mx<<endl;\n    assert(mx<=1000000000000000ll);\n\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)cout<<b[i][j]<<' ';cout<<endl;\n    }\n    //cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 101000;\nint g[N],pri[N],tot;\nll f[1010][1010],p1[1010],p2[1010];\nvoid init(){\n\tfor(int i=2;i<=10000;i++){\n\t\tif(!g[i]){pri[++tot]=i;g[i]=i;}\n\t\tfor(int j=1;pri[j]*i<=10000;j++){\n\t\t\tg[pri[j]*i]=pri[j];\n\t\t\tif(pri[j]==g[i]) break; \n\t\t}\n\t}\n\tint k1=0,k2=0;\n\tfor(int i=1;i<=1100;i++)\n\t\tif(i&1) p1[++k1]=pri[i];\n\t\telse p2[++k2]=pri[i];\n\tsrand(3284792);\n\trandom_shuffle(p1+1,p1+k1+1);\n\trandom_shuffle(p2+1,p2+k2+1);\n}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){\n\tif(a==0) return b;\n\tif(b==0) return a;\n\treturn a/gcd(a,b)*b;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i+j&1){\n\t\t\t\tint k=i+j>>1;\n\t\t\t\tf[i][j]=p1[k];\n\t\t\t\tk=i+(n-j+1)>>1;\n\t\t\t\tf[i][j]*=p2[k];\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(~(i+j)&1){\n\t\t\t\tf[i][j]=lcm(f[i][j-1],lcm(f[i][j+1],lcm(f[i-1][j],f[i+1][j])))+1;\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcout<<f[i][j]<<\" \\n\"[j==n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n \nconst int N=505;\nconst int LIM=8000;\nint fl[LIM],pri[LIM],n;\nvoid initprime(){\n\tFor(i,2,LIM-1) For(j,2,(LIM-1)/i) fl[i*j]=1;\n\tFor(i,1,LIM-1) if (!fl[i]) pri[++*pri]=i;\n}\nmap<int,int> mp1,mp2;\nmap<ll,int> mp3;\nll ans[N][N];\nll gcd(ll x,ll y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid work(){\n\tint l=4;\n\tFor(i,1,n) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp1[i+j]) mp1[i+j]=pri[l++];\n\t\tans[i][j]=mp1[i+j];\n\t}\n\tRep(i,n,1) For(j,1,n) if ((i+j)&1){\n\t\tif (!mp2[i-j]) mp2[i-j]=pri[l++];\n\t\tans[i][j]*=mp2[i-j];\n\t}\n\n\tll mx=0;\n\tFor(i,1,n) For(j,1,n) if (!ans[i][j]){\n\t\tll lcm=1;\n\t\tif (i!=1) lcm*=ans[i-1][j]/gcd(ans[i-1][j],lcm);\n\t\tif (i!=n) lcm*=ans[i+1][j]/gcd(ans[i+1][j],lcm);\n\t\tif (j!=1) lcm*=ans[i][j-1]/gcd(ans[i][j-1],lcm);\n\t\tif (j!=n) lcm*=ans[i][j+1]/gcd(ans[i][j+1],lcm);\n\t\tans[i][j]=lcm+1;\n\t}\n\tFor(i,1,n){\n\t\tFor(j,1,n) \n\t\t  {//if(mp3[ans[i][j]]) {cout<<\"fuck\"<<endl;exit(0);}  else mp3[ans[i][j]]=1; \n\t\t   printf(\"%lld \",ans[i][j]);\n\t      } \n\t\tputs(\"\");\n\t}\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tinitprime();\n\twork();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint ch[100000];\ndeque<int> pr;\nllong P1[500];\nllong P2[500];\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tfor (int i = 2; i < 100000; ++i) {\n        if (ch[i]) continue;\n        pr.push_back(i);\n        for (llong j = (llong)i * i; j < 100000; j += i) ch[j] = 1;\n\t}\n        \n\tint n;\n\tcin >> n;\n\tif (n == 2) {\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n\t}\n\tfor (int i = 0; i <= ((n + n - 2) >> 1); ++i) {\n        P1[i] = pr.front();\n        pr.pop_front();\n\t}\n\tfor (int i = 0; i <= ((n + n - 2) >> 1); ++i) {\n        P2[i] = pr.front();\n        pr.pop_front();\n\t}\n\tfor (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) & 1) {\n                int x = (i + j), y = (i - j + (n - 1));\n                llong ret = 1;\n                if (x > 0) ret *= P1[x - 1 >> 1];\n                if (x + 1 <= n + n - 2) ret *= P1[x + 1 >> 1];\n                if (y > 0) ret *= P2[y - 1 >> 1];\n                if (y + 1 <= n + n - 2) ret *= P2[y + 1 >> 1];\n                printf(\"%lld\", ret + 1);\n                //if (ret > 1e15) { printf(\"%lld\\n\", ret); }\n            }\n            else {\n                printf(\"%lld\", P1[i + j >> 1] * P2[i - j + (n - 1) >> 1]);\n            }\n            if (j + 1 < n) printf(\" \");\n            else printf(\"\\n\");\n        }\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <regex>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing dbl = double;\nusing pii = pair<int,int>;\nusing pl4 = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing vvs = vector<vs>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpl4 = vector<pl4>;\nusing vvpl4 = vector<vpl4>;\nusing vd = vector<dbl>;\nusing vvd = vector<vd>;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define sz size()\n#define be begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define ft front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define rFOR(i,a,b) for(int i=(b);i>=(a);i--)\n#define SORT(a) sort((a).be,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).be,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).be,(a).en)\n#define NEXTP(a) next_permutation((a).be,(a).en)\n#define BINS(a,b) binary_search((a).be,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).be,(a).en,(b))-(a).be)\n#define UPB(a,b) (upper_bound((a).be,(a).en,(b))-(a).be)\n#define CNT(a,b) count((a).be,(a).en,b)\n#define SUM(a) accumulate((a).be,(a).en,0)\n#define REV(a) reverse((a).be,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define say(a) cout <<(a);\n#define sal(a) cout <<(a)<<endl;\n#define sak cout <<endl;\n#define dbg(a) cout <<(#a)<<\": \"<<(a)<<endl;\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) (1<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define llin(a) ll (a);cin >>(a);\n#define stin(a) string (a);cin >>(a);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define min(a,b) ((a<b)?(a):(b))\n#define max(a,b) ((a>b)?(a):(b))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n\n#define int ll\n\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\npl4 Bezout(ll a,ll b){\n    if(b!=0){\n        pl4 xy;\n        xy=Bezout(b,a%b);\n        return mp(xy.se,xy.fi-((a/b)*xy.se));\n    }\n    if(b==0){\n        return mp(1,0);\n    }\n}\npl4 Bez(ll a,ll b,ll c){\n    pl4 xy;\n    ll x,y,z,gc;\n    xy=Bezout(a,b);\n    gc=gcd(a,b);\n    if(c%gc!=0) return mp(-1,-1);\n    x=xy.fi*(c/gc);y=xy.se*(c/gc);\n    if(x<0) z=rup(-x,(b/gc));\n    if(x>=0) z=-x/(b/gc);\n    x+=z*(b/gc);\n    y-=z*(a/gc);\n    return mp(x,y);\n}\n\nvoid salv(vll v){\n    say(\"{\");\n    FOR(i,0,v.sz-1){\n        say(v[i]);\n        if(i!=v.sz-1) say(\",\");\n    }\n    sal(\"}\")\n}\n\nll DigS10(ll n){\n    ll m=0;\n    FOR(i,0,DigN10(n)-1){\n        m+=(ll)((llabs(n)%(ll)(pow(10.0,(double)(i+1))))/(ll)(pow(10.0,(double)i)));\n    }\n    return m;\n}\n\nll isP(ll n){\n    if(n<=1) return 0;\n    FOR(i,2,(ll)sqrt(n)){\n        if(n%i==0) return 0;\n    }\n    return 1;\n}\n\nvll FactM(1,1);\nvll FactMI(1,1);\n\nll PowM(ll a,ll b){\n    ll ans=1,x=(a%MOD);\n    FOR(i,0,DigN2(b)-1){\n        if(Dig2(b,i)==1) ans=(ans*x)%MOD;\n        if(i!=(DigN2(b)-1)) x=(x*x)%MOD;\n    }\n    return ans;\n}\n\nvoid CFactM(ll n){\n    if(FactM.sz<=n){\n        FOR(i,FactM.sz,n){\n            FactM.pb((FactM[i-1]*(i%MOD))%MOD);\n        }\n    }\n    return;\n}\n\nvoid CFactMI(ll n){\n    CFactM(n);\n    if(FactMI.sz<(n+1)) FactMI.res(n+1,-1);\n    if(FactMI[n]==-1) FactMI[n]=PowM(FactM[n],MOD-2);\n    rFOR(i,1,n-1){\n        if(FactMI[i]!=-1) break;\n        FactMI[i]=((FactMI[i+1]*((i+1)%MOD))%MOD);\n    }\n    return;\n}\n\nll CombM(ll n,ll k){\n    if((n<0)||(k<0)) return 0;\n    if(n<k) return 0;\n    if(n+1>FactMI.sz) CFactMI(n);\n    return ((((FactMI[k]*FactMI[n-k])%MOD)*FactM[n])%MOD);\n}\n\nsigned main() {\n\n    llin(N);\n    vvll a(N+2,vll(N+2,1));//1~N\n    vll prime={2,3};\n    ll nown=5;\n    ll ip=1;\n    if(N>=3){\n        FOR(aa,1,(N*N)/2){\n            while(1){\n                ip=1;\n                FOR(pn,0,prime.sz-1){\n                    if(nown<prime[pn]*prime[pn]){\n                        break;\n                    }\n                    if(nown%prime[pn]==0){\n                        ip=0;\n                        break;\n                    }\n                }\n                nown++;\n                if(ip==1){\n                    prime.pb(nown-1);\n                    break;\n                }\n            }\n        }\n        ll uf=2;\n        ll us=prime.sz-1;\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==1){\n                    if(i%2==0){\n                        a[i][j]=prime[uf];\n                        uf++;\n                    }\n                    if(i%2==1){\n                        a[i][j]=prime[us];\n                        us--;\n                    }\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                if((i+j)%2==0){\n                    a[i][j]=a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]+1;\n                }\n            }\n        }\n        FOR(i,1,N){\n            FOR(j,1,N){\n                say(a[i][j]);\n                say(\" \");\n            }\n            sak;\n        }\n    }\n    if(N==2){\n        sal(\"4 7\");\n        sal(\"23 10\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(it,st,en) for(int it=(st);it<(int)(en);++it)\n#define all(c) (c).begin(), (c).end()\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define eb emplace_back\n#define X first\n#define Y second\ntypedef long long int ll; \ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MAX_PR = 5000000;\nbitset<MAX_PR> isprime;\nvi eratosthenes_sieve(int lim) {\n  isprime.set(); isprime[0] = isprime[1] = 0;\n  for (int i = 4; i < lim; i += 2) isprime[i] = 0;\n  for (int i = 3; i*i < lim; i += 2) if (isprime[i])\n    for (int j = i*i; j < lim; j += i*2) isprime[j] = 0;\n  vi pr;\n  rep(i,2,lim) if (isprime[i]) pr.push_back(i);\n  return pr;\n}\n\nll primes[] = {\n  2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,\n  97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n = 500;\n    vector<vector<ll> > v(n, vector<ll>(n));\n    vi p = eratosthenes_sieve(500000);\n    debug(p.size());\n    set<ll> forbidden;\n    rep(i,0,n) {\n      ll x = p[i/2];\n      rep(j,0,n) if((i+j)&1) {\n        ll y = p[205+j/2];\n        v[i][j] = x*y;\n        while(forbidden.count(v[i][j])) v[i][j] += x*y;\n        forbidden.insert(v[i][j]);\n      }\n    }\n    rep(i,0,n) rep(j,0,n/2) {\n      int x = i, y = 2*j + (i&1);\n      ll p = 1;\n      auto f = [&](ll a) { return p/__gcd(a,p)*a; };\n      if(x != 0)   p = f(v[x-1][y]);\n      if(x != n-1) p = f(v[x+1][y]);\n      if(y != 0)   p = f(v[x][y-1]);\n      if(y != n-1) p = f(v[x][y+1]);\n      v[x][y] = p+1;\n      while(forbidden.count(v[x][y])) v[x][y] += p;\n      forbidden.insert(v[x][y]);\n    }\n    debug(forbidden.size());\n    assert(*(--forbidden.end()) < 1e15);\n    assert(*forbidden.begin() > 0);\n\n    cin >> n;\n    rep(i,0,n) rep(j,0,n) {\n      cout << v[i][j] << \" \\n\"[j == n-1];\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 510;\ntypedef long long LL;\nint pri[MAXN], bak, n;\nint ispri(int x) {\n\tfor (int i = 2; i * i <= x; ++i)\n\t\tif (x % i == 0) return false;\n\treturn true;\n}\nLL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }\nLL lcm(LL a, LL b) { return a / gcd(a, b) * b; }\nLL get(int x, int y) {\n\tif (x < 1 || y < 1 || x > n || y > n) return 1;\n\tif ((x & 1) == (y & 1))\n\t\treturn pri[x + y >> 1] * pri[x + n * 3 - y + 1 >> 1];\n\treturn lcm(lcm(get(x - 1, y), get(x, y - 1)), lcm(get(x + 1, y), get(x, y + 1))) + 1;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n; n += 2;\n\tint now = 2;\n\twhile (bak < n * 2) {\n\t\tif (ispri(now)) pri[++bak] = now;\n\t\t++now;\n\t}\n\tfor (int i = 2; i < n; ++i, std::cout << '\\n')\n\t\tfor (int j = 2; j < n; ++j)\n\t\t\tstd::cout << get(i, j) << ' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 1e3 + 10;\n\nint N;\n\nll A[MAX_N][MAX_N];\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\nbool is_prime(int x) {\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint get_prime() {\n    static int x = 2;\n    while (!is_prime(x)) x++;\n    int res = x; x++;\n    return res;\n}\n\nvoid paint(int x, int y, int dx, int dy, ll v) {\n    while (x >= 1 && x <= N && y >= 1 && y <= N) {\n        A[x][y] *= v;\n        x += dx; y += dy;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    if (N == 2) {\n        printf(\"4 7\\n23 10\\n\");\n        return 0;\n    }\n    for (int i = 1; i <= N; i++)\n        for (int j = 1; j <= N; j++)\n            A[i][j] = 1;\n    for (int i = 1; i <= N; i++) {\n        if (!(i + 1 & 1)) {\n            paint(1, i, 1, 1, get_prime());\n        }\n    }\n    for (int i = 2; i <= N; i++) {\n        if (!(i + 1 & 1)) {\n            paint(i, 1, 1, 1, get_prime());\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!(i + 1 & 1)) {\n            paint(1, i, 1, -1, get_prime());\n        }\n    }\n    for (int i = 2; i <= N; i++) {\n        if (!(i + N & 1)) {\n            paint(i, N, 1, -1, get_prime());\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (i + j & 1) {\n                for (int dx = -1; dx <= 1; dx++) {\n                    for (int dy = -1; dy <= 1; dy++) {\n                        if (abs(dx) + abs(dy) == 1) {\n                            int x = i + dx, y = j + dy;\n                            if (x >= 1 && x <= N && y >= 1 && y <= N) {\n                                A[i][j] = lcm(A[i][j], A[x][y]);\n                            }\n                        }\n                    }\n                }\n                A[i][j]++;\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++)\n            printf(\"%lld \", A[i][j]);\n        printf(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\n\nbool updownup(map<int, int>upmp, map<int, int>downmp) {\n\tint mink = upmp.begin()->first;\n\tint maxk = prev(downmp.end())->first;\n\t\n\n\treturn true;\n\n\n}\n\nint main() {\n\tlong long int A=317;\n\tlong long int B=323;\n\tvector<vector<long long int>>v(501,vector<long long int>(501));\n\tv[0][0]=1010;\n\tfor (int y = 0; y < 500; ++y) {\n\t\tfor (int x = 0; x < 500; ++x) {\n\t\t\tif (y % 3 != 2) {\n\n\t\t\t\tv[y + 1][x] = v[y][x] * A + A*B;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[y+1][x]=(v[y][x]-A*B)/(A*A);\n\t\t\t}\n\n\t\t\tif (x % 3 != 2) {\n\n\t\t\t\tv[y][x+1] = v[y][x] * B + A*B;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[y][x+1] = (v[y][x] - A*B) / (B*B);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tset<long long int>aset;\n\tfor (int y = 0; y < 500; ++y) {\n\t\tfor (int x = 0; x < 500; ++x) {\n\t\t\taset.emplace(v[y][x]);\n\t\t}\n\t}\n\t//cout<<v[497][497]<<endl;\n\tint N;cin>>N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout<<v[i][j];\n\t\t\tif(j==N-1)cout<<endl;\n\t\t\telse cout<<\" \";\n\t\t}\n\t}\n\n\t//cout<<aset.size()<<endl;\n\t//int N;cin>>N;\n\t//vector<pair<int,int>>vs;\n\t//map<int,int>upmp,downmp;\n\t//for (int i = 0; i < N; ++i) {\n\t//\tint a,b;cin>>a>>b;\n\t//\tif (b == 1) {\n\t//\t\tupmp[a]++;\n\t//\t}\n\t//\telse {\n\t//\t\tdownmp[a]++;\n\t//\t}\n\t//}\n\n\t//int mink=upmp.begin()->first;\n\t//int maxk=prev(downmp.end())->first;\n\n\t////up down up\n\n\t//{\n\t//\t\n\t//}\n\t//\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nllint n;\nbool prime[5000005];\nvector<llint> pvec, rvec, vec;\nllint ans[505][505];\n\nllint gcd(llint a, llint b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\nllint lcm(llint a, llint b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nint main(void)\n{\n\tcin >> n;\n\t\n\tfor(int i = 2; i < 5000005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 5000005; j+=i) prime[j] = true;\n\t}\n\tfor(int i = 2; i < 5000005; i++) if(!prime[i]) pvec.push_back(i);\n\t\n\tpvec.resize(1000);\n\trvec = pvec;\n\treverse(rvec.begin(), rvec.end());\n\t\n\tfor(int i = 0; i < 500; i++){\n\t\tvec.push_back(pvec[i]);\n\t\tvec.push_back(rvec[i]);\n\t}\n\t\n\tfor(int i = 0; i < 500; i++){\n\t\tfor(int j = 0; j < 500; j++){\n\t\t\tans[i][j] = 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < 500; i++){\n\t\tfor(int j = 0; j < 500; j++){\n\t\t\tif((i+j)%2) continue;\n\t\t\tans[i][j] *= vec[(i+j)/2];\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i++){\n\t\tfor(int j = 0; j < 500; j++){\n\t\t\tif((i-j+500)%2) continue;\n\t\t\tans[i][j] *= vec[(i-j+500)/2 + 500];\n\t\t}\n\t}\n\tfor(int i = 0; i < 500; i++){\n\t\tfor(int j = 0; j < 500; j++){\n\t\t\tif(ans[i][j] != 1) continue;\n\t\t\tif(i-1 >= 0) ans[i][j] = lcm(ans[i][j], ans[i-1][j]);\n\t\t\tif(i+1 < 500) ans[i][j] = lcm(ans[i][j], ans[i+1][j]);\n\t\t\tif(j-1 >= 0) ans[i][j] = lcm(ans[i][j], ans[i][j-1]);\n\t\t\tif(j+1 < 500) ans[i][j] = lcm(ans[i][j], ans[i][j+1]);\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcout << ans[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 513\n#define MAXP 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint sp[MAXP];\nvector<ll> primes;\nll ans[MAXN][MAXN];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nll gcd(ll a, ll b)\n{\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\nll lcm(ll a, ll b)\n{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool valid(int x, int y)\n{\n\treturn (0 <= x && x < N && 0 <= y && y < N);\n}\nll mind(ll x)\n{\n\t//-N-1...N-1\n\tx += (N - 1);\n\treturn primes[x];\n}\nll plud(ll x)\n{\n\t//0...2N-2\n\treturn primes[x];\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tif (N == 2)\n\t{\n\t\tcout << \"4 7\\n23 10\\n\";\n\t\treturn 0;\n\t}\n\tN += 2;\n\tfor (int i = 2; i < MAXP; i++)\n\t{\n\t\tif (sp[i] == 0)\n\t\t{\n\t\t\tsp[i] = i;\n\t\t\tprimes.PB(i);\n\t\t}\n\t\tfor (ll p : primes)\n\t\t{\n\t\t\tif (p > sp[i] || i * p > MAXP)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp[i * p] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2 == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i][j] = mind(i - j) * plud(i + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif ((i + j) % 2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\tif (valid(i + dx[k], j + dy[k]))\n\t\t\t\t{\n\t\t\t\t\tans[i][j] = lcm(ans[i][j], ans[i + dx[k]][j + dy[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[i][j]++;\n\t\t}\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\t\tfor (int j = 1; j < N - 1; j++)\n\t\t{\n\t\t\tif (j != 1) cout << ' ';\n\t\t\tcout << ans[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 505;\nll a[maxN][maxN];\nvector < int > primes;\nint n;\nbool used[maxN * maxN * 10];\nll gcd(ll a, ll b) {\n    while (a > 0 && b > 0) {\n        if (a < b) swap(a, b);\n        a %= b;\n    }\n    return a + b;\n}\nll lcm(ll a, ll b) {\n    return (a * (b / gcd(a, b)));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int max_n = 500;\n    for (int i = 2; ; i++) {\n        if (used[i]) continue;\n        primes.push_back(i);\n        if (primes.size() > 2 * max_n + 10) {\n            break;\n        }\n        for (int j = i; j < maxN * maxN * 10; j += i) used[j] = true;\n    }\n    set < ll > all;\n    for (int i = 1; i <= max_n; i++) {\n        for (int j = 1; j <= max_n; j++) {\n            if (((i + j) % 2) == 0) {\n                a[i][j] = 1LL * primes[(i + j) / 2] * primes[(i - j) / 2 + max_n + 2 + (max_n / 2)];\n                all.insert(a[i][j]);\n            }\n        }\n    }\n    ll mx = 1;\n    for (int i = 1; i <= max_n; i++) {\n        for (int j = 1; j <= max_n; j++) {\n            if (((i + j) % 2) == 0) continue;\n            a[i][j] = 1;\n            if (i > 1) a[i][j] = lcm(a[i][j], a[i - 1][j]);\n            if (i < max_n) a[i][j] = lcm(a[i + 1][j], a[i][j]);\n            if (j < max_n) a[i][j] = lcm(a[i][j], a[i][j + 1]);\n            if (j > 1) a[i][j] = lcm(a[i][j], a[i][j - 1]);\n            a[i][j]++;\n            mx = max(mx, a[i][j]);\n            all.insert(a[i][j]);\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[1001][1001], prm[2003];\nint vis[100005], cnt;\nvoid euler() {\n    vis[1] = 1;\n    for (int i = 2; i <= 10000; ++i) {\n        if (!vis[i]) prm[++cnt] = i;\n        for (int j = 1; j <= cnt && i * prm[j] <= 10000; ++j) {\n            vis[i * prm[j]] = 1;\n            if (!(i % prm[j])) break;\n        }\n    }\n}\n\nlong long gcd(long long x, long long y) {\n    while (y ^= x ^= y ^= x %= y) void();\n    return x;\n}\n\nlong long lcm(long long x, long long y) {\n    if (!x || !y) return x + y;\n    return x / gcd(x, y) * y;\n}\n\nint main() {\n    scanf(\"%d\", &n), euler();\n    if (n == 2) return puts(\"4 7\\n23 10\\n\"), 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i + 1 & 1) + 1; j <= n; j += 2)\n            a[i][j] = prm[(i + j) / 2] * prm[n + (i - j) / 2 + (n + 1) / 2];\n    for (int i = 1; i <= n; ++i)\n        for (int j = (i & 1) + 1; j <= n; j += 2)\n            a[i][j] = lcm(lcm(a[i - 1][j], a[i][j - 1]),\n                          lcm(a[i][j + 1], a[i + 1][j])) +\n                      1;\n    for (int i = 1; i <= n; ++i, puts(\"\"))\n        for (int j = 1; j <= n; ++j) printf(\"%lld \", a[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL K = 750;\nconst LL MP = 20000;\n\nLL pri[20005],pc = 0;\nLL npr[20005] = {0};\nLL w[505][505];\n\nvoid sieve(LL x){\n\tfor(LL i = 2;i <= x;i ++){\n\t\tif(npr[i]) continue;\n\t\tpri[++ pc] = i;\n\t\tfor(LL j = i * i;j <= x;j += i){\n\t\t\tnpr[j] = 1;\n\t\t}\n\t} \n}\n\nLL gcd(LL x,LL y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nLL lcm(LL x,LL y){\n\treturn x / gcd(x,y) * y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tLL n,m; cin >> n; m = n;\n\tsieve(MP);\n\tfor(LL i = 0;i <= n + 1;i ++){\n\t\tfor(LL j = 0;j <= m + 1;j ++){\n\t\t\tw[i][j] = 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= m;j ++){\n\t\t\tif((i + j) & 1) w[i][j] = pri[(i + j) >> 1] * pri[((i - j) >> 1) + K];\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= m;j ++){\n\t\t\tif(w[i][j] == 1) w[i][j] = lcm(lcm(w[i - 1][j],w[i][j - 1]),lcm(w[i + 1][j],w[i][j + 1])) + 1;\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= m;j ++){\n\t\t\tcout << w[i][j] << (j == m ? '\\n' : ' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 203050\n\nusing namespace std;\ntypedef long long ll;\nll a[maxn],n,b[505][505],mx,c,o,r;\nint p[maxn];\nvector<ll> h[maxn];\nbool vis[maxn];\nll lcm(ll x,ll y){\n    return x/__gcd(x,y)*y;\n}\nmap<ll,int> f;\n\nint main(){\n    cin >> n;\n    //for (int i=0;i<n*n/2;i++) a[c++]=i+1;\n    //for (int i=0;i<c;i++)cout<<a[i]<<' ';cout<<endl;\n    //random_shuffle(a,a+c);\n    o=3;\n    for (int i=1;i<=n;i+=4)\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n            o+=2;\n        }\n    int pos=3; while (pos+4<=n) pos+=4;\n    for (int i=pos;i>0;i-=4){\n        for (int j=1;j<=n;j+=2){\n            b[i][j]=o; o+=2;\n            if (i<n&&j<n) b[i+1][j+1]=o*2;\n        }\n    }\n\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) if ((i+j)%2==1){\n            r=1;\n            if (i>1) r=lcm(r,b[i-1][j]);\n            if (i<n) r=lcm(r,b[i+1][j]);\n            if (j>1) r=lcm(r,b[i][j-1]);\n            if (j<n) r=lcm(r,b[i][j+1]);\n            long long s=1;\n            while (f[r*s]) s++;\n            b[i][j]=r*s+1; f[r*s]=1;\n        }\n\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)cout<<b[i][j]<<' ';cout<<endl;\n    }\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) mx=max(mx,b[i][j]);\n    //cout<<mx<<endl;\n    assert(mx<=1000000000000000ll);\n    //cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#pragma region Macros\n#define ios\\\n    ios::sync_with_stdio(false);\\\n    cin.tie(nullptr);\n#define VEC(type, name, size)\\\n    V<type> name(size);\\\n    IN(name)\n#define VVEC(type, name, h, w)\\\n    VV<type> name(h, V<type>(w));\\\n    IN(name)\n#define INT(...)\\\n    int __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LL(...)\\\n    ll __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define STR(...)\\\n    string __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define CHAR(...)\\\n    char __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define DOUBLE(...)\\\n    DOUBLE __VA_ARGS__;\\\n    IN(__VA_ARGS__)\n#define LD(...)\\\n    LD __VA_ARGS__;\\\n    IN(__VA_ARGS__)\ntemplate <class T> void scan(T &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &a) { for(auto &i : a) scan(i); }\ntemplate <class T, class L> void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) { scan(head); IN(tail...); }\ntemplate <class T> inline void print(T x){ cout << x << '\\n';}\n#define ll long long\n#define ld long double\n#define FOR(i,l,r) for(ll i=(l);i<(r);++i)\n#define REP(i,n) FOR(i,0,n)\n#define REPS(i,n) FOR(i,1,n+1)\n#define RFOR(i,l,r) for(ll i=(l);i>=(r);--i)\n#define RREP(i,n) RFOR(i,n-1,0)\n#define RREPS(i,n) RFOR(i,n,1)\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((ll)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntemplate<class T = ll> using V = vector<T>;\ntemplate<class T = ll> using VV = V<V<T>>;\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true; }return false; }\ninline void Yes(bool b = true) {cout << (b ? \"Yes\" : \"No\") << '\\n';}\ninline void YES(bool b = true) {cout << (b ? \"YES\" : \"NO\") << '\\n';}\ninline void err(bool b = true) {if(b) {cout << -1 << '\\n'; exit(0);}}\ntemplate<class T> inline void fin(bool b = true, T e = 0) {if(b) {cout << e << '\\n'; exit(0);}}\ntemplate<class T> T Roundup_div(T x, T y) {return (x+(y-1))/y;}\ntemplate <typename T> T pow(T a, long long n, T e = 1) {T ret = e; while (n) {if (n & 1) ret *= a; a *= a; n >>= 1; } return ret; }\nconst ll INF = 1e18;\n#pragma endregion\n\nint N = 500;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ninline bool inside(int x, int y) {return x >= 0 and x < N and y >= 0 and y < N;}\n\nV<> pv;\nvector<bool> ip(10010, true);\nvoid er(){\n    ip[0] = ip[1] = 0;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) for(int j = 2 * i; j <= 10000; j += i) ip[j] = false;\n    for(int i = 2; i <= 10000; i++) if(ip[i]) pv.pb(i);\n}\n\nll lcm(ll x,ll y) {return x/__gcd(x,y)*y;};\n\nint main(){\n    ios;\n    er();\n    INT(n);\n    VV<> res(N, V<>(N, 1));\n    V<> ver(N), sid(N);\n    REP(i, N) ver[i] = pv[i];\n    REP(i, N) sid[i] = pv[999 - 2 * i];\n    REP(i, N){\n        if(i % 2) REP(j, N) res[j][(j + i) % N] *= pv[i];\n    }\n    REP(i, N){\n        if(i % 2) REP(j, N) res[j][(i - j + N) % N] *= pv[i - 1];\n    }\n    //REP(i, N) REP(j, N) if((i + j) % 2) res[i][j] = ver[i] * sid[j];\n    REP(i, N) REP(j, N){\n        if(!((i + j) % 2)){\n            REP(k, 4){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(inside(nx, ny)) res[i][j] = lcm(res[i][j], res[nx][ny]);\n            }\n        }\n    }\n    REP(i, n){  \n        REP(j, n) cout << ((i + j) % 2 ? res[i][j] : res[i][j] + 1 )<< \" \"; cout << endl;\n    }\n}                           "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nbool isPrime[100001];\nvector<ll> p, nonPrimeOdd;\nvoid init(){\n    for(int i = 2; i <= 10000; i++) isPrime[i] = true;\n    for(int i = 2; i <= 10000; i++){\n        if(isPrime[i]){\n            if(i != 2) p.push_back(i);\n            for(int j = 2; i*j <= 10000; j++) isPrime[i*j] = false;\n        }\n    }\n    for(int i = 2; i <= 10000; i++){\n        if(i%2 == 1 && !isPrime[i]) nonPrimeOdd.push_back(i);\n    }\n}\n\nll ans[500][500];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    int N;\n    cin >> N;\n    init();\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if((i-j)%2 == 0){\n                int k = (i+j)/2;\n                int m = (i-j)/2+N/2;\n                ans[i][j] = p[m]*p[N+k];\n            }else{\n                int k = (i+j)/2;\n                int m = (i-j-1)/2+N/2;\n                // cout << i << ' ' << j << ' ' << k << ' ' << m << endl;\n                ans[i][j] = p[m]*p[m+1]*p[N+k]*p[N+k+1]+1;\n            }\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            cout << ans[i][j] << ' ';\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 505\nint vl[N*3],n,ct,d[4][2]={-1,0,1,0,0,1,0,-1};\nlong long gcd(long long a,long long b){return b?gcd(b,a%b):a;}\nlong long as[N][N],mx;\nint main()\n{\n\tfor(int i=501;i<=10000;i++)\n\t{\n\t\tint fg=0;\n\t\tfor(int j=2;j<=100;j++)if(i%j==0)fg=1;\n\t\tif(!fg)vl[++ct]=i;\n\t}\n\tfor(int i=1;i<=500;i++)as[i][i]=vl[1]*i;\n\tint st=2;\n\tfor(int i=2;i<=500;i+=2){for(int j=1;i+j<=500;j++)as[i+j][j]=vl[st]*(j+i/2),as[j][i+j]=vl[st+1]*(j+i/2);st+=2;}\n\tfor(int i=1;i<=500;i++)\n\tfor(int j=1;j<=500;j++)\n\tif((i+j)&1)\n\t{\n\t\tlong long st=1;\n\t\tfor(int s=0;s<4;s++)\n\t\t{\n\t\t\tint vl=as[i+d[s][0]][j+d[s][1]];\n\t\t\tif(vl)st=st/gcd(st,vl)*vl;\n\t\t}\n\t\tas[i][j]=st+1;\n\t\tif(mx<st)\n\t\tmx=st;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++,printf(\"\\n\"))\n\tfor(int j=1;j<=n;j++)\n\tprintf(\"%lld \",as[i][j]);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n \n//long long gcd(long long a,long long b)\n//{\n//\tif (b==0) return a;\n//\treturn gcd(b,a%b);\n//}\n \nlong long lcm(long long a,long long b)\n{\n\treturn a*b/__gcd(a,b);\n}\n \nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n//\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tlong long op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op==0) op=ans[x][y];\n\t\t\t\t\t\telse op=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ff first\n#define ss second\n#define ll long long\nusing namespace std;\ntypedef pair<char,int> pii;\n\nint main(){\n\n    ///freopen(\"test.txt\",\"r\",stdin);\n\n    int n;\n    scanf(\"%d\",&n);\n    int m=10;\n    int delta=m-1;\n    printf(\"%d \",m);\n    int curr=m;\n    for(int i=2;i<=n;i++){\n        curr+=delta;\n        printf(\"%d \",curr);\n    }\n\n    printf(\"\\n\");\n    for(int i=2;i<=n;i++){\n        m+=delta;\n        curr=m-delta;\n        for(int j=1;j<=n;j++){\n            curr+=delta;\n            printf(\"%d \",curr);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n// from https://judge.yosupo.jp/submission/5147\nvector<int> prime_sieve(const int N, const int Q = 17, const int L = 1 << 15) {\n    using u8 = unsigned char;\n    static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};\n    struct P {\n        P(int p) : p(p) {}\n        int p;\n        int pos[8];\n    };\n    auto approx_prime_count = [](const int N) -> int { return N > 60184 ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1; };\n\n    const int v = sqrt(N), vv = sqrt(v);\n    vector<bool> isp(v + 1, true);\n    for(int i = 2; i <= vv; ++i)\n        if(isp[i]) {\n            for(int j = i * i; j <= v; j += i) isp[j] = false;\n        }\n\n    const int rsize = approx_prime_count(N + 30);\n    vector<int> primes = {2, 3, 5};\n    int psize = 3;\n    primes.resize(rsize);\n\n    vector<P> sprimes;\n    size_t pbeg = 0;\n    int prod = 1;\n    for(int p = 7; p <= v; ++p) {\n        if(!isp[p]) continue;\n        if(p <= Q) prod *= p, ++pbeg, primes[psize++] = p;\n        auto pp = P(p);\n        for(int t = 0; t < 8; ++t) {\n            int j = (p <= Q) ? p : p * p;\n            while(j % 30 != rs[t]) j += p << 1;\n            pp.pos[t] = j / 30;\n        }\n        sprimes.push_back(pp);\n    }\n\n    vector<u8> pre(prod, 0xFF);\n    for(size_t pi = 0; pi < pbeg; ++pi) {\n        auto pp = sprimes[pi];\n        const int p = pp.p;\n        for(int t = 0; t < 8; ++t) {\n            const u8 m = ~(1 << t);\n            for(int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;\n        }\n    }\n\n    const int block_size = (L + prod - 1) / prod * prod;\n    vector<u8> block(block_size);\n    u8 *pblock = block.data();\n    const int M = (N + 29) / 30;\n\n    for(int beg = 0; beg < M; beg += block_size, pblock -= block_size) {\n        int end = min(M, beg + block_size);\n        for(int i = beg; i < end; i += prod) { copy(pre.begin(), pre.end(), pblock + i); }\n        if(beg == 0) pblock[0] &= 0xFE;\n        for(size_t pi = pbeg; pi < sprimes.size(); ++pi) {\n            auto &pp = sprimes[pi];\n            const int p = pp.p;\n            for(int t = 0; t < 8; ++t) {\n                int i = pp.pos[t];\n                const u8 m = ~(1 << t);\n                for(; i < end; i += p) pblock[i] &= m;\n                pp.pos[t] = i;\n            }\n        }\n        for(int i = beg; i < end; ++i) {\n            for(int m = pblock[i]; m > 0; m &= m - 1) { primes[psize++] = i * 30 + rs[__builtin_ctz(m)]; }\n        }\n    }\n    assert(psize <= rsize);\n    while(psize > 0 && primes[psize - 1] > N) --psize;\n    primes.resize(psize);\n    return primes;\n}\nmain() {\n    auto P = prime_sieve(10000000);\n    int n = 500;\n    vv(ll, a, n, n);\n    int t = 0;\n    vll p;\n    while(P[t] < 260) t++;\n    rep(i, n) p.eb(P[t++]);\n    random_shuffle(all(p));\n    auto inc = [&](int x, int y) { return 0 <= x and x < n and 0 <= y and y < n; };\n    rep(i, n) a[i][i] = p[i];\n\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = j, y = i + j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x][y - 1] * a[x + 1][y] * (i + 1) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * i;\n        }\n    }\n    rep2(i, 1, n - 1) {\n        rep(j, n) {\n            int x = i + j, y = j;\n            if(!inc(x, y)) break;\n            if(i & 1) {\n                a[x][y] = a[x - 1][y] * a[x][y + 1] * (i + 2) + 1;\n            } else\n                a[x][y] = p[(x + y) / 2] * (i + 1) + 1;\n        }\n    }\n    INT(N);\n    rep(i, N) {\n        rep(j, N) { cout << a[i][j] << \" \"; }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\nusing ll = long long;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\ntemplate <typename T> T gcd(T a, T b) { while (a) { b %= a; swap(a, b); } return b; }\ntemplate <typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// $ seq 10000 | factor | grep '^\\(\\w\\+\\): \\1*$' | head -n 1000 | sed 's/:.*/,/' | tr -d '\\n'\nconst array<ll, 1000> primes = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919 };\n\nvector<vector<ll> > solve(int n) {\n    vector<ll> b(n);\n    vector<ll> c(n);\n    REP (z, n) {\n        b[z] = primes[z % 2 == 0 ? z     : primes.size() - z - 1];\n        c[z] = primes[z % 2 == 0 ? z + 1 : primes.size() - z - 2];\n    }\n    cerr << \"b = \" << b << endl;\n    cerr << \"c = \" << c << endl;\n\n    constexpr ll m = 1;\n    auto a = vectors(n, n, ll());\n    REP (y, n) REP (x, n) if ((y + x) % 2 == 0) {\n        a[y][x] = b[(y + x) / 2] * c[(y + (n - x - 1)) / 2];\n    }\n    REP (y, n) REP (x, n) if ((y + x) % 2 == 1) {\n        ll b = 1;\n        if (y - 1 >= 0) b = lcm(b, a[y - 1][x]);\n        if (x - 1 >= 0) b = lcm(b, a[y][x - 1]);\n        if (y + 1 <  n) b = lcm(b, a[y + 1][x]);\n        if (x + 1 <  n) b = lcm(b, a[y][x + 1]);\n        a[y][x] = b + m;\n    }\n\n    if (n == 2) {\n        a[0][1] = 2 * a[0][1] - m;\n    }\n    return a;\n}\n\nint main() {\n    int n; cin >> n;\n    auto a = solve(n);\n    REP (y, n) {\n        cout << a[y] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=5e2+10;\nconst int MAXM=1e5+10;\nint n;\nll Mat[MAXN][MAXN];\nint pcnt=0,prime[MAXM],vis[MAXM];\nvoid Linear_Shaker()\n{\n\tfor(rg int i=2;i<=MAXM;++i)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t\tprime[++pcnt]=i;\n\t\t\tfor(rg int j=1;i*prime[j]<=MAXM;++j)\n\t\t\t\t{\n\t\t\t\t\tvis[i*prime[j]]=1;\n\t\t\t\t\tif(i % prime[j]==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n}\nll GCD(ll x,ll y)\n{\n\treturn y==0? x: GCD(y,x%y);\n}\nll LCM(ll x,ll y)\n{\n\treturn x / GCD(x,y) * y;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tif(n==2)\n\t\t{\n\t\t\tprintf(\"4 7\\n23 10\");\n\t\t\treturn 0;\n\t\t}\n\tLinear_Shaker();\n\tfor(rg int i=1;i<=n;++i)\n\t\tfor(rg int j=1;j<=n;++j)\n\t\t\tMat[i][j]=1ll;\n\tfor(rg int i=1;i<=n;++i)\n\t\tfor(rg int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif((i&1)==(j&1))\n\t\t\t\t\t{\n\t\t\t\t\t\tMat[i][j]=1ll* prime[(i+j)/2] * prime[(i+n+1-j)/2+n];\n\t\t\t\t\t\tMat[i+1][j]=LCM(Mat[i+1][j],Mat[i][j]);\n\t\t\t\t\t\tMat[i-1][j]=LCM(Mat[i-1][j],Mat[i][j]);\n\t\t\t\t\t\tMat[i][j+1]=LCM(Mat[i][j+1],Mat[i][j]);\n\t\t\t\t\t\tMat[i][j-1]=LCM(Mat[i][j-1],Mat[i][j]);\n\t\t\t\t\t}\n\t\t\t}\n\tfor(rg int i=1;i<=n;++i)\n\t\tfor(rg int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld%c\",(i&1)==(j&1)?Mat[i][j]:Mat[i][j]+1,j==n?'\\n':' ');\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// PRNG {{{\ntemplate<class T, T x1, T x2, T x3, int y1, int y2, int y3>\nstruct PRNG {\n    using S = typename make_signed<T>::type;\n    T s;\n    PRNG() {\n        s = 0;\n    }\n    PRNG(T _s) : s(_s) {}\n    T next() {\n        T z = (s += x1);\n        z = (z ^ (z >> y1)) * x2;\n        z = (z ^ (z >> y2)) * x3;\n        return z ^ (z >> y3);\n    }\n    T next(T n) { return next() % n; }\n    S next(S l, S r) { return l + next(r - l + 1); }\n    T operator()() { return next(); }\n    T operator()(T n) { return next(n); }\n    S operator()(S l, S r) { return next(l, r); }\n    static T gen(T s) { return PRNG(s)(); }\n    template<class U>\n    void shuffle(U first, U last) {\n        size_t n = last - first;\n        for (size_t i = 0; i < n; i++) swap(first[i], first[next(i + 1)]);\n    }\n};\n\nusing R32 = PRNG<uint32_t, 0x9E3779B1, 0x85EBCA6B, 0xC2B2AE35, 16, 13, 16>;\nR32 r32;\n\nusing R64 = PRNG<uint64_t, 0x9E3779B97F4A7C15, 0xBF58476D1CE4E5B9, 0x94D049BB133111EB, 30, 27, 31>;\nR64 r64;\n// }}}\n\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\ninline bool bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nVI ps;\nbool is_prime( int x ) {\n    for ( int i=2; i*i<=x; i++ ) if ( x%i==0 ) return 0;\n    return 1;\n}\n\nLL lcm( LL x, LL y ) {\n    assert(y!=0);\n    return x/__gcd(x,y)*y;\n}\n\nconst int N=500;\nconst LL U=1e15;\nLL a[N][N];\nvoid main() {\n    REP1(i,2,10000) if ( is_prime(i) ) ps.PB(i);\n    dump(SZ(ps));\n    set<LL> v;\n    auto add=[&]( LL x ) {\n        assert(!v.count(x));\n        v.insert(x);\n    };\n    // r64.s=chrono::high_resolution_clock::now().time_since_epoch().count() & numeric_limits<uint64_t>::max();\n    // r64.shuffle(ps.begin(),ps.begin()+2*N);\n    REP(i,N) {\n        REP(j,N) if ( (i+j)%2==0 ) {\n            LL x=1;\n            x*=ps[(i+j)/2+1];\n            x*=ps[(i-j+N)/2+1];\n            if ( i+j<i-j+N ) x*=2;\n            a[i][j]=x;\n            add(x);\n        }\n    }\n    REP(i,N) REP(j,N) if ( (i+j)%2==1 ) {\n        LL t=1;\n        REP(k,4) {\n            int x=i+dx[k];\n            int y=j+dy[k];\n            if ( x<0 || x>=N || y<0 || y>=N ) continue;\n            t=lcm(t,a[x][y]);\n        }\n        assert(t<=U);\n        // dump(i,j,t);\n        LL x=t;\n        while ( v.count(x) ) {\n            x+=t;\n            assert(x<=U);\n        }\n        add(x);\n        a[i][j]=x;\n    }\n    int n;\n    R(n);\n    REP(i,n) W(vector<LL>(a[i],a[i]+n));\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define N 100005\n\nusing namespace std;\n\nint n, cnt;\nint prime[N], a[N], b[N];\nlong long ans[502][502];\nbool vis[N];\n\nlong long lcm(long long x, long long y){\n\treturn x / __gcd(x, y) * y;\n}\n\nint main(){\n\tscanf(\"%d\", &n); int m = 1e5;\n\tif(n == 2){\n\t\tputs(\"4 7\"); puts(\"23 10\");\n\t\treturn 0;\n\t}\n\tfor(int i = 2; i <= m; ++i){\n\t\tif(!vis[i]) prime[++cnt] = i;\n\t\tfor(int j = 1; j <= cnt && i * prime[j] <= m; ++j){\n\t\t\tvis[i * prime[j]] = true; \n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif((i + j) & 1) continue;\n\t\t\tint p1 = (i - j) / 2 + (n + 1) / 2;\n\t\t\tint p2 = (i + j) / 2 + n;\n\t\t\tans[i][j] = 1ll * prime[p1] * prime[p2];\n\t\t}\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif(!((i + j) & 1)) continue;\n\t\t\tlong long tmp = 1;\n\t\t\tif(i != 1) tmp = lcm(tmp, ans[i - 1][j]);\n\t\t\tif(j != 1) tmp = lcm(tmp, ans[i][j - 1]);\n\t\t\tif(i != n) tmp = lcm(tmp, ans[i + 1][j]);\n\t\t\tif(j != n) tmp = lcm(tmp, ans[i][j + 1]);\n\t\t\tans[i][j] = tmp + 1;\n\t\t}\n\tfor(int i = 1; i <= n; ++i, puts(\"\"))\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tprintf(\"%lld \", ans[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <climits>\n#include <algorithm>\n#include <random>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <bitset> \n#include <queue>\n#define inf 0x3f3f3f3f\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0);\n#define rep(i, a, n) for(register int i = a; i <= n; ++ i)\n#define per(i, a, n) for(register int i = n; i >= a; -- i)\n//#define ONLINE_JUDGE\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\ntemplate<typename T>void write(T x)\n{\n    if(x<0)\n    {\n        putchar('-');\n        x=-x;\n    }\n    if(x>9)\n    {\n        write(x/10);\n    }\n    putchar(x%10+'0');\n}\n \ntemplate<typename T> void read(T &x)\n{\n    x = 0;char ch = getchar();ll f = 1;\n    while(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n    while(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;};\nll ksm(ll a,ll n){//看是否要mod \n\tll ans=1;\n\twhile(n){\n\t\tif(n&1) ans=(ans*a)%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn ans%mod;\n}\n//==============================================================\nconst int maxn=5e2+10;\nint mat[maxn][maxn];\nint n;\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\t//===========================================================\n    read(n);\n\tmat[1][1]=2;\n    int x=1,y=2;\n    rep(i,2,n) mat[1][i]=mat[1][i-1]+1;\n    mat[2][n]=mat[1][n]+1;\n    x=2,y=n-1;\n    int dir=1;\n    while(true){\n        if(mat[x-1][y]!=0&&mat[x][y+dir]!=0)mat[x][y]=lcm(mat[x-1][y],mat[x][y+dir])+1;\n        else{\n            mat[x][y]=mat[x][y+dir]+mat[x-1][y]+1;\n        }\n        y-=dir;\n        if(y==0) dir=-1,x++,y=1;\n        if(y==n+1) dir=1,x++,y=n;\n        if(x>n) break;\n    }\n    rep(i,1,n){\n        rep(j,1,n){\n            if(j-1) putchar(' ');\n            write(mat[i][j]);\n        }\n        \n        putchar('\\n');\n    }\n\t//===========================================================\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 5e2 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nconst int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};\n\nll n;\n\nll f[maxn][maxn], g[maxn][maxn];\n\nll vis[100100], prime[maxn << 1], tot;\n\nvoid init()\n{\n\trep(i, 2, 100000)\n\t{\n\t\tif(vis[i]) continue;\n\t\tprime[++ tot] = i;\n\t\tif(tot >= 1000) return;\n\t\trep(j, 2, 100000)\n\t\t{\n\t\t\tif(i * j >= 100000) break;\n\t\t\tvis[i * j] = 1;\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tscanf(\"%lld\", &n);\n\tif(n == 2) return puts(\"1 2\\n4 8\"), 0;\n\tinit();\n\tll cnt = 0;\n\trep(i, 2, n << 1)\n\t{\n\t\t++ cnt;\n\t\trep(j, 1, i - 1) f[j][i - j] = prime[cnt];\n\t\t++ i;\n\t}\n\t// rep(i, 1, n) rep(j, 1, n) printf(\"%lld%c\", f[i][j], \" \\n\"[j == n]);\n\trep(i, - n / 2, n / 2)\n\t{\n\t\t++ cnt;\n\t\trep(j, max(1ll, - i * 2 + 1), min(n, n - i * 2)) f[j][j + i * 2] *= prime[cnt], g[j][j + i * 2] = prime[cnt];\n\t}\n\t// rep(i, 1, n) rep(j, 1, n) printf(\"%lld%c\", f[i][j], \" \\n\"[j == n]);\n\trep(i, 1, n) rep(j, 1, n)\n\t{\n\t\tll tmp = 1;\n\t\tif(f[i][j]) goto end;\n\t\trep(k, 0, 3)\n\t\t{\n\t\t\tint x = i + dx[k], y = j + dy[k];\n\t\t\tif(x <= 0 || y <= 0 || x > n || y > n) continue;\n\t\t\ttmp = tmp / __gcd(tmp, f[x][y]) * f[x][y];\n\t\t}\n\t\tf[i][j] = tmp + 1;\n\t\tend:;\n\t\tprintf(\"%lld%c\", f[i][j], \" \\n\"[j == n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 5e2 + 10,Lim = 1e4 + 10;\n\nint dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\nint prime[Lim],vis[Lim],cnt = 0;\nll res[N][N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline ll Lcm(ll a,ll b) {\n\treturn a / __gcd(a,b) * b;\n}\n\ninline void init(int n) {\n\tFor(i,2,n) {\n\t\tif(!vis[i]) prime[++cnt] = i;\n\t\tfor(int j = 1;j <= cnt && i * prime[j] <= n;j++) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif(i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nint main() {\n\n\tint n = read();\n\tif(n == 2) { puts(\"4 7\\n23 10\");return 0; }\n\tinit(1e4);\n\tFor(i,1,n) For(j,1,n) if((i + j) % 2 == 0)\n\t\tres[i][j] = prime[(i + j) / 2];\n\tFor(i,1,n) For(j,1,n) if((i + j) % 2 == 0)\n\t\tres[i][j] *= prime[n + (n - i + 1 + j) / 2];\n\tFor(i,1,n) For(j,1,n) if(!res[i][j]) {\n\t\tll Prod = 1;\n\t\tFor(k,0,3) {\n\t\t\tint x = i + dir[k][0],y = j + dir[k][1];\n\t\t\tif(x <= 0 || y <= 0 || x > n || y > n) continue;\n\t\t\tProd = Lcm(Prod,res[i + dir[k][0]][j + dir[k][1]]);\n\t\t}\n\t\tres[i][j] = Prod + 1;\n\t}\n\tFor(i,1,n) For(j,1,n) printf(\"%lld%c\",res[i][j],j == n ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2018 Mstdream\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=505;\nint n,is[N*N],pr[N*N],cnt;\nLL a[N][N];\nmap<int,int>x,y;\nint main(){\n\t//freopen(\"xxx.in\",\"r\",stdin);\n\t//freopen(\"xxx.out\",\"w\",stdout);\n\tfor(int i=2;i<=100000;i++){\n\t\tif(!is[i]){\n\t\t\tpr[++cnt]=i;\n\t\t\tfor(int j=i+i;j<=100000;j+=i)is[j]=1;\n\t\t}\n\t}\n\tcin>>n;\n\tcnt=0;\n\tfor(int i=0;i<=n+n+2;i+=2)x[i]=pr[++cnt];\n\tint sta=-n-1,end=n+1;\n\tif(end&1)sta--,end++;\n\tfor(int i=sta;i<=end;i+=2)y[i]=pr[++cnt];\n\tfor(int i=0;i<=n+1;i++){\n\t\tfor(int j=0;j<=n+1;j++){\n\t\t\tif((i+j)%2==0)a[i][j]=x[i+j]*y[i-j];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif((i+j)%2==1){\n\t\t\t\ta[i][j]=a[i-1][j];\n\t\t\t\ta[i][j]=a[i][j] / __gcd(a[i][j], a[i + 1][j]) * a[i + 1][j];\n\t\t\t\ta[i][j]=a[i][j] / __gcd(a[i][j], a[i][j - 1]) * a[i][j - 1];\n\t\t\t\ta[i][j]=a[i][j] / __gcd(a[i][j], a[i][j + 1]) * a[i][j + 1];\n\t\t\t\ta[i][j] ++;\n\t\t\t}\n\t\t\tprintf(\"%lld%c\",a[i][j],\" \\n\"[j==n]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 502;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n   for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n\n\n    for(int j = 2 - !(MaxN & 1); j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j + !(MaxN & 1) - 1];\n\n\n  /*  for(int i = 0; i < MaxN; ++i)\n    {\n        for(int j = 0; j < MaxN; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }*/\n\n\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define int long long\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 3000, M = 100010;\nLL a[N][N], prime[M], tot;\nbool vis[M];\n\nvoid init(int n) {\n\tfor (int i = 2; i <= n; ++ i) {\n\t\tif (!vis[i]) prime[++ tot] = i;\n\t\tfor (int j = 1; j <= tot && prime[j] * i <= n; ++ j) {\n\t\t\tvis[i * prime[j]] = 1;\n\t\t\tif (i % prime[j] == 0) break;\n\t\t}\n\t}\n}\n\nLL lcm(LL x, LL y) {\n\tif (!x || !y) return x | y;\n\tLL o = std::__gcd(x, y);\n\treturn x / o * y;\n}\n\nsigned main() {\n\tinit(M - 1);\n\tint n = read();\n\tif (n == 2) return puts(\"4 7\\n23 10\"), 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = ((i + 1) & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = prime[(i + j) / 2] * prime[n + (i - j) / 2 + (n + 1) / 2];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = (i & 1) + 1; j <= n; j += 2) {\n\t\t\ta[i][j] = lcm(lcm(a[i - 1][j], a[i - 1][j - 1]), lcm(a[i + 1][j], a[i + 1][j + 1]));\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int dx[] {0, 0, -1, 1}, dy[] {-1, 1, 0, 0};\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; ++i)\n        if (x % i == 0)\n            return false;\n    return true;\n}\nLL lcm(LL x, LL y) {return x / __gcd(x, y) * y;}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> primes;\n    int now = 2;\n    while (primes.size() < 2 * n) {\n        if (isPrime(now))\n            primes.push_back(now);\n        ++now;\n    }\n    vector<vector<LL>> a(n);\n    for (int i = 0; i < n; ++i)\n        a[i].resize(n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            if ((i + j) % 2 == 0)\n                a[i][j] = primes[(i + j) / 2] * primes[(i - j + n - 1) / 2 + n];\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if ((i + j) % 2 == 1) {\n                a[i][j] = 1;\n                for (int k = 0; k < 4; ++k) {\n                    int x = i + dx[k];\n                    int y = j + dy[k];\n                    if (x >= 0 && x < n && y >= 0 && y < n)\n                        a[i][j] = lcm(a[i][j], a[x][y]);\n                }\n                ++a[i][j];\n            }\n        }\n    }\n    if (n == 2)\n        a[1][0] = 2 * a[1][0] - 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cout << a[i][j] << \" \\n\"[j == n - 1];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nvector<ll> primes;\nll factor[1005];\nll field[505][505];\nset<ll> used;\n\nint main() {\n    //cout.precision(10);\n    int N;\n    cin >> N;\n    for(ll i = 2; i <= 20000; i++) {\n        bool ok = true;\n        for(ll j = 2; j * j <= i; j++) {\n            if(i % j == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if(ok) primes.push_back(i);\n    }\n    int index = 1;\n    for(int i = 2; i <= 2 * N; i += 2) {\n        factor[i] = primes[index];\n        index++;\n    }\n    for(int i = 1; i <= N + 1; i += 2) {\n        field[i][1] = primes[index];\n        index++;\n        ll now1 = field[i][1];\n        field[1][i] = primes[index];\n        index++;\n        ll now2 = field[1][i];\n        //cerr << i << \" \" << index << endl;\n        for(int j = 1; j + i - 1 <= N + 1; j++) {\n            field[j][i+j-1] = now1 * factor[i + 2 * j - 1];\n            field[i+j-1][j] = now2 * factor[i + 2 * j - 1];\n            //cerr << i << \" \" << j << endl;\n        }\n    }\n    vector<ll> val;\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= N; j++) {\n            if(field[i][j] == 0) {\n                if(i > 1) field[i][j] = field[i+1][j] * field[i-1][j] + 1;\n                else field[i][j] = field[i][j+1] * field[i][j-1] + 1;\n            }\n            cout << field[i][j] << \" \";\n            //if(field[i][j] > 1e15) val.push_back(field[i][j]);\n            //if(used.find(field[i][j]) != used.end()) val.push_back(field[i][j]);\n            used.insert(field[i][j]);\n            if(i > 1) {\n                if(max(field[i-1][j], field[i][j]) % min(field[i][j], field[i-1][j]) != 1) val.push_back(field[i][j]);\n                //cerr << i << \" \" << j << \" \" << field[i][j] << \" \"<< field[i-1][j] << endl;\n            }\n        }\n        cout << endl;\n    }\n    //cout << \"out\" << endl;\n    //for(int i = 0; i < val.size(); i++) cout << val[i] << endl;\n    //cout << primes.size() << \" \" << primes[2] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 500;\nll a[N][N];\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, 1, -1};\nvector<ll> primes;\nvoid gen_primes(){\n    primes.push_back(2);\n    while((int) primes.size() < 2 * N){\n        ll cur = primes.back() + 1;\n        while(true){\n            bool ok = false;\n            for(ll p: primes){\n                if(cur % p == 0){\n                    ok = true;\n                    break;\n                }\n            }\n            if(!ok){\n                primes.push_back(cur);\n                break;\n            }\n            cur++;\n        }\n    }\n}\nll LCM(ll x, ll y){\n    return x / __gcd(x, y) * y;\n}\nbool valid(int i, int j){\n    return (i >= 0 && i < N && j >= 0 && j < N);\n}\nvoid gen(){\n    gen_primes();\n    for(int i = 0; i < N; i++){\n        for(int j = i % 2; j < N; j += 2){\n            int diag1 = (i + j) / 2, diag2 = (i - j) / 2 + N;\n            a[i][j] = primes[diag1] * primes[diag2];\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(a[i][j] != 0) continue;\n            a[i][j] = 1;\n            for(int d = 0; d < 4; d++){\n                int ni = i + di[d], nj = j + dj[d];\n                if(valid(ni, nj)){\n                    a[i][j] *= a[ni][nj];\n                }\n            }\n            a[i][j]++;\n        }\n    }\n}\nint main(){\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n    gen();\n    int n; cin >> n;\n    cout << '\\n';\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int dx[4]={0,0,1,-1};\nconst int dy[4]={1,-1,0,0};\nconst int N=10000;\nint n,a[N],b[N],c[N],cnt,p[N],prime[N],tot;\nll num[505][505];\nvoid shai()\n{\n\tfor (int i=2;i<N;i++)\n\t{\n\t\tif (!p[i]) prime[++tot]=i;\n\t\tfor (int j=1;j<=tot&&prime[j]*i<N;j++)\n\t\t{\n\t\t\tp[prime[j]*i]=1;\n\t\t\tif (i%prime[j]==0) break;\n\t\t}\n\t}\n}\nll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\nll calc(int x,int y)\n{\n\tll Lcm=0;\n\tfor (int i=0;i<4;i++)\n\t{\n\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\tif (xx<1||yy<1||xx>n||yy>n) continue;\n\t\tif (!Lcm) Lcm=num[xx][yy];else Lcm=lcm(num[xx][yy],Lcm);\n\t}\n\treturn Lcm+1;\n}\nint main()\n{\n\tshai();\n\tscanf(\"%d\",&n);\n\tif (n==2){\n\t\tprintf(\"4 7\\n23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;i<=2*n;i+=2) a[i]=prime[++cnt];\n\tfor (int i=0;i<=n-1;i+=2) b[i]=prime[++cnt];\n\tfor (int i=2;i<=n-1;i+=2) c[i]=prime[++cnt];\n\tfor (int i=1;i<=n;i++)\n\t  for (int j=1;j<=n;j++)\n\t  if ((i+j)%2==0)\n\t  {\n\t  \t  if (i<=j) num[i][j]=(ll)a[i+j]*b[j-i];\n\t  \t  else num[i][j]=(ll)a[i+j]*c[i-j];\n\t  }\n\tfor (int i=1;i<=n;i++)\n\t{\n\t   for (int j=1;j<=n;j++)\n\t   {\n\t  \t if (num[i][j]) printf(\"%lld \",num[i][j]);\n\t  \t else printf(\"%lld \",calc(i,j));\n\t   }\n\t   puts(\"\");\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\n\nint x[501];\nint y[501];\nint so[100000]={0};\nvector<int> ve1,ve2,ve;\nint ans[501][501]={0};\nint ban[1010][1010]={0};\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nrandom_device seed_gen;\n  \t\n mt19937 engine(seed_gen());\n  \tfor(int i=2;i<100000;i++)if(so[i]==0){\n  \t\tif(ve1.size()<500)ve1.pb(i);\n  \t\telse ve2.pb(i);\n  \t\tif(ve2.size()==500) break;\n  \t\tfor(int j=i;j<100000;j+=i)so[j]=1;\n  \t}\n  //\tcout<<ve2.back()<<endl;\n  \tint cnt=0;\n  \twhile(1){\n  \t\tshuffle(ve1.begin(), ve1.end(),engine);\n  \t\tshuffle(ve2.begin(), ve2.end(),engine);\n  \t\tcnt++;\n  //\t\tcout<<cnt<<endl;\n  \t\tve.clear();\n  \t\tfor(int i=0;i<500;i++){\n  \t\t\tve.pb(ve1[i]);\n  \t\t\tve.pb(ve2[i]);\n  \t\t}\n  \t\tfor(int i=0;i<=498;i++)for(int j=500;j<=998;j++){\n  \t\t\tif(ve[i]*ve[i+1]*ve[j]*ve[j+1]>1000000000000000ll){\n  \t\t//\tcout<<i<<\" \"<<j-500<<endl;\n  \t\t\t\tgoto lll;\n  \t\t\t}\n  \t\t\t}\n  \t\t\n  \t\tbreak;\n  \t\tlll:;\n  \t}\n  //\tfor(auto v:ve)cout<<v<<endl;\n  \t\n  \tfor(int i=0;i<=500;i++){\n  \t\tif(i==0) x[i]=ve[i];\n  \t\telse if(i==500) x[i]=ve[i-1];\n  \t\telse{\n  \t\t\tx[i]=ve[i]*ve[i-1];\n  \t\t}\n  \t}\n  \t\n  \tfor(int j=0;j<=500;j++){\n  \t\tif(j==0) y[j]=ve[500+j];\n  \t\telse if(j==500)y[j]=ve[j-1+500];\n  \t\telse{\n  \t\t\ty[j]=ve[j+500]*ve[j-1+500];\n  \t\t}\n  \t}\n  \tint n;\n  \tcin>>n;\t\n  \tfor(int i=0;i<=500;i++)for(int j=0;j<=500;j++){\n  \t\tban[2*i][2*j]=x[i]*y[j]+1;\n  \t//\tassert(x[2*i]*y[2*j]<=1000000000000000ll);\n  \t}\n  \t\n  \t\n  \t\n  \tfor(int i=0;i<=499;i++)for(int j=0;j<=499;j++){\n  \t\tint g=ban[2*i][2*j]-1;\n  \t\tg=gcd(g,ban[2*i+2][2*j]-1);\n  \t\tg=gcd(g,ban[2*i][2*j+2]-1);\n // \t\tg=gcd(g,ban[i+1][j]);\n  \t\tg=gcd(g,ban[2*i+2][2*j+2]-1);\n  \t\tban[2*i+1][2*j+1]=g;\n  //\t\tcout<<g<<\" \"<<se.size()<<endl;\n  \t//\tassert(se.count(g)==0);\n  //\t\tse.insert(g);\n  \t}\n  \t\n  \tset<int> se;\n  \tfor(int i=0;i<500;i++)for(int j=0;j<500;j++){\n  \t\t\n  \t\tint s=(i+j);\n  \t\tint t=(i-j)+500;\n  \t\tif(ban[s][t]<=0){\n  \t\t\tcout<<i<<\" \"<<j<<endl;\n  \t\t}\n  \t\tassert(ban[s][t]>0);\n  \t\tassert(ban[s][t]<=1000000000000000ll);\n  \t\tassert(se.count(ban[s][t])==0);\n  \t\tse.insert(ban[s][t]);\n  \t\t\n  \t\tans[i][j]=ban[s][t];\n  \t}\n  \tfor(int i=0;i<n;i++){\n  \t\tfor(int j=0;j<n;j++)cout<<ans[i][j]<<\" \";\n  \t\tcout<<endl;\n  \t}\n  \treturn 0;\n\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n  donttttttt use vector \n  run n = 1 and n = MAXN before submit\n  try to AC within one submission\n*/\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\n\n#define int long long\n\nconst int N = 555;\nconst int M = 5e6 + 233;\nbool np[M], ban[M]; int p[M / 10], p_cnt;\nint n, a[N][N], bad[N][N];\n\ninline void prepare(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (np[i]) continue;\n\t\tp[++p_cnt] = i;\n\t\tfor (int j = i + i; j <= n; j += i) {\n\t\t\tnp[j] = true;\n\t\t}\n\t}\n}\n\ninline int lcm(int x, int y) {\n\treturn x / __gcd(x, y) * y;\n}\n\nsigned main(void) {\n\tprepare(10000);\n\tread(n);\n\trep (i, n) rep (j, n) bad[i][j] = ~(i + j) & 1;\n\tint tot = 0;\n\trep (len, n + n) if (len % 2 == 0) {\n\t\t++tot;\n\t\trep (i, n) rep (j, n)\n\t\t\tif (i + j == len && bad[i][j])\n\t\t\t\ta[i][j] = p[tot];\n\t}\n\trep (len, n + n) if (len % 2 == 0) {\n\t\t++tot;\n\t\trep (i, n) rep (j, n)\n\t\t\tif ((n - i + 1 + j) == len && bad[i][j])\n\t\t\t\ta[i][j] *= p[tot];\n\t}\n\t// cerr << p[500] * p[1000] << \"\\n\";\n\t// rep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n\trep (i, n) rep (j, n) if ((i + j) & 1) {\n\t\ta[i][j] = 1;\n\t\tauto add = [&](int x, int y) {\n\t\t\tif (x < 1 || x > n || y < 1 || y > n) return ;\n\t\t\tint t = lcm(a[i][j], a[x][y]), base = t;\n\t\t\ta[i][j] = t;\n\t\t\treturn ;\n\t\t};\n\t\tadd(i - 1, j);\n\t\tadd(i + 1, j);\n\t\tadd(i, j - 1);\n\t\tadd(i, j + 1);\n\t\t++a[i][j];\n\t}\n\trep (i, n) rep (j, n) cout << a[i][j] << \" \\n\"[j == n];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define fr(i,a,b) for (int i = b-1; i >= a; i--)\n#define pb push_back\n#define IN(i,a,b) (a<=i&&i<=b)\n\nint di[] = {0,0,1,-1};\nint dj[] = {1,-1,0,0};\n\nll gcd(ll a, ll b) {\n\treturn a?gcd(b%a,a):b;\n}\n\nll lcm(ll a, ll b) {\n\treturn a*b/gcd(a,b);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tint n; cin>>n;\n\tll a[n][n];\n\tint mxn = 1e5;\n\tint sieve[mxn];\n\tfill(sieve,sieve+mxn,0);\n\tvi primes;\n\tf(i,2,mxn) if (sieve[i] == 0) {\n\t\tprimes.pb(i);\n\t\tfor (int j = i; j <mxn; j+=i)\n\t\t\tsieve[j] = i;\n\t}\n\tint x[n],y[n];\n\tint t = 0;\n\tf(i,0,n) x[i] = primes[t++];\n\tf(i,0,n) y[i] = primes[t++];\n\tf(i,0,n) f(j,0,n) if ((i+j)&1)\t\n\t\ta[i][j] = x[i]*y[j];\n\tf(i,0,n) f(j,0,n) if (!((i+j)&1)) {\n\t\tll w = 1;\n\t\tf(k,0,4) {\n\t\t\tint ni = i+di[k], nj = j+dj[k];\n\t\t\tif (IN(ni,0,n-1) && IN(nj,0,n-1)) \n\t\t\t\tw = lcm(w,a[ni][nj]);\n\t\t}\n\t\ta[i][j] = w+1;\n\t}\n\tstringstream ss;\n\tf(i,0,n) f(j,0,n) ss << a[i][j] << \" \\n\"[j+1==n];\n\tcout << ss.str();\n\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nif(n==2){\nprintf(\"4 7\\n10 23\\n\");\nreturn 0;\n}\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=-((n-1)>>1);i<((n+1)>>1);i++){\ntot=min(n-i-1,n+i-1);\nfor(int j=max(i,-i);j<=tot;j++)ans[i+j][j-i]*=prime[i+n+((n-1)>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bz[500010];\nint gs,n;\nlong long b[1010][1010],c[1010][1010],ans[1010][1010],zs[500010];\nint fx[4][2]={{0,-1},{0,1},{-1,0},{1,0}};\n\nlong long gcd(long long a,long long b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b)\n{\n\tif (a==0) return b;\n\tif (b==0) return a;\n\treturn a*b/gcd(a,b);\n}\n\nint main()\n{\n//\tfreopen(\"hanoi.out\",\"w\",stdout);\n\tfor (int i=2;i<=500000;i++)\n\t{\n\t\tif (!bz[i])\n\t\t{\n\t\t\tgs++;\n\t\t\tzs[gs]=i;\n\t\t\tfor (int j=1;j<=500000/i;j++)\n\t\t\t{\n\t\t\t\tbz[j*i]=true;\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&n);\n\tif (n==2)\n\t{\n\t\tprintf(\"4 7\\n\");\n\t\tprintf(\"23 10\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t\tif (i==1) continue;\n\t\t\tx=i;y=1;\n\t\t\twhile (x<=n && y<=n)\n\t\t\t{\n\t\t\t\tb[x][y]=zs[i-1];\n\t\t\t\tx++;y++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (i%2==1)\n\t\t{\n\t\t\tint x=1;int y=i;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i+1];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t\tif (i==n) continue;\n\t\t\tif (n%2==0) x=n-i+1;\n\t\t\telse x=n-i+1;y=n;\n\t\t\twhile (x<=n && y>=1)\n\t\t\t{\n\t\t\t\tc[x][y]=zs[n+n-i];\n\t\t\t\tx++;y--;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n//\t\t\tif(!((i + j) & 1)) ans[i][j] = zs[(i + j) / 2] * zs[n + (i - j) / 2 + (n + 1) / 2];\n\t\t\tif ((i+j)%2==0)\n\t\t\t{\n\t\t\t\tans[i][j]=b[i][j]*c[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif ((i+j)%2==1)\n\t\t\t{\n\t\t\t\tlong long op=0;\n\t\t\t\tfor (int k=0;k<=3;k++)\n\t\t\t\t{\n\t\t\t\t\tint x=i+fx[k][0];\n\t\t\t\t\tint y=j+fx[k][1];\n\t\t\t\t\tif (x>=1 && x<=n && y>=1 && y<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\top=lcm(op,ans[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[i][j]=op+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tprintf(\"%lld \",ans[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1005;\nint a[N][N],flag[N*10],P[N*10],tot,n; \nint check1(int x,int y){\n\treturn (x+y)/2;\n}\nint check2(int x,int y){\n\treturn (x-y+n+1)/2;\n}\nint Lcm(int x,int y){\n\tif (!x||!y)return x+y;\n\treturn x/__gcd(x,y)*y;\n} \nsigned main(){\n\tscanf(\"%lld\",&n);\n\tif (n==2){\n\t\tputs(\"2 3\");\n\t\tputs(\"5 16\");\n\t\treturn 0;\n\t}\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])for (int j=2*i;j<=10000;j+=i)flag[j]=1;\n\tfor (int i=2;i<=10000;i++)\n\t\tif (!flag[i])P[++tot]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==1)a[i][j]=P[check1(i,j)]*P[check2(i,j)+n+1];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif ((i+j)%2==0)a[i][j]=Lcm(Lcm(a[i+1][j],a[i-1][j]),Lcm(a[i][j-1],a[i][j+1]))+1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++)printf(\"%lld \",a[i][j]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 503;\n\nlong long a[MaxN][MaxN];\n\nvector <int> p1;\nvector <int> p2;\n\nlong long lcm(long long a, long long b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nbool isPrime(int x)\n{\n    if(x == 1)\n        return false;\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0)\n            return false;\n    return true;\n}\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nvoid build(int x, int y)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx >= 0 && xx < MaxN && yy >= 0 && yy < MaxN)\n            a[x][y] = lcm(a[x][y], a[xx][yy]);\n    }\n\n    ++a[x][y];\n\n    assert(a[x][y] <= 1e15 && a[x][y] > 0);\n}\n\nvoid check()\n{\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n        {\n            for(int d = 0; d < 4; ++d)\n            {\n                int x = i + dx[d];\n                int y = j + dy[d];\n\n                if(x >= 0 && x < MaxN && y >= 0 && y < MaxN)\n                {\n                    long long k1 = min(a[i][j], a[x][y]);\n                    long long k2 = max(a[i][j], a[x][y]);\n\n                    assert(k2 % k1 == 1);\n                }\n            }\n        }\n}\n\nint main()\n{\n    ios_base :: sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"input.txt\", \"r\", stdin);\n    mt19937 rnd(clock());\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            a[i][j] = 1;\n\n    for(int i = 2; i <= 20000; ++i)\n        if(isPrime(i))\n        {\n            if(p1.size() <= MaxN)\n                p1.push_back(i);\n            else\n                p2.push_back(i);\n        }\n\n//    shuffle(p1.begin(), p1.end(), rnd);\n//    shuffle(p2.begin(), p2.end(), rnd);\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j + i < MaxN; ++j)\n            a[i + j][j] *= p1[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; i + j < MaxN; ++i)\n            a[i][j + i] *= p1[j - 1];\n\n\n    for(int i = 0; i < MaxN; i += 2)\n        for(int j = 0; j < MaxN && i - j >= 0; ++j)\n            a[i - j][j] *= p2[i];\n\n    for(int j = 2; j < MaxN; j += 2)\n        for(int i = 0; j + i < MaxN; ++i)\n            a[MaxN - 1 - i][j + i] *= p2[j - 1];\n\n    for(int i = 0; i < MaxN; ++i)\n        for(int j = 0; j < MaxN; ++j)\n            if((i + j) & 1)\n                build(i, j);\n\n    check();\n\n    int n;\n    cin >> n;\n\n    assert(n <= MaxN);\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < n; ++j)\n            cout << a[i][j] << ' ';\n        cout << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nlong long n, x[600], y[600], p = 2;\n\nint not_prime(long long x)\n{\n\tfor (int i = 2; i < x; i++) if (x % i == 0) return 1;\n\treturn 0;\n}\nint main()\n{\n\tstd::cin >> n;\n\tfor (int i = 0; i <= 500; i += 2)\n\t{\n\t\twhile (not_prime(p)) p++;\n\t\tx[i] = p;\n\t\tp++;\n\t}\n\tfor (int i = 0; i <= 500; i += 2)\n\t{\n\t\twhile (not_prime(p)) p++;\n\t\ty[i] = p;\n\t\tp++;\n\t}\n\tfor (int i = 1; i < 500; i += 2)\n\t    x[i] = x[i - 1] * x[i + 1];\n\tfor (int i = 1; i < 500; i += 2)\n\t    y[i] = y[i - 1] * y[i + 1];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tstd::cout << x[i] * y[j] << \" \";\n\t\t}\n\t\tstd::cout << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// 最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint N;\nint A[550][550];\ndeque<int> prime;\nunordered_map<int, int> mpA, mpB;\nunordered_map<int, bool> ex;\nsigned main() {\n    cin >> N;\n    for (int i = 2; i <= 1500; i++) {\n        prime.push_back(i);\nnene:;\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        if (i % 2 == 0) {mpA[2 * i] = prime.front(); prime.pop_front();}\n        else {mpA[2 * i] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 10; i++) {\n        if (i % 2 == 0) {mpB[2 * i - (N + 4) - N % 2] = prime.front(); prime.pop_front();}\n        else {mpB[2 * i - (N + 4) - N % 2] = prime.back(); prime.pop_back();}\n    }\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= N + 1; j++) {\n            if ((i + j) % 2 == 1)continue;\n            A[i][j] = mpA[i + j] * mpB[i - j];\n            ex[A[i][j]] = true;\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if ((i + j) % 2 == 0) {cout << A[i][j] << \" \"; continue;}\n            int cur = 1;\n            for (int k = 0; k < 4; k++) {\n                cur = cur / gcd(cur, A[i + dy[k]][j + dx[k]]) * A[i + dy[k]][j + dx[k]];\n            }\n            int c = 1;\n            while (ex[cur * c + 1])c++;\n            cout << cur*c + 1 << \" \";\n            ex[cur * c + 1] = true;\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=505,M=100005,x[4]={1,-1,0,0},y[4]={0,0,1,-1};\nll ans[N][N],tot;\nint n,p[M],vis[M],q[M];\n#define ld long double\nll lcm(ll x,ll y){\n\tif(x==0)return y; if(y==0)return x;//cout<<x<<\" \"<<y<<endl;\n\t//if((ld)x/__gcd(x,y)*y>(1e15))while(1);\n\treturn x/__gcd(x,y)*y;\n}\nsigned main(){\n\tn=500;\n\tfor(int i=2;i<M;i++)if(!vis[i]){\n\t\tq[++tot]=i; for(int j=i;j<M;j+=i)vis[j]=1;\n\t}\n\tfor(int i=1;i<=1000;i++)if(i&1)p[i]=q[(i+1)/2]; else p[i]=q[1001-i/2];\n\tint tx=248,ty=249;\n\tfor(int i=1;i<=n*2;i+=2){\n\t\tif(i<=n){tx+=2; ty+=1;} else {tx+=2; if(i!=n+1)ty--;}\n\t\tint x=i<=n?1:i-n+1,y=i<=n?n-i+1:1;\n\t\tint t=min(n-x+1,n-y+1);\n\t\tfor(int j=0;j<t;j++){\n\t\t\tans[x+j][y+j]=p[tx]*p[ty-j];\n\t\t\t//if(abs(x+j-2)+abs(y+j-2)==1)cout<<tx<<\" \"<<ty-j<<endl;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if((i+j)%2==0){\n\t//cout<<i<<\" \"<<j<<endl;\n\t\tfor(int k=0;k<4;k++)ans[i][j]=lcm(ans[i][j],ans[i+x[k]][j+y[k]]);\n\t\tans[i][j]++;\n\t}\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\twrite(ans[i][j]); putchar(' ');\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n/*\n\n \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=10005;\nint fl[N],pri[N];\nint v1[N],v2[N],n;\nvoid init(){\n\tFor(i,2,N-1) For(j,2,(N-1)/i) fl[i*j]=1;\n\tFor(i,2,N-1) if (!fl[i]) pri[++*pri]=i;\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\tFor(i,0,n+n+2) v1[i]=v2[i]=1;\n\tFor(i,0,n+n+2){\n\t\tif (i%2==0) v1[i]=pri[(*pri)--];\n\t\tif ((i+n+1)%2==0) v2[i]=pri[(*pri)--];\n\t}\n\tFor(i,1,n) For(j,1,n)\n\t\tif ((i+j)%2==0) printf(\"%lld%c\",1ll*v1[i+j]*v2[i+n-j+1],j==n?'\\n':' ');\n\t\telse printf(\"%lld%c\",1ll*v1[i+j-1]*v1[i+j+1]*v2[i+n-j]*v2[i+n-j+2]+1,j==n?'\\n':' ');\n}"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport Data.Tuple\nimport Data.Bits\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport Control.Monad\nimport Control.Monad.ST\nimport Debug.Trace\n\nsolve :: Int -> String\nsolve n = unlines $ map (unwords . map show) $ solve0 n\n\nsolve0 :: Int -> [[Int]]\nsolve0 n = take n $ tail $ unfoldr f $ VU.toList getTable\n  where f [] = Nothing\n        f xs = Just (take n (tail lst1), lst2)\n          where (lst1, lst2) = splitAt 512 xs\n\nprime9 = [2,3,4,5,7,9,11,13,17]\nirr9 = concat $ zipWith (\\p q -> [p,q]) ls1 (reverse ls2)\n  where (ls1, rest) = splitAt 256 $ foldr op [2..] prime9\n          where op p rem = filter (\\x -> x `mod` p /= 0) rem\n        ls2 = take 256 rest\n\nbitPs :: Int -> Int\nbitPs i = product $ zipWith (hat i) [0..8] prime9\n  where\n    hat :: Int -> Int -> Int -> Int\n    hat i j x | testBit i j = x\n              | otherwise   = 1\n\nenc :: (Int,Int) -> Int\nenc (y,x) = y*512+x\n\ndec :: Int -> (Int,Int)\ndec i = divMod i 512\n\ngetTable :: VU.Vector Int\ngetTable = VU.create $ do\n  table <- VUM.new (512*512)\n  t_irr9 <- VUM.new 512\n  forM_ (zip [0..] irr9) $ \\(i,x) -> VUM.write t_irr9 i x\n  forM_ [0..511] $ \\u -> do\n    forM_ [0..255] $ \\v -> do\n      let v' = 2*v + (if u `mod` 2 == 0 then 0 else 1)\n      c <- VUM.read t_irr9 ((u + v') `div` 2)\n      VUM.write table (enc (u,v')) (c * (bitPs u))\n  forM_ [1..509] $ \\s -> do\n    used <- VUM.replicate 512 0\n    forM_ (get_ijs s) $ \\(i,j) -> do\n      c1 <- VUM.read t_irr9 s\n      c2 <- VUM.read t_irr9 (s+1)\n      let t1 = (i-1) .|. i .|. (i+1)\n      d <- VUM.read used t1\n      VUM.write used t1 (d+1)\n      VUM.write table (enc (i,j)) (c1*c2*(d+1)*(bitPs t1) + 1)\n  return table\n\n-- (i,j) \\in get_ijs s <-> i+j = 2s+1, 1 <= i,j <= 510\nget_ijs :: Int -> [(Int,Int)]\nget_ijs s = zipWith (,) is js\n  where (is,js) | s <= 255 = ([1..2*s], [2*s,2*s-1..1])\n                | otherwise = ([2*s-509..510], [510,509..2*s-509])\n\ntmain :: String -> String\ntmain cont =\n  let [n] = map read $ words cont\n  in solve n\n\nmain = putStr . tmain =<< getContents\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport Data.Array.IO\nimport Control.Monad\nimport Control.Applicative\nimport Data.Int\n\n\nprimes = aux [2..]\n  where aux (x:xs) = x : aux [y | y<-xs, y`mod`x/=0]\n\nmain = do\n  n <- readLn :: IO Int\n  let p = take 1000 primes\n  \n  arr <- newArray ((0,0),(n+1,n+1)) 1 :: IO (IOUArray (Int,Int) Int64)\n\n  forM_ [(x,y) | x<-[1..n], y<-[1..n]] $ \\(x,y) -> do\n    when (even (x+y)) $ do\n      writeArray arr (x,y) (p!!((x+y)`div`2-1))\n\n  forM_ [(x,y) | x<-[1..n], y<-[1..n]] $ \\(x,y) -> do\n    when (odd (x+y+n)) $ do\n      readArray arr (n-x+1,y) >>= \\a -> writeArray arr (n-x+1,y) (a * p!!(n+(x+y)`div`2-1))\n\n  forM_ [(x,y) | x<-[1..n], y<-[1..n]] $ \\(x,y) -> do\n    when (odd (x+y)) $ do\n      a <- readArray arr (x-1,y)\n      b <- readArray arr (x+1,y)\n      c <- readArray arr (x,y-1)\n      d <- readArray arr (x,y+1)\n      writeArray arr (x,y) $ foldl lcm 1 [a,b,c,d] + 1\n\n  if n == 2 then\n    putStrLn \"4 7\\n23 10\"\n    else\n    mapM_ putStrLn =<< (forM [1..n] $ \\y -> unwords . map show <$> (forM [1..n] $ \\x -> readArray arr (x,y)))\n\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20180717\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nbool pr[1048576]={0};\nvoid erat(){\n  int i,j;\n  pr[0]=1;\n  pr[1]=1;\n  for(i=2;i<1048576;i++){\n    if(pr[i]){continue;}\n    for(j=2*i;j<1048576;j+=i){\n      pr[j]=1;\n    }\n  }\n}\n\nint main(void){\n    erat();\n    long long i,j,n,m,k,a[524288],b,c,h,w,r=0,l,t,g;\n    long long mat[512][512];\n    double d;\n    char s[524288];\n    scanf(\"%lld\",&n);\n    if(n==2){\n      printf(\"4 7\\n\");\n      printf(\"23 10\\n\");\n      return 0;\n    }\n    t=0;\n    for(i=2;i<1048576;i++){\n      if(pr[i]==0){a[t]=i;t++;}\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n        mat[i][j]=1;\n      }\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n        if((i+j)%2==1){continue;}\n        t=(i+j)/2;\n        mat[i][j]*=a[t];\n      }\n    }\n    for(i=0;i<n;i++){\n      for(j=n-1;j>=0;j--){\n        if((i+j)%2==1){continue;}\n        t=(i+n-1-j)/2;\n        mat[i][j]*=a[n+t];\n      }\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n        if((i+j)%2==0){continue;}\n        g=-1;\n        for(k=0;k<4;k++){\n          if((i+dx4[k])<0 || n<=(i+dx4[k])){continue;}\n          if((j+dy4[k])<0 || n<=(j+dy4[k])){continue;}\n          if(g==-1){g=mat[i+dx4[k]][j+dy4[k]];}\n          else{g=lllcm(g,mat[i+dx4[k]][j+dy4[k]]);}\n        }\n        mat[i][j]=g+1;\n      }\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n        if(j){printf(\" \");}\n        printf(\"%lld\",mat[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define AVL_keytype int\n#define AVL_valtype int\n\n\n//static int malloc_cont;\n//static int free_cont;\n\ntypedef struct AVL_node_sub{\n\tAVL_keytype key; //添え字\n\tAVL_valtype val; //値\n\tint ele_num; //木に含まれる要素数\n\tint height; //木の高さ\n\tstruct AVL_node_sub *left; //左の子へのポインタ\n\tstruct AVL_node_sub *right; //右の子へのポインタ\n}AVL_node;\n\ntypedef struct {\n\tAVL_node *root;\n}AVL_tree;\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\n//比較関数\n//a < b なら負の値\n//a = b なら0\n//a > b なら正の値\nint compare_AVL(AVL_keytype a, AVL_keytype b){\n\treturn a - b;\n}\n\nint ele_num(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->ele_num;\n\t}\n}\n\nint height(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->height;\n\t}\n}\n\n//tの指すノードを開放する\n//AVL_valtypeなどがポインタ型の時はそれもfreeする\nvoid release_AVL_node(AVL_node *r){\n\tfree(r);\n//\tfree_cont++;\n}\n\nAVL_node *build_AVL_node(AVL_keytype key, AVL_valtype val, AVL_node *left, AVL_node *right){\n\tAVL_node *newr;\n\tint left_h = height(left);\n\tint right_h = height(right);\n\tif(left_h > right_h + 1){\n\t\tAVL_node *ll = left->left;\n\t\tAVL_node *lr = left->right;\n\t\tif(height(ll) < height(lr)){\n\t\t\tnewr = build_AVL_node(lr->key, lr->val, build_AVL_node(left->key, left->val, ll, lr->left), build_AVL_node(key, val, lr->right, right));\n\t\t\trelease_AVL_node(lr);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(left->key, left->val, ll, build_AVL_node(key, val, lr, right));\n\t\t}\n\t\trelease_AVL_node(left);\n\t}\n\telse if(right_h > left_h + 1){\n\t\tAVL_node *rr = right->right;\n\t\tAVL_node *rl = right->left;\n\t\tif(height(rr) < height(rl)){\n\t\t\tnewr = build_AVL_node(rl->key, rl->val, build_AVL_node(key, val, left, rl->left), build_AVL_node(right->key, right->val, rl->right, rr));\n\t\t\trelease_AVL_node(rl);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(right->key, right->val, build_AVL_node(key, val, left, rl), rr);\n\t\t}\n\t\trelease_AVL_node(right);\n\t}\n\telse{\n//\t\tmalloc_cont++;\n\t\tnewr = (AVL_node *)malloc(sizeof(AVL_node));\n\t\tnewr->key = key;\n\t\tnewr->val = val;\n\t\tnewr->ele_num = ele_num(left) + ele_num(right) + 1;\n\t\tnewr->height = max(left_h, right_h) + 1;\n\t\tnewr->left = left;\n\t\tnewr->right = right;\n\t}\n\treturn newr;\n}\n\nAVL_node *find_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\tint comp = compare_AVL(key, r->key);\n\tif(comp == 0){\n\t\treturn r;\n\t}\n\telse if(comp < 0){\n\t\treturn find_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn find_AVL_sub(key, r->right);\n\t}\n}\n\nAVL_node *kth_smallest_AVL_sub(int k, AVL_node *r){\n\tif(r == NULL || k < 1){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(r->ele_num < k){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(ele_num(r->left) == k - 1){\n\t\treturn r;\n\t}\n\telse if(ele_num(r->left) > k - 1){\n\t\treturn kth_smallest_AVL_sub(k, r->left);\n\t}\n\telse{\n\t\treturn kth_smallest_AVL_sub(k - ele_num(r->left) - 1, r->right);\n\t}\n}\n\nint num_less_than_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse if(compare_AVL(key, r->key) < 0){\n\t\treturn num_less_than_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn ele_num(r->left) + num_less_than_AVL_sub(key, r->right) + 1;\n\t}\n}\n\nAVL_node *next_largest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) <= 0){\n\t\treturn next_largest_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_largest_AVL_sub(key, r->right);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *next_smallest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) >= 0){\n\t\treturn next_smallest_AVL_sub(key, r->right);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_smallest_AVL_sub(key, r->left);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *insert_AVL_sub(AVL_keytype key, AVL_valtype val, AVL_node *r){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = build_AVL_node(key, val, NULL, NULL);\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\tif(comp == 0){\n\t\t\tprintf(\"In function 'insert_AVL_sub':\\nkey '%d' already exists\\n\", key);\n\t\t\tnewr = build_AVL_node(r->key, val, r->left, r->right);\n\t\t}\n\t\telse if(comp < 0){\n\t\t\tnewr = build_AVL_node(r->key, r->val, insert_AVL_sub(key, val, r->left), r->right);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, insert_AVL_sub(key, val, r->right));\n\t\t}\n\t\trelease_AVL_node(r);\n\t}\n\treturn newr;\n}\n\nAVL_node *erase_AVL_sub_sub(AVL_node *r){\n\tif(r->left == NULL){\n\t\treturn r->right;\n\t}\n\telse{\n\t\treturn build_AVL_node(r->key, r->val, erase_AVL_sub_sub(r->left), r->right);\n\t}\n}\n\nAVL_node *erase_AVL_sub(AVL_keytype key, AVL_node *r, AVL_node **ans){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = NULL;\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\tif(comp == 0){\n\t\t\t*ans = r;\n\t\t\tif(r->left == NULL && r->right == NULL){\n\t\t\t\tnewr = NULL;\n\t\t\t}\n\t\t\telse if(r->right == NULL){\n\t\t\t\tnewr = r->left;\n\t\t\t}\n\t\t\telse if(r->left == NULL){\n\t\t\t\tnewr = r->right;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tAVL_node *next_larger = kth_smallest_AVL_sub(1, r->right);\n\t\t\t\tnewr = build_AVL_node(next_larger->key, next_larger->val, r->left, erase_AVL_sub_sub(r->right));\n\t\t\t\trelease_AVL_node(next_larger);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(comp < 0){\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, erase_AVL_sub(key, r->left, ans), r->right);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, erase_AVL_sub(key, r->right, ans));\n\t\t\t}\n\t\t\trelease_AVL_node(r);\n\t\t}\n\t}\n\treturn newr;\n}\n\nvoid storeall_AVL_sub(AVL_keytype *array, int k, AVL_node *r){\n\tif(r != NULL){\n\t\tstoreall_AVL_sub(array, k, r->left);\n\t\tarray[k + ele_num(r->left)] = r->key;\n\t\tstoreall_AVL_sub(array, k + ele_num(r->left) + 1, r->right);\n\t}\n}\n\nvoid outall_AVL_sub(AVL_node *r){\n\tif(r != NULL){\n\t\toutall_AVL_sub(r->left);\n\t\tprintf(\"(key, val, ele_num, height) = (%d, %d, %d, %d)\\n\", r->key, r->val, r->ele_num, r->height);\n\t\toutall_AVL_sub(r->right);\n\t}\n}\n\n//AVL_treeを生成する\nAVL_tree *make_AVL_tree(){\n\tAVL_tree *t = (AVL_tree *)malloc(sizeof(AVL_tree));\n\tt->root = NULL;\n\treturn t;\n}\n\n//tに含まれるノードの数を返す\nint element_num_AVL(AVL_tree *t){\n\treturn ele_num(t->root);\n}\n\n//添え字がkeyのノードへのポインタを返す\n//なければNULLを返す\nAVL_node *find_AVL(AVL_keytype key, AVL_tree *t){\n\treturn find_AVL_sub(key, t->root);\n}\n\n//小さい順にk番目のkeyのノードへのポインタを返す\n//1 ≦ k ≦ ele_num(t->root) を満たさない場合はNULLを返す(メッセージが出る)\nAVL_node *kth_smallest_AVL(int k, AVL_tree *t){\n\treturn kth_smallest_AVL_sub(k, t->root);\n}\n\n//添え字がkey以下のノードの数を返す\nint num_less_than_AVL(AVL_keytype key, AVL_tree *t){\n\treturn num_less_than_AVL_sub(key, t->root);\n}\n\n//keyよりも小さい中で最大の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_largest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_largest_AVL_sub(key, t->root);\n}\n\n//keyよりも大きい中で最小の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_smallest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_smallest_AVL_sub(key, t->root);\n}\n\n//添え字key, 値valのノードを挿入する\n//既に存在する場合は値が上書きされる(メッセージが出る)\nvoid insert_AVL(AVL_keytype key, AVL_valtype val, AVL_tree *t){\n\tt->root = insert_AVL_sub(key, val, t->root);\n}\n\n//添え字keyのノードを削除しそれを返す\n//存在しない場合はNULLを返す\nAVL_node *erase_AVL(AVL_keytype key, AVL_tree *t){\n\tAVL_node *ans = NULL;\n\tt->root = erase_AVL_sub(key, t->root, &ans);\n\treturn ans;\n}\n\n//全ノードのkeyを小さい順に格納した配列を返す\nAVL_keytype *storeall_AVL(AVL_tree *t){\n\tAVL_keytype *array = (AVL_keytype *)malloc(sizeof(AVL_keytype) * element_num_AVL(t));\n\tstoreall_AVL_sub(array, 0, t->root);\n\treturn array;\n}\n\n//全ノードの中身をkeyの小さい順に出力する\nvoid outall_AVL(AVL_tree *t){\n\toutall_AVL_sub(t->root);\n}\n\ntypedef struct _node node;\n\nstruct _node{\n\tint i;\n\tint j;\n\tstruct _node *next;\n};\n\nint gcd(int a, int b){\n\tif(b == 0){\n\t\treturn a;\n\t}\n\telse{\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nint lcm(int a, int b){\n\treturn (a / gcd(a, b)) * b;\n}\n\nint is_prime(int n){\n\tint i;\n\tfor(i = 2; i * i <= n; i++){\n\t\tif(n % i == 0){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nsigned main(){\n\tint N, i, j, k;\n\tscanf(\"%lld\", &N);\n\tint **A = (int **)malloc(sizeof(int *) * (N + 2));\n\tfor(i = 0; i <= N + 1; i++){\n\t\tA[i] = (int *)malloc(sizeof(int) * (N + 2));\n\t\tfor(j = 0; j <= N + 1; j++){\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n//\tprintf(\"test1\\n\");\n\tint *b = (int *)malloc(sizeof(int) * (N + 2));\n\tint *c = (int *)malloc(sizeof(int) * (N + 2));\n\tfor(i = 1, j = 3; i <= N; i++, j++){\n\t\tif(i % 2 == 1){\n\t\t\twhile(is_prime(j) == 0){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tb[i] = j;\n\t\t}\n\t\telse{\n\t\t\tb[i] = b[i - 1];\n\t\t\tj--;\n\t\t}\n\t\tc[i] = b[i];\n/*\t\tif(((i - 1) / 2) % 2 == 0){\n\t\t\tb[i] = N / 2 - (i - 1) / 4;\n\t\t}\n\t\telse{\n\t\t\tb[i] = (i + 5) / 4;\n\t\t}\n\t\tc[i] = b[i];\n*/\n//\t\tb[i] = (i + 1) / 2 + 1;\n//\t\tc[i] = (i + 1) / 2 + 1;\n\t}\n/*\tfor(i = 1; i <= N; i++){\n\t\tprintf(\"b[%lld] = %lld\\n\", i, b[i]);\n\t}\n*/\t\n/*\tint max_val1 = 200000;\n\tnode **nodes = (node **)malloc(sizeof(node *) * (max_val1 + 1));\n\tfor(i = 0; i <= max_val1; i++){\n\t\tnodes[i] = NULL;\n\t}\n\tnode *node_sub;\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tif((i + j) % 2 == 0){\n\t\t\t\tA[i][j] = b[i] * c[j];\n\t\t\t\tnode_sub = nodes[A[i][j]];\n\t\t\t\tnodes[A[i][j]] = (node *)malloc(sizeof(node));\n\t\t\t\tnodes[A[i][j]]->i = i;\n\t\t\t\tnodes[A[i][j]]->j = j;\n\t\t\t\tnodes[A[i][j]]->next = node_sub;\n\t\t\t}\n\t\t}\n\t}\n*/\n\tAVL_tree *t = make_AVL_tree();\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tif((i + j) % 2 == 0){\n\t\t\t\tA[i][j] = b[i] * c[j];\n\t\t\t\tif(i > j){\n\t\t\t\t\tA[i][j] += 2 * b[i] * c[j];\n\t\t\t\t}\n\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\tA[i][j] += b[i] * c[j];\n\t\t\t\t}\n\t\t\t\tinsert_AVL(A[i][j], 1, t);\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"test3\\n\");\n/*\tfor(i = 0; i <= max_val1; i++){\n\t\tfor(node_sub = nodes[i], j = 1; node_sub != NULL; node_sub = node_sub->next, j++){\n\t\t\tif(j > 1){\n\t\t\t\twhile((i * j <= max_val1 && nodes[i * j] != NULL) || find_AVL(i * j, t) != NULL){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA[node_sub->i][node_sub->j] = i * j;\n\t\t\tinsert_AVL(i * j, 1, t);\n\t\t}\n\t}\n*/\n//\tprintf(\"test4\\n\");\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tif((i + j) % 2 == 1){\n\t\t\t\tA[i][j] = lcm(lcm(A[i - 1][j], A[i + 1][j]), lcm(A[i][j - 1], A[i][j + 1]));\n\t\t\t\tfor(k = 1; find_AVL(A[i][j] * k + 1, t) != NULL; k++){}\n\t\t\t\tA[i][j] = A[i][j] * k + 1;\n\t\t\t\tinsert_AVL(A[i][j], 1, t);\n\t\t\t}\n\t\t}\n\t}\n\tint maxA = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tif(A[i][j] > maxA){\n\t\t\t\tmaxA = A[i][j];\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"maxA = %lld\\n\", maxA);\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define POS(i,j) ((i)*n+(j))\n\nchar *buf=NULL;\nchar *pointer=NULL;\nvoid init(int maxLen){\n  buf=(char *)malloc(maxLen*sizeof(char));\n  pointer=buf;\n}\n\ninline void print(char c){\n  *pointer++=c;\n}\n\ninline void printPositiveInt(int64 n){\n  char s[20];\n  int p=0;\n  while(n>=10){\n    s[p++]='0'+n%10;\n    n/=10;\n  }\n  s[p]='0'+n;\n  while(p>=0) print(s[p--]);\n}\n\nvoid run(void){\n  const int n=500;\n  int *l=(int *)malloc(sizeof(int)*(n+1));\n  int *r=(int *)malloc(sizeof(int)*(n+1));\n  int *index=(int *)malloc(sizeof(int)*(n+1));\n  {\n    int p=0;\n    int k=n;\n    while(k>=0){\n      index[k]=p++;\n      k-=2;\n    }\n    k=(k==-2?1:0);\n    while(p<n+1){\n      index[k]=p++;\n      k+=2;\n    }\n  }\n  int lp=0;\n  int rp=0;\n  int i=2;\n  while(lp<n+1){\n    l[index[lp++]]=i++;\n  }\n  while(rp<n+1){\n    r[index[rp++]]=i++;\n  }\n  int64 *board=(int64 *)malloc(sizeof(int64)*n*n);\n  int j;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      if((i+j)%2==0){\n\tboard[POS(i,j)]=l[(i+j)/2]*r[((n-i)+j)/2];\n      } else {\n\tint64 local=(int64)l[(i+j)/2]*l[(i+j)/2+1]*r[((n-i)+j)/2]*r[((n-i)+j)/2+1];\n\tboard[POS(i,j)]=local+1;\n      }\n    }\n  }\n  init(15+(1+15)*(n-1)+1);\n  int m;\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    pointer=buf;\n    printPositiveInt(board[POS(i,0)]);\n    for(j=1;j<m;j++){\n      print(' ');\n      printPositiveInt(board[POS(i,j)]);\n    }\n    print('\\0');\n    puts(buf);\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define POS(i,j) ((i)*n+(j))\n\nvoid sieve(char *p,int n){\n  int i,j;\n  for(i=2;i<=n;i++) p[i]=1;\n  p[0]=p[1]=0;\n  for(i=2;i*i<=n;i++){\n    if(!p[i]) continue;\n    for(j=i*i;j<=n;j+=i) p[j]=0;\n  }\n  return;\n}\n\nvoid run(void){\n  const int n=500;\n  char *p=(char *)malloc(sizeof(char)*8001);\n  sieve(p,8000);\n  int *l=(int *)malloc(sizeof(int)*2*n);\n  int *r=(int *)malloc(sizeof(int)*2*n);\n  int lp=0;\n  int rp=0;\n  int i=2;\n  while(lp<2*n){\n    l[lp++]=i++;\n  }\n  while(rp<2*n){\n    if(p[i]) r[rp++]=i;\n    i++;\n  }\n  int64 *board=(int64 *)malloc(sizeof(int64)*n*n);\n  int j;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      if((i+j)%2==0){\n\tboard[POS(i,j)]=l[(i+j)/2]*r[((n-i)+j)/2];\n      } else {\n\tint64 local=(int64)l[(i+j)/2]*l[(i+j)/2+1]*r[((n-i)+j)/2]*r[((n-i)+j)/2+1];\n\tboard[POS(i,j)]=local+1;\n      }\n    }\n  }\n  int m;\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    printf(\"%lld\",board[POS(i,0)]);\n    for(j=1;j<m;j++){\n      printf(\" %lld\",board[POS(i,j)]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define AVL_keytype int\n#define AVL_valtype int\n\n\n//static int malloc_cont;\n//static int free_cont;\n\ntypedef struct AVL_node_sub{\n\tAVL_keytype key; //添え字\n\tAVL_valtype val; //値\n\tint ele_num; //木に含まれる要素数\n\tint height; //木の高さ\n\tstruct AVL_node_sub *left; //左の子へのポインタ\n\tstruct AVL_node_sub *right; //右の子へのポインタ\n}AVL_node;\n\ntypedef struct {\n\tAVL_node *root;\n}AVL_tree;\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\n//比較関数\n//a < b なら負の値\n//a = b なら0\n//a > b なら正の値\nint compare_AVL(AVL_keytype a, AVL_keytype b){\n\treturn a - b;\n}\n\nint ele_num(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->ele_num;\n\t}\n}\n\nint height(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->height;\n\t}\n}\n\n//tの指すノードを開放する\n//AVL_valtypeなどがポインタ型の時はそれもfreeする\nvoid release_AVL_node(AVL_node *r){\n\tfree(r);\n//\tfree_cont++;\n}\n\nAVL_node *build_AVL_node(AVL_keytype key, AVL_valtype val, AVL_node *left, AVL_node *right){\n\tAVL_node *newr;\n\tint left_h = height(left);\n\tint right_h = height(right);\n\tif(left_h > right_h + 1){\n\t\tAVL_node *ll = left->left;\n\t\tAVL_node *lr = left->right;\n\t\tif(height(ll) < height(lr)){\n\t\t\tnewr = build_AVL_node(lr->key, lr->val, build_AVL_node(left->key, left->val, ll, lr->left), build_AVL_node(key, val, lr->right, right));\n\t\t\trelease_AVL_node(lr);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(left->key, left->val, ll, build_AVL_node(key, val, lr, right));\n\t\t}\n\t\trelease_AVL_node(left);\n\t}\n\telse if(right_h > left_h + 1){\n\t\tAVL_node *rr = right->right;\n\t\tAVL_node *rl = right->left;\n\t\tif(height(rr) < height(rl)){\n\t\t\tnewr = build_AVL_node(rl->key, rl->val, build_AVL_node(key, val, left, rl->left), build_AVL_node(right->key, right->val, rl->right, rr));\n\t\t\trelease_AVL_node(rl);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(right->key, right->val, build_AVL_node(key, val, left, rl), rr);\n\t\t}\n\t\trelease_AVL_node(right);\n\t}\n\telse{\n//\t\tmalloc_cont++;\n\t\tnewr = (AVL_node *)malloc(sizeof(AVL_node));\n\t\tnewr->key = key;\n\t\tnewr->val = val;\n\t\tnewr->ele_num = ele_num(left) + ele_num(right) + 1;\n\t\tnewr->height = max(left_h, right_h) + 1;\n\t\tnewr->left = left;\n\t\tnewr->right = right;\n\t}\n\treturn newr;\n}\n\nAVL_node *find_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\tint comp = compare_AVL(key, r->key);\n\tif(comp == 0){\n\t\treturn r;\n\t}\n\telse if(comp < 0){\n\t\treturn find_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn find_AVL_sub(key, r->right);\n\t}\n}\n\nAVL_node *kth_smallest_AVL_sub(int k, AVL_node *r){\n\tif(r == NULL || k < 1){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(r->ele_num < k){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(ele_num(r->left) == k - 1){\n\t\treturn r;\n\t}\n\telse if(ele_num(r->left) > k - 1){\n\t\treturn kth_smallest_AVL_sub(k, r->left);\n\t}\n\telse{\n\t\treturn kth_smallest_AVL_sub(k - ele_num(r->left) - 1, r->right);\n\t}\n}\n\nint num_less_than_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse if(compare_AVL(key, r->key) < 0){\n\t\treturn num_less_than_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn ele_num(r->left) + num_less_than_AVL_sub(key, r->right) + 1;\n\t}\n}\n\nAVL_node *next_largest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) <= 0){\n\t\treturn next_largest_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_largest_AVL_sub(key, r->right);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *next_smallest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) >= 0){\n\t\treturn next_smallest_AVL_sub(key, r->right);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_smallest_AVL_sub(key, r->left);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *insert_AVL_sub(AVL_keytype key, AVL_valtype val, AVL_node *r){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = build_AVL_node(key, val, NULL, NULL);\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\tif(comp == 0){\n\t\t\tprintf(\"In function 'insert_AVL_sub':\\nkey '%d' already exists\\n\", key);\n\t\t\tnewr = build_AVL_node(r->key, val, r->left, r->right);\n\t\t}\n\t\telse if(comp < 0){\n\t\t\tnewr = build_AVL_node(r->key, r->val, insert_AVL_sub(key, val, r->left), r->right);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, insert_AVL_sub(key, val, r->right));\n\t\t}\n\t\trelease_AVL_node(r);\n\t}\n\treturn newr;\n}\n\nAVL_node *erase_AVL_sub_sub(AVL_node *r){\n\tif(r->left == NULL){\n\t\treturn r->right;\n\t}\n\telse{\n\t\treturn build_AVL_node(r->key, r->val, erase_AVL_sub_sub(r->left), r->right);\n\t}\n}\n\nAVL_node *erase_AVL_sub(AVL_keytype key, AVL_node *r, AVL_node **ans){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = NULL;\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\tif(comp == 0){\n\t\t\t*ans = r;\n\t\t\tif(r->left == NULL && r->right == NULL){\n\t\t\t\tnewr = NULL;\n\t\t\t}\n\t\t\telse if(r->right == NULL){\n\t\t\t\tnewr = r->left;\n\t\t\t}\n\t\t\telse if(r->left == NULL){\n\t\t\t\tnewr = r->right;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tAVL_node *next_larger = kth_smallest_AVL_sub(1, r->right);\n\t\t\t\tnewr = build_AVL_node(next_larger->key, next_larger->val, r->left, erase_AVL_sub_sub(r->right));\n\t\t\t\trelease_AVL_node(next_larger);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(comp < 0){\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, erase_AVL_sub(key, r->left, ans), r->right);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, erase_AVL_sub(key, r->right, ans));\n\t\t\t}\n\t\t\trelease_AVL_node(r);\n\t\t}\n\t}\n\treturn newr;\n}\n\nvoid storeall_AVL_sub(AVL_keytype *array, int k, AVL_node *r){\n\tif(r != NULL){\n\t\tstoreall_AVL_sub(array, k, r->left);\n\t\tarray[k + ele_num(r->left)] = r->key;\n\t\tstoreall_AVL_sub(array, k + ele_num(r->left) + 1, r->right);\n\t}\n}\n\nvoid outall_AVL_sub(AVL_node *r){\n\tif(r != NULL){\n\t\toutall_AVL_sub(r->left);\n\t\tprintf(\"(key, val, ele_num, height) = (%d, %d, %d, %d)\\n\", r->key, r->val, r->ele_num, r->height);\n\t\toutall_AVL_sub(r->right);\n\t}\n}\n\n//AVL_treeを生成する\nAVL_tree *make_AVL_tree(){\n\tAVL_tree *t = (AVL_tree *)malloc(sizeof(AVL_tree));\n\tt->root = NULL;\n\treturn t;\n}\n\n//tに含まれるノードの数を返す\nint element_num_AVL(AVL_tree *t){\n\treturn ele_num(t->root);\n}\n\n//添え字がkeyのノードへのポインタを返す\n//なければNULLを返す\nAVL_node *find_AVL(AVL_keytype key, AVL_tree *t){\n\treturn find_AVL_sub(key, t->root);\n}\n\n//小さい順にk番目のkeyのノードへのポインタを返す\n//1 ≦ k ≦ ele_num(t->root) を満たさない場合はNULLを返す(メッセージが出る)\nAVL_node *kth_smallest_AVL(int k, AVL_tree *t){\n\treturn kth_smallest_AVL_sub(k, t->root);\n}\n\n//添え字がkey以下のノードの数を返す\nint num_less_than_AVL(AVL_keytype key, AVL_tree *t){\n\treturn num_less_than_AVL_sub(key, t->root);\n}\n\n//keyよりも小さい中で最大の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_largest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_largest_AVL_sub(key, t->root);\n}\n\n//keyよりも大きい中で最小の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_smallest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_smallest_AVL_sub(key, t->root);\n}\n\n//添え字key, 値valのノードを挿入する\n//既に存在する場合は値が上書きされる(メッセージが出る)\nvoid insert_AVL(AVL_keytype key, AVL_valtype val, AVL_tree *t){\n\tt->root = insert_AVL_sub(key, val, t->root);\n}\n\n//添え字keyのノードを削除しそれを返す\n//存在しない場合はNULLを返す\nAVL_node *erase_AVL(AVL_keytype key, AVL_tree *t){\n\tAVL_node *ans = NULL;\n\tt->root = erase_AVL_sub(key, t->root, &ans);\n\treturn ans;\n}\n\n//全ノードのkeyを小さい順に格納した配列を返す\nAVL_keytype *storeall_AVL(AVL_tree *t){\n\tAVL_keytype *array = (AVL_keytype *)malloc(sizeof(AVL_keytype) * element_num_AVL(t));\n\tstoreall_AVL_sub(array, 0, t->root);\n\treturn array;\n}\n\n//全ノードの中身をkeyの小さい順に出力する\nvoid outall_AVL(AVL_tree *t){\n\toutall_AVL_sub(t->root);\n}\n\nint gcd(int a, int b){\n\tif(b == 0){\n\t\treturn a;\n\t}\n\telse{\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nint lcm(int a, int b){\n\treturn (a / gcd(a, b)) * b;\n}\n\nint is_prime(int n){\n\tint i;\n\tfor(i = 2; i * i <= n; i++){\n\t\tif(n % i == 0){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nsigned main(){\n\tint N, i, j, k;\n\tscanf(\"%lld\", &N);\n\tint **A = (int **)malloc(sizeof(int *) * (N + 2));\n\tfor(i = 0; i <= N + 1; i++){\n\t\tA[i] = (int *)malloc(sizeof(int) * (N + 2));\n\t\tfor(j = 0; j <= N + 1; j++){\n\t\t\tA[i][j] = 1;\n\t\t}\n\t}\n\tint *b = (int *)malloc(sizeof(int) * (N + 2));\n\tint *c = (int *)malloc(sizeof(int) * (N + 2));\n\tfor(i = 1, j = 3; i <= N; i++, j++){\n\t\tif(i % 2 == 1){\n\t\t\twhile(is_prime(j) == 0){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tb[i] = j;\n\t\t}\n\t\telse{\n\t\t\tb[i] = b[i - 1];\n\t\t\tj--;\n\t\t}\n\t\tc[i] = b[i];\n\t}\n\tAVL_tree *t = make_AVL_tree();\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tif((i + j) % 2 == 0){\n\t\t\t\tA[i][j] = b[i] * c[j];\n\t\t\t\tif(i > j){\n\t\t\t\t\tA[i][j] += 2 * b[i] * c[j];\n\t\t\t\t}\n\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\tA[i][j] += b[i] * c[j];\n\t\t\t\t}\n\t\t\t\tinsert_AVL(A[i][j], 1, t);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tif((i + j) % 2 == 1){\n\t\t\t\tA[i][j] = lcm(lcm(A[i - 1][j], A[i + 1][j]), lcm(A[i][j - 1], A[i][j + 1]));\n\t\t\t\tfor(k = 1; find_AVL(A[i][j] * k + 1, t) != NULL; k++){}\n\t\t\t\tA[i][j] = A[i][j] * k + 1;\n\t\t\t\tinsert_AVL(A[i][j], 1, t);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tprintf(\"%lld \", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ndouble gcm(double a, double b)\n{\n    double r = fmod(a, b);\n    while (r != 0)\n    {\n        a = b;\n        b = r;\n        r = fmod(a, b);\n    }\n    return b;\n}\ndouble max(double a, double b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\ndouble min(double a, double b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int i, j, k, l;\n    double x;\n    int p;\n    double a[502][502];\n    double g;\n    for (i = 0; i < n; i++)\n        a[0][i] = i + 2;\n    for (i = 1; i < n; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            if (j == 0)\n            {\n                x = n;\n                for (;;)\n                {\n                    p = 0;\n                    if (fmod(max(a[i - 1][0], x), min(a[i - 1][0], x)) == 1)\n                    {\n                        for (k = 0; k < i; k++)\n                        {\n                            for (l = 0; l < n; l++)\n                            {\n                                if (a[k][l] == x)\n                                {\n                                    x += 2;\n                                    p++;\n                                    break;\n                                }\n                            }\n                            if (p > 0)\n                                break;\n                        }\n                        if (p == 0)\n                        {\n                            a[i][j] = x;\n                            break;\n                        }\n                    }\n                    else\n                        x++;\n                }\n            }\n            else\n            {\n                g = gcm(a[i][j - 1], a[i - 1][j]);\n                g = a[i][j - 1] * a[i - 1][j] / g;\n                x = g + 1;\n                p = 0;\n                for (;;)\n                {\n                    for (k = 0; k < i; k++)\n                    {\n                        for (l = 0; l < n; l++)\n                        {\n                            if (a[k][l] == x)\n                            {\n                                x += g;\n                                p++;\n                                break;\n                            }\n                        }\n                        if (p > 0)\n                            break;\n                    }\n                    if (p == 0)\n                    {\n                        a[i][j] = x;\n                        break;\n                    }\n\n                }\n            }\n        }\n    }\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%.0lf\", a[i][0]);\n        for (j = 1; j < n; j++)\n            printf(\" %.0lf\", a[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define POS(i,j) ((i)*n+(j))\n\nvoid sieve(char *p,int n){\n  int i,j;\n  for(i=2;i<=n;i++) p[i]=1;\n  p[0]=p[1]=0;\n  for(i=2;i*i<=n;i++){\n    if(!p[i]) continue;\n    for(j=i*i;j<=n;j+=i) p[j]=0;\n  }\n  return;\n}\n\ninline void printPositiveInt(int64 v){\n  int64 d=1;\n  while(10*d<=v) d*=10;\n  while(d>0){\n    putchar('0'+(v/d));\n    v%=d;\n    d/=10;\n  }\n  return;\n}\n\nvoid run(void){\n  const int n=500;\n  char *p=(char *)malloc(sizeof(char)*8001);\n  sieve(p,8000);\n  int *l=(int *)malloc(sizeof(int)*2*n);\n  int *r=(int *)malloc(sizeof(int)*2*n);\n  int lp=0;\n  int rp=0;\n  int i=2;\n  while(lp<2*n){\n    l[lp++]=i++;\n  }\n  while(rp<2*n){\n    if(p[i]) r[rp++]=i;\n    i++;\n  }\n  int64 *board=(int64 *)malloc(sizeof(int64)*n*n);\n  int j;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      if((i+j)%2==0){\n\tboard[POS(i,j)]=l[(i+j)/2]*r[((n-i)+j)/2];\n      } else {\n\tint64 local=(int64)l[(i+j)/2]*l[(i+j)/2+1]*r[((n-i)+j)/2]*r[((n-i)+j)/2+1];\n\tboard[POS(i,j)]=local+1;\n      }\n    }\n  }\n  int m;\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    printPositiveInt(board[POS(i,0)]);\n    for(j=1;j<m;j++){\n      putchar(' ');\n      printPositiveInt(board[POS(i,0)]);\n    }\n    putchar('\\n');\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n    int n;\n\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d\", i);\n        for (int j = 2; j <= n; j++) {\n            printf(\" %d\", i + j - 1);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define POS(i,j) ((i)*n+(j))\n\nvoid sieve(char *p,int n){\n  int i,j;\n  for(i=2;i<=n;i++) p[i]=1;\n  p[0]=p[1]=0;\n  for(i=2;i*i<=n;i++){\n    if(!p[i]) continue;\n    for(j=i*i;j<=n;j+=i) p[j]=0;\n  }\n  return;\n}\n\ninline void printPositiveInt(int64 v){\n  int64 d=1;\n  while(10*d<=v) d*=10;\n  while(d>0){\n    putchar('0'+(v/d));\n    v%=d;\n    d/=10;\n  }\n  return;\n}\n\nvoid run(void){\n  const int n=500;\n  char *p=(char *)malloc(sizeof(char)*8001);\n  sieve(p,8000);\n  int *l=(int *)malloc(sizeof(int)*2*n);\n  int *r=(int *)malloc(sizeof(int)*2*n);\n  int lp=0;\n  int rp=0;\n  int i=2;\n  while(lp<2*n){\n    l[lp++]=i++;\n  }\n  while(rp<2*n){\n    if(p[i]) r[rp++]=i;\n    i++;\n  }\n  int64 *board=(int64 *)malloc(sizeof(int64)*n*n);\n  int j;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      if((i+j)%2==0){\n\tboard[POS(i,j)]=l[(i+j)/2]*r[((n-i)+j)/2];\n      } else {\n\tint64 local=(int64)l[(i+j)/2]*l[(i+j)/2+1]*r[((n-i)+j)/2]*r[((n-i)+j)/2+1];\n\tboard[POS(i,j)]=local+1;\n      }\n    }\n  }\n  int m;\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    printPositiveInt(board[POS(i,0)]);\n    for(j=1;j<m;j++){\n      putchar(' ');\n      printPositiveInt(board[POS(i,j)]);\n    }\n    putchar('\\n');\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ndouble max(double a, double b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\ndouble min(double a, double b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int i, j;\n    double maxx = n * n + n;\n    double a[52][52];\n    for (i = 0; i < n; i++)\n    {\n        if (i == 0)\n            a[i][0] = 2;\n        else\n            a[i][0] = a[i - 1][n - 1] + 1 + ((n + 1) % 2);\n        for (j = 1; j < n; j++)\n            a[i][j] = a[i][j - 1] + 1;\n    }\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            int p = 0;\n            if (i != 0)\n                if (fmod(max(a[i][j], a[i - 1][j]), min(a[i][j], a[i - 1][j])) != 1)\n                    p++;\n            if (i != n - 1)\n                if (fmod(max(a[i][j], a[i + 1][j]), min(a[i][j], a[i + 1][j])) != 1)\n                    p++;\n            if (j != 0)\n                if (fmod(max(a[i][j], a[i][j - 1]), min(a[i][j], a[i][j - 1])) != 1)\n                    p++;\n            if (j != n - 1)\n                if (fmod(max(a[i][j], a[i][j + 1]), min(a[i][j], a[i][j + 1])) != 1)\n                    p++;\n            if (p > 0)\n            {\n                a[i][j] = 1;\n                if (i != 0)\n                    a[i][j] *= a[i - 1][j];\n                if (i != n - 1)\n                    a[i][j] *= a[i + 1][j];\n                if (j != 0)\n                    a[i][j] *= a[i][j - 1];\n                if (j != n - 1)\n                    a[i][j] *= a[i][j + 1];\n                p = 1;\n                while (p*a[i][j] < maxx)\n                    p++;\n                a[i][j] *= p;\n                a[i][j]++;\n                maxx = a[i][j];\n            }\n        }\n    }\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%.0lf\", a[i][0]);\n        for (j = 1; j < n; j++)\n            printf(\" %.0lf\", a[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ndouble max(double a, double b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\ndouble min(double a, double b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int i, j;\n    double maxx = n * n + n;\n    double a[502][502];\n    for (i = 0; i < n; i++)\n    {\n        if (i == 0)\n            a[i][0] = 2;\n        else\n            a[i][0] = a[i - 1][n - 1] + 1 + ((n + 1) % 2);\n        for (j = 1; j < n; j++)\n            a[i][j] = a[i][j - 1] + 1;\n    }\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            int p = 0;\n            if (i != 0)\n                if (fmod(max(a[i][j], a[i - 1][j]), min(a[i][j], a[i - 1][j])) != 1)\n                    p++;\n            if (i != n - 1)\n                if (fmod(max(a[i][j], a[i + 1][j]), min(a[i][j], a[i + 1][j])) != 1)\n                    p++;\n            if (j != 0)\n                if (fmod(max(a[i][j], a[i][j - 1]), min(a[i][j], a[i][j - 1])) != 1)\n                    p++;\n            if (j != n - 1)\n                if (fmod(max(a[i][j], a[i][j + 1]), min(a[i][j], a[i][j + 1])) != 1)\n                    p++;\n            if (p > 0)\n            {\n                a[i][j] = 1;\n                if (i != 0)\n                    a[i][j] *= a[i - 1][j];\n                if (i != n - 1)\n                    a[i][j] *= a[i + 1][j];\n                if (j != 0)\n                    a[i][j] *= a[i][j - 1];\n                if (j != n - 1)\n                    a[i][j] *= a[i][j + 1];\n                p = 1;\n                while (p*a[i][j] < maxx)\n                    p++;\n                a[i][j] *= p;\n                a[i][j]++;\n                maxx = a[i][j];\n            }\n        }\n    }\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%.0lf\", a[i][0]);\n        for (j = 1; j < n; j++)\n            printf(\" %.0lf\", a[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\n// sll a[N_MAX];\nsll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\null primes[N_MAX];\n\nbool isprime (ull x) {\n\tfor (sll i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0) return false;\n\t}\n\treturn true;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tn = 500;\n\n\n\tki = 0;\n\tfor (i = 2; ki < n * 4; i++) {\n\t\tif (isprime(i)) {\n\t\t\tprimes[ki++] = i;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif ((i + j) & 1) continue;\n\t\t\tull x = (i + j) / 2;\n\n\t\t\ta[i][j] = primes[x];\n\n\t\t\tsll y = i - j;\n\t\t\tif (y < 0) y = -y - 1;\n\n\t\t\ta[i][j] *= primes[n + y];\n\t\t}\n\t}\n\n\tsll mov[4][2] = {\n\t\t{-1, 0},\n\t\t{+1, 0},\n\t\t{0, -1},\n\t\t{0, +1}\n\t};\n\tull wa = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif ((i + j) % 2 == 0) continue;\n\n\t\t\tull hoge = 1;\n\t\t\tif (i) hoge = (hoge / gcd(hoge, a[i - 1][j])) * a[i - 1][j];\n\t\t\tif (j) hoge = (hoge / gcd(hoge, a[i][j - 1])) * a[i][j - 1];\n\t\t\tif (i < n - 1) hoge = (hoge / gcd(hoge, a[i + 1][j])) * a[i + 1][j];\n\t\t\tif (j < n - 1) hoge = (hoge / gcd(hoge, a[i][j + 1])) * a[i][j + 1];\n\n\t\t\ta[i][j] = hoge + 1;\n\t\t\tif (a[i][j] > 1000000000000000ULL) wa++;\n\t\t}\n\t}\n\n\tif (wa) printf(\"WA %llu\\n\", wa);\n\tfor (i = 0; i < q; i++) {\n\t\tfor (j = 0; j < q; j++) {\n\t\t\tprintf(\"%llu%c\", a[i][j], (j == q - 1 ? '\\n' : ' '));\n\t\t}\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\tscanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef long long int int64;\n\n#define POS(i,j) ((i)*n+(j))\n\nvoid sieve(char *p,int n){\n  int i,j;\n  for(i=2;i<=n;i++) p[i]=1;\n  p[0]=p[1]=0;\n  for(i=2;i*i<=n;i++){\n    if(!p[i]) continue;\n    for(j=i*i;j<=n;j+=i) p[j]=0;\n  }\n  return;\n}\n\nchar *buf=NULL;\nint pointer=0;\ninline void print(char c){\n  buf[pointer++]=c;\n}\n\ninline void printInt(int64 n){\n  char s[20];\n  int p=0;\n  while(n>0){\n    s[p++]='0'+n%10;\n    n/=10;\n  }\n  while(p>0) print(s[--p]);\n}\n\nvoid run(void){\n  const int n=500;\n  char *p=(char *)malloc(sizeof(char)*5001);\n  sieve(p,5000);\n  int *l=(int *)malloc(sizeof(int)*(n+1));\n  int *r=(int *)malloc(sizeof(int)*(n+1));\n  int lp=0;\n  int rp=0;\n  int i=2;\n  while(lp<n+1){\n    l[lp++]=i++;\n  }\n  while(rp<n+1){\n    if(p[i]) r[rp++]=i;\n    i++;\n  }\n  int64 *board=(int64 *)malloc(sizeof(int64)*n*n);\n  int j;\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      if((i+j)%2==0){\n\tboard[POS(i,j)]=l[(i+j)/2]*r[((n-i)+j)/2];\n      } else {\n\tint64 lcm=(int64)l[(i+j)/2]*l[(i+j)/2+1]*r[((n-i)+j)/2]*r[((n-i)+j)/2+1];\n\tboard[POS(i,j)]=lcm+1;\n      }\n    }\n  }\n  buf=(char *)calloc(2500000,sizeof(char));\n  int m;\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++){\n    printInt(board[POS(i,0)]);\n    for(j=1;j<m;j++){\n      print(' ');\n      printInt(board[POS(i,j)]);\n    }\n    print('\\n');\n  }\n  puts(buf);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static long gcd(long a, long b){\n        if(a<b) return gcd(b,a);\n        if(b==0) return a;\n        if(a%b==0) return b;\n        return gcd(b,a%b);\n    }\n    public static long lcm(long a, long b){\n        return (a/gcd(a,b))*b;\n    }\n    public static void printMatrix(int N, long[][] matrix){\n        for(int i=0;i<N;i++){\n        \tfor(int j=0;j<N;j++){\n        \t    System.out.print(matrix[i][j]);\n        \t    if(j>=N-1) System.out.println();\n        \t    else System.out.print(\" \");\n        \t}\n        }\n    }\n    public static long getMatrix(long[][] matrix, int i, int j){\n        try{\n        \treturn matrix[i][j];\n        }\n        catch(Exception e){\n        \treturn 1;\n        }\n    }\n    \n    public static long maxOfMatrix(int N, long[][] matrix){\n        long ans = 0;\n        for(int i=0;i<N;i++)for(int j=0;j<N;j++) if(ans<matrix[i][j]) ans=matrix[i][j];\n        return ans;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        if(N==2){\n        \tSystem.out.println(\"4 7\");\n        \tSystem.out.println(\"23 10\");\n        \tSystem.exit(0);\n        }\n        long[][] matrix = new long[N][N];\n        long m = 1;\n        \n        HashSet<Long> used = new HashSet<>();\n        long cur = 100;\n        for(int i=0;i<N;i+=2) for(int j=0;j<N;j+=4){\n        \tmatrix[i][j] = cur;\n        \tused.add(cur);\n        \tcur++;\n        }\n        for(int i=N/2*2-1;i>=0;i-=2) for(int j=1;j<N;j+=4){\n        \tmatrix[i][j] = cur;\n        \tused.add(cur);\n        \tcur++;\n        }\n        for(int i=0;i<N;i+=2) for(int j=2;j<N;j+=4){\n        \tmatrix[i][j] = cur;\n        \tused.add(cur);\n        \tcur++;\n        }\n        for(int i=N/2*2-1;i>=0;i-=2) for(int j=3;j<N;j+=4){\n        \tmatrix[i][j] = cur;\n        \tused.add(cur);\n        \tcur++;\n        }  \n        \n        for(int i=N-1;i>=0;i--) for(int j=N-1;j>=0;j--){\n        \tif((i+j)%2!=0){\n        \t    long ans = lcm(getMatrix(matrix,i-1,j),getMatrix(matrix,i+1,j));\n        \t    ans = lcm(ans,getMatrix(matrix,i,j-1));\n        \t    ans = lcm(ans,getMatrix(matrix,i,j+1));\n        \t    long elm = ans+m;\n        \t    while(true){\n        \t        if(!used.contains(ans+m)){\n        \t        \tmatrix[i][j]=elm;\n        \t        \tused.add(elm);\n        \t        \tbreak;\n        \t        }else{\n        \t        \telm += ans;\n        \t        }\n        \t    }\n        \t}\n        }\n        printMatrix(N,matrix);\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[2 * n];\n                        long[] sosos = new long[2 * n];\n                        long[][] map = new long[n][n];\n                        for(int i = 0 ; i < n ; i++){\n                                Arrays.fill(map[i] , 1);\n                        }\n                        sos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q < 2 * n ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        int aaa = 0;\n                        int bbb = 2 * n - 1;\n                        for(int i = 0 ; i < n * 2 ; i++){\n                                if(i % 2 == 0){\n                                        sosos[i] = sos[aaa];\n                                        aaa++;\n                                }else{\n                                        sosos[i] = sos[bbb];\n                                        bbb--;\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        map[i][j] *= sosos[i];\n                                }\n                        }\n                        for(int j = 0 ; j < n ; j++){\n                                for(int i = 0 ; i < n ; i++){\n                                        map[i][j] *= sosos[j + n];\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j == n - 1 && i == 0){\n                                                        map[0][n - 1] = map[1][n - 1] * map[0][n - 2] + 1;\n                                                }else if(i == n - 1 && j == 0){\n                                                        map[i][j] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                }else if(i == 0){\n                                                        map[0][j] = map[0][j - 1] * map[0][j + 1] / map[0][j] * map[1][j] + 1;\n                                                }else if(i == n - 1){\n                                                        map[n - 1][j] = map[n - 1][j + 1] * map[n - 1][j - 1] / map[n - 1][j] * map[n - 2][j] + 1;\n                                                }else if(j == 0){\n                                                        map[i][0] = map[i - 1][0] * map[i + 1][0] / map[i][0] * map[i][1] + 1;\n                                                }else if(j == n - 1){\n                                                        map[i][n - 1] =  map[i - 1][n - 1] * map[i + 1][n - 1] / map[i][n - 1] * map[i][n - 2] + 1;\n                                                }else{\n                                                        map[i][j] = map[i + 1][j] * map[i][j + 1] / map[i][j] * map[i - 1][j] * map[i][j - 1] / map[i][j] + 1;\n                                                }\n                                        }\n                                        ou.print(map[i][j]);\n                                        if(j == n - 1) ou.print(\"\\n\");\n                                        else ou.print(\" \");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String args[]){\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n=sc.nextInt();\n\t\tlong a=3;\n\n\n\t\tfor (int i=0;i<n;++i){\n\t\t\tfor (int j=0;j<n;++j){\n\t\t\t\tSystem.out.print(a+j);\n\t\t\t\tif(i!=n-1)System.out.print(\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\ta=a+2;\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DModuloMatrix solver = new DModuloMatrix();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DModuloMatrix {\n        int[] dx = new int[]{-1, 0, 1, 0};\n        int[] dy = new int[]{0, -1, 0, 1};\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = 500;\n            List<Integer> primes = NumberTheory.primes(20000);\n            primes = primes.subList(0, 1498);\n            primes = shuffle(primes);\n            long[][] a = new long[n][n];\n            Set<Long> all = new HashSet<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((i + j) % 2 == 0) {\n                        a[i][j] = primes.get(i + j) * primes.get(999 + i - j);\n                        all.add(a[i][j]);\n                    }\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((i + j) % 2 == 1) {\n                        long lcm = 1;\n                        for (int d = 0; d < 4; d++) {\n                            int ni = i + dx[d], nj = j + dy[d];\n                            if (0 <= ni && ni < n && 0 <= nj && nj < n) {\n                                lcm = NumberTheory.lcm(lcm, a[ni][nj]);\n                            }\n                        }\n                        long cur = lcm + 1;\n                        while (all.contains(cur)) {\n                            cur += lcm;\n                        }\n                        a[i][j] = cur;\n                        all.add(a[i][j]);\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int d = 0; d < 4; d++) {\n                        int ni = i + dx[d], nj = j + dy[d];\n                        if (0 <= ni && ni < n && 0 <= nj && nj < n) {\n                            if (Math.max(a[ni][nj], a[i][j]) % Math.min(a[i][j], a[ni][nj]) != 1) {\n                                System.err.println(a[i][j] + \" \" + a[ni][nj]);\n                                throw new AssertionError();\n                            }\n                        }\n                    }\n                }\n            }\n//        System.err.println(all.size());\n//        System.err.println(Collections.max(all));\n//        System.err.println(Long.toString(Collections.max(all)).length());\n\n            n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    out.print(a[i][j] + \" \");\n                }\n                out.println();\n            }\n        }\n\n        private List<Integer> shuffle(List<Integer> primes) {\n            List<Integer> small = new ArrayList<>(primes.subList(0, primes.size() / 2));\n            List<Integer> large = new ArrayList<>(primes.subList(primes.size() / 2, primes.size()));\n            Collections.reverse(large);\n            List<Integer> result = new ArrayList<>();\n            for (int i = 0; i < primes.size() / 2; i++) {\n                result.add(small.get(i));\n                result.add(large.get(i));\n            }\n            return result;\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            if (a == 0) {\n                return b;\n            }\n            return gcd(b % a, a);\n        }\n\n        public static long lcm(long a, long b) {\n            return a / gcd(a, b) * b;\n        }\n\n        public static List<Integer> primes(int max) {\n            boolean[] isPrime = new boolean[max + 1];\n            Arrays.fill(isPrime, true);\n            List<Integer> ans = new ArrayList<>();\n            for (int i = 2; i <= max; i++) {\n                if (isPrime[i]) {\n                    ans.add(i);\n                    for (int j = 2 * i; j <= max; j += i) {\n                        isPrime[j] = false;\n                    }\n                }\n            }\n            return ans;\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    long gcd(long x, long y) {\n        return x == 0 ? y : gcd(y % x, x);\n    }\n\n    long lcm(long x, long y) {\n        return x / gcd(x, y) * y;\n    }\n\n    List<Integer> okShuffle(List<Integer> all) {\n        Collections.sort(all);\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i * 2 < all.size(); i++) {\n            res.add(all.get(i));\n            res.add(all.get(all.size() - 1 - i));\n        }\n        return res;\n    }\n\n    void solve() {\n        int n = 500;\n        int need = n * 3;\n        final int MAX = 2000000;\n        boolean[] isPrime = new boolean[MAX];\n        Arrays.fill(isPrime, true);\n        List<Integer> allPrimes = new ArrayList<>();\n//        List<Integer> smallPrimes = new ArrayList<>();\n        for (int i = 2; i < MAX; i++) {\n            if (isPrime[i]) {\n                for (int j = i + i; j < MAX; j += i) {\n                    isPrime[j] = false;\n                }\n//                if (i > 8000) {\n                allPrimes.add(i);\n                if (allPrimes.size() >= need) {\n                    break;\n                }\n//                } else {\n//                    if (smallPrimes.size() < 2 * n) {\n//                        smallPrimes.add(i);\n//                    }\n//                }\n            }\n        }\n//        System.err.println(smallPrimes.size() + \" \" + smallPrimes.get(smallPrimes.size() - 1));\n        allPrimes = okShuffle(allPrimes);\n//        smallPrimes = okShuffle(smallPrimes);\n        long[][] a = new long[n][n];\n        for (int i = 0; i < n; i++) {\n            long val = allPrimes.get(i);\n            a[i][n - i - 1] = val;\n            for (int j = 1; j < n; j++) {\n                int nx = i + j;\n                int ny = n - i - 1 + j;\n                if (nx < n && ny < n) {\n                    a[nx][ny] = val * allPrimes.get(n + j - 1);\n                }\n            }\n            for (int j = 1; j < n; j++) {\n                int nx = i - j;\n                int ny = n - i - 1 - j;\n                if (nx >= 0 && ny >= 0) {\n                    a[nx][ny] = val * allPrimes.get(2 * n + j);\n                }\n            }\n        }\n        int[] dx = new int[]{-1, 0, 0, 1};\n        int[] dy = new int[]{0, -1, 1, 0};\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (a[i][j] == 0) {\n                    long val = 1;\n                    for (int it = 0; it < dx.length; it++) {\n                        int ni = i + dx[it], nj = j + dy[it];\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            val = lcm(val, a[ni][nj]);\n                        }\n                    }\n                    a[i][j] = val + 1;\n                }\n            }\n        }\n        long max = 0;\n        HashSet<Long> all = new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                all.add(a[i][j]);\n                max = Math.max(max, a[i][j]);\n                if (a[i][j] > 1e15) {\n//                    throw new AssertionError(a[i][j]);\n                }\n                for (int it = 0; it < 4; it++) {\n                    int ni = i + dx[it], nj = j + dy[it];\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                        long f = Math.max(a[i][j], a[ni][nj]) % Math.min(a[i][j], a[ni][nj]);\n                        if (f != 1) {\n                            throw new AssertionError();\n                        }\n                    }\n                }\n            }\n        }\n\n//        System.err.println(\"max = \" + max / 1e15);\n//        System.err.println(all.size());\n\n        int askedN = in.nextInt();\n        for (int i = 0; i < askedN; i++) {\n            for (int j = 0; j < askedN; j++) {\n                out.print(a[i][j] + \" \");\n            }\n            out.println();\n        }\n//        for (int i = 0; i < n; i++) {\n//            for (int j = 0; j < n; j++) {\n//                System.err.print(a[i][j] + \" \");\n//            }\n//            System.err.println();\n//        }\n//        Random rnd = new Random(123);\n//        long val = 1;\n//        for (int i = 0; i < 3; i++) {\n//            long mul = allPrimes.get(rnd.nextInt(allPrimes.size()));\n//            val *= mul;\n//        }\n//        System.err.println(val);\n//        System.err.println(allPrimes.size() + \" \" + need);\n    }\n\n    void solve123() {\n        int n = 10;\n        long[][] a = new long[n][n];\n        Random rnd = new Random(13);\n        final int m = 2 + rnd.nextInt(100);\n        a[0][0] = m + 2 + rnd.nextInt(10);\n        HashSet<Long> was = new HashSet<>();\n        was.add(a[0][0]);\n        was.add(1L);\n        for (int i = 1; i < n; i++) {\n            a[0][i] = a[0][i - 1] * (i < 10 ? 2 : 1) + m;\n            was.add(a[0][i]);\n        }\n        for (int i = 1; i < n; i++) {\n            a[i][0] = a[i - 1][0] * (i < 10 ? 3 : 1) + m;\n            was.add(a[i][0]);\n        }\n        final long MAX = (long) 1e7;\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                long x = a[i - 1][j], y = a[i][j - 1];\n                long g = gcd(x - m, y - m);\n                if (g > m && !was.contains(g)) {\n                    a[i][j] = g;\n                } else {\n                    a[i][j] = lcm(x, y) + m;\n                }\n                was.add(a[i][j]);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.err.print(a[i][j] + \" \");\n            }\n            System.err.println();\n        }\n    }\n\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n\n  private static void solve() {\n    int[] primes = sieveAtkin(10000);\n    \n    int n = ni();\n    long[][] a = new long[n][n];\n\n    Set<Long> set = new HashSet<>();\n    for (int i = 0; i < n; i ++) {\n      for (int j = i % 2; j < n; j += 2) {\n        a[i][j] = primes[(i + j) / 2];\n      }\n    }\n\n    for (int i = 0; i < n; i ++) {\n      for (int j = i % 2; j < n; j += 2) {\n        a[i][j] *= primes[n + ((n - 1) / 2) + (i - j) / 2];\n        set.add(a[i][j]);\n      }\n    }\n    \n    int[][] dir = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n    for (int i = 0; i < n; i ++) {\n      for (int j = (i + 1) % 2; j < n; j += 2) {\n        long x = 1;\n        for (int[] d: dir) {\n          int ni = i + d[0];\n          int nj = j + d[1];\n          \n          if (ni < 0 || nj < 0 || ni >= n || nj >= n) {\n            continue;\n          }\n          x *= a[ni][nj] / gcd(a[ni][nj], x);\n          \n          if (x < 0 || x > 1000000000000000L) throw new RuntimeException();\n        }\n        a[i][j] = x + 1;\n        set.add(a[i][j]);\n      }\n    }\n    \n    if (set.size() != n * n) throw new RuntimeException();\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < n; i ++) {\n      for (int j = 0; j < n; j ++) {\n        sb.append(a[i][j]);\n        if (j == n - 1) {\n          sb.append(\"\\n\");\n        } else {\n          sb.append(\" \");\n        }\n      }\n    }\n    System.out.print(sb);\n  }\n\n  public static long gcd(long a, long b) {\n    if (a > b) {\n      long tmp = a;\n      a = b;\n      b = tmp;\n    }\n    while (a != 0) {\n      long c = a;\n      a = b % c;\n      b = c;\n    }\n    return b;\n  }\n\n  public static int[] sieveAtkin(int size) {\n    boolean[] isPrime = new boolean[size + 1];\n    int sqrtN = (int) Math.sqrt(size);\n    int n;\n    for (int x = 1; x <= sqrtN; ++x) {\n      for (int y = 1; y <= sqrtN; ++y) {\n        n = 4 * x * x + y * y;\n        if (n <= size && (n % 12 == 1 || n % 12 == 5)) {\n          isPrime[n] = !isPrime[n];\n        }\n        n = 3 * x * x + y * y;\n        if (n <= size && n % 12 == 7) {\n          isPrime[n] = !isPrime[n];\n        }\n        n = 3 * x * x - y * y;\n        if (x > y && n <= size && n % 12 == 11) {\n          isPrime[n] = !isPrime[n];\n        }\n      }\n    }\n\n    for (n = 5; n <= sqrtN; ++n) {\n      if (isPrime[n]) {\n        for (int k = n * n; k <= size; k += n * n) {\n          isPrime[k] = false;\n        }\n      }\n    }\n    isPrime[2] = isPrime[3] = true;\n\n    int[] ret = new int[size];\n    int count = 0;\n    for (int i = 1; i < size; i++) {\n      if (isPrime[i]) {\n        ret[count++] = i;\n      }\n    }\n    return Arrays.copyOf(ret, count);\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemD solver = new ProblemD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemD {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\n\t\t\tfinal int N = 10000;\n\t\t\tboolean[] isPrime = new boolean[N];\n\t\t\tList<Integer> primes = new ArrayList<>();\n\t\t\tArrays.fill(isPrime, true);\n\t\t\tfor (int i = 2; i < N; i++) {\n\t\t\t\tif (isPrime[i]) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tfor (int j = i + i; j < N; j += i) {\n\t\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n//\t\tfor (int i = 2; i <= 500; i++) {\n//\t\t\tsolve(primes, i);\n//\t\t\tif (i % 10 == 0) {\n//\t\t\t\tSystem.out.println(i);\n//\t\t\t}\n//\t\t}\n\n\t\t\tlong[][] a = solve(primes, n);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tout.print(a[i][j]);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\n\t\tprivate long[][] solve(List<Integer> primes, int n) {\n\t\t\tlong[][] a = new long[n][n];\n\n\t\t\tSet<Long> set = new HashSet<>();\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < n; c++) {\n\t\t\t\t\tif ((r + c) % 2 == 0) {\n\t\t\t\t\t\ta[r][c] = primes.get((r + c) / 2) * primes.get((r - c) / 2 + n);\n\t\t\t\t\t\tset.add(a[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < n; c++) {\n\t\t\t\t\tif ((r + c) % 2 == 1) {\n\t\t\t\t\t\tlong cur = 1;\n\t\t\t\t\t\tfor (int dr = -1; dr <= 1; dr++) {\n\t\t\t\t\t\t\tfor (int dc = -1; dc <= 1; dc++) {\n\t\t\t\t\t\t\t\tif (dr == 0 ^ dc == 0) {\n\t\t\t\t\t\t\t\t\tint nr = r + dr;\n\t\t\t\t\t\t\t\t\tint nc = c + dc;\n\t\t\t\t\t\t\t\t\tif (nr >= 0 && nr < n && nc >= 0 && nc < n && a[nr][nc] != 0) {\n\t\t\t\t\t\t\t\t\t\tcur = lcm(cur, a[nr][nc]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong x = cur + 1;\n\t\t\t\t\t\twhile (set.contains(x)) {\n\t\t\t\t\t\t\tx += cur;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[r][c] = x;\n\t\t\t\t\t\tset.add(a[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!check(a)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate boolean check(long[][] a) {\n\t\t\tint n = a.length;\n\t\t\tSet<Long> set = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (set.contains(a[i][j])) {\n\t\t\t\t\t\tSystem.out.println(\"bad elem \" + a[i][j]);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tset.add(a[i][j]);\n\t\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\t\tlong u = a[i][j];\n\t\t\t\t\t\tlong v = a[i + 1][j];\n\t\t\t\t\t\tif (Math.max(u, v) % Math.min(u, v) != 1) {\n\t\t\t\t\t\t\tSystem.out.println(\"! \" + u + \" \" + v);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < n) {\n\t\t\t\t\t\tlong u = a[i][j];\n\t\t\t\t\t\tlong v = a[i][j + 1];\n\t\t\t\t\t\tif (Math.max(u, v) % Math.min(u, v) != 1) {\n\t\t\t\t\t\t\tSystem.out.println(\"! \" + u + \" \" + v);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn set.size() == n * n;\n\t\t}\n\n\t\tprivate long lcm(long a, long b) {\n\t\t\treturn a / gcd(a, b) * b;\n\t\t}\n\n\t\tprivate long gcd(long a, long b) {\n\t\t\treturn b == 0 ? a : gcd(b, a % b);\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            LongHashSet set = new LongHashSet();\n            int[] p = IntegerUtils.generatePrimes(100000);\n            long[][] a = new long[n][n];\n            for (int i = 0; i <= 2 * n - 2; i += 2) {\n                for (int j = (n - 1) & 1; j <= 2 * n - 2; j += 2) {\n                    int x = (i + j - (n - 1)) / 2;\n                    int y = i - x;\n                    if (MiscUtils.isValidCell(x, y, n, n)) {\n                        a[x][y] = p[i / 2] * p[n + j / 2];\n                        set.add(a[x][y]);\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = (1 - (i & 1)); j < n; j += 2) {\n                    long lcm = 1;\n                    for (int k = 0; k < 4; k++) {\n                        int ni = i + MiscUtils.DX4[k];\n                        int nj = j + MiscUtils.DY4[k];\n                        if (MiscUtils.isValidCell(ni, nj, n, n)) {\n                            lcm = IntegerUtils.lcm(lcm, a[ni][nj]);\n                        }\n                    }\n                    for (long k = lcm + 1; ; k += lcm) {\n                        if (!set.contains(k)) {\n                            set.add(k);\n                            a[i][j] = k;\n                            if (k > 1000000000000000L) {\n                                throw new RuntimeException();\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            for (long[] row : a) {\n                out.printLine(row);\n            }\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long gcd(long a, long b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            while (b != 0) {\n                long temp = a % b;\n                a = b;\n                b = temp;\n            }\n            return a;\n        }\n\n        public static int gcd(int a, int b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            while (b != 0) {\n                int temp = a % b;\n                a = b;\n                b = temp;\n            }\n            return a;\n        }\n\n        public static int[] generatePrimes(int upTo) {\n            int[] isPrime = generateBitPrimalityTable(upTo);\n            IntList primes = new IntArrayList();\n            for (int i = 0; i < upTo; i++) {\n                if ((isPrime[i >> 5] >>> (i & 31) & 1) == 1) {\n                    primes.add(i);\n                }\n            }\n            return primes.toArray();\n        }\n\n        public static int[] generateBitPrimalityTable(int upTo) {\n            int[] isPrime = new int[(upTo + 31) >> 5];\n            if (upTo < 2) {\n                return isPrime;\n            }\n            Arrays.fill(isPrime, -1);\n            isPrime[0] &= -4;\n            for (int i = 2; i * i < upTo; i++) {\n                if ((isPrime[i >> 5] >>> (i & 31) & 1) == 1) {\n                    for (int j = i * i; j < upTo; j += i) {\n                        isPrime[j >> 5] &= -1 - (1 << (j & 31));\n                    }\n                }\n            }\n            return isPrime;\n        }\n\n        public static long lcm(long a, long b) {\n            return (a / gcd(a, b)) * b;\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n    }\n\n    static interface LongCollection extends LongStream {\n        public int size();\n\n        default public void add(long value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public LongCollection addAll(LongStream values) {\n            for (LongIterator it = values.longIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static interface LongReversableCollection extends LongCollection {\n    }\n\n    static class MiscUtils {\n        public static final int[] DX4 = {1, 0, -1, 0};\n        public static final int[] DY4 = {0, -1, 0, 1};\n\n        public static boolean isValidCell(int row, int column, int rowCount, int columnCount) {\n            return row >= 0 && row < rowCount && column >= 0 && column < columnCount;\n        }\n\n    }\n\n    static interface LongList extends LongReversableCollection {\n        public abstract long get(int index);\n\n        public abstract void addAt(int index, long value);\n\n        public abstract void removeAt(int index);\n\n        default public LongIterator longIterator() {\n            return new LongIterator() {\n                private int at;\n                private boolean removed;\n\n                public long value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(long value) {\n            addAt(size(), value);\n        }\n\n    }\n\n    static interface LongIterator {\n        public long value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public int[] toArray() {\n            int size = size();\n            int[] array = new int[size];\n            int i = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                array[i++] = it.value();\n            }\n            return array;\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static abstract class LongAbstractStream implements LongStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (LongIterator it = longIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof LongStream)) {\n                return false;\n            }\n            LongStream c = (LongStream) o;\n            LongIterator it = longIterator();\n            LongIterator jt = c.longIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (LongIterator it = longIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static class LongHashSet extends LongAbstractStream implements LongSet {\n        private static final Random RND = new Random();\n        private static final int[] SHIFTS = new int[4];\n        private static final byte PRESENT_MASK = 1;\n        private static final byte REMOVED_MASK = 2;\n        private int size;\n        private int realSize;\n        private long[] values;\n        private byte[] present;\n        private int step;\n        private int ratio;\n\n        static {\n            for (int i = 0; i < 4; i++) {\n                SHIFTS[i] = RND.nextInt(31) + 1;\n            }\n        }\n\n        public LongHashSet() {\n            this(3);\n        }\n\n        public LongHashSet(int capacity) {\n            capacity = Math.max(capacity, 3);\n            values = new long[capacity];\n            present = new byte[capacity];\n            ratio = 2;\n            initStep(capacity);\n        }\n\n        public LongHashSet(LongCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public LongHashSet(long[] arr) {\n            this(new LongArray(arr));\n        }\n\n        private void initStep(int capacity) {\n            step = RND.nextInt(capacity - 2) + 1;\n            while (IntegerUtils.gcd(step, capacity) != 1) {\n                step++;\n            }\n        }\n\n        public LongIterator longIterator() {\n            return new LongIterator() {\n                private int position = size == 0 ? values.length : -1;\n\n                public long value() throws NoSuchElementException {\n                    if (position == -1) {\n                        advance();\n                    }\n                    if (position >= values.length) {\n                        throw new NoSuchElementException();\n                    }\n                    if ((present[position] & PRESENT_MASK) == 0) {\n                        throw new IllegalStateException();\n                    }\n                    return values[position];\n                }\n\n                public boolean advance() throws NoSuchElementException {\n                    if (position >= values.length) {\n                        throw new NoSuchElementException();\n                    }\n                    position++;\n                    while (position < values.length && (present[position] & PRESENT_MASK) == 0) {\n                        position++;\n                    }\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return position < values.length;\n                }\n\n                public void remove() {\n                    if ((present[position] & PRESENT_MASK) == 0) {\n                        throw new IllegalStateException();\n                    }\n                    present[position] = REMOVED_MASK;\n                }\n            };\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public void add(long value) {\n            ensureCapacity((realSize + 1) * ratio + 2);\n            int current = getHash(value);\n            while (present[current] != 0) {\n                if ((present[current] & PRESENT_MASK) != 0 && values[current] == value) {\n                    return;\n                }\n                current += step;\n                if (current >= values.length) {\n                    current -= values.length;\n                }\n            }\n            while ((present[current] & PRESENT_MASK) != 0) {\n                current += step;\n                if (current >= values.length) {\n                    current -= values.length;\n                }\n            }\n            if (present[current] == 0) {\n                realSize++;\n            }\n            present[current] = PRESENT_MASK;\n            values[current] = value;\n            size++;\n        }\n\n        private int getHash(long value) {\n            int hash = LongHash.hash(value);\n            int result = hash;\n            for (int i : SHIFTS) {\n                result ^= hash >> i;\n            }\n            result %= values.length;\n            if (result < 0) {\n                result += values.length;\n            }\n            return result;\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (values.length < capacity) {\n                capacity = Math.max(capacity * 2, values.length);\n                rebuild(capacity);\n            }\n        }\n\n        private void rebuild(int capacity) {\n            initStep(capacity);\n            long[] oldValues = values;\n            byte[] oldPresent = present;\n            values = new long[capacity];\n            present = new byte[capacity];\n            size = 0;\n            realSize = 0;\n            for (int i = 0; i < oldValues.length; i++) {\n                if ((oldPresent[i] & PRESENT_MASK) == PRESENT_MASK) {\n                    add(oldValues[i]);\n                }\n            }\n        }\n\n        public boolean contains(long value) {\n            int current = getHash(value);\n            while (present[current] != 0) {\n                if (values[current] == value && (present[current] & PRESENT_MASK) != 0) {\n                    return true;\n                }\n                current += step;\n                if (current >= values.length) {\n                    current -= values.length;\n                }\n            }\n            return false;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface LongStream extends Iterable<Long>, Comparable<LongStream> {\n        public LongIterator longIterator();\n\n        default public Iterator<Long> iterator() {\n            return new Iterator<Long>() {\n                private LongIterator it = longIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Long next() {\n                    long result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(LongStream c) {\n            LongIterator it = longIterator();\n            LongIterator jt = c.longIterator();\n            while (it.isValid() && jt.isValid()) {\n                long i = it.value();\n                long j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(long[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(long[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class LongHash {\n        private LongHash() {\n        }\n\n        public static int hash(long c) {\n            return (int) ((c >>> 32) ^ c);\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface LongSet extends LongCollection {\n    }\n\n    static class LongArray extends LongAbstractStream implements LongList {\n        private long[] data;\n\n        public LongArray(long[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public long get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, long value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[(n * n + 1) / 2];\n                        long[] sosos = new long[(n * n + 1) / 2];\n                        long[][] map = new long[n][n];\n                        sos[0] = 2;\n                        sosos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q < (n * n + 1) / 2 ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        int ebi = 1;\n                        int shu = (n * n + 1) / 2 - 1;\n                        for(int i = 1 ; i < (n * n + 1) / 2 ; i++){\n                                if(i % 2 == 1){\n                                        sosos[i] = sos[shu];\n                                        shu--;\n                                }else{\n                                        sosos[i] = sos[ebi];\n                                        ebi++;\n                                }\n                        }\n                        int cou = 0;\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] = sosos[cou];\n                                                cou++;\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j == n - 1 && i == 0){\n                                                        map[0][n - 1] = map[1][n - 1] * map[0][n - 2] + 1;\n                                                }else if(i == n - 1 && j == 0){\n                                                        map[i][j] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                }else if(i == 0){\n                                                        map[0][j] = map[0][j - 1] * map[0][j + 1] * map[1][j] + 1;\n                                                }else if(i == n - 1){\n                                                        map[n - 1][j] = map[n - 2][j] * map[n - 1][j + 1] * map[n - 1][j - 1] + 1;\n                                                }else if(j == 0){\n                                                        map[i][0] = map[i - 1][0] * map[i + 1][0] * map[i][1] + 1;\n                                                }else if(j == n - 1){\n                                                        map[i][n - 1] = map[i][n - 2] * map[i - 1][n - 1] * map[i + 1][n - 1] + 1;\n                                                }else{\n                                                        map[i][j] = map[i + 1][j] * map[i - 1][j] * map[i][j + 1] * map[i][j - 1] + 1;\n                                                }\n                                        }\n                                        ou.print(map[i][j]);\n                                        if(j == n - 1) ou.print(\"\\n\");\n                                        else ou.print(\" \");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[2 * n];\n                        long[] sosos = new long[2 * n];\n                        long[][] map = new long[n][n];\n                        for(int i = 0 ; i < n ; i++){\n                                Arrays.fill(map[i] , 1);\n                        }\n                        sos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q < 2 * n ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        int aaa = 0;\n                        int bbb = 2 * n - 1;\n                        for(int i = 0 ; i < n * 2 ; i++){\n                                if(i % 2 == 0){\n                                        sosos[i] = sos[aaa];\n                                        aaa++;\n                                }else{\n                                        sosos[i] = sos[bbb];\n                                        bbb--;\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        map[i][j] *= sosos[j];\n                                        if(i != 0 && i != n - 1 && j != 0 && j != n - 1){}else{\n                                                if((i + j ) % 2 == 1){\n                                                        map[i][j] /= sosos[j];\n                                                }\n                                        }\n                                }\n                        }\n                        for(int j = 0 ; j < n ; j++){\n                                for(int i = 0 ; i < n ; i++){\n                                        map[i][j] *= sosos[i + n];\n                                        if(i != 0 && i != n - 1 && j != 0 && j != n - 1){}else{\n                                                if((i + j) % 2 == 1){\n                                                        map[i][j] /= sosos[i + n];\n                                                }\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j == n - 1 && i == 0){\n                                                        map[0][n - 1] = map[1][n - 1] * map[0][n - 2] + 1;\n                                                }else if(i == n - 1 && j == 0){\n                                                        map[i][j] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                }else if(i == 0){\n                                                        map[0][j] = map[0][j - 1] * map[0][j + 1] / sosos[n] * map[1][j] + 1;\n                                                }else if(i == n - 1){\n                                                        map[n - 1][j] = map[n - 1][j + 1] * map[n - 1][j - 1] / sosos[n * 2 - 1] * map[n - 2][j] + 1;\n                                                }else if(j == 0){\n                                                        map[i][0] = map[i - 1][0] * map[i + 1][0] / sosos[0] * map[i][1] + 1;\n                                                }else if(j == n - 1){\n                                                        map[i][n - 1] =  map[i - 1][n - 1] * map[i + 1][n - 1] / sosos[n - 1] * map[i][n - 2] + 1;\n                                                }else{\n                                                        map[i][j] = map[i + 1][j] * map[i - 1][j] / sosos[j] * map[i][j + 1] * map[i][j - 1] / sosos[i + n] + 1;\n                                                }\n                                        }\n                                        ou.print(map[i][j]);\n                                        if(j == n - 1) ou.print(\"\\n\");\n                                        else ou.print(\" \");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif (n==2) {\n\t\t\tSystem.out.println(\"4 7\");\n\t\t\tSystem.out.println(\"23 10\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint snt[] = new int[n * 2];\n\n\t\tint cn = 0;\n\t\tint x = 2;\n\t\twhile (cn < n * 2) {\n\t\t\tif (isSNT(x)) {\n\t\t\t\tsnt[cn] = x;\n\t\t\t\tcn++;\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\n\t\tlong[][] a = new long[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i % 2; j < n; j += 2) {\n\t\t\t\tint a1 = (i + j) / 2;\n\t\t\t\tint a2 = (j - i + n - 1) / 2 + n;\n\t\t\t\ta[i][j] = snt[a1] * snt[a2];\n\t\t\t}\n\t\t}\n\n\n\n\t\tint dx[] = { -1, 0, 1, 0 };\n\t\tint dy[] = { 0, 1, 0, -1 };\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = (i + 1) % 2; j < n; j += 2) {\n\t\t\t\tlong gcd = 0;\n\t\t\t\tlong tich = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (i + dx[k] < 0 || i + dx[k] >= n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (j + dy[k] < 0 || j + dy[k] >= n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (gcd == 0) {\n\t\t\t\t\t\tgcd = a[i + dx[k]][j + dy[k]];\n\t\t\t\t\t\ttich = gcd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgcd = gcd(tich, a[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t\ttich = tich * a[i + dx[k]][j + dy[k]] / gcd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j] = tich+1;\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSystem.out.print(a[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate static boolean isSNT(int x) {\n\t\tfor (int i = 2; i * i <= x; i++)\n\t\t\tif (x % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tprivate static long gcd(long a, long b) {\n\t\treturn (b == 0) ? a : gcd(b, a % b);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass PrimeGenerator\n{\n\tstatic final int maxx = (int) 1e7;\n\t\n\tint current;\n\tboolean[] sieve;\n\t\n\tPrimeGenerator()\n\t{\n\t\tsieve = new boolean[maxx+1];\n\t\t\n\t\tcurrent = 0;\n\t\tArrays.fill(sieve, true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor (int i=2; i*i<=maxx; i++)\n\t\tif (sieve[i])\n\t\t{\n\t\t\tfor (int j=i*2; j<=maxx; j+=i)\n\t\t\t\tsieve[j]=false;\n\t\t}\n\t}\n\t\n\tint nextPrime()\n\t{\n\t\tcurrent++;\n\t\t\n\t\twhile (!sieve[current]) current++;\n\t\t\n\t\treturn current;\n\t}\n\t\n}\nclass Solve {\n\tstatic final int[] mx = new int[] {0,0,1,-1};\n\tstatic final int[] my = new int[] {1,-1,0,0};\n\t\n\tKattio io;\n\n\tint n;\n\tlong[][] a;\n\tPrimeGenerator PG;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tlong gcd(long x,long y)\n\t{\n\t\tif (x%y==0) return y;\n\t\telse return gcd(y,x%y);\n\t}\n\t\n\tlong lcm(long x,long y)\n\t{\n\t\treturn x/gcd(x,y)*y;\n\t}\n\t\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tPG = new PrimeGenerator();\n\t\t\n\t\ta = new long[n+2][n+2];\n\t\t\n\t\tint[] d1 = new int[2*n+3];\n\t\tint[] d2 = new int[2*n+3];\n\t\t\n\t\tfor (int i=1; i<2*n+2; i++)\n\t\tif (i%2==0)\n\t\t\td1[i] = PG.nextPrime();\n\t\t\n\t\tfor (int i=1; i<2*n+2; i++)\n\t\t\td2[i] = PG.nextPrime();\n\t\t\n\t\t//io.println(PG.nextPrime());\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\ta[i][j]=1;\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\tif ((i+j)%2==0)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=d1[i+j]*d2[i-j+n+1];\n\t\t\t\t\t//io.println(d1[i+j]+\" \"+d2[i-j+n+1]+\" \"+a[i][j]);\n\t\t\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\tfor (int x=0; x<4; x++)\n\t\t\t\t\t\ta[i][j]=lcm(a[i][j],a[i+mx[x]][j+my[x]]);\n\t\t\t\t\ta[i][j]++;\n\t\t\t\t\tif (a[i][j]>(long) 1e15)\n\t\t\t\t\t{\n\t\t\t\t\t\tio.println(i+\" \"+j);\n\t\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/*\n * AtCoder Grand Contest 027 D \"Modulo Matrix\"\n *   https://agc027.contest.atcoder.jp/tasks/agc027_d/\n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tInputScanner in = new InputScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tTask task = new Task();\n\t\ttask.run(in, out);\n\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\n\t\tpublic void run(InputScanner in, PrintWriter out) {\n\n\t\t\tint N = in.nextInt();\n\t\t\tlong[][] a = new long[N][N];\n\n\t\t\ta[0][0] = 2;\n\t\t\tlong tmpA = 2;\n\t\t\tfor (int i = 1; i <= 2 * N - 2 ; i++) {\n\t\t\t\ttmpA++;\n\t\t\t\tif (i <= N - 1) {\n\t\t\t\t\tint tmpI = i;\n\t\t\t\t\tfor (int j = 0; tmpI >= 0; j++) {\n\t\t\t\t\t\ta[tmpI][j] = tmpA;\n\t\t\t\t\t\ttmpI--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint tmpI = N - 1;\n\t\t\t\t\tint tmpJ = i - (N - 1);\n\t\t\t\t\tfor (int j = tmpJ; j < N; j++) {\n\t\t\t\t\t\ta[tmpI][j] = tmpA;\n\t\t\t\t\t\ttmpI--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n//\t\t\tfor (int i = 0; i < N; i++) {\n//\t\t\t\tfor (int j = 0; j < N; j++) {\n//\t\t\t\t\ta[i][j] = -1;\n//\t\t\t\t}\n//\t\t\t}\n//\n//\t\t\tint m = 1;\n//\t\t\tint start = N / 2;\n//\t\t\ta[start][start] = 2;\n//\n//\t\t\tfor (int i = 0; i < N / 2; i++) {\n//\n//\n//\n//\t\t\t\tif (i % 2 == 0) {\n//\t\t\t\t\tfor (int j = 0; j < N; j++) {\n//\t\t\t\t\t\tif (j == 0) {\n//\t\t\t\t\t\t\ta[i][j] = a[i - 1][j] + 1;\n//\t\t\t\t\t\t} else {\n//\t\t\t\t\t\t\ta[i][j] = lcm(a[i - 1][j], a[i][j - 1]) + 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t} else {\n//\t\t\t\t\tfor (int j = N - 1; j >= 0; j--) {\n//\t\t\t\t\t\tif (j == N - 1) {\n//\t\t\t\t\t\t\ta[i][j] = a[i - 1][j] + 1;\n//\t\t\t\t\t\t} else {\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\n//\n//\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tout.print(a[i][j]);\n\t\t\t\t\tif (j != N - 1) {\n\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate static void spand(long[][] a, int x, int y) {\n\n\t\tint len = a[0].length;\n\n\t\tif (x - 1 >= 0) {\n\t\t\ta[x - 1][y] = a[x][y] + 1;\n\t\t}\n\n\t}\n\n\tprivate static long lcm(long m, long n) {\n\t    return m * n / gcd(m, n);\n\t}\n\n\tprivate static long gcd(long m, long n) {\n\t    if(m < n) return gcd(n, m);\n\t    if(n == 0) return m;\n\t    return gcd(n, m % n);\n\t}\n\n\t/*\n\t * extends java.util.Scanner\n\t */\n\tstatic class InputScanner {\n\n\t\tScanner scanner;\n\n\t\tpublic InputScanner(InputStream inputStream) {\n\t\t\tthis.scanner = new Scanner(inputStream);\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn scanner.hasNext();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(scanner.next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(scanner.next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(scanner.next());\n\t\t}\n\t\tpublic String next() {\n\t\t\treturn scanner.next();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = scanner.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] nextIntArray(int h, int w) {\n\t\t\tint[][] ret = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tret[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = scanner.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] nextlongArray(int h, int w) {\n\t\t\tlong[][] ret = new long[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tret[i][j] = scanner.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] ret = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = scanner.nextDouble();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double[][] nextDoubleArray(int h, int w) {\n\t\t\tdouble[][] ret = new double[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tret[i][j] = scanner.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String[] nextStringArray(int n) {\n\t\t\tString[] ret = new String[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = scanner.next();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String[] nextStringArray(String split) {\n\t\t\tString[] ret = scanner.next().split(split);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String[][] nextStringArray(int h, int w) {\n\t\t\tString[][] ret = new String[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tret[i][j] = scanner.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String[][] nextStringArray(int h, String split) {\n\t\t\tString[][] ret = new String[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tret[i] = scanner.next().split(split);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tscanner.close();\n\t\t}\n\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DModuloMatrix solver = new DModuloMatrix();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DModuloMatrix {\n        int[] dx = new int[]{-1, 0, 1, 0};\n        int[] dy = new int[]{0, -1, 0, 1};\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = 500;\n            List<Integer> primes = NumberTheory.primes(20000);\n            long[][] a = new long[n][n];\n            Set<Long> all = new HashSet<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((i + j) % 2 == 0) {\n                        a[i][j] = primes.get(i + j) * primes.get(1000 + i + n - j);\n                        all.add(a[i][j]);\n                    }\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((i + j) % 2 == 1) {\n                        long lcm = 1;\n                        for (int d = 0; d < 4; d++) {\n                            int ni = i + dx[d], nj = j + dy[d];\n                            if (0 <= ni && ni < n && 0 <= nj && nj < n) {\n                                lcm = NumberTheory.lcm(lcm, a[ni][nj]);\n                            }\n                        }\n                        long cur = lcm + 1;\n                        while (all.contains(cur)) {\n                            cur += lcm;\n                        }\n                        a[i][j] = cur;\n                        all.add(a[i][j]);\n\n//                    for (int d = 0; d < 4; d++) {\n//                        int ni = i + dx[d], nj = j + dy[d];\n//                        if (0 <= ni && ni < n && 0 <= nj && nj < n) {\n//                            if (Math.max(a[ni][nj], a[i][j]) % Math.min(a[i][j], a[ni][nj]) != 1) {\n//                                System.err.println(a[i][j] + \" \" + a[ni][nj]);\n//                                throw new AssertionError();\n//                            }\n//                        }\n//                    }\n                    }\n                }\n            }\n\n            n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    out.print(a[i][j] + \" \");\n                }\n                out.println();\n            }\n        }\n\n    }\n\n    static class NumberTheory {\n        public static long gcd(long a, long b) {\n            if (a == 0) {\n                return b;\n            }\n            return gcd(b % a, a);\n        }\n\n        public static long lcm(long a, long b) {\n            return a / gcd(a, b) * b;\n        }\n\n        public static List<Integer> primes(int max) {\n            boolean[] isPrime = new boolean[max + 1];\n            Arrays.fill(isPrime, true);\n            List<Integer> ans = new ArrayList<>();\n            for (int i = 2; i <= max; i++) {\n                if (isPrime[i]) {\n                    ans.add(i);\n                    for (int j = 2 * i; j <= max; j += i) {\n                        isPrime[j] = false;\n                    }\n                }\n            }\n            return ans;\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static long gcd(long a, long b){\n        if(a<b) return gcd(b,a);\n        if(b==0) return a;\n        if(a%b==0) return b;\n        return gcd(b,a%b);\n    }\n    public static long lcm(long a, long b){\n        return (a/gcd(a,b))*b;\n    }\n    public static void printMatrix(int N, long[][] matrix){\n        for(int i=0;i<N;i++){\n        \tfor(int j=0;j<N;j++){\n        \t    System.out.print(matrix[i][j]);\n        \t    if(j>=N-1) System.out.println();\n        \t    else System.out.print(\" \");\n        \t}\n        }\n    }\n    public static long getMatrix(long[][] matrix, int i, int j){\n        try{\n        \treturn matrix[i][j];\n        }\n        catch(Exception e){\n        \treturn 1;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long[][] matrix = new long[N][N];\n        long m = 1;\n        long cur = 2;\n        for(int i=0;i<N;i+=2) for(int j=0;j<N;j++){\n        \tif((i+j)%2==0){\n        \t    matrix[i][j] = cur;\n        \t    cur++;\n        \t}\n        }\n        for(int i=N/2*2-1;i>=0;i-=2) for(int j=N-1;j>=0;j--){\n        \tif((i+j)%2==0){\n        \t    matrix[i][j] = cur;\n        \t    cur++;\n        \t}\n        }\n        for(int i=0;i<N;i++) for(int j=0;j<N;j++){\n        \tif((i+j)%2!=0){\n        \t    matrix[i][j] = getMatrix(matrix,i-1,j)*getMatrix(matrix,i+1,j)*getMatrix(matrix,i,j-1)*getMatrix(matrix,i,j+1) + m;\n        \t}\n        }\n        printMatrix(N,matrix);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DModuloMatrix solver = new DModuloMatrix();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DModuloMatrix {\n        Debug debug = new Debug(false);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = 504;//in.readInt();\n            long[][] mat = new long[n][n];\n            EulerSieve sieve = new EulerSieve(10000);\n            int[] row = new int[n];\n            int[] col = new int[n];\n            for (int i = 0; i < n / 2; i++) {\n                row[i] = sieve.get(i * 2 + 3);\n                col[i] = sieve.get(i * 2 + 4);\n            }\n\n            row = zigzag(row, 0, n / 2 - 1);\n            col = zigzag(col, 0, n / 2 - 1);\n\n            debug.debug(\"row\", row);\n            debug.debug(\"col\", col);\n\n            int[] expandRow = new int[n];\n            int[] expandCol = new int[n];\n            for (int i = 0; i < n; i += 2) {\n                expandRow[i] = row[i / 2];\n                expandRow[i + 1] = 2 * row[i / 2];\n                expandCol[i] = col[i / 2];\n                expandCol[i + 1] = 3 * col[i / 2];\n            }\n            debug.debug(\"expandRow\", expandRow);\n            debug.debug(\"expandCol\", expandCol);\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((i + j) % 2 == 0) {\n                        mat[i][j] = expandRow[i] * expandCol[j];\n                    }\n                }\n            }\n\n            int[][] dirs = new int[][]{\n                    {-1, 0},\n                    {1, 0},\n                    {0, -1},\n                    {0, 1}\n            };\n            for (int i = 1; i < n - 1; i++) {\n                for (int j = 1; j < n - 1; j++) {\n                    if ((i + j) % 2 == 0) {\n                        continue;\n                    }\n                    long lcm = 1;\n                    for (int[] dir : dirs) {\n                        int x = i + dir[0];\n                        int y = j + dir[1];\n                        if (x < 0 || y < 0 || x >= n || y >= n) {\n                            continue;\n                        }\n                        lcm = LCMs.lcm(lcm, mat[x][y]);\n                    }\n                    if (i % 2 == 0) {\n                        lcm *= 2;\n                    }\n                    mat[i][j] = lcm + 1;\n                }\n            }\n\n            int m = in.readInt();\n            for (int i = 1; i <= m; i++) {\n                for (int j = 1; j <= m; j++) {\n                    out.append(mat[i][j]).append(' ');\n                }\n                out.println();\n            }\n        }\n\n        public int[] zigzag(int[] data, int l, int r) {\n            int[] ans = new int[data.length];\n            int offset = 0;\n            while (l <= r) {\n                ans[offset++] = data[l];\n                if (r >= l + 1) {\n                    ans[offset++] = data[r];\n                }\n                l++;\n                r--;\n            }\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class EulerSieve {\n        private int[] primes;\n        private boolean[] isComp;\n        private int primeLength;\n\n        public int get(int k) {\n            return primes[k];\n        }\n\n        public EulerSieve(int limit) {\n            isComp = new boolean[limit + 1];\n            primes = new int[limit + 1];\n            primeLength = 0;\n            for (int i = 2; i <= limit; i++) {\n                if (!isComp[i]) {\n                    primes[primeLength++] = i;\n                }\n                for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                    int pi = primes[j] * i;\n                    isComp[pi] = true;\n                    if (i % primes[j] == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class GCDs {\n        private GCDs() {\n        }\n\n        public static long gcd(long a, long b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static long gcd0(long a, long b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n    }\n\n    static class LCMs {\n        private LCMs() {\n        }\n\n        public static long lcm(long x, long y) {\n            return x / GCDs.gcd(x, y) * y;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[2 * n + 1];\n                        long[] sosos = new long[2 * n + 1];\n                        long[][] map = new long[n][n];\n                        for(int i = 0 ; i < n ; i++){\n                                Arrays.fill(map[i] , 1);\n                        }\n                        sos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q <= 2 * n ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        int aaa = 0;\n                        int bbb = 2 * n;\n                        for(int i = 0 ; i <= n * 2 ; i++){\n                                if(i % 2 == 0){\n                                        sosos[i] = sos[aaa];\n                                        aaa++;\n                                }else{\n                                        sosos[i] = sos[bbb];\n                                        bbb--;\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] *= sosos[(i + j) / 2];\n                                                map[i][j] *= sosos[n + (j - i + n) / 2];\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j != 0 && j != n - 1){\n                                                        map[i][j] = map[i][j + 1] * map[i][j - 1] + 1;\n                                                }else{\n                                                        if(i != 0 && i != n - 1){\n                                                                map[i][j] = map[i + 1][j] * map[i - 1][j] + 1;\n                                                        }else{\n                                                                if(j == 0){\n                                                                        map[n - 1][0] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                                }else{\n                                                                        map[0][n - 1] = map[0][n - 2] * map[1][n - 1] + 1;\n                                                                }\n                                                        }\n                                                }\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        ou.print(map[i][j]);\n                                        if(j != n - 1) ou.print(\" \");\n                                        else ou.print(\"\\n\");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemD solver = new ProblemD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemD {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tlong[][] a = new long[n][n];\n\t\t\tint[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199};\n\t\t\tList<Integer> fromSmallPrimes = new ArrayList<>();\n\t\t\tfor (int i = 2; ; i++) {\n\t\t\t\tint x = i;\n\t\t\t\tfor (int p : primes) {\n\t\t\t\t\twhile (x % p == 0) {\n\t\t\t\t\t\tx /= p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x == 1) {\n\t\t\t\t\tfromSmallPrimes.add(i);\n\t\t\t\t\tif (fromSmallPrimes.size() == 500 * 500 / 2) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSet<Long> set = new HashSet<>();\n\t\t\tint u = 0;\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < n; c++) {\n\t\t\t\t\tif ((r + c) % 2 == 0) {\n\t\t\t\t\t\ta[r][c] = fromSmallPrimes.get(u++);\n\t\t\t\t\t\tset.add(a[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < n; c++) {\n\t\t\t\t\tif ((r + c) % 2 == 1) {\n\t\t\t\t\t\tlong cur = 1;\n\t\t\t\t\t\tfor (int dr = -1; dr <= 1; dr++) {\n\t\t\t\t\t\t\tfor (int dc = -1; dc <= 1; dc++) {\n\t\t\t\t\t\t\t\tif (dr == 0 ^ dc == 0) {\n\t\t\t\t\t\t\t\t\tint nr = r + dr;\n\t\t\t\t\t\t\t\t\tint nc = c + dc;\n\t\t\t\t\t\t\t\t\tif (nr >= 0 && nr < n && nc >= 0 && nc < n && a[nr][nc] != 0) {\n\t\t\t\t\t\t\t\t\t\tcur = lcm(cur, a[nr][nc]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong x = cur + 1;\n\t\t\t\t\t\twhile (set.contains(x)) {\n\t\t\t\t\t\t\tx += cur;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[r][c] = x;\n\t\t\t\t\t\tset.add(a[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!check(a)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tout.print(a[i][j]);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean check(long[][] a) {\n\t\t\tint n = a.length;\n\t\t\tSet<Long> set = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (set.contains(a[i][j])) {\n\t\t\t\t\t\tSystem.out.println(\"bad elem \" + a[i][j]);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tset.add(a[i][j]);\n\t\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\t\tlong u = a[i][j];\n\t\t\t\t\t\tlong v = a[i + 1][j];\n\t\t\t\t\t\tif (Math.max(u, v) % Math.min(u, v) != 1) {\n\t\t\t\t\t\t\tSystem.out.println(\"! \" + u + \" \" + v);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < n) {\n\t\t\t\t\t\tlong u = a[i][j];\n\t\t\t\t\t\tlong v = a[i][j + 1];\n\t\t\t\t\t\tif (Math.max(u, v) % Math.min(u, v) != 1) {\n\t\t\t\t\t\t\tSystem.out.println(\"! \" + u + \" \" + v);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn set.size() == n * n;\n\t\t}\n\n\t\tprivate long lcm(long a, long b) {\n\t\t\treturn a / gcd(a, b) * b;\n\t\t}\n\n\t\tprivate long gcd(long a, long b) {\n\t\t\treturn b == 0 ? a : gcd(b, a % b);\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass PrimeGenerator\n{\n\tstatic final int maxx = (int) 1e7;\n\t\n\tint current;\n\tboolean[] sieve;\n\t\n\tPrimeGenerator()\n\t{\n\t\tsieve = new boolean[maxx+1];\n\t\t\n\t\tcurrent = 0;\n\t\tArrays.fill(sieve, true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor (int i=2; i*i<=maxx; i++)\n\t\tif (sieve[i])\n\t\t{\n\t\t\tfor (int j=i*2; j<=maxx; j+=i)\n\t\t\t\tsieve[j]=false;\n\t\t}\n\t}\n\t\n\tint nextPrime()\n\t{\n\t\tcurrent++;\n\t\t\n\t\twhile (!sieve[current]) current++;\n\t\t\n\t\treturn current;\n\t}\n\t\n}\nclass Solve {\n\tstatic final int[] mx = new int[] {0,0,1,-1};\n\tstatic final int[] my = new int[] {1,-1,0,0};\n\t\n\tKattio io;\n\n\tint n;\n\tlong[][] a;\n\tPrimeGenerator PG;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tlong gcd(long x,long y)\n\t{\n\t\tif (x%y==0) return y;\n\t\telse return gcd(y,x%y);\n\t}\n\t\n\tlong lcm(long x,long y)\n\t{\n\t\treturn x/gcd(x,y)*y;\n\t}\n\t\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tPG = new PrimeGenerator();\n\t\ta = new long[n+2][n+2];\n\t\tint[] d1 = new int[2001];\n\t\tint[] d2 = new int[2001];\n\t\t\n\t\tfor (int i=0; i<=2000; i++)\n\t\t\td1[i] = PG.nextPrime();\n\t\tfor (int i=0; i<=2000; i++)\n\t\t\td2[i] = PG.nextPrime();\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\ta[i][j]=1;\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\tif ((i+j)%2==0)\n\t\t\t\t\ta[i][j]=d1[i+j]*d2[i-j+n+1];\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\tfor (int x=0; x<4; x++)\n\t\t\t\t\t\ta[i][j]=lcm(a[i][j],a[i+mx[x]][j+my[x]]);\n\t\t\t\t\ta[i][j]++;\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass PrimeGenerator\n{\n\tstatic final int maxx = (int) 1e7;\n\t\n\tint current;\n\tboolean[] sieve;\n\t\n\tPrimeGenerator()\n\t{\n\t\tsieve = new boolean[maxx+1];\n\t\t\n\t\tcurrent = 0;\n\t\tArrays.fill(sieve, true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor (int i=2; i*i<=maxx; i++)\n\t\tif (sieve[i])\n\t\t{\n\t\t\tfor (int j=i*2; j<=maxx; j+=i)\n\t\t\t\tsieve[j]=false;\n\t\t}\n\t}\n\t\n\tint nextPrime()\n\t{\n\t\tcurrent++;\n\t\t\n\t\twhile (!sieve[current]) current++;\n\t\t\n\t\treturn current;\n\t}\n\t\n}\nclass Solve {\n\tstatic final int[] mx = new int[] {0,0,1,-1};\n\tstatic final int[] my = new int[] {1,-1,0,0};\n\t\n\tKattio io;\n\n\tint n;\n\tlong[][] a;\n\tPrimeGenerator PG;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tlong gcd(long x,long y)\n\t{\n\t\tif (x%y==0) return y;\n\t\telse return gcd(y,x%y);\n\t}\n\t\n\tlong lcm(long x,long y)\n\t{\n\t\treturn x/gcd(x,y)*y;\n\t}\n\t\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tPG = new PrimeGenerator();\n\t\ta = new long[n+2][n+2];\n\t\tint[] d1 = new int[2*n+1];\n\t\tint[] d2 = new int[2*n+1];\n\t\t\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\td1[i] = PG.nextPrime();\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\td2[i] = PG.nextPrime();\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\ta[i][j]=1;\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==0)\n\t\t\t\t\ta[i][j]=d1[i+j]*d2[i-j+n];\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\tfor (int x=0; x<4; x++)\n\t\t\t\t\t\ta[i][j]=lcm(a[i][j],a[i+mx[x]][j+my[x]])+1;\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass PrimeGenerator\n{\n\tstatic final int maxx = (int) 1e7;\n\t\n\tint current;\n\tboolean[] sieve;\n\t\n\tPrimeGenerator()\n\t{\n\t\tsieve = new boolean[maxx+1];\n\t\t\n\t\tcurrent = 0;\n\t\tArrays.fill(sieve, true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor (int i=2; i*i<=maxx; i++)\n\t\tif (sieve[i])\n\t\t{\n\t\t\tfor (int j=i*2; j<=maxx; j+=i)\n\t\t\t\tsieve[j]=false;\n\t\t}\n\t}\n\t\n\tint nextPrime()\n\t{\n\t\tcurrent++;\n\t\t\n\t\twhile (!sieve[current]) current++;\n\t\t\n\t\treturn current;\n\t}\n\t\n}\nclass Solve {\n\tstatic final int[] mx = new int[] {0,0,1,-1};\n\tstatic final int[] my = new int[] {1,-1,0,0};\n\t\n\tKattio io;\n\n\tint n;\n\tlong[][] a;\n\tPrimeGenerator PG;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tlong gcd(long x,long y)\n\t{\n\t\tif (x%y==0) return y;\n\t\telse return gcd(y,x%y);\n\t}\n\t\n\tlong lcm(long x,long y)\n\t{\n\t\treturn x/gcd(x,y)*y;\n\t}\n\t\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tPG = new PrimeGenerator();\n\t\ta = new long[n+2][n+2];\n\t\tint[] d1 = new int[2*n+1];\n\t\tint[] d2 = new int[2*n+1];\n\t\t\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\td1[i] = PG.nextPrime();\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\td2[i] = PG.nextPrime();\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\ta[i][j]=1;\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==0)\n\t\t\t\t\ta[i][j]=d1[i+j]*d2[i-j+n];\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\tfor (int x=0; x<4; x++)\n\t\t\t\t\t\ta[i][j]=lcm(a[i][j],a[i+mx[x]][j+my[x]]);\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.TreeSet;\n \n \n \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt(); \n\n    int basenum = 4;\n    for(int i = 0; i < n; i++){\n      int startnum = basenum + 3 * i;\n      for(int j = 0; j < n - 1; j++){\n        System.out.print(startnum + 3 * j);\n        System.out.print(\" \");\n      }\n      System.out.println(startnum + 3 * (n - 1));\n    }\n\n \n  }\n \n //ここからテンプレ\n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n \n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n \n      public char nextChar() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        char ret;\n        do{\n          ret = (char)c;\n          c = next();\n        }while(!isSpaceChar(c));\n        return ret;\n      }\n \n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass PrimeGenerator\n{\n\tstatic final int maxx = (int) 1e7;\n\t\n\tint current;\n\tboolean[] sieve;\n\t\n\tPrimeGenerator()\n\t{\n\t\tsieve = new boolean[maxx+1];\n\t\t\n\t\tcurrent = 0;\n\t\tArrays.fill(sieve, true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor (int i=2; i*i<=maxx; i++)\n\t\tif (sieve[i])\n\t\t{\n\t\t\tfor (int j=i*2; j<=maxx; j+=i)\n\t\t\t\tsieve[j]=false;\n\t\t}\n\t}\n\t\n\tint nextPrime()\n\t{\n\t\tcurrent++;\n\t\t\n\t\twhile (!sieve[current]) current++;\n\t\t\n\t\treturn current;\n\t}\n\t\n}\nclass Solve {\n\tstatic final int[] mx = new int[] {0,0,1,-1};\n\tstatic final int[] my = new int[] {1,-1,0,0};\n\t\n\tKattio io;\n\n\tint n;\n\tlong[][] a;\n\tPrimeGenerator PG;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tlong gcd(long x,long y)\n\t{\n\t\tif (x%y==0) return y;\n\t\telse return gcd(y,x%y);\n\t}\n\t\n\tlong lcm(long x,long y)\n\t{\n\t\treturn x/gcd(x,y)*y;\n\t}\n\t\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tPG = new PrimeGenerator();\n\t\ta = new long[n+2][n+2];\n\t\tint[] d1 = new int[2*n+1];\n\t\tint[] d2 = new int[2*n+1];\n\t\t\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\td1[i] = PG.nextPrime();\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\td2[i] = PG.nextPrime();\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\ta[i][j]=1;\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==0)\n\t\t\t\t\ta[i][j]=d1[i+j]*d2[i-j+n];\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\tfor (int x=0; x<4; x++)\n\t\t\t\t\t\ta[i][j]=lcm(a[i][j],a[i+mx[x]][j+my[x]]);\n\t\t\t\t\ta[i][j]++;\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[2 * n];\n                        long[][] map = new long[n][n];\n                        for(int i = 0 ; i < n ; i++){\n                                Arrays.fill(map[i] , 1);\n                        }\n                        sos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q < 2 * n ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] *= sos[i];\n                                        }\n                                }\n                        }\n                        for(int j = 0 ; j < n ; j++){\n                                for(int i = 0 ; i < n ; i++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] *= sos[j + n];\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j == n - 1 && i == 0){\n                                                        map[0][n - 1] = map[1][n - 1] * map[0][n - 2] + 1;\n                                                }else if(i == n - 1 && j == 0){\n                                                        map[i][j] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                }else if(i == 0){\n                                                        map[0][j] = map[0][j - 1] * map[0][j + 1] * map[1][j] + 1;\n                                                }else if(i == n - 1){\n                                                        map[n - 1][j] = map[n - 2][j] * map[n - 1][j + 1] * map[n - 1][j - 1] + 1;\n                                                }else if(j == 0){\n                                                        map[i][0] = map[i - 1][0] * map[i + 1][0] * map[i][1] + 1;\n                                                }else if(j == n - 1){\n                                                        map[i][n - 1] = map[i][n - 2] * map[i - 1][n - 1] * map[i + 1][n - 1] + 1;\n                                                }else{\n                                                        map[i][j] = map[i + 1][j] * map[i - 1][j] * map[i][j + 1] * map[i][j - 1] + 1;\n                                                }\n                                        }\n                                        ou.print(map[i][j]);\n                                        if(j == n - 1) ou.print(\"\\n\");\n                                        else ou.print(\" \");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Set;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        static final long MAX = (long) 1e15;\n        static final int BUBEN = 5000;\n        Random random = new Random(543535151L);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = 1;\n            long[][] a = new long[n][n];\n            Set<Long> have = new HashSet<>();\n            outer:\n            while (true) {\n                long[] plus = new long[n + n];\n                long[] minus = new long[n + n];\n                for (int i = 0; i < n + n; ++i) {\n                    do {\n                        plus[i] = random.nextInt(BUBEN) + 2;\n                    } while (!have.add(plus[i]));\n                    do {\n                        minus[i] = random.nextInt(BUBEN) + 2;\n                    } while (!have.add(minus[i]));\n                }\n                for (int i = 0; i < n; ++i) {\n                    for (int j = 0; j < n; ++j) {\n                        if ((i + j) % 2 == 0) {\n                            long got = plus[i + j] * minus[i + n - j];\n                            long r = got;\n                            while (r <= MAX && have.contains(r)) r += got;\n                            if (r > MAX) continue outer;\n                            have.add(r);\n                            a[i][j] = r;\n                        }\n                    }\n                }\n                for (int i = 0; i < n; ++i) {\n                    for (int j = 0; j < n; ++j) {\n                        if ((i + j) % 2 != 0) {\n                            long got = 1;\n                            if (i > 0) got = lcm(got, a[i - 1][j]);\n                            if (i + 1 < n) got = lcm(got, a[i + 1][j]);\n                            if (j > 0) got = lcm(got, a[i][j - 1]);\n                            if (j + 1 < n) got = lcm(got, a[i][j + 1]);\n                            long r = got + 1;\n                            while (r <= MAX && have.contains(r)) r += got;\n                            if (r > MAX) continue outer;\n                            have.add(r);\n                            a[i][j] = r;\n                        }\n                    }\n                }\n                break;\n            }\n            for (long[] x : a) {\n                for (long y : x) out.print(y + \" \");\n                out.println();\n            }\n        }\n\n        long lcm(long a, long b) {\n            if (a == 0 || b == 0) throw new RuntimeException();\n            b /= gcd(a, b);\n            if (a <= MAX / b) return a * b;\n            else return MAX + 1;\n        }\n\n        long gcd(long a, long b) {\n            while (b > 0) {\n                long t = a % b;\n                a = b;\n                b = t;\n            }\n            return a;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc027;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    private static int[] dx = new int[]{0, -1, 0, 1};\n    private static int[] dy = new int[]{-1, 0, 1, 0};\n\n    private static long THE_NUMBER = 14414400;\n\n    /**\n     * Generates primes less than upto.\n     *\n     * O(nlog(logn))\n     *\n     * @param upto limit\n     * @return array of primes\n     */\n    static int[] generatePrimes(int upto) {\n        boolean[] isp = new boolean[upto];\n        Arrays.fill(isp, true);\n        isp[0] = isp[1] = false;\n\n        int pi = 0;\n        for (int i = 2; i < upto ; i++) {\n            if (isp[i]) {\n                pi++;\n                for (int j = i * 2; j < upto; j += i) {\n                    isp[j] = false;\n                }\n            }\n        }\n\n        int[] ret = new int[pi];\n        int ri = 0;\n        for (int i = 2 ; i < upto ; i++) {\n            if (isp[i]) {\n                ret[ri++] = i;\n            }\n        }\n        return ret;\n    }\n\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        List<Long> divisors = new ArrayList<>();\n        for (long i = 1; i * i < THE_NUMBER ; i++) {\n            if (THE_NUMBER % i == 0) {\n                divisors.add(i);\n                divisors.add(THE_NUMBER / i);\n            }\n        }\n        Collections.sort(divisors);\n\n        int n = in.nextInt();\n        long[][] f = new long[n][n];\n\n        int[] p = generatePrimes(10000);\n\n        int pi = 10;\n        int pf0 = 10;\n        int pf1 = 260;\n\n        int idx = 0;\n        int flg = 0;\n        for (int i = 0 ; i < n ; i++) {\n            for (int j = (i & 1); j < n ; j += 2) {\n                f[i][j] = p[pi] * divisors.get(idx++);\n            }\n            if (i % 2 == 1) {\n                if (flg == 0) {\n                    pf0++;\n                    pi = pf1;\n                } else {\n                    pf1--;\n                    pi = pf0;\n                }\n                idx = 0;\n                flg ^= 1;\n            }\n        }\n\n\n        Set<Long> used = new HashSet<>();\n\n        int bestC = 0;\n        for (int i = 0; i < n ; i++) {\n            for (int j = 0; j < n ; j++) {\n                if (f[i][j] == 0) {\n                    long m = 1;\n                    for (int d = 0; d < 4 ; d++) {\n                        if (i+dy[d] < 0 || i+dy[d] >= n || j+dx[d] < 0 || j+dx[d] >= n) {\n                            continue;\n                        }\n                        m = lcm(m, f[i+dy[d]][j+dx[d]]);\n                    }\n                    long mm = m;\n                    int cnt = 0;\n                    while (used.contains(mm)) {\n                        mm += m;\n                        cnt += 1;\n                    }\n                    used.add(mm);\n                    f[i][j] = mm+1;\n                    bestC = Math.max(bestC, cnt);\n                }\n            }\n        }\n\n        for (int i = 0; i < n ; i++) {\n            StringBuilder line = new StringBuilder();\n            for (int j = 0; j < n ; j++) {\n                line.append(' ').append(f[i][j]);\n            }\n            out.println(line.substring(1));\n        }\n        out.println();\n        out.flush();\n\n\n    }\n\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a%b);\n    }\n\n    static long lcm(long a, long b) {\n        long w = gcd(a, b);\n        a /= w;\n        return a * b;\n    }\n\n\n    static long largestP(long a) {\n        long best = 0;\n        for (long i = 2 ; i * i <= a ; i++) {\n            int cnt = 0;\n            while (a % i == 0) {\n                a /= i;\n                cnt++;\n            }\n            if (cnt == 1) {\n                best = Math.max(best, i);\n            }\n        }\n        best = Math.max(best, a);\n        return best;\n    }\n\n    static void check(long[][] a) {\n        Set<Long> s = new HashSet<>();\n        int n = a.length;\n        for (int i = 0; i < a.length ; i++) {\n            for (int j = 0; j < a[0].length ; j++) {\n                if (a[i][j] > 1e15 || s.contains(a[i][j])) {\n\n                    for (int d = 0 ; d < 4 ; d++) {\n                        if (i+dy[d] < 0 || i+dy[d] >= n || j+dx[d] < 0 || j+dx[d] >= n) {\n                            continue;\n                        }\n                        debug(a[i+dy[d]][j+dx[d]], largestP(a[i+dy[d]][j+dx[d]]));\n                    }\n\n                    debug(i, j, a[i][j]);\n                    if (s.contains(a[i][j])) {\n                        throw new RuntimeException(\"mul\");\n                    } else {\n                        throw new RuntimeException(\"over\");\n                    }\n                }\n\n                for (int d = 0 ; d < 4 ; d++) {\n                    if (i+dy[d] < 0 || i+dy[d] >= n || j+dx[d] < 0 || j+dx[d] >= n) {\n                        continue;\n                    }\n                    long max = Math.max(a[i][j], a[i+dy[d]][j+dx[d]]);\n                    long min = Math.min(a[i][j], a[i+dy[d]][j+dx[d]]);\n                    if (max % min != 1) {\n                        debug(i, j, i+dy[d], j+dx[d], a[i][j], a[i+dy[d]][j+dx[d]], max % min);\n                        throw new RuntimeException(\"mod err\");\n                    }\n                }\n                s.add(a[i][j]);\n            }\n        }\n        if (s.size() != a.length *  a[0].length) {\n            throw new RuntimeException(\"mul\");\n        }\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n\n  private static void solve() {\n    int[] primes = sieveAtkin(10000);\n    \n    int n = ni();\n    if (n == 2) {\n      System.out.println(\"4 7\");\n      System.out.println(\"23 10\");\n      return;\n    }\n    long[][] a = new long[n][n];\n\n    Set<Long> set = new HashSet<>();\n    for (int i = 0; i < n; i ++) {\n      for (int j = i % 2; j < n; j += 2) {\n        a[i][j] = primes[(i + j) / 2];\n      }\n    }\n\n    for (int i = 0; i < n; i ++) {\n      for (int j = i % 2; j < n; j += 2) {\n        a[i][j] *= primes[n + ((n - 1) / 2) + (i - j) / 2];\n        set.add(a[i][j]);\n      }\n    }\n    \n    int[][] dir = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n    for (int i = 0; i < n; i ++) {\n      for (int j = (i + 1) % 2; j < n; j += 2) {\n        long x = 1;\n        for (int[] d: dir) {\n          int ni = i + d[0];\n          int nj = j + d[1];\n          \n          if (ni < 0 || nj < 0 || ni >= n || nj >= n) {\n            continue;\n          }\n          x *= a[ni][nj] / gcd(a[ni][nj], x);\n          \n          if (x < 0 || x > 1000000000000000L) throw new RuntimeException();\n        }\n        a[i][j] = x + 1;\n        set.add(a[i][j]);\n      }\n    }\n    \n    if (set.size() != n * n) throw new RuntimeException();\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < n; i ++) {\n      for (int j = 0; j < n; j ++) {\n        sb.append(a[i][j]);\n        if (j == n - 1) {\n          sb.append(\"\\n\");\n        } else {\n          sb.append(\" \");\n        }\n      }\n    }\n    System.out.print(sb);\n  }\n\n  public static long gcd(long a, long b) {\n    if (a > b) {\n      long tmp = a;\n      a = b;\n      b = tmp;\n    }\n    while (a != 0) {\n      long c = a;\n      a = b % c;\n      b = c;\n    }\n    return b;\n  }\n\n  public static int[] sieveAtkin(int size) {\n    boolean[] isPrime = new boolean[size + 1];\n    int sqrtN = (int) Math.sqrt(size);\n    int n;\n    for (int x = 1; x <= sqrtN; ++x) {\n      for (int y = 1; y <= sqrtN; ++y) {\n        n = 4 * x * x + y * y;\n        if (n <= size && (n % 12 == 1 || n % 12 == 5)) {\n          isPrime[n] = !isPrime[n];\n        }\n        n = 3 * x * x + y * y;\n        if (n <= size && n % 12 == 7) {\n          isPrime[n] = !isPrime[n];\n        }\n        n = 3 * x * x - y * y;\n        if (x > y && n <= size && n % 12 == 11) {\n          isPrime[n] = !isPrime[n];\n        }\n      }\n    }\n\n    for (n = 5; n <= sqrtN; ++n) {\n      if (isPrime[n]) {\n        for (int k = n * n; k <= size; k += n * n) {\n          isPrime[k] = false;\n        }\n      }\n    }\n    isPrime[2] = isPrime[3] = true;\n\n    int[] ret = new int[size];\n    int count = 0;\n    for (int i = 1; i < size; i++) {\n      if (isPrime[i]) {\n        ret[count++] = i;\n      }\n    }\n    return Arrays.copyOf(ret, count);\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static long gcd(long a, long b){\n        if(a<b) return gcd(b,a);\n        if(b==0) return a;\n        if(a%b==0) return b;\n        return gcd(b,a%b);\n    }\n    public static long lcm(long a, long b){\n        return (a/gcd(a,b))*b;\n    }\n    public static void printMatrix(int N, long[][] matrix){\n        for(int i=0;i<N;i++){\n        \tfor(int j=0;j<N;j++){\n        \t    System.out.print(matrix[i][j]);\n        \t    if(j>=N-1) System.out.println();\n        \t    else System.out.print(\" \");\n        \t}\n        }\n    }\n    public static long getMatrix(long[][] matrix, int i, int j){\n        try{\n        \treturn matrix[i][j];\n        }\n        catch(Exception e){\n        \treturn 1;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        if(N==2){\n        \tSystem.out.println(\"4 7\");\n        \tSystem.out.println(\"23 10\");\n        \tSystem.exit(0);\n        }\n        long[][] matrix = new long[N][N];\n        long m = 1;\n        \n        HashSet<Long> used = new HashSet<>();\n        long cur = 2;\n        for(int i=0;i<N;i+=2) for(int j=0;j<N;j++){\n        \tif((i+j)%2==0){\n        \t    matrix[i][j] = cur;\n        \t    used.add(cur);\n        \t    cur++;\n        \t}\n        }\n        for(int i=N/2*2-1;i>=0;i-=2) for(int j=N-1;j>=0;j--){\n        \tif((i+j)%2==0){\n        \t    matrix[i][j] = cur;\n        \t    used.add(cur);\n        \t    cur++;\n        \t}\n        }\n        \n        for(int i=0;i<N;i++) for(int j=0;j<N;j++){\n        \tif((i+j)%2!=0){\n        \t    long ans = lcm(getMatrix(matrix,i-1,j),getMatrix(matrix,i+1,j));\n        \t    ans = lcm(ans,getMatrix(matrix,i,j-1));\n        \t    ans = lcm(ans,getMatrix(matrix,i,j+1));\n        \t    long elm = ans+m;\n        \t    while(true){\n        \t        if(!used.contains(ans+m)){\n        \t        \tmatrix[i][j]=elm;\n        \t        \tused.add(elm);\n        \t        \tbreak;\n        \t        }else{\n        \t        \telm += ans;\n        \t        }\n        \t    }\n        \t}\n        }\n        printMatrix(N,matrix);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n \nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n \npublic class Main{\n    static final long mod=1000000007;\n    \n    public  static void main(String[] args)   throws Exception, IOException{\n        Reader sc = new Reader(System.in);\n        PrintWriter out=new PrintWriter(System.out);\n        // int n=sc.nextInt();\n        // char c[][] = new char[h][w];\n        // char c[]=sc.nextString().toCharArray();\n        // int d[]=new int[n];\n        // for(int i=0; i<n; i++) {d[i]=sc.nextInt();}\n\n        int m=sc.nextInt();\n        int n=100000;\n        long a[][]=new long[m][m];\n        boolean p[]=new boolean[n+1];\n        for(int i=4; i<=n; i+=2)p[i]=true;\n        for(int i=3; i*i<=n; i+=2) {\n            if(!p[i]){\n                for (int t=i*i; t<=n; t+=i) {\n                    p[t]=true;\n                }\n            }\n        }\n        int prime[]=new int[1010];\n        int c=0,v=0;\n        for(int i=2; c<prime.length; i++)if(!p[i]){\n            prime[c++]=i;\n        }\n        \n        for(int i=0; i<m; i++) {\n            fill(a[i],1);\n        }\n        n=m;\n        for (int i = 0; i < n; i++) {\n          for (int j = 0; j < n; j++) {\n            if ((i + j) % 2 == 0) {\n              a[i][j] = prime[(i + j) / 2] * prime[(i - j) / 2 + n + n / 2 + 2];\n            }\n          }\n        }      \n\n        int dx[]={1,-1,0,0};\n        int dy[]={0,0,1,-1};\n\n        for(int i=0; i<m; i++) {\n            for(int t=0; t<m; t++) {\n                if(i%2!=t%2){\n                    long z=1,g;\n                    for (int w=0,xx,yy; w<4; w++) {\n                        yy=i+dy[w];\n                        xx=t+dx[w];\n                        if(0<=xx&&xx<m && 0<=yy&&yy<m){\n                            g=gcd(z,a[yy][xx]);\n                            z*=a[yy][xx]/g;\n                        }\n                    }\n                    a[i][t]+=z;\n                }\n            }\n        }\n        if(n==2)a[0][1]+=78;\n        for(int t=0; t<m; t++){\n            for (int i=0; i<m; i++) {\n                out.print(a[t][i]+\" \");\n            }\n                out.println();\n        }\n        // out.println(ans);\n        out.flush();\n    }\n\n\n    static void db(Object... os){\n        System.err.println(Arrays.deepToString(os));\n    }  \n\n    static long gcd(long a, long b){\n        if(min(a,b) == 0)return max(a,b);\n        return gcd(max(a,b) % min(a,b),min(a,b));\n    }\n}\n\nclass P implements Comparable<P>{\n    int id, d;\n    P(int  id, int d) {\n        this.id=id;\n        this.d=d;\n    }\n    public int compareTo(P p){\n        return d-p.d; //des\n    }\n}\n\nclass Reader\n{ \n    private BufferedReader x;\n    private StringTokenizer st;\n    \n    public Reader(InputStream in)\n    {\n        x = new BufferedReader(new InputStreamReader(in));\n        st = null;\n    }\n    public String nextString() throws IOException\n    {\n        while( st==null || !st.hasMoreTokens() )\n            st = new StringTokenizer(x.readLine());\n        return st.nextToken();\n    }\n    public int nextInt() throws IOException\n    {\n        return Integer.parseInt(nextString());\n    }\n    public long nextLong() throws IOException\n    {\n        return Long.parseLong(nextString());\n    }\n    public double nextDouble() throws IOException\n    {\n        return Double.parseDouble(nextString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass Solve {\n\tKattio io;\n\n\tint n;\n\tint[][] a;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tint dis(int a,int b,int c,int d)\n\t{\n\t\treturn Math.abs(a-c)+Math.abs(b-d);\n\t}\n\t\n\tvoid main() {\n\t\tn=io.getInt();\n\t\ta = new int[n+1][n+1];\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\ta[i][j]=dis(1,1,i,j)+2;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif (n==2) {\n\t\t\tSystem.out.println(\"4 7\");\n\t\t\tSystem.out.println(\"23 10\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint snt[] = new int[n * 2];\n\n\t\tint cn = 0;\n\t\tint x = 2;\n\t\twhile (cn < n * 2) {\n\t\t\tif (isSNT(x)) {\n\t\t\t\tsnt[cn] = x;\n\t\t\t\tcn++;\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\n\t\tlong[][] a = new long[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i % 2; j < n; j += 2) {\n\t\t\t\tint a1 = (i + j) / 2;\n\t\t\t\tint a2 = (j - i + n - 1) / 2 + n;\n\t\t\t\ta[i][j] = snt[a1] * snt[a2];\n\t\t\t}\n\t\t}\n\n\n\n\t\tint dx[] = { -1, 0, 1, 0 };\n\t\tint dy[] = { 0, 1, 0, -1 };\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = (i + 1) % 2; j < n; j += 2) {\n\t\t\t\tlong gcd = 0;\n\t\t\t\tlong tich = 1;\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (i + dx[k] < 0 || i + dx[k] >= n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (j + dy[k] < 0 || j + dy[k] >= n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (gcd == 0) {\n\t\t\t\t\t\tgcd = a[i + dx[k]][j + dy[k]];\n\t\t\t\t\t\ttich = gcd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgcd = gcd(tich, a[i + dx[k]][j + dy[k]]);\n\t\t\t\t\t\ttich = tich / gcd * a[i + dx[k]][j + dy[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta[i][j] = tich+1;\n\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSystem.out.print(a[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate static boolean isSNT(int x) {\n\t\tfor (int i = 2; i * i <= x; i++)\n\t\t\tif (x % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tprivate static long gcd(long a, long b) {\n\t\treturn (b == 0) ? a : gcd(b, a % b);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream input;\n\t\tOutputStream output;\n\t\ttry {\n\t\t\tinput = new FileInputStream(\"input.txt\");\n\t\t\toutput = new FileOutputStream(\"output.txt\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tinput = System.in;\n\t\t\toutput = System.out;\n\t\t}\n\t\tKattio io = new Kattio(input, output);\n\t\t(new Solve(io)).main();\n\t\tio.close();\n\n\t\tif (input instanceof FileInputStream)\n\t\t\ttry {\n\t\t\t\tinput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\tif (output instanceof FileOutputStream)\n\t\t\ttry {\n\t\t\t\toutput.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t}\n}\n\nclass PrimeGenerator\n{\n\tstatic final int maxx = (int) 1e7;\n\t\n\tint current;\n\tboolean[] sieve;\n\t\n\tPrimeGenerator()\n\t{\n\t\tsieve = new boolean[maxx+1];\n\t\t\n\t\tcurrent = 0;\n\t\tArrays.fill(sieve, true);\n\t\tsieve[0]=false;\n\t\tsieve[1]=false;\n\t\tfor (int i=2; i*i<=maxx; i++)\n\t\tif (sieve[i])\n\t\t{\n\t\t\tfor (int j=i*2; j<=maxx; j+=i)\n\t\t\t\tsieve[j]=false;\n\t\t}\n\t}\n\t\n\tint nextPrime()\n\t{\n\t\tcurrent++;\n\t\t\n\t\twhile (!sieve[current]) current++;\n\t\t\n\t\treturn current;\n\t}\n\t\n}\nclass Solve {\n\tstatic final int[] mx = new int[] {0,0,1,-1};\n\tstatic final int[] my = new int[] {1,-1,0,0};\n\t\n\tKattio io;\n\n\tint n;\n\tlong[][] a;\n\tPrimeGenerator PG;\n\tSolve(Kattio io) {\n\t\tthis.io = io;\n\t}\n\n\tlong gcd(long x,long y)\n\t{\n\t\tif (x%y==0) return y;\n\t\telse return gcd(y,x%y);\n\t}\n\t\n\tlong lcm(long x,long y)\n\t{\n\t\treturn x/gcd(x,y)*y;\n\t}\n\t\n\tvoid main() {\n\t\tn = io.getInt();\n\t\tPG = new PrimeGenerator();\n\t\ta = new long[n+2][n+2];\n\t\tint[] d1 = new int[3*n+1];\n\t\tint[] d2 = new int[3*n+1];\n\t\t\n\t\tfor (int i=0; i<=3*n; i++)\n\t\t\td1[i] = PG.nextPrime();\n\t\tfor (int i=0; i<=3*n; i++)\n\t\t\td2[i] = PG.nextPrime();\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\ta[i][j]=1;\n\t\t\n\t\tfor (int i=0; i<=n+1; i++)\n\t\t\tfor (int j=0; j<=n+1; j++)\n\t\t\t\tif ((i+j)%2==0)\n\t\t\t\t\ta[i][j]=d1[i+j]*d2[i-j+n];\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tif ((i+j)%2==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][j]=1;\n\t\t\t\t\tfor (int x=0; x<4; x++)\n\t\t\t\t\t\ta[i][j]=lcm(a[i][j],a[i+mx[x]][j+my[x]]);\n\t\t\t\t\ta[i][j]++;\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\tio.print(a[i][j]+\" \");\n\t\t\tio.println();\n\t\t}\n\t}\n}\n\nclass Kattio extends PrintWriter {\n\tpublic Kattio(InputStream i) {\n\t\tsuper(new BufferedOutputStream(System.out));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic Kattio(InputStream i, OutputStream o) {\n\t\tsuper(new BufferedOutputStream(o));\n\t\tr = new BufferedReader(new InputStreamReader(i));\n\t}\n\n\tpublic boolean hasMoreTokens() {\n\t\treturn peekToken() != null;\n\t}\n\n\tpublic int getInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic double getDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic long getLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic String getWord() {\n\t\treturn nextToken();\n\t}\n\n\tprivate BufferedReader r;\n\tprivate String line;\n\tprivate StringTokenizer st;\n\tprivate String token;\n\n\tprivate String peekToken() {\n\t\tif (token == null)\n\t\t\ttry {\n\t\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\t\tline = r.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\ttoken = st.nextToken();\n\t\t\t} catch (IOException e) {\n\t\t\t}\n\t\treturn token;\n\t}\n\n\tprivate String nextToken() {\n\t\tString ans = peekToken();\n\t\ttoken = null;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[2 * n];\n                        long[] sosos = new long[2 * n];\n                        long[][] map = new long[n][n];\n                        for(int i = 0 ; i < n ; i++){\n                                Arrays.fill(map[i] , 1);\n                        }\n                        sos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q < 2 * n ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        int aaa = 0;\n                        int bbb = 2 * n - 1;\n                        for(int i = 0 ; i < n * 2 ; i++){\n                                if(i % 2 == 0){\n                                        sosos[i] = sos[aaa];\n                                        aaa++;\n                                }else{\n                                        sosos[i] = sos[bbb];\n                                        bbb--;\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] *= sosos[j];\n                                        }\n                                }\n                        }\n                        for(int j = 0 ; j < n ; j++){\n                                for(int i = 0 ; i < n ; i++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] *= sosos[i + n];\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j == n - 1 && i == 0){\n                                                        map[0][n - 1] = map[1][n - 1] * map[0][n - 2] + 1;\n                                                }else if(i == n - 1 && j == 0){\n                                                        map[i][j] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                }else if(i == 0){\n                                                        map[0][j] = map[0][j - 1] * map[0][j + 1] * map[1][j] + 1;\n                                                }else if(i == n - 1){\n                                                        map[n - 1][j] = map[n - 2][j] * map[n - 1][j + 1] * map[n - 1][j - 1] + 1;\n                                                }else if(j == 0){\n                                                        map[i][0] = map[i - 1][0] * map[i + 1][0] * map[i][1] + 1;\n                                                }else if(j == n - 1){\n                                                        map[i][n - 1] = map[i][n - 2] * map[i - 1][n - 1] * map[i + 1][n - 1] + 1;\n                                                }else{\n                                                        map[i][j] = map[i + 1][j] * map[i - 1][j] * map[i][j + 1] * map[i][j - 1] + 1;\n                                                }\n                                        }\n                                        ou.print(map[i][j]);\n                                        if(j == n - 1) ou.print(\"\\n\");\n                                        else ou.print(\" \");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                Map hs = new HashMap();\n                PrintWriter ou = new PrintWriter(System.out);\n                int n = Integer.parseInt(sc.next());\n                sc.close();\n                if(n == 2){\n                        ou.print(\"4 7\\n23 10\\n\");\n                }else{\n                        long[] sos = new long[(n * n + 1) / 2];\n                        long[][] map = new long[n][n];\n                        sos[0] = 2;\n                        int q = 1;\n                        for(long i = 3 ; q < (n * n + 1) / 2 ; i++){\n                                boolean ebishu = true;\n                                for(int j = 2 ; j <= Math.sqrt(i) && ebishu ; j++){\n                                        if(i % j == 0) ebishu = false;\n                                }\n                                if(ebishu){\n                                        sos[q] = i;\n                                        q++;\n                                }\n                        }\n                        int cou = 0;\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 == 0){\n                                                map[i][j] = sos[cou];\n                                                cou++;\n                                        }\n                                }\n                        }\n                        for(int i = 0 ; i < n ; i++){\n                                for(int j = 0 ; j < n ; j++){\n                                        if((i + j) % 2 != 0){\n                                                if(j == n - 1 && i == 0){\n                                                        map[0][n - 1] = map[1][n - 1] * map[0][n - 2] + 1;\n                                                }else if(i == n - 1 && j == 0){\n                                                        map[i][j] = map[n - 2][0] * map[n - 1][1] + 1;\n                                                }else if(i == 0){\n                                                        map[0][j] = map[0][j - 1] * map[0][j + 1] * map[1][j] + 1;\n                                                }else if(i == n - 1){\n                                                        map[n - 1][j] = map[n - 2][j] * map[n - 1][j + 1] * map[n - 1][j - 1] + 1;\n                                                }else if(j == 0){\n                                                        map[i][0] = map[i - 1][0] * map[i + 1][0] * map[i][1] + 1;\n                                                }else if(j == n - 1){\n                                                        map[i][n - 1] = map[i][n - 2] * map[i - 1][n - 1] * map[i + 1][n - 1] + 1;\n                                                }else{\n                                                        map[i][j] = map[i + 1][j] * map[i - 1][j] * map[i][j + 1] * map[i][j - 1] + 1;\n                                                }\n                                        }\n                                        ou.print(map[i][j]);\n                                        if(j == n - 1) ou.print(\"\\n\");\n                                        else ou.print(\" \");\n                                }\n                        }\n                }\n                ou.flush();\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemD solver = new ProblemD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemD {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\n\t\t\tfinal int N = 1000;\n\t\t\tboolean[] isPrime = new boolean[N];\n\t\t\tList<Integer> primes = new ArrayList<>();\n\t\t\tArrays.fill(isPrime, true);\n\t\t\tfor (int i = 2; i < N; i++) {\n\t\t\t\tif (isPrime[i]) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tfor (int j = i + i; j < N; j += i) {\n\t\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tMap<Integer, Integer> fs = new HashMap();\n\t\t\tList<Integer> fromSmallPrimes = new ArrayList<>();\n\t\t\tfor (int i = 2; ; i++) {\n\t\t\t\tint x = i;\n\t\t\t\tint mf = 0;\n\t\t\t\tfor (int p : primes) {\n\t\t\t\t\tint f = 0;\n\t\t\t\t\twhile (x % p == 0) {\n\t\t\t\t\t\tx /= p;\n\t\t\t\t\t\t++f;\n\t\t\t\t\t}\n\t\t\t\t\tmf = Math.max(mf, f);\n\t\t\t\t}\n\t\t\t\tfs.put(i, mf);\n\t\t\t\tif (x == 1) {\n\t\t\t\t\tfromSmallPrimes.add(i);\n\t\t\t\t\tif (fromSmallPrimes.size() == 500 * 500 / 2) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(fromSmallPrimes, (u, v) -> (fs.get(u) - fs.get(v)));\n//\t\tSystem.out.println(\"precalc done\");\n\n//\t\tfor (int i = 2; i <= 500; i++) {\n//\t\t\tsolve(fromSmallPrimes, i);\n//\t\t\tif (i % 10 == 0) {\n//\t\t\t\tSystem.out.println(i);\n//\t\t\t}\n//\t\t}\n\t\t\tlong[][] a = solve(fromSmallPrimes, n);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t}\n\t\t\t\t\tout.print(a[i][j]);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\n\t\tprivate long[][] solve(List<Integer> fromSmallPrimes, int n) {\n\t\t\tlong[][] a = new long[n][n];\n\n\t\t\tSet<Long> set = new HashSet<>();\n\t\t\tint u = 0;\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < n; c++) {\n\t\t\t\t\tif ((r + c) % 2 == 0) {\n\t\t\t\t\t\ta[r][c] = fromSmallPrimes.get(u++);\n\t\t\t\t\t\tset.add(a[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tfor (int c = 0; c < n; c++) {\n\t\t\t\t\tif ((r + c) % 2 == 1) {\n\t\t\t\t\t\tlong cur = 1;\n\t\t\t\t\t\tfor (int dr = -1; dr <= 1; dr++) {\n\t\t\t\t\t\t\tfor (int dc = -1; dc <= 1; dc++) {\n\t\t\t\t\t\t\t\tif (dr == 0 ^ dc == 0) {\n\t\t\t\t\t\t\t\t\tint nr = r + dr;\n\t\t\t\t\t\t\t\t\tint nc = c + dc;\n\t\t\t\t\t\t\t\t\tif (nr >= 0 && nr < n && nc >= 0 && nc < n && a[nr][nc] != 0) {\n\t\t\t\t\t\t\t\t\t\tcur = lcm(cur, a[nr][nc]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong x = cur + 1;\n\t\t\t\t\t\twhile (set.contains(x)) {\n\t\t\t\t\t\t\tx += cur;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[r][c] = x;\n\t\t\t\t\t\tset.add(a[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!check(a)) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate boolean check(long[][] a) {\n\t\t\tint n = a.length;\n\t\t\tSet<Long> set = new HashSet<>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (set.contains(a[i][j])) {\n\t\t\t\t\t\tSystem.out.println(\"bad elem \" + a[i][j]);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tset.add(a[i][j]);\n\t\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\t\tlong u = a[i][j];\n\t\t\t\t\t\tlong v = a[i + 1][j];\n\t\t\t\t\t\tif (Math.max(u, v) % Math.min(u, v) != 1) {\n\t\t\t\t\t\t\tSystem.out.println(\"! \" + u + \" \" + v);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < n) {\n\t\t\t\t\t\tlong u = a[i][j];\n\t\t\t\t\t\tlong v = a[i][j + 1];\n\t\t\t\t\t\tif (Math.max(u, v) % Math.min(u, v) != 1) {\n\t\t\t\t\t\t\tSystem.out.println(\"! \" + u + \" \" + v);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn set.size() == n * n;\n\t\t}\n\n\t\tprivate long lcm(long a, long b) {\n\t\t\treturn a / gcd(a, b) * b;\n\t\t}\n\n\t\tprivate long gcd(long a, long b) {\n\t\t\treturn b == 0 ? a : gcd(b, a % b);\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tint[,]B = new int[500,500];\n\t\tint[,]C = new int[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(10000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tB[ix,iy] = 249+(ix-iy)/2;\n\t\t\t\tC[ix,iy] = 500;\n\t\t\t\tif(ix+iy>500){\n\t\t\t\t\tC[ix,iy] = ((ix+iy)-500)/2*2+499;\n\t\t\t\t} else if(ix+iy<500){\n\t\t\t\t\tC[ix,iy] = (500-(ix+iy))/2*2+500;\n\t\t\t\t}\n\t\t\t\tA[ix,iy]=(long)B[ix,iy] * (long)C[ix,iy];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t\tif(iy==500){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix==0){\n\t\t\t\t\tif(iy<499){\n\t\t\t\t\t\taa *= B[ix,iy+1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= B[ix-1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix==499){\n\t\t\t\t\tif(iy>0){\n\t\t\t\t\t\taa *= B[ix,iy-1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= B[ix+1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix==499){\n\t\t\t\t\tif(iy<499){\n\t\t\t\t\t\taa *= C[ix,iy+1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= C[ix+1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix==0){\n\t\t\t\t\tif(iy>0){\n\t\t\t\t\t\taa *= C[ix,iy-1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= C[ix-1,iy];\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tlong ix = 0;\n\t\tlong iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 2;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\twhile(true){\n\t\t\t\t\t//if(IsPrime((int)at)){\n\t\t\t\t\t\tA[ix,iy]=at;\n\t\t\t\t\t\tat += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//} else {\n\t\t\t\t\t//\tat += 1;\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy = iy + 2;\n\t\t\t\tif(iy==500){\n\t\t\t\t\tiy = 1;\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy==501){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\twhile(aa < 150000){\n\t\t\t\t\taa *= 2;\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\tpublic static bool IsPrime(int num)\n\t{\n\t\tif (num < 2) return false;\n\t\telse if (num == 2) return true;\n\t\telse if (num % 2 == 0) return false;\n\n\t\tdouble sqrtNum = Math.Sqrt(num);\n\t\tfor (int i = 3; i <= sqrtNum; i += 2){\n\t\t\tif (num % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var primes = Primes(10000).ToArray();\n        var rprimes = primes.Take(n).ToArray();\n        var cprimes = primes.Skip(n).ToArray();\n        long[][] res = Enumerable.Repeat(0, n).Select(_ => Enumerable.Repeat(1L, n).ToArray()).ToArray();\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = 0; j < n; i++, j++)\n            {\n                if (i < 0) continue;\n                res[i][j] *= rprimes[iter];\n                if (0 <= j - 1) res[i][j - 1] *= rprimes[iter];\n                if (j + 1 < n) res[i][j + 1] *= rprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + (n % 2 == 0 ? 2 : 1) + 2 * iter, j = n - 1; j >= 0; i++, j--)\n            {\n                if (i < 0) continue;\n                res[i][j] *= cprimes[iter];\n                if (0 <= j - 1) res[i][j - 1] *= cprimes[iter];\n                if (j + 1 < n) res[i][j + 1] *= cprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 2 * iter, j = 0; j < n; i++, j++)\n            {\n                if (i < 0) continue;\n                res[i][j]++;\n            }\n        }\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x))));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 124511785) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tA[ix,iy]=(long)list[(ix+iy)/2] * (long)list[250+(ix-iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tif(aa >= Math.Pow(10,15)){\n\t\t\t\t\tA[ix,iy] = -1;\n\t\t\t\t} else {\n\t\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tA[ix,iy]=(long)list[(250+(ix+iy)/2)%500] * (long)list[500+(ix-iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tA[ix,iy]=(long)list[(ix+iy)/2] * (long)list[500+(ix-iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tint a = 0;\n\t\t\t\tif(ix>iy){\n\t\t\t\t\ta = (ix-iy)/2*2-1;\n\t\t\t\t} else {\n\t\t\t\t\ta = (iy-ix)/2*2;\n\t\t\t\t}\n\t\t\t\tA[ix,iy]=(long)list[a] * (long)list[500+(ix+iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong[,]B = new long[500,500];\n\t\tlong[,]C = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(10000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tB[ix,iy] = list[249+(ix-iy)/2];\n\t\t\t\tC[ix,iy] = list[500];\n\t\t\t\tif(ix+iy>500){\n\t\t\t\t\tC[ix,iy] = list[((ix+iy)-500)/2*2+499];\n\t\t\t\t} else if(ix+iy<500){\n\t\t\t\t\tC[ix,iy] = list[(500-(ix+iy))/2*2+500];\n\t\t\t\t}\n\t\t\t\tA[ix,iy]=(long)B[ix,iy] * (long)C[ix,iy];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t\tif(iy==500){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix==0){\n\t\t\t\t\tif(iy<499){\n\t\t\t\t\t\taa *= B[ix,iy+1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= B[ix-1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix==499){\n\t\t\t\t\tif(iy>0){\n\t\t\t\t\t\taa *= B[ix,iy-1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= B[ix+1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix==499){\n\t\t\t\t\tif(iy<499){\n\t\t\t\t\t\taa *= C[ix,iy+1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= C[ix+1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix==0){\n\t\t\t\t\tif(iy>0){\n\t\t\t\t\t\taa *= C[ix,iy-1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taa *= C[ix-1,iy];\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tA[ix,iy]=(long)list[(ix+iy)/2] * (long)list[250+(ix-iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var primes = Primes((int)Floor(Pow(10, 15.0 / 6))).Take(60).ToArray();\n        var rprimes = primes.Take(30).ToArray();\n        var cprimes = primes.Skip(30).ToArray();\n        var rseq = generateSequence(30).Select(x => (long)rprimes[x]).ToArray();\n        var cseq = generateSequence(30).Select(x => (long)cprimes[x]).ToArray();\n        long[][] res = Enumerable.Repeat(0, n).Select(_ => new long[n]).ToArray();\n        //a/p q r\n        //   AB..\n        // b CD..\n        //   ....\n        // c ....\n        //  \n        // A = a * b * p * q + 1\n        // B = q * a * b\n        // C = p * q * b\n        // D = p * q * r * a * b * c + 1\n        \n        // A\n        for (int i = 0; i < n; i += 2)\n            for (int j = 0; j < n; j += 2)\n            {\n                //A\n                res[i][j] = rseq[i / 2] * cseq[j / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1] + 1;\n                //B\n                if (j + 1 < n) res[i][j + 1] = cseq[j / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1];\n                //C\n                if (i + 1 < n) res[i + 1][j] = rseq[i / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1];\n                //D\n                if (i + 1 < n && j + 1 < n) res[i + 1][j + 1] = rseq[i / 2] * cseq[j / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1] * rseq[i / 2 + 2] * cseq[j / 2 + 2] + 1;\n            }\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x))));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 124511785) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n    static List<int> generateSequence(int count)\n    {\n        HashSet<int>[] remainNeighbour = Enumerable.Repeat(0, count).Select(_ => new HashSet<int>(Enumerable.Range(0, count))).ToArray();\n        for (int i = 0; i < count; i++) remainNeighbour[i].Remove(i);\n        RandomizedQueue<int>[] rqueues = remainNeighbour.Select(x => new RandomizedQueue<int>(x)).ToArray();\n        List<int> res = new List<int>() { 0 };\n        while (true)\n        {\n            var last = res.Last();\n            if (remainNeighbour[last].Count == 0) break;\n            var next = rqueues[last].Pop();\n            if (!remainNeighbour[next].Contains(last)) continue;\n            remainNeighbour[last].Remove(next);\n            remainNeighbour[next].Remove(last);\n            res.Add(next);\n        }\n        return res;\n    }\n}\n\n\nclass RandomizedQueue<T>\n{\n    int front;\n    T[] datas;\n    Random RNG = new Random();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public RandomizedQueue(int defaultSize = 512) { datas = new T[defaultSize]; }\n    public RandomizedQueue(IEnumerable<T> values) { datas = values.ToArray(); front = datas.Length; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Add(T data)\n    {\n        if (front >= datas.Length) Extend(datas.Length * 2);\n        datas[front++] = data;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Pop()\n    {\n        ValidateNonEmpty();\n        var index = RNG.Next() % front;\n        var data = datas[index];\n        datas[index] = datas[--front];\n        return data;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Extend(int newSize)\n    {\n        T[] newDatas = new T[newSize];\n        datas.CopyTo(newDatas, 0);\n        datas = newDatas;\n    }\n    private void ValidateNonEmpty() { if (front == 0) throw new Exception(); }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tint a = 0;\n\t\t\t\tif(ix>iy){\n\t\t\t\t\ta = (ix-iy)/2*2-1;\n\t\t\t\t} else {\n\t\t\t\t\ta = (iy-ix)/2*2;\n\t\t\t\t}\n\t\t\t\tA[ix,iy]=(long)list[a] * (long)list[500+(ix+iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t\tif(iy==500){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n    int P = 500;\n    List<long> plist;\n\n    int[] vy = { 1, 0, -1, 0 };\n    int[] vx = { 0, 1, 0, -1 };\n\n    long[] xar, yar;\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n\n        plist = new List<long>();\n        for (int i = 2; plist.Count < P * 4; i++)\n        {\n            if(isPrime(i)) plist.Add(i);\n        }\n\n        xar = new long[P * 2];\n        yar = new long[P * 2];\n\n        for (int i = 0; i < P; i++)\n        {\n            xar[(i * 4 % (P * 2)) + ((i * 4) / (P * 2)) * 2] = plist[i];\n            yar[i * 2] = plist[P * 2 + i];\n        }\n\n\n        long[,] ans = new long[P, P];\n\n        for (int i = 0; i < P; i++)\n        {\n            for (int j = 0; j < P; j++)\n            {\n                if ((i + j) % 2 == 0)\n                {\n                    ans[i, j] = yar[i + j] * xar[(i - j) + P];\n                }\n            }\n        }\n\n\n\n        long maxnext = 0;\n        for (int i = 0; i < P; i++)\n        {\n            for (int j = 0; j < P; j++)\n            {\n                if (ans[i,j] == 0)\n                {\n                    long next = 1;\n                    int A = i + j;\n                    int B = (i - j) + P;\n                    if (A != 0) next *= yar[A - 1];\n                    next *= yar[A + 1];\n\n                    if (B != 0) next *= xar[B - 1];\n                    if( B != xar.Length - 1) next *= xar[B + 1];\n\n                    next += 1;\n                    ans[i, j] = next;\n                    maxnext = Math.Max(next, maxnext);\n                }\n            }\n        }\n\n        Dictionary<long, int> dic = new Dictionary<long, int>();\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if ((i + j) % 2 == 0)\n                {\n                    if (dic.ContainsKey(ans[i, j]))\n                    {\n                        Console.WriteLine(\"!?1 \" + ans[i, j]);\n                    }\n                    dic[ans[i, j]] = 1;\n                }\n            }\n        }\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if ((i + j) % 2 == 1)\n                {\n                    if (dic.ContainsKey(ans[i, j]))\n                    {\n                        Console.WriteLine(\"!?2 \" + ans[i, j]);\n                    }\n                    dic[ans[i, j]] = 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N - 1; j++)\n            {\n                long MAX = Math.Max(ans[i, j], ans[i, j + 1]);\n                long MIN = Math.Min(ans[i, j], ans[i, j + 1]);\n                if (MAX % MIN != 1) Console.WriteLine(\"!? \" + MAX + \" \" + MIN + \" \" + (MAX % MIN));\n            }\n        }\n\n\n        for (int i = 0; i < N - 1; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                long MAX = Math.Max(ans[i, j], ans[i + 1, j]);\n                long MIN = Math.Min(ans[i, j], ans[i + 1, j]);\n                if (MAX % MIN != 1) Console.WriteLine(\"!? \" + MAX + \" \" + MIN + \" \" + (MAX % MIN));\n            }\n        }\n\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                Console.Write(ans[i,j] + \" \");\n            }\n            Console.WriteLine();\n        }\n\n        //Console.WriteLine(maxnext);\n        //Console.WriteLine((long)1e15);\n    }\n\n    bool inside(int y, int x)\n    {\n        return y >= 0 && x >= 0 && y < P && x < P;\n    }\n    \n    bool isPrime(long a)\n    {\n        if (a < 2) return false;\n        long i;\n        for (i = 2; i * i <= a; i++)\n        {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    long gcd(long a, long b)\n    {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b)\n    {\n        return a / gcd(a, b) * b;\n    }\n\n}\n\n\n\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tA[ix,iy]=(long)list[(ix+iy)/2] * (long)list[500+(ix-iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        var max = 500;\n        var primes = Primes(10000).ToArray();\n        var rprimes = primes.Take(max).ToArray();\n        var cprimes = primes.Skip(max).ToArray();\n        long[][] res = Enumerable.Repeat(0, max).Select(_ => Enumerable.Repeat(1L, max).ToArray()).ToArray();\n\n        for (int iter = 0; iter < max; iter++)\n        {\n            for (int i = -max + 2 + 2 * iter, j = 0; i <= max && j < max; i++, j++)\n            {\n                if (0 <= i - 1 && i - 1 < max) res[i - 1][j] *= rprimes[iter];\n                if (0 <= i + 1 && i + 1 < max) res[i + 1][j] *= rprimes[iter];\n                if (i < 0 || max <= i) continue;\n                res[i][j] *= rprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < max; iter++)\n        {\n            for (int i = -max + 1 + 2 * iter, j = max - 1; i <= max && j >= 0; i++, j--)\n            {\n                if (0 <= i - 1 && i - 1 < max) res[i - 1][j] *= cprimes[iter];\n                if (0 <= i + 1 && i + 1 < max) res[i + 1][j] *= cprimes[iter];\n                if (i < 0 || max <= i) continue;\n                res[i][j] *= cprimes[iter];\n            }\n        }\n        for (int iter = 0; iter < max; iter++)\n        {\n            for (int i = -max + 1 + 2 * iter, j = 0; i < max && j < max; i++, j++)\n            {\n                if (i < 0) continue;\n                res[i][j]++;\n            }\n        }\n        var n = int.Parse(Console.ReadLine());\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x.Take(n))).Take(n)));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 124511785) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var primes = Primes(10000).ToArray();\n        var rprimes = primes.Take(n).ToArray();\n        var cprimes = primes.Skip(n).ToArray();\n        long[][] res = Enumerable.Repeat(0, n).Select(_ => Enumerable.Repeat(1L, n).ToArray()).ToArray();\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + (n % 2 == 0 ? 2 : 1) + 2 * iter, j = 0; i < n && j < n; i++, j++)\n            {\n                if (0 <= i - 1 && i - 1 < n) res[i - 1][j] *= rprimes[iter];\n                if (0 <= i + 1 && i + 1 < n) res[i + 1][j] *= rprimes[iter];\n                if (i < 0 || n <= i) continue;\n                res[i][j] *= rprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = n - 1; i <= n && j >= 0; i++, j--)\n            {\n                if (0 <= i - 1 && i - 1 < n) res[i - 1][j] *= cprimes[iter];\n                if (0 <= i + 1 && i + 1 < n) res[i + 1][j] *= cprimes[iter];\n                if (i < 0 || n <= i) continue;\n                res[i][j] *= cprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = 0; i < n && j < n; i++, j++)\n            {\n                if (i < 0) continue;\n                res[i][j]++;\n            }\n        }\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x))));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 124511785) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var primes = Primes(10000).ToArray();\n        var rprimes = primes.Take(n).ToArray();\n        var cprimes = primes.Skip(n).ToArray();\n        long[][] res = Enumerable.Repeat(0, n).Select(_ => Enumerable.Repeat(1L, n).ToArray()).ToArray();\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + (n % 2 == 0 ? 2 : 1) + 2 * iter, j = 0; i <= n && j < n; i++, j++)\n            {\n                if (0 <= i - 1 && i - 1 < n) res[i - 1][j] *= rprimes[iter];\n                if (0 <= i + 1 && i + 1 < n) res[i + 1][j] *= rprimes[iter];\n                if (i < 0 || n <= i) continue;\n                res[i][j] *= rprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = n - 1; i <= n && j >= 0; i++, j--)\n            {\n                if (0 <= i - 1 && i - 1 < n) res[i - 1][j] *= cprimes[iter];\n                if (0 <= i + 1 && i + 1 < n) res[i + 1][j] *= cprimes[iter];\n                if (i < 0 || n <= i) continue;\n                res[i][j] *= cprimes[iter];\n            }\n        }\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = 0; i < n && j < n; i++, j++)\n            {\n                if (i < 0) continue;\n                res[i][j]++;\n            }\n        }\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x))));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 124511785) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tlong ix = 0;\n\t\tlong iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 2;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(IsPrime((int)at)){\n\t\t\t\t\t\tA[ix,iy]=at;\n\t\t\t\t\t\tat += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tat += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa *= A[ix-1,iy];\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa *= A[ix+1,iy];\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa *= A[ix,iy-1];\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa *= A[ix,iy+1];\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa+1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\tpublic static bool IsPrime(int num)\n\t{\n\t\tif (num < 2) return false;\n\t\telse if (num == 2) return true;\n\t\telse if (num % 2 == 0) return false;\n\n\t\tdouble sqrtNum = Math.Sqrt(num);\n\t\tfor (int i = 3; i <= sqrtNum; i += 2){\n\t\t\tif (num % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tint a = 0;\n\t\t\t\tif(ix>iy){\n\t\t\t\t\ta = (ix-iy)/2*2+1;\n\t\t\t\t} else {\n\t\t\t\t\ta = (iy-ix)/2*2+2;\n\t\t\t\t}\n\t\t\t\tA[ix,iy]=(long)list[a] * (long)list[500+(ix+iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tint a = 0;\n\t\t\t\tif(ix>iy){\n\t\t\t\t\ta = (ix-iy)/2*2-1;\n\t\t\t\t} else {\n\t\t\t\t\ta = (iy-ix)/2*2;\n\t\t\t\t}\n\t\t\t\tint b = 0;\n\t\t\t\tif(ix+iy>500){\n\t\t\t\t\tb = ((ix+iy)-500)/2*2+499;\n\t\t\t\t} else {\n\t\t\t\t\tb = (500-(ix+iy))/2*2+500;\n\t\t\t\t}\n\t\t\t\tA[ix,iy]=(long)list[a] * (long)list[b];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t\tif(iy==500){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\n\nstatic class P\n{\n    static void Main()\n    {\n        DateTime start = DateTime.Now;\n        int n = int.Parse(Console.ReadLine());\n        Matrix a = new Matrix(n, n);\n        Matrix b = new Matrix(n, n);\n        Matrix c = new Matrix(n, n);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                a[i, j] = Read();\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                b[i, j] = Read();\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                c[i, j] = Read();\n        bool flag = true;\n        for (int i = 0; i < 100; i++)\n        {\n            var randomVector = GetRandomVector(n);\n            if (a * (b * randomVector) != c * randomVector) flag = false;\n        }\n        Console.WriteLine(flag ? \"YES\" : \"NO\");\n    }\n    static Random RNG = new Random(1333);\n    static Matrix GetRandomVector(int n)\n    {\n        Matrix res = new Matrix(n, 1);\n        for (int i = 0; i < n; i++) res[i, 0] = RNG.Next() & 1;\n        return res;\n    }\n\n    static readonly TextReader In = Console.In;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    static int Read()\n    {\n        int res = 0;\n        int next = In.Read();\n        int sign = 1;\n        while (45 > next || next > 57) next = In.Read();\n        while (45 <= next && next < 48)\n        {\n            sign = -1;\n            next = In.Read();\n        }\n        while (48 <= next && next <= 57)\n        {\n            res = res * 10 + next - 48;\n            next = In.Read();\n        }\n        return res * sign;\n    }\n}\nclass Matrix : IEquatable<Matrix>\n{\n    public readonly int Height;\n    public readonly int Width;\n    long[,] data;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public Matrix(int height, int width)\n    {\n        data = new long[height, width];\n        Height = height;\n        Width = width;\n    }\n    public long this[int i, int j]\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get { return data[i, j]; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        set { data[i, j] = value; }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public bool Equals(Matrix other)\n    {\n        if (this.Width != other.Width || this.Height != other.Height) return false;\n        for (int i = 0; i < Height; i++) for (int j = 0; j < Width; j++) if (this[i, j] != other[i, j]) return false;\n        return true;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Matrix Add(Matrix a, Matrix b)\n    {\n        Debug.Assert(a.Width == b.Width && a.Height == b.Height);\n        var res = new Matrix(a.Height, a.Width);\n        for (int i = 0; i < a.Height; i++) for (int j = 0; j < a.Width; j++) res[i, j] = a[i, j] + b[i, j];\n        return res;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Matrix Sub(Matrix a, Matrix b)\n    {\n        Debug.Assert(a.Width == b.Width && a.Height == b.Height);\n        var res = new Matrix(a.Height, a.Width);\n        for (int i = 0; i < a.Height; i++) for (int j = 0; j < a.Width; j++) res[i, j] = a[i, j] - b[i, j];\n        return res;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Matrix Mul(Matrix a, Matrix b)\n    {\n        Debug.Assert(a.Width == b.Height);\n        var res = new Matrix(a.Height, b.Width);\n        for (int i = 0; i < a.Height; i++) for (int j = 0; j < b.Width; j++) for (int k = 0; k < a.Width; k++) res[i, j] += a[i, k] * b[k, j];\n        return res;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Matrix operator +(Matrix a, Matrix b) => Add(a, b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Matrix operator -(Matrix a, Matrix b) => Sub(a, b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Matrix operator *(Matrix a, Matrix b) => Mul(a, b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool operator ==(Matrix a, Matrix b) => a.Equals(b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool operator !=(Matrix a, Matrix b) => !a.Equals(b);\n}\n\n[StructLayout(LayoutKind.Explicit)]\nclass Random\n{\n    [FieldOffset(0)]\n    private byte __byte;\n    [FieldOffset(0)]\n    private sbyte __sbyte;\n    [FieldOffset(0)]\n    private char __char;\n    [FieldOffset(0)]\n    private short __short;\n    [FieldOffset(0)]\n    private ushort __ushort;\n    [FieldOffset(0)]\n    private int __int;\n    [FieldOffset(0)]\n    private uint __uint;\n    [FieldOffset(0)]\n    private long __long;\n    [FieldOffset(0)]\n    private ulong __ulong;\n\n    public byte Byte { get { Update(); return __byte; } }\n    public sbyte SByte { get { Update(); return __sbyte; } }\n    public char Char { get { Update(); return __char; } }\n    public short Short { get { Update(); return __short; } }\n    public ushort UShort { get { Update(); return __ushort; } }\n    public int Int { get { Update(); return __int; } }\n    public uint UInt { get { Update(); return __uint; } }\n    public long Long { get { Update(); return __long; } }\n    public ulong ULong { get { Update(); return __ulong; } }\n    public double Double { get { return (double)ULong / ulong.MaxValue; } }\n\n    [FieldOffset(0)]\n    private ulong _xorshift;\n\n    public Random() : this((ulong)DateTime.Now.Ticks) { }\n    public Random(ulong seed) { SetSeed(seed); }\n    public void SetSeed(ulong seed) => _xorshift = seed * 0x3141592c0ffeeul;\n\n    public int Next() => Int & 2147483647;\n    public void Update()\n    {\n        _xorshift ^= _xorshift << 7;\n        _xorshift ^= _xorshift >> 9;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var primes = Primes(10000).ToArray();\n        var rprimes = primes.Take(n).ToArray();\n        var cprimes = primes.Skip(n).ToArray();\n        long[][] res = Enumerable.Repeat(0, n).Select(_ => Enumerable.Repeat(1L, n).ToArray()).ToArray();\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + (n % 2 == 0 ? 2 : 1) + 2 * iter, j = 0; i < n && j < n; i++, j++)\n            {\n                if (0 <= i - 1 && i - 1 < n) res[i - 1][j] *= rprimes[iter];\n                if (0 <= i + 1 && i + 1 < n) res[i + 1][j] *= rprimes[iter];\n                if (i < 0 || n <= i) continue;\n                res[i][j] *= rprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = n - 1; i <= n && j >= 0; i++, j--)\n            {\n                if (0 <= i - 1 && i - 1 < n) res[i - 1][j] *= rprimes[iter];\n                if (0 <= i + 1 && i + 1 < n) res[i + 1][j] *= rprimes[iter];\n                if (i < 0 || n <= i) continue;\n                res[i][j] *= cprimes[iter];\n            }\n        }\n\n        for (int iter = 0; iter < n; iter++)\n        {\n            for (int i = -n + 1 + 2 * iter, j = 0; i < n && j < n; i++, j++)\n            {\n                if (i < 0) continue;\n                res[i][j]++;\n            }\n        }\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x))));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 124511785) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tlong ix = 0;\n\t\tlong iy = 0;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 2;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\twhile(true){\n\t\t\t\t\t//if(IsPrime((int)at)){\n\t\t\t\t\t\tA[ix,iy]=at;\n\t\t\t\t\t\tat += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t//} else {\n\t\t\t\t\t//\tat += 1;\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy = iy + 2;\n\t\t\t\tif(iy==500){\n\t\t\t\t\tiy = 1;\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy==501){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\tA[ix,iy] = aa+1;\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\tpublic static bool IsPrime(int num)\n\t{\n\t\tif (num < 2) return false;\n\t\telse if (num == 2) return true;\n\t\telse if (num % 2 == 0) return false;\n\n\t\tdouble sqrtNum = Math.Sqrt(num);\n\t\tfor (int i = 3; i <= sqrtNum; i += 2){\n\t\t\tif (num % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tint ix = 0;\n\t\tint iy = 499;\n\t\tlong m = 2;\n\t\tlong t = m;\n\t\tlong h = 1;\n\t\tlong[,]A = new long[500,500];\n\t\tlong at = 0;\n\t\tvar list = GeneratePrime(100000);\n\t\tConsole.WriteLine(list[0]);\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==0){\n\t\t\t\tA[ix,iy]=(long)list[(ix+iy)/2] * (long)list[250+(ix-iy)/2];\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tif(iy%2==1){\n\t\t\t\t\tiy = iy - 2;\n\t\t\t\t\tif(iy==-1){\n\t\t\t\t\t\tiy = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiy = iy + 2;\n\t\t\t\t\tif(iy==500){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t}\n\t\tix = 0;\n\t\tiy = 0;\n\t\twhile(true){\n\t\t\tif((ix+iy)%2==1){\n\t\t\t\tlong aa = 1;\n\t\t\t\tif(ix>0){\n\t\t\t\t\taa = Lcm(aa,A[ix-1,iy]);\n\t\t\t\t}\n\t\t\t\tif(ix<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix+1,iy]);\n\t\t\t\t}\n\t\t\t\tif(iy>0){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy-1]);\n\t\t\t\t}\n\t\t\t\tif(iy<500-1){\n\t\t\t\t\taa = Lcm(aa,A[ix,iy+1]);\n\t\t\t\t}\n\t\t\t\twhile(aa < 150000){\n\t\t\t\t\taa *= 2;\n\t\t\t\t}\n\t\t\t\tif(aa >= Math.Pow(10,15)){\n\t\t\t\t\tA[ix,iy] = -1;\n\t\t\t\t} else {\n\t\t\t\t\tA[ix,iy] = aa + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tix += 1;\n\t\t\tif(ix>=500){\n\t\t\t\tiy += 1;\n\t\t\t\tix = 0;\n\t\t\t}\n\t\t\tif(iy>=500){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<N;i++){\n\t\t\tstring str = \"\";\n\t\t\tstr += A[0,i];\n\t\t\tfor(var j=1;j<N;j++){\n\t\t\t\tstr += \" \" + A[j,i];\n\t\t\t}\n\t\t\tConsole.WriteLine(str);\n\t\t}\n\t}\n\t\n\tpublic static List<int> GeneratePrime(int max)\n\t{\n\t\tSystem.Diagnostics.Debug.Assert(max >= 2);\n\t\tint prime;\n\t\tdouble sqrtMax = Math.Sqrt(max);\n\t\tvar primeList = new List<int>();\n\t\tvar searchList = Enumerable.Range(2, max - 1).ToList();\n\t\tdo\n\t\t{\n\t\t\tprime = searchList.First();\n\t\t\tprimeList.Add(prime);\n\t\t\tsearchList.RemoveAll(n => n % prime == 0);\n\t\t} while (prime < sqrtMax);\n\t\tprimeList.AddRange(searchList);\n\t\treturn primeList;\n\t}\n\t\n\tpublic static long Lcm(long a, long b) {\n        return a * b / Gcd(a, b);\n    }\n\tpublic static long Gcd(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn Gcd(b, a);\n\t\twhile (b != 0) {\n\t\t\tvar r = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;\nusing FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        var primes = Primes((int)Floor(Pow(10, 15.0 / 6))).Take(60).ToArray();\n        var rprimes = primes.Take(30).ToArray();\n        var cprimes = primes.Skip(30).ToArray();\n        var rseq = generateSequence(30).Select(x => (long)rprimes[x]).ToArray();\n        var cseq = generateSequence(30).Select(x => (long)cprimes[x]).ToArray();\n        long[][] res = Enumerable.Repeat(0, n).Select(_ => new long[n]).ToArray();\n        //a/p q r\n        //   AB..\n        // b CD..\n        //   ....\n        // c ....\n        //  \n        // A = a * b * p * q + 1\n        // B = q * a * b\n        // C = p * q * b\n        // D = p * q * r * a * b * c + 1\n        \n        // A\n        for (int i = 0; i < n; i += 2)\n            for (int j = 0; j < n; j += 2)\n            {\n                //A\n                res[i][j] = rseq[i / 2] * cseq[j / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1] + 1;\n                //B\n                if (j + 1 < n) res[i][j + 1] = cseq[j / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1];\n                //C\n                if (i + 1 < n) res[i + 1][j] = rseq[i / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1];\n                //D\n                if (i + 1 < n && j + 1 < n) res[i + 1][j + 1] = rseq[i / 2] * cseq[j / 2] * rseq[i / 2 + 1] * cseq[j / 2 + 1] * rseq[i / 2 + 2] * cseq[j / 2 + 2] + 1;\n            }\n        Console.WriteLine(string.Join(\"\\n\", res.Select(x => string.Join(\" \", x))));\n    }\n\n    public static IEnumerable<int> Primes(int n)\n    {\n        if (n <= 32)\n        {\n            int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n            for (int i = 0; i < primes.Length; i++)\n            {\n                if (n < primes[i]) break;\n                else yield return primes[i];\n            }\n            yield break;\n        }\n\n        yield return 2;\n        int sup = (n + 1) / 32 / 2 + 1;\n        uint[] isp = new uint[sup];\n\n        int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\n        for (int i = 0; i < tprimes.Length; i++)\n        {\n            var tp = tprimes[i];\n            yield return tp;\n            uint[] ptn = new uint[tp];\n            for (int j = (tp - 3) / 2; j < (tp << 5); j += tp) ptn[j >> 5] |= 1U << (j & 31);\n            for (int j = 0; j < tp; j++) for (int l = j; l < sup; l += tp) isp[l] |= ptn[j];\n        }\n\n        int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };\n        int h = n / 2;\n        for (int i = 0; i < sup; i++)\n        {\n            for (uint j = ~isp[i]; j != 0; j &= j - 1)\n            {\n                int pp = i << 5 | magic[((uint)(j & -j) * 0b0000111011010111110011000101001U) >> 27];\n                int p = 2 * pp + 3;\n                if (p > n) break;\n                yield return p;\n                for (int q = pp; q <= h; q += p) isp[q >> 5] |= 1U << (q & 31);\n            }\n        }\n    }\n    static List<int> generateSequence(int count)\n    {\n        HashSet<int>[] remainNeighbour = Enumerable.Repeat(0, count).Select(_ => new HashSet<int>(Enumerable.Range(0, count))).ToArray();\n        for (int i = 0; i < count; i++) remainNeighbour[i].Remove(i);\n        RandomizedQueue<int>[] rqueues = remainNeighbour.Select(x => new RandomizedQueue<int>(x)).ToArray();\n        List<int> res = new List<int>() { 0 };\n        while (true)\n        {\n            var last = res.Last();\n            if (remainNeighbour[last].Count == 0) break;\n            var next = rqueues[last].Pop();\n            if (!remainNeighbour[next].Contains(last)) continue;\n            remainNeighbour[last].Remove(next);\n            remainNeighbour[next].Remove(last);\n            res.Add(next);\n        }\n        return res;\n    }\n}\n\n\nclass RandomizedQueue<T>\n{\n    int front;\n    T[] datas;\n    Random RNG = new Random();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public RandomizedQueue(int defaultSize = 512) { datas = new T[defaultSize]; }\n    public RandomizedQueue(IEnumerable<T> values) { datas = values.ToArray(); front = datas.Length; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Add(T data)\n    {\n        if (front >= datas.Length) Extend(datas.Length * 2);\n        datas[front++] = data;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Pop()\n    {\n        ValidateNonEmpty();\n        var index = RNG.Next() % front;\n        var data = datas[index];\n        datas[index] = datas[--front];\n        return data;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Extend(int newSize)\n    {\n        T[] newDatas = new T[newSize];\n        datas.CopyTo(newDatas, 0);\n        datas = newDatas;\n    }\n    private void ValidateNonEmpty() { if (front == 0) throw new Exception(); }\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n# IS_DEBUG = true\nIS_DEBUG = false\ndef dputs str\n\tif(IS_DEBUG)\n\t\tputs str\n\tend\nend\ndef dpp str\n\tif(IS_DEBUG)\n\t\tpp str\n\tend\nend\n\n\ndef gcd(a,b)\n\tif(a>b)\n\t\treturn gcd(b,a)\n\tend\n\twhile(b%a != 0)\n\t\ttmp = a\n\t\ta = b%a\n\t\tb = tmp\n\tend\n\treturn a\nend\ndef lcm(a,b)\n\ta/gcd(a,b)*b\nend\n\n\nN,_=gets.chomp.split(' ').map{|n| n.to_i}\n\nA=Array.new(N) { |i| Array.new(N) {1} }\n\nP=Array.new(100001) {true}\nP[0]=P[1]=false\nfor i in 2..(100000)\n\tif(P[i])\n\t\t(i+i).step(100000, i){|j|\n\t\t\tP[j] = false\n\t\t}\n\tend\nend\n@pi = 0\ndef get\n\t@pi += 1\n\twhile(!P[@pi])\n\t\t@pi += 1\n\tend\n\t@pi\nend\n\n0.step(2*N-2,2){|n|\n\tval = get\n\tdputs \"left down line #{val}\"\n\tfor i in 0..n\n\t\tj = n-i\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n}\nval = get\ndputs \"right down line #{val}\"\nfor i in 0..(N-1)\n\tj = i\n\tif(0<=i && i<N && 0<=j && j<N)\n\t\tA[i][j] *= val\n\tend\nend\n2.step(N-1,2){|d|\n\tval = get\n\tdputs \"right down line #{val}\"\n\tfor i in 0..(N-1)\n\t\tj = i+d\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n\tval = get\n\tdputs \"right down line #{val}\"\n\tfor i in 0..(N-1)\n\t\tj = i-d\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n}\nfor i in 0..(N-1)\n\tfor j in 0..(N-1)\n\t\tif(A[i][j]==1)\n\t\t\tnei = []\n\t\t\tnei << A[i-1][j] if(i>0)\n\t\t\tnei << A[i+1][j] if(i<N-1)\n\t\t\tnei << A[i][j-1] if(j>0)\n\t\t\tnei << A[i][j+1] if(j<N-1)\n\t\t\tA[i][j] = nei.inject(1){|a,sum| lcm(sum,a)} + 1\n\t\tend\n\tend\nend\n\nputs A.map{|a| a.join(\" \")}.join(\"\\n\")\n"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n# IS_DEBUG = true\nIS_DEBUG = false\ndef dputs str\n\tif(IS_DEBUG)\n\t\tputs str\n\tend\nend\ndef dpp str\n\tif(IS_DEBUG)\n\t\tpp str\n\tend\nend\n\n\ndef gcd(a,b)\n\tif(a>b)\n\t\treturn gcd(b,a)\n\tend\n\twhile(b%a != 0)\n\t\ttmp = a\n\t\ta = b%a\n\t\tb = tmp\n\tend\n\treturn a\nend\ndef lcm(a,b)\n\ta/gcd(a,b)*b\nend\n\n\nN,_=gets.chomp.split(' ').map{|n| n.to_i}\n\nA=Array.new(N) { |i| Array.new(N) {1} }\n\nP=Array.new(100001) {true}\nP[0]=P[1]=false\nfor i in 2..(100000)\n\tif(P[i])\n\t\t(i+i).step(100000, i){|j|\n\t\t\tP[j] = false\n\t\t}\n\tend\nend\n@pi = 0\ndef get\n\t@pi += 1\n\twhile(!P[@pi])\n\t\t@pi += 1\n\tend\n\t@pi\nend\n\n0.step(2*N-2,2){|n|\n\tval = get\n\tdputs \"left down line #{val}\"\n\tfor i in 0..n\n\t\tj = n-i\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n}\nval = get\ndputs \"right down line #{val}\"\nfor i in 0..(N-1)\n\tj = i\n\tif(0<=i && i<N && 0<=j && j<N)\n\t\tA[i][j] *= val\n\tend\nend\n2.step(N-1,2){|d|\n\tval = get\n\tdputs \"right down line #{val}\"\n\tfor i in 0..(N-1)\n\t\tj = i+d\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n\tval = get\n\tdputs \"right down line #{val}\"\n\tfor i in 0..(N-1)\n\t\tj = i-d\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n}\nfor i in 0..(N-1)\n\tfor j in 0..(N-1)\n\t\tif(A[i][j]==1)\n\t\t\tnei = []\n\t\t\tnei << A[i-1][j] if(i>0)\n\t\t\tnei << A[i+1][j] if(i<N-1)\n\t\t\tnei << A[i][j-1] if(j>0)\n\t\t\tnei << A[i][j+1] if(j<N-1)\n\t\t\tA[i][j] = nei.inject(1){|a,sum| lcm(sum,a)} + 1\n\t\tend\n\tend\nend\n\nputs A.map{|a| a.join(\" \")}.join(\"\\n\")\n"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nN = 500\n\nprimes = Prime.each(10000).to_a\nans = Array.new(N+1){Array.new(N+1, 1)}\n\nN.times do |i|\n    N.times do |j|\n        if (i+j)%2 == 0\n            ans[i][j] *= primes[(i+j)/2] * primes[(i-j+N-1)/2+N]\n        end\n    end\nend\n\nN.times do |i|\n    N.times do |j|\n        if (i+j)%2 == 1\n            [[i+1, j], [i-1, j], [i, j-1], [i, j+1]].each do |x, y|\n                ans[i][j] = ans[i][j].lcm(ans[x][y])\n            end\n            ans[i][j] += 1\n        end\n    end\nend\n\nn = gets.to_i\nn.times do |i|\n    puts ans[i][0, n].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nN = gets.to_i\n\nprimes = Prime.each(10000).to_a\nans = Array.new(N+1){Array.new(N+1, 1)}\n\nN.times do |i|\n    N.times do |j|\n        if (i+j)%2 == 0\n            ans[i][j] *= primes[(i+j)/2] * primes[(i-j+N-1)/2+N]\n        end\n    end\nend\n\nN.times do |i|\n    N.times do |j|\n        if (i+j)%2 == 1\n            [[i+1, j], [i-1, j], [i, j-1], [i, j+1]].each do |x, y|\n                ans[i][j] = ans[i][j].lcm(ans[x][y])\n            end\n            ans[i][j] += 1\n        end\n    end\nend\n\nN.times do |i|\n    puts ans[i][0, N].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "n = nn = gets.to_i\nprime=[2, 3, 5, 7,11,13,17,19,23,29,31,37,41]\npp = prime.inject(:*)/41/37/31;\n\nl = 42\nr = 41 + n\nres =[]\nwhile ( nn > 0)\n  res << (l..r).map{|x| pp*x}\n  nn-=1\n  l += n\n  r += n\nend\nputs res.map{|x|x*\" \"}"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n# IS_DEBUG = true\nIS_DEBUG = false\ndef dputs str\n\tif(IS_DEBUG)\n\t\tputs str\n\tend\nend\ndef dpp str\n\tif(IS_DEBUG)\n\t\tpp str\n\tend\nend\n\n\ndef gcd(a,b)\n\tif(a>b)\n\t\treturn gcd(b,a)\n\tend\n\twhile(b%a != 0)\n\t\ttmp = a\n\t\ta = b%a\n\t\tb = tmp\n\tend\n\treturn a\nend\ndef lcm(a,b)\n\ta/gcd(a,b)*b\nend\n\n\nN,_=gets.chomp.split(' ').map{|n| n.to_i}\n\nA=Array.new(N) { |i| Array.new(N) {1} }\n\nP=Array.new(100001) {true}\nP[0]=P[1]=false\nfor i in 2..(100000)\n\tif(P[i])\n\t\t(i+i).step(100000, i){|j|\n\t\t\tP[j] = false\n\t\t}\n\tend\nend\n@pi = 0\ndef get\n\t@pi += 1\n\twhile(!P[@pi])\n\t\t@pi += 1\n\tend\n\t@pi\nend\n\n0.step(2*N-2,2){|n|\n\tval = get\n\tdputs \"left down line #{val}\"\n\tfor i in 0..n\n\t\tj = n-i\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n}\nval = get\ndputs \"right down line #{val}\"\nfor i in 0..(N-1)\n\tj = i\n\tif(0<=i && i<N && 0<=j && j<N)\n\t\tA[i][j] *= val\n\tend\nend\n2.step(N-1,2){|d|\n\tval = get\n\tdputs \"right down line #{val}\"\n\tfor i in 0..(N-1)\n\t\tj = i+d\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n\tval = get\n\tdputs \"right down line #{val}\"\n\tfor i in 0..(N-1)\n\t\tj = i-d\n\t\tif(0<=i && i<N && 0<=j && j<N)\n\t\t\tA[i][j] *= val\n\t\tend\n\tend\n}\nfor i in 0..(N-1)\n\tfor j in 0..(N-1)\n\t\tif(A[i][j]==1)\n\t\t\tnei = []\n\t\t\tnei << A[i-1][j] if(i>0)\n\t\t\tnei << A[i+1][j] if(i<N-1)\n\t\t\tnei << A[i][j-1] if(j>0)\n\t\t\tnei << A[i][j+1] if(j<N-1)\n\t\t\tA[i][j] = nei.inject(1){|a,sum| lcm(sum,a)} + 1\n\t\tend\n\tend\nend\nif(N==2)\n\tA[1][0] = (A[1][0] - 1) * 2 + 1\nend\n\nputs A.map{|a| a.join(\" \")}.join(\"\\n\")\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype IOTp struct {\n\tiBuffer []byte\n\tiPos int\n}\nfunc (this *IOTp) GetChar() byte {\n\tres:=this.iBuffer[this.iPos]\n\tthis.iPos++\n\treturn res\n}\nfunc (this *IOTp) ReadInt() int {\n\tres:=0\n\tk:=1\n\tfor ch:=this.iBuffer[this.iPos]; !(ch>='0' && ch<='9'); ch=this.iBuffer[this.iPos]{\n\t\tif ch=='-' {\n\t\t\tk=-1\n\t\t}\n\t\tthis.iPos++\n\t}\n\tfor ch:=this.iBuffer[this.iPos]; ch>='0' && ch<='9'; ch=this.iBuffer[this.iPos]{\n\t\tres=res*10+int(ch-'0')\n\t\tthis.iPos++\n\t}\n\tres*=k\n\treturn res\n}\nfunc NewIOTp() *IOTp {\n\tnow:=new(IOTp)\n\t//inputFile,_:=os.Open(\"in.txt\")\n\tinputFile:=os.Stdin\n\tnow.iBuffer,_=ioutil.ReadAll(inputFile)\n\tnow.iBuffer=append(now.iBuffer, '\\n')\n\tnow.iPos=0\n\treturn now\n}\nfunc max(x,y int) int {\n\tif x>y {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\nfunc min(x,y int) int {\n\tif x<y {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\nvar cin *bufio.Reader\nvar cout *bufio.Writer\nconst MAXN=500\nvar n int\nfunc get(i,j int) (x,y int) {\n\tx=(i-j+n)/2\n\ty=(i+j)/2\n\treturn\n}\nfunc main() {\n\tIO:=NewIOTp()\n\tcout=bufio.NewWriter(os.Stdout)\n\tn=IO.ReadInt()\n\tvar prime []int\n\tfor i:=2; len(prime)<=1000; i++ {\n\t\tflag:=true\n\t\tfor j:=2; j*j<=i; j++ {\n\t\t\tif i%j==0 {\n\t\t\t\tflag=false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif flag {\n\t\t\tprime=append(prime, i)\n\t\t}\n\t}\n\tvar a[MAXN+5][MAXN+5]int\n\tfor i:=1; i<=n; i++ {\n\t\tfor j:=1; j<=n; j++ {\n\t\t\tif (i+j)%2==1 {\n\t\t\t\tx,y:=get(i,j)\n\t\t\t\t//fmt.Println(i,j,x,n+y)\n\t\t\t\ta[i][j]=prime[x]*prime[n+y]\n\t\t\t} else {\n\t\t\t\tx1,y1:=get(i,j-1)\n\t\t\t\tx2,y2:=get(i,j+1)\n\t\t\t\t//fmt.Println(prime[x1],prime[y1+n-1],prime[x2],prime[y2+n-1])\n\t\t\t\ta[i][j]=prime[x1]*prime[n+y1]*prime[x2]*prime[n+y2]+1\n\t\t\t}\n\t\t\tfmt.Fprint(cout,a[i][j],\" \")\n\t\t}\n\t\tfmt.Fprintln(cout)\n\t}\n\tcout.Flush()\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N=5e2+10;\nconst int C=1e4+10;\nconst int SC=1e2+10;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a>b?b:a;}\nlong long int gcd(long long int a,long long int b){return b==0?a:gcd(b,a%b);}\nlong long int lcm(long long int a,long long int b){return a/gcd(a,b)*b;}\nlong long int ans[N][N];\nint n;\nlong long int f(int a,int b){\nif(a<0||b<0||a>=n||b>=n)return 1;\nelse return ans[a][b];\n}\nint main(){\nint tot;\nbitset<C> went;\nvector<int> prime;\nscanf(\"%d\",&n);\nwent.reset();\nprime.push_back(2);\nfor(int i=3;i<SC;i+=2){\nif(!went[i]){\nprime.push_back(i);\nfor(int j=i*i;j<C;j+=i<<1)went[j]=true;\n}\n}\nfor(int i=SC+1;i<C;i+=2)if(!went[i])prime.push_back(i);\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)ans[i][j]=0;\nfor(int i=0;i<n;i++){\ntot=min(i,n-i-1);\nfor(int j=-tot;j<=tot;j++)ans[i+j][i-j]=prime[i];\n}\nfor(int i=0;i<=n;i++){\ntot=n-i;\nfor(int j=i;j<=tot;j++)ans[i+j][j-i]*=prime[i+n+(n>>1)];\n}\nfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(ans[i][j]==0)ans[i][j]=lcm(lcm(f(i-1,j),f(i,j-1)),lcm(f(i+1,j),f(i,j+1)))+1;\nfor(int i=0;i<n;i++){\nprintf(\"%lld\",ans[i][0]);\nfor(int j=1;j<n;j++)printf(\" %lld\",ans[i][j]);\nprintf(\"\\n\");\n}\n}\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\n\n#最大公約数\ndef gcd(a,b):\n\twhile b:\n\t\ta,b = b, a%b\n\treturn a\n\n#最小公倍数\ndef lcm(a,b):\n\treturn a*b // gcd(a,b)\n\nans = [[0]*N for i in range(N)]\n\ntmp = 2\nfor y in range(N):\n\tif y%2 == 0:\n\t\txx = range(0,N,2)\n\telse:\n\t\txx = range(1,N,2)\n\n\tfor x in xx:\n\t\tpl = y+x+2\n\t\tmn = y-x + N + N%2+1\n\t\tans[y][x] = pl*mn\n\ned = defaultdict(bool)\nfor y in range(N):\n    for x in range(N):\n        if ans[y][x] == 0:\n            tmp = 1\n            if x > 0:\n                tmp = lcm(tmp,ans[y][x-1])\n            if x < N-1:\n                tmp = lcm(tmp,ans[y][x+1])\n            if y > 0:\n                tmp = lcm(tmp,ans[y-1][x])\n            if y < N-1:\n                tmp = lcm(tmp,ans[y+1][x])\n\n            while ed[tmp+1]:\n                tmp += tmp\n\n            ans[y][x] = tmp + 1\n            if tmp >= 10**15:\n                print(tmp)\n                print('nya-n')\n                exit()\n\n            ed[tmp+1] = True\n\n\nfor a in ans:\n    print(' '.join(map(str,a)))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nm = 0\nk = 1\nfor i in range(n):\n  m+=3\n  k = 1\n  for j in range(n):\n    k+=3\n    print(m+k, end=' ')\n  print()"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\nmii=lambda:map(int,input().split())\n\n# get primes\nlim=100000\nsieve=[1]*lim\nprime=[]\nfor i in range(2,lim):\n    if not sieve[i]: continue\n    prime.append(i)\n    for j in range(i*i,lim,i):\n        sieve[j]=0\n\npowers=[]\nfor p in prime:\n    q=p\n    while q<5600:\n        if q>500: powers.append(q)\n        q*=p\n\n# create two arrays where adjacent elements divide each other\na1=[]\nfor i in range(250):\n    a1.append(prime[i])\n    a1.append(prime[i]*prime[i+1])\na2=[]\nfor i in range(255,505):\n    a2.append(prime[i])\n    a2.append(prime[i]*prime[i+1])\n\n# print matrix\nn=int(input())\nout=[[0 for j in range(n)] for i in range(n)]\n\ns=set()\nfor i in range(n):\n    for j in range(n):\n        if (i+j)%2==0:\n            # put small number\n            out[i][j]=powers[(i+j)//2]*(i+1)\n            s.add(out[i][j])\n\nfor i in range(n):\n    for j in range(n):\n        if (i+j)%2==1:\n            # put big number\n            big=i+1\n            if i>0: big*=i\n            if i<n-1: big*=i+2\n            big*=powers[(i+j)//2]\n            big*=powers[(i+j+1)//2]\n            k=1\n            while big*k+1 in s: k+=1\n            out[i][j]=big*k+1\n            s.add(out[i][j])\n\n\n# checking\nif 0:\n    for i in range(n-1):\n        for j in range(n):\n            x=out[i][j]\n            y=out[i+1][j]\n            if x<y: x,y=y,x\n            while x%y!=1: 1\n            x=out[j][i]\n            y=out[j][i+1]\n            if x<y: x,y=y,x\n            while x%y!=1: 1\n    s=set()\n    for i in out:\n        for j in i:\n            s.add(j)\n    while len(s)!=n**2: 1\n    while max(s)>10**15: 1\n    while min(s)<1: 1\n\nfor li in out: print(\" \".join(map(str,li)))\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nm=int(input())\n\nn=502\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\nq=27004\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2==0:\n                a[i][j] = p\n                p+=2\n            else:\n                a[i][j] = q\n                q-=2\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//16 +1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1] +1\n\n\nfor i in range(1,m+1):          \n    print(*a[i][1:m+1])\n    \n\n#for i in range(1,m+1):\n #   print(i)\n  #  for j in range(1,m+1):\n   #     print(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j])%min(a[i][j],a[i+1][j]))\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\nN = int(input())\na = []\nfor i in range(N):\n  a.append([])\n  for j in range(N):\n    if (i + j) % 2 == 0:\n      a[i].append(Primes[250 + (i - j) // 2] * Primes[500 + (i + j) // 2])\n    else:\n      a[i].append(0)\n\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul = mul * a[i-1][j] // gcd(mul,a[i-1][j])\n      if j > 0:\n        mul = mul * a[i][j-1] // gcd(mul,a[i][j-1])\n      if i < N-1:\n        mul = mul * a[i+1][j] // gcd(mul,a[i+1][j])\n      if j < N - 1:\n        mul = mul * a[i][j+1] // gcd(mul,a[i][j+1])\n      mul += 1\n      a[i][j] = mul\nif N == 2:\n    print(\"4 7\\n23 10\")\nelse:\n    for row in a:\n      print(\" \".join(map(str,row)))"
  },
  {
    "language": "Python",
    "code": "z=int(input())\nn=500\n\ndef gcd(a,b):\n\twhile b:\n\t\ta,b=b,a%b\n\treturn a\n\ndef lcm(a,b):\n\treturn a*b//gcd(a,b)\n\ndef lcm3(a,b,c):\n\treturn lcm(lcm(a,b),c)\n\ndef lcm4(a,b,c,d):\n\treturn lcm(lcm(a,b),lcm(c,d))\n\na=[0]*(n*n)\nx=set([1])\nfor i in range(n*n//4)[::-1]:\n\tj=i//((n*n)//16)\n\tif j==0:\n\t\ty1=0\n\t\ty2=0\n\telif j==1:\n\t\ty1=1\n\t\ty2=1\n\telif j==2:\n\t\ty1=0\n\t\ty2=1\n\telse:\n\t\ty1=1\n\t\ty2=0\n\tk=i%((n*n)//16)\n\tm=i+2\n\ta[n*(4*(k//(n//4))+2*y1)+4*(k%(n//4))+2*y2]=m\n\tx.add(m)\n\twhile m in x:\n\t\tm+=i+2\n\ta[n*(4*(k//(n//4))+2*y1+1)+4*(k%(n//4))+2*y2+1]=m\n\tx.add(m)\n#print(a)\nfor i in range(0,n*n):\n\tif a[i]==0:\n\t\tj=i//n\n\t\tk=i%n\n\t\tif j==0 and k==n-1:\n\t\t\tm=lcm(a[i-1],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==n-1 and k==0:\n\t\t\tm=lcm(a[i+1],a[i-n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==0:\n\t\t\tm=lcm3(a[i-1],a[i+1],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==n-1:\n\t\t\tm=lcm3(a[i-1],a[i+1],a[i-n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif k==0:\n\t\t\tm=lcm3(a[i+1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif k==n-1:\n\t\t\tm=lcm3(a[i-1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telse:\n\t\t\tm=lcm4(a[i+1],a[i-1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\n#print(max(x))\n\nfor i in range(z):\n\tprint(' '.join(map(str,a[i*n:i*n+z])))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\n\n#最大公約数\ndef gcd(a,b):\n\twhile b:\n\t\ta,b = b, a%b\n\treturn a\n\n#最小公倍数\ndef lcm(a,b):\n\treturn a*b // gcd(a,b)\n\nans = [[0]*N for i in range(N)]\n\ntmp = 2\nfor y in range(0,N,2):\n    for x in range(0,N,2):\n        ans[y][x] = tmp\n        tmp += 1\n\nfor y in reversed(range(1,N,2)):\n    for x in range(1,N,2):\n        ans[y][x] = tmp\n        tmp += 1\n\nfor y in range(N):\n    for x in range(N):\n        if ans[y][x] == 0:\n            tmp = 1\n            if x > 0:\n                tmp = lcm(tmp,ans[y][x-1])\n            if x < N-1:\n                tmp = lcm(tmp,ans[y][x+1])\n            if y > 0:\n                tmp = lcm(tmp,ans[y-1][x])\n            if y < N-1:\n                tmp = lcm(tmp,ans[y+1][x])\n            ans[y][x] = tmp + 1\n\nif N == 2:\n    ans = [[4,7],[23,10]]\n\nfor a in ans:\n    print(' '.join(map(str,a)))\n"
  },
  {
    "language": "Python",
    "code": "import math, itertools\n\ndef genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break\n\nn = int(input())\nres = [[1 for i in range(n)] for j in range(n)]\ncoord = [(i, j) for i in range(n) for j in range(n) if (i + j) % 2 == 0]\ngen = genprime()\n\nfoo = sorted(coord, key = lambda x: x[0] + x[1])\nfor i, p in zip(itertools.groupby(foo, lambda x: x[0] + x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nfoo = sorted(coord, key = lambda x: x[0] - x[1])\nfor i, p in zip(itertools.groupby(foo, lambda x: x[0] - x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nlcm = lambda x, y: x // math.gcd(x, y) * y\n\nfor i in range(0, n):\n    for j in range(0, n):\n        if (i + j) % 2 == 0:\n            continue\n        if i > 0:\n            res[i][j] = lcm(res[i][j], res[i - 1][j])\n        if j > 0:\n            res[i][j] = lcm(res[i][j], res[i][j - 1])\n        if i < n - 1:\n            res[i][j] = lcm(res[i][j], res[i + 1][j])\n        if j < n - 1:\n            res[i][j] = lcm(res[i][j], res[i][j + 1])\n\nif n == 2:\n    res = [[2, 3], [5, 4]]\n\nfor i in range(0, n):\n    print(*res[i])"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nU = 10 ** 5\nis_prime = np.zeros(U+1, dtype=np.bool)\nis_prime[2] = 1\nis_prime[3::2] = 1\nfor p in range(3,U+1,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::2*p] = 0\n\nprimes = is_prime.nonzero()[0].astype(np.int64)\n\nMM = 510\nM = 255\n\nA = np.ones((MM,MM), dtype = np.int64)\nfor n in range(MM):\n    if n % 2 == 0:\n        A[n,::2] *= primes[n//2:n//2+M]\n        A[n,::2] *= primes[MM+M-n//2:2*MM-n//2]\n        A[n,1::2] *= A[n,::2]\n        A[n,1:-1:2] *= A[n,2::2]\n        A[n,1::2] += 1\n    elif n % 2 == 1:\n        A[n,1::2] *= primes[(n+1)//2:(n+1)//2+M]\n        A[n,1::2] *= primes[MM+M-(n-1)//2:2*MM-(n-1)//2]\n        A[n,::2] *= A[n,1::2]\n        A[n,2::2] *= A[n,1:-1:2]\n        A[n,::2] += 1\n\nN = int(input())\nA = A[1:N+1,1:N+1]\n\nanswer = '\\n'.join(' '.join(row) for row in A.astype(str))\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef primes(x):\n    if x < 2: return []\n\n    primes = [i for i in range(x)]\n    primes[1] = 0 # 1は素数ではない\n\n    for prime in primes:\n        if prime > math.sqrt(x): break\n        if prime == 0: continue\n        for non_prime in range(2 * prime, x, prime): primes[non_prime] = 0\n\n    return [prime for prime in primes if prime != 0]\n\n\ndef is_prime(x):\n    if x < 2: return False # 2未満に素数はない\n    if x == 2 or x == 3 or x == 5: return True # 2,3,5は素数\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0: return False # 2,3,5の倍数は合成数\n\n    prime = 7\n    step = 4\n    while prime <= math.sqrt(x):\n        if x % prime == 0: return False\n\n        prime += step\n        step = 6 - step\n\n    return True\n\np = primes(10**5)\n\nN = int(input())\n\nfor j in range(N):\n    ans = \"\"\n    for i in range(N):\n        ans += \"2\" if (i+j)%2==0 else \"3\"\n        if i != N-1:\n            ans += \" \"\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\n\ndef gcd(a,b):\n\twhile b:\n\t\ta,b=b,a%b\n\treturn a\n\ndef lcm(a,b):\n\treturn a*b//gcd(a,b)\n\ndef lcm3(a,b,c):\n\treturn lcm(lcm(a,b),c)\n\ndef lcm4(a,b,c,d):\n\treturn lcm(lcm(a,b),lcm(c,d))\n\na=[0]*(n*n)\nx=set([1])\ns=2\nfor i in range(0,n*n):\n\tif (i//n+i%n)%2==0:\n\t\ta[i]=s\n\t\tx.add(s)\n\t\ts+=1\n#print(a)\nfor i in range(0,n*n):\n\tif a[i]==0:\n\t\tj=i//n\n\t\tk=i%n\n\t\tif j==0 and k==n-1:\n\t\t\tm=lcm(a[i-1],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==n-1 and k==0:\n\t\t\tm=lcm(a[i+1],a[i-n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==0:\n\t\t\tm=lcm3(a[i-1],a[i+1],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==n-1:\n\t\t\tm=lcm3(a[i-1],a[i+1],a[i-n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif k==0:\n\t\t\tm=lcm3(a[i+1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif k==n-1:\n\t\t\tm=lcm3(a[i-1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telse:\n\t\t\tm=lcm4(a[i+1],a[i-1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\nfor i in range(n):\n\tprint(' '.join(map(str,a[i*n:i*n+n])))\n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nfrom itertools import groupby\n\ndef genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break\n\nn = int(input())\nres = [[1 for i in range(n)] for j in range(n)]\ncoord = [(i, j) for i in range(n) for j in range(n) if (i + j) % 2 == 0]\ngen = genprime()\n\nfoo = sorted(coord, key = lambda x: x[0] + x[1])\nfor i, p in zip(groupby(foo, lambda x: x[0] + x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nfoo = sorted(coord, key = lambda x: x[0] - x[1])\nfor i, p in zip(groupby(foo, lambda x: x[0] - x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nlcm = lambda x, y: x // gcd(x, y) * y\n\nfor i in range(0, n):\n    for j in range(0, n):\n        if (i + j) % 2 == 0:\n            continue\n        if i > 0:\n            res[i][j] = lcm(res[i][j], res[i - 1][j])\n        if j > 0:\n            res[i][j] = lcm(res[i][j], res[i][j - 1])\n        if i < n - 1:\n            res[i][j] = lcm(res[i][j], res[i + 1][j])\n        if j < n - 1:\n            res[i][j] = lcm(res[i][j], res[i][j + 1])\n\nif n == 2:\n    res = [[2, 3], [5, 4]]\n\nfor i in range(0, n):\n    print(*res[i])"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999]\nN = int(input())\na = []\nfor i in range(N):\n  a.append([])\n  for j in range(N):\n    if (i + j) % 2 == 0:\n      a.append(Primes[250 + (i-j) // 2] * Primes[500 + (i + j) // 2])\n    else:\n      a.append(0)\n\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul = mul * a[i-1][j] // gcd(mul,a[i-1][j])\n      if j > 0:\n        mul = mul * a[i][j-1] // gcd(mul,a[i][j-1])\n      if i < N-1:\n        mul = mul * a[i+1][j] // gcd(mul,a[i+1][j])\n      if j < N - 1:\n        mul = mul * a[i][j+1] // gcd(mul,a[i][j+1])\n\nfor row in a:\n  print(\" \".join(map(str,a)))\n  "
  },
  {
    "language": "Python",
    "code": "N = int(input())\nxzero = 3\nyzero = 5\ny = N+1\n\nbiggest = 8*(int(N/4)+1)*(int(N/4)+1)+4\na = [[0 for i in range(N+4)] for j in range(N+4)]\nfours = [4*i for i in range((int(N/4)+1))]\nodds = [2*i for i in range(int((N+1)/2))]\nevens = [2*i+1 for i in range(int(N/2))]\n\nif N==2:\n    print(\"4 7\")\n    print(\"23 10\")\nelse:\n    x = xzero\n    for i in fours:\n        for j in fours:\n            a[i][j] = x\n            a[i+1][j+1] = 2*x\n            a[i][j+2]=biggest-x\n            a[i+1][j+3] = 2*(biggest-x)\n            a[i+2][j] = biggest-x-(int(N/4)+1)*2\n            a[i+3][j+1] = 2*(biggest-x-(int(N/4)+1)*2)\n            a[i+2][j+2] = x+(int(N/4)+1)*2\n            a[i+3][j+3] = 2*(x+(int(N/4)+1)*2)\n            x += 2\n        x+=(int(N/4)+1)*2\n\n    for i in odds:\n        for j in evens:\n            ans = 1\n            ans *= a[i][j - 1]\n            ans *= a[i][j + 1]\n            if i > 0:\n                ans *= a[i - 1][j]\n            else:\n                ans *= 2\n            ans += 1\n            a[i][j] = ans\n\n    for i in evens:\n        for j in odds:\n            ans = 1\n            ans *= a[i - 1][j]\n            ans *= a[i + 1][j]\n            if j > 0:\n                ans *= a[i][j - 1]\n            else:\n                ans *= 2\n            ans += 1\n            a[i][j] = ans\n    a = [i[0:N] for i in a[0:N]]\n\n    for i in range(N):\n        print(\" \".join(str(j) for j in a[i]))"
  },
  {
    "language": "Python",
    "code": "tmp = 2\nflag = 0\nn = int(input())\nmat = [[0]*n for i in range(n)]\nfor i in range(0,2*n,2):\n  for j in range(i+1):\n    try:\n      if flag == 0:\n        mat[i-j][j] = tmp\n        flag = 1\n        tmp += 1\n      else:\n        mat[i-j][j] = (n*n+1)//2-tmp+4\n        flag = 0\n    except:\n      pass\nfor i in range(n):\n  for j in range(n):\n    if mat[i][j]==0:\n      a = 1;b=1;c=1;d=1\n      if i-1 >= 0:\n        a = mat[i-1][j]\n      if i+1<=n-1:\n        b = mat[i+1][j]\n      if j-1 >= 0:\n        c = mat[i][j-1]\n      if j+1<= n-1:\n        d = mat[i][j+1]\n      mat[i][j] = a*b*c*d +1\nfor i in mat:\n  print(*i)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport random, math\n\ndef lcm(a, b):\n    return (a // math.gcd(a, b)) * b\n\ndef is_prime(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef primes(n):\n    lst = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            lst.append(i)\n    return lst\n\nn = int(input())\n\na = [[None for j in range(n)] for i in range(n)]\n\nlst = [(i,j) for i in range(n) for j in range(n - 1, -1, -1)]\n\nused = set()\npr = primes(10 ** 4)\n\noff = 0\nwhile pr[off] < n + 3:\n    off += 1\n\nfor (i, j) in lst:\n    if (i + j) % 2 == 0:\n        A = (i + j) // 2\n        B = n + (i - j) // 2\n        a[i][j] = (A + 1) * (pr[off + B])\n        if a[i][j] in used:\n            print(101, a[i][j])\n            raise ValueError()\n        used.add(a[i][j])\n        \nfor (i, j) in lst:\n    if (i + j) % 2 == 0:\n        continue\n    \n    val = 1\n    for (ip, jp) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n        if 0 <= ip < n and 0 <= jp < n and a[ip][jp] != None:\n            val = lcm(val, a[ip][jp])\n\n    if val >= 5 * 10 ** 14:\n        print(\"ERR\", val)\n        raise ValueError()\n    \n    res = val + 1\n    while res in used:\n        k = random.randint(1, (10 ** 15 - 1) // val)\n        res = k * val + 1\n\n    a[i][j] = res\n    used.add(res)\n\nfor i in range(n):\n    print(\" \".join(map(str, a[i])))\n"
  },
  {
    "language": "Python",
    "code": "n  =int(input())\n\nout = []\nfor row in range(n):\n    s = []\n    for col in range(n):\n        s.append(str(row + col + 2))\n    out.append(\" \".join(s))\nprint(\"\\n\".join(out))\n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\nmii=lambda:map(int,input().split())\n\n# get primes\nlim=10000\nsieve=[1]*lim\nprime=[]\nfor i in range(2,lim):\n    if not sieve[i]: continue\n    prime.append(i)\n    for j in range(i*i,lim,i):\n        sieve[j]=0\n\n# create two arrays where adjacent elements divide each other\na1=[]\nfor i in range(250):\n    a1.append(prime[i])\n    a1.append(prime[i]*prime[i+1])\na2=[]\nfor i in range(255,505):\n    a2.append(prime[i])\n    a2.append(prime[i]*prime[i+1])\n\n# print matrix\nn=int(input())\nout=[[a1[i]*a2[j] for j in range(n)] for i in range(n)]\n\n# checking\nfor i in range(n-1):\n    for j in range(n):\n        x=out[i][j]\n        y=out[i+1][j]\n        if x<y: x,y=y,x\n        while x%y!=0: 1\n        x=out[j][i]\n        y=out[j][i+1]\n        if x<y: x,y=y,x\n        while x%y!=0: 1\ns=set()\nfor i in out:\n    for j in i:\n        s.add(j)\nwhile len(s)!=n**2: 1\nwhile max(s)>10**15: 1\nwhile min(s)<1: 1\n\nfor li in out: print(\" \".join(map(str,li)))\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\nfrom random import shuffle, seed\ndef main():\n    N = int(raw_input())\n    n = 500\n    a = [[0] * n for i in xrange(n)]\n    b = range(2, n * n / 2 + 2)\n    seed(42)\n    shuffle(b)\n    c = 0\n    for i in xrange(n):\n        for j in xrange(n):\n            if (i + j) % 2:\n                a[i][j] = b[c]\n                c += 1\n    L = b[-1]\n    s = set(b)\n    for i in xrange(n):\n        for j in xrange(n):\n            if a[i][j]:\n                continue\n            g = 0\n            if i:\n                g = gcd(a[i-1][j], g)\n            if j:\n                g = gcd(a[i][j-1], g)\n            if i < n - 1:\n                g = gcd(a[i+1][j], g)\n            if j < n - 1:\n                g = gcd(a[i][j+1], g)\n            x = L / g * g + g + 1\n            while x in s:\n                x += g\n            s.add(x)\n            a[i][j] = L = x\n    for i in xrange(N):\n        for j in xrange(N):\n            print a[i][j],\n        print\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nfrom itertools import groupby\n\ndef genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break\n\nn = int(input())\nres = [[1 for i in range(n)] for j in range(n)]\ncoord = [(i, j) for i in range(n) for j in range(n) if (i + j) % 2 == 0]\ngen = genprime()\n\nfoo = sorted(coord, key = lambda x: x[0] + x[1])\nfor i, p in zip(groupby(foo, lambda x: x[0] + x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nfoo = sorted(coord, key = lambda x: x[0] - x[1])\nfor i, p in zip(groupby(foo, lambda x: x[0] - x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nlcm = lambda x, y: x // gcd(x, y) * y\n\nfor i in range(0, n):\n    for j in range(0, n):\n        if (i + j) % 2 == 0:\n            continue\n        if i > 0:\n            res[i][j] = lcm(res[i][j], res[i - 1][j])\n        if j > 0:\n            res[i][j] = lcm(res[i][j], res[i][j - 1])\n        if i < n - 1:\n            res[i][j] = lcm(res[i][j], res[i + 1][j])\n        if j < n - 1:\n            res[i][j] = lcm(res[i][j], res[i][j + 1])\n\nfor i in range(0, n):\n    print(*res[i])"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nn_1 = N % 2\nn_2 = N // 2\n\nPN = [2]\nL = 3\nwhile len(PN) < N*2:\n    c = True\n    for p in PN:\n        if L % p == 0: c = False\n    if c == True: PN.append(L)\n    L += 2\n\na = [[1]*N for _ in range(N)]\nb = [[1]*N for _ in range(N)]\n\nif n_1 == 1:\n    w = 1\n    for i in range(n_2):\n        if w > 0:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[4*i]\n                a[i - j][i + j] = PN[4*i]\n                a[N-1-i + j][N-1-i - j] = PN[4*i+1]\n                a[N-1-i - j][N-1-i + j] = PN[4*i+1]\n                b[i + j][N-1-i + j] = PN[4*i+2]\n                b[i - j][N-1-i - j] = PN[4*i+2]\n                b[N-1-i + j][i + j] = PN[4*i+3]\n                b[N-1-i - j][i - j] = PN[4*i+3]\n        else:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[-4*(i-1)-1]\n                a[i - j][i + j] = PN[-4*(i-1)-1]\n                a[N-1-i + j][N-1-i - j] = PN[-4*(i-1)-2]\n                a[N-1-i - j][N-1-i + j] = PN[-4*(i-1)-2]\n                b[i + j][N-1-i + j] = PN[-4*(i-1)-3]\n                b[i - j][N-1-i - j] = PN[-4*(i-1)-3]\n                b[N-1-i + j][i + j] = PN[-4*(i-1)-4]\n                b[N-1-i - j][i - j] = PN[-4*(i-1)-4]\n        w *= -1\n    r = (n_2-1)//2+1\n    for j in range(n_2+1):\n        a[n_2 + j][n_2 - j] = PN[4*r]\n        a[n_2 - j][n_2 + j] = PN[4*r]\n        b[n_2 + j][n_2 + j] = PN[4*r+1]\n        b[n_2 - j][n_2 - j] = PN[4*r+1]\nelse:\n    w = 1\n    for i in range(n_2):\n        if w > 0:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[4*i]\n                a[i - j][i + j] = PN[4*i]\n                a[N-1-i + j][N-1-i - j] = PN[4*i+1]\n                a[N-1-i - j][N-1-i + j] = PN[4*i+1]\n                b[i+1 + j][N-1-i + j] = PN[4*i+3]\n                b[i - j][N-2-i - j] = PN[4*i+3]\n                b[N-1-i + j][i+1 + j] = PN[4*i+2]\n                b[N-2-i - j][i - j] = PN[4*i+2]\n        else:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[-4*(i-1)-1]\n                a[i - j][i + j] = PN[-4*(i-1)-1]\n                a[N-1-i + j][N-1-i - j] = PN[-4*(i-1)-2]\n                a[N-1-i - j][N-1-i + j] = PN[-4*(i-1)-2]\n                b[i+1 + j][N-1-i + j] = PN[-4*(i-1)-4]\n                b[i - j][N-2-i - j] = PN[-4*(i-1)-4]\n                b[N-1-i + j][i+1 + j] = PN[-4*(i-1)-3]\n                b[N-2-i - j][i - j] = PN[-4*(i-1)-3]\n        w *= -1\n\nc = [[1]*N for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        c[i][j] = a[i][j] * b[i][j]\n\nif n_1 == 1:\n    for i in range(n_2+1):\n        for j in range(n_2):\n            c[2*i][1+2*j] += c[2*i][1+2*j - 1] * c[2*i][1+2*j + 1]\n    for i in range(n_2):\n        for j in range(n_2+1):\n            c[1+2*i][2*j] += c[1+2*i - 1][2*j] * c[1+2*i + 1][2*j]\nelse:\n    for i in range(n_2-1):\n        for j in range(n_2):\n            c[1+2*i][2*j] += c[1+2*i - 1][2*j] * c[1+2*i + 1][2*j]\n            c[1+2*i + 1][2*j + 1] += c[1+2*i - 1 + 1][2*j + 1] * c[1+2*i + 1 + 1][2*j + 1]\n    for j in range(n_2-1):\n        c[0][1+2*j] += c[0][1+2*j - 1] * c[0][1+2*j + 1]\n        c[-1][2+2*j] += c[-1][2+2*j - 1] * c[-1][2+2*j + 1]\n    c[0][-1] += a[0][-2] * a[1][-1] * b[0][-2]\n    c[-1][0] += a[-2][0] * a[-1][1] * b[-1][1] * 2\n\nfor C in c:\n    print(*C)\n"
  },
  {
    "language": "Python",
    "code": "import math, itertools\n \ndef genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break\n \nn = int(input())\nres = [[1 for i in range(n)] for j in range(n)]\ncoord = [(i, j) for i in range(n) for j in range(n) if (i + j) % 2 == 0]\ngen = genprime()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: 隣接行列(距離付き)\n    N: ノード数\n    K: 始点ノード\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  現在のノード\n    pre: １つ前のノード\n    dist: 現在の距離\n\n    以下は別途用意する\n    D: 隣接リスト(行列ではない)\n    D_dfs_d: dfs_d関数で用いる，始点ノードから見た距離リスト\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\ndef comb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r + 1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p - 1, r, p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\n\n# --------------------------------------------\n\ndp = None\n\ndef bisearch(L, target):\n    low = 0\n    high = len(L) - 1\n\n    if len(L) == 0:\n        return False\n    \n    while low <= high:\n        mid = (low + high) // 2\n        guess = L[mid]\n        if guess == target:\n            return True\n        elif guess < target:\n            low = mid + 1\n        elif guess > target:\n            high = mid - 1\n    if guess != target:\n        return False\n\ndef main():\n    MAX_V = 10**150\n    N = int(input())\n\n    L = [2, 3, 4, 5]\n    A = [[0] * N for _ in range(N+1)]\n\n    A[0][0] = 2\n    A[1][0] = 5\n    A[0][1] = 3\n    A[1][1] = 4\n\n\n    for t in range(2, N):\n        for i in range(t):\n            if i == 0:\n                f = True\n                for x in range(A[i][t - 1] + 1, 0, -A[i][t - 1]):\n                    if not bisearch(L, x):\n                        L.append(x)\n                        L.sort()\n                        A[i][t] = x\n                        f = False\n                        break\n                if f:\n                    for x in range(A[i][t - 1] + 1, MAX_V, A[i][t - 1]):\n                        if not bisearch(L, x):\n                            L.append(x)\n                            L.sort()\n                            A[i][t] = x\n                            break\n            else:\n                _lcm = lcm(A[i - 1][t], A[i][t - 1])\n                f = True\n                for x in range(_lcm + 1, 0, -_lcm):\n                    if not bisearch(L, x):\n                        L.append(x)\n                        L.sort()\n                        A[i][t] = x\n                        f = False\n                        break\n                if f:\n                    for x in range(_lcm + 1, MAX_V, _lcm):\n                        if not bisearch(L, x):\n                            L.append(x)\n                            L.sort()\n                            A[i][t] = x\n                            break\n        \n        for j in range(t):\n            if j == 0:\n                f = True\n                for x in range(A[t - 1][j] + 1, 0, -A[t - 1][j]):\n                    if not bisearch(L, x):\n                        L.append(x)\n                        L.sort()\n                        A[t][j] = x\n                        f = False\n                        break\n                if f:\n                    for x in range(A[t - 1][j] + 1, MAX_V, A[t - 1][j]):\n                        if not bisearch(L, x):\n                            L.append(x)\n                            L.sort()\n                            A[t][j] = x\n                            break\n            else:\n                _lcm = lcm(A[t - 1][j], A[t][j - 1])\n                f = True\n                for x in range(_lcm + 1, 0, -_lcm):\n                    \n                    if not bisearch(L, x):\n                        L.append(x)\n                        L.sort()\n                        A[t][j] = x\n                        f = False\n                        break\n                if f:\n                    for x in range(_lcm + 1, MAX_V, _lcm):\n                        if not bisearch(L, x):\n                            L.append(x)\n                            L.sort()\n                            A[t][j] = x\n                            break\n        \n        print(L)\n       \n\n        _lcm = lcm(A[t - 1][t], A[t][t - 1])\n        f = True\n        for x in range(_lcm + 1, 0, -_lcm):\n            if not bisearch(L, x):\n                L.append(x)\n                L.sort()\n                A[t][t] = x\n                break\n        if f:\n            for x in range(_lcm + 1, MAX_V, _lcm):\n                if not bisearch(L, x):\n                    L.append(x)\n                    L.sort()\n                    A[t][t] = x\n                    break\n    \n    for i in range(N):\n        print(\" \".join(list(map(str, A[i]))))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nm=int(input())\n\nn=502\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\np2=4\nq=25000\nq2=24998\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2==0:\n                a[i][j] = p\n                p+=2\n#            elif i%2==0 and i%4!=0:\n#                a[i][j] = p2\n#                p2+=4\n            elif (i+1)%2==0:\n                a[i][j] = q\n                q-=2\n#            elif (i+1)%2==0 and (i+1)%4!=0:\n#                a[i][j] = q2\n#                q2-=4\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//16+1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1] +1\n\n\nfor i in range(1,m+1):          \n    print(*a[i][1:m+1])\n    \n\n#for i in range(1,m+1):\n#    print(i)\n#    for j in range(1,m+1):\n#        print(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j])%min(a[i][j],a[i+1][j]),max(a[i][j],a[i][j+1]),min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j]),min(a[i][j],a[i+1][j]))\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nn=int(input())\n\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\nq=25000\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2!=0:\n                a[i][j] = p\n                p+=2\n            else:\n                a[i][j] = q\n                q-=2\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//32 +1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//8 +1\n                \n\nfor i in range(1,n+1):          \n    print(*a[i][1:n+1])\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\na = []\nfor i in range(N):\n  a.append([0] * N)\ncur = 101\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 == 0:\n      a[i][j] = cur\n      cur += 1\n\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul *= a[i-1][j]\n      if j > 0:\n        mul *= a[i][j-1]\n      if i < N - 1:\n        mul *= a[i+1][j]\n      if j < N - 1:\n        mul *= a[i][j+1]\n      a[i][j] = mul + 1\n\nfor aList in a:\n  print(\" \".join(map(str,aList)))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nnewrow = [i+2 for i in range (N)]\nnrow = 0\nwhile nrow<N:\n    print(' '.join(map(str, newrow)))\n    max = newrow[-1]\n    newrow[0] = (max//newrow[0] + 1)*newrow[0]+1\n    for j in range(N-1):\n        newrow[j+1] = newrow[j]*newrow[j+1]+1\n    nrow += 1"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nn_1 = N % 2\nn_2 = N // 2\n\nPN = [2]\nL = 3\nwhile len(PN) < N*2:\n    c = True\n    for p in PN:\n        if L % p == 0: c = False\n    if c == True: PN.append(L)\n    L += 2\n\na = [[1]*N for _ in range(N)]\nb = [[1]*N for _ in range(N)]\n\nif n_1 == 1:\n    w = 1\n    for i in range(n_2):\n        if w > 0:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[4*i]\n                a[i - j][i + j] = PN[4*i]\n                a[N-1-i + j][N-1-i - j] = PN[4*i+1]\n                a[N-1-i - j][N-1-i + j] = PN[4*i+1]\n                b[i + j][N-1-i + j] = PN[4*i+2]\n                b[i - j][N-1-i - j] = PN[4*i+2]\n                b[N-1-i + j][i + j] = PN[4*i+3]\n                b[N-1-i - j][i - j] = PN[4*i+3]\n        else:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[-4*(i-1)-1]\n                a[i - j][i + j] = PN[-4*(i-1)-1]\n                a[N-1-i + j][N-1-i - j] = PN[-4*(i-1)-2]\n                a[N-1-i - j][N-1-i + j] = PN[-4*(i-1)-2]\n                b[i + j][N-1-i + j] = PN[-4*(i-1)-3]\n                b[i - j][N-1-i - j] = PN[-4*(i-1)-3]\n                b[N-1-i + j][i + j] = PN[-4*(i-1)-4]\n                b[N-1-i - j][i - j] = PN[-4*(i-1)-4]\n        w *= -1\n    r = (n_2-1)//2+1\n    for j in range(n_2+1):\n        a[n_2 + j][n_2 - j] = PN[4*r]\n        a[n_2 - j][n_2 + j] = PN[4*r]\n        b[n_2 + j][n_2 + j] = PN[4*r+1]\n        b[n_2 - j][n_2 - j] = PN[4*r+1]\nelse:\n    w = 1\n    for i in range(n_2):\n        if w > 0:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[4*i]\n                a[i - j][i + j] = PN[4*i]\n                a[N-1-i + j][N-1-i - j] = PN[4*i+1]\n                a[N-1-i - j][N-1-i + j] = PN[4*i+1]\n                b[i+1 + j][N-1-i + j] = PN[4*i+3]\n                b[i - j][N-2-i - j] = PN[4*i+3]\n                b[N-1-i + j][i+1 + j] = PN[4*i+2]\n                b[N-2-i - j][i - j] = PN[4*i+2]\n        else:\n            for j in range(i+1):\n                a[i + j][i - j] = PN[-4*(i-1)-1]\n                a[i - j][i + j] = PN[-4*(i-1)-1]\n                a[N-1-i + j][N-1-i - j] = PN[-4*(i-1)-2]\n                a[N-1-i - j][N-1-i + j] = PN[-4*(i-1)-2]\n                b[i+1 + j][N-1-i + j] = PN[-4*(i-1)-4]\n                b[i - j][N-2-i - j] = PN[-4*(i-1)-4]\n                b[N-1-i + j][i+1 + j] = PN[-4*(i-1)-3]\n                b[N-2-i - j][i - j] = PN[-4*(i-1)-3]\n        w *= -1\n\nc = [[1]*N for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        c[i][j] = a[i][j] * b[i][j]\n\nif n_1 == 1:\n    for i in range(n_2+1):\n        for j in range(n_2):\n            c[2*i][1+2*j] += c[2*i][1+2*j - 1] * c[2*i][1+2*j + 1]\n    for i in range(n_2):\n        for j in range(n_2+1):\n            c[1+2*i][2*j] += c[1+2*i - 1][2*j] * c[1+2*i + 1][2*j]\nelse:\n    for i in range(n_2-1):\n        for j in range(n_2):\n            c[1+2*i][2*j] += c[1+2*i - 1][2*j] * c[1+2*i + 1][2*j]\n            c[1+2*i + 1][2*j + 1] += c[1+2*i - 1 + 1][2*j + 1] * c[1+2*i + 1 + 1][2*j + 1]\n    for j in range(n_2-1):\n        c[0][1+2*j] += c[0][1+2*j - 1] * c[0][1+2*j + 1]\n        c[-1][2+2*j] += c[-1][2+2*j - 1] * c[-1][2+2*j + 1]\n    c[0][-1] += a[0][-2] * a[1][-1] * b[0][-2]\n    c[-1][0] += a[-2][0] * a[-1][1] * b[-1][1] * 2\n\nprint(PN)\nfor C in c:\n    print(*C)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn=int(input())\n\nM=np.zeros((n,n),dtype=int)\n\nfor i in range(n):\n    M[0][i]=i+2\nfor i in range(1,n):\n    M[i][0]=n+i+1+ int(n%2==0)\n    \nfor i in range(1,n):\n    for j in range(1,n):\n        M[i][j]=M[i-1][j]*M[i][j-1]+1\n        \nfor row in M:\n    for r in row[:-1]:\n        print(r,end=' ')\n    print(row[-1])"
  },
  {
    "language": "Python",
    "code": "import fractions\nimport sys\n\ndef lcm(a,b):\n    return a * b // fractions.gcd(a,b)\n\nN = int(input())\n\nif N == 2:\n    print (\"4 7\")\n    print (\"23 10\")\n    sys.exit()\n\nlis = [2]\n\nnow = 3\nwhile len(lis) < 2 * N:\n\n    flag = True\n    for i in lis:\n        if now % i == 0:\n            flag = False\n            break\n\n    if flag:\n        lis.append(now)\n    now += 2\n\n#print (lis)\n\nans = [ [1] * N for i in range(N) ]\n\n\nfor loop in range(2 * N):\n\n    if loop % 2 == 0:\n\n        i = loop\n        j = 0\n\n        while i >= 0:\n            if i < N and j < N:\n                ans[i][j] *= lis[loop // 2]\n\n            i -= 1\n            j += 1\n\n\n\nm = -1\nfor loop in range(2 * N):\n\n    if (N - 1 - loop) % 2 == 0:\n\n        i = 0\n        j = N-1-loop\n\n        while i < N and (i + j) % 2 == 0:\n            if i < N and j < N:\n                ans[i][j] *= lis[m]\n\n            i += 1\n            j += 1\n            \n        m -= 1\n\n\n\nfor i in range(N):\n    for j in range(N):\n\n        if (i + j) % 2 == 1:\n\n            t = 1\n\n            if i > 0:\n                t = lcm(t,ans[i-1][j])\n            \n            if j > 0:\n                t = lcm(t,ans[i][j-1])\n            \n\n            if i < N-1:\n                t = lcm(t,ans[i+1][j])\n            \n\n            if j < N-1:\n                t = lcm(t,ans[i][j+1])\n\n            ans[i][j] = t+1\n            \n\nfor i in range(N):\n    print (\" \".join(map(str,ans[i])))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\na = []\nfor i in range(N):\n  a.append([0] * N)\ncur = 101\nfor i in range(N + 2):\n  for j in range(N + 2):\n    if (i + j) % 2 == 0:\n      a[i][j] = cur\n      cur += 1\n\nfor i in range(N + 2):\n  for j in range(N + 2):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul *= a[i-1][j]\n      if j > 0:\n        mul *= a[i][j-1]\n      if i < N - 1:\n        mul *= a[i+1][j]\n      if j < N - 1:\n        mul *= a[i][j+1]\n      a[i][j] = mul + 1\n\nfor aList in a[1:-1]:\n  print(\" \".join(map(str,aList[1:-1])))"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\nN = int(input())\na = []\nfor i in range(N):\n  a.append([])\n  for j in range(N):\n    if (i + j) % 2 == 0:\n      a[i].append(Primes[250 + (i - j) // 2] * Primes[500 + (i + j) // 2])\n    else:\n      a[i].append(0)\n\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul = mul * a[i-1][j] // gcd(mul,a[i-1][j])\n      if j > 0:\n        mul = mul * a[i][j-1] // gcd(mul,a[i][j-1])\n      if i < N-1:\n        mul = mul * a[i+1][j] // gcd(mul,a[i+1][j])\n      if j < N - 1:\n        mul = mul * a[i][j+1] // gcd(mul,a[i][j+1])\n      mul += 1\n      a[i][j] = mul\n\nfor row in a:\n  print(\" \".join(map(str,row)))\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nfor i in range(N):\n  L=list(range(i+2,i+2+N))\n  L=list(map(str,L))\n  print(\" \".join(L))"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\n\ndef eratosthenes_generator():\n    yield 2\n    n = 3\n    h = {}\n    while True:\n        m = n\n        if n in h:\n            b = h[n]\n            m += 2 * b\n            while m in h:\n                m += 2 * b\n            h[m] = b\n            del h[n]\n        else:\n            m += 2 * n\n            while m in h:\n                m += 2 * n\n            h[m] = n\n            yield n\n        n += 2\n\n\nn = int(input())\nm = n // 2\nans = [[0] * n for _ in range(n)]\nfirst = []\n\nfor i in range(n):\n    mi = abs(i - m)\n    itr = range(0, n, 2) if i % 2 == 0 else range(1, n, 2)\n    first.extend((mi + abs(j - m), i, j) for j in itr)\nfirst.sort()\n\neg = eratosthenes_generator()\n\nfor _, i, j in first:\n    ans[i][j] = next(eg)\n\nfor i in range(n):\n    for j in range(int(i % 2 == 0), n, 2):\n        surroundings = []\n        if i > 0:\n            surroundings.append(ans[i - 1][j])\n        if i < n - 1:\n            surroundings.append(ans[i + 1][j])\n        if j > 0:\n            surroundings.append(ans[i][j - 1])\n        if j < n - 1:\n            surroundings.append(ans[i][j + 1])\n        lcd = surroundings[0]\n        for s in surroundings[1:]:\n            lcd = lcd * s // gcd(lcd, s)\n        ans[i][j] = lcd + 1\n\nprint('\\n'.join(' '.join(map(str, row[:-1])) for row in ans))\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\n\ndef eratosthenes_generator():\n    yield 2\n    n = 3\n    h = {}\n    while True:\n        m = n\n        if n in h:\n            b = h[n]\n            m += 2 * b\n            while m in h:\n                m += 2 * b\n            h[m] = b\n            del h[n]\n        else:\n            m += 2 * n\n            while m in h:\n                m += 2 * n\n            h[m] = n\n            yield n\n        n += 2\n\n\ndef solve(n):\n    if n == 2:\n        return [[2, 3], [5, 4]]\n\n    m = n // 2\n    ans = [[0] * n for _ in range(n)]\n    first = []\n\n    for i in range(n):\n        mi = abs(i - m)\n        itr = range(0, n, 2) if i % 2 == 0 else range(1, n, 2)\n        first.extend((mi + abs(j - m), i, j) for j in itr)\n    first.sort()\n\n    eg = eratosthenes_generator()\n\n    for _, i, j in first:\n        ans[i][j] = next(eg)\n\n    for i in range(n):\n        for j in range(int(i % 2 == 0), n, 2):\n            surroundings = []\n            if i > 0:\n                surroundings.append(ans[i - 1][j])\n            if i < n - 1:\n                surroundings.append(ans[i + 1][j])\n            if j > 0:\n                surroundings.append(ans[i][j - 1])\n            if j < n - 1:\n                surroundings.append(ans[i][j + 1])\n            lcd = surroundings[0]\n            for s in surroundings[1:]:\n                lcd = lcd * s // gcd(lcd, s)\n            ans[i][j] = lcd + 1\n           \n    return ans\n\n\nn = int(input())\nans = solve(n)\nprint('\\n'.join(' '.join(map(str, row)) for row in ans))\n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nfrom itertools import groupby"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nn=int(input())\n\nM=np.zeros((n,n),dtype=int)\n\nfor i in range(n):\n    M[0][i]=i+2\nfor i in range(1,n):\n    M[i][0]=n+i+1+ int(n%2==0)\n    \nfor i in range(1,n):\n    for j in range(1,n):\n        M[i][j]=M[i-1][j]*M[i][j-1]+1\n        \nprint(M)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nxzero = 3\nyzero = 5\ny = N+1\n\nbiggest = 8*(int(N/4)+1)*(int(N/4)+1)+4\na = [[0 for i in range(N+4)] for j in range(N+4)]\nfours = [4*i for i in range((int(N/4)+1))]\nodds = [2*i for i in range(int((N+1)/2))]\nevens = [2*i+1 for i in range(int(N/2))]\n\nif N==2:\n    print(\"4 7\")\n    print(\"23 10\")\nelse:\n    x = xzero\n    for i in fours:\n        for j in fours:\n            a[i][j] = x\n            a[i+1][j+1] = 2*x\n            a[i][j+2]=biggest-x\n            a[i+1][j+3] = 2*(biggest-x)\n            a[i+2][j] = biggest-x-(int(N/4)+1)*2\n            a[i+3][j+1] = 2*(biggest-x-(int(N/4)+1)*2)\n            a[i+2][j+2] = x+(int(N/4)+1)*2\n            a[i+3][j+3] = 2*(x+(int(N/4)+1)*2)\n            x += 2\n        x+=(int(N/4)+1)*2\n\n    for i in odds:\n        for j in evens:\n            ans = 1\n            ans *= a[i][j - 1]\n            ans *= a[i][j + 1]\n            if i > 0:\n                ans *= a[i - 1][j]\n            else:\n                ans *= 2\n            ans += 1\n            a[i][j] = ans\n\n    for i in evens:\n        for j in odds:\n            ans = 1\n            ans *= a[i - 1][j]\n            ans *= a[i + 1][j]\n            if j > 0:\n                ans *= a[i][j - 1]\n            else:\n                ans *= 2\n            ans += 1\n            a[i][j] = ans\n    print(a)\n    a = [i[0:N] for i in a[0:N]]\n\n    for i in range(N):\n        print(\" \".join(str(j) for j in a[i]))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n \na = []\nfor i in range(N + 2):\n  a.append([0] * (N + 2))\ncur = 101\nfor i in range(N + 2):\n  for j in range(N + 2):\n    if (i + j) % 2 == 0:\n      a[i][j] = cur\n      cur += 1\n\nfor i in range(N + 2):\n  for j in range(N + 2):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul *= a[i-1][j]\n      if j > 0:\n        mul *= a[i][j-1]\n      if i < N + 1:\n        mul *= a[i+1][j]\n      if j < N + 1:\n        mul *= a[i][j+1]\n      a[i][j] = mul + 1\n \n      \nfor aList in a[1:-1]:\n  print(\" \".join(map(str,aList[1:-1])))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport random, math, fractions\n\ndef lcm(a, b):\n    return (a // fractions.gcd(a, b)) * b\n\ndef is_prime(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef primes(n):\n    lst = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            lst.append(i)\n    return lst\n\nn = int(input())\n\na = [[None for j in range(n)] for i in range(n)]\n\nlst = [(i,j) for i in range(n) for j in range(n - 1, -1, -1)]\n\nused = set()\npr = primes(10 ** 4)\n\noff = 0\nwhile pr[off] < n + 3:\n    off += 1\n\nfor (i, j) in lst:\n    if (i + j) % 2 == 0:\n        A = (i + j) // 2\n        B = n + (i - j) // 2\n        a[i][j] = (A + 1) * (pr[off + B])\n        if a[i][j] in used:\n            print(101, a[i][j])\n            raise ValueError()\n        used.add(a[i][j])\n        \nfor (i, j) in lst:\n    if (i + j) % 2 == 0:\n        continue\n    \n    val = 1\n    for (ip, jp) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n        if 0 <= ip < n and 0 <= jp < n and a[ip][jp] != None:\n            val = lcm(val, a[ip][jp])\n\n    if val >= 5 * 10 ** 14:\n        print(\"ERR\", val)\n        raise ValueError()\n    \n    res = val + 1\n    while res in used:\n        k = random.randint(1, (10 ** 15 - 1) // val)\n        res = k * val + 1\n\n    a[i][j] = res\n    used.add(res)\n\nfor i in range(n):\n    print(\" \".join(map(str, a[i])))\n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\nN = int(input())\na = []\nfor i in range(N):\n  a.append([])\n  for j in range(N):\n    if (i + j) % 2 == 0:\n      a[i].append(Primes[250 + (i-j) // 2] * Primes[500 + (i + j) // 2])\n    else:\n      a[i].append(0)\n\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul = mul * a[i-1][j] // gcd(mul,a[i-1][j])\n      if j > 0:\n        mul = mul * a[i][j-1] // gcd(mul,a[i][j-1])\n      if i < N-1:\n        mul = mul * a[i+1][j] // gcd(mul,a[i+1][j])\n      if j < N - 1:\n        mul = mul * a[i][j+1] // gcd(mul,a[i][j+1])\n      mul += 1\n      a[i][j] = mul\n\nfor row in a:\n  print(\" \".join(map(str,a)))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = []\nfor i in range(n):\n\tt = []\n\tx = 1 if i&1 else 2\n\tfor j in range(n):\n\t\tt.append('2' if x&1 else '3')\n\t\tx = 2 if x == 1 else 1\n\ta.append(t)\nprint('\\n'.join([' '.join(i) for i in a]))"
  },
  {
    "language": "Python",
    "code": "import fractions\nimport sys\n\ndef lcm(a,b):\n    return a * b // fractions.gcd(a,b)\n\nN = int(input())\n\nif N == 2:\n    print (\"4 7\")\n    print (\"23 10\")\n    sys.exit()\n\nlis = [2]\n\nnow = 3\nwhile len(lis) <= 2 * N:\n\n    flag = True\n    for i in lis:\n        if now % i == 0:\n            flag = False\n            break\n\n    if flag:\n        lis.append(now)\n    now += 2\n\n#print (lis)\n\nans = [ [1] * N for i in range(N) ]\n\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if (i + j) % 2 == 0:\n            ans[i][j] *= lis[(i+j) // 2]\n\nif N % 2 == 1:\n\n    for i in range(N):\n        for j in range(N):\n\n            if (i + abs(N-1 - j)) % 2 == 0:\n                ans[i][j] *= lis[ -1 - (i + abs(N-1 - j)) // 2 ]\n\nelse:\n    for i in range(N):\n        for j in range(N):\n\n            if (i + abs(N-1 - j)) % 2 == 1:\n                ans[i][j] *= lis[ -1 - ((i + abs(N-1 - j) -1 ) // 2)]\n\n\n#for i in range(N):\n#    print (\" \".join(map(str,ans[i])))\n\n\nfor i in range(N):\n    for j in range(N):\n\n        if (i + j) % 2 == 1:\n\n            t = 1\n\n            if i > 0:\n                t = lcm(t,ans[i-1][j])\n            \n            if j > 0:\n                t = lcm(t,ans[i][j-1])\n            \n\n            if i < N-1:\n                t = lcm(t,ans[i+1][j])\n            \n\n            if j < N-1:\n                t = lcm(t,ans[i][j+1])\n\n            ans[i][j] = t+1\n            \n\nfor i in range(N):\n    print (\" \".join(map(str,ans[i])))\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\n\nM=[[0]*n for _ in range(n)]\n\nfor i in range(n):\n    M[0][i]=i+2\nfor i in range(1,n):\n    M[i][0]=n+i+1+ int(n%2==0)\n    \nfor i in range(1,n):\n    for j in range(1,n):\n        M[i][j]=M[i-1][j]*M[i][j-1]+1\n        \nfor row in M:\n    for r in row[:-1]:\n        print(r,end=' ')\n    print(row[-1])"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nfor i in range(N):\n    print(*list(range(2+i,N+2+i)))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\n\n#最大公約数\ndef gcd(a,b):\n\twhile b:\n\t\ta,b = b, a%b\n\treturn a\n\n#最小公倍数\ndef lcm(a,b):\n\treturn a*b // gcd(a,b)\n\nans = [[0]*N for i in range(N)]\n\ntmp = 2\nfor y in range(0,N,2):\n    for x in range(0,N,2):\n        ans[y][x] = tmp\n        tmp += 1\n\nfor y in reversed(range(1,N,2)):\n    for x in range(1,N,2):\n        ans[y][x] = tmp\n        tmp += 1\n\ned = defaultdict(bool)\nfor y in range(N):\n    for x in range(N):\n        if ans[y][x] == 0:\n            tmp = 1\n            if x > 0:\n                tmp = lcm(tmp,ans[y][x-1])\n            if x < N-1:\n                tmp = lcm(tmp,ans[y][x+1])\n            if y > 0:\n                tmp = lcm(tmp,ans[y-1][x])\n            if y < N-1:\n                tmp = lcm(tmp,ans[y+1][x])\n\n            while ed[tmp+1]:\n                tmp += tmp\n\n            ans[y][x] = tmp + 1\n            ed[tmp+1] = True\n\n\nfor a in ans:\n    print(' '.join(map(str,a)))\n"
  },
  {
    "language": "Python",
    "code": "def eratosthenes_generator():\n    yield 2\n    n = 3\n    h = {}\n    while True:\n        m = n\n        if n in h:\n            b = h[n]\n            m += 2 * b\n            while m in h:\n                m += 2 * b\n            h[m] = b\n            del h[n]\n        else:\n            m += 2 * n\n            while m in h:\n                m += 2 * n\n            h[m] = n\n            yield n\n        n += 2\n\n\ndef solve(n):\n    if n == 2:\n        return [[2, 3], [5, 4]]\n\n    ans = [[0] * n for _ in range(n)]\n    eg = eratosthenes_generator()\n    ps = [next(eg) for _ in range(2 * n)]\n    m = (n - 1) // 2\n\n    for i in range(n):\n        for j in range(i % 2, n, 2):\n            l1 = ps[(i + j) // 2]\n            l2 = ps[(i - j) // 2 + m + n]\n            ans[i][j] = l1 * l2\n\n    for i in range(n):\n        for j in range((i % 2) ^ 1, n, 2):\n            surroundings = 1\n            if i > 0:\n                surroundings *= ans[i - 1][j]\n            if i < n - 1:\n                surroundings *= ans[i + 1][j]\n            if j > 0:\n                surroundings *= ans[i][j - 1]\n            if j < n - 1:\n                surroundings *= ans[i][j + 1]\n            ans[i][j] = surroundings + 1\n\n    return ans\n\n\nn = int(input())\nans = solve(n)\nprint('\\n'.join(' '.join(map(str, row)) for row in ans))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [[None] * n for _ in range(n)]\n\nfrom fractions import gcd\n\ndef lcm(x, y=None):\n    if not y:\n        return x\n    return (x * y) // gcd(x, y)\n  \ndef next_num(a1=None, a2=None):\n    ret = next_num2(a1, a2, lb=2, m=1)\n    set_a.add(ret)\n    return ret\n  \ndef next_num2(a1=None, a2=None, lb=2, m=1):\n    if not a1:\n        return lb\n    if not a2:\n        l = a1-m\n    else:\n        l = gcd(a1-m, a2-m)\n    if l >= lb:\n\n        for i in range(2, 1 + int(l//2)):\n            # print(a1, a2, i)\n            if l % i == 0:\n                if not i in set_a:\n                    return i\n                if not l//i in set_a:\n                    return l//i\n        if not l in set_a:\n            return l\n    g = lcm(a1, a2)\n    g_ = g + 1\n    while True:\n        if not g_ in set_a:\n            return g_\n        g_ += g\n        \nset_a = set()\nfor i in range(n):\n    for j in range(n):\n        if i == 0:\n            if j == 0:\n                a[i][j] = next_num()\n            else:\n                if a[i][j-1] > 2:\n                    a[i][j] = next_num(a[i][j-1])\n                else:\n                    a[i][j] = next_num(a[i][j-1])\n        else:\n            if j == 0:\n                if i % 2 == 1:\n                    a[i][n-1-j] = next_num(a[i-1][n-1-j])\n                else:\n                    a[i][j] = next_num(a[i-1][j])\n            elif i % 2 == 1:\n                a[i][n-1-j] = next_num(a[i-1][n-1-j], a[i][n-j])\n            else:\n                a[i][j] = next_num(a[i-1][j], a[i][j-1])\nfor l in a:\n    print(*l)                 "
  },
  {
    "language": "Python",
    "code": "def genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\n\ndef eratosthenes_generator():\n    yield 2\n    n = 3\n    h = {}\n    while True:\n        m = n\n        if n in h:\n            b = h[n]\n            m += 2 * b\n            while m in h:\n                m += 2 * b\n            h[m] = b\n            del h[n]\n        else:\n            m += 2 * n\n            while m in h:\n                m += 2 * n\n            h[m] = n\n            yield n\n        n += 2\n\n\ndef solve(n):\n    if n == 2:\n        return [[2, 3], [5, 4]]\n\n    ans = [[0] * n for _ in range(n)]\n    eg = eratosthenes_generator()\n    ps = [next(eg) for _ in range(n)]\n    m = (n - 1) // 2\n\n    for i in range(n):\n        for j in range(i % 2, n, 2):\n            l1 = ps[(i + j) // 2]\n            l2 = ps[(i - j) // 2]\n            ans[i][j] = l1 * l2\n\n    for i in range(n):\n        for j in range((i % 2) ^ 1, n, 2):\n            surroundings = []\n            if i > 0:\n                surroundings.append(ans[i - 1][j])\n            if i < n - 1:\n                surroundings.append(ans[i + 1][j])\n            if j > 0:\n                surroundings.append(ans[i][j - 1])\n            if j < n - 1:\n                surroundings.append(ans[i][j + 1])\n            lcd = surroundings[0]\n            for s in surroundings[1:]:\n                lcd = lcd * s // gcd(lcd, s)\n            ans[i][j] = lcd + 1\n\n    return ans\n\n\nn = int(input())\nans = solve(n)\nprint('\\n'.join(' '.join(map(str, row)) for row in ans))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\na = []\nfor i in range(N):\n  a.append([0] * N)\ncur = 10001\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 == 0:\n      a[i][j] = cur\n      cur += 1\n\nfor i in range(N):\n  for j in range(N):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul *= a[i-1][j]\n      if j > 0:\n        mul *= a[i][j-1]\n      if i < N - 1:\n        mul *= a[i+1][j]\n      if j < N - 1:\n        mul *= a[i][j+1]\n      a[i][j] = mul + 1\n\nfor aList in a:\n  print(\" \".join(map(str,aList)))"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\nmii=lambda:map(int,input().split())\n\n# get primes\nlim=10000\nsieve=[1]*lim\nprime=[]\nfor i in range(2,lim):\n    if not sieve[i]: continue\n    prime.append(i)\n    for j in range(i*i,lim,i):\n        sieve[j]=0\n\n# create two arrays where adjacent elements divide each other\na1=[]\nfor i in range(250):\n    a1.append(prime[i])\n    a1.append(prime[i]*prime[i+1])\na2=[]\nfor i in range(255,505):\n    a2.append(prime[i])\n    a2.append(prime[i]*prime[i+1])\n\n# print matrix\nn=int(input())\nout=[[a1[i]*a2[j] for j in range(n)] for i in range(n)]\n\n# checking\nfor i in range(n-1):\n    for j in range(n):\n        x=out[i][j]\n        y=out[i+1][j]\n        if x<y: x,y=y,x\n        while x%y!=0: 1\n        x=out[j][i]\n        y=out[j][i+1]\n        if x<y: x,y=y,x\n        while x%y!=0: 1\ns=set()\nfor i in out:\n    for j in i:\n        s.add(j)\nwhile len(s)!=n**2: 1\nwhile max(s)>10**15: 1\nwhile min(s)<1: 1\n\n#for li in out: print(\" \".join(map(str,li)))\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\nfrom itertools import chain\n\n\ndef eratosthenes_generator():\n    yield 2\n    n = 3\n    h = {}\n    while True:\n        m = n\n        if n in h:\n            b = h[n]\n            m += 2 * b\n            while m in h:\n                m += 2 * b\n            h[m] = b\n            del h[n]\n        else:\n            m += 2 * n\n            while m in h:\n                m += 2 * n\n            h[m] = n\n            yield n\n        n += 2\n\n\ndef solve(n):\n    if n == 2:\n        return [[2, 3], [5, 4]]\n\n    ans = [[0] * n for _ in range(n)]\n    eg = eratosthenes_generator()\n    primes = [next(eg) for _ in range(2 * n)]\n    primes = list(chain.from_iterable(zip(primes, primes[::-1])))\n    ps = primes[:n]\n    qs = primes[n:2 * n]\n    m = (n - 1) // 2\n\n    for i in range(n):\n        for j in range(i % 2, n, 2):\n            l1 = ps[(i + j) // 2 - m]\n            l2 = qs[(i - j) // 2]\n            ans[i][j] = l1 * l2\n\n    for i in range(n):\n        for j in range((i % 2) ^ 1, n, 2):\n            surroundings = []\n            if i > 0:\n                surroundings.append(ans[i - 1][j])\n            if i < n - 1:\n                surroundings.append(ans[i + 1][j])\n            if j > 0:\n                surroundings.append(ans[i][j - 1])\n            if j < n - 1:\n                surroundings.append(ans[i][j + 1])\n            lcm = surroundings[0]\n            for s in surroundings[1:]:\n                lcm = lcm * s // gcd(lcm, s)\n            ans[i][j] = lcm + 1\n\n    return ans\n\n\ndef check(ans):\n    for i in range(n):\n        for j in range(n):\n            x = ans[i][j]\n            assert x <= 1e15, x\n            if i > 0:\n                y = ans[i - 1][j]\n                assert max(x, y) % min(x, y) == 1\n            if i < n - 1:\n                y = ans[i + 1][j]\n                assert max(x, y) % min(x, y) == 1\n            if j > 0:\n                y = ans[i][j - 1]\n                assert max(x, y) % min(x, y) == 1\n            if j < n - 1:\n                y = ans[i][j + 1]\n                assert max(x, y) % min(x, y) == 1\n    print('OK')\n\n\nn = int(input())\nans = solve(n)\n# check(ans)\nprint('\\n'.join(' '.join(map(str, row)) for row in ans))\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nm=int(input())\n\nn=502\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\np2=4\nq=26100\nq2=24998\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%3==0:\n                a[i][j] = p\n                p+=2\n#            elif i%2==0 and i%4!=0:\n#                a[i][j] = p2\n#                p2+=4\n            else:\n                a[i][j] = q\n                q-=2\n#            elif (i+1)%2==0 and (i+1)%4!=0:\n#                a[i][j] = q2\n#                q2-=4\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//16+1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//4 +1\n\n\nfor i in range(1,m+1):          \n    print(*a[i][1:m+1])\n    \n\n#for i in range(1,m+1):\n#    print(i)\n#    for j in range(1,m+1):\n#        print(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j])%min(a[i][j],a[i+1][j]),max(a[i][j],a[i][j+1]),min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j]),min(a[i][j],a[i+1][j]))\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nn=int(input())\n\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\nq=25000\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2!=0:\n                a[i][j] = p\n                p+=2\n            else:\n                a[i][j] = q\n                q-=2\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//16 +1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//4 +1\n                \n\nfor i in range(1,n+1):          \n    print(*a[i][1:n+1])\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport math\nfrom functools import reduce\n\ndef lcm_base(x,y):\n    return (x*y) // math.gcd(x,y)\n\ndef koubaisuu(i,j):\n    lst = [arr[i-1][j],arr[i+1][j],arr[i][j-1],arr[i][j+1]]\n    return reduce(lcm_base,lst,1)\n\nN = int(input())\nif N == 2:\n    print(4,7)\n    print(23,10)\n    exit()\narr = np.array([[0] * (N+2) for _ in range(N+2)])\narr[0,:],arr[:,0],arr[-1,:],arr[:,-1] = 1,1,1,1\n\nnums_lst = list(range(2, N ** 2 // 2 + 3))\n#print(nums_lst)\n\nfor i in range(1,N+1):\n    for j in range(1,N+1,2):\n        if i % 2 != 0:\n            arr[i][j] = nums_lst.pop(0)\n        else:\n            if j != N:\n                arr[i][j+1] = nums_lst.pop(-1)\n            else:\n                break\n            \nfor i in range(len(arr)):\n    for j in range(len(arr)):\n        if arr[i][j] == 0:\n            arr[i][j] = koubaisuu(i,j) + 1\n        \na = np.delete(arr,[0],1)\nb = np.delete(a,np.s_[-1],1)\nc = np.delete(b,[0],0)\nd = np.delete(c,np.s_[-1],0)\n\nfor i in d:\n    print(*i)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport math\nfrom functools import reduce\n\ndef lcm_base(x,y):\n    return (x*y) // math.gcd(x,y)\n\ndef koubaisuu(i,j):\n    lst = [arr[i-1][j],arr[i+1][j],arr[i][j-1],arr[i][j+1]]\n    return reduce(lcm_base,lst,1)\n\nN = int(input())\narr = np.array([[0] * (N+2) for _ in range(N+2)])\narr[0,:],arr[:,0],arr[-1,:],arr[:,-1] = 1,1,1,1\n\nnums_lst = list(range(2, N ** 2 // 2 + 3))\n#print(nums_lst)\n\nfor i in range(1,N+1):\n    for j in range(1,N+1,2):\n        if i % 2 != 0:\n            arr[i][j] = nums_lst.pop(0)\n        else:\n            if j != N:\n                arr[i][j+1] = nums_lst.pop(-1)\n            else:\n                break\n            \nfor i in range(len(arr)):\n    for j in range(len(arr)):\n        if arr[i][j] == 0:\n            arr[i][j] = koubaisuu(i,j) + 1\n        \na = np.delete(arr,[0],1)\nb = np.delete(a,np.s_[-1],1)\nc = np.delete(b,[0],0)\nd = np.delete(c,np.s_[-1],0)\n\nfor i in d:\n    print(*i)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nfrom fractions import gcd\n\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\nN = int(raw_input().replace(\"\\n\", \"\"))\n\nm = 2\n\nwhile m:\n    start_value = m + 1\n    try:\n        mat_N_i = np.asarray([start_value]).reshape(1, 1)\n\n        def get_value(in_mat, y, x):\n            if x == 0:\n                p = 1\n                while True:\n                    tmp = in_mat[y-1, 0] * p\n                    p += 1\n                    if tmp < m:\n                        continue\n                    out_value = tmp + m\n                    if out_value not in in_mat:\n                        break\n            elif y == 0:\n                p = 1\n                while True:\n                    tmp = in_mat[0, x-1] * p\n                    p += 1\n                    if tmp < m:\n                        continue\n                    out_value = tmp + m\n                    if out_value not in in_mat:\n                        break\n            else:\n                m11 = in_mat[y-1, x-1]\n                m12 = in_mat[y-1, x]\n                m21 = in_mat[y, x-1]\n                p = 1\n                while True:\n                    lcm_ = lcm(m12, m21)\n                    p += 1\n                    if lcm_ < m:\n                        continue\n                    m22 = lcm_ * p + m\n                    if m22 not in in_mat:\n                        break\n\n                out_value = m22\n            return out_value\n\n        def make_mat(in_mat, N_i):\n            out_mat = np.zeros((N_i + 1, N_i + 1)).astype(int)\n            out_mat[:N_i, :N_i] = in_mat\n            for k in xrange(N_i): # k = 0 to N_i - 1\n                out_mat[k, N_i] = get_value(out_mat, k, N_i)\n                out_mat[N_i, k] = get_value(out_mat, N_i, k)\n            out_mat[N_i, N_i] = get_value(out_mat, N_i, N_i)\n            return out_mat\n\n        for N_i in xrange(1, N):\n            mat_N_i = make_mat(mat_N_i, N_i)\n\n        break\n    except:\n        m += 1\n\nmat = mat_N_i.tolist()\nfor line in mat:\n    print \" \".join(map(str, line))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nMAX = 10**6\nmat = [[0]*n for i in range(n)]\nmat[0][0] = MAX\nfor i in range(1,2*n):\n  MAX-=2\n  for j in range(i+1):\n    try:\n      mat[i-j][j] = MAX\n    except:\n      pass\nfor i in mat:\n  print(*i)"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef primes(x):\n    if x < 2: return []\n\n    primes = [i for i in range(x)]\n    primes[1] = 0 # 1は素数ではない\n\n    for prime in primes:\n        if prime > math.sqrt(x): break\n        if prime == 0: continue\n        for non_prime in range(2 * prime, x, prime): primes[non_prime] = 0\n\n    return [prime for prime in primes if prime != 0]\n\n\ndef is_prime(x):\n    if x < 2: return False # 2未満に素数はない\n    if x == 2 or x == 3 or x == 5: return True # 2,3,5は素数\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0: return False # 2,3,5の倍数は合成数\n\n    prime = 7\n    step = 4\n    while prime <= math.sqrt(x):\n        if x % prime == 0: return False\n\n        prime += step\n        step = 6 - step\n\n    return True\n\np = primes(10**5)\n\nN = int(input())\n\nfor j in range(N):\n    ans = \"\"\n    for i in range(N):\n        ans += str(p[i+j])\n        if i != N-1:\n            ans += \" \"\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nif N == 2:\n    print(4, 7)\n    print(23, 10)\n    exit()\n\na= [[0] * N for _ in range(N)]\n\ndef sieve(n):\n    '''\n    :param n:\n    :return: n以下の素数のリストを返す\n    エラトステネスの篩→O(n log log n)\n    '''\n    prime = []\n    is_prime = [True] * (n + 1) #is_prime[i] = Trueならiは素数\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, n+1):\n        if is_prime[i]:\n            prime.append(i)\n            for j in range(2 * i, n + 1, i):\n                is_prime[j] = False\n    return prime\n\nP = sieve(8000) #len(P) > 1000\n\ndef p1(k):\n    return P[(k // 2) + 1]\n\ndef p2(k):\n    if k >= 0:\n        return P[(k // 2) + N + 1]\n    else:\n        return P[k // 2]\n\nfor i in range(N):\n    for j in range(N):\n        if (i + j) % 2 == 0:\n            a[i][j] = p1(i + j) * p2(i - j)\n        else:\n            a[i][j] = p1(i + j + 1) * p1(i + j - 1) * p2(i - j + 1) * p2(i - j - 1) + 1\n\nfor i in range(N):\n    print(' '.join(map(str, a[i])))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nm=int(input())\n\nn=500\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\np2=4\nq=25000\nq2=24998\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2==0 and i%4==0:\n                a[i][j] = p\n                p+=4\n            elif i%2==0 and i%4!=0:\n                a[i][j] = p2\n                p2+=4\n            elif (i+1)%2==0 and (i+1)%4==0:\n                a[i][j] = q\n                q-=4\n            elif (i+1)%2==0 and (i+1)%4!=0:\n                a[i][j] = q2\n                q2-=4\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//32 +1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1] +1\n\n\nfor i in range(1,m+1):          \n    print(*a[i][1:m+1])\n    \n\n#for i in range(1,m+1):\n #   print(i)\n  #  for j in range(1,m+1):\n   #     print(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j])%min(a[i][j],a[i+1][j]))\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\nmii=lambda:map(int,input().split())\n\n# get primes\nlim=10000\nsieve=[1]*lim\nprime=[]\nfor i in range(2,lim):\n    if not sieve[i]: continue\n    prime.append(i)\n    for j in range(i*i,lim,i):\n        sieve[j]=0\n\n# create two arrays where adjacent elements divide each other\na1=[]\nfor i in range(250):\n    a1.append(prime[i])\n    a1.append(prime[i]*prime[i+1])\na2=[]\nfor i in range(255,505):\n    a2.append(prime[i])\n    a2.append(prime[i]*prime[i+1])\n\n# print matrix\nn=int(input())\nfor i in range(n):\n    out=[a1[i]*a2[j] for j in range(n)]\n    print(\" \".join(map(str,out)))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nif N == 2:\n    print(4,7)\n    print(23,10)\n    exit()\n\nMAXN = 8000\nsieve = [0,0] + [1]*MAXN\nprimes = []\np = 2\nwhile p*p <= MAXN:\n    if sieve[p]:\n        primes.append(p)\n        for q in range(2*p,MAXN+1,p):\n            sieve[q] = 0\n    p += 1\nfor q in range(p,MAXN):\n    if sieve[q]:\n        primes.append(q)\n\nmem = [[[] for j in range(N)] for i in range(N)]\npi = 0\nfor i in range(0,2*N-1,4):\n    for x in range(N):\n        y = i-x\n        if y >= N: continue\n        if y < 0: break\n        mem[y][x].append(primes[pi])\n    pi += 1\nfor i in reversed(range(2,2*N-1,4)):\n    for x in range(N):\n        y = i-x\n        if y >= N: continue\n        if y < 0: break\n        mem[y][x].append(primes[pi])\n    pi += 1\n\nini = -((N-1)//2*2)\nfor i in range(ini,N,4):\n    for x in range(N):\n        y = x-i\n        if y < 0: continue\n        if y >= N: break\n        mem[y][x].append(primes[pi])\n    pi += 1\nfor i in range(ini+2,N,4):\n    for x in range(N):\n        y = x-i\n        if y < 0: continue\n        if y >= N: break\n        mem[y][x].append(primes[pi])\n    pi += 1\n\nans = [[None]*N for i in range(N)]\ndxy = [(1,0),(0,1),(-1,0),(0,-1)]\nfor y in range(N):\n    for x in range(N):\n        if (x+y)%2:\n            pset = set()\n            for dx,dy in dxy:\n                nx,ny = x+dx,y+dy\n                if not 0 <= nx < N: continue\n                if not 0 <= ny < N: continue\n                pset.add(mem[ny][nx][0])\n                pset.add(mem[ny][nx][1])\n            a = 1\n            for p in pset:\n                a *= p\n            ans[y][x] = a+1\n        else:\n            ans[y][x] = mem[y][x][0] * mem[y][x][1]\n\nfor row in ans:\n    print(*row)"
  },
  {
    "language": "Python",
    "code": "import itertools"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport random, math\n\ndef lcm(a, b):\n    return (a // math.gcd(a, b)) * b\n\ndef is_prime(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef primes(n):\n    lst = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            lst.append(i)\n    return lst\n\nn = int(input())\n\na = [[None for j in range(n)] for i in range(n)]\n\nlst = [(i,j) for i in range(n) for j in range(n - 1, -1, -1)]\n\nused = set()\npr = primes(10 ** 4)\n\noff = 0\nwhile pr[off] < n + 3:\n    off += 1\n\nfor (i, j) in lst:\n    if (i + j) % 2 == 0:\n        A = (i + j) // 2\n        B = n + (i - j) // 2\n        a[i][j] = (A + 1) * (pr[off + B])\n        if a[i][j] in used:\n            print(101, a[i][j])\n            raise ValueError()\n        used.add(a[i][j])\n        \nfor (i, j) in lst:\n    if (i + j) % 2 == 0:\n        continue\n    \n    val = 1\n    for (ip, jp) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n        if 0 <= ip < n and 0 <= jp < n and a[ip][jp] != None:\n            val = lcm(val, a[ip][jp])\n\n    if val >= 5 * 10 ** 14:\n        print(\"ERR\", val)\n        raise ValueError()\n    \n    res = val + 1\n    while res in used:\n        k = random.randint(1, (10 ** 15 - 1) // val)\n        res = k * val + 1\n\n    a[i][j] = res\n    used.add(res)\n\nfor i in range(n):\n    print(\" \".join(map(str, a[i])))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\n\n#最大公約数\ndef gcd(a,b):\n\twhile b:\n\t\ta,b = b, a%b\n\treturn a\n\n#最小公倍数\ndef lcm(a,b):\n\treturn a*b // gcd(a,b)\n\nans = [[0]*N for i in range(N)]\n\ntmp = 2\nfor y in range(N):\n\tif y%2 == 0:\n\t\txx = range(0,N,2)\n\telse:\n\t\txx = range(1,N,2)\n\n\tfor x in xx:\n\t\tpl = y+x+1\n\t\tmn = y-x + N*2 + N%2+1\n\t\tans[y][x] = pl*mn\n\ned = defaultdict(bool)\nfor y in range(N):\n    for x in range(N):\n        if ans[y][x] == 0:\n            tmp = 1\n            if x > 0:\n                tmp = lcm(tmp,ans[y][x-1])\n            if x < N-1:\n                tmp = lcm(tmp,ans[y][x+1])\n            if y > 0:\n                tmp = lcm(tmp,ans[y-1][x])\n            if y < N-1:\n                tmp = lcm(tmp,ans[y+1][x])\n\n            while ed[tmp+1]:\n                tmp += tmp\n\n            ans[y][x] = tmp + 1\n            ed[tmp+1] = True\n\n\nfor a in ans:\n    print(' '.join(map(str,a)))\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nm=int(input())\n\nn=502\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\np2=4\nq=26100\nq2=24998\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2==0:\n                a[i][j] = p\n                p+=2\n#            elif i%2==0 and i%4!=0:\n#                a[i][j] = p2\n#                p2+=4\n            elif (i+1)%2==0:\n                a[i][j] = q\n                q-=2\n#            elif (i+1)%2==0 and (i+1)%4!=0:\n#                a[i][j] = q2\n#                q2-=4\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//16+1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//4 +1\n\n\nfor i in range(1,m+1):          \n    print(*a[i][1:m+1])\n    \n\n#for i in range(1,m+1):\n#    print(i)\n#    for j in range(1,m+1):\n#        print(max(a[i][j],a[i][j+1])%min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j])%min(a[i][j],a[i+1][j]),max(a[i][j],a[i][j+1]),min(a[i][j],a[i][j+1]),max(a[i][j],a[i+1][j]),min(a[i][j],a[i+1][j]))\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\nN = input()\n\nprimes = [False, False] + [True] * 100000\n\nprime_ls = []\n\nfor i in range(100000):\n    if primes[i]:\n        prime_ls.append(i)\n        for j in range(i * 2, 100000, i):\n            primes[j] = False\n\nprimes = prime_ls[:1006]\n\nans = [[1] * 502 for i in range(502)]\n\nfor i in range(502):\n    for j in range(502):\n        if (i + j) % 2 == 0:\n            pos1 = (i + j) / 2\n            pos2 = 753 + (i - j) / 2\n            ans[i][j] *= primes[pos1]\n            ans[i][j] *= primes[pos2]\n\nfor i in range(1, 501):\n    for j in range(1, 501):\n        if (i + j) % 2 == 1:\n            ans[i][j] *= ans[i - 1][j]\n            ans[i][j] *= ans[i + 1][j]\n            ans[i][j] *= ans[i][j - 1]\n            ans[i][j] *= ans[i][j + 1]\n            ans[i][j] = int(math.sqrt(ans[i][j])) + 1\n\nfor i in range(1, N + 1):\n    print \" \".join(map(str, ans[i][1:N+1]))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nif N == 2:\n    print(2, 3)\n    print(5, 4)\n    exit()\n\na = [[1] * N for _ in range(N)]\n\nPN = [2]\nL = 3\nwhile len(PN) < N*2:\n    c = True\n    for p in PN:\n        if L % p == 0: c = False\n    if c == True: PN.append(L)\n    L += 2\n\ndef P1(k):\n    return PN[(k//2)]\n\ndef P2(k):\n    if k >= 0:\n        return PN[(k//2) + N]\n    else:\n        return PN[(k//2)]\n\nfor i in range(N):\n    for j in range(N):\n        if (i + j) % 2 == 0:\n            a[i][j] = P1(i + j) * P2(i - j)\n        else:\n            a[i][j] += P1(i + j + 1) * P1(i + j - 1) * P2(i - j + 1) * P2(i - j - 1)\n\nfor a_i in a:\n    print(*a_i)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\n\n#最大公約数\ndef gcd(a,b):\n\twhile b:\n\t\ta,b = b, a%b\n\treturn a\n\n#最小公倍数\ndef lcm(a,b):\n\treturn a*b // gcd(a,b)\n\nans = [[0]*N for i in range(N)]\n\ntmp = 2\nfor y in range(0,N,2):\n    for x in range(0,N,2):\n        ans[y][x] = tmp\n        tmp += 1\n\nfor y in reversed(range(1,N,2)):\n    for x in range(1,N,2):\n        ans[y][x] = tmp\n        tmp += 1\n\nfor y in range(N):\n    for x in range(N):\n        if ans[y][x] == 0:\n            tmp = 1\n            if x > 0:\n                tmp = lcm(tmp,ans[y][x-1])\n            if x < N-1:\n                tmp = lcm(tmp,ans[y][x+1])\n            if y > 0:\n                tmp = lcm(tmp,ans[y-1][x])\n            if y < N-1:\n                tmp = lcm(tmp,ans[y+1][x])\n            ans[y][x] = tmp + 1\n\nfor a in ans:\n    print(' '.join(map(str,a)))\n"
  },
  {
    "language": "Python",
    "code": "import math, itertools"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\nmii=lambda:map(int,input().split())\n\n# get primes\nlim=10000\nsieve=[1]*lim\nprime=[]\nfor i in range(2,lim):\n    if not sieve[i]: continue\n    prime.append(i)\n    for j in range(i*i,lim,i):\n        sieve[j]=0\n\nprime.sort()\nprime=[i for i in prime if i>500]\nprime=prime[:500]\nli=[]\nwhile prime:\n    li.append(prime.pop(0))\n    li.append(prime.pop(-1))\npowers=li\n\n# print matrix\nn=int(input())\nout=[[0 for j in range(n)] for i in range(n)]\n\ns=set()\nfor i in range(n):\n    for j in range(n):\n        if (i+j)%2==0:\n            # put small number\n            out[i][j]=powers[(i+j)//2]*(i+1)\n            if out[i][j] in s:\n                print(\"why\",i,j)\n            s.add(out[i][j])\n\nfor i in range(n):\n    for j in range(n):\n        if (i+j)%2==1:\n            # put big number\n            big=i+1\n            if i>0: big*=i\n            if i<n-1: big*=i+2\n            big*=powers[(i+j)//2]\n            big*=powers[(i+j+1)//2]\n            k=1\n            while big*k+1 in s: k+=1\n            out[i][j]=big*k+1\n            s.add(out[i][j])\n\n\n# checking\nif 0:\n    for i in range(n-1):\n        for j in range(n):\n            x=out[i][j]\n            y=out[i+1][j]\n            if x<y: x,y=y,x\n            while x%y!=1: 1\n            x=out[j][i]\n            y=out[j][i+1]\n            if x<y: x,y=y,x\n            while x%y!=1: 1\n    s=set()\n    for i in out:\n        for j in i:\n            s.add(j)\n    while len(s)!=n**2: 1\n    while max(s)>10**15: 1\n    while min(s)<1: 1\n\nfor li in out: print(\" \".join(map(str,li)))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nx = N\ny = N+1\na = [[0 for i in range(N)] for j in range(N)]\nodds = [2*i for i in range(int((N+1)/2))]\nevens = [2*i+1 for i in range(int(N/2))]\n\nif N==2:\n    print(\"4 7\")\n    print(\"23 10\")\nelse:\n    for i in odds:\n        for j in odds:\n            a[i][j] = x\n            x += 2\n    for i in evens:\n        for j in evens:\n            a[i][j] = y\n            y += 2\n\n    for i in odds:\n        for j in evens:\n            ans = 1\n            ans *= a[i][j - 1]\n            if j < N - 1:\n                ans *= a[i][j + 1]\n            if i > 0:\n                ans *= a[i - 1][j]\n            if i < N - 1:\n                ans *= a[i + 1][j]\n            ans += 1\n            a[i][j] = ans\n\n    for i in evens:\n        for j in odds:\n            ans = 1\n            ans *= a[i - 1][j]\n            if i < N - 1:\n                ans *= a[i + 1][j]\n            if j > 0:\n                ans *= a[i][j - 1]\n            if j < N - 1:\n                ans *= a[i][j + 1]\n            ans += 1\n            a[i][j] = ans\n\n    for i in range(N):\n        print(\" \".join(str(j) for j in a[i]))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\na= [[0] * N for _ in range(N)]\n\nif N == 2:\n    print(4, 7)\n    print(23, 10)\n    exit()\n\ndef sieve(n):\n    '''\n    :param n:\n    :return: n以下の素数のリストを返す\n    エラトステネスの篩→O(n log log n)\n    '''\n    prime = []\n    is_prime = [True] * (n + 1) #is_prime[i] = Trueならiは素数\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, n+1):\n        if is_prime[i]:\n            prime.append(i)\n            for j in range(2 * i, n + 1, i):\n                is_prime[j] = False\n    return prime\n\nP = sieve(8 * (10 ** 5))\nfor i in range((N + 1) // 2):\n    for j in range((N + 1) // 2):\n        a[2 * i][2 * j] = P[i * ((N + 1) // 2) + j + 1]\n\nfor i in range(N // 2):\n    for j in range(N // 2):\n        a[2 * i + 1][2 * j + 1] = P[-(i * (N // 2) + j + 1)]\n\n\ndef prod_around(x, y):\n    #a[x][y]の周囲のマスの積 + 1 を返す\n    ans = 1\n    diff = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for d in diff:\n        i, j = d\n        if 0 <= x + i < N and 0 <= y + j < N:\n            ans *= a[x + i][y + j]\n    ans += 1\n    return ans\n\nfor i in range((N + 1) // 2):\n    for j in range(N // 2):\n        a[2 * i][2 * j + 1] = prod_around(2 * i, 2 * j + 1)\n        a[2 * j + 1][2 * i] = prod_around(2 * j + 1, 2 * i)\n\nfor i in range(N):\n    print(' '.join(map(str, a[i])))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n \na = []\nfor i in range(N + 2):\n  a.append([0] * N + 2)\ncur = 101\nfor i in range(N + 2):\n  for j in range(N + 2):\n    if (i + j) % 2 == 0:\n      a[i][j] = cur\n      cur += 1\n\nfor i in range(N + 2):\n  for j in range(N + 2):\n    if (i + j) % 2 != 0:\n      mul = 1\n      if i > 0:\n        mul *= a[i-1][j]\n      if j > 0:\n        mul *= a[i][j-1]\n      if i < N - 1:\n        mul *= a[i+1][j]\n      if j < N - 1:\n        mul *= a[i][j+1]\n      a[i][j] = mul + 1\n\n      \nfor aList in a[1:-1]:\n  print(\" \".join(map(str,aList[1:-1])))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nn=int(input())\n\na=[[1]*(n+2) for _ in range(n+2)]\n\nc=0\n\np=2\nq=25000\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==0:\n            if i%2!=0:\n                a[i][j] = p\n                p+=2\n            else:\n                a[i][j] = q\n                q-=2\n        \n    \n#print(a)\n\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        if (i+j)%2==1:\n            a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1]//16 +1\n            if i==1 or i==n or j==1 or j==n:\n                a[i][j] = a[i-1][j]*a[i+1][j]*a[i][j-1]*a[i][j+1] +1\n\n\nfor i in range(1,n+1):          \n    print(*a[i][1:n+1])\n    \n    \n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\n\n#最大公約数\ndef gcd(a,b):\n\twhile b:\n\t\ta,b = b, a%b\n\treturn a\n\n#最小公倍数\ndef lcm(a,b):\n\treturn a*b // gcd(a,b)\n\ndef hurui(n):\n    data = [i for i in range(2, n + 1)]\n    for d in data:\n        data = [x for x in data if (x == d or x % d != 0)]\n    return data\n\nPrimes = hurui(8000)\n\npn = []\nfor p in Primes:\n\tpn.append(p)\n\nans = [[0]*N for i in range(N)]\nfor y in range(N):\n\tif y%2 == 0:\n\t\txx = range(0,N,2)\n\telse:\n\t\txx = range(1,N,2)\n\n\tfor x in xx:\n\t\tpl = (y+x)//2\n\t\tmn = (y-x)//2 + N + (N-1)//2\n\t\tans[y][x] = pn[pl]*pn[mn]\n\ned = defaultdict(bool)\nfor y in range(N):\n    for x in range(N):\n        if ans[y][x] == 0:\n            tmp = 1\n            if x > 0:\n                tmp = lcm(tmp,ans[y][x-1])\n            if x < N-1:\n                tmp = lcm(tmp,ans[y][x+1])\n            if y > 0:\n                tmp = lcm(tmp,ans[y-1][x])\n            if y < N-1:\n                tmp = lcm(tmp,ans[y+1][x])\n\n            while ed[tmp+1]:\n                tmp += tmp\n\n            ans[y][x] = tmp + 1\n            ed[tmp+1] = True\n\nfor a in ans:\n    print(' '.join(map(str,a)))\n"
  },
  {
    "language": "Python",
    "code": "tmp = 1\nflag = 0\nn = int(input())\nmat = [[0]*n for i in range(n)]\nfor i in range(0,2*n,2):\n  for j in range(i+1):\n    try:\n      if flag == 0:\n        mat[i-j][j] = tmp\n        flag = 1\n        tmp += 1\n      else:\n        mat[i-j][j] = (n*n+1)//2-tmp+2\n        flag = 0\n    except:\n      pass\nfor i in range(n):\n  for j in range(n):\n    if mat[i][j]==0:\n      a = 1;b=1;c=1;d=1\n      if i-1 >= 0:\n        a = mat[i-1][j]\n      if i+1<=n-1:\n        b = mat[i+1][j]\n      if j-1 >= 0:\n        c = mat[i][j-1]\n      if j+1<= n-1:\n        d = mat[i][j+1]\n      mat[i][j] = a*b*c*d +1\nfor i in mat:\n  print(*i)"
  },
  {
    "language": "Python",
    "code": "    if l % 2==1:\n        for i in range(3):\n            if i == 0:\n                ans[2][i] = ans[1][i]+1\n                continue\n            if i == 2:\n                ans[2][i] = ans[2][i-1]+1\n                continue\n            ans[2][i] = lcm(ans[2][i-1],ans[1][i])+1\n#print(ans)\n        for i in range(1,-1,-1):\n    #print(i)\n            ans[i][2] = lcm(ans[i+1][2],ans[i][1])+1"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\nN = int(input())\n\n  \n\ndef search(num1,num2, m):\n  i = 1\n  while(True):\n    ans = i * num1 + m\n    if ans % num2 == m:\n      return ans\n    i += 1\n\nm = 3\n\nans = np.zeros((N,N), dtype = np.uint64)\nans[0,0] = 4\nans[0,1] = 7\na,b = 0,1\nfor i in range(N-1):\n  if i % 2 == 0:\n    for j in range(i+1):\n      a += 1\n      if ans[a, b-1]== 0:\n        ans[a,b] = ans[a-1, b] + m\n      else:\n        ans[a,b] = search(ans[a-1, b], ans[a, b-1], m)\n    for j in range(i+1):\n      b -= 1\n      ans[a,b] = search(ans[a, b+1],ans[a-1, b], m)\n    if i+2 < N:\n      a += 1\n      ans[a,b] = ans[a-1,b] + m\n  else:\n    for j in range(i+1):\n      b += 1\n      if ans[a-1, b] == 0:\n        ans[a,b] = ans[a,b-1]+m\n      else:\n        ans[a,b] = search(ans[a, b-1], ans[a-1, b], m)\n    for j in range(i+1):\n      a -= 1\n      ans[a,b] = search(ans[a+1, b], ans[a, b-1], m)\n    if i + 2 < N:\n      b += 1\n      ans[a,b] = ans[a, b-1] + m\n\nfor i in range(N):\n  a = list(ans[i,:])\n  print(' '.join(map(str, a)))\n    \n      \n    \n  \n    \n    \n\n "
  },
  {
    "language": "Python",
    "code": "from math import gcd\nfrom itertools import groupby\n \ndef genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break\n \nn = int(input())"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom math import gcd\nfrom itertools import groupby\n\ndef genprime():\n    m = 10000\n    primes = []\n    vis = [True] * m\n    for i in range(2, m):\n        if vis[i]:\n            primes.append(i)\n            yield i\n        for p in primes:\n            foo = i * p\n            if foo >= m:\n                break\n            vis[foo] = False\n            if i % p == 0:\n                break\n\nn = int(stdin.readline())\nres = [[1 for i in range(n)] for j in range(n)]\ncoord = [(i, j) for i in range(n) for j in range(n) if (i + j) % 2 == 0]\ngen = genprime()\n\nfoo = sorted(coord, key = lambda x: x[0] + x[1])\nfor i, p in zip(groupby(foo, lambda x: x[0] + x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nfoo = sorted(coord, key = lambda x: x[0] - x[1])\nfor i, p in zip(groupby(foo, lambda x: x[0] - x[1]), gen):\n    for j in list(i[1]):\n        res[j[0]][j[1]] *= p\n\nlcm = lambda x, y: x // gcd(x, y) * y\n\nfor i in range(0, n):\n    for j in range(0, n):\n        if (i + j) % 2 == 0:\n            continue\n        if i > 0:\n            res[i][j] = lcm(res[i][j], res[i - 1][j])\n        if j > 0:\n            res[i][j] = lcm(res[i][j], res[i][j - 1])\n        if i < n - 1:\n            res[i][j] = lcm(res[i][j], res[i + 1][j])\n        if j < n - 1:\n            res[i][j] = lcm(res[i][j], res[i][j + 1])\n\nif n == 2:\n    res = [[2, 3], [5, 4]]\n\nfor i in range(0, n):\n    print(*res[i])"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nv1 = [0 for i in range(n+100)]\nfor i in range(n):\n    if i % 2 == 1:\n        v1[i] = 4\n    if i % 2 == 0:\n        v1[i] = 7\n    \n\nv2 = [0 for i in range(n)]\nfor i in range(n):\n    if i % 2 == 1:\n        v2[i] = 23\n    if i % 2 == 0:\n        v2[i] = 10\n\nfor i in range(n):\n    if i % 2 == 1:\n        for i in range(n-1):\n            print(v1[i], end=\" \")\n        print(v1[n-1])\n    if i % 2 == 0:\n        for i in range(n-1):\n            print(v2[i], end=\" \")\n        print(v2[n-1])"
  },
  {
    "language": "Python",
    "code": "import math\nn=int(input())\n\ndef lcm(a,b):\n\treturn a*b//math.gcd(a,b)\n\ndef lcm3(a,b,c):\n\treturn lcm(lcm(a,b),c)\n\ndef lcm4(a,b,c,d):\n\treturn lcm(lcm(a,b),lcm(c,d))\n\na=[0]*(n*n)\nx=set([1])\ns=2\nfor i in range(0,n*n):\n\tif (i//n+i%n)%2==0:\n\t\ta[i]=s\n\t\tx.add(s)\n\t\ts+=1\n#print(a)\nfor i in range(0,n*n):\n\tif a[i]==0:\n\t\tj=i//n\n\t\tk=i%n\n\t\tif j==0 and k==n-1:\n\t\t\tm=lcm(a[i-1],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==n-1 and k==0:\n\t\t\tm=lcm(a[i+1],a[i-n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==0:\n\t\t\tm=lcm3(a[i-1],a[i+1],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif j==n-1:\n\t\t\tm=lcm3(a[i-1],a[i+1],a[i-n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif k==0:\n\t\t\tm=lcm3(a[i+1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telif k==n-1:\n\t\t\tm=lcm3(a[i-1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\t\telse:\n\t\t\tm=lcm4(a[i+1],a[i-1],a[i-n],a[i+n])\n\t\t\tl=m+1\n\t\t\twhile l in x:\n\t\t\t\tl+=m\n\t\t\ta[i]=l\n\t\t\tx.add(l)\n\nfor i in range(n):\n\tprint(' '.join(map(str,a[i*n:i*n+n])))\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused)]\nuse std::io::*;\n#[allow(unused)]\nuse std::str::*;\n#[allow(unused)]\nuse std::collections::*;\n\npub fn read_from<T: FromStr, R: Read>(s: &mut R) -> T {\n    let s = s.bytes().map(|c| c.unwrap() as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect::<String>();\n    if s.is_empty() {\n        if cfg!(local) {\n            // eprintln!(\"reached to EOF\");\n        }\n        std::process::exit(0)\n    }\n    s.parse::<T>().unwrap_or_else(|_| panic!(\"failed to parse {}\", s))\n}\n\npub fn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let mut stdin = stdin.lock();\n    read_from(&mut stdin)\n}\n\npub const MOD: u64 = 1000000007;\n\nfn main() {\n    let n: usize = read();\n    for i in 0..n {\n        for j in 0..n {\n            print!(\"{}{}\", i + j + 1, if j + 1 == n { '\\n' } else { ' ' });\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused)]\nuse std::io::*;\n#[allow(unused)]\nuse std::str::*;\n#[allow(unused)]\nuse std::collections::*;\n\npub fn read_from<T: FromStr, R: Read>(s: &mut R) -> T {\n    let s = s.bytes().map(|c| c.unwrap() as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect::<String>();\n    if s.is_empty() {\n        if cfg!(local) {\n            // eprintln!(\"reached to EOF\");\n        }\n        std::process::exit(0)\n    }\n    s.parse::<T>().unwrap_or_else(|_| panic!(\"failed to parse {}\", s))\n}\n\npub fn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let mut stdin = stdin.lock();\n    read_from(&mut stdin)\n}\n\npub const MOD: u64 = 1000000007;\n\nfn main() {\n    let n: usize = read();\n    for i in 0..n {\n        for j in 0..n {\n            print!(\"{} \", i + j + 1);\n        }\n        println!(\"\");\n    }\n}\n\n"
  }
]