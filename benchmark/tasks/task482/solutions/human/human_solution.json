[
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint enc(int y,int m,int d){\n  return y*31*12 + m * 31 + d;\n}\n\nint main() {\n  int n;scanf(\"%d\",&n);\n  vector<string> ts(n),as(n);vector<int> ds(n);\n  REP(i,n){\n\tcin >> ts[i] >> as[i];\n\tstring dstr;cin >> dstr;\n\tint y,m,d;sscanf(dstr.c_str(),\"%d/%d/%d\",&y,&m,&d);\n\tds[i]=enc(y,m,d);\n  }\n\n  int m;scanf(\"%d\",&m);\n  REP(i,m){\n\tstring t,a;\n\tcin >> t >> a;\n\tint dl=-(1<<28),dr=1<<28;\n\tstring dlstr,drstr;cin >> dlstr >> drstr;\n\tif(dlstr!=\"*\"){\n\t  int y,m,d;sscanf(dlstr.c_str(),\"%d/%d/%d\",&y,&m,&d);\n\t  dl=enc(y,m,d);\n\t}\n\tif(drstr!=\"*\"){\n\t  int y,m,d;sscanf(drstr.c_str(),\"%d/%d/%d\",&y,&m,&d);\n\t  dr=enc(y,m,d);\n\t}\n\tREP(j,n){\n\t  bool ok=true;\n\n\t  if(t!=\"*\" && ts[j].find(t)==string::npos)ok=false;\n\t  if(a!=\"*\" && as[j].find(a)==string::npos)ok=false;\n\t  if(!(dl<= ds[j] && ds[j] <=dr))ok=false;\n\t  if(ok){\n\t\tcout << ts[j] <<endl;\n\t  }\n\t}\n\tcout <<endl;\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,flag2,len,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to,out;\n  queue<string> Q;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  flag2=0;\n  for(i=0;i<q;i++){\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0){\n\tQ.push(title[j]);\n      }\n    }\n    if(flag2!=0&&Q.empty()!=1) cout << endl;\n    if(Q.empty()==1) cout << endl;\n    len=Q.size();\n    for(j=0;j<len;j++){\n      out=Q.front();\n      Q.pop();\n      cout << out << endl;\n      flag2=1;\n    }\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int len,len2,i,j,l,flag=0,cnt=0;\n  if(c==\"title\"){\n    len=title[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==title[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }else{\n    len=author[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==author[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n;\n  cin>>n;\n  vector<string> ts(n),as(n),ds(n);\n  for(Int i=0;i<n;i++) cin>>ts[i]>>as[i]>>ds[i];\n\n  Int q;\n  cin>>q;\n  for(Int i=0;i<q;i++){\n    if(i) cout<<endl;\n    string a,b,c,d;\n    cin>>a>>b>>c>>d;\n    for(Int j=0;j<n;j++){\n      Int flg=1;\n      if(a!=\"*\"){\n\tflg&=ts[j].find(a)!=string::npos;\n      }\n      if(b!=\"*\"){\n\tflg&=as[j].find(b)!=string::npos;\n      }\n      if(c!=\"*\"){\n\tflg&=ds[j]>=c;\n      }\n      if(d!=\"*\"){\n\tflg&=ds[j]<=d;\n      }\n      \n      if(flg) cout<<ts[j]<<endl;\n    }\n  }\n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring title[101];\nstring aut[101];\nint era[101];\n\nint henkan(string a) {\n  int c = 0;\n  int sum = 0;\n  int cnt =0;\n  for(int i=0;i<a.size();i++) {\n    if(a[i] == '/') continue;\n    c *= 10;\n    c += a[i]-'0';\n  }\n  sum = c;\n  return sum;\n}\n\nint check(string a,string b) {\n  if(a.size() > b.size()) return 1;\n  else \n    for(int j=0;j<b.size();j++) {\n      if(a[0] == b[j] && a.size() <= b.size()-j) {\n\tint cnt = 1;\n\tfor(int k=1;k<a.size();k++)\n\t  if(a[k] == b[j+k])cnt++;\n\tif(cnt == a.size()) return 0;\n      }\n    }\n  return 1;\n}\n\nint main() {\n\n  int n;\n  cin >>n;\n  for(int i=0;i<n;i++) {\n    string a;\n    cin >> title[i] >> aut[i] >> a;\n    era[i] = henkan(a);\n  }\n\n\n  int m;\n  cin >> m;\n  for(int i=0;i<m;i++) {\n    string t,a,ef,et;\n    cin >> t >> a >>ef >>et;\n    int ief = henkan(ef),iet = henkan(et);\n    if(ef == \"*\") ief = 0;\n    if(et == \"*\") iet = 1000000000;\n\n    if(i != 0) cout << endl;\n    int flg[101] = {};\n    for(int j=0;j<n;j++) {\n      if(t != \"*\") flg[j] = check(t,title[j]);\n      if(a != \"*\") if(check(a,aut[j]) == 1) flg[j] = 1;\n      //  cout << flg[i] <<endl;\n      if(!(ief<=era[j] &&  era[j] <= iet)) flg[j] = 1;  \n      if(flg[j] == 0) cout << title[j] <<endl;\n    }\n  \n  \n  }\n\n  return 0;\n  \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring title[111],auther[111];\nint date[111];\nint N,Q;\n\nbool flag[111];\nvoid search1(string s){\n  for(int i=0;i<N;i++){\n    if( title[i].find(s) == string::npos ) flag[i] = true;\n  }\n}\nvoid search2(string s){\n  for(int i=0;i<N;i++){\n    if( auther[i].find(s) == string::npos ) flag[i] = true; \n  }\n}\nvoid search3(int day){\n  for(int i=0;i<N;i++){\n    if( date[i] < day ) flag[i] = true;\n  }\n}\nvoid search4(int day){\n  for(int i=0;i<N;i++){\n    if( date[i] > day ) flag[i] = true;\n  }\n}\n\nint getday(int h,int m,int d){ return h *  1000 + m * 32 + d; }\n\nint main(){\n  scanf(\"%d\",&N);\n  char buf[111],buf1[111],buf2[111],buf3[111];\n  int h,m,d;\n  \n  for(int i=0;i<N;i++){\n    scanf(\"%s %s %d/%d/%d\",buf,buf1,&h,&m,&d);\n    title[i] = buf;\n    auther[i] = buf1;\n    date[i] = getday(h,m,d);\n  }\n  \n  scanf(\"%d\",&Q);\n  for(int i=0;i<Q;i++){\n    scanf(\"%s %s %s %s\",buf,buf1,buf2,buf3);\n    string s;\n    memset(flag,0,sizeof(flag));\n    if( buf[0] != '*' ){\n      s = buf; search1(s);\n    }\n    if( buf1[0] != '*' ){\n      s = buf1; search2(s);\n    }\n    if( buf2[0] != '*' ){\n      sscanf(buf2,\"%d/%d/%d\",&h,&m,&d);\n      search3( getday(h,m,d) );\n    }\n    if( buf3[0] != '*' ){\n      sscanf(buf3,\"%d/%d/%d\",&h,&m,&d);\n      search4( getday(h,m,d) );\n    }\n    if( i > 0 ) puts(\"\");\n    for(int i=0;i<N;i++){\n      if( flag[i] == false ){\n        printf(\"%s\\n\",title[i].c_str());\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[4];\n\t\trep (k, 4 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from <= curr  ) search[3].push_back (search[2][i] );\n\t\t} // end rep\n\n\t\trep (i, search[3].size() ){\n\t\t\tll curr = search[3][i].datenum;\n\t\t\tif (curr <= to  ) res.push_back (search[3][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<functional>\n#include<algorithm>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n\nint f(const string &s){\n\tif(s[0]=='*')return -1;\n\tint res=0;\n\trep(i,s.size()){\n\t\tif(s[i]!='/'){\n\t\t\tres=res*10+s[i]-'0';\n\t\t}\n\t}\n\treturn res;\n}\n\nbool contain(const string &s,const string &t){\n\trep(i,s.size()){\n\t\tif(s.compare(i,t.size(),t)==0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n;\n\tstring title[100],auther[100];\n\tint date[100];\n\tint q;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>title[i]>>auther[i]>>s;\n\t\tdate[i]=f(s);\n\t}\n\tcin>>q;\n\trep(i,q){\n\t\tif(i)cout<<endl;\n\t\tstring ti,au,s,t;\n\t\tint from,to;\n\t\tcin>>ti>>au>>s>>t;\n\t\tfrom=f(s);\n\t\tto=f(t);\n\t\trep(j,n){\n\t\t\tif( (ti==\"*\"||contain(title[j],ti)) && (au==\"*\"||au==auther[j])\n\t\t\t\t&& (from<=date[j]) && (to==-1||to>=date[j]) ){\n\t\t\t\t\tcout<<title[j]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint N, Q, y, m, d, date[100]; string a, b, c, d, book[100], auth[100];\nint main() {\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> book[i] >> auth[i] >> a;\n\t\tsscanf(a.c_str(), \"%d/%02d/%02d\", y, m, d);\n\t\tdate[i] = y * 10000 + m * 100 + d;\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> a >> b >> c >> d;\n\t\tif(i) cout << endl;\n\t\tif(c != \"*\") sscanf(c.c_str(), \"%d/%02d/%02d\", y, m, d);\n\t\tint d1 = y * 10000 + m * 100 + d;\n\t\tif(d != \"*\") sscanf(d.c_str(), \"%d/%02d/%02d\", y, m, d);\n\t\tint d2 = y * 10000 + m * 100 + d;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tbool f1 = (a == \"*\" || book[i].find(a) != string::npos);\n\t\t\tbool f2 = (b == \"*\" || auth[i].find(b) != string::npos);\n\t\t\tbool f3 = (c == \"*\" || date[i] >= d1);\n\t\t\tbool f4 = (d == \"*\" || date[i] <= d2);\n\t\t\tif(f1 && f2 && f3 && f4) cout << book[i] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nstruct Info{\n\tchar title[51],author[51];\n\tint year,month,day;\n};\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nbool partialCmp(char* base, char* comp){\n\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 < length2)return false;\n\n\tif(length2 == 1 && comp[0] == '*')return true;\n\n\tbool FLG;\n\n\tint limit = length1-length2;\n\n\tfor(int left=0;left <= limit; left++){\n\t\tFLG = true;\n\t\tfor(int i = 0; i < length2; i++){\n\t\t\tif(base[left+i] != comp[i]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(FLG)return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\tInfo info[N];\n\n\tchar TITLE[51],AUTHOR[51],P_DATE[11];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %s %s\",TITLE,AUTHOR,P_DATE);\n\t\tstrcpy(info[i].title,TITLE);\n\t\tstrcpy(info[i].author,AUTHOR);\n\n\t\tinfo[i].year = 1000*(P_DATE[0]-'0') + 100*(P_DATE[1]-'0') + 10*(P_DATE[2]-'0')+(P_DATE[3]-'0');\n\t\tinfo[i].month = 10*(P_DATE[5]-'0')+(P_DATE[6]-'0');\n\t\tinfo[i].day = 10*(P_DATE[8]-'0')+(P_DATE[9]-'0');\n\t}\n\n\tint Q;\n\n\tscanf(\"%d\",&Q);\n\n\tchar Q_title[51],Q_author[51],Q_from[11],Q_to[11];\n\n\tint from_year,from_month,from_day,to_year,to_month,to_day;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\n\t\tscanf(\"%s %s %s %s\",Q_title,Q_author,Q_from,Q_to);\n\n\t\tif(Q_from[0] == '*'){\n\t\t\tfrom_year = 0;\n\t\t}else{\n\t\t\tfrom_year = 1000*(Q_from[0]-'0') + 100*(Q_from[1]-'0') + 10*(Q_from[2]-'0')+(Q_from[3]-'0');\n\t\t\tfrom_month = 10*(Q_from[5]-'0')+(Q_from[6]-'0');\n\t\t\tfrom_day = 10*(Q_from[8]-'0')+(Q_from[9]-'0');\n\t\t}\n\n\t\tif(Q_to[0] == '*'){\n\t\t\tto_year = 9999;\n\t\t}else{\n\t\t\tto_year = 1000*(Q_to[0]-'0') + 100*(Q_to[1]-'0') + 10*(Q_to[2]-'0')+(Q_to[3]-'0');\n\t\t\tto_month = 10*(Q_to[5]-'0')+(Q_to[6]-'0');\n\t\t\tto_day = 10*(Q_to[8]-'0')+(Q_to[9]-'0');\n\t\t}\n\n\t\tif(loop > 0)printf(\"\\n\");\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(partialCmp(info[i].title,Q_title) == true && partialCmp(info[i].author,Q_author) == true){ //??????????????¨???????????¨????????´???OK\n\t\t\t\tif((from_year < info[i].year) || (from_year == info[i].year && from_month < info[i].month) ||\n\t\t\t\t\t\t(from_year == info[i].year && from_month == info[i].month && from_day <= info[i].day)){ //from??\\???\n\t\t\t\t\tif((to_year > info[i].year) || (to_year == info[i].year && to_month > info[i].month) ||\n\t\t\t\t\t\t\t(to_year == info[i].year && to_month == info[i].month && to_day >= info[i].day)){\n\t\t\t\t\t\tprintf(\"%s\\n\",info[i].title);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 からの経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tll res = 0LL;\n\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from <= curr && curr < to ) res.push_back (search[2][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Date\n{\n    int year,month,day;\n\n    Date(){}\n    Date(string s)\n    {\n        year=atoi(s.substr(0,4).c_str());\n        month=atoi(s.substr(5,2).c_str());\n        day=atoi(s.substr(8,2).c_str());\n    }\n\n    int releasedAfter(Date b)\n    {\n        if(year>b.year) return 1;\n        else if(year==b.year)\n        {\n            if(month>b.month) return 1;\n            else if(month==b.month)\n            {\n                if(day>b.day) return 1;\n            }\n        }\n        return 0;\n    }\n\n    int releasedBefore(Date b)\n    {\n        if(year<b.year) return 1;\n        else if(year==b.year)\n        {\n            if(month<b.month) return 1;\n            else if(month==b.month)\n            {\n                if(day<b.day) return 1;\n            }\n        }\n        return 0;\n    }\n};\n\nstruct Book\n{\n    string title,author;\n    Date date;\n\n    Book(){}\n    Book(string a, string b, Date c)\n    {\n        title=a;\n        author=b;\n        date=c;\n    }\n\n    int searchString(string q, string s)\n    {\n        int Q=q.size(), S=s.size();\n\n        rep(i,S-Q+1)\n        {\n            if(s.substr(i,Q)==q) return 1;\n        }\n        return 0;\n    }\n\n    int includeTitle(string q)\n    {\n        return searchString(q,title);\n    }\n    int includeAuthor(string q)\n    {\n        return searchString(q,author);\n    }\n    int releasedBefore(Date q)\n    {\n        return date.releasedBefore(q);\n    }\n    int releasedAfter(Date q)\n    {\n        return date.releasedAfter(q);\n    }\n};\n\nint main()\n{\n    int n;\n    cin >>n;\n\n    vector<Book> b(n);\n    rep(i,n)\n    {\n        string x,y,z;\n        cin >>x >>y >>z;\n        b[i]=Book(x,y,Date(z));\n    }\n\n    int Q;\n    cin >>Q;\n    rep(q,Q)\n    {\n        string t,a,from,to;\n        cin >>t >>a >>from >>to;\n\n        vector<int> ok(n,1);\n        rep(i,n)\n        {\n            if(t!=\"*\") ok[i]&=b[i].includeTitle(t);\n            if(a!=\"*\") ok[i]&=b[i].includeAuthor(a);\n            if(from!=\"*\") ok[i]&=b[i].releasedAfter(Date(from));\n            if(to!=\"*\") ok[i]&=b[i].releasedBefore(Date(to));\n        }\n\n        if(q) printf(\"\\n\");\n        rep(i,n) if(ok[i]) cout << b[i].title << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\ntypedef  unsigned long long ull;\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstruct P {\n\tstring title, auther;\n\tint y, m, d;\n};\n\nvoid YMD(string s,int& y, int &m, int &d) {\n\tFOR(i, sz(s)) s[i] -= '0';\n\ty = s[0] * 1000 + s[1] * 100 + s[2] * 10 + s[3];\n\tm = s[5] * 10 + s[6];\n\td = s[8] * 10 + s[9];\n}\n\nbool C(int ly, int lm, int ld, int ry, int rm, int rd) {\n\tif (ly != ry) return ly < ry;\n\tif (lm != rm) return lm < rm;\n\treturn ld <= rd;\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<P> vp;\n\tFOR(i, n) {\n\t\tP p;\n\t\tcin >> p.title >> p.auther;\n\t\tstring ymd; cin >> ymd;\n\t\tYMD(ymd,p.y, p.m, p.d);\n\t\tvp.push_back(p);\n\t}\n\n\tint q; cin >> q;\n\tFOR(_, q) {\n\t\tif (_ != 0) cout << endl;\n\t\tstring ti, au, st, en;\n\t\tcin >> ti >> au >> st >> en;\n\t\tbool ok[100] = {};\n\t\tmemset(ok, 1, sizeof(ok));\n\t\tif (ti != \"*\") {\n\t\t\tFOR(i, n) if (vp[i].title.find(ti) == -1) ok[i] = false;\n\t\t}\n\t\tif (au != \"*\") {\n\t\t\tFOR(i, n) if (vp[i].auther.find(au) == -1) ok[i] = false;\n\t\t}\n\t\tif (st != \"*\") {\n\t\t\tint y, m, d; YMD(st, y, m, d);\n\t\t\tFOR(i, n) if (!C(y, m, d, vp[i].y, vp[i].m, vp[i].d)) ok[i] = false;\n\t\t}\n\t\tif (en != \"*\") {\n\t\t\tint y, m, d; YMD(en, y, m, d);\n\t\t\tFOR(i, n) if (!C(vp[i].y, vp[i].m, vp[i].d, y, m, d)) ok[i] = false;\n\t\t}\n\t\tFOR(i, n) {\n\t\t\tif (ok[i]) cout << vp[i].title << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint rec(int idx, const string& a, const string& b){\n  if(idx == a.size()) return false;\n  if(a[idx] == b[idx]) return rec( idx + 1, a, b);\n  return a[idx] < b[idx];\n}\n\n\nint main(){\n\n  int N, Q;\n  string title[100], auther[100], date[100];\n  bool ei1333[100], flag = false;\n\n  cin >> N;\n  for(int i = 0; i < N; i++){\n    cin >> title[i] >> auther[i] >> date[i];\n  }\n  cin >> Q;\n  for(int i = 0; i < Q; i++){\n\n    if(flag++) cout << endl;\n\n    string t, a, from, to;\n    cin >> t >> a >> from >> to;\n\n    fill_n( ei1333, 100, true);\n    if(t != \"*\"){\n      for(int j = 0; j < N; j++){\n        ei1333[j] &= title[j].find(t) != string::npos;\n      }\n    }\n    if(a != \"*\"){\n      for(int j = 0; j < N; j++){\n        ei1333[j] &= auther[j].find(a) != string::npos;\n      }\n    }\n    if(from != \"*\"){\n      for(int j = 0; j < N; j++){\n        ei1333[j] &= rec( 0, from, date[j]);\n      }\n    }\n    if(to != \"*\"){\n      for(int j = 0; j < N; j++){\n        ei1333[j] &= rec( 0, date[j], to);\n      }\n    }\n    for(int j = 0; j < N; j++){\n      if(ei1333[j]) cout << title[j] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int N,Q;\n  string ti[101],au[101],da[101];\n  cin>>N;\n  for(int i=0;i<N;i++)cin>>ti[i]>>au[i]>>da[i];\n  cin>>Q;\n  string a,b,c,d;\n \n  for(int k=0;k<Q;k++){\n    int f[4][101]={};\n    cin>>a>>b>>c>>d;\n    if(a[0]!='*'){\n      for(int i=0;i<N;i++){\n       \tfor(int j=0;j<ti[i].size();j++){\n\t  int c=0;\n\t  while(ti[i][j+c]==a[c]){\n\t    c++;\n\t    if(c==a.size()){f[0][i]=1;break;}\n\t  }\n\t}\n      }\n    }\n    else for(int i=0;i<N;i++)f[0][i]=1;\n\n    if(b[0]!='*'){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<au[i].size();j++){\n\t  int c=0;\n\t  while(au[i][j+c]==b[c]){\n\t    c++;\n\t    if(c==b.size()){f[1][i]=1;break;}\n\t  }\n\t}\n      }\n    }\n    else for(int i=0;i<N;i++)f[1][i]=1;\n\n    if(c[0]!='*'){\n      for(int i=0;i<N;i++)\n\tfor(int j=0;j<10;j++){\n\t  if(c[j]>da[i][j])break;\n\t  if(c[j]<da[i][j]){f[2][i]=1;break;}\n\t  if(j==9)f[2][i]=1;\n\t}\n    }\n    else for(int i=0;i<N;i++)f[2][i]=1;\n\n    if(d[0]!='*'){\n      for(int i=0;i<N;i++)\n\tfor(int j=0;j<10;j++){\n\t  if(d[j]<da[i][j])break;\n\t  if(d[j]>da[i][j]){f[3][i]=1;break;}\n\t  if(j==9)f[3][i]=1;\n\t}\n    }\n    else for(int i=0;i<N;i++)f[3][i]=1;\n\n    for(int i=0;i<N;i++){\n      if(f[0][i]==1&&f[1][i]==1&&f[2][i]==1&&f[3][i]==1)cout<<ti[i]<<endl;\n    }\n    if(k<Q-1) cout<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,flag2,len,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to,out;\n  queue<string> Q;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  flag2=0;\n  for(i=0;i<q;i++){\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0){\n\tQ.push(title[j]);\n      }\n    }\n    len=Q.size();\n    for(j=0;j<len;j++){\n      out=Q.front();\n      Q.pop();\n      cout << out << endl;\n    }\n    if(i!=q-1) cout << endl;\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int len,len2,i,j,l,flag=0,cnt=0;\n  if(c==\"title\"){\n    len=title[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==title[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }else{\n    len=author[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      cnt=0;\n      for(j=0;j<len2;j++){\n\tif(str[j]==author[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <map>\n#include <string.h>\n#include <stdlib.h>\nusing namespace std;\n\nconst int INF = 1<<25;\ntypedef pair<int, char> P;\n\nint main() {\n\tint n, q, year, month, day, d[100];\n\tstring s1[100], s2[100];\n\t/*map<int, map<char, int> > t;\n\tmap<int, map<char, int> > a;*/\n\tcin >> n;\n\tchar c;\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> s1[i];\n\t\tcin >> s2[i];\n\t\tscanf(\"%d%c%d%c%d\", &year, &c, &month, &c, &day);\n\t\t/*\tfor(unsigned int j = 0; j < s1[i].size(); ++j)\n\t\t\tt[i][s1[i][j]] = 1;\n\t\tfor(unsigned int j = 0; j < s2[i].size(); ++j)\n\t\t\ta[i][s2[i][j]] = 1;*/\n\t\td[i] = year * 366 + month * 31 + day;\n\t}\n\tcin >> q;\n\tstring st, sa, sf, sdt;\n\tfor(int i = 0; i < q; ++i){\n\t\tif(i)\n\t\t\tcout << endl;\n\t\tcin >> st;\n\t\tcin >> sa;\n\t\tcin >> sf;\n\t\tcin >> sdt;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(st != \"*\"){\n\t\t\t\tif(s1[j].find(st, 0) == string::npos)\n\t\t\t\t\tcontinue;\n\t\t\t/*\t\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(unsigned int k = 0; k < st.size(); ++k){\n\t\t\t\t\tif(t[j][st[k]] != 1){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)\n\t\t\t\t\tcontinue;\n\t\t\t*/\n\t\t\t}\n\t\t\tif(sa != \"*\"){\n\t\t\t\tif(s2[j].find(sa, 0) == string::npos)\n\t\t\t\t\tcontinue;\n\t\t\t/*\t\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(unsigned int k = 0; k < sa.size(); ++k){\n\t\t\t\t\tif(a[j][sa[k]] != 1){\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)\n\t\t\t\t\tcontinue;\n\t\t\t*/\n\t\t\t}\n\t\t\tint f = 0;\n\t\t\tif(sf == \"*\"){\n\t\t\t\tf = 1970 * 366 + 1 * 31 + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint y = atoi(sf.substr(0, 4).c_str());\n\t\t\t\tint m = atoi(sf.substr(5, 2).c_str());\n\t\t\t\tint dd = atoi(sf.substr(8, 2).c_str());\n\t\t\t\tf = y * 366 + m * 31 + dd;\n\t\t\t}\n\t\t\tint dt = 0;\n\t\t\tif(sdt == \"*\"){\n\t\t\t\tdt = 2037 * 366 + 12 * 31 + 31;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint y = atoi(sdt.substr(0, 4).c_str());\n\t\t\t\tint m = atoi(sdt.substr(5, 2).c_str());\n\t\t\t\tint dd = atoi(sdt.substr(8, 2).c_str());\n\t\t\t\tdt = y * 366 + m * 31 + dd;\n\t\t\t}\n\t\t\tif(!(f <= d[j] && d[j] <= dt))\n\t\t\t\tcontinue;\n\t\t\tcout << s1[j] << endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint getDate(string s){\n\tif(s == \"*\") return -1;\n\tint ret = 0;\n\tint n = s.size();\n\trep(i, n) {\n\t\tif(s[i] == '/') continue;\n\t\tret *= 10;\n\t\tret += (s[i]-'0');\n\t}\n\treturn ret;\n}\n\nstruct D\n{\n\tstring title, author;\n\tint date;\n};\n\nbool check(const D& d, const string& t, const string& a, int s, int e){\n\tbool b[4] = {};\n\tb[0] = d.title.find(t) != string::npos || t == \"*\";\n\tb[1] = d.author.find(a) != string::npos || a == \"*\";\n\tb[2] = d.date >= s || s == -1;\n\tb[3] = d.date <= e || e == -1;\n\treturn b[0] && b[1] && b[2] && b[3];\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tstring a, b, c, d;\n\tvector<D> v;\n\trep(i, n){\n\t\tcin>>a>>b>>c;\n\t\tv.pb({a, b, getDate(c)});\n\t}\n\tint q;\n\tcin>>q;\n\trep(i, q){\n\t\tif(i != 0) cout<<endl;\n\t\tcin>>a>>b>>c>>d;\n\t\trep(j, n){\n\t\t\tif(check(v[j],a,b,getDate(c),getDate(d))) cout<<v[j].title<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef vector<int> vi;\n\nvi toVec(string s){\n  rep(i,s.size()){\n    if(s[i] == '/')s[i] = ' ';\n  }\n  stringstream ss(s);\n  vi res;\n  int tmp;\n  while(ss >> tmp){\n    res.push_back(tmp);\n  }\n  return res;\n}\n\n\nint main(){\n  vi start = toVec(\"0000/00/00\");\n  vi last = toVec(\"9999/99/99\");\n\n  int n,q;\n  cin >> n;\n  vector<string> bn(n),ba(n),bd(n);\n  vector<vi> bv(n);\n\n  rep(i,n){\n    cin >> bn[i] >> ba[i] >> bd[i];\n    bv[i] = toVec(bd[i]);\n  }\n\n  cin >> q;\n  rep(i,q){\n    string qn,qa,qf,qt;\n    vi qvf,qvt;\n    cin >> qn >> qa >> qf >> qt;\n    \n    rep(j,n){\n      bool f = true;\n      if(qn!=\"*\"){\n\tf &= (bn[j].find(qn)!=string::npos);\n      }\n\n      if(qa!=\"*\"){\n\tf &= (ba[j].find(qa)!=string::npos);\n      }\n\n      if(qf!=\"*\")qvf = toVec(qf);\n      else qvf = start;\n      if(qt!=\"*\")qvt = toVec(qt);\n      else qvt = last;\n      f &= (qvf <= bv[j] && bv[j] <= qvt);\n      \n      if(f)cout << bn[j] << endl;\n    }\n    if(i<q-1)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Book {\nprivate:\n  string title;\n  string author;\n  string date;\n\n  int date2day(string date){\n    vector<string> elements;\n    string tmp = \"\";\n    for(int i = 0; i < date.size(); i++){\n      if(date[i] == '/'){\n        elements.push_back(tmp);\n        tmp = \"\";\n        continue;\n      }\n      tmp += date[i];\n    }\n    elements.push_back(tmp);\n    \n    return 365 * (atoi(elements[0].c_str()) - 1970)\n      + (atoi(elements[1].c_str()) - 1) * 31\n      + (atoi(elements[2].c_str()) - 1);\n  }\n\npublic:\n  Book(string title, string author, string date) {\n    this->title = title;\n    this->author = author;\n    this->date = date;\n  }\n\n  bool match_title(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= title.size(); i++){\n      if(title.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_author(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= author.size(); i++){\n      if(author.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_date(string from,string to) {\n    int my_sec = date2day(date);\n    if(from != \"*\" && my_sec < date2day(from)) return false;\n    if(to != \"*\" && my_sec > date2day(to)) return false;\n    return true;\n  }\n\n  string get_title() const {\n    return title;\n  }\n};\n\nint main(){\n  int num_of_books;\n  int num_of_queries;\n  while(~scanf(\"%d\",&num_of_books)){\n    vector<Book> books;\n    for(int book_i = 0; book_i < num_of_books; book_i++){\n      string title,author,date;\n      cin >> title >> author >> date;\n      books.push_back(Book(title,author,date));\n    }\n    scanf(\"%d\",&num_of_queries);\n    for(int query_i = 0; query_i < num_of_queries; query_i++){\n      string title,author,from,to;\n      cin >> title >> author >> from >> to;\n      for(int book_i = 0; book_i < num_of_books; book_i++){\n        if(books[book_i].match_title(title)\n           && books[book_i].match_author(author)\n           && books[book_i].match_date(from,to)){\n          cout << books[book_i].get_title() << endl;\n        }\n      }\n      if(query_i != num_of_queries - 1){\n        cout << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint N, Q, y, m, d, date[100]; string a, b, c, g, book[100], auth[100];\nint main() {\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> book[i] >> auth[i] >> a;\n\t\tsscanf(a.c_str(), \"%d/%02d/%02d\", &y, &m, &d);\n\t\tdate[i] = y * 10000 + m * 100 + d;\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> a >> b >> c >> g;\n\t\tif(i) cout << endl;\n\t\tif(c != \"*\") sscanf(c.c_str(), \"%d/%02d/%02d\", &y, &m, &d);\n\t\tint d1 = y * 10000 + m * 100 + d;\n\t\tif(g != \"*\") sscanf(g.c_str(), \"%d/%02d/%02d\", &y, &m, &d);\n\t\tint d2 = y * 10000 + m * 100 + d;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tbool f1 = (a == \"*\" || book[i].find(a) != string::npos);\n\t\t\tbool f2 = (b == \"*\" || auth[i].find(b) != string::npos);\n\t\t\tbool f3 = (c == \"*\" || date[i] >= d1);\n\t\t\tbool f4 = (g == \"*\" || date[i] <= d2);\n\t\t\tif(f1 && f2 && f3 && f4) cout << book[i] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<string, pair<string,string>>> books;\n\nvoid search_books(string qname, string qauthor, string qfrom, string qto){\n    for(int i=0;i<books.size();++i){\n        if(books[i].first.find(qname)==string::npos&&qname.at(0)!='*') continue;\n        if(books[i].second.first.find(qauthor)==string::npos&&qauthor.at(0)!='*') continue;\n        if((books[i].second.second<qfrom||books[i].second.second>qto)&&qfrom.at(0)!='*'&&qto.at(0)!='*') continue;\n        cout << books[i].first << endl;\n    }\n\n    return;\n}\n\nint main() {\n    for(int N;cin>>N;){\n        for(int i=0;i<N;++i){\n            string name,author,date;\n            cin>>name>>author>>date;\n            books.push_back(make_pair(name,make_pair(author,date)));\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;++i){\n            string qname,qauthor,qfrom,qto;\n            cin>>qname>>qauthor>>qfrom>>qto;\n            search_books(qname,qauthor,qfrom,qto);\n            if(i!=Q-1) cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include <cassert>\n#include <functional>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(...) ;\n#else\n#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n\nvoid _tostr_rec(ostringstream &oss) {\n  oss << \"\\b\\b \\b\";\n}\n\ntemplate<typename Head, typename... Tail>\nvoid _tostr_rec(ostringstream &oss, Head &&head, Tail &&... tail) {\n  oss << head << \", \";\n  _tostr_rec(oss, forward<Tail>(tail)...);\n}\n\ntemplate<typename... T>\nstring _tostr(T &&... args) {\n  ostringstream oss;\n  int size = sizeof...(args);\n  if (size > 1) oss << \"{\";\n  _tostr_rec(oss, forward<T>(args)...);\n  if (size > 1) oss << \"}\";\n  return oss.str();\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 210\n\nint main() {\n  int N, Q;\n  string title[SIZE], author[SIZE], date[SIZE];\n\n  scanf(\"%d\", &N);\n\n  for (int i = 0; i < N; i++) {\n    cin >> title[i] >> author[i] >> date[i];\n  }\n\n  cin >> Q;\n\n  for (int i = 0; i < Q; i++) {\n    string q1, q2, q3, q4;\n    cin >> q1 >> q2 >> q3 >> q4;\n    for (int j = 0; j < N; j++) {\n      bool ok = true;\n\n\n      ok &= q1 == \"*\" || title[j].find(q1) != string::npos;\n      ok &= q2 == \"*\" || author[j].find(q2) != string::npos;\n      ok &= q3 == \"*\" || q3 <= date[j];\n      ok &= q4 == \"*\" || date[j] <= q4;\n\n      if (ok) {\n        cout << title[j] << endl;\n      }\n    }\n\n    if (i + 1 < Q) cout << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nusing P = pair<string, string>;\nusing PP = pair<P, string>;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint N, Q;\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    vector<PP> books;\n    for(int i = 0; i < N; i++)\n    {\n        string s, t, u; cin >> s >> t >> u;\n        books.push_back(PP(P(s, t), u));\n    }\n    cin >> Q;\n    for(int i = 0; i < Q; i++)\n    {\n        string s, t, from, to; cin >> s >> t >> from >> to;\n        if(i) cout << \"\\n\";\n        for(int j = 0; j < N; j++)\n        {\n            int match = 0;\n            PP book = books[j];\n            if(s == \"*\" or book.first.first.find(s) != -1) match++;\n            if(t == \"*\" or book.first.second.find(t) != -1) match++;\n            if(from == \"*\") from = \"0000/00/00\";\n            if(to == \"*\") to = \"2040/01/01\";\n            if(from <= book.second and book.second <= to) match++;\n            if(match == 3) cout << book.first.first << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\nchar in[110];\nstring name[110];\nstring author[110];\nint y[110];\nint m[110];\nint d[110];\nint ok[110];\nbool contain(string a,string b){\n\tif(a.size()<b.size())return false;\n\tfor(int i=0;i<=a.size()-b.size();i++){\n\t\tbool OK=true;\n\t\tfor(int j=0;j<b.size();j++)if(a[i+j]!=b[j])OK=false;\n\t\tif(OK)return true;\n\t}\n\treturn false;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",in);\n\t\tname[i]=in;\n\t\tscanf(\"%s\",in);\n\t\tauthor[i]=in;\n\t\tscanf(\"%d/%d/%d\",y+i,m+i,d+i);\n\t}\n\tint b;scanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<a;j++)ok[j]=1;\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tstring now=in;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(!contain(name[j],now))ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tstring now=in;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(!contain(author[j],now))ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tint Y,M,D;\n\t\t\tsscanf(in,\"%d/%d/%d\",&Y,&M,&D);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(Y*10000+M*100+D>y[j]*10000+m[j]*100+d[j])ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tint Y,M,D;\n\t\t\tsscanf(in,\"%d/%d/%d\",&Y,&M,&D);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(Y*10000+M*100+D<y[j]*10000+m[j]*100+d[j])ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<a;j++)if(ok[j])printf(\"%s\\n\",name[j].c_str());\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, m, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\ta1 = 1000; a2 = 1000;\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(k, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok == true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a1 > 0) {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (a2 < (1 << 28)) {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Book{\n  string title, author;\n  string pub_time;\n};\n\nint main(){\n  int N;\n  cin >> N;\n  vector<Book> books(N);\n  for(int i=0;i<N;++i){\n\tcin >> books[i].title >> books[i].author >> books[i].pub_time;\n  }\n\n  int Q;\n  cin >> Q;\n  for(int q=0;q<Q;++q){\n\tstring q_name, q_author, q_start, q_end;\n\tcin >> q_name >> q_author >> q_start >> q_end;\n\n\tif(q_name == \"*\")\n\t  q_name = \"\";\n\tif(q_author == \"*\")\n\t  q_author = \"\";\n\tif(q_start == \"*\")\n\t  q_start = \"1970/01/01\";\n\tif(q_end == \"*\")\n\t  q_end = \"2037/12/31\";\n\n\tfor(int i=0;i<books.size();++i){\n\t  if(books[i].title.find(q_name) != string::npos\n\t\t && books[i].author.find(q_author) != string::npos\n\t\t && q_start <= books[i].pub_time\n\t\t && books[i].pub_time <= q_end\n\t\t )\n\t\tcout << books[i].title << endl;\n\t}\n\tcout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tyear -= 1900;\n\tmonth -= 1;\n\tll res = 0LL;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr <= to ) search[2].push_back (book[i] );\t\n//\t\t\tif ( (from < curr || abs (from - curr ) < EPS ) && (curr < to || abs (to - curr ) < EPS ) ) search[2].push_back (book[i] );\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<25;\ntypedef pair<int, char> P;\n\nint main() {\n\tint n, q, year, month, day, d[100];\n\tstring s1[100], s2[100];\n\t/*map<int, map<char, int> > t;\n\tmap<int, map<char, int> > a;*/\n\tcin >> n;\n\tchar c;\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> s1[i];\n\t\tcin >> s2[i];\n\t\tscanf(\"%d%c%d%c%d\", &year, &c, &month, &c, &day);\n\t\t/*\tfor(unsigned int j = 0; j < s1[i].size(); ++j)\n\t\t\tt[i][s1[i][j]] = 1;\n\t\tfor(unsigned int j = 0; j < s2[i].size(); ++j)\n\t\t\ta[i][s2[i][j]] = 1;*/\n\t\td[i] = year * 366 + month * 31 + day;\n\t}\n\tcin >> q;\n\tstring st, sa, sf, sdt;\n\tfor(int i = 0; i < q; ++i){\n\t\tif(i)\n\t\t\tcout << endl;\n\t\tcin >> st;\n\t\tcin >> sa;\n\t\tcin >> sf;\n\t\tcin >> sdt;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(st != \"*\"){\n\t\t\t\tif(s1[j].find(st, 0) == string::npos)\n\t\t\t\t\tcontinue;\n\t\t\t/*\t\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(unsigned int k = 0; k < st.size(); ++k){\n\t\t\t\t\tif(t[j][st[k]] != 1){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)\n\t\t\t\t\tcontinue;\n\t\t\t*/\n\t\t\t}\n\t\t\tif(sa != \"*\"){\n\t\t\t\tif(s2[j].find(sa, 0) == string::npos)\n\t\t\t\t\tcontinue;\n\t\t\t/*\t\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(unsigned int k = 0; k < sa.size(); ++k){\n\t\t\t\t\tif(a[j][sa[k]] != 1){\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)\n\t\t\t\t\tcontinue;\n\t\t\t*/\n\t\t\t}\n\t\t\tint f = 0;\n\t\t\tif(sf == \"*\"){\n\t\t\t\tf = 1970 * 366 + 1 * 31 + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint y = atoi(sf.substr(0, 4).c_str());\n\t\t\t\tint m = atoi(sf.substr(5, 2).c_str());\n\t\t\t\tint dd = atoi(sf.substr(8, 2).c_str());\n\t\t\t\tf = y * 366 + m * 31 + dd;\n\t\t\t}\n\t\t\tint dt = 0;\n\t\t\tif(sdt == \"*\"){\n\t\t\t\tdt = 2037 * 366 + 12 * 31 + 31;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint y = atoi(sdt.substr(0, 4).c_str());\n\t\t\t\tint m = atoi(sdt.substr(5, 2).c_str());\n\t\t\t\tint dd = atoi(sdt.substr(8, 2).c_str());\n\t\t\t\tdt = y * 366 + m * 31 + dd;\n\t\t\t}\n\t\t\tif(!(f <= d[j] && d[j] <= dt))\n\t\t\t\tcontinue;\n\t\t\tcout << s1[j] << endl;\n\t\t}\n\t\t\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Book{\n  string title, author;\n  string pub_time;\n};\n\nint main(){\n  int N;\n  cin >> N;\n  vector<Book> books(N);\n  for(int i=0;i<N;++i){\n\tcin >> books[i].title >> books[i].author >> books[i].pub_time;\n  }\n\n  int Q;\n  cin >> Q;\n  for(int q=0;q<Q;++q){\n\tstring q_name, q_author, q_start, q_end;\n\tcin >> q_name >> q_author >> q_start >> q_end;\n\n\tif(q_name == \"*\")\n\t  q_name = \"\";\n\tif(q_author == \"*\")\n\t  q_author = \"\";\n\tif(q_start == \"*\")\n\t  q_start = \"1970/01/01\";\n\tif(q_end == \"*\")\n\t  q_end = \"2037/12/31\";\n\n\tfor(int i=0;i<books.size();++i){\n\t  if(books[i].title.find(q_name) != string::npos\n\t\t && books[i].author.find(q_author) != string::npos\n\t\t && q_start <= books[i].pub_time\n\t\t && books[i].pub_time <= q_end\n\t\t )\n\t\tcout << books[i].title << endl;\n\t}\n\tif(q != Q-1) cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<functional>\n#include<algorithm>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n\nint f(const string &s){\n\tif(s[0]=='*')return -1;\n\tint res=0;\n\trep(i,s.size()){\n\t\tif(s[i]!='/'){\n\t\t\tres=res*10+s[i]-'0';\n\t\t}\n\t}\n\treturn res;\n}\n\nbool contain(const string &s,const string &t){\n\trep(i,s.size()){\n\t\tif(s.compare(i,t.size(),t)==0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n;\n\tstring title[100],auther[100];\n\tint date[100];\n\tint q;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>title[i]>>auther[i]>>s;\n\t\tdate[i]=f(s);\n\t}\n\tcin>>q;\n\trep(i,q){\n\t\tif(i)cout<<endl;\n\t\tstring ti,au,s,t;\n\t\tint from,to;\n\t\tcin>>ti>>au>>s>>t;\n\t\tfrom=f(s);\n\t\tto=f(t);\n\t\trep(j,n){\n\t\t\tif( (ti==\"*\"||contain(title[j],ti)) && (au==\"*\"||contain(auther[j],au))\n\t\t\t\t&& (from<=date[j]) && (to==-1||to>=date[j]) ){\n\t\t\t\t\tcout<<title[j]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MAX_N 100000\nint N, Q; vector<int>vec, vec2;\nstring S[MAX_N][3], T[4];\nbool Find(string U, string V) {\n\tfor (int i = 0; i <= U.size() - V.size(); i++) {\n\t\tif (U.substr(i, V.size()) == V) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> S[i][0] >> S[i][1] >> S[i][2];\n\t}\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tcin >> T[0] >> T[1] >> T[2] >> T[3];\n\t\tvec.clear(); vec2.clear();\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tvec.push_back(j);\n\t\t}\n\t\tif (T[0] != \"*\") {\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (Find(S[vec[i]][0], T[0])) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2; vec2.clear();\n\t\tif (T[1] != \"*\") {\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (Find(S[vec[i]][1], T[1])) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2; vec2.clear();\n\t\tif (T[2] != \"*\") {\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (S[i][2] >= T[2]) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2; vec2.clear();\n\t\tif (T[3] != \"*\") {\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (S[i][2] <= T[3]) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2; vec2.clear();\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tcout << S[vec[i]][0] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) os << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <typename T> void print(T a, int n, const string& split = \" \") { for (int i = 0; i < n; i++) { cout << a[i]; if (i + 1 != n) cout << split; } cout << endl; }\ntemplate <typename T> void print2d(T a, int w, int h, int width = -1, int br = 0) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) { if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\ntemplate <typename T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n#define dump(v) (cerr << #v << \": \" << v << endl)\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nll gao(const string& s)\n{\n    int y, m, d;\n    sscanf(s.c_str(),\"%d/%d/%d\", &y, &m, &d);\n    return (ll)y * 30 * 51 + m * 50 + d;\n}\nint main()\n{\n    int n;\n    cin >> n;\n\n    string title[128], auther[128];\n    ll t[128];\n    rep(i, n)\n    {\n        string d;\n        cin >> title[i] >> auther[i] >> d;\n        t[i] = gao(d);\n    }\n\n    int q;\n    cin >> q;\n    rep(qi, q)\n    {\n        string qtitle, qauther, qf, qt;\n        cin >> qtitle >> qauther >> qf >> qt;\n\n        vector<string> hit;\n        rep(i, n)\n        {\n            if ((qtitle == \"*\" || title[i].find(qtitle) != string::npos) &&\n                (qauther == \"*\" || auther[i].find(qauther) != string::npos) &&\n                ((qf == \"*\" || gao(qf) <= t[i]) && (qt == \"*\" || t[i] <= gao(qt))))\n                cout << title[i] << endl;\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) os << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <typename T> void print(T a, int n, const string& split = \" \") { for (int i = 0; i < n; i++) { cout << a[i]; if (i + 1 != n) cout << split; } cout << endl; }\ntemplate <typename T> void print2d(T a, int w, int h, int width = -1, int br = 0) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) { if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\ntemplate <typename T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n#define dump(v) (cerr << #v << \": \" << v << endl)\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nll gao(const string& s)\n{\n    int y, m, d;\n    sscanf(s.c_str(),\"%d/%d/%d\", &y, &m, &d);\n    return (ll)y * 30 * 51 + m * 50 + d;\n}\nint main()\n{\n    int n;\n    cin >> n;\n\n    string title[128], auther[128];\n    ll t[128];\n    rep(i, n)\n    {\n        string d;\n        cin >> title[i] >> auther[i] >> d;\n        t[i] = gao(d);\n    }\n\n    int q;\n    cin >> q;\n    rep(qi, q)\n    {\n        string qtitle, qauther, qf, qt;\n        cin >> qtitle >> qauther >> qf >> qt;\n\n        rep(i, n)\n        {\n            if ((qtitle == \"*\" || title[i].find(qtitle) != string::npos) &&\n                (qauther == \"*\" || auther[i].find(qauther) != string::npos) &&\n                ((qf == \"*\" || gao(qf) <= t[i]) && (qt == \"*\" || t[i] <= gao(qt))))\n            {\n                cout << title[i] << endl;\n            }\n        }\n        if (qi + 1 < q)\n            cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s[100],t[100];\nint g[100];\nint n,m;\n\nint conv(string x){\n    int a,b,c;\n    char ig;\n    stringstream ss(x);\n    ss>>a>>ig>>b>>ig>>c;\n    return a*10000+b*100+c;\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<6;i++){\n        string a;\n        cin>>s[i]>>t[i]>>a;\n        g[i]=conv(a);\n    }\n\n    cin>>m;\n    bool la=false;\n    while(m--){\n        if(la)cout<<endl;\n        else la=true;\n        string a,b,c,d;\n        cin>>a>>b>>c>>d;\n        for(int i=0;i<n;i++){\n            bool flag=true;\n            if(a!=\"*\")if(s[i].find(a)==string::npos)flag=false;\n            if(b!=\"*\")if(t[i].find(b)==string::npos)flag=false;\n            if(c!=\"*\")if(conv(c)>g[i])flag=false;\n            if(d!=\"*\")if(conv(d)<g[i])flag=false;\n            if(flag)cout<<s[i]<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2657.cc: Books\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\n\n/* typedef */\n\n/* global variables */\n\nstring ts[MAX_N], as[MAX_N];\nint ds[MAX_N];\n\n/* subroutines */\n\ninline int ymd2n(string &s) {\n  int y = atoi(s.substr(0, 4).c_str());\n  int m = atoi(s.substr(5, 2).c_str());\n  int d = atoi(s.substr(8, 2).c_str());\n  return y * 10000 + m * 100 + d;\n}\n\nbool match(int i, string &t, string &a, string &fd, string &td) {\n  if (t != \"*\" && ts[i].find(t) == string::npos) return false;\n  if (a != \"*\" && as[i].find(a) == string::npos) return false;\n  if (fd != \"*\") {\n    int fdn = ymd2n(fd);\n    if (fdn > ds[i]) return false;\n  }\n  if (td != \"*\") {\n    int tdn = ymd2n(td);\n    if (tdn < ds[i]) return false;\n  }\n  return true;\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    string ymd;\n    cin >> ts[i] >> as[i] >> ymd;\n    ds[i] = ymd2n(ymd);\n  }\n\n  int q;\n  cin >> q;\n\n  for (int i = 0; i < q; i++) {\n    string t, a, fd, td;\n    cin >> t >> a >> fd >> td;\n\n    if (i > 0) putchar('\\n');\n    \n    for (int i = 0; i < n; i++)\n      if (match(i, t, a, fd, td)) cout << ts[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint dtoi(string date)\n{\n  int ans=0;\n  ans =stoi(date.substr(0,4))*12*31+stoi(date.substr(5,2))*31+stoi(date.substr(8,2));\n  return ans;\n}\n\nint main()\n{\n  int n;\n  cin>>n;\n  string t[n], a[n],d[n];\n  for(int i=0;i<n;i++){\n    cin>>t[i]>>a[i]>>d[i];\n  }\n  int q;\n  cin>>q;\n  for(int x=0;x<q;x++){\n    string tt,qq,df,dt;\n    cin>>tt>>qq>>df>>dt;\n    for(int i=0;i<n;i++){\n      if(tt!=\"*\"&& t[i].find(tt)==string::npos)\n\tcontinue;\n      if(qq!=\"*\"&& a[i].find(qq)==string::npos)\n\tcontinue;\n      int d1 = dtoi(d[i]);\n      if(df!=\"*\" && d1<dtoi(df))\n\tcontinue;\n      if(dt!=\"*\" && d1>dtoi(dt))\n\tcontinue;\n      cout<<t[i]<<endl;\n    }\n    if(x!=q-1)\n      cout<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int N;\n    vector<string> T, A, D;\n    int Q;\n\n    const int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    const int days_leap[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    bool is_leap(int y) {\n        if (y % 400 == 0) return true;\n        if (y % 100 == 0) return false;\n        if (y % 4 == 0) return true;\n        return false;\n    }\n\n    int date(const string& s) {\n        int y, m, d;\n        sscanf(s.c_str(), \"%d/%d/%d\", &y, &m, &d);\n        int ret = 365 * y;\n        ret += (y / 400) * 97;\n        for (int i = 0; i < y % 400; i++) {\n            if (is_leap(i)) ret++;\n        }\n        bool l = is_leap(y);\n        for (int i = 1; i < m; i++) ret += (l ? days_leap : days)[i];\n        ret += d;\n        return ret;\n    }\n\n    bool check(const string& s, const string& key) {\n        if (key == \"*\") return true;\n        return s.find(key) != string::npos;\n    }\n\n    void query(const string& t, const string& a, const string& froms, const string& tos) {\n        int from, to;\n        if (froms == \"*\") from = 0;\n        else from = date(froms);\n        if (tos == \"*\") to = date(\"2040/01/01\");\n        else to = date(tos);\n\n        for (int i = 0; i < N; i++) {\n            if (!check(T[i], t)) continue;\n            if (!check(A[i], a)) continue;\n            int d = date(D[i]);\n            if (!(from <= d && d <= to)) continue;\n            cout << T[i] << endl;\n        }\n    }\n\n    void solve() {\n        cin >> N;\n        T.resize(N); A.resize(N); D.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> T[i] >> A[i] >> D[i];\n        }\n        cin >> Q;\n        for (int i = 0; i < Q; i++) {\n            string t, a, from, to;\n            cin >> t >> a >> from >> to;\n            if (i != 0) cout << endl;\n            query(t, a, from, to);\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int N,Q;\n  string ti[101],au[101],da[101];\n  cin>>N;\n  for(int i=0;i<N;i++)cin>>ti[i]>>au[i]>>da[i];\n  cin>>Q;\n  string a,b,c,d;\n \n  for(int k=0;k<Q;k++){\n    int f[4][101]={};\n    cin>>a>>b>>c>>d;\n    if(a[0]!='*'){\n      for(int i=0;i<N;i++){\n       \tfor(int j=0;j<ti[i].size();j++){\n\t  int c=0;\n\t  while(ti[i][j+c]==a[c]){\n\t    c++;\n\t    if(c==a.size()){f[0][i]=1;break;}\n\t  }\n\t}\n      }\n    }\n    else for(int i=0;i<N;i++)f[0][i]=1;\n\n    if(b[0]!='*'){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<au[i].size();j++){\n\t  int c=0;\n\t  while(au[i][j+c]==b[c]){\n\t    c++;\n\t    if(c==b.size()){f[1][i]=1;break;}\n\t  }\n\t}\n      }\n    }\n    else for(int i=0;i<N;i++)f[1][i]=1;\n\n    if(c[0]!='*'){\n      for(int i=0;i<N;i++)\n\tfor(int j=0;j<10;j++){\n\t  if(c[j]>da[i][j])break;\n\t  if(c[j]<da[i][j]){f[2][i]=1;break;}\n\t}\n    }\n    else for(int i=0;i<N;i++)f[2][i]=1;\n\n    if(d[0]!='*'){\n      for(int i=0;i<N;i++)\n\tfor(int j=0;j<10;j++){\n\t  if(d[j]<da[i][j])break;\n\t  if(d[j]>da[i][j]){f[3][i]=1;break;}\n\t}\n    }\n    else for(int i=0;i<N;i++)f[3][i]=1;\n    for(int i=0;i<N;i++){\n      if(f[0][i]==1&&f[1][i]==1&&f[2][i]==1&&f[3][i]==1)cout<<ti[i]<<endl;\n    }\n    if(k<Q-1) cout<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <map>\n#include <string.h>\n#include <stdlib.h>\nusing namespace std;\n\nconst int INF = 1<<25;\ntypedef pair<int, char> P;\n\nint main() {\n\tint n, q, year, month, day, d[100];\n\tstring s1[100], s2[100];\n\t/*map<int, map<char, int> > t;\n\tmap<int, map<char, int> > a;*/\n\tcin >> n;\n\tchar c;\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> s1[i];\n\t\tcin >> s2[i];\n\t\tscanf(\"%d%c%d%c%d\", &year, &c, &month, &c, &day);\n\t\t/*\tfor(unsigned int j = 0; j < s1[i].size(); ++j)\n\t\t\tt[i][s1[i][j]] = 1;\n\t\tfor(unsigned int j = 0; j < s2[i].size(); ++j)\n\t\t\ta[i][s2[i][j]] = 1;*/\n\t\td[i] = year * 366 + month * 31 + day;\n\t}\n\tcin >> q;\n\tstring st, sa, sf, sdt;\n\tfor(int i = 0; i < q; ++i){\n\t\tif(i)\n\t\t\tcout << endl;\n\t\tcin >> st;\n\t\tcin >> sa;\n\t\tcin >> sf;\n\t\tcin >> sdt;\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif(st != \"*\"){\n\t\t\t\tif(s1[j].find(st, 0) == string::npos)\n\t\t\t\t\tcontinue;\n\t\t\t/*\t\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(unsigned int k = 0; k < st.size(); ++k){\n\t\t\t\t\tif(t[j][st[k]] != 1){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)\n\t\t\t\t\tcontinue;\n\t\t\t*/\n\t\t\t}\n\t\t\tif(sa != \"*\"){\n\t\t\t\tif(s2[j].find(sa, 0) == string::npos)\n\t\t\t\t\tcontinue;\n\t\t\t/*\t\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(unsigned int k = 0; k < sa.size(); ++k){\n\t\t\t\t\tif(a[j][sa[k]] != 1){\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok)\n\t\t\t\t\tcontinue;\n\t\t\t*/\n\t\t\t}\n\t\t\tint f = 0;\n\t\t\tif(sf == \"*\"){\n\t\t\t\tf = 1970 * 366 + 1 * 31 + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint y = atoi(sf.substr(0, 4).c_str());\n\t\t\t\tint m = atoi(sf.substr(5, 2).c_str());\n\t\t\t\tint dd = atoi(sf.substr(8, 2).c_str());\n\t\t\t\tf = y * 366 + m * 31 + dd;\n\t\t\t}\n\t\t\tint dt = 0;\n\t\t\tif(sdt == \"*\"){\n\t\t\t\tdt = 2037 * 366 + 12 * 31 + 31;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint y = atoi(sdt.substr(0, 4).c_str());\n\t\t\t\tint m = atoi(sdt.substr(5, 2).c_str());\n\t\t\t\tint dd = atoi(sdt.substr(8, 2).c_str());\n\t\t\t\tdt = y * 366 + m * 31 + dd;\n\t\t\t}\n\t\t\tif(!(f <= d[j] && d[j] <= dt))\n\t\t\t\tcontinue;\n\t\t\tcout << s1[j] << endl;\n\t\t}\n\t\t\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int             long long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )    for( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )  FOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nstruct Data{\n    string title;\n    string author;\n    string date;\n};\n\nsigned main(){\n    int N, M;\n    string t, n, df, dt;\n\n    cin >> N;\n    vector<Data> data;\n    REP( i, N ){\n        cin >> t >> n >> df;\n        data.emplace_back( Data{ t, n, df } );\n    }\n\n    cin >> M;\n    REP( i, M ){\n        cin >> t >> n >> df >> dt;\n        if( t == \"*\" ) t = \".*\";\n        if( n == \"*\" ) n = \".*\";\n        if( df == \"*\" ) df = \"1970\";\n        if( dt == \"*\" ) dt = \"2038\";\n        regex rt( t ), rn( n );\n\n        REP( i, N ){\n            if( regex_search( data[i].title, rt ) && regex_search( data[i].author, rn ) && data[i].date >= df && data[i].date <= dt ){\n                cout << data[i].title << endl;\n            }\n        }\n        if( i != M - 1 ) cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[4];\n\t\trep (k, 4 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from <= curr  ) search[3].push_back (search[2][i] );\n\t\t} // end rep\n\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, search[3].size() ){\n\t\t\tll curr = search[3][i].datenum;\n\t\t\tif (curr < to  ) res.push_back (search[3][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nint main(){\n\n\tint n;\n\tcin >> n;\n\tvector<string> title(n), auther(n);\n\tvector<vector<int>> ymd(n);\n\trep(i, n){\n\t\tcin >> title[i] >> auther[i];\n\t\tint yy, mm, dd;\n\t\tchar cc;\n\t\tcin >> yy >> cc >> mm >> cc >> dd;\n\t\tymd[i] = {yy, mm, dd};\n\t}\n\n\n\tint q;\n\tcin >> q;\n\tbool f = true;\n\twhile (q--){\n\t\tif (!f) cout << '\\n';\n\t\tf = false;\n\t\tvector<int> invalid(n);\n\t\tstring a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (a != \"*\") rep(i, n){\n\t\t\tif (title[i].find(a) == string::npos) invalid[i] = 1;\n\t\t}\n\t\tif (b != \"*\") rep(i, n){\n\t\t\tif (auther[i].find(b) == -1) invalid[i] = 1;\n\t\t}\n\t\tif (c != \"*\"){\n\t\t\tstringstream ss(c);\n\t\t\tint yy, mm, dd;\n\t\t\tchar cc;\n\t\t\tss >> yy >> cc >> mm >> cc >> dd;\n\t\t\tvector<int> v = { yy, mm, dd };\n\t\t\trep(i, n){\n\t\t\t\tif (ymd[i] < v) invalid[i] = 1;\n\t\t\t}\n\t\t}\n\t\tif (d != \"*\"){\n\t\t\tstringstream ss(d);\n\t\t\tint yy, mm, dd;\n\t\t\tchar cc;\n\t\t\tss >> yy >> cc >> mm >> cc >> dd;\n\t\t\tvector<int> v = { yy, mm, dd };\n\t\t\trep(i, n){\n\t\t\t\tif (ymd[i] > v) invalid[i] = 1;\n\t\t\t}\n\t\t}\n\t\trep(i, n){\n\t\t\tif (invalid[i]) continue;\n\t\t\tcout << title[i] << '\\n';\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\nbool find(string s,string f){\n\tREP(i,s.size())\n\t\tREP(j,f.size())\n\t\t\tif(i+j>=s.size() || s[i+j]!=f[j])\n\t\t\tbreak;\n\t\t\telse if(j==f.size()-1)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main() {\n\tstring books[101][3],query[4];\n\tint N,Q;\n\tcin >> N ;\n\tREP(i,N)\n\t\tREP(j,3)\n\t\t\tcin >> books[i][j];\n\tcin >> Q;\n\tREP(i,Q){\n\t\tREP(j,4)\n\t\t\tcin >> query[j];\n\t\tREP(j,N){\n\t\t\tbool ans=true;\n\t\t\tREP(k,4){\n\t\t\t\tif(query[k]==\"*\")\n\t\t\t\tcontinue;\n\t\t\t\tif(k<=1)\n\t\t\t\t\tif(!find(books[j][k],query[k]))\n\t\t\t\t\tans=false;\n\t\t\t\tif(k==2)\n\t\t\t\t\tif(!(query[k]<=books[j][2]))\n\t\t\t\t\tans=false;\n\t\t\t\tif(k==3)\n\t\t\t\t\tif(!(query[k]>=books[j][2]))\n\t\t\t\t\tans=false;\n\t\t\t}\n\t\t\tif(ans)\n\t\t\tcout << books[j][0] << endl;\n\t\t}\n\t\tif(i!=Q-1)\n\t\tcout << endl;\n\t}\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cstdlib>\n\nusing namespace std;\ntypedef tuple<string, string, int> tssi;\n\nint read_date(){\n\tstring head;\n\tcin >> head;\n\tif(head == \"*\"){ return -1; }\n\tistringstream iss(head);\n\tint y, m, d;\n\tiss >> y; iss.ignore();\n\tiss >> m; cin.ignore();\n\tiss >> d;\n\treturn y * 10000 + m * 100 + d;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<tssi> books(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tstring title, author;\n\t\tcin >> title >> author;\n\t\tconst int date = read_date();\n\t\tbooks[i] = tssi(title, author, date);\n\t}\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tstring title, author;\n\t\tcin >> title >> author;\n\t\tint from = read_date();\n\t\tint to = read_date();\n\t\tif(from < 0){ from = 0; }\n\t\tif(to < 0){ to = 1000000000; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(title != \"*\" && get<0>(books[i]).find(title) == string::npos){ continue; }\n\t\t\tif(author != \"*\" && get<1>(books[i]).find(author) == string::npos){ continue; }\n\t\t\tif(from <= get<2>(books[i]) && get<2>(books[i]) <= to){\n\t\t\t\tcout << get<0>(books[i]) << endl;\n\t\t\t}\n\t\t}\n\t\tif(q != 0){ cout << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nvector<string> split(const string& input, char delimiter){\n    istringstream stream(input);\n    string field;\n    vector<string> result;\n    while(getline(stream, field, delimiter))result.push_back(field);\n    return result;\n}\n\ntm convert(vector<string> strs){\n    tm res;\n    res.tm_year = stoi(strs[0]);\n    res.tm_mon = stoi(strs[1]);\n    res.tm_mday = stoi(strs[2]);\n    return res;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    typedef tuple<string, string, tm> Data;\n    vector<Data> books;\n    rep(i, N){\n        string title, author, date;\n        cin >> title >> author >> date;\n        books.emplace_back(title, author, convert(split(date, '/')));\n    }\n    int Q;\n    cin >> Q;\n    while(Q--){\n        string Qtitle, Qauthor, Qfrom, Qto;\n        cin >> Qtitle >> Qauthor >> Qfrom >> Qto;\n        vector<Data> match(all(books));\n        if(Qtitle != \"*\"){\n            auto mismatch = [&](Data& d){return get<0>(d).find(Qtitle) == string::npos;};\n            match.erase(remove_if(all(match), mismatch), match.end());\n        }\n        if(Qauthor != \"*\"){\n            auto mismatch = [&](Data& d){return get<1>(d).find(Qauthor) == string::npos;};\n            match.erase(remove_if(all(match), mismatch), match.end());\n        }\n        if(Qfrom != \"*\" || Qto != \"*\"){\n            if(Qfrom == \"*\")Qfrom = \"0000/01/01\";\n            if(Qto == \"*\")Qto = \"9999/12/31\";\n            tm from = convert(split(Qfrom, '/')), to = convert(split(Qto, '/'));\n            auto mismatch = [&](Data& d){\n                return difftime(mktime(&get<2>(d)), mktime(&from)) < 0 ||\n                       difftime(mktime(&to), mktime(&get<2>(d))) < 0;\n            };\n            match.erase(remove_if(all(match), mismatch), match.end());;\n        }\n        for(auto x: match)cout << get<0>(x) << '\\n';\n        if(Q)cout << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nnamespace Day {\n  enum {MON, TUE, WED, THU, FRI, SAT, SUN};\n  int leap_count(int year) {\n    if (year < 0) return -leap_count(-year - 1) - 1;\n    return year / 4 - year / 100 + year / 400;\n  }\n  int day_count(int year, int month, int day) {\n    if (month <= 2) --year, month += 12;\n    return year * 365 + leap_count(year) + (month * 153 + 3) / 5 + day;\n  }\n  bool is_leap(int year) {return leap_count(year) > leap_count(year - 1);}\n};\n\n#include <sstream>\n\ntemplate<class A, class B> B convert(A a) {\n  stringstream ss;\n  ss << a;\n  B b;\n  ss >> b;\n  return b;\n}\n\nint parse(string s) {\n  int year = convert<string, int>(s.substr(0, 4));\n  int month = convert<string, int>(s.substr(5, 2));\n  int day = convert<string, int>(s.substr(8));\n  return Day::day_count(year, month, day);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string title[n], auther[n], date[n];\n  for (int i : range(n)) cin >> title[i] >> auther[i] >> date[i];\n  int d[n];\n  for (int i : range(n)) d[i] = parse(date[i]);\n  int q;\n  cin >> q;\n  for (int i : range(q)) {\n    if (i != 0) cout << endl;\n    string q_title, q_auther, q_date_from, q_date_to;\n    cin >> q_title >> q_auther >> q_date_from >> q_date_to;\n    int from = -1;\n    if (q_date_from != \"*\") from = parse(q_date_from);\n    int to = -1;\n    if (q_date_to != \"*\") to = parse(q_date_to);\n    for (int j : range(n)) {\n      if (q_title != \"*\" && title[j].find(q_title) == string::npos) continue;\n      if (q_auther != \"*\" && auther[j].find(q_auther) == string::npos) continue;\n      if (from != -1 && d[j] <= from) continue;\n      if (to != -1 && to <= d[j]) continue;\n      cout << title[j] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[4];\n\t\trep (k, 4 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr.find (q_auther ) != string::npos ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from <= curr  ) search[3].push_back (search[2][i] );\n\t\t} // end rep\n\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, search[3].size() ){\n\t\t\tll curr = search[3][i].datenum;\n\t\t\tif (curr <= to  ) res.push_back (search[3][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,flag2,len,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to,out;\n  queue<string> Q;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  flag2=0;\n  for(i=0;i<q;i++){\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0){\n\tQ.push(title[j]);\n      }\n    }\n    len=Q.size();\n    flag2=0;\n    for(j=0;j<len;j++){\n      out=Q.front();\n      Q.pop();\n      cout << out << endl;\n      flag2=1;\n    }\n    if(i!=q-1&&flag2==1) cout << endl;\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int len,len2,i,j,l,flag=0,cnt=0;\n  if(c==\"title\"){\n    len=title[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==title[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }else{\n    len=author[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      cnt=0;\n      for(j=0;j<len2;j++){\n\tif(str[j]==author[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tyear -= 1900;\n\tmonth -= 1;\n\tll res = 0LL;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr <= to ) search[2].push_back (book[i] );\t\n//\t\t\tif ( (from < curr || abs (from - curr ) < EPS ) && (curr < to || abs (to - curr ) < EPS ) ) search[2].push_back (book[i] );\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (res.empty() ){\n\t\t\tcout << endl;\n\t\t}else{\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, m, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(i, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok == true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass book {\n  std::string title, author, date;\n\npublic:\n  book(const std::string& title,\n       const std::string& author,\n       const std::string& date): title(title), author(author), date(date) {}\n\n  std::string get_title() const { return title; }\n\n  bool matches(const std::string& q_title,\n               const std::string& q_author,\n               const std::string& q_date_from,\n               const std::string& q_date_to) const {\n\n    if (q_title != \"*\") {\n      bool has = false;\n      for (size_t i = 0; i + q_title.length() <= title.length(); ++i) {\n        if (title.compare(i, q_title.length(), q_title) == 0) {\n          has = true;\n          break;\n        }\n      }\n      if (!has) return false;\n    }\n    if (q_author != \"*\") {\n      bool has = false;\n      for (size_t i = 0; i + q_author.length() <= author.length(); ++i) {\n        if (author.compare(i, q_author.length(), q_author) == 0) {\n          has = true;\n          break;\n        }\n      }\n      if (!has) return false;\n    }\n    if (q_date_from != \"*\") {\n      if (date < q_date_from) return false;\n    }\n    if (q_date_to != \"*\") {\n      if (date > q_date_to) return false;\n    }\n    return true;\n  }\n};\n\nint main() {\n  size_t N;\n  scanf(\"%zu\", &N);\n\n  std::vector<book> s;\n  for (size_t i = 0; i < N; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    std::string title = buf;\n    scanf(\"%s\", buf);\n    std::string author = buf;\n    scanf(\"%s\", buf);\n    std::string date = buf;\n    s.emplace_back(title, author, date);\n  }\n\n  size_t Q;\n  scanf(\"%zu\", &Q);\n  for (size_t i = 0; i < Q; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    std::string title = buf;\n    scanf(\"%s\", buf);\n    std::string author = buf;\n    scanf(\"%s\", buf);\n    std::string date_from = buf;\n    scanf(\"%s\", buf);\n    std::string date_to = buf;\n\n    for (const auto& si: s)\n      if (si.matches(title, author, date_from, date_to))\n        printf(\"%s\\n\", si.get_title().c_str());\n\n    if (i+1 < Q) puts(\"\");\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,flag2,len,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to,out;\n  queue<string> Q;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  flag2=0;\n  for(i=0;i<q;i++){\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0){\n\tQ.push(title[j]);\n      }\n    }\n    len=Q.size();\n    for(j=0;j<len;j++){\n      out=Q.front();\n      Q.pop();\n      cout << out << endl;\n    }\n    if(i!=q-1) cout << endl;\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int flag,len,len2,i;\n  string a;\n  if(c==\"title\") len=title[n].size();\n  else len=author[n].size();\n  len2=str.size();\n  flag=0;\n  for(i=0;i<=len-len2;i++){\n    if(c==\"title\") a=title[n].substr(i,len2);\n    else a=author[n].substr(i,len2);\n    if(a==str){\n      flag=1;\n      break;\n    }\n  }\n  if(flag==1) return 1;\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(i, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok = true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  for(i=0;i<q;i++){\n    if(i!=0) cout << endl;\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0) cout << title[j] << endl;\n    }\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int len,len2,i,j,l,flag=0,cnt=0;\n  if(c==\"title\"){\n    len=title[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==title[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }else{\n    len=author[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==author[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, m, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(i, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok == true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct book{\n  string name,auth,date;\n\n  bool match(string a, string b, string c, string d){\n    if(a!=\"*\" && name.find(a)==string::npos)return false;\n    if(b!=\"*\" && auth.find(b)==string::npos)return false;\n    if(c!=\"*\" && date<c)return false;\n    if(d!=\"*\" && d<date)return false;\n    return true;\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<book> B(n);\n  for(int i=0;i<n;i++){\n    string a,b,c;\n    cin >> a >> b >> c;\n    B[i].name = a; B[i].auth = b; B[i].date = c;\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    string a,b,c,d;\n    cin >> a >> b >> c >> d;\n    for(int j=0;j<n;j++){\n      if(B[j].match(a,b,c,d))cout << B[j].name << endl;\n    }\n    if(i<q-1)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\nchar in[110];\nstring name[110];\nstring author[110];\nint y[110];\nint m[110];\nint d[110];\nint ok[110];\nbool contain(string a,string b){\n\tif(a.size()<b.size())return false;\n\tfor(int i=0;i<=a.size()-b.size();i++){\n\t\tbool OK=true;\n\t\tfor(int j=0;j<b.size();j++)if(a[i+j]!=b[j])OK=false;\n\t\tif(OK)return true;\n\t}\n\treturn false;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",in);\n\t\tname[i]=in;\n\t\tscanf(\"%s\",in);\n\t\tauthor[i]=in;\n\t\tscanf(\"%d/%d/%d\",y+i,m+i,d+i);\n\t}\n\tint b;scanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<a;j++)ok[j]=1;\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tstring now=in;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(!contain(name[j],now))ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tstring now=in;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(!contain(author[j],now))ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tint Y,M,D;\n\t\t\tsscanf(in,\"%d/%d/%d\",&Y,&M,&D);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(Y*10000+M*100+D>y[j]*10000+m[j]*100+d[j])ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\",in);\n\t\tif(in[0]!='*'){\n\t\t\tint Y,M,D;\n\t\t\tsscanf(in,\"%d/%d/%d\",&Y,&M,&D);\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(Y*10000+M*100+D<y[j]*10000+m[j]*100+d[j])ok[j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<a;j++)if(ok[j])printf(\"%s\\n\",name[j].c_str());\n\t\tif(i<b-1)printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(i, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok = true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nvector<string> split(const string& input, char delimiter){\n    istringstream stream(input);\n    string field;\n    vector<string> result;\n    while(getline(stream, field, delimiter))result.push_back(field);\n    return result;\n}\n\ntm convert(vector<string> strs){\n    tm res;\n    res.tm_year = stoi(strs[0]) - 1900;\n    res.tm_mon = stoi(strs[1]) - 1;\n    res.tm_mday = stoi(strs[2]);\n    return res;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    typedef tuple<string, string, tm> Data;\n    vector<Data> books;\n    rep(i, N){\n        string title, author, date;\n        cin >> title >> author >> date;\n        books.emplace_back(title, author, convert(split(date, '/')));\n    }\n    int Q;\n    cin >> Q;\n    while(Q--){\n        string Qtitle, Qauthor, Qfrom, Qto;\n        cin >> Qtitle >> Qauthor >> Qfrom >> Qto;\n        vector<Data> match(all(books));\n        if(Qtitle != \"*\"){\n            auto mismatch = [&](Data& d){return get<0>(d).find(Qtitle) == string::npos;};\n            match.erase(remove_if(all(match), mismatch), match.end());\n        }\n        if(Qauthor != \"*\"){\n            auto mismatch = [&](Data& d){return get<1>(d).find(Qauthor) == string::npos;};\n            match.erase(remove_if(all(match), mismatch), match.end());\n        }\n        if(Qfrom != \"*\" || Qto != \"*\"){\n            if(Qfrom == \"*\")Qfrom = \"1900/01/01\";\n            if(Qto == \"*\")Qto = \"2099/12/31\";\n            tm from = convert(split(Qfrom, '/')), to = convert(split(Qto, '/'));\n            auto mismatch = [&](Data& d){\n                return difftime(mktime(&get<2>(d)), mktime(&from)) < 0 ||\n                       difftime(mktime(&to), mktime(&get<2>(d))) < 0;\n            };\n            match.erase(remove_if(all(match), mismatch), match.end());;\n        }\n        for(auto x: match)cout << get<0>(x) << '\\n';\n        if(Q)cout << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Book {\nprivate:\n  string title;\n  string author;\n  string date;\n\n  int date2sec(string date){\n    vector<string> elements;\n    string tmp = \"\";\n    for(int i = 0; i < date.size(); i++){\n      if(date[i] == '/'){\n        elements.push_back(tmp);\n        tmp = \"\";\n        continue;\n      }\n      tmp += date[i];\n    }\n    elements.push_back(tmp);\n    \n    return 365 * (atoi(elements[0].c_str()) - 1970)\n      + atoi(elements[1].c_str()) * 31\n      + atoi(elements[2].c_str());\n  }\n\npublic:\n  Book(string title, string author, string date) {\n    this->title = title;\n    this->author = author;\n    this->date = date;\n  }\n\n  bool match_title(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= title.size(); i++){\n      if(title.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_author(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= author.size(); i++){\n      if(author.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_date(string from,string to) {\n    int my_sec = date2sec(date);\n    if(from != \"*\" && my_sec < date2sec(from)) return false;\n    if(to != \"*\" && my_sec > date2sec(to)) return false;\n    return true;\n  }\n\n  string get_title() const {\n    return title;\n  }\n};\n\nint main(){\n  int num_of_books;\n  int num_of_queries;\n  while(~scanf(\"%d\",&num_of_books)){\n    vector<Book> books;\n    for(int book_i = 0; book_i < num_of_books; book_i++){\n      string title,author,date;\n      cin >> title >> author >> date;\n      books.push_back(Book(title,author,date));\n    }\n    scanf(\"%d\",&num_of_queries);\n    for(int query_i = 0; query_i < num_of_queries; query_i++){\n      string title,author,from,to;\n      cin >> title >> author >> from >> to;\n      for(int book_i = 0; book_i < num_of_books; book_i++){\n        if(books[book_i].match_title(title)\n           && books[book_i].match_author(author)\n           && books[book_i].match_date(from,to)){\n          cout << books[book_i].get_title() << endl;\n        }\n      }\n      if(query_i != num_of_queries -1){\n        cout << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum DATE{ FAST, SAME, LATE };\nDATE realcomp(const string& a, const string& b, int idx)\n{\n  if(idx == 10) return(SAME);\n  if(a[idx] == b[idx]) return(realcomp(a, b, idx + 1));\n  if(a[idx] < b[idx]) return(FAST);\n  return(LATE);\n}\nDATE DateCompare(const string& a, const string& b)\n{\n  return(realcomp(a, b, 0));\n}\nbool Compare(const string& a, const string& b) {\n  return(a == \"*\" || b == \"*\" || b.find(a) != string::npos);\n}\n\n\nint main()\n{\n  int N, Q;\n  char buffer[256];\n  char t[256], a[256], d[256];\n  int yy, mm, dd;\n\n  cin >> N;\n  vector< string > title(N), author(N), date(N);\n  for(int i = 0; i < N; i++) {\n    cin >> title[i] >> author[i] >> date[i];\n  }\n  cin >> Q;\n  for(int i = 0; i < Q; i++) {\n    if(i) cout << endl;\n    \n    string Qtitle, Qauthor, Qfrom, Qto;\n    cin >> Qtitle >> Qauthor >> Qfrom >> Qto;\n    for(int j = 0; j < N; j++) {\n      if(Compare(Qtitle, title[j]) &&\n         Compare(Qauthor, author[j]) &&\n         (Qfrom == \"*\" || DateCompare(Qfrom, date[j]) != LATE) &&\n         (Qto   == \"*\" || DateCompare(Qto  , date[j]) != FAST)){\n        cout << title[j] << endl;\n      }\n    }\n  }\n\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tyear -= 1900;\n\tmonth -= 1;\n\tll res = 0LL;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr <= to ) search[2].push_back (book[i] );\t\n//\t\t\tif ( (from < curr || abs (from - curr ) < EPS ) && (curr < to || abs (to - curr ) < EPS ) ) search[2].push_back (book[i] );\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (res.empty() ){\n\t\t\tcout << endl;\n\t\t}else{\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tcout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"tree-vectorize\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define FFOR(i, a, b) FOR(i, a, b+1)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) FOR(i, 1, n+1)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define LEN(x) (int)(x).size()\n#define DUMP(x) cerr<<__LINE__<<' '<<#x<<\"=\"<<(x)<<endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\nusing namespace std;\nusing lint = long long;\nusing pii =  pair<int, int>;\nusing pll =  pair<lint, lint>;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vector<T>>;\ntemplate <typename T> inline bool chmax(T &a, T b){if(a<b){a = b; return true;} return false;}\ntemplate <typename T> inline bool chmin(T &a, T b){if(a>b){a = b; return true;} return false;}\n\nconst double PI = acos(-1);\nconstexpr lint ten(int n) {return n==0 ? 1 : ten(n-1)*10;}\n\nstruct Book{string title, author, date;};\n\nbool matchTitle(string& s, string& t){\n    int n = LEN(s), m = LEN(t);\n    if(t==\"*\") return true;\n    if(n<m) return false;\n    REP(i, n-m+1){\n        if(s.substr(i, m)==t){\n            return true;\n        }\n    }\n    return false;\n}\n\nbool geq(string& dt1, string& dt2){\n    if(dt1==\"*\" or dt2==\"*\") return true;\n    return dt1 <= dt2;\n}\n\nclass Task{\npublic:\n    void solve(istream& in, ostream& out){\n        int N;\n        in>>N;\n        vc<Book> B(N);\n        for(auto& b : B) in>>b.title>>b.author>>b.date;\n        int Q;\n        in>>Q;\n        while(Q--){\n            string title, author, from, to;\n            in>>title>>author>>from>>to;\n            for(auto& b : B){\n                bool ok = true;\n                ok &= matchTitle(b.title, title);\n                ok &= matchTitle(b.author, author);\n                ok &= geq(from, b.date);\n                ok &= geq(b.date, to);\n                if(ok) out<<b.title<<'\\n';\n            }\n            if(Q) out<<'\\n';\n        }\n    }\n};\n\nint main(){\n    istream& in(cin);\n    ostream& out(cout);\n    ios_base::sync_with_stdio(false);\n    in.tie(nullptr), out.tie(nullptr);\n    Task solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nclass book{\npublic:\n  string title,auther;\n  ll data;\n};\n\nll toInt(string str){\n  stringstream ss(str);\n  ll re=0,a;char c;\n  ss>>a>>c;\n  re+=a*10000;\n  ss>>a>>c;\n  re+=a*100;\n  ss>>a>>c;\n  re+=a;\n  return re;\n}\n\nint main(){\n  int i,j,k;\n  int n,q;\n  cin>>n;\n  vector<book> books;\n  string ti,au,dat;\n  book tmp;\n  rep(i,n){\n    cin>>ti>>au>>dat;\n    tmp.title=ti;\n    tmp.auther=au;\n    tmp.data=toInt(dat);\n    books.pb(tmp);\n  }\n  cin>>q;\n  string datl,datr;\n  rep(i,q){\n    cin>>ti>>au>>datl>>datr;\n    ll datal=toInt(datl),datar=toInt(datr);\n    rep(j,n){\n      if(ti!=\"*\" && books[j].title.find(ti)==string::npos)\n        continue;\n      if(au!=\"*\" && books[j].auther.find(au)==string::npos)\n        continue;\n      if(datl!=\"*\" && datal>books[j].data)\n        continue;\n      if(datr!=\"*\" && datar<books[j].data)\n        continue;\n      cout<<books[j].title<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,flag2,len,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to,out;\n  queue<string> Q;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  flag2=0;\n  for(i=0;i<q;i++){\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0){\n\tQ.push(title[j]);\n      }\n    }\n    if(flag2!=0&&Q.empty()!=1) cout << endl;\n    len=Q.size();\n    for(j=0;j<len;j++){\n      out=Q.front();\n      Q.pop();\n      cout << out << endl;\n      flag2=1;\n    }\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int len,len2,i,j,l,flag=0,cnt=0;\n  if(c==\"title\"){\n    len=title[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==title[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }else{\n    len=author[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==author[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[4];\n\t\trep (k, 4 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from < curr  ) search[3].push_back (search[2][i] );\n\t\t} // end rep\n\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, search[3].size() ){\n\t\t\tll curr = search[3][i].datenum;\n\t\t\tif (curr < to  ) res.push_back (search[3][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint N, Q, y, m, d, date[100]; string a, b, c, g, book[100], auth[100];\nint main() {\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> book[i] >> auth[i] >> a;\n\t\tsscanf(a.c_str(), \"%d/%02d/%02d\", y, m, d);\n\t\tdate[i] = y * 10000 + m * 100 + d;\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> a >> b >> c >> g;\n\t\tif(i) cout << endl;\n\t\tif(c != \"*\") sscanf(c.c_str(), \"%d/%02d/%02d\", y, m, d);\n\t\tint d1 = y * 10000 + m * 100 + d;\n\t\tif(g != \"*\") sscanf(g.c_str(), \"%d/%02d/%02d\", y, m, d);\n\t\tint d2 = y * 10000 + m * 100 + d;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tbool f1 = (a == \"*\" || book[i].find(a) != string::npos);\n\t\t\tbool f2 = (b == \"*\" || auth[i].find(b) != string::npos);\n\t\t\tbool f3 = (c == \"*\" || date[i] >= d1);\n\t\t\tbool f4 = (g == \"*\" || date[i] <= d2);\n\t\t\tif(f1 && f2 && f3 && f4) cout << book[i] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nstruct book{\n    string t, a;\n    int y,m,d;\n};\nvector<book>vec;\nint main(){\n    int n;\n    string t,a,d,qt,qa,qd1,qd2;\n    cin>>n;\n    while(n--){\n        int ty=0,tm=0,td=0,i;\n        cin>>t>>a>>d;\n        book b;\n        b.t=t;\n        b.a=a;\n        for(i=0;i<4;i++)\n            ty=ty*10+d[i]-'0';\n        for(i=5;i<7;i++)\n            tm=tm*10+d[i]-'0';\n        for(i=8;i<10;i++)\n            td=td*10+d[i]-'0';\n        b.y=ty,b.m=tm,b.d=td;\n        vec.push_back(b);\n    }\n    cin>>n;\n    while(n--){\n        string q1,q2,q3,q4;\n        cin>>q1>>q2>>q3>>q4;\n        int ty1=0,tm1=0,td1=0,ty2=3000,tm2=30,td2=50,i;\n        if(q3!=\"*\"){\n            for(i=0;i<4;i++)\n                ty1=ty1*10+q3[i]-'0';\n            for(i=5;i<7;i++)\n                tm1=tm1*10+q3[i]-'0';\n            for(i=8;i<10;i++)\n                td1=td1*10+q3[i]-'0';\n        }\n        if(q4!=\"*\"){\n            for(i=0;i<4;i++)\n                ty2=ty2*10+q4[i]-'0';\n            for(i=5;i<7;i++)\n                tm2=tm2*10+q4[i]-'0';\n            for(i=8;i<10;i++)\n                td2=td2*10+q4[i]-'0';\n        }\n        int f=0;\n        for(int i=0;i<vec.size();i++){\n            size_t found = vec[i].t.find(q1);\n            if (q1!=\"*\"&&found==string::npos)\n                continue;\n            \n            found = vec[i].a.find(q2);\n            if (q2!=\"*\"&&found==string::npos)\n                continue;\n            if(vec[i].y>=ty1&&vec[i].m>=tm1&&vec[i].d>=td1&&vec[i].y<=ty2&&vec[i].m<=tm2&&vec[i].d<=td2){\n                f=1;\n                cout<<vec[i].t<<endl;\n            }\n            \n        }\n        if(n>0)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint dtoi(string date)\n{\n  int ans=0;\n  ans =stoi(date.substr(0,4))*12*31+stoi(date.substr(5,2))*31+stoi(date.substr(8,2));\n  return ans;\n}\n\nint main()\n{\n  int n;\n  cin>>n;\n  string t[n], a[n],d[n];\n  for(int i=0;i<n;i++){\n    cin>>t[i]>>a[i]>>d[i];\n  }\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    string tt,qq,df,dt;\n    cin>>tt>>qq>>df>>dt;\n    for(int i=0;i<n;i++){\n      if(tt!=\"*\"&& t[i].find(tt)==string::npos)\n\tcontinue;\n      if(qq!=\"*\"&& a[i].find(qq)==string::npos)\n\tcontinue;\n      int d1 = dtoi(d[i]);\n      if(df!=\"*\" && d1<dtoi(df))\n\tcontinue;\n      if(dt!=\"*\" && d1>dtoi(dt))\n\tcontinue;\n      cout<<t[i]<<endl;\n    }\n    if(i!=q-1)\n      cout<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n,q;\nstring tit[111],date[111],name[111];\n\nbool ok1(string a,string b){\n  if(b==\"*\")return 1;\n  r(i,a.size()){\n    if(i+(int)b.size()>a.size())return 0;\n    int f=0;\n    r(j,b.size()){\n      if(a[i+j]!=b[j])f=1;\n    }\n    if(!f)return 1;\n  }\n  return 0;\n}\n\nbool ok3(string a,string b,string c){\n  if(b==\"*\"&&c==\"*\")return 1;\n  else if(b==\"*\"){\n    return a<=c;\n  }\n  else if(c==\"*\"){\n    return b<=a;\n  }\n  else{\n    return b<=a && a<=c;\n  }\n}\n\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>tit[i];\n    cin>>name[i];\n    cin>>date[i];\n  }\n  cin>>q;\n  r(jj,q){\n    string a,b,c,d;\n    cin>>a>>b>>c>>d;\n    r(i,n){\n      if(!ok1(tit[i],a))continue;\n      if(!ok1(name[i],b))continue;\n      if(!ok3(date[i],c,d))continue;\n      cout<<tit[i]<<endl;\n    }\n    if(jj!=q-1)cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Book {\nprivate:\n  string title;\n  string author;\n  string date;\n\n  int date2sec(string date){\n    vector<string> elements;\n    string tmp = \"\";\n    for(int i = 0; i < date.size(); i++){\n      if(date[i] == '/'){\n        elements.push_back(tmp);\n        tmp = \"\";\n        continue;\n      }\n      tmp += date[i];\n    }\n    elements.push_back(tmp);\n    \n    return 365 * (atoi(elements[0].c_str()) - 1970)\n      + atoi(elements[1].c_str()) * 31\n      + atoi(elements[2].c_str());\n  }\n\npublic:\n  Book(string title, string author, string date) {\n    this->title = title;\n    this->author = author;\n    this->date = date;\n  }\n\n  bool match_title(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= title.size(); i++){\n      if(title.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_author(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= author.size(); i++){\n      if(author.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_date(string from,string to) {\n    int my_sec = date2sec(date);\n    if(from != \"*\" && my_sec < date2sec(from)) return false;\n    if(to != \"*\" && my_sec > date2sec(to)) return false;\n    return true;\n  }\n\n  string get_title() const {\n    return title;\n  }\n};\n\nint main(){\n  int num_of_books;\n  int num_of_queries;\n  while(~scanf(\"%d\",&num_of_books)){\n    vector<Book> books;\n    for(int book_i = 0; book_i < num_of_books; book_i++){\n      string title,author,date;\n      cin >> title >> author >> date;\n      books.push_back(Book(title,author,date));\n    }\n    scanf(\"%d\",&num_of_queries);\n    for(int query_i = 0; query_i < num_of_queries; query_i++){\n      string title,author,from,to;\n      cin >> title >> author >> from >> to;\n      for(int book_i = 0; book_i < num_of_books; book_i++){\n        if(books[book_i].match_title(title)\n           && books[book_i].match_author(author)\n           && books[book_i].match_date(from,to)){\n          cout << books[book_i].get_title() << endl;\n        }\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nclass book{\npublic:\n  string title,auther;\n  ll data;\n};\n\nll toInt(string str){\n  stringstream ss(str);\n  ll re=0,a;char c;\n  ss>>a>>c;\n  re+=a*10000;\n  ss>>a>>c;\n  re+=a*100;\n  ss>>a>>c;\n  re+=a;\n  return re;\n}\n\nint main(){\n  int i,j,k;\n  int n,q;\n  cin>>n;\n  vector<book> books;\n  string ti,au,dat;\n  book tmp;\n  rep(i,n){\n    cin>>ti>>au>>dat;\n    tmp.title=ti;\n    tmp.auther=au;\n    tmp.data=toInt(dat);\n    books.pb(tmp);\n  }\n  cin>>q;\n  string datl,datr;\n  rep(i,q){\n    cin>>ti>>au>>datl>>datr;\n    ll datal=toInt(datl),datar=toInt(datr);\n    rep(j,n){\n      if(ti!=\"*\" && books[j].title.find(ti)==string::npos)\n        continue;\n      if(au!=\"*\" && books[j].auther.find(au)==string::npos)\n        continue;\n      if(datl!=\"*\" && datal>books[j].data)\n        continue;\n      if(datr!=\"*\" && datar<books[j].data)\n        continue;\n      cout<<books[j].title<<endl;\n    }\n    if(i<q-1)cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cstdlib>\n\nusing namespace std;\ntypedef tuple<string, string, int> tssi;\n\nint read_date(){\n\tstring head;\n\tcin >> head;\n\tif(head == \"*\"){ return -1; }\n\tistringstream iss(head);\n\tint y, m, d;\n\tiss >> y; iss.ignore();\n\tiss >> m; cin.ignore();\n\tiss >> d;\n\treturn y * 1000 + m * 100 + d;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<tssi> books(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tstring title, author;\n\t\tcin >> title >> author;\n\t\tconst int date = read_date();\n\t\tbooks[i] = tssi(title, author, date);\n\t}\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tstring title, author;\n\t\tcin >> title >> author;\n\t\tint from = read_date();\n\t\tint to = read_date();\n\t\tif(from < 0){ from = 0; }\n\t\tif(to < 0){ to = 1000000000; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(title != \"*\" && get<0>(books[i]).find(title) == string::npos){ continue; }\n\t\t\tif(author != \"*\" && get<1>(books[i]).find(author) == string::npos){ continue; }\n\t\t\tif(from <= get<2>(books[i]) && get<2>(books[i]) <= to){\n\t\t\t\tcout << get<0>(books[i]) << endl;\n\t\t\t}\n\t\t}\n\t\tif(q != 0){ cout << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint parseDate(const string &s){\n  int y, m, d;\n  sscanf(s.c_str(), \"%04d/%02d/%02d\", &y, &m, &d);\n  return y * 10000 + m * 100 + d;\n}\n\nint main(){\n  const int n = getInt();\n  vector<string> title(n);\n  vector<string> auther(n);\n  vector<int> date(n);\n\n  REP(i,n){\n    string dt;\n    cin >> title[i] >> auther[i] >> dt;\n    date[i] = parseDate(dt);\n  }\n\n  const int q = getInt();\n  REP(i,q){\n    string t, a, df, dt;\n    cin >> t >> a >> df >> dt;\n\n    REP(j,n){\n      if(t != \"*\" && title[j].find(t) == string::npos) goto next;\n      if(a != \"*\" && auther[j].find(a) == string::npos) goto next;\n      if(df != \"*\" && parseDate(df) > date[j]) goto next;\n      if(dt != \"*\" && parseDate(dt) < date[j]) goto next;\n      printf(\"%s\\n\", title[j].c_str());\n      next:;\n    }\n\n    puts(\"\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, m, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(i, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok = true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n//\t\trep (i, search[2].size() ) disp_book (search[2][i] );\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from < curr && curr < to ) res.push_back (search[2][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, m, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\ta1 = 1000; a2 = 1000;\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (k + W.size()>a[j].size()) { break; }\n\t\t\t\t\tif (a[j].substr(k, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok == true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a1 > 0) {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (a2 < (1 << 28)) {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 からの経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tll res = 0LL;\n\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr <= to ) search[2].push_back (book[i] );\t\n//\t\t\tif ( (from < curr || abs (from - curr ) < EPS ) && (curr < to || abs (to - curr ) < EPS ) ) search[2].push_back (book[i] );\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nbool contain(string str, string sub) {\n    for (int i = 0; i < (int)str.size() - (int)sub.size() + 1; ++i) {\n        if (str.substr(i, (int)sub.size()) == sub) return true;\n    }\n    return false;\n}\n\nstruct data {\n    string title, author, date;\n    \n    data(string t_, string a_, string d_) { title = t_; author = a_; date = d_; }\n    \n    bool equal(string t, string a, string from, string to) {\n        if (t != \"*\") {\n            if (!contain(title, t)) return false;\n        }\n        if (a != \"*\") {\n            if (!contain(author, a)) return false;\n        }\n        if (from != \"*\") {\n            if (from > date) return false;\n        }\n        if (to != \"*\") {\n            if (to < date) return false;\n        }\n        return true;\n    }\n};\n\nint n, q;\n\nint main() {\n    while (cin >> n) {\n        vector<data> se;\n        for (int i = 0; i < n; ++i) {\n            string a, b, c;\n            cin >> a >> b >> c;\n            se.PB(data(a, b, c));\n        }\n        cin >> q;\n        for (int i = 0; i < q; ++i) {\n            string t, a, from, to;\n            cin >> t >> a >> from >> to;\n            \n            for (int i = 0; i < se.size(); ++i) {\n                data d = se[i];\n                if ( d.equal(t, a, from, to)) {\n                    cout << d.title << endl;\n                }\n            }\n            if (i != q-1) cout << endl;\n        }            \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\nint enc(int y,int m,int d){\n  return y*31*12 + m * 31 + d;\n}\n\nint main() {\n  int n;scanf(\"%d\",&n);\n  vector<string> ts(n),as(n);vector<int> ds(n);\n  REP(i,n){\n\tcin >> ts[i] >> as[i];\n\tstring dstr;cin >> dstr;\n\tint y,m,d;sscanf(dstr.c_str(),\"%d/%d/%d\",&y,&m,&d);\n\tds[i]=enc(y,m,d);\n  }\n\n  int m;scanf(\"%d\",&m);\n  REP(i,m){\n\tstring t,a;\n\tcin >> t >> a;\n\tint dl=-(1<<28),dr=1<<28;\n\tstring dlstr,drstr;cin >> dlstr >> drstr;\n\tif(dlstr!=\"*\"){\n\t  int y,m,d;sscanf(dlstr.c_str(),\"%d/%d/%d\",&y,&m,&d);\n\t  dl=enc(y,m,d);\n\t}\n\tif(drstr!=\"*\"){\n\t  int y,m,d;sscanf(drstr.c_str(),\"%d/%d/%d\",&y,&m,&d);\n\t  dr=enc(y,m,d);\n\t}\n\tREP(j,n){\n\t  bool ok=true;\n\n\t  if(t!=\"*\" && ts[j].find(t)==string::npos)ok=false;\n\t  if(a!=\"*\" && as[j].find(a)==string::npos)ok=false;\n\t  if(!(dl<= ds[j] && ds[j] <=dr))ok=false;\n\t  if(ok){\n\t\tcout << ts[j] <<endl;\n\t  }\n\t}\n\tif(i!=m-1)cout <<endl;\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nchar t[111][55],a[111][55],d[111][55];\nint y[111],m[111],D[111];\n\n\nint main(void)\n{\n  int n,q;\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%s%s%s\",t[i],a[i],d[i]);\n    y[i] = atoi(d[i]);\n    m[i] = atoi(d[i]+5);\n    D[i] = atoi(d[i]+8);\n  }\n  scanf(\"%d\",&q);\n  for( int i = 0; i < q; i++ ) {\n    char ti[55],aa[55],ff[55],tt[55];\n    if( i ) puts(\"\");\n    scanf(\"%s%s%s%s\",ti,aa,ff,tt);\n    bool o = false;\n    for( int j = 0; j < n; j++ ) {\n      bool hit = true;\n      if( *ti != '*' ) {\n        if( !strstr(t[j],ti) ) hit = false;\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( *aa != '*' ) {\n        if( !strstr(a[j],aa) ) hit = false;\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( *ff != '*' ) {\n        int yy,mm,dd;\n        yy = atoi(ff);\n        mm = atoi(ff+5);\n        dd = atoi(ff+8);\n        if( yy > y[j] ) hit = false;\n        if( yy == y[j] ) {\n          if( mm > m[j] ) hit = false;\n          if( mm == m[j] ) {\n            if( dd > D[j] ) hit = false;\n          }\n        }\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( *tt != '*' ) {\n        int yy,mm,dd;\n        yy = atoi(tt);\n        mm = atoi(tt+5);\n        dd = atoi(tt+8);\n        if( yy < y[j] ) hit = false;\n        if( yy == y[j] ) {\n          if( mm < m[j] ) hit = false;\n          if( mm == m[j] ) {\n            if( dd < D[j] ) hit = false;\n          }\n        }\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( hit ) puts(t[j]);\n      o |= hit;\n    }\n    if( !o ) puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<string, pair<string,string>>> books;\n\nvoid search_books(string qname, string qauthor, string qfrom, string qto){\n    for(int i=0;i<books.size();++i){\n        if(books[i].first.find(qname)==string::npos&&qname.at(0)!='*') continue;\n        if(books[i].second.first.find(qauthor)==string::npos&&qauthor.at(0)!='*') continue;\n        if((books[i].second.second<qfrom&&qfrom.at(0)!='*') continue;\n        if((books[i].second.second>qto&&qto.at(0)!='*') continue;\n        cout << books[i].first << endl;\n    }\n\n    return;\n}\n\nint main() {\n    for(int N;cin>>N;){\n        for(int i=0;i<N;++i){\n            string name,author,date;\n            cin>>name>>author>>date;\n            books.push_back(make_pair(name,make_pair(author,date)));\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;++i){\n            string qname,qauthor,qfrom,qto;\n            cin>>qname>>qauthor>>qfrom>>qto;\n            search_books(qname,qauthor,qfrom,qto);\n            if(i!=Q-1) cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int N,Q;\n  string ti[101],au[101],da[101];\n  cin>>N;\n  for(int i=0;i<N;i++)cin>>ti[i]>>au[i]>>da[i];\n  cin>>Q;\n  string a,b,c,d;\n \n  for(int k=0;k<Q;k++){\n    int f[4][101]={};\n    cin>>a>>b>>c>>d;\n    if(a[0]!='*'){\n      for(int i=0;i<N;i++){\n       \tfor(int j=0;j<ti[i].size();j++){\n\t  int c=0;\n\t  while(ti[i][j+c]==a[c]){\n\t    c++;\n\t    if(c==a.size()){f[0][i]=1;break;}\n\t  }\n\t}\n      }\n    }\n    else for(int i=0;i<N;i++)f[0][i]=1;\n\n    if(b[0]!='*'){\n      for(int i=0;i<N;i++){\n\tfor(int j=0;j<au[i].size();j++){\n\t  int c=0;\n\t  while(au[i][j+c]==b[c]){\n\t    c++;\n\t    if(c==b.size()){f[1][i]=1;break;}\n\t  }\n\t}\n      }\n    }\n    else for(int i=0;i<N;i++)f[1][i]=1;\n\n    if(c[0]!='*'){\n      for(int i=0;i<N;i++)\n\tfor(int j=0;j<10;j++){\n\t  if(c[j]>da[i][j])break;\n\t  if(c[j]<da[i][j]){f[2][i]=1;break;}\n\t}\n    }\n    else for(int i=0;i<N;i++)f[2][i]=1;\n\n    if(d[0]!='*'){\n      for(int i=0;i<N;i++)\n\tfor(int j=0;j<10;j++){\n\t  if(d[j]<da[i][j])break;\n\t  if(d[j]>da[i][j]){f[3][i]=1;break;}\n\t}\n    }\n    else for(int i=0;i<N;i++)f[3][i]=1;\n    for(int i=0;i<N;i++){\n      if(f[0][i]==1&&f[1][i]==1&&f[2][i]==1&&f[3][i]==1)cout<<ti[i]<<endl;\n    }\n    if(k<Q-1) cout<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <functional>\n#include <iomanip>\nusing namespace std;\n\ntypedef struct\n{\n    string title;\n    string author;\n    int date;\n} book;\n\nbook nyaan[100];\nint nyan(string str);\n\nint main(void)\n{\n    int i, j, N;\n\n    cin >> N;\n\n    for (i = 0; i < N; i++)\n    {\n        string str;\n        cin >> nyaan[i].title >> nyaan[i].author >> str;\n        int y = 10000 * stoi(str.substr(0, 4)) + 100 * stoi(str.substr(5, 2)) + stoi(str.substr(8, 2));\n        nyaan[i].date = y;\n    }\n\n    int Q;\n\n    cin >> Q;\n\n    for (j = 0; j < Q; j++)\n    {\n        string in1, in2, in3, in4;\n        cin >> in1 >> in2 >> in3 >> in4;\n\n        for (i = 0; i < N; i++)\n        {\n            bool ok = true;\n\n            if (nyaan[i].title.find(in1) != string::npos || in1 == \"*\")\n                ;\n            else\n                ok = false;\n\n            if (nyaan[i].author.find(in2) != string::npos || in2 == \"*\")\n                ;\n            else\n                ok = false;\n\n            if (in3 != \"*\" && nyaan[i].date < nyan(in3))\n                ok = false;\n\n            if (in4 != \"*\" && nyaan[i].date > nyan(in4))\n                ok = false;\n\n            if (ok)\n                cout << nyaan[i].title << endl;\n        }\n\n        if (j != Q - 1)\n            cout << endl;\n    }\n\n    return 0;\n}\n\nint nyan(string str)\n{\n    int y = 10000 * stoi(str.substr(0, 4)) + 100 * stoi(str.substr(5, 2)) + stoi(str.substr(8, 2));\n    return y;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nnamespace Day {\n  enum {MON, TUE, WED, THU, FRI, SAT, SUN};\n  int leap_count(int year) {\n    if (year < 0) return -leap_count(-year - 1) - 1;\n    return year / 4 - year / 100 + year / 400;\n  }\n  int day_count(int year, int month, int day) {\n    if (month <= 2) --year, month += 12;\n    return year * 365 + leap_count(year) + (month * 153 + 3) / 5 + day;\n  }\n  bool is_leap(int year) {return leap_count(year) > leap_count(year - 1);}\n};\n\n#include <sstream>\n\ntemplate<class A, class B> B convert(A a) {\n  stringstream ss;\n  ss << a;\n  B b;\n  ss >> b;\n  return b;\n}\n\nint parse(string s) {\n  int year = convert<string, int>(s.substr(0, 4));\n  int month = convert<string, int>(s.substr(5, 2));\n  int day = convert<string, int>(s.substr(8));\n  return Day::day_count(year, month, day);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string title[n], auther[n], date[n];\n  for (int i : range(n)) cin >> title[i] >> auther[i] >> date[i];\n  int d[n];\n  for (int i : range(n)) d[i] = parse(date[i]);\n  int q;\n  cin >> q;\n  for (int i : range(q)) {\n    if (i != 0) cout << endl;\n    string q_title, q_auther, q_date_from, q_date_to;\n    cin >> q_title >> q_auther >> q_date_from >> q_date_to;\n    int from = -1;\n    if (q_date_from != \"*\") from = parse(q_date_from);\n    int to = -1;\n    if (q_date_to != \"*\") to = parse(q_date_to);\n    for (int j : range(n)) {\n      if (q_title != \"*\" && title[j].find(q_title) == string::npos) continue;\n      if (q_auther != \"*\" && auther[j].find(q_auther) == string::npos) continue;\n      if (from != -1 && d[j] < from) continue;\n      if (to != -1 && to < d[j]) continue;\n      cout << title[j] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 からの経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tll res = 0LL;\n\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1900;\n\tmonth -= 1;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr <= to ) search[2].push_back (book[i] );\t\n//\t\t\tif ( (from < curr || abs (from - curr ) < EPS ) && (curr < to || abs (to - curr ) < EPS ) ) search[2].push_back (book[i] );\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nchar t[111][55],a[111][55],d[111][55];\nint y[111],m[111],D[111];\n\n\nint main(void)\n{\n  int n,q;\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%s%s%s\",t[i],a[i],d[i]);\n    y[i] = atoi(d[i]);\n    m[i] = atoi(d[i]+5);\n    D[i] = atoi(d[i]+8);\n  }\n  scanf(\"%d\",&q);\n  for( int i = 0; i < q; i++ ) {\n    char ti[55],aa[55],ff[55],tt[55];\n    if( i ) puts(\"\");\n    scanf(\"%s%s%s%s\",ti,aa,ff,tt);\n    bool o = false;\n    for( int j = 0; j < n; j++ ) {\n      bool hit = true;\n      if( *ti != '*' ) {\n        if( !strstr(t[j],ti) ) hit = false;\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( *aa != '*' ) {\n        if( !strstr(a[j],aa) ) hit = false;\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( *ff != '*' ) {\n        int yy,mm,dd;\n        yy = atoi(ff);\n        mm = atoi(ff+5);\n        dd = atoi(ff+8);\n        if( yy > y[j] ) hit = false;\n        if( yy == y[j] ) {\n          if( mm > m[j] ) hit = false;\n          if( mm == m[j] ) {\n            if( dd > D[j] ) hit = false;\n          }\n        }\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( *tt != '*' ) {\n        int yy,mm,dd;\n        yy = atoi(tt);\n        mm = atoi(tt+5);\n        dd = atoi(tt+8);\n        if( yy < y[j] ) hit = false;\n        if( yy == y[j] ) {\n          if( mm < m[j] ) hit = false;\n          if( mm == m[j] ) {\n            if( dd < D[j] ) hit = false;\n          }\n        }\n      }\n      //printf(\"%d:%d %d\\n\",i,j,hit);\n      if( hit ) puts(t[j]);\n      o |= hit;\n    }\n    //if( !o ) puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nusing namespace std;\nstring f(){\n\tstring a=\"\";\n\tchar d;\n\trep(i,10){\n\t\tcin>>d;\n\t\tif(d=='*')return \"*\";\n\t\tif(i==4||i==7)continue;\n\t\ta+=d;\n\t}\n\treturn a;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<vector<string> >in(n,vector<string>(3));\n\trep(i,n){\n\t\trep(j,2)cin>>in[i][j];\n\t\tin[i][2]=f();\n\t}\n\tint m;\n\tcin>>m;\n\twhile(m--){\n\t\tstring a,b,c,d;\n\t\tcin>>a>>b;\n\t\tc=f();\n\t\td=f();\n\t\tvector<bool>h(n,true);\n\t\tif(a!=\"*\")rep(i,n)if(in[i][0].find(a)==string::npos)h[i]=false;\n\t\tif(b!=\"*\")rep(i,n)if(in[i][1].find(b)==string::npos)h[i]=false;\n\t\tif(c!=\"*\")rep(i,n)if(atoi(&in[i][2][0])<atoi(&c[0]))h[i]=false;\n\t\tif(d!=\"*\")rep(i,n)if(atoi(&in[i][2][0])>atoi(&d[0]))h[i]=false;\n\t\trep(i,n)if(h[i])cout<<in[i][0]<<endl;\n\t\tif(m)cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n\nconst int B = 1e9+7, H = 1e9+9;\n//Hash(C) = (C1*B^(n-1)+...+Cn*B^0) mod H\nint contain(string a,string b){\n  if(a.size() > b.size()) return false;\n\n  int t = 1,ah = 0,bh = 0;\n  for(int i = 0; i < a.size(); i++) ah = ah*B + a[i],t *= B;\n  for(int i = 0; i < a.size(); i++) bh = bh*B + b[i];\n\n  int cnt = 0;\n  for(int i = a.size(); i <= b.size(); i++){\n    if(ah == bh) cnt++;\n    if(i >= b.size()) break;\n    bh = bh*B + b[i] - b[i-a.size()]*t;\n  }\n  return cnt;\n}\n\nsigned main(){\n\n  int n; cin >> n;\n  vector<tuple<string,string,string>> v(n);\n  for(int i = 0; i < n; i++){\n    string a,b,c; cin >> a >> b >> c;\n    v[i] = make_tuple(a,b,c);\n  }\n\n  int q; cin >> q;\n  for(int i = 0; i < q; i++){\n    string a,b,c,d; cin >> a >> b >> c >> d;\n    if(i) cout << endl;\n    for(int j = 0; j < n; j++){\n      string e = get<0>(v[j]);\n      string f = get<1>(v[j]);\n      string g = get<2>(v[j]);\n      bool judge = true;\n      if(!(a == \"*\" || contain(a,e))) judge = false;\n      if(!(b == \"*\" || contain(b,f))) judge = false;\n      if(!(c == \"*\" || c <= g)) judge = false;\n      if(!(d == \"*\" || d >= g)) judge = false;\n      if(judge) cout << e << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948, 1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 からの経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tll res = 0LL;\n\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1900;\n\tmonth -= 1;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr <= to ) search[2].push_back (book[i] );\t\n//\t\t\tif ( (from < curr || abs (from - curr ) < EPS ) && (curr < to || abs (to - curr ) < EPS ) ) search[2].push_back (book[i] );\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lp(i, n) for(int i = 0;i<(n);++i)\n#define INF 1000000009\nusing namespace std;\n\nint hsd(string c){\n  int y=stoi(c.substr(0,4));\n  int m=stoi(c.substr(5,2));\n  int d=stoi(c.substr(8,2));\n  return y*10000+m*100+d;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<pair<pair<string,string>,int>> l;\n  lp(i,n){\n    string a,b,c;\n    cin>>a>>b>>c;\n    l.push_back({{a,b},hsd(c)});\n  }\n  int q;\n  cin>>q;\n  lp(i,q){\n    string a,b,c,d;\n    cin>>a>>b>>c>>d;\n    int un,up;\n    if(c==\"*\") un=0;\n    else un=hsd(c);\n    if(d==\"*\") up=INF;\n    else up=hsd(d);\n    lp(j,n){\n      string title=l[j].first.first;\n      bool ok=true;\n      if(a!=\"*\"){\n\tok=false;\n\tif(title.size()<a.size()) continue;\n\tlp(z,title.size()-a.size()+1){\n\t  if(a==title.substr(z,a.size())) ok=true;\n\t}\n      }\n      if(ok==false) continue;\n      title=l[j].first.second;\n      if(b!=\"*\"){\n\tok=false;\n\tif(title.size()<b.size()) continue;\n\tlp(z,title.size()-b.size()+1){\n\t  if(b==title.substr(z,b.size())) ok=true;\n\t}\n\tif(ok==false) continue;\n      }\n      ok=false;\n      if(un<=l[j].second&&l[j].second<=up) ok=true;\n      if(ok==true)cout<<l[j].first.first<<endl;\n    }\n    if(i!=q-1)cout<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\ntypedef struct book{\n    string title,auth,date;\n} bk;\n\nvector<string> split(string s,char ch){\n    vector<string> ret;\n    string tmp =\"\";\n    rep(i,s.size()){\n        if(s[i]==ch){\n            ret.pb(tmp);\n            tmp = \"\";\n        }else tmp+=s[i];\n    }\n    if(tmp.size())ret.pb(tmp);\n    return ret;\n}\n\n//????????????0\n//a?????\\????????????????????????1???\n//a?????\\????????????????????????-1?????????\nint ymdcompare(string a,string b){\n    vector<string> A[2];\n    A[0] = split(a,'/');\n    A[1] = split(b,'/');\n    int ymd[2][3];\n    rep(i,2)rep(j,3)ymd[i][j]=stoi(A[i][j]);\n    \n    rep(i,3){\n        if(ymd[0][i]>ymd[1][i])return -1;\n        if(ymd[0][i]<ymd[1][i])return  1;\n    }\n    \n    return 0;\n}\n\n\nbool is(bk data,string title,string auth,string from,string to){\n    if(title!=\"*\"   && data.title.find(title)==string::npos)return false;\n\n    if(auth!=\"*\"    && data.auth.find(auth)==string::npos)  return false;\n\n    if(from!=\"*\"    && ymdcompare(from,data.date)==-1)      return false;\n\n    if(to!=\"*\"      && ymdcompare(to,data.date)==1)         return false;\n\n    return true;\n}\n\nint main(){\n    \n    int n;\n    cin>>n;\n    vector<bk> data;\n    \n    rep(i,n){\n        string a,b,c;\n        cin>>a>>b>>c;\n        data.pb(bk{a,b,c});\n    }\n    \n    int q;\n    cin>>q;\n    rep(i,q){\n        string title,auth,from,to;\n        cin>>title>>auth>>from>>to;\n        \n        vector<string> t;\n        rep(j,n){\n            if(is(data[j],title,auth,from,to))t.pb(data[j].title);\n        }\n        \n        rep(i,t.size())cout<<t[i]<<endl;\n        if(i!=q-1)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s[100],t[100];\nint g[100];\nint n,m;\n\nint conv(string x){\n    int a,b,c;\n    char ig;\n    stringstream ss(x);\n    ss>>a>>ig>>b>>ig>>c;\n    return a*10000+b*100+c;\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        string a;\n        cin>>s[i]>>t[i]>>a;\n        g[i]=conv(a);\n    }\n\n    cin>>m;\n    bool la=false;\n    while(m--){\n        if(la)cout<<endl;\n        else la=true;\n        string a,b,c,d;\n        cin>>a>>b>>c>>d;\n        for(int i=0;i<n;i++){\n            bool flag=true;\n            if(a!=\"*\")if(s[i].find(a)==string::npos)flag=false;\n            if(b!=\"*\")if(t[i].find(b)==string::npos)flag=false;\n            if(c!=\"*\")if(conv(c)>g[i])flag=false;\n            if(d!=\"*\")if(conv(d)<g[i])flag=false;\n            if(flag)cout<<s[i]<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nvector<string> G[100];\n\nbool check(string &s,string &t){\n  for(int i=0;i+t.size()<=s.size();i++){\n    if(s.substr(i,t.size())==t)return true;\n  }\n  return false;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    G[i].resize(3);\n    for(int j=0;j<3;j++)cin>>G[i][j];\n  }\n  cin>>m;\n  for(int i=0;i<m;i++){\n    if(i)cout<<endl;\n    vector<string> a(4);    \n    for(int j=0;j<4;j++)cin>>a[j];\n    for(int k=0;k<n;k++){\n      if(a[0]!=\"*\"&&!check(G[k][0],a[0]))continue;\n      if(a[1]!=\"*\"&&!check(G[k][1],a[1]))continue;\n      if(a[2]!=\"*\"&&G[k][2]<a[2])continue;\n      if(a[3]!=\"*\"&&G[k][2]>a[3])continue;\n      cout<<G[k][0]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\n\nBOOK book[105];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 からの経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tll res = 0LL;\n\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, 105 ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" ) q_title = q_t;\n\t\tif (q_a != \"*\" ) q_auther = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to = q_d_t;\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, n ){\n\t\t\t\tstring curr = book[i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[0].push_back (book[i] );\n\t\t\t} // end if\n\t\t}else{\n\t\t\trep (i, n ) search[0].push_back (book[i] );\n\t\t} // end if\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, n ) if (book[i].auther == q_auther ) search[1].push_back (book[i] );\n\t\t}else{\n\t\t\trep (i, n ) search[1].push_back (book[i] );\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, n ){\n\t\t\tll curr = book[i].datenum;\n\t\t\tif (from <= curr && curr < to ) search[2].push_back (book[i] );\t\n//\t\t\t\n\t\t} // end rep\n\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[0].size() ){\n\t\t\trep (j, search[1].size() ){\n\t\t\t\trep (k, search[2].size() ){\n\t\t\t\t\tif (search[0][i] == search[1][j] && search[1][j] == search[2][k] ){\n\t\t\t\t\t\tBOOK ans = search[0][i];\n\t\t\t\t\t\tres.push_back (ans.title );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Date {\n\n  int year,month,day;\n\n  Date(string date) {\n    rep(i,date.size()) if( date[i] == '/' ) date[i] = ' ';\n    stringstream ss;\n    ss << date;\n    ss >> year >> month >> day;\n  }\n  \n  bool operator <= ( const Date& data ) const  {\n    if( year != data.year )   return year  < data.year;\n    if( month != data.month ) return month < data.month;\n    return day <= data.day;\n  }\n\n};\n\nstruct Book {\n  string title,author;\n  Date date;\n  Book(string title,string author,string date) : title(title), author(author), date(date){}\n};\n\nvoid outputValidBooks(vector<Book> &books,string queryTitle,string queryAuthor,string queryDateFrom,string queryDateTo){\n  rep(i,books.size()){\n    Book book = books[i];\n    if( queryTitle[0]  != '*' && book.title.find(queryTitle)   == string::npos  ) continue;\n    if( queryAuthor[0] != '*' && book.author.find(queryAuthor) == string::npos ) continue;\n    Date dateFrom(queryDateFrom);\n    if( queryDateFrom[0] != '*' && !( dateFrom  <= book.date ) ) continue;\n    Date dateTo(queryDateTo);\n    if( queryDateTo[0]   != '*' && !( book.date <= dateTo )    ) continue;\n    cout << book.title << endl;\n  }\n}\n\nint main(){\n  int n,q;\n  string title,author,date;\n  vector<Book> books;\n \n  cin >> n;\n\n  rep(i,n) {\n    cin >> title >> author >> date;\n    books.push_back(Book(title,author,date));\n  }\n\n  cin >> q;\n  \n  string queryTitle,queryAuthor,queryDateFrom,queryDateTo;\n  rep(_,q){\n    if( _ ) puts(\"\");\n    cin >> queryTitle >> queryAuthor >> queryDateFrom >> queryDateTo;\n    outputValidBooks(books,queryTitle,queryAuthor,queryDateFrom,queryDateTo);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct book{\n  string n,w,t;\n\n  bool match(string a, string b, string c, string d){\n    if(a!=\"*\" && n.find(a)==string::npos)return false;\n    if(b!=\"*\" && w.find(b)==string::npos)return false;\n    if(c!=\"*\" && t<c)return false;\n    if(d!=\"*\" && d<t)return false;\n    return true;\n  }\n};\n\nint main(){\n  int n; cin >> n;\n  string a,b,c,d;\n\n  book B[100];\n  for(int i=0;i<n;i++){\n    cin >> a >> b >> c;\n    B[i].n = a; B[i].w = b; B[i].t = c;\n  }\n\n  int q; cin >> q;\n  for(int i=0;i<q;i++){\n    cin >> a >> b >> c >> d;\n    for(int j=0;j<n;j++){\n      if(B[j].match(a,b,c,d))cout << B[j].n << endl;\n    }\n    if(i<q-1)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint dtoi(string date)\n{\n  int ans=0;\n  ans =stoi(date.substr(0,4))*12*31+stoi(date.substr(5,2))*31+stoi(date.substr(8,2));\n  return ans;\n}\n\nint main()\n{\n  int n;\n  cin>>n;\n  string t[n], a[n],d[n];\n  for(int i=0;i<n;i++){\n    cin>>t[i]>>a[i]>>d[i];\n  }\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    string tt,qq,df,dt;\n    cin>>tt>>qq>>df>>dt;\n    for(int i=0;i<n;i++){\n      if(tt!=\"*\"&& t[i].find(tt)==string::npos)\n\tcontinue;\n      if(qq!=\"*\"&& a[i].find(qq)==string::npos)\n\tcontinue;\n      int d1 = dtoi(d[i]);\n      if(df!=\"*\" && d1<dtoi(df))\n\tcontinue;\n      if(dt!=\"*\" && d1>dtoi(dt))\n\tcontinue;\n      cout<<t[i]<<endl;\n    }\n    if(i!=q-1)\n      cout<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nstruct Book {\n\tstring t, a;\n\tint y, m, d;\n\tBook(string _t, string _a, int _y, int _m, int _d) : t(_t), a(_a), y(_y), m(_m), d(_d) {}\n};\n\nbool comp_date(int yy1, int mm1, int dd1, int yy2, int mm2, int dd2) {\n\tif (yy1 < yy2) return true;\n\tif (yy1 == yy2) {\n\t\tif (mm1 < mm2) return true;\n\t\tif (mm1 == mm2) {\n\t\t\tif (dd1 < dd2) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint N, Q;\nvector<Book> vb;\n\nvoid solve() {\n\tfor_(j,0,Q) {\n\t\tstring t, a, from, to; cin >> t >> a >> from >> to;\n\t\tvector<Book> sub = vb;\n\t\tvector<Book> ans;\n\t\t\n\t\tif (t == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (sub[i].t.find(t) != t.npos) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (a == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (sub[i].a.find(a) != a.npos) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (from == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint y, m, d;\n\t\t\tsscanf(from.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (comp_date(y,m,d, sub[i].y, sub[i].m, sub[i].d)) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (to == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint y, m, d;\n\t\t\tsscanf(to.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (comp_date(sub[i].y, sub[i].m, sub[i].d, y, m, d)) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tint a_size = size_of(ans);\n\t\tfor_(i,0,a_size) cout << ans[i].t << endl;\n\t\tif (j != Q - 1) cout << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) {\n\t\tstring t, a; int y, m, d;\n\t\tcin >> t >> a;\n\t\tscanf(\"%d/%d/%d\", &y, &m, &d);\n\t\tvb.push_back(Book(t, a, y, m, d));\n\t}\n\tcin >> Q;\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint parseDate(const string &s){\n  int y, m, d;\n  sscanf(s.c_str(), \"%04d/%02d/%02d\", &y, &m, &d);\n  return y * 10000 + m * 100 + d;\n}\n\nint main(){\n  const int n = getInt();\n  vector<string> title(n);\n  vector<string> auther(n);\n  vector<int> date(n);\n\n  REP(i,n){\n    string dt;\n    cin >> title[i] >> auther[i] >> dt;\n    date[i] = parseDate(dt);\n  }\n\n  const int q = getInt();\n  REP(i,q){\n    string t, a, df, dt;\n    cin >> t >> a >> df >> dt;\n\n    REP(j,n){\n      if(t != \"*\" && title[j].find(t) == string::npos) goto next;\n      if(a != \"*\" && auther[j].find(a) == string::npos) goto next;\n      if(df != \"*\" && parseDate(df) > date[j]) goto next;\n      if(dt != \"*\" && parseDate(dt) < date[j]) goto next;\n      printf(\"%s\\n\", title[j].c_str());\n      next:;\n    }\n\n    if(i != q - 1) puts(\"\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Book{\npublic:\n  string title,author;\n  int date;\n};\n\nint getDate(string &s){\n  for(int i = 0 ; i < (int)s.size() ; i++){\n    if(s[i] == '/'){\n      s[i] = ' ';\n    }\n  }\n  int y,m,d;\n  stringstream ss(s);\n  ss >> y; ss >> m; ss >> d;\n  return y*10000 + m*100 + d;\n}\n\nint main(){\n  int N;\n  string str;\n  bool blank = false;\n  cin >> N;\n  vector<Book> books(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> books[i].title >> books[i].author >> str;\n    books[i].date = getDate(str);\n  }\n  int Q;\n  cin >> Q;\n  while(Q--){\n    if(blank){ cout << endl; }\n    blank = true;\n    string s[4];\n    int S = 0;\n    for(int i = 0 ; i < 4 ; i++){\n      cin >> s[i];\n      if(s[i] == \"*\"){\n        S |= (1<<i);\n      }\n    }\n    vector<string> res;\n    for(int i = 0 ; i < N ; i++){\n      bool ok = true;\n      for(int j = 0 ; j < 4 ; j++){\n        if(S >> j & 1){ continue; }\n        if(j == 0){\n          if(books[i].title.find(s[j]) == string::npos){\n            ok = false;\n          }\n        }else if(j == 1){\n          if(books[i].author.find(s[j]) == string::npos){\n            ok = false;\n          }\n        }else if(j == 2){\n          int date = getDate(s[j]);\n          if(date > books[i].date){\n            ok = false;\n          }\n        }else{\n          int date = getDate(s[j]);\n          if(books[i].date > date){\n            ok = false;\n          }\n        }\n      }\n      if(ok){\n        res.push_back(books[i].title);\n      }\n    }\n    for(auto x : res){\n      cout << x << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#define N 100\nusing namespace std;\nint Change(string);\nint Change_2(string);\nint Search(string,string,int);\nint Check(int,string,int);\nint date[N];\nstring title[N],author[N];\nint main(){\n  int n,q,begin,end,need_check[4],r,flag,flag2,len,i,j,k;\n  string indate,q_title,q_author,q_date_from,q_date_to,out;\n  queue<string> Q;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> title[i] >> author[i] >> indate;\n    date[i]=Change(indate);\n  }\n  cin >> q;\n  flag2=0;\n  for(i=0;i<q;i++){\n    cin >> q_title >> q_author >> q_date_from >> q_date_to;\n    if(q_date_from!=\"*\") begin=Change(q_date_from);\n    if(q_date_to!=\"*\") end=Change(q_date_to);\n    for(j=0;j<n;j++){\n      for(k=0;k<4;k++) need_check[k]=0;\n      if(q_title!=\"*\"){\n\tneed_check[0]=1;\n\tr=Search(q_title,\"title\",j);\n\tif(r==1) need_check[0]=0;\n      }\n      if(q_author!=\"*\"){\n\tneed_check[1]=1;\n\tr=Search(q_author,\"author\",j);\n\tif(r==1) need_check[1]=0;\n      }\n      if(q_date_from!=\"*\"){\n\tneed_check[2]=1;\n\tr=Check(begin,\"from\",j);\n\tif(r==1) need_check[2]=0;\n      }\n      if(q_date_to!=\"*\"){\n\tneed_check[3]=1;\n\tr=Check(end,\"to\",j);\n\tif(r==1) need_check[3]=0;\n      }\n      flag=0;\n      for(k=0;k<4;k++){\n\tif(need_check[k]==1){\n\t  flag=1;\n\t  break;\n\t}\n      }\n      if(flag==0){\n\tQ.push(title[j]);\n      }\n    }\n    len=Q.size();\n    flag2=0;\n    if(Q.empty()==1) cout << endl;\n    for(j=0;j<len;j++){\n      out=Q.front();\n      Q.pop();\n      cout << out << endl;\n      flag2=1;\n    }\n    if(i!=q-1&&flag2==1) cout << endl;\n  }\n  return 0;\n}\nint Change(string s){\n  int ret;\n  string a,b,c,d;\n  a=s.substr(0,4);\n  b=s.substr(5,2);\n  c=s.substr(8,2);\n  ret=Change_2(a+b+c);\n  return ret;\n}\nint Change_2(string s){\n  int len=s.size(),ret=0,x=10,i=0;\n  while(len){\n    ret=ret*x+(s[i]-'0');\n    i++;\n    len--;\n  }\n  return ret;\n}\nint Search(string str,string c,int n){\n  int len,len2,i,j,l,flag=0,cnt=0;\n  if(c==\"title\"){\n    len=title[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      for(j=0;j<len2;j++){\n\tif(str[j]==title[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }else{\n    len=author[n].size();\n    len2=str.size();\n    for(i=0;i<len;i++){\n      l=i;\n      cnt=0;\n      for(j=0;j<len2;j++){\n\tif(str[j]==author[n][l]){\n\t  cnt++;\n\t  l++;\n\t}else{\n\t  cnt=0;\n\t}\n\tif(cnt==len2){\n\t  flag=1;\n\t  break;\n\t}\n\tif(l==len) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==1) return 1;\n  }\n  return 0;\n}\nint Check(int y,string c,int n){\n  if(c==\"from\"){\n    if(y<=date[n]) return 1;\n  }else{\n    if(y>=date[n]) return 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    return;\n}\n\nint main() {\n    for(int N;cin>>N;){\n        for(int i=0;i<N;++i){\n            string name,author,date;\n            cin>>name>>author>>date;\n            books.push_back(make_pair(name,make_pair(author,date)));\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;++i){\n            string qname,qauthor,qfrom,qto;\n            cin>>qname>>qauthor>>qfrom>>qto;\n            search_books(qname,qauthor,qfrom,qto);\n            if(i!=Q-1) cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<string, pair<string,string>>> books;\n\nvoid search_books(string qname, string qauthor, string qfrom, string qto){\n    for(int i=0;i<books.size();++i){\n        if(books[i].first.find(qname)==string::npos&&qname.at(0)!='*') continue;\n        if(books[i].second.first.find(qauthor)==string::npos&&qauthor.at(0)!='*') continue;\n        if(books[i].second.second<qfrom&&qfrom.at(0)!='*') continue;\n        if(books[i].second.second>qto&&qto.at(0)!='*') continue;\n        cout << books[i].first << endl;\n    }\n\n    return;\n}\n\nint main() {\n    for(int N;cin>>N;){\n        for(int i=0;i<N;++i){\n            string name,author,date;\n            cin>>name>>author>>date;\n            books.push_back(make_pair(name,make_pair(author,date)));\n        }\n        int Q;\n        cin>>Q;\n        for(int i=0;i<Q;++i){\n            string qname,qauthor,qfrom,qto;\n            cin>>qname>>qauthor>>qfrom>>qto;\n            search_books(qname,qauthor,qfrom,qto);\n            if(i!=Q-1) cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct book{\n  string name,auth,date;\n\n  bool match(string a, string b, string c, string d){\n    if(a!=\"*\" && name.find(a)==string::npos)return false;\n    if(b!=\"*\" && auth.find(b)==string::npos)return false;\n    if(c!=\"*\" && date<c)return false;\n    if(d!=\"*\" && d<date)return false;\n    return true;\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<book> B(n);\n  for(int i=0;i<n;i++){\n    string a,b,c;\n    cin >> a >> b >> c;\n    B[i].name = a; B[i].auth = b; B[i].date = c;\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    string a,b,c,d;\n    cin >> a >> b >> c >> d;\n    for(int j=0;j<n;j++){\n      if(B[j].match(a,b,c,d))cout << B[j].name << endl;\n    }\n    cout << \" \\n\"[i+1==q];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint n, m;\n\tcin >> n;\n\tvector<pair<pair<string, string>, int> > v(n);\n\tfor(int i=0; i< n; i++){\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tint a, b, c;\n\t\tscanf(\"%d/%d/%d\", &a, &b, &c);\n\t\ta = a*10000 + b*100 + c;\n\t\tv[i].second = a;\n\t}\n\tcin >> m;\n\tfor(int i=0; i< m; i++){\n\t\tif(i != 0) cout << endl;\n\t\tstring a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint cc = -1, dd = -1;\n\t\tif(c != \"*\") cc = stoi(c.substr(0, 4))*10000 + stoi(c.substr(5, 2))*100 + stoi(c.substr(8, 2));\n\t\tif(d != \"*\") dd = stoi(d.substr(0, 4))*10000 + stoi(d.substr(5, 2))*100 + stoi(d.substr(8, 2));\n\t\tfor(int j=0; j < n; j++){\n\t\t\tif((a == \"*\" || v[j].first.first.find(a) != string::npos) &&\n\t\t\t\t\t(b == \"*\" || v[j].first.second.find(b) != string::npos) &&\n\t\t\t\t\t(c == \"*\" || cc <= v[j].second) &&\n\t\t\t\t\t(d == \"*\" || v[j].second <= dd)) cout << v[j].first.first << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint parseDate(const string &s){\n  int y, m, d;\n  sscanf(s.c_str(), \"%04d/%02d%02d\", &y, &m, &d);\n  return y * 1000000 + m * 10 + d;\n}\n\nint main(){\n  const int n = getInt();\n  vector<string> title(n);\n  vector<string> auther(n);\n  vector<int> date(n);\n\n  REP(i,n){\n    string dt; \n    cin >> title[i] >> auther[i] >> dt;\n    date[i] = parseDate(dt);\n  }\n\n  const int q = getInt();\n  REP(i,q){\n    string t, a, df, dt;\n    cin >> t >> a >> df >> dt;\n\n    REP(j,n){\n      if(t != \"*\" && title[j].find(t) == string::npos) goto next;\n      if(a != \"*\" && auther[j].find(a) == string::npos) goto next;\n      if(df != \"*\" && parseDate(df) > date[j]) goto next;\n      if(dt != \"*\" && parseDate(dt) < date[j]) goto next;\n      printf(\"%s\\n\", title[j].c_str());\n      next:;\n    }\n\n    puts(\"\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n//\t\trep (i, search[2].size() ) disp_book (search[2][i] );\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from < curr && curr <= to ) res.push_back (search[2][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include<cstdio>\n#define repi(i,x,n) for(int i = x; i < n; i++)\n#define rep(i,n) repi(i,0,n)\n#define int long long\nusing namespace std;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\n\nstruct info{\n    string title, author;\n    pair<int,pair<int,int>> from, to;\n    \n};\nbool check(string a, string b){\n    for(int i = 0; i <(int)b.size() - (int)a.size()+1; i++){\n        bool flag = true;\n        // cout<<\"i = \"<<i<<\" \"<<b[i]<<\"  {}{} \"<<b.size() - a.size() +1<<endl;\n        for(int j = 0; j < a.size(); j++){\n            if(b[i+j] != a[j]){\n                // cout<<i<<\" \"<<j<<\" \"<<b[i+j]<<\" \"<<a[j]<<endl;\n                flag = false;\n                break;\n            }\n        }\n        if(flag) return true;\n    }\n\n    return false;\n}\n\nsigned main()\n{\n    // cin.tie(0);\n    //ios::sync_with_stdio(false);\n\n    int N, Q;\n\n    vector<info> in;\n\n    cin>>N;\n\n    in.resize(N);\n\n    for(int i = 0; i < N; i++){\n        string a;\n        cin>>in[i].title>>in[i].author>>a;\n        // if(a != \"*\"){\n            in[i].to.first = stoi(a.substr(0,4));\n            in[i].to.second.first =  stoi(a.substr(5,2));\n            in[i].to.second.second =  stoi(a.substr(8,2));\n            // } else in[i].from.first = -INF;\n            //if(b != \"*\"){\n            //cout<<in[i].from.first<<\" \"<<in[i].from.second.first<<\" \"<<in[i].from.second.second<<endl;\n            //in[i].to.first = stoi(b.substr(0,4));\n            //in[i].to.second.first =  stoi(b.substr(5,2));\n            //in[i].to.second.second =  stoi(b.substr(8,2));\n            // } else in[i].to.first = INF;\n        //scanf(\"%ld %ld %ld\", &in[i].from.first, &in[i].from.second.first, &in[i].from.second.second);\n        //scanf(\"%ld/%ld/%ld\", &in[i].from.first, &in[i].from.second.first, &in[i].from.second.second);\n    }\n\n    cin>>Q;\n\n    for(int i = 0; i < Q; i++){\n        info q;\n        string a, b;\n        //cout<<\"i = \"<<i<<endl;\n        cin>>q.title>>q.author>>a>>b;\n        \n         if(a != \"*\"){\n            q.from.first = stoi(a.substr(0,4));\n            q.from.second.first =  stoi(a.substr(5,2));\n            q.from.second.second =  stoi(a.substr(8,2));\n            \n        } else q.from.first = -INF;\n         \n        if(b != \"*\"){\n            q.to.first = stoi(b.substr(0,4));\n            q.to.second.first =  stoi(b.substr(5,2));\n            q.to.second.second =  stoi(b.substr(8,2));\n        } else q.to.first = INF;\n        \n        for(int j = 0; j < N; j++){\n            //  cout<<\"j = \"<<j<<endl;\n            if(q.title != \"*\" && !check(q.title,in[j].title)) continue;\n            // cout<<\"w\"<<\" \"<<q.title<<\" \"<<in[j].title<<endl;\n\n            if(q.author != \"*\" && !check(q.author,in[j].author)) continue;\n            \n\n            // cout<<\"x \"<<q.author<<\" \"<<in[j].author<<endl;\n            //if(q.from > in[j].to) continue;\n            // cout<<\"Y\"<<endl;\n            //if(q.to < in[j].to) continue;\n\n            if(!(q.from <= in[j].to && in[j].to <= q.to)) continue;\n\n            cout<<in[j].title<<endl;\n        }\n        if(i != Q-1) cout<<endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <tuple>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define DECIM8  fixed<<setprecision(8) \n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nbool suitstr(string str,string query)\n{\n  if(query==\"*\") return true;\n  REP(i,SZ(str)-SZ(query)+1)\n    if(query==string(str.begin()+i,str.begin()+i+SZ(query)))\n      return true;\n  return false;\n}\nint main(void)\n{\n  int n,q;\n  string book[128][3];\n  const int title=0,auther=1,date=2;\n  cin >> n;\n  REP(i,n) REP(j,3)\n    cin >> book[i][j];\n  cin >> q;\n  REP(i,q){\n    if(i) cout << endl;\n    string qtitle,qauther,qdate[2];\n    cin >> qtitle >> qauther >> qdate[0] >> qdate[1];\n    REP(j,n){\n      if(suitstr(book[j][title],qtitle)\n\t && suitstr(book[j][auther],qauther)\n\t && (qdate[0] <= book[j][date] || qdate[0] == \"*\")\n\t && (book[j][date] <= qdate[1] || qdate[1] == \"*\"))\n\tcout << book[j][title] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MAX_N 100000\nint N, Q; vector<int>vec, vec2;\nstring S[MAX_N][3], T[4];\nbool Find(string U, string V) {\n\tint X = U.size(), Y = V.size();\n\tfor (int i = 0; i <= X - Y; i++) {\n\t\tstring W = U.substr(i, Y);\n\t\tif (W == V) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> S[i][0] >> S[i][1] >> S[i][2];\n\t}\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tcin >> T[0] >> T[1] >> T[2] >> T[3];\n\t\tvec.clear(); vec2.clear();\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tvec.push_back(j);\n\t\t}\n\t\tvec2 = vec;\n\t\tif (T[0] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (Find(S[vec[j]][0], T[0]) == true) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2;\n\t\tif (T[1] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (Find(S[vec[j]][1], T[1]) == true) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2;\n\t\tif (T[2] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (S[j][2] >= T[2]) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2;\n\t\tif (T[3] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (S[j][2] <= T[3]) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2; vec2.clear();\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tcout << S[vec[j]][0] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define loop(i,a,b) for(ll i=(a);i<ll(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nbool match(vector<string> b, vector<string> q){\n    auto np = string::npos;\n    if(q[0] != \"*\" && b[0].find(q[0]) == np) return false;\n    if(q[1] != \"*\" && b[1].find(q[1]) == np) return false;\n    if(q[2] != \"*\" && q[2] > b[2]) return false;\n    if(q[3] != \"*\" && q[3] < b[2]) return false;\n    return true;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<vector<string>> bs(n,{\"\",\"\",\"\",\"\"});\n    rep(i,n)rep(j,3) cin >> bs[i][j];\n    int q;\n    cin >> q;\n    rep(i,q){\n        vector<string> qq(4);\n        rep(j,4) cin >> qq[j];\n        rep(j,n){\n            if(match(bs[j],qq)){\n                cout << bs[j][0] << endl;\n            }\n        }\n        if(i!=q-1) cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\t\t//\t1,   2,   3,  4,   5,   6,  7,  8,   9, 10,  11, 12\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\n\tll res = 0LL;\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365LL*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[4];\n\t\trep (k, 4 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n\t\tll from = calc_date (q_date_from );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from < curr  ) search[3].push_back (search[2][i] );\n\t\t} // end rep\n\n\t\tll to   = calc_date (q_date_to );\n\t\trep (i, search[3].size() ){\n\t\t\tll curr = search[3][i].datenum;\n\t\t\tif (curr <= to  ) res.push_back (search[3][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nstruct Book {\n\tstring t, a;\n\tint y, m, d;\n\tBook(string _t, string _a, int _y, int _m, int _d) : t(_t), a(_a), y(_y), m(_m), d(_d) {}\n};\n\nbool comp_date(int yy1, int mm1, int dd1, int yy2, int mm2, int dd2) {\n\tif (yy1 <= yy2) return true;\n\tif (yy1 == yy2) {\n\t\tif (mm1 <= mm2) return true;\n\t\tif (mm1 == mm2) {\n\t\t\tif (dd1 <= dd2) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint N, Q;\nvector<Book> vb;\n\nvoid solve() {\n\tfor_(j,0,Q) {\n\t\tstring t, a, from, to; cin >> t >> a >> from >> to;\n\t\tvector<Book> sub = vb;\n\t\tvector<Book> ans;\n\t\t\n\t\tif (t == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (sub[i].t.find(t) != t.npos) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (a == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (sub[i].a.find(a) != a.npos) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (from == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint y, m, d;\n\t\t\tsscanf(from.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (comp_date(y,m,d, sub[i].y, sub[i].m, sub[i].d)) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (to == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint y, m, d;\n\t\t\tsscanf(to.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (comp_date(sub[i].y, sub[i].m, sub[i].d, y, m, d)) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tint a_size = size_of(ans);\n\t\tfor_(i,0,a_size) cout << ans[i].t << endl;\n\t\tif (j != Q - 1) cout << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) {\n\t\tstring t, a; int y, m, d;\n\t\tcin >> t >> a;\n\t\tscanf(\"%d/%d/%d\", &y, &m, &d);\n\t\tvb.push_back(Book(t, a, y, m, d));\n\t}\n\tcin >> Q;\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\ntypedef struct book{\n    string title,auth,date;\n} bk;\n\nvector<string> split(string s,char ch){\n    vector<string> ret;\n    string tmp =\"\";\n    rep(i,s.size()){\n        if(s[i]==ch){\n            ret.pb(tmp);\n            tmp = \"\";\n        }else tmp+=s[i];\n    }\n    if(tmp.size())ret.pb(tmp);\n    return ret;\n}\n\n//????????????0\n//a?????\\????????????????????????1???\n//a?????\\????????????????????????-1?????????\nint ymdcompare(string a,string b){\n    vector<string> A[2];\n    A[0] = split(a,'/');\n    A[1] = split(b,'/');\n    int ymd[2][3];\n    rep(i,2)rep(j,3)ymd[i][j]=stoi(A[i][j]);\n    \n    rep(i,3){\n        if(ymd[0][i]>ymd[1][i])return -1;\n        if(ymd[0][i]>ymd[1][i])return  1;\n    }\n    \n    return 0;\n}\n\n\nbool is(bk data,string title,string auth,string from,string to){\n    if(title!=\"*\"   && data.title.find(title)==string::npos)return false;\n\n    if(auth!=\"*\"    && data.auth.find(auth)==string::npos)  return false;\n\n    if(from!=\"*\"    && ymdcompare(from,data.date)==-1)      return false;\n\n    if(to!=\"*\"      && ymdcompare(to,data.date)==1)         return false;\n\n    return true;\n}\n\nint main(){\n    \n    int n;\n    cin>>n;\n    vector<bk> data;\n    \n    rep(i,n){\n        string a,b,c;\n        cin>>a>>b>>c;\n        data.pb(bk{a,b,c});\n    }\n    \n    int q;\n    cin>>q;\n    rep(i,q){\n        string title,auth,from,to;\n        cin>>title>>auth>>from>>to;\n        \n        vector<string> t;\n        rep(j,n){\n            if(is(data[j],title,auth,from,to))t.pb(data[j].title);\n        }\n        \n        rep(i,t.size())cout<<t[i]<<endl;\n        if(i!=q-1)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int> Date;\n\nstruct book {\n\tstring title, author;\n\tDate date;\n\n\tbook(const string &title_, const string &author_, const Date &date_):title(title_), author(author_), date(date_) {}\n\tbool match(const string &q_title, const string &q_author, const Date &from, const Date &to) const {\n\t\tif(title.find(q_title) == string::npos) return false;\n\t\tif(author.find(q_author) == string::npos) return false;\n\t\tif(date < from) return false;\n\t\tif(to < date) return false;\n\t\treturn true;\n\t}\n};\n\nDate string_to_date(const string &s) {\n\tint y, m, d;\n\tsscanf(s.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\treturn Date(y, m, d);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<book> books;\n\tbooks.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tstring title, author, date;\n\t\tcin >> title >> author >> date;\n\t\tbooks.emplace_back(title, author, string_to_date(date));\n\t}\n\n\tint q;\n\tcin >> q;\n\n\twhile(true) {\n\t\tstring q_title, q_author, q_date_from, q_date_to;\n\t\tcin >> q_title >> q_author >> q_date_from >> q_date_to;\n\n\t\tif(q_title == \"*\") q_title = \"\";\n\t\tif(q_author == \"*\") q_author = \"\";\n\n\t\tconst Date from = (q_date_from == \"*\" ? Date(0, 0, 0) : string_to_date(q_date_from));\n\t\tconst Date to = (q_date_to == \"*\" ? Date(10000, 0, 0) : string_to_date(q_date_to));\n\n\t\tfor(const auto &book : books) {\n\t\t\tif(book.match(q_title, q_author, from, to)) {\n\t\t\t\tcout << book.title << '\\n';\n\t\t\t}\n\t\t}\n\n\t\tif(--q) {\n\t\t\tcout << '\\n';\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring title[102], author[102], dt[102];\n\nint main() {\n  int n;\n\n  while (cin >> n) {\n    for (int i = 0; i < n; i++) {\n      cin >> title[i] >> author[i] >> dt[i];\n    }\n    int q;\n    cin >> q;\n    for (int QUERY = 1; QUERY <= q; QUERY++) {\n      if (QUERY != 1) {\n        cout << endl;\n      }\n      string qt, qa, qd_from, qd_to;\n      cin >> qt >> qa >> qd_from >> qd_to;\n      for (int i = 0; i < n; i++) {\n        if ((qt == \"*\" || title[i].find(qt) != string::npos) &&\n            (qa == \"*\" || author[i].find(qa) != string::npos) &&\n            (qd_from == \"*\" || qd_from <= dt[i]) &&\n            (qd_to == \"*\" || qd_to >= dt[i])) {\n          cout << title[i] << endl;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, m, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\telse { W = S; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(k, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok == true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\ntypedef struct book{\n    string title,auth,date;\n} bk;\n\nvector<string> split(string s,char ch){\n    vector<string> ret;\n    string tmp =\"\";\n    rep(i,s.size()){\n        if(s[i]==ch){\n            ret.pb(tmp);\n            tmp = \"\";\n        }else tmp+=s[i];\n    }\n    if(tmp.size())ret.pb(tmp);\n    return ret;\n}\n\n//????????????0\n//a?????\\????????????????????????1???\n//a?????\\????????????????????????-1?????????\nint ymdcompare(string a,string b){\n    vector<string> A[2];\n    A[0] = split(a,'/');\n    A[1] = split(a,'/');\n    int ymd[2][3];\n    rep(i,2)rep(j,3)ymd[i][j]=stoi(A[i][j]);\n    \n    rep(i,3){\n        if(ymd[0][i]>ymd[1][i])return -1;\n        if(ymd[0][i]>ymd[1][i])return  1;\n    }\n    \n    return 0;\n}\n\n\nbool is(bk data,string title,string auth,string from,string to){\n    if(title!=\"*\"   && data.title.find(title)==string::npos)return false;\n\n    if(auth!=\"*\"    && data.auth.find(auth)==string::npos)  return false;\n\n    if(from!=\"*\"    && ymdcompare(from,data.date)==-1)      return false;\n\n    if(to!=\"*\"      && ymdcompare(to,data.date)==1)         return false;\n\n    return true;\n}\n\nint main(){\n    \n    int n;\n    cin>>n;\n    vector<bk> data;\n    \n    rep(i,n){\n        string a,b,c;\n        cin>>a>>b>>c;\n        data.pb(bk{a,b,c});\n    }\n    \n    int q;\n    cin>>q;\n    rep(i,q){\n        string title,auth,from,to;\n        cin>>title>>auth>>from>>to;\n        \n        vector<string> t;\n        rep(j,n){\n            if(is(data[j],title,auth,from,to))t.pb(data[j].title);\n        }\n        \n        rep(i,t.size())cout<<t[i]<<endl;\n        if(i!=q-1)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nstruct Book {\n\tstring t, a;\n\tint y, m, d;\n\tBook(string _t, string _a, int _y, int _m, int _d) : t(_t), a(_a), y(_y), m(_m), d(_d) {}\n};\n\nbool comp_date(int yy1, int mm1, int dd1, int yy2, int mm2, int dd2) {\n\tif (yy1 > yy2) return false;\n\tif (yy1 == yy2) {\n\t\tif (mm1 > mm2) return false;\n\t\tif (mm1 == mm2) {\n\t\t\tif (dd1 > dd2) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint N, Q;\nvector<Book> vb;\n\nvoid solve() {\n\tfor_(j,0,Q) {\n\t\tstring t, a, from, to; cin >> t >> a >> from >> to;\n\t\tvector<Book> sub = vb;\n\t\tvector<Book> ans;\n\t\t\n\t\tif (t == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (sub[i].t.find(t) != t.npos) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (a == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (sub[i].a.find(a) != a.npos) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (from == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint y, m, d;\n\t\t\tsscanf(from.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (comp_date(y,m,d, sub[i].y, sub[i].m, sub[i].d)) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tif (to == \"*\") {\n\t\t\tans = sub;\n\t\t\tsub = ans;\n\t\t} else {\n\t\t\tint y, m, d;\n\t\t\tsscanf(to.c_str(), \"%d/%d/%d\", &y, &m, &d);\n\t\t\tint s_size = size_of(sub);\n\t\t\tfor_(i,0,s_size) {\n\t\t\t\tif (comp_date(sub[i].y, sub[i].m, sub[i].d, y, m, d)) ans.push_back(sub[i]);\n\t\t\t}\n\t\t\tsub = ans;\n\t\t}\n\t\t\n\t\tint a_size = size_of(ans);\n\t\tfor_(i,0,a_size) cout << ans[i].t << endl;\n\t\tif (j != Q - 1) cout << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) {\n\t\tstring t, a; int y, m, d;\n\t\tcin >> t >> a;\n\t\tscanf(\"%d/%d/%d\", &y, &m, &d);\n\t\tvb.push_back(Book(t, a, y, m, d));\n\t}\n\tcin >> Q;\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\ntypedef struct book{\n    string title,auth,date;\n} bk;\n\nvector<string> split(string s,char ch){\n    vector<string> ret;\n    string tmp =\"\";\n    rep(i,s.size()){\n        if(s[i]==ch){\n            ret.pb(tmp);\n            tmp = \"\";\n        }else tmp+=s[i];\n    }\n    if(tmp.size())ret.pb(tmp);\n    return ret;\n}\n\n//  aaa???bbb???????????? -> 1\n//  aaa???bbb???????????? -> -1\n//  aaa??¨bbb????????? -> 0\nint comp(string aaa,string bbb){\n    if(aaa==bbb)return 0;\n    vector<string> a = split(aaa,'/');\n    vector<string> b = split(bbb,'/');\n    \n    if(stoi(a[0])>stoi(b[0]))return -1;\n    if(stoi(a[1])>stoi(b[1]))return -1;\n    if(stoi(a[2])>stoi(b[2]))return -1;\n    \n    return 1;\n    \n}\n\n\nbool is(bk data,string title,string auth,string from,string to){\n    if(title!=\"*\" && data.title.find(title)==string::npos)return false;\n\n    if(auth!=\"*\" && data.auth.find(auth)==string::npos)return false;\n\n    if(from!=\"*\" && comp(from,data.date)==-1)return false;\n\n    if(to!=\"*\" && comp(to,data.date)==1)return false;\n\n    return true;\n}\n\nint main(){\n    \n    int n;\n    cin>>n;\n    vector<bk> data;\n    \n    rep(i,n){\n        string a,b,c;\n        cin>>a>>b>>c;\n        data.pb(bk{a,b,c});\n    }\n    \n    int q;\n    cin>>q;\n    rep(i,q){\n        string title,auth,from,to;\n        cin>>title>>auth>>from>>to;\n        \n        vector<string> t;\n        rep(j,n){\n            if(is(data[j],title,auth,from,to))t.pb(data[j].title);\n        }\n        \n        rep(i,t.size())cout<<t[i]<<endl;\n        if(i!=q-1)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\nbool find(string s,string f){\n\tREP(i,s.size())\n\t\tREP(j,f.size())\n\t\t\tif(i+j>=s.size() || s[i+j]!=f[j])\n\t\t\tbreak;\n\t\t\telse if(j==f.size()-1)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main() {\n\tstring books[101][3],query[4];\n\tint N,Q;\n\tcin >> N ;\n\tREP(i,N)\n\t\tREP(j,3)\n\t\t\tcin >> books[i][j];\n\tcin >> Q;\n\tREP(i,Q){\n\t\tREP(j,4)\n\t\t\tcin >> query[j];\n\t\tREP(j,N){\n\t\t\tbool ans=true;\n\t\t\tREP(k,4){\n\t\t\t\tif(query[k]==\"*\")\n\t\t\t\tcontinue;\n\t\t\t\tif(k<=1)\n\t\t\t\t\tif(!find(books[j][k],query[k]))\n\t\t\t\t\tans=false;\n\t\t\t\tif(k==2)\n\t\t\t\t\tif(!(query[k]<=books[j][2]))\n\t\t\t\t\tans=false;\n\t\t\t\tif(k==3)\n\t\t\t\t\tif(!(query[k]>=books[j][2]))\n\t\t\t\t\tans=false;\n\t\t\t}\n\t\t\tif(ans)\n\t\t\tcout << books[j][0] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\n#pragma warning(disable:4996)\n\n#define MAX_N 10000\n\nint n, a1, a2, a3;\nstring a[MAX_N], b[MAX_N];int c[MAX_N];\nstring S, T, U, V, W;\nbool ok, ok1, ok2, ok3, ok4;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tscanf(\"%04d/%04d/%04d\", &a1, &a2, &a3);\n\t\tc[i] = a1 * 10000 + a2 * 100 + a3;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tok = false;\n\t\tcin >> S >> T >> U >> V;\n\t\tif (S == \"*\") { W = \"\"; }\n\t\tif (U == \"*\") { a1 = 0; }\n\t\tif (V == \"*\") { a2 = 1 << 30; }\n\t\tif (T == \"*\") { ok = true; }\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tok1 = false; ok2 = false; ok3 = false; ok4 = false;\n\t\t\tif (W != \"\") {\n\t\t\t\tfor (int k = 0; k <= a[j].size() - W.size(); k++) {\n\t\t\t\t\tif (a[j].substr(i, W.size()) == W) {\n\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok1 = true;\n\t\t\t}\n\t\t\tif (ok = true) { ok2 = true; }\n\t\t\telse {\n\t\t\t\tif (T == b[j]) {\n\t\t\t\t\tok2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U != \"*\") {\n\t\t\t\ta1 = stoi(U.substr(0, 4)) * 10000 + stoi(U.substr(5, 2)) * 100 + stoi(U.substr(8, 2));\n\t\t\t}\n\t\t\tif (V != \"*\") {\n\t\t\t\ta2 = stoi(V.substr(0, 4)) * 10000 + stoi(V.substr(5, 2)) * 100 + stoi(V.substr(8, 2));\n\t\t\t}\n\t\t\tif (a1 <= c[j] && c[j] <= a2) {\n\t\t\t\tok3 = true;\n\t\t\t}\n\t\t\tif (ok1 == true && ok2 == true && ok3 == true) {\n\t\t\t\tcout << a[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nstruct book{\n    string t, a;\n    int y,m,d;\n};\nvector<book>vec;\nint main(){\n    int n;\n    string t,a,d,qt,qa,qd1,qd2;\n    cin>>n;\n    while(n--){\n        int ty=0,tm=0,td=0,i;\n        cin>>t>>a>>d;\n        book b;\n        b.t=t;\n        b.a=a;\n        for(i=0;i<4;i++)\n            ty=ty*10+d[i]-'0';\n        for(i=5;i<7;i++)\n            tm=tm*10+d[i]-'0';\n        for(i=8;i<10;i++)\n            td=td*10+d[i]-'0';\n        b.y=ty,b.m=tm,b.d=td;\n        vec.push_back(b);\n    }\n    cin>>n;\n    while(n--){\n        string q1,q2,q3,q4;\n        cin>>q1>>q2>>q3>>q4;\n        int ty1=0,tm1=0,td1=0,ty2=0,tm2=0,td2=0,i;\n        if(q3!=\"*\"){\n            for(i=0;i<4;i++)\n                ty1=ty1*10+q3[i]-'0';\n            for(i=5;i<7;i++)\n                tm1=tm1*10+q3[i]-'0';\n            for(i=8;i<10;i++)\n                td1=td1*10+q3[i]-'0';\n        }\n        if(q4!=\"*\"){\n            for(i=0;i<4;i++)\n                ty2=ty2*10+q4[i]-'0';\n            for(i=5;i<7;i++)\n                tm2=tm2*10+q4[i]-'0';\n            for(i=8;i<10;i++)\n                td2=td2*10+q4[i]-'0';\n        }\n        else{\n            ty2=3000,tm2=50,td2=50;\n        }\n        for(int i=0;i<vec.size();i++){\n            if ((q1!=\"*\" && vec[i].t.find(q1)==string::npos)||\n                (q2!=\"*\" && vec[i].a.find(q2)==string::npos))\n                continue;\n            if((vec[i].y>ty1||(vec[i].y==ty1&&(vec[i].m>tm1||(vec[i].m==tm1&&vec[i].d>=td1))))&&\n               (vec[i].y<ty2||(vec[i].y==ty2&&(vec[i].m<tm2||(vec[i].m==tm2&&vec[i].d<=td2))))){\n                cout<<vec[i].t<<endl;\n            }\n        }\n        if(n>0)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <cstdlib>\n\nusing namespace std;\ntypedef tuple<string, string, int> tssi;\n\nint read_date(){\n\tstring head;\n\tcin >> head;\n\tif(head == \"*\"){ return -1; }\n\tistringstream iss(head);\n\tint y, m, d;\n\tiss >> y; iss.ignore();\n\tiss >> m; iss.ignore();\n\tiss >> d;\n\treturn y * 10000 + m * 100 + d;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<tssi> books(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tstring title, author;\n\t\tcin >> title >> author;\n\t\tconst int date = read_date();\n\t\tbooks[i] = tssi(title, author, date);\n\t}\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tstring title, author;\n\t\tcin >> title >> author;\n\t\tint from = read_date();\n\t\tint to = read_date();\n\t\tif(from < 0){ from = 0; }\n\t\tif(to < 0){ to = 1000000000; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(title != \"*\" && get<0>(books[i]).find(title) == string::npos){ continue; }\n\t\t\tif(author != \"*\" && get<1>(books[i]).find(author) == string::npos){ continue; }\n\t\t\tif(from <= get<2>(books[i]) && get<2>(books[i]) <= to){\n\t\t\t\tcout << get<0>(books[i]) << endl;\n\t\t\t}\n\t\t}\n\t\tif(q != 0){ cout << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nstruct Book {\n  string title,author;\n  string date;\n  void in() {\n    cin >> title >> author >> date;\n    // int y,m,d;\n    // scanf(\"%d:%d:%d\", &y, &m, &d);\n    // date = (ll)y*12*31 + (m-1)*31 + (d-1);\n  }\n} book[100];\nbool contain(const string &s, const string&t) {\n  for (int i=0; i<=(int)s.size()-(int)t.size(); ++i) {\n    if (s.substr(i,t.size()) == t) return 1;\n  }\n  return 0;\n}\nint main() {\n  int n;\n  while(cin>>n) {\n    REP(i,n) {\n      book[i].in();\n    }\n    int q;\n    cin >> q;\n    REP(i,q) {\n      string title, author, from, to;\n      cin >> title >> author >> from >> to;\n      if (i) cout << endl;\n      REP(j,n) {\n        if ((title == \"*\" || contain(book[j].title,title)) &&\n            (author == \"*\" || contain(book[j].author,author)) &&\n            (from == \"*\" || from <= book[j].date) &&\n            (to == \"*\" || to >= book[j].date)) {\n          cout << book[j].title << endl;\n            }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Date\n{\n    int year,month,day;\n\n    Date(){}\n    Date(string s)\n    {\n        year=atoi(s.substr(0,4).c_str());\n        month=atoi(s.substr(5,2).c_str());\n        day=atoi(s.substr(8,2).c_str());\n    }\n\n    int releasedAfter(Date b)\n    {\n        if(year>b.year) return 1;\n        else if(year==b.year)\n        {\n            if(month>b.month) return 1;\n            else if(month==b.month)\n            {\n                if(day>=b.day) return 1;\n            }\n        }\n        return 0;\n    }\n\n    int releasedBefore(Date b)\n    {\n        if(year<b.year) return 1;\n        else if(year==b.year)\n        {\n            if(month<b.month) return 1;\n            else if(month==b.month)\n            {\n                if(day<=b.day) return 1;\n            }\n        }\n        return 0;\n    }\n};\n\nstruct Book\n{\n    string title,author;\n    Date date;\n\n    Book(){}\n    Book(string a, string b, Date c)\n    {\n        title=a;\n        author=b;\n        date=c;\n    }\n\n    int searchString(string q, string s)\n    {\n        int Q=q.size(), S=s.size();\n\n        rep(i,S-Q+1)\n        {\n            if(s.substr(i,Q)==q) return 1;\n        }\n        return 0;\n    }\n\n    int includeTitle(string q)\n    {\n        return searchString(q,title);\n    }\n    int includeAuthor(string q)\n    {\n        return searchString(q,author);\n    }\n    int releasedBefore(Date q)\n    {\n        return date.releasedBefore(q);\n    }\n    int releasedAfter(Date q)\n    {\n        return date.releasedAfter(q);\n    }\n};\n\nint main()\n{\n    int n;\n    cin >>n;\n\n    vector<Book> b(n);\n    rep(i,n)\n    {\n        string x,y,z;\n        cin >>x >>y >>z;\n        b[i]=Book(x,y,Date(z));\n    }\n\n    int Q;\n    cin >>Q;\n    rep(q,Q)\n    {\n        string t,a,from,to;\n        cin >>t >>a >>from >>to;\n\n        vector<int> ok(n,1);\n        rep(i,n)\n        {\n            if(t!=\"*\") ok[i]&=b[i].includeTitle(t);\n            if(a!=\"*\") ok[i]&=b[i].includeAuthor(a);\n            if(from!=\"*\") ok[i]&=b[i].releasedAfter(Date(from));\n            if(to!=\"*\") ok[i]&=b[i].releasedBefore(Date(to));\n        }\n\n        if(q) printf(\"\\n\");\n        rep(i,n) if(ok[i]) cout << b[i].title << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\ntypedef struct book{\n    string title,auth,date;\n} bk;\n\nvector<string> split(string s,char ch){\n    vector<string> ret;\n    string tmp =\"\";\n    rep(i,s.size()){\n        if(s[i]==ch){\n            ret.pb(tmp);\n            tmp = \"\";\n        }else tmp+=s[i];\n    }\n    if(tmp.size())ret.pb(tmp);\n    return ret;\n}\n\n//  aaa???bbb???????????? -> 1\n//  aaa???bbb???????????? -> -1\n//  aaa??¨bbb????????? -> 0\nint comp(string aaa,string bbb){\n    if(aaa==bbb)return 0;\n    vector<string> a = split(aaa,'/');\n    vector<string> b = split(bbb,'/');\n    \n    if(stoi(a[0])>stoi(b[0]))return -1;\n    if(stoi(a[0])<stoi(b[0]))return 1;\n    \n    if(stoi(a[1])>stoi(b[1]))return -1;\n    if(stoi(a[1])<stoi(b[1]))return 1;\n    \n    if(stoi(a[2])>stoi(b[2]))return -1;\n    else return 1;\n    \n}\n\n\nbool is(bk data,string title,string auth,string from,string to){\n    if(title!=\"*\" && data.title.find(title)==string::npos)return false;\n\n    if(auth!=\"*\" && data.auth.find(auth)==string::npos)return false;\n\n    if(from!=\"*\" && comp(from,data.date)==-1)return false;\n\n    if(to!=\"*\" && comp(to,data.date)==1)return false;\n\n    return true;\n}\n\nint main(){\n    \n    int n;\n    cin>>n;\n    vector<bk> data;\n    \n    rep(i,n){\n        string a,b,c;\n        cin>>a>>b>>c;\n        data.pb(bk{a,b,c});\n    }\n    \n    int q;\n    cin>>q;\n    rep(i,q){\n        string title,auth,from,to;\n        cin>>title>>auth>>from>>to;\n        \n        vector<string> t;\n        rep(j,n){\n            if(is(data[j],title,auth,from,to))t.pb(data[j].title);\n        }\n        \n        rep(i,t.size())cout<<t[i]<<endl;\n        if(i!=q-1)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct book{\n  string name,auth,date;\n\n  bool match(string a, string b, string c, string d){\n    if(a!=\"*\" && name.find(a)==string::npos)return false;\n    if(b!=\"*\" && auth.find(b)==string::npos)return false;\n    if(c!=\"*\" && date<c)return false;\n    if(d!=\"*\" && d<date)return false;\n    return true;\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<book> B(n);\n  for(int i=0;i<n;i++){\n    string a,b,c;\n    cin >> a >> b >> c;\n    B[i].name = a; B[i].auth = b; B[i].date = c;\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    string a,b,c,d;\n    cin >> a >> b >> c >> d;\n    for(int j=0;j<n;j++){\n      if(B[j].match(a,b,c,d))cout << B[j].name << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n,q;\nstring tit[111],date[111],name[111];\n\nbool ok1(string a,string b){\n  if(b==\"*\")return 1;\n  r(i,a.size()){\n    if(i+(int)b.size()>a.size())return 0;\n    int f=0;\n    r(j,b.size()){\n      if(a[i+j]!=b[j])f=1;\n    }\n    if(!f)return 1;\n  }\n  return 0;\n}\n\nbool ok3(string a,string b,string c){\n  if(b==\"*\"&&c==\"*\")return 1;\n  else if(b==\"*\"){\n    return a<=c;\n  }\n  else if(c==\"*\"){\n    return b<=a;\n  }\n  else{\n    return b<=a && a<=c;\n  }\n}\n\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>tit[i];\n    cin>>name[i];\n    cin>>date[i];\n  }\n  cin>>q;\n  r(jj,q){\n    string a,b,c,d;\n    cin>>a>>b>>c>>d;\n    r(i,n){\n      if(!ok1(tit[i],a))continue;\n      if(!ok1(name[i],b))continue;\n      if(!ok3(date[i],c,d))continue;\n      cout<<tit[i]<<endl;\n    }\n    if(jj!=q-1)cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MAX_N 100000\nint N, Q; vector<int>vec, vec2;\nstring S[MAX_N][3], T[4];\nbool Find(string U, string V) {\n\tint X = U.size(), Y = V.size();\n\tfor (int i = 0; i <= X - Y; i++) {\n\t\tstring W = U.substr(i, Y);\n\t\tif (W == V) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> S[i][0] >> S[i][1] >> S[i][2];\n\t}\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tif (i >= 1) { cout << endl; }\n\t\tcin >> T[0] >> T[1] >> T[2] >> T[3];\n\t\tvec.clear(); vec2.clear();\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tvec.push_back(j);\n\t\t}\n\t\tvec2 = vec;\n\t\tif (T[0] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (Find(S[vec[j]][0], T[0]) == true) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2;\n\t\tif (T[1] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (Find(S[vec[j]][1], T[1]) == true) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2;\n\t\tif (T[2] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (S[vec[j]][2] >= T[2]) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2;\n\t\tif (T[3] != \"*\") {\n\t\t\tvec2.clear();\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (S[vec[j]][2] <= T[3]) {\n\t\t\t\t\tvec2.push_back(vec[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvec.clear(); vec = vec2; vec2.clear();\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tcout << S[vec[j]][0] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nclass Book{\npublic:\n    string title,author;\n    int date;\n};\n \nint getDate(string &s){\n    for(int i = 0 ; i < (int)s.size() ; i++){\n\tif(s[i] == '/'){\n\t    s[i] = ' ';\n\t}\n    }\n    int y,m,d;\n    stringstream ss(s);\n    ss >> y; ss >> m; ss >> d;\n    return y*10000 + m*100 + d;\n}\n \nint main(){\n    int N;\n    string str;\n    bool blank = false;\n    cin >> N;\n    vector<Book> books(N);\n    for(int i = 0 ; i < N ; i++){\n\tcin >> books[i].title >> books[i].author >> str;\n\tbooks[i].date = getDate(str);\n    }\n    int Q;\n    cin >> Q;\n    while(Q--){\n\tif(blank) cout << endl;\n\tblank = true;\n\tstring s[4];\n\tint S = 0;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    cin >> s[i];\n\t    if(s[i] == \"*\"){\n\t\tS |= (1<<i);\n\t    }\n\t}\n\tvector<string> res;\n\tfor(int i = 0 ; i < N ; i++){\n\t    bool ok = true;\n\t    for(int j = 0 ; j < 4 ; j++){\n\t\tif(S >> j & 1) continue;\n\t\tif(j == 0){\n\t\t    if(books[i].title.find(s[j]) == string::npos){\n\t\t\tok = false;\n\t\t    }\n\t\t}else if(j == 1){\n\t\t    if(books[i].author.find(s[j]) == string::npos){\n\t\t\tok = false;\n\t\t    }\n\t\t}else if(j == 2){\n\t\t    int date = getDate(s[j]);\n\t\t    if(date > books[i].date){\n\t\t\tok = false;\n\t\t    }\n\t\t}else{\n\t\t    int date = getDate(s[j]);\n\t\t    if(books[i].date > date){\n\t\t\tok = false;\n\t\t    }\n\t\t}\n\t    }\n\t    if(ok){\n\t\tres.push_back(books[i].title);\n\t    }\n\t}\n\tfor(auto x : res){\n\t    cout << x << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include<cstdio>\n#define repi(i,x,n) for(int i = x; i < n; i++)\n#define rep(i,n) repi(i,0,n)\n#define int long long\nusing namespace std;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\n\nstruct info{\n    string title, author;\n    pair<int,pair<int,int>> from, to;\n    \n};\nbool check(string a, string b){\n    for(int i = 0; i <(int)b.size() - (int)a.size()+1; i++){\n        bool flag = true;\n        // cout<<\"i = \"<<i<<\" \"<<b[i]<<\"  {}{} \"<<b.size() - a.size() +1<<endl;\n        for(int j = 0; j < a.size(); j++){\n            if(b[i+j] != a[j]){\n                // cout<<i<<\" \"<<j<<\" \"<<b[i+j]<<\" \"<<a[j]<<endl;\n                flag = false;\n                break;\n            }\n        }\n        if(flag) return true;\n    }\n\n    return false;\n}\n\nsigned main()\n{\n    // cin.tie(0);\n    //ios::sync_with_stdio(false);\n\n    int N, Q;\n\n    vector<info> in;\n\n    cin>>N;\n\n    in.resize(N);\n\n    for(int i = 0; i < N; i++){\n        string a;\n        cin>>in[i].title>>in[i].author>>a;\n        // if(a != \"*\"){\n            in[i].to.first = stoi(a.substr(0,4));\n            in[i].to.second.first =  stoi(a.substr(5,2));\n            in[i].to.second.second =  stoi(a.substr(8,2));\n            // } else in[i].from.first = -INF;\n            //if(b != \"*\"){\n            //cout<<in[i].from.first<<\" \"<<in[i].from.second.first<<\" \"<<in[i].from.second.second<<endl;\n            //in[i].to.first = stoi(b.substr(0,4));\n            //in[i].to.second.first =  stoi(b.substr(5,2));\n            //in[i].to.second.second =  stoi(b.substr(8,2));\n            // } else in[i].to.first = INF;\n        //scanf(\"%ld %ld %ld\", &in[i].from.first, &in[i].from.second.first, &in[i].from.second.second);\n        //scanf(\"%ld/%ld/%ld\", &in[i].from.first, &in[i].from.second.first, &in[i].from.second.second);\n    }\n\n    cin>>Q;\n\n    for(int i = 0; i < Q; i++){\n        info q;\n        string a, b;\n        //cout<<\"i = \"<<i<<endl;\n        cin>>q.title>>q.author>>a>>b;\n        \n         if(a != \"*\"){\n            q.from.first = stoi(a.substr(0,4));\n            q.from.second.first =  stoi(a.substr(5,2));\n            q.from.second.second =  stoi(a.substr(8,2));\n            \n        } else q.from.first = -INF;\n         \n        if(b != \"*\"){\n            q.to.first = stoi(b.substr(0,4));\n            q.to.second.first =  stoi(b.substr(5,2));\n            q.to.second.second =  stoi(b.substr(8,2));\n        } else q.to.first = INF;\n        \n        for(int j = 0; j < N; j++){\n            //  cout<<\"j = \"<<j<<endl;\n            if(q.title != \"*\" && !check(q.title,in[j].title)) continue;\n            // cout<<\"w\"<<\" \"<<q.title<<\" \"<<in[j].title<<endl;\n\n            if(q.author != \"*\" && !check(q.author,in[j].author)) continue;\n            \n\n            // cout<<\"x \"<<q.author<<\" \"<<in[j].author<<endl;\n            //if(q.from > in[j].to) continue;\n            // cout<<\"Y\"<<endl;\n            //if(q.to < in[j].to) continue;\n\n            if(!(q.from <= in[j].to && in[j].to <= q.to)) continue;\n\n            cout<<in[j].title<<endl;\n        }\n        if(i != Q-1) cout<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct book{\n  string n,a,d;\n\n  bool match(string a, string b, string c, string d){\n    if(a!=\"*\" && n.find(a)==string::npos)return false;\n    if(b!=\"*\" && a.find(b)==string::npos)return false;\n    if(c!=\"*\" && d<c)return false;\n    if(d!=\"*\" && d<date)return false;\n    return true;\n  }\n};\n\nint main(){\n  int n; cin >> n;\n  string a,b,c,d;\n\n  book B[100];\n  for(int i=0;i<n;i++){\n    cin >> a >> b >> c;\n    B[i].n = a; B[i].a = b; B[i].d = c;\n  }\n\n  int q; cin >> q;\n  for(int i=0;i<q;i++){\n    cin >> a >> b >> c >> d;\n    for(int j=0;j<n;j++){\n      if(B[j].match(a,b,c,d))cout << B[j].name << endl;\n    }\n    if(i<q-1)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.B\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nstruct BOOK{\n\tstring title;\n\tstring auther;\n\tstring date;\n\tll datenum;\n};\n\nbool operator==(const BOOK &a, const BOOK &b ){\n\treturn (a.title == b.title && a.auther == b.auther && a.date == b.date );\n}\nconst int MAX_N = 105;\nBOOK book[MAX_N];\n\nconst int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\nconst int leap[] = { 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 };\n\n// 1970/01/01 を1日目と勘定する経過日時\nll calc_date (string d ){\n\n\trep (i, d.length() ) if (!isdigit(d[i] ) )  d[i] = ' ';\n\tstringstream ss(d );\n\n\tint year, month, date;\n\tss >> year >> month >> date;\n\tll res = 0LL;\n\n\trep (i, sizeof(leap)/sizeof(leap[0] ) ){\n\t\tif (leap[i] < year ) res++;\n\t\telse\n\t\tif (leap[i] == year && month >= 3 ) res++;\n\t} \n\tyear -= 1970;\n\tmonth -= 1;\n\tres += (ll)365*year;\n\trep (i, month ) res += (ll)days[i];\n\tres += (ll)date;\n\n\treturn res;\n}\n\nvoid disp_book (BOOK b ){\n\tcerr << b.title << endl;\n\tcerr << b.auther << endl;\n\tcerr << b.date << endl;\n\tcerr << b.datenum << endl;\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\trep (i, MAX_N ) book[i].title = \"\", book[i].auther = \"\", book[i].date = \"\", book[i].datenum = 0LL;\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\trep (i, n ){\n\t\tcin >> book[i].title >> book[i].auther >> book[i].date;\n\t\tbook[i].datenum = calc_date (book[i].date);\n//\t\tdisp_book (book[i] );\n\t} // end rep\n\n\tint q; cin >> q;\n\twhile (q-- ){\n\t\tstring q_title = \"\", q_auther = \"\", q_date_from = \"1970/01/01\", q_date_to = \"2037/12/31\";\n\t\tstring q_t, q_a, q_d_f, q_d_t;\n\t\tvector<BOOK> search[3];\n\t\trep (k, 3 ) search[k].clear();\n\n\t\tcin >> q_t >> q_a >> q_d_f >> q_d_t;\n\t\tif (q_t != \"*\" )   q_title     = q_t;\n\t\tif (q_a != \"*\" )   q_auther    = q_a;\n\t\tif (q_d_f != \"*\" ) q_date_from = q_d_f;\n\t\tif (q_d_t != \"*\" ) q_date_to   = q_d_t;\n\n\t\trep (i, n ) search[0].push_back (book[i] );\n\n\t\tif (!q_title.empty() ){\n\t\t\trep (i, search[0].size() ){\n\t\t\t\tstring curr = search[0][i].title;\n\t\t\t\tif (curr.find (q_title ) != string::npos ) search[1].push_back (search[0][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[1] = search[0];\n\t\t} // end if\n\n\n\t\tif (!q_auther.empty() ){\n\t\t\trep (i, search[1].size() ){\n\t\t\t\tstring curr = search[1][i].auther;\n\t\t\t\tif (curr == q_auther ) search[2].push_back (search[1][i] );\n\t\t\t} // end rep\n\t\t}else{\n\t\t\tsearch[2] = search[1];\n\t\t} // end if\n\n//\t\trep (i, search[2].size() ) disp_book (search[2][i] );\n\n\t\tll from = calc_date (q_date_from );\n\t\tll to   = calc_date (q_date_to );\n\t\tvector<string> res; res.clear();\n\t\trep (i, search[2].size() ){\n\t\t\tll curr = search[2][i].datenum;\n\t\t\tif (from <= curr && curr <= to ) res.push_back (search[2][i].title );\n\t\t} // end rep\n\n\t\tif (!res.empty() ){\n\t\t\trep (i, res.size() ){\n\t\t\t\tcout << res[i] << endl;\n\t\t\t} // end rep\n\t\t} // end if\n\t\tif (q != 0 ) cout << endl;\n\t} // end while\t\n\t\t\n\t\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Book {\nprivate:\n  string title;\n  string author;\n  string date;\n\n  int date2day(string date){\n    vector<string> elements;\n    string tmp = \"\";\n    for(int i = 0; i < date.size(); i++){\n      if(date[i] == '/'){\n        elements.push_back(tmp);\n        tmp = \"\";\n        continue;\n      }\n      tmp += date[i];\n    }\n    elements.push_back(tmp);\n    \n    return 365 * (atoi(elements[0].c_str()) - 1970)\n      + (atoi(elements[1].c_str()) - 1) * 31\n      + (atoi(elements[2].c_str()) - 1);\n  }\n\npublic:\n  Book(string title, string author, string date) {\n    this->title = title;\n    this->author = author;\n    this->date = date;\n  }\n\n  bool match_title(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= title.size(); i++){\n      if(title.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_author(string query){\n    if(query == \"*\") return true;\n    for(int i = 0; i + query.size() <= author.size(); i++){\n      if(author.substr(i,query.size()) == query) return true;\n    }\n    return false;\n  }\n\n  bool match_date(string from,string to) {\n    int my_sec = date2sec(date);\n    if(from != \"*\" && my_sec < date2sec(from)) return false;\n    if(to != \"*\" && my_sec > date2sec(to)) return false;\n    return true;\n  }\n\n  string get_title() const {\n    return title;\n  }\n};\n\nint main(){\n  int num_of_books;\n  int num_of_queries;\n  while(~scanf(\"%d\",&num_of_books)){\n    vector<Book> books;\n    for(int book_i = 0; book_i < num_of_books; book_i++){\n      string title,author,date;\n      cin >> title >> author >> date;\n      books.push_back(Book(title,author,date));\n    }\n    scanf(\"%d\",&num_of_queries);\n    for(int query_i = 0; query_i < num_of_queries; query_i++){\n      string title,author,from,to;\n      cin >> title >> author >> from >> to;\n      for(int book_i = 0; book_i < num_of_books; book_i++){\n        if(books[book_i].match_title(title)\n           && books[book_i].match_author(author)\n           && books[book_i].match_date(from,to)){\n          cout << books[book_i].get_title() << endl;\n        }\n      }\n      if(query_i != num_of_queries -1){\n        cout << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n\nint main(){\n\n    int n,q;\n    cin >> n;\n\n    char book[110][2][60];\n    int day[110][3];\n\n    for(int i = 0;i < n;i++){\n        cin >> book[i][0] >> book[i][1];\n        scanf(\"%d/%d/%d\",&day[i][0],&day[i][1],&day[i][2]);\n    }\n\n    bool ch[110][4];\n    cin >> q;\n\n    for(int ii = 0;ii < q;ii++){\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < 4;j++){\n                ch[i][j] = false;\n            }\n        }\n        char a[2][60];\n        for(int k = 0;k < 2;k++){\n            cin >> a[k];\n       //     cout << a[k] << \" \" ;\n            if(a[k][0] != '*'){\n                int alen = strlen(a[k]);\n                for(int i = 0;i < n;i++){\n                //    cout << \"no.\" << i  << \" \";\n                    for(int st = 0;st < strlen(book[i][k]);st++){\n                        int j = 0;\n                        for(j = 0;j < alen;j++){\n                            if(st+j >= strlen(book[i][k])){\n                         //       cout << \"a\" ;\n                                j = -1;\n                                break;\n                            }\n                            if(book[i][k][st+j] != a[k][j]){\n                         //       cout << \"b\" << book[i][k][st+j] << \":\" << a[k][j] << endl;\n\n                                j = -1;\n                                break;\n                            }\n                        }\n                        if(j == alen){\n                            ch[i][k] = true;\n                            break;\n                        }\n                    }\n                }\n            }else{\n           //     cout << \"pou\";\n                for(int i = 0;i < n;i++){\n                    ch[i][k] = true;\n                }\n            }\n        }\n        \n        int day1[3];\n        char tmp[60];\n        cin >> tmp;\n    //    scanf(\"%d/%d/%d\",&day1[0],&day1[1],&day1[2]);\n        bool flag;\n        if(tmp[0] != '*'){\n            day1[0] = 1000 * (tmp[0] - '0') + 100 * (tmp[1] - '0') + 10 * (tmp[2] - '0') + (tmp[3] - '0');\n            day1[1] = 10 * (tmp[5] - '0') + (tmp[6] - '0');\n            day1[2] = 10 * (tmp[8] - '0') + (tmp[9] - '0');\n            for(int i = 0;i < n;i++){\n                flag = true;\n                for(int j = 0;j < 3;j++){\n                    if(day[i][j] < day1[j]){\n                        flag = false;\n                        break;\n                    }else if(day[i][j] > day1[j]){\n                        break;\n                    }\n                }\n                if(flag == true){\n                    ch[i][2] = true;\n                }\n            }\n        }else{\n            for(int i = 0;i < n;i++){\n                ch[i][2] = true;\n            }\n        }\n        // もう一回\n        cin >> tmp;\n        if(tmp[0] != '*'){\n            day1[0] = 1000 * (tmp[0] - '0') + 100 * (tmp[1] - '0') + 10 * (tmp[2] - '0') + (tmp[3] - '0');\n            day1[1] = 10 * (tmp[5] - '0') + (tmp[6] - '0');\n            day1[2] = 10 * (tmp[8] - '0') + (tmp[9] - '0');\n            for(int i = 0;i < n;i++){\n                flag = true;\n                for(int j = 0;j < 3;j++){\n                    if(day[i][j] > day1[j]){\n                        flag = false;\n                        break;\n                    }else if(day[i][j] < day1[j]){\n                        break;\n                    }\n                }\n                if(flag == true){\n                    ch[i][3] = true;\n                }\n            }\n        }else{\n            for(int i = 0;i < n;i++){\n                ch[i][3] = true;\n            }\n        }\n        for(int i = 0;i < n;i++){\n            bool ans = true;\n            for(int j = 0; j < 4;j++){\n                if(ch[i][j] == false){\n                    ans = false;\n                    break;\n                }\n            }\n            if(ans == true){\n                cout << book[i][0] << endl;\n            }\n        }\n        for(int i = 0;i < n;i++){\n   //         cout << ch[i][0] << \" \" ;\n        }\n        if(ii != q-1) cout << endl;\n\n    }\n\n\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tint y,m,d;\n} koiwaikotori;\n\ntypedef struct {\n\tchar asumikana[64];\n\tchar murakawarie[64];\n\tkoiwaikotori sakuraayane;\n} nadukakaori;\n\ntypedef struct {\n\tchar asumikana[64];\n\tchar murakawarie[64];\n\tkoiwaikotori sintaniryouko;\n\tkoiwaikotori fukuennmisato;\n} horieyui;\n\nvoid kitamuraeri(nadukakaori* sintasu) {\n\tif(scanf(\"%s%s%d/%d/%d\",sintasu->asumikana,sintasu->murakawarie,\n\t\t\t &sintasu->sakuraayane.y,&sintasu->sakuraayane.m,&sintasu->sakuraayane.d)!=5)exit(1);\n}\n\nvoid kugimiyarie(horieyui* asumisu) {\n\tchar mizuhasikaori[64];\n\tif(scanf(\"%s%s\",asumisu->asumikana,asumisu->murakawarie)!=2)exit(1);\n\tif(scanf(\"%s\",mizuhasikaori)!=1)exit(1);\n\tif(mizuhasikaori[0]=='*') {\n\t\tasumisu->sintaniryouko.y=asumisu->sintaniryouko.m=asumisu->sintaniryouko.d=-1;\n\t} else {\n\t\tif(sscanf(mizuhasikaori,\"%d/%d/%d\",\n\t\t\t\t  &asumisu->sintaniryouko.y,&asumisu->sintaniryouko.m,&asumisu->sintaniryouko.d)!=3)exit(1);\n\t}\n\tif(scanf(\"%s\",mizuhasikaori)!=1)exit(1);\n\tif(mizuhasikaori[0]=='*') {\n\t\tasumisu->fukuennmisato.y=asumisu->fukuennmisato.m=asumisu->fukuennmisato.d=-1;\n\t} else {\n\t\tif(sscanf(mizuhasikaori,\"%d/%d/%d\",\n\t\t\t\t  &asumisu->fukuennmisato.y,&asumisu->fukuennmisato.m,&asumisu->fukuennmisato.d)!=3)exit(1);\n\t}\n}\n\nint tomatuharuka(const koiwaikotori* miyanomamoru,const koiwaikotori* hanazawakana) {\n\tif(miyanomamoru->y > hanazawakana->y) return 1;\n\tif(miyanomamoru->y < hanazawakana->y) return -1;\n\tif(miyanomamoru->m > hanazawakana->m) return 1;\n\tif(miyanomamoru->m < hanazawakana->m) return -1;\n\tif(miyanomamoru->d > hanazawakana->d) return 1;\n\tif(miyanomamoru->d < hanazawakana->d) return -1;\n\treturn 0;\n}\n\nint maenotomoaki(const nadukakaori* yukana, const horieyui* satourina) {\n\tif(satourina->asumikana[0]!='*' && strstr(yukana->asumikana,satourina->asumikana)==NULL)return 0;\n\tif(satourina->murakawarie[0]!='*' && strstr(yukana->murakawarie,satourina->murakawarie)==NULL)return 0;\n\tif(satourina->sintaniryouko.y>=0) {\n\t\tif(tomatuharuka(&yukana->sakuraayane,&satourina->sintaniryouko)<0)return 0;\n\t}\n\tif(satourina->fukuennmisato.y>=0) {\n\t\tif(tomatuharuka(&satourina->fukuennmisato,&yukana->sakuraayane)<0)return 0;\n\t}\n\treturn 1;\n}\n\nint main(void) {\n\tint haradahitomi,tamurayukari;\n\tnadukakaori simonohiro[100];\n\thorieyui tangesakura;\n\tint mimorisuzuko,tokuisora;\n\tif(scanf(\"%d\",&haradahitomi)!=1)return 1;\n\tfor(mimorisuzuko=0;mimorisuzuko<haradahitomi;mimorisuzuko++) {\n\t\tkitamuraeri(&simonohiro[mimorisuzuko]);\n\t}\n\tif(scanf(\"%d\",&tamurayukari)!=1)return 1;\n\tfor(mimorisuzuko=0;mimorisuzuko<tamurayukari;mimorisuzuko++) {\n\t\tif(mimorisuzuko>0)putchar('\\n');\n\t\tkugimiyarie(&tangesakura);\n\t\tfor(tokuisora=0;tokuisora<haradahitomi;tokuisora++) {\n\t\t\tif(maenotomoaki(&simonohiro[tokuisora],&tangesakura)) {\n\t\t\t\tputs(simonohiro[tokuisora].asumikana);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,i,j,a[10010],b,c,y,m,d;\n  char s[4][110],t[110][110],o[110][110];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s %s %d/%d/%d\",t[i],o[i],&y,&m,&d);\n    a[i]=y*10000+m*100+d;\n  }\n  scanf(\"%d\",&m);\n  while(m--){\n    for(i=0;i<4;i++)scanf(\"%s\",s[i]);//printf(\"%s %s %S %s\\n\");\n    for(i=0;i<n;i++){\n      if(s[0][0]-'*'&&strstr(t[i],s[0])==NULL)continue;\n      if(s[1][0]-'*'&&strstr(o[i],s[1])==NULL)continue;\n      for(j=b=0;s[2][j];j++)b=s[2][j]-'/'?b*10+s[2][j]-'0':b;\n      if(s[2][0]=='*')b=0;\n      for(j=c=0;s[3][j];j++)c=s[3][j]-'/'?c*10+s[3][j]-'0':c;\n      if(s[3][0]=='*')c=1e9;\n      if(b<=a[i]&&a[i]<=c)printf(\"%s\\n\",t[i]);\n    }\n    if(m)printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2657: Books\n// 2017.11.16 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { char t[52]; int lt; char a[52]; int la; int d; } T;\nT book[101]; int n;\n\nint nxt[100], nxa[100];\nint kmpMatch(char *text, int len, char *pattern, int patlen, int *next)\n{\n    char *pp;\n    char *textEnd, *patEnd;\n\n    if (len < patlen) return 0;\n\n    textEnd = text + len;\n    patEnd  = pattern + patlen;\n\n    pp = pattern;\n    while (text != textEnd) {\n        if (*text++ == *pp) pp++;\n        else if (pp != pattern) {\n            pp = pattern + *(next + (pp - pattern));\n            text--;\n        }\n        if (pp == patEnd) return 1;\n    }\n    return 0;\n}\n\nint kmpNext(int *next, int nlen, char *pattern, int patlen)\n{\n    char *tp, *pp;\n    char *patEnd;\n\n    if (nlen < patlen) return -1;\n\n    patEnd  = pattern + patlen;\n    *next = 0;\n\n    tp = pp = pattern;\n    while (++tp != patEnd) {\n        *(next + (tp - pattern)) = pp - pattern;\n        if (*tp == *pp) pp++;\n    }\n    return 0;\n}\n\nint ymd2d(char *s)\n{\n\tint y, m, d;\n\ty = atoi(s), m = atoi(s+5), d = atoi(s+8);\n\treturn (((y << 4) + m) << 5) + d;\n}\n\nint main()\n{\n\tint i, j, q, lt, la, from, to;\n\tchar qt[52], qa[52], buf[15], bu2[15];\n\tT *t;\n\n\tscanf(\"%d\", &n);\n\tfor (t = book, i = 0; i < n; i++, t++) {\n\t\tscanf(\"%s%s%s\", t->t, t->a, buf);\n\t\tt->lt = strlen(t->t), t->la = strlen(t->a), t->d = ymd2d(buf);\n\t}\n\tscanf(\"%d\", &q);\n\tfor (i = 0; i < q; i++) {\n\t\tint ft, fa, fm, fo;\n\t\tft = fa = fm = fo = 0;\n\t\tscanf(\"%s%s%s%s\", qt, qa, buf, bu2);\n\n\t\tif (*qt == '*') ft = 1;\n\t\telse lt = strlen(qt), kmpNext(nxt, 100, qt, lt);\n\n\t\tif (*qa == '*') fa = 1;\n\t\telse la = strlen(qa), kmpNext(nxa, 100, qa, la);\n\n\t\tif (*buf == '*') fm = 1;\n\t\telse from = ymd2d(buf);\n\n\t\tif (*bu2 == '*') fo = 1;\n\t\telse to = ymd2d(bu2);\n\n\t\tif (i > 0) putchar('\\n');\n\t\tfor (t = book, j = 0; j < n; j++, t++) {\n\t\t\tint a = ft, b = fa, c = fm, d = fo;\n\t\t\tif (!a) a = kmpMatch(t->t, t->lt, qt, lt, nxt);\n\t\t\tif (!b) b = kmpMatch(t->a, t->la, qa, la, nxa);\n\t\t\tif (!c) c = (t->d >= from);\n\t\t\tif (!d) d = (t->d <= to);\n\n\t\t\tif (a&b&c&d) puts(t->t);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    val n = readLine()!!.trim().toInt()\n    val books = Array(n){\n        val (title, author, date) = readLine()!!.trim().split(' ')\n        Book(title, author, date)\n    }\n    repeat(readLine()!!.trim().toInt()){\n        if (it != 0) println()\n        val (title, author, from, to) = readLine()!!.trim().split(' ')\n        var find: List<Int> = books.indices.toList()\n        if (title != \"*\") find = find.filter{ i -> title in books[i].title }\n        if (author != \"*\") find = find.filter { i -> author in books[i].author }\n        if (from != \"*\") {\n            val f = Date.parse(from)\n            find = find.filter{ i -> f <= books[i].date}\n        }\n        if (to != \"*\") {\n            val t = Date.parse(to)\n            find = find.filter{ i -> t >= books[i].date}\n        }\n        if (find.isNotEmpty())\n            println(find.joinToString(\"\\n\"){i -> books[i].title})\n    }\n}\ndata class Book(val title: String, val author: String, val date: Date) {\n    constructor(title: String, author: String, date: String):this(title, author, Date.parse(date))\n}\ndata class Date(val year: Int, val month: Int, val day: Int): Comparable<Date> {\n    override fun compareTo(other: Date): Int {\n        return if (year == other.year) if (month == other.month) day.compareTo(other.day) else month.compareTo(other.month) else year.compareTo(other.year)\n    }\n\n    companion object {\n        fun parse(str: String): Date {\n            val (year, month, day) = str.trim().split('/').map(String::toInt)\n            return Date(year, month, day)\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tArrayList<Data>list = new ArrayList<Data>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString title = sc.next();\n\t\t\tString author = sc.next();\n\t\t\tCalendar date = Calendar.getInstance();\n\t\t\tString[] datex = sc.next().split(\"/\");\n\t\t\t\n\t\t\tdate.set(Integer.parseInt(datex[0]),Integer.parseInt(datex[1]),Integer.parseInt(datex[2]));\n\t\t\tlist.add(new Data(title,author,date));\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tif(i != 0) System.out.println();\n\t\t\tArrayList<Data> ok = new ArrayList<Data>();\n\t\t\tArrayList<Data> ok2 = new ArrayList<Data>();\n\t\t\tString title = sc.next();\n\t\t\tString author = sc.next();\n\t\t\tCalendar from = Calendar.getInstance();\n\t\t\tString[] datex = sc.next().split(\"/\");\n\t\t\tif(datex[0].equals(\"*\")) from.set(1970, 1,1);\n\t\t\telse from.set(Integer.parseInt(datex[0]),Integer.parseInt(datex[1]),Integer.parseInt(datex[2]));\n\t\t\tCalendar to   = Calendar.getInstance();\n\t\t\tdatex = sc.next().split(\"/\");\n\t\t\tif(datex[0].equals(\"*\")) to.set(2037, 12,31);\n\t\t\telse to.set(Integer.parseInt(datex[0]),Integer.parseInt(datex[1]),Integer.parseInt(datex[2]));\n\t\t\tif(title.equals(\"*\")) ok.addAll(list);\n\t\t\telse \n\t\t\t\tfor(int j = 0; j < list.size(); j++) {\n\t\t\t\t\tif(list.get(j).title.contains(title)) ok.add(list.get(j));\n\t\t\t\t}\n\t\t\tif(author.equals(\"*\")) ok2.addAll(ok);\n\t\t\telse\n\t\t\t\tfor(int j = 0; j < ok.size(); j++) {\n\t\t\t\t\tif(ok.get(j).author.contains(author)) ok2.add(ok.get(j));\n\t\t\t\t}\n\t\t\tfor(int j = 0; j < ok2.size(); j++) {\n\t\t\t\tif(ok2.get(j).date.compareTo(from) >= 0 && ok2.get(j).date.compareTo(to) <= 0) System.out.println(ok2.get(j).title);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tstatic class Data {\n\t\tString title;\n\t\tString author;\n\t\tCalendar date;\n\t\tData(String a, String b, Calendar c) {\n\t\t\ttitle = a;\n\t\t\tauthor = b;\n\t\t\tdate = c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic int max;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tArrayList<Data>list = new ArrayList<Data>(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString title = sc.next();\n\t\t\tString author = sc.next();\n\t\t\tCalendar date = Calendar.getInstance();\n\t\t\tdate.clear();\n\t\t\tString[] datex = sc.next().split(\"/\");\n\t\t\t\n\t\t\tdate.set(Integer.parseInt(datex[0]),Integer.parseInt(datex[1]),Integer.parseInt(datex[2]));\n\t\t\tlist.add(new Data(title,author,date));\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tif(i != 0) System.out.println();\n\t\t\tArrayList<Data> ok = new ArrayList<Data>();\n\t\t\tArrayList<Data> ok2 = new ArrayList<Data>();\n\t\t\tString title = sc.next();\n\t\t\tString author = sc.next();\n\t\t\tCalendar from = Calendar.getInstance();\n\t\t\tfrom.clear();\n\t\t\tString[] datex = sc.next().split(\"/\");\n\t\t\tif(datex[0].equals(\"*\")) from.set(1970, 1,1);\n\t\t\telse from.set(Integer.parseInt(datex[0]),Integer.parseInt(datex[1]),Integer.parseInt(datex[2]));\n\t\t\tCalendar to   = Calendar.getInstance();\n\t\t\tto.clear();\n\t\t\tdatex = sc.next().split(\"/\");\n\t\t\tif(datex[0].equals(\"*\")) to.set(2037, 12,31);\n\t\t\telse to.set(Integer.parseInt(datex[0]),Integer.parseInt(datex[1]),Integer.parseInt(datex[2]));\n\t\t\t\n\t\t\tif(title.equals(\"*\")) ok.addAll(list);\n\t\t\telse \n\t\t\t\tfor(int j = 0; j < list.size(); j++) {\n\t\t\t\t\tif(list.get(j).title.contains(title)) ok.add(list.get(j));\n\t\t\t\t}\n\t\t\tif(author.equals(\"*\")) ok2.addAll(ok);\n\t\t\telse\n\t\t\t\tfor(int j = 0; j < ok.size(); j++) {\n\t\t\t\t\tif(ok.get(j).author.contains(author)) ok2.add(ok.get(j));\n\t\t\t\t}\n\t\t\tfor(int j = 0; j < ok2.size(); j++) {\n\t\t\t\tif(ok2.get(j).date.compareTo(from) >= 0 && ok2.get(j).date.compareTo(to) <= 0) System.out.println(ok2.get(j).title);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tstatic class Data {\n\t\tString title;\n\t\tString author;\n\t\tCalendar date;\n\t\tData(String a, String b, Calendar c) {\n\t\t\ttitle = a;\n\t\t\tauthor = b;\n\t\t\tdate = c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tBook[] books = new Book[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t    books[i] = new Book(sc.next(), sc.next(), sc.next());\n\t\t}\n\t\tint q = sc.nextInt();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t    if (i != 0) {\n\t\t        sb.append(\"\\n\");\n\t\t    }\n\t\t    String tQuery = sc.next();\n\t\t    String aQuery = sc.next();\n\t\t    String from = sc.next();\n\t\t    String to = sc.next();\n\t\t    for (int j = 0; j < n; j++) {\n\t\t        if (books[j].isHit(tQuery, aQuery, from, to)) {\n\t\t            sb.append(books[j].title).append(\"\\n\");\n\t\t        }\n\t\t    }\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n\t\n\tstatic class Book {\n\t    String title;\n\t    String author;\n\t    String date;\n\t    \n\t    public Book (String title, String author, String date) {\n\t        this.title = title;\n\t        this.author = author;\n\t        this.date = date;\n\t    }\n\t    \n\t    public boolean isHit(String tQuery, String aQuery, String from, String to) {\n\t        if (!tQuery.equals(\"*\")) {\n\t            if (!title.contains(tQuery)) {\n\t                return false;\n\t            }\n\t        }\n\t        if (!aQuery.equals(\"*\")) {\n\t            if (!author.contains(aQuery)) {\n\t                return false;\n\t            }\n\t        }\n\t        if (!from.equals(\"*\")) {\n\t            if (date.compareTo(from) < 0) {\n\t                return false;\n\t            }\n\t        }\n\t        if (!to.equals(\"*\")) {\n\t            if (date.compareTo(to) > 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var dict = Enumerable.Range(0, int.Parse(Console.ReadLine())).Select(p => {\n                var input = Console.ReadLine().Split();\n                return new { t = input[0], w = input[1], d = Convert.ToDateTime(input[2]) };\n            }).ToList();\n            for (int i = int.Parse(Console.ReadLine()) - 1; i >= 0; --i) {\n                var input = Console.ReadLine().Split();\n                var ds = Convert.ToDateTime(input[2] == \"*\" ? \"1970/01/01\" : input[2]);\n                var db = Convert.ToDateTime(input[3] == \"*\" ? \"2037/12/31\" : input[3]);\n                foreach (var item in dict.Where(p => (input[0] == \"*\" || p.t.Contains(input[0])) && (input[1] == \"*\" || p.w.Contains(input[1])) && (p.d >= ds) && (p.d <= db) )) {\n                    Console.WriteLine(item.t);\n                }\n                if (i != 0) {\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var dict = Enumerable.Range(0, int.Parse(Console.ReadLine())).Select(p => {\n                var input = Console.ReadLine().Split();\n                return new { t = input[0], w = input[1], d = Convert.ToDateTime(input[2]) };\n            }).ToList();\n            var output = new System.Text.StringBuilder();\n            for (int i = int.Parse(Console.ReadLine()) - 1; i >= 0; --i) {\n                var input = Console.ReadLine().Split();\n                var ds = Convert.ToDateTime(input[2] == \"*\" ? \"1970/01/01\" : input[2]);\n                var db = Convert.ToDateTime(input[3] == \"*\" ? \"2037/12/31\" : input[3]);\n                foreach (var item in dict.Where(p => (input[0] == \"*\" || p.t.Contains(input[0])) && (input[1] == \"*\" || p.w.Contains(input[1])) && (p.d >= ds) && (p.d <= db) )) {\n                    output.AppendLine(item.t);\n                }\n                if (i != 0) {\n                    output.AppendLine();\n                }\n            }\n            Console.Write(output.ToString());\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar n=arr.shift()-0;\nvar book=[];\nfor(var i=0;i<n;i++)book[i]=arr.shift();\nvar q=arr.shift()-0;\nfor(var i=0;i<q;i++){\n   if(i!=0)console.log(\"\");\n   var ans=[];\n   var v=arr.shift().split(\" \");\n   var a=v[0];\n   var b=v[1];\n   var c=(v[2]!=\"*\")?(new Date(v[2])).getTime():\"*\";\n   var d=(v[3]!=\"*\")?(new Date(v[3])).getTime():\"*\";\n   book.forEach(function(V){\n      V=V.split(\" \");\n      var A=V[0];\n      var B=V[1];\n      var C=(new Date(V[2])).getTime();\n      var flag=true;\n      if(a!=\"*\"){\n         var regex = new RegExp(a);\n         if(regex.test(A)==false)flag=false;\n      }\n      if(b!=\"*\"){\n         var regex = new RegExp(b);\n         if(regex.test(B)==false)flag=false;\n      }\n      if(c!=\"*\"){\n         if(c>C)flag=false;\n      }\n      if(d!=\"*\"){\n         if(d<C)flag=false;\n      }\n      if(flag)ans.push(A);\n   });\n   ans.forEach(function(value){\n       console.log(value);\n   });\n}"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    books = []\n    for i in range(N):\n        title, author, date = input().split()\n        date = list(map(int, date.split('/')))\n        books.append((title, author, date))\n\n    Q = int(input())\n    for i in range(Q):\n        title, author, date_from, date_to = input().split()\n        if date_from != '*':\n            date_from = list(map(int, date_from.split('/')))\n        if date_to != '*':\n            date_to = list(map(int, date_to.split('/')))\n\n        resp = books[:]\n        resp = [book for book in resp if title == '*' or title in book[0]]\n        resp = [book for book in resp if author == '*' or author in book[1]]\n        resp = [book for book in resp if date_from == '*' or date_from <= book[2]]\n        resp = [book for book in resp if date_to == '*' or date_to >= book[2]]\n\n        for book in resp:\n            print(book[0])\n\n        if i+1 < Q:\n            print()\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nbooks = [input().split(\" \") for i in range(N)]\nQ = int(input())\nquery = [input().split(\" \") for i in range(Q)]\ndates = []\nfor _, _, date in books:\n    dates.append(list(map(int, date.split(\"/\"))))\n\n\ndef search_Q_title(Q_title, books):\n    if (Q_title==\"*\"):\n        return (1<<(N+1))-1\n    else:\n        ret = 0\n        for i, book in enumerate(books):\n            if (Q_title in book[0]):\n                ret |= 1<<i\n        return ret\n\ndef search_Q_author(Q_author, books):\n    if (Q_author==\"*\"):\n        return (1<<(N+1))-1\n    else:\n        ret = 0\n        for i, book in enumerate(books):\n            if (Q_author in book[1]):\n                ret |= 1<<i\n        return ret\n\ndef search_Q_date_from(Q_date_from, dates):\n    if (Q_date_from==\"*\"):\n        return (1<<(N+1))-1\n    else:\n        ret = 0\n        Q_year, Q_month, Q_day = list(map(int, Q_date_from.split(\"/\")))\n        for i, date in enumerate(dates):\n            year, month, day = date\n            if (year > Q_year):\n                ret |= 1<<i\n            elif (year == Q_year):\n                if (month > Q_month):\n                    ret |= 1<<i\n                elif (month == Q_month):\n                    if (day >= Q_day):\n                        ret |= 1<<i\n        return ret\n\n\ndef search_Q_date_t0(Q_date_to, dates):\n    if (Q_date_to==\"*\"):\n        return (1<<(N+1))-1\n    else:\n        ret = 0\n        Q_year, Q_month, Q_day = list(map(int, Q_date_to.split(\"/\")))\n        for i, date in enumerate(dates):\n            year, month, day = date\n            if (year < Q_year):\n                ret |= 1<<i\n            elif (year == Q_year):\n                if (month < Q_month):\n                    ret |= 1<<i\n                elif (month == Q_month):\n                    if (day <= Q_day):\n                        ret |= 1<<i\n        return ret\n        \n\nfor i, Quer in enumerate(query):\n    Q_title, Q_author, Q_date_from, Q_date_to = Quer\n    bit = search_Q_title(Q_title, books) & search_Q_author(Q_author, books) & search_Q_date_from(Q_date_from, dates) & search_Q_date_t0(Q_date_to, dates)\n    for j in range(N):\n        if (bit & 1):\n            print(books[j][0])\n        bit >>= 1\n    if (i != Q-1):\n        print()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nbooks = [input().split() for _ in range(n)]\nq = int(input())\nfor i in range(q):\n  qt, qa, qdf, qdt = input().split()\n  for title, auther, date in books:\n    if (qt == \"*\" or qt in title) and (qa == \"*\" or qa in auther) and (qdf == \"*\" or qdf <= date) and (qdt == \"*\" or date <= qdt):\n      print(title)\n  if i != q - 1:\n    print() \n"
  },
  {
    "language": "Python",
    "code": "import sys\nn = int(sys.stdin.readline())\ndata = [[None]*3 for i in range(n)]\nfor i in range(n):\n    s = sys.stdin.readline().split()\n    data[i][0] = \"*\"+s[0]\n    data[i][1] = \"*\"+s[1]\n    data[i][2] = s[2]\n\nq = int(sys.stdin.readline())\nfor i in range(q):\n    qb,qa,f,t = sys.stdin.readline().split()\n    if t == \"*\":\n        t = \"9\"+t\n    for b,a,d in data:\n        if qb in b and qa in a and f <= d <= t:\n            print(b[1:])\n    if i < q-1:\n        print()\n\n"
  }
]