[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_BOOKS 1000\n#define MAX_TITLE_LENGTH 100\n#define MAX_AUTHOR_LENGTH 100\n#define MAX_DATE_LENGTH 11\n\ntypedef struct {\n    char title[MAX_TITLE_LENGTH];\n    char author[MAX_AUTHOR_LENGTH];\n    char date[MAX_DATE_LENGTH];\n} Book;\n\nint is_match(const char* query, const char* value) {\n    if (strcmp(query, \"*\") == 0) return 1;\n    return strstr(value, query) != NULL;\n}\n\nint date_compare(const char* date1, const char* date2) {\n    return strcmp(date1, date2);\n}\n\nint main() {\n    int N, Q;\n    Book books[MAX_BOOKS];\n    \n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s %s %s\", \n            books[i].title, \n            books[i].author, \n            books[i].date);\n    }\n    \n    scanf(\"%d\", &Q);\n    for (int q = 0; q < Q; q++) {\n        char Q_title[MAX_TITLE_LENGTH];\n        char Q_author[MAX_AUTHOR_LENGTH];\n        char Q_date_from[MAX_DATE_LENGTH];\n        char Q_date_to[MAX_DATE_LENGTH];\n        \n        scanf(\"%s %s %s %s\", \n            Q_title, \n            Q_author, \n            Q_date_from, \n            Q_date_to);\n        \n        int matches_found = 0;\n        for (int i = 0; i < N; i++) {\n            if (is_match(Q_title, books[i].title) &&\n                is_match(Q_author, books[i].author) &&\n                (strcmp(Q_date_from, \"*\") == 0 || date_compare(books[i].date, Q_date_from) >= 0) &&\n                (strcmp(Q_date_to, \"*\") == 0 || date_compare(books[i].date, Q_date_to) <= 0)) {\n                \n                if (matches_found > 0) printf(\"\\n\");\n                printf(\"%s\", books[i].title);\n                matches_found++;\n            }\n        }\n        \n        if (q < Q - 1) printf(\"\\n\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char title[100];\n    char author[100];\n    char date[11];\n} Book;\n\nint compare_dates(const char *date1, const char *date2) {\n    return strcmp(date1, date2);\n}\n\nint matches(const Book *book, const char *q_title, const char *q_author, const char *q_date_from, const char *q_date_to) {\n    if (strcmp(q_title, \"*\") != 0 && strstr(book->title, q_title) == NULL) {\n        return 0;\n    }\n    if (strcmp(q_author, \"*\") != 0 && strstr(book->author, q_author) == NULL) {\n        return 0;\n    }\n    if (strcmp(q_date_from, \"*\") != 0 && compare_dates(book->date, q_date_from) < 0) {\n        return 0;\n    }\n    if (strcmp(q_date_to, \"*\") != 0 && compare_dates(book->date, q_date_to) > 0) {\n        return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d\", &N);\n    Book *books = malloc(N * sizeof(Book));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s %s %s\", books[i].title, books[i].author, books[i].date);\n    }\n    scanf(\"%d\", &M);\n    for (int i = 0; i < M; i++) {\n        char q_title[100], q_author[100], q_date_from[11], q_date_to[11];\n        scanf(\"%s %s %s %s\", q_title, q_author, q_date_from, q_date_to);\n        for (int j = 0; j < N; j++) {\n            if (matches(&books[j], q_title, q_author, q_date_from, q_date_to)) {\n                printf(\"%s\\n\", books[j].title);\n            }\n        }\n        if (i != M - 1) {\n            printf(\"\\n\");\n        }\n    }\n    free(books);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Book {\n    string title;\n    string author;\n    string date;\n};\n\nbool matches(const Book &book, const string &q_title, const string &q_author, const string &q_date_from, const string &q_date_to) {\n    if (q_title != \"*\" && book.title.find(q_title) == string::npos) {\n        return false;\n    }\n    if (q_author != \"*\" && book.author.find(q_author) == string::npos) {\n        return false;\n    }\n    if (q_date_from != \"*\" && book.date < q_date_from) {\n        return false;\n    }\n    if (q_date_to != \"*\" && book.date > q_date_to) {\n        return false;\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N;\n    vector<Book> books(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> books[i].title >> books[i].author >> books[i].date;\n    }\n    cin >> M;\n    for (int i = 0; i < M; ++i) {\n        string q_title, q_author, q_date_from, q_date_to;\n        cin >> q_title >> q_author >> q_date_from >> q_date_to;\n        bool first = true;\n        for (const auto &book : books) {\n            if (matches(book, q_title, q_author, q_date_from, q_date_to)) {\n                if (!first) {\n                    cout << endl;\n                }\n                cout << book.title;\n                first = false;\n            }\n        }\n        if (i != M - 1) {\n            cout << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Book {\n    String title;\n    String author;\n    String date;\n\n    Book(String title, String author, String date) {\n        this.title = title;\n        this.author = author;\n        this.date = date;\n    }\n}\n\npublic class BookSearch {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // consume the newline\n\n        List<Book> books = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            String title = parts[0];\n            String author = parts[1];\n            String date = parts[2];\n            books.add(new Book(title, author, date));\n        }\n\n        int M = scanner.nextInt();\n        scanner.nextLine(); // consume the newline\n\n        for (int i = 0; i < M; i++) {\n            String[] queryParts = scanner.nextLine().split(\" \");\n            String qTitle = queryParts[0];\n            String qAuthor = queryParts[1];\n            String qDateFrom = queryParts[2];\n            String qDateTo = queryParts[3];\n\n            List<String> results = new ArrayList<>();\n            for (Book book : books) {\n                boolean titleMatch = qTitle.equals(\"*\") || book.title.contains(qTitle);\n                boolean authorMatch = qAuthor.equals(\"*\") || book.author.contains(qAuthor);\n                boolean dateFromMatch = qDateFrom.equals(\"*\") || book.date.compareTo(qDateFrom) >= 0;\n                boolean dateToMatch = qDateTo.equals(\"*\") || book.date.compareTo(qDateTo) <= 0;\n\n                if (titleMatch && authorMatch && dateFromMatch && dateToMatch) {\n                    results.add(book.title);\n                }\n            }\n\n            for (String title : results) {\n                System.out.println(title);\n            }\n            if (i < M - 1) {\n                System.out.println();\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:52:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BookSearch {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Book> books = new ArrayList<>();\n        \n        // Read book entries\n        int N = scanner.nextInt();\n        scanner.nextLine();\n        for (int i = 0; i < N; i++) {\n            String title = scanner.nextLine();\n            String author = scanner.nextLine();\n            String date = scanner.nextLine();\n            books.add(new Book(title, author, date));\n        }\n        \n        // Read queries\n        int Q = scanner.nextInt();\n        scanner.nextLine();\n        \n        for (int i = 0; i < Q; i++) {\n            String[] query = scanner.nextLine().split(\" \");\n            String Q_title = query[0];\n            String Q_author = query[1];\n            String Q_date_from = query[2];\n            String Q_date_to = query[3];\n            \n            boolean foundMatch = false;\n            for (Book book : books) {\n                if (matchesQuery(book, Q_title, Q_author, Q_date_from, Q_date_to)) {\n                    System.out.println(book.title);\n                    foundMatch = true;\n                }\n            }\n            \n            if (i < Q - 1 && foundMatch) {\n                System.out.println();\n            }\n        }\n    }\n    \n    static boolean matchesQuery(Book book, String Q_title, String Q_author, \n                                 String Q_date_from, String Q_date_to) {\n        // Title match\n        boolean titleMatch = Q_title.equals(\"*\") || \n                             book.title.toLowerCase().contains(Q_title.toLowerCase());\n        \n        // Author match\n        boolean authorMatch = Q_author.equals(\"*\") || \n                              book.author.toLowerCase().contains(Q_author.toLowerCase());\n        \n        // Date match\n        boolean dateMatch = (Q_date_from.equals(\"*\") || book.date.compareTo(Q_date_from) >= 0) &&\n                            (Q_date_to.equals(\"*\") || book.date.compareTo(Q_date_to) <= 0);\n        \n        return titleMatch && authorMatch && dateMatch;\n    }\n    \n    static class Book {\n        String title;\n        String author;\n        String date;\n        \n        Book(String title, String author, String date) {\n            this.title = title;\n            this.author = author;\n            this.date = date;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:53:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstruct Book {\n    string title;\n    string author;\n    string date;\n};\n\nbool isMatch(const string& query, const string& value) {\n    if (query == \"*\") return true;\n    return value.find(query) != string::npos;\n}\n\nbool isDateInRange(const string& date, const string& from, const string& to) {\n    if (from != \"*\" && date < from) return false;\n    if (to != \"*\" && date > to) return false;\n    return true;\n}\n\nint main() {\n    int n, q;\n    cin >> n;\n    \n    vector<Book> books(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> books[i].title >> books[i].author >> books[i].date;\n    }\n    \n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        string Q_title, Q_author, Q_date_from, Q_date_to;\n        cin >> Q_title >> Q_author >> Q_date_from >> Q_date_to;\n        \n        bool found = false;\n        for (const auto& book : books) {\n            if (isMatch(Q_title, book.title) &&\n                isMatch(Q_author, book.author) &&\n                isDateInRange(book.date, Q_date_from, Q_date_to)) {\n                cout << book.title << endl;\n                found = true;\n            }\n        }\n        \n        if (i < q - 1 && found) cout << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Book:\n    def __init__(self, title, author, date):\n        self.title = title\n        self.author = author\n        self.date = date\n\ndef matches(book, q_title, q_author, q_date_from, q_date_to):\n    matches_title = q_title in book.title if q_title != \"*\" else True\n    matches_author = q_author in book.author if q_author != \"*\" else True\n    matches_date_from = book.date >= q_date_from if q_date_from != \"*\" else True\n    matches_date_to = book.date <= q_date_to if q_date_to != \"*\" else True\n    return matches_title and matches_author and matches_date_from and matches_date_to\n\ndef search_books(books, queries):\n    results = []\n    for q in queries:\n        q_title, q_author, q_date_from, q_date_to = q\n        result = []\n        for book in books:\n            if matches(book, q_title, q_author, q_date_from, q_date_to):\n                result.append(book.title)\n        results.append(result)\n    return results\n\n# Sample input\nbooks_data = [\n    [\"The Great Gatsby\", \"F. Scott Fitzgerald\", \"1925/04/10\"],\n    [\"1984\", \"George Orwell\", \"1949/06/08\"],\n    [\"To Kill a Mockingbird\", \"Harper Lee\", \"1960/07/11\"]\n]\n\nqueries_data = [\n    [\"The\", \"*\", \"*\", \"1930/01/01\"],\n    [\"1984\", \"George\", \"*\", \"*\"],\n    [\"Harry\", \"*\", \"*\", \"*\"]\n]\n\n# Processing\nbooks = [Book(title, author, date) for title, author, date in books_data]\nqueries = [tuple(query) for query in queries_data]\n\n# Execute\nmatch_results = search_books(books, queries)\n\n# Output\nfor result in match_results:\n    if result:\n        print(\"\\n\".join(result))\n    print()",
    "timestamp": "2025-08-13 07:53:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Book {\n    String title;\n    String author;\n    String date;\n\n    public Book(String title, String author, String date) {\n        this.title = title;\n        this.author = author;\n        this.date = date;\n    }\n}\n\npublic class BookSearchSystem {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read the number of books\n        int n = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n\n        // Initialize the list of books\n        List<Book> books = new ArrayList<>();\n\n        // Read all the book details\n        for (int i = 0; i < n; i++) {\n            String title = scanner.nextLine();\n            String author = scanner.nextLine();\n            String date = scanner.nextLine();\n            books.add(new Book(title, author, date));\n        }\n\n        // Read the number of queries\n        int q = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n\n        // Process each query\n        for (int i = 0; i < q; i++) {\n            String query = scanner.nextLine();\n            String[] queryParts = query.split(\" \");\n            \n            String qTitle = queryParts[0];\n            String qAuthor = queryParts[1];\n            String qDateFrom = queryParts[2];\n            String qDateTo = queryParts[3];\n\n            List<String> results = new ArrayList<>();\n\n            for (Book book : books) {\n                if (matches(book.title, qTitle) &&\n                    matches(book.author, qAuthor) &&\n                    withinDateRange(book.date, qDateFrom, qDateTo)) {\n                    results.add(book.title);\n                }\n            }\n\n            // Output the results for this query\n            for (String result : results) {\n                System.out.println(result);\n            }\n            if (!results.isEmpty() && i < q - 1) {\n                System.out.println();\n            }\n        }\n        scanner.close();\n    }\n\n    private static boolean matches(String value, String query) {\n        return query.equals(\"*\") || value.contains(query);\n    }\n\n    private static boolean withinDateRange(String date, String from, String to) {\n        return (from.equals(\"*\") || date.compareTo(from) >= 0) &&\n               (to.equals(\"*\") || date.compareTo(to) <= 0);\n    }\n}",
    "timestamp": "2025-08-13 07:53:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_BOOKS 100\n#define MAX_LENGTH 100\n\ntypedef struct {\n    char title[MAX_LENGTH];\n    char author[MAX_LENGTH];\n    char date[MAX_LENGTH];\n} Book;\n\nint matches(const char *pattern, const char *str) {\n    if (strcmp(pattern, \"*\") == 0) return 1;\n    return strstr(str, pattern) != NULL;\n}\n\nint is_within_date_range(const char *date, const char *date_from, const char *date_to) {\n    return strcmp(date_from, \"*\") <= 0 || strcmp(date, date_from) >= 0 &&\n           strcmp(date_to, \"*\") >= 0 || strcmp(date, date_to) <= 0;\n}\n\nint main() {\n    Book books[MAX_BOOKS];\n    int num_books = 0;\n    int num_queries = 0;\n    char buffer[MAX_LENGTH];\n\n    // Input number of books\n    scanf(\"%d\", &num_books);\n    getchar();  // Consume newline\n\n    // Input book data\n    for (int i = 0; i < num_books; ++i) {\n        fgets(books[i].title, MAX_LENGTH, stdin);\n        strtok(books[i].title, \"\\n\");\n        fgets(books[i].author, MAX_LENGTH, stdin);\n        strtok(books[i].author, \"\\n\");\n        fgets(books[i].date, MAX_LENGTH, stdin);\n        strtok(books[i].date, \"\\n\");\n    }\n\n    // Input number of queries\n    scanf(\"%d\", &num_queries);\n    getchar();  // Consume newline\n\n    for (int i = 0; i < num_queries; ++i) {\n        char q_title[MAX_LENGTH], q_author[MAX_LENGTH], q_date_from[MAX_LENGTH], q_date_to[MAX_LENGTH];\n\n        // Input a query\n        fgets(buffer, MAX_LENGTH, stdin);\n        sscanf(buffer, \"%s %s %s %s\", q_title, q_author, q_date_from, q_date_to);\n        \n        int first_match = 1;\n        for (int j = 0; j < num_books; ++j) {\n            if (matches(q_title, books[j].title) &&\n                matches(q_author, books[j].author) &&\n                is_within_date_range(books[j].date, q_date_from, q_date_to)) {\n                \n                if (!first_match) {\n                    printf(\"\\n\");\n                }\n                printf(\"%s\", books[j].title);\n                first_match = 0;\n            }\n        }\n\n        if (i < num_queries - 1) {\n            printf(\"\\n\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:53:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def matches_query(book, query):\n    title, author, date_from, date_to = query\n    \n    # Check title match\n    if title != '*' and title.lower() not in book[0].lower():\n        return False\n    \n    # Check author match\n    if author != '*' and author.lower() not in book[1].lower():\n        return False\n    \n    # Check date range\n    if date_from != '*' and book[2] < date_from:\n        return False\n    \n    if date_to != '*' and book[2] > date_to:\n        return False\n    \n    return True\n\ndef solve_book_search():\n    # Read number of books\n    n = int(input())\n    books = []\n    \n    # Read book details\n    for _ in range(n):\n        title = input()\n        author = input()\n        date = input()\n        books.append((title, author, date))\n    \n    # Read number of queries\n    q = int(input())\n    \n    # Process each query\n    for _ in range(q):\n        query = input().split()\n        \n        # Expand query if fewer than 4 elements\n        while len(query) < 4:\n            query.append('*')\n        \n        # Find and print matching books\n        matches = [book[0] for book in books if matches_query(book, query)]\n        \n        # Print matches with blank lines between\n        for match in matches:\n            print(match)\n        \n        # Print blank line after query unless it's the last query\n        if _ < q - 1:\n            print()\n\nsolve_book_search()",
    "timestamp": "2025-08-13 07:53:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef process_queries(books, queries):\n    for query in queries:\n        q_title, q_author, q_date_from, q_date_to = query\n        matched_books = []\n        for book in books:\n            title, author, date = book\n            # Check title condition\n            title_match = (q_title == '*' or q_title in title)\n            # Check author condition\n            author_match = (q_author == '*' or q_author in author)\n            # Check date conditions\n            date_ok = (date >= q_date_from and date <= q_date_to)\n            if title_match and author_match and date_ok:\n                matched_books.append(title)\n        # Output results for this query\n        for title in matched_books:\n            print(title)\n        # Print blank line between queries, if there was any output\n        if matched_books and query != queries[-1]:\n            print()\n\ndef main():\n    input_lines = [line.strip() for line in sys.stdin if line.strip()]\n    idx = 0\n    N = int(input_lines[idx])\n    idx += 1\n    books = []\n    for _ in range(N):\n        parts = input_lines[idx].split()\n        # Combine title parts (since title can have spaces)\n        title_parts = []\n        i = 0\n        while i < len(parts) and not parts[i].startswith('\"'):\n            i += 1\n        if i < len(parts):\n            title_start = i\n            while i < len(parts) and not parts[i].endswith('\"'):\n                i += 1\n            if i < len(parts):\n                title = ' '.join(parts[title_start:i+1])\n                # Remove quotes\n                title = title[1:-1]\n                author = parts[i+1]\n                date = parts[i+2]\n                books.append((title, author, date))\n                idx += 1\n            else:\n                # Handle unexpected format\n                pass\n        else:\n            # Handle unexpected format\n            pass\n    \n    M = int(input_lines[idx])\n    idx += 1\n    queries = []\n    for _ in range(M):\n        parts = input_lines[idx].split()\n        q_title = parts[0]\n        q_author = parts[1]\n        q_date_from = parts[2]\n        q_date_to = parts[3]\n        queries.append((q_title, q_author, q_date_from, q_date_to))\n        idx += 1\n    \n    process_queries(books, queries)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:53:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstruct Book {\n    std::string title;\n    std::string author;\n    std::string date;\n};\n\nbool matches(const Book& book, const std::string& q_title, const std::string& q_author, const std::string& q_date_from, const std::string& q_date_to) {\n    bool title_match = (q_title == \"*\" || book.title.find(q_title) != std::string::npos);\n    bool author_match = (q_author == \"*\" || book.author.find(q_author) != std::string::npos);\n    bool date_match = (q_date_from == \"*\" || book.date >= q_date_from) && (q_date_to == \"*\" || book.date <= q_date_to);\n    return title_match && author_match && date_match;\n}\n\nint main() {\n    // Example collection of books (You can replace with actual input logic)\n    std::vector<Book> books = {\n        {\"Title1\", \"Author1\", \"2022/01/01\"},\n        {\"Title2\", \"Author2\", \"2021/05/13\"},\n        {\"Title3\", \"Author3\", \"2023/02/20\"},\n    };\n\n    std::vector<std::string> queries = {\n        \"Title Author * *\",\n        \"Title2 * 2020/01/01 2022/12/31\",\n        \"* Author3 * *\"\n    };\n\n    for (const auto& query : queries) {\n        std::istringstream iss(query);\n        std::string q_title, q_author, q_date_from, q_date_to;\n        iss >> q_title >> q_author >> q_date_from >> q_date_to;\n\n        bool matched = false;\n        for (const auto& book : books) {\n            if (matches(book, q_title, q_author, q_date_from, q_date_to)) {\n                std::cout << book.title << std::endl;\n                matched = true;\n            }\n        }\n        if (matched) {\n            std::cout << std::endl; // Blank line between queries\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:41:18"
  }
]