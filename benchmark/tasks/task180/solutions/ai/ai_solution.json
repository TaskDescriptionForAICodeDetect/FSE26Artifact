[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint n;\nchar tree[1000];\nlong long dp[1000][16];\n\nvoid dfs(int node) {\n    if (2 * node + 1 >= n) {\n        // Leaf node\n        int subset = 0;\n        if (tree[node] == 'a') subset = 1;\n        else if (tree[node] == 'b') subset = 2;\n        else if (tree[node] == 'c') subset = 4;\n        else if (tree[node] == 'd') subset = 8;\n        for (int s = 0; s < 16; s++) {\n            dp[node][s] = (s == subset) ? 1 : 0;\n        }\n        return;\n    }\n    dfs(2 * node + 1);\n    dfs(2 * node + 2);\n    for (int op = 0; op < 3; op++) {\n        char op_char = \"AOX\"[op];\n        for (int s1 = 0; s1 < 16; s1++) {\n            for (int s2 = 0; s2 < 16; s2++) {\n                int res;\n                if (op_char == 'A') res = s1 & s2;\n                else if (op_char == 'O') res = s1 | s2;\n                else res = s1 ^ s2;\n                dp[node][res] = (dp[node][res] + dp[2 * node + 1][s1] * dp[2 * node + 2][s2]) % MOD;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\" %c\", &tree[i]);\n    }\n    memset(dp, 0, sizeof(dp));\n    dfs(0);\n    printf(\"%lld\\n\", dp[0][15]);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SnackTree {\n    static int MOD = 1000000007;\n    static int[] snacks = {1, 2, 4, 8};  // a, b, c, d represented as bits\n\n    static int solve() {\n        return dfs(15, 0);\n    }\n\n    static int dfs(int target, int depth) {\n        if (target == 0) return 1;\n        if (depth >= 3) return 0;\n\n        int total = 0;\n        // A (Intersection)\n        if (depth < 3) {\n            for (int left = 0; left <= target; left++) {\n                int right = target & left;\n                if (right != target) continue;\n                total = (total + dfs(left, depth + 1) * dfs(right, depth + 1)) % MOD;\n            }\n        }\n\n        // O (Union)\n        for (int left = 0; left <= target; left++) {\n            int right = target | left;\n            if (right != target) continue;\n            total = (total + dfs(left, depth + 1) * dfs(right, depth + 1)) % MOD;\n        }\n\n        // X (Symmetric Difference)\n        for (int left = 0; left <= target; left++) {\n            int right = target ^ left;\n            if (right != target) continue;\n            total = (total + dfs(left, depth + 1) * dfs(right, depth + 1)) % MOD;\n        }\n\n        return total;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solve());\n    }\n}",
    "timestamp": "2025-08-05 18:57:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count = 0;\n\nstruct Node {\n    char op;\n    Node* left;\n    Node* right;\n    int mask; // 4 bits representing subset {a,b,c,d}, e.g., 0001 is {d}, 1111 is {a,b,c,d}\n    bool is_leaf;\n};\n\nvoid buildTree(Node* &root, const string &s, int &index) {\n    if (index >= s.size()) return;\n    root = new Node();\n    if (s[index] == '(') {\n        root->is_leaf = false;\n        index++; // skip '('\n        buildTree(root->left, s, index);\n        root->op = s[index++];\n        buildTree(root->right, s, index);\n        index++; // skip ')'\n    } else {\n        root->is_leaf = true;\n        root->mask = 0;\n        if (s[index] == 'a') root->mask = 1 << 0;\n        else if (s[index] == 'b') root->mask = 1 << 1;\n        else if (s[index] == 'c') root->mask = 1 << 2;\n        else if (s[index] == 'd') root->mask = 1 << 3;\n        index++;\n    }\n}\n\nvoid compute(Node* root, int target_mask) {\n    if (root->is_leaf) {\n        root->mask = root->mask;\n        return;\n    }\n    int total = 0;\n    for (char op : {'A', 'O', 'X'}) {\n        root->op = op;\n        if (root->left) compute(root->left, target_mask);\n        if (root->right) compute(root->right, target_mask);\n        int left_mask = root->left->mask;\n        int right_mask = root->right->mask;\n        int res;\n        if (op == 'A') {\n            res = left_mask & right_mask;\n        } else if (op == 'O') {\n            res = left_mask | right_mask;\n        } else if (op == 'X') {\n            res = left_mask ^ right_mask;\n        }\n        root->mask = res;\n        if (root->mask == target_mask) {\n            if (root->op == 'A') total += 1;\n            else if (root->op == 'O') total += 1;\n            else if (root->op == 'X') total += 1;\n        }\n    }\n    count = total;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    Node* root = nullptr;\n    int index = 0;\n    buildTree(root, s, index);\n    int target_mask = (1 << 4) - 1; // 1111, representing {a,b,c,d}\n    compute(root, target_mask);\n    cout << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SETS 16\n\ntypedef struct {\n    int sets[MAX_SETS];\n    int count;\n} SetCollection;\n\nint applyOperation(int set1, int set2, char op) {\n    switch(op) {\n        case 'A': return set1 & set2;\n        case 'O': return set1 | set2;\n        case 'X': return set1 ^ set2;\n    }\n    return 0;\n}\n\nint countWays(int n) {\n    int ways = 0;\n    int totalSets = 1 << n;\n    \n    for (int mask = 0; mask < (1 << (2 * n - 1)); mask++) {\n        bool valid = true;\n        int result = 0;\n        \n        for (int i = 0; i < totalSets; i++) {\n            int left = i & ((1 << (n/2)) - 1);\n            int right = i >> (n/2);\n            int curr = 0;\n            \n            for (int j = 0; j < n - 1; j++) {\n                if (mask & (1 << j)) {\n                    if (curr == 0) {\n                        curr = applyOperation(left, right, 'A' + (mask >> (2*n-2)) % 3);\n                    } else {\n                        curr = applyOperation(curr, left, 'A' + (mask >> (2*n-2)) % 3);\n                    }\n                }\n            }\n            \n            if (curr != totalSets - 1) {\n                valid = false;\n                break;\n            }\n        }\n        \n        if (valid) ways++;\n    }\n    \n    return ways;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", countWays(n));\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint countWays(int n) {\n    vector<vector<int>> dp(1 << 4, vector<int>(4, 0));\n    \n    for (int mask = 1; mask < (1 << 4); mask++) {\n        for (int op = 0; op < 3; op++) {\n            for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n                int complementMask = mask ^ submask;\n                \n                int result;\n                if (op == 0) result = submask & complementMask;    // Intersection\n                else if (op == 1) result = submask | complementMask;  // Union\n                else result = submask ^ complementMask;  // Symmetric Difference\n                \n                if (result == (1 << 4) - 1) {\n                    dp[mask][op]++;\n                }\n            }\n        }\n    }\n    \n    int totalWays = 0;\n    for (int mask = 1; mask < (1 << 4); mask++) {\n        for (int op = 0; op < 3; op++) {\n            totalWays += dp[mask][op];\n        }\n    }\n    \n    return totalWays;\n}\n\nint main() {\n    cout << countWays(4) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int n;\n    static int[] left, right;\n    static char[] ops;\n    static int[][] dp;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        left = new int[n + 1];\n        right = new int[n + 1];\n        ops = new char[n + 1];\n        dp = new int[n + 1][16]; // 16 possible subsets (0-15)\n\n        for (int i = 1; i <= n; i++) {\n            left[i] = scanner.nextInt();\n            right[i] = scanner.nextInt();\n        }\n\n        int result = 0;\n        // Try all possible operations for the root\n        for (char op : new char[]{'A', 'O', 'X'}) {\n            ops[1] = op;\n            Arrays.fill(dp[1], 0);\n            dfs(1);\n            result += dp[1][15]; // 15 represents the subset {a,b,c,d}\n        }\n\n        System.out.println(result);\n    }\n\n    static void dfs(int node) {\n        if (left[node] == -1 && right[node] == -1) {\n            // Leaf node: initialize with the subset it represents\n            int subset = 0;\n            if (ops[node] == 'a') subset = 1;\n            else if (ops[node] == 'b') subset = 2;\n            else if (ops[node] == 'c') subset = 4;\n            else if (ops[node] == 'd') subset = 8;\n            dp[node][subset] = 1;\n            return;\n        }\n\n        dfs(left[node]);\n        dfs(right[node]);\n\n        for (int l = 0; l < 16; l++) {\n            for (int r = 0; r < 16; r++) {\n                if (dp[left[node]][l] == 0 || dp[right[node]][r] == 0) continue;\n                int res = 0;\n                if (ops[node] == 'A') res = l & r;\n                else if (ops[node] == 'O') res = l | r;\n                else if (ops[node] == 'X') res = l ^ r;\n                dp[node][res] += dp[left[node]][l] * dp[right[node]][r];\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:58:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways_to_fill_tree():\n    # There are three possible operations for internal nodes:\n    # 'A' for intersection, 'O' for union, 'X' for symmetric difference\n    operations = ['A', 'O', 'X']\n\n    # Calculate number of ways for various binary trees\n    # We need a binary tree with leaves as subsets of S = {a, b, c, d}\n    \n    # Let's prepare the subsets of S\n    S = {'a', 'b', 'c', 'd'}\n    all_subsets = [set()]\n    for snack in S:\n        all_subsets += [subset | {snack} for subset in all_subsets]\n\n    # Efficient function to perform operations on sets\n    def operation(op, s1, s2):\n        if op == 'A':\n            return s1 & s2\n        elif op == 'O':\n            return s1 | s2\n        elif op == 'X':\n            return s1 ^ s2\n\n    # We'll use a recursive helper to figure out the possible fillings\n    memo = {}\n\n    def count_ways(subsets):\n        if len(subsets) == 1:\n            return 1 if subsets[0] == S else 0\n        \n        if len(subsets) not in memo:\n            memo[len(subsets)] = {}\n        \n        subsets_tuple = tuple(map(frozenset, subsets))\n        \n        if subsets_tuple in memo[len(subsets)]:\n            return memo[len(subsets)][subsets_tuple]\n\n        n = len(subsets)\n        total_ways = 0\n\n        # Try every possible split point\n        for i in range(1, n):\n            left_subsets = subsets[:i]\n            right_subsets = subsets[i:]\n\n            # Get the results from left and right recursively\n            left_way_count = count_ways(left_subsets)\n            right_way_count = count_ways(right_subsets)\n\n            # Try all operations for the current node\n            for op in operations:\n                combined_set = operation(op, left_subsets[-1], right_subsets[0])\n                if combined_set == S:\n                    total_ways += left_way_count * right_way_count\n                \n        memo[len(subsets)][subsets_tuple] = total_ways\n        return total_ways\n\n    # Start with all subsets\n    return count_ways(all_subsets)\n\n# Output the result\nprint(count_ways_to_fill_tree())",
    "timestamp": "2025-08-13 01:40:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MidnightTeaParty {\n    private static final char[] OPERATIONS = {'A', 'O', 'X'};\n    \n    public static void main(String[] args) {\n        Set<Character> S = new HashSet<>(Arrays.asList('a', 'b', 'c', 'd'));\n        int result = countWaysToFillTree(S);\n        System.out.println(result);\n    }\n    \n    private static int countWaysToFillTree(Set<Character> S) {\n        // Note: As 'A' results in intersection, 'O' in union, and 'X' in symmetric difference,\n        // Only the operation 'O' applied to all subsets directly would result in the union of all elements in S\n        // Given the structure, we are interested in the count of combinations where 'O' results \n        // in all subsets combined resulting in all elements from S\n\n        // Assuming binary tree with 3 internal nodes like a shape of ((X Y) Z) where X, Y, Z are some operations\n\n        // Only 'O' will result in union of all subsets, which results in a set S itself\n        // There are 3 internal nodes, and each can be filled with {'A', 'O', 'X'},\n        // but to achieve a result where all snacks are received, all must be 'O'\n\n        return countWaysToCombineOperations(3, 'O');\n    }\n\n    private static int countWaysToCombineOperations(int nodes, char operation) {\n        if (operation == 'O') {\n            // All nodes must be union operations which amounts to only one valid configuration\n            return 1;\n        } else {\n            // Other operations will not result in union of all elements\n            return 0;\n        }\n    }\n}",
    "timestamp": "2025-08-13 01:40:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint countWays(int n) {\n    // Base case: if there is only one leaf node, there are no internal nodes.\n    if (n == 1) return 0;\n\n    // Number of internal nodes in a full binary tree with n leaf nodes\n    int internalNodes = n - 1;\n\n    // All possible mappings of internal nodes\n    // Each node can independently be 'A', 'O', or 'X'\n    int totalMappings = 1;\n    for (int i = 0; i < internalNodes; i++) {\n        totalMappings *= 3; // 3 choices per node ('A', 'O', 'X')\n    }\n\n    // We need at least one 'O' at one of the internal nodes to ensure full union of all elements\n    int ways = totalMappings / 3;\n\n    return ways;\n}\n\nint main() {\n    int result = countWays(4); // size of set S is 4 (a, b, c, d)\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:41:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways(n):\n    MOD = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(subset, depth):\n        if depth == 0:\n            return 1 if subset == (1 << 4) - 1 else 0\n        \n        total_ways = 0\n        for op in ['A', 'O', 'X']:\n            for left_subset in range(1 << 4):\n                right_subset = subset\n                \n                if op == 'A':\n                    result = left_subset & right_subset\n                elif op == 'O':\n                    result = left_subset | right_subset\n                else:  # 'X'\n                    result = left_subset ^ right_subset\n                \n                total_ways += dp(left_subset, depth - 1) * dp(result, depth - 1)\n                total_ways %= MOD\n        \n        return total_ways\n    \n    return dp(0, n)\n\ndef main():\n    n = int(input())\n    print(count_ways(n))\n\nif __name__ == '__main__':\n    from functools import lru_cache\n    main()",
    "timestamp": "2025-08-13 01:41:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom functools import lru_cache\n\ndef solve():\n    S = {'a', 'b', 'c', 'd'}\n    full_set = frozenset(S)\n    MOD = 10**9 + 7\n\n    def parse_tree():\n        s = sys.stdin.readline().strip()\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                # Pop until '(' is encountered\n                children = []\n                while stack[-1] != '(':\n                    children.append(stack.pop())\n                stack.pop()  # Remove '('\n                # The last popped is the operator\n                op = children.pop()\n                # The remaining are the children (left and right)\n                left = children.pop() if children else None\n                right = children.pop() if children else None\n                stack.append((op, left, right))\n            else:\n                if c in {'A', 'O', 'X'}:\n                    stack.append(c)\n                else:\n                    # It's a leaf node representing a subset\n                    subset = set()\n                    if c != '0':\n                        subset.add(c.lower())\n                    stack.append(frozenset(subset))\n        return stack[0]\n\n    root = parse_tree()\n\n    @lru_cache(maxsize=None)\n    def dfs(node):\n        if isinstance(node, frozenset):\n            # Leaf node: return 1 if the subset is the one represented, else 0\n            return {node: 1}\n        \n        op, left, right = node\n        left_dp = dfs(left)\n        right_dp = dfs(right)\n        res = {}\n        \n        for left_set in left_dp:\n            for right_set in right_dp:\n                count = left_dp[left_set] * right_dp[right_set] % MOD\n                if op == 'A':\n                    new_set = left_set & right_set\n                elif op == 'O':\n                    new_set = left_set | right_set\n                elif op == 'X':\n                    new_set = left_set ^ right_set\n                else:\n                    assert False, \"Invalid operator\"\n                new_set = frozenset(new_set)\n                if new_set in res:\n                    res[new_set] = (res[new_set] + count) % MOD\n                else:\n                    res[new_set] = count\n        return res\n\n    dp = dfs(root)\n    print(dp.get(full_set, 0) % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 01:41:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\n// Function to apply operation between two sets\nset<char> operateSets(const set<char> &left, const set<char> &right, char op) {\n    set<char> result;\n    if (op == 'A') {\n        // Intersection\n        for (auto &item : left) {\n            if (right.find(item) != right.end())\n                result.insert(item);\n        }\n    } else if (op == 'O') {\n        // Union\n        result = left;\n        for (auto &item : right) {\n            result.insert(item);\n        }\n    } else if (op == 'X') {\n        // Symmetric Difference\n        for (auto &item : left) {\n            if (right.find(item) == right.end())\n                result.insert(item);\n        }\n        for (auto &item : right) {\n            if (left.find(item) == left.end())\n                result.insert(item);\n        }\n    }\n    return result;\n}\n\n// Recursive function to evaluate tree configurations\nint countWays(int pos, vector<string> &nodes, set<char> currentSnacks) {\n    if (pos >= nodes.size() - 1) {\n        // Leaf nodes\n        set<char> leafSet(nodes[pos].begin(), nodes[pos].end());\n        currentSnacks = leafSet;\n        if (currentSnacks == set<char>{'a', 'b', 'c', 'd'}) return 1;\n        return 0;\n    } else {\n        // Internal nodes\n        int ways = 0;\n        int leftPos = 2 * pos + 1;\n        int rightPos = 2 * pos + 2;\n        for (char op : {'A', 'O', 'X'}) {\n            set<char> leftSnacks, rightSnacks;\n            ways += countWays(leftPos, nodes, leftSnacks) * countWays(rightPos, nodes, rightSnacks);\n            set<char> combinedSnacks = operateSets(leftSnacks, rightSnacks, op);\n            currentSnacks = combinedSnacks;\n            if (currentSnacks == set<char>{'a', 'b', 'c', 'd'}) ways++;\n        }\n        return ways;\n    }\n}\n\nint main() {\n    vector<string> leafNodes = {\"a\", \"b\", \"c\", \"d\"};\n    int totalWays = countWays(0, leafNodes, set<char>());\n    cout << totalWays << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:01:45"
  }
]