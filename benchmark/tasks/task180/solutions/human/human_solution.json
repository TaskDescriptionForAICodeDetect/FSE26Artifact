[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nobject Main extends App {\n\n  import scala.io.StdIn._\n\n  solve\n  def solve: Unit = {\n    val exp = readLine.trim\n    if (exp == \"END\") return\n    val leaf = Array.tabulate(readInt){_ ⇒\n      val Array(a, b, c, d) = readLine.trim.split(' ').map(_.toInt == 1)\n      Leaf(CandySet(a, b, c, d))\n    }\n    Tree.parse(exp, leaf) match {\n      case Some(r) ⇒ println(r.calPattern(CandySet(true, true, true, true)))\n      case _ ⇒ ???\n    }\n    solve\n\n  }\n  object Tree {\n    def parse(express: String, leaf: Array[Leaf]): Option[Node] = {\n      implicit val l = leaf\n      express.toList match {\n        case n Tree Nil ⇒ Some(n)\n        case _ ⇒ None\n      }\n    }\n    def unapply(arg:List[Char])(implicit leaf: Array[Leaf]): Option[(Node, List[Char])] = {\n      arg match {\n        case n::t if n.isDigit ⇒ Some(leaf(n.asDigit - 1), t)\n        case '('::(l Tree ' '::(r Tree ')'::t)) ⇒Some(new InterNode(l, r), t)\n        case _ ⇒ None\n      }\n    }\n  }\n  sealed trait Node {\n    def calPattern(candySet: CandySet): Long\n  }\n  class InterNode(val left: Node, right: Node) extends Node {\n    override def calPattern(candySet: CandySet): Long = memo(candySet.toIndex) match {\n      case Some(r) ⇒ r\n      case None ⇒\n        val and = CandySet.all.map{l ⇒\n          CandySet.all.filter(r ⇒ l.and(r) == candySet).map(r ⇒ right.calPattern(r)).sum * left.calPattern(l)\n        }.sum\n        val or = CandySet.all.map{l ⇒\n          CandySet.all.filter(r ⇒ l.or(r) == candySet).map(r ⇒ right.calPattern(r)).sum * left.calPattern(l)\n        }.sum\n        val xor = CandySet.all.map{l ⇒\n          CandySet.all.filter(r ⇒ l.xor(r) == candySet).map(r ⇒ right.calPattern(r)).sum * left.calPattern(l)\n        }.sum\n        memo(candySet.toIndex) = Some(and + or + xor)\n        and + or + xor\n    }\n    private val memo = Array.tabulate(16){_ ⇒ None: Option[Long]}\n  }\n\n  case class Leaf(state: CandySet) extends Node {\n    override def calPattern(candySet: CandySet): Long = if (candySet == state) 1 else 0\n  }\n  object CandySet{\n    val all: List[CandySet] = (0 until 4).map{_ ⇒ List(true, false)}.foldLeft(Nil::Nil:List[List[Boolean]]){case (a, b) ⇒ a.flatMap{l ⇒ b.map{r ⇒ r::l}}}.map{case a::b::c::d::Nil ⇒ CandySet(a, b, c, d); case _ ⇒ ???}\n  }\n  case class CandySet(a: Boolean, b: Boolean, c: Boolean, d: Boolean) {\n    def toIndex: Int = List(a, b, c, d).map {if (_) 1 else 0}.foldLeft(0) { case (l, r) ⇒ l * 2 + r }\n    def and(that: CandySet): CandySet = map(that)(_.&&)\n    def or(that: CandySet): CandySet = map(that)(_.||)\n    def xor(that: CandySet): CandySet = map(that)(_.^)\n    @inline\n    private def map(that: CandySet)(@inline func: Boolean ⇒ Boolean ⇒ Boolean): CandySet = CandySet(func(a)(that.a), func(b)(that.b), func(c)(that.c), func(d)(that.d))\n  }\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define A (0)\n#define O (1)\n#define X (2)\n#define PRINT_FLAG(x) for(int i = 0; i < 4; i++)printf(\"%d\", ((x) >> i) & 1); puts(\"\");\n\ntypedef struct tree {\n\tunsigned int flag;\n\tstruct tree *right;\n\tstruct tree *left;\n} TREE;\n\nint input_tree(TREE *root, char str[], int i, TREE *point[10]);\nint make_num(int depth, int num, int max_depth, TREE *root);\nunsigned int check_tree(TREE *root, int *mode_list, bool flag);\n\n\nint input_count;\nint ans;\n\nint main(void)\n{\n\tTREE root;\n\tTREE *point[10];\n\tchar str[100];\n\t\n\twhile (1){\n\t\tans = 0;\n\t\troot.right = root.left = NULL;\n\t\tinput_count = 0;\n\t\t\n\t\tfgets(str, 100, stdin);\n\t\tif (str[0] == 'E'){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tinput_tree(&root, str, 0, point);\n\t\tscanf(\"%d\", &input_count);\n\t\tif (input_count == 0){\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < input_count; i++){\n\t\t\tpoint[i]->flag = 0;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tunsigned int flag;\n\t\t\t\tscanf(\"%u\", &flag);\n\t\t\t\t\n\t\t\t\tpoint[i]->flag |= flag << j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmake_num(0, 0, input_count - 1, &root);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t}\n\treturn (0);\n}\n\nint input_tree(TREE *root, char str[], int i, TREE *point[10])\n{\n\twhile (1){\n\t\tif (str[i] == '\\0'){\n\t\t\treturn (i);\n\t\t}\n\t\t\n\t\tif (str[i] == '('){\n\t\t\troot->right = (TREE *)malloc(sizeof(TREE));\n\t\t\troot->left = (TREE *)malloc(sizeof(TREE));\n\t\t\t\n\t\t\troot->right->right = root->right->left = root->left->right = root->left->left = NULL;\n\t\t\ti = input_tree(root->left, str, i + 1, point);\n\t\t\ti = input_tree(root->right, str, i + 1, point);\n\t\t\treturn (i);\n\t\t}\n\t\tif (str[i] >= '1' && str[i] <= '9'){\n\t\t\tpoint[str[i] - '0' - 1] = root;\n\t\t\treturn (i);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint make_num(int depth, int num, int max_depth, TREE *root)\n{\n\tif (depth == max_depth){\n\t\tbool flag = false;\n\t\t\n\t\tif (check_tree(root, &num, flag) == 0xf){\n\t\t\tans++;\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tnum *= 10;\n\t\n\tfor (int i = A; i <= X; i++){\n\t\tint temp = num;\n\t\ttemp += i;\n\t\tmake_num(depth + 1, temp, max_depth, root);\n\t}\n\t\n\treturn (0);\n}\n\nunsigned int check_tree(TREE *root, int *mode_list, bool flag)\n{\n\tunsigned int ans_flag;\n\t\n\tif (root->left == NULL){\n\t\treturn (root->flag);\n\t}\n\telse {\n\t\tunsigned int flag1 = check_tree(root->left, mode_list, flag);\n\t\tunsigned int flag2 = check_tree(root->right, mode_list, flag);\n\t\t\n\t\t//if (flag)printf(\"%d\\n\", *mode_list % 10);\n\t\tswitch (*mode_list % 10){\n\t\t  case 0:\n\t\t  \tans_flag = (flag1 & flag2);\n\t\t\tbreak;\n\t\t  case 1:\n\t\t  \tans_flag = (flag1 | flag2);\n\t\t\tbreak;\n\t\t  case 2:\n\t\t  \tans_flag = (flag1 ^ flag2);\n\t\t\tbreak;\n\t\t}\n\t\t*mode_list /= 10;\n\t}\n\t\n\t/*if (flag){\n\t\tPRINT_FLAG(ans_flag);\n\t}*/\n\t\n\treturn (ans_flag);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nstring s;\nint p;\nint f[11];\nvector<int> eq()\n{\n    if (s[p] == '(')\n    {\n        ++p;\n        vector<int> l = eq();\n        ++p;\n        vector<int> r = eq();\n        ++p;\n\n        vector<int> res(16);\n        rep(i, 16) rep(j, 16)\n        {\n            int way = l[i] * r[j];\n            res[i & j] += way;\n            res[i | j] += way;\n            res[i ^ j] += way;\n        }\n        return res;\n    }\n    else if (isdigit(s[p]))\n    {\n        int id = s[p] - '0' - 1;\n        ++p;\n\n        vector<int> res(16);\n        res[f[id]] = 1;\n        return res;\n    }\n}\nint main()\n{\n    while (getline(cin, s), s != \"END\")\n    {\n        int n;\n        cin >> n;\n        rep(i, n)\n        {\n            f[i] = 0;\n            rep(j, 4)\n            {\n                int a;\n                cin >> a;\n                f[i] |= a * bin(j);\n            }\n        }\n\n        p = 0;\n        cout << eq()[15] << endl;\n        \n        cin.ignore();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <set>\nusing namespace std;\n\nint N;\nvector<int> tree[100];\nint dp[100][(1<<4)];\n\nint m;\nstring str,tmp;\nint p,len;\n\n\nint ans,cnt;\nint t[10];\n\nvoid make_tree(){\n  int k=N++;\n  if(str[p]=='('){\n    p++;\n    tree[k].push_back(N);\n    make_tree();\n    p++;\n    tree[k].push_back(N);\n    make_tree();\n    p++;\n  }else{\n    int num=str[p]-'0';\n    p++;\n    dp[k][t[num]]=1;\n  }\n}\n\nint input(){\n\n  for(int i=0;i<100;i++){\n    tree[i].clear();\n    for(int j=0;j<(1<<4);j++)dp[i][j]=0;\n  }\n\n  getline(cin,str);\n  if(str==\"END\")return 0;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    t[i]=0;\n    int a;\n    for(int j=0;j<4;j++){\n      cin>>a;\n      t[i]=t[i]*2+a;\n    }\n  }\n  getline(cin,tmp);\n  N=0;\n  p=0;\n  len=str.size();\n  make_tree();\n  return 1;\n}\n\nvoid dfs(int pos){\n  if(tree[pos].size()>0){\n    int lc=tree[pos][0];\n    int rc=tree[pos][1];\n    dfs(lc);\n    dfs(rc);\n    for(int L=0;L<(1<<4);L++){\n      for(int R=0;R<(1<<4);R++){\n\tdp[pos][L|R]+=dp[lc][L]*dp[rc][R];\n\tdp[pos][L&R]+=dp[lc][L]*dp[rc][R];\n\tdp[pos][L^R]+=dp[lc][L]*dp[rc][R];\n      }\n    }\n  }\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    cnt=0;\n    dfs(0);\n    cout<<dp[0][15]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> G[32];\nint pat[32];\n\nchar str[128];\n\nint makeTree(int &p, int &num, int &intnum)\n{\n    if (isdigit(str[p])) return (str[p++] - '0');\n    \n    int v = num++;\n    if (str[p] == '('){\n        intnum++;\n        p++; // (\n        int u1 = makeTree(p, num, intnum);\n        p++; // Space\n        int u2 = makeTree(p, num, intnum);\n        p++; // )\n        G[v].push_back(u1);\n        G[v].push_back(u2);\n    }\n    \n    return (v);\n}\n\nint dfs(int v, int &pt)\n{\n    if (G[v].size() == 0) return (pat[v]);\n    \n    int p1 = dfs(G[v][0], pt);\n    int op = pt % 3;\n    pt /= 3;\n    int p2 = dfs(G[v][1], pt);\n    \n    if (op == 0) return (p1 | p2);\n    if (op == 1) return (p1 & p2);\n    return (p1 ^ p2);\n}\n\nint main()\n{\n    \n    while (fgets(str, sizeof(str), stdin) && str[0] != 'E'){\n        for (int i = 0; i < 32; i++) G[i].clear();\n        int intnum = 0;\n        int v = 10;\n        int p = 0;\n        makeTree(p, v, intnum);\n        \n        int n;\n        scanf(\"%d\", &n); getchar();\n        for (int i = 0; i < n; i++){\n            pat[i + 1] = 0;\n            for (int j = 0; j < 4; j++){\n                int t;\n                scanf(\"%d\", &t); getchar();\n                pat[i + 1] = pat[i + 1] * 2 + t;\n            }\n        }\n        \n        int pattern = 1;\n        for (int i = 0; i < intnum; i++) pattern *= 3;\n        \n        int ret = 0;\n        for (int i = 0; i < pattern; i++){\n            int tmp = i;\n            if (dfs(10, tmp) == 15) ret++;\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\npair<int,vi> parse(string& s,vi& a,int i)\n{\n\tif(isdigit(s[i])){\n\t\tvi res(16); res[a[s[i]-'0']]=1;\n\t\treturn mp(i+1,res);\n\t}\n\t\n\ti++;\n\tpair<int,vi> p1=parse(s,a,i); i=p1.first+1;\n\tpair<int,vi> p2=parse(s,a,i); i=p2.first+1;\n\t\n\tvi res(16);\n\trep(j,16) rep(k,16){\n\t\tres[j&k]+=p1.second[j]*p2.second[k];\n\t\tres[j|k]+=p1.second[j]*p2.second[k];\n\t\tres[j^k]+=p1.second[j]*p2.second[k];\n\t}\n\treturn mp(i,res);\n}\n\nint main()\n{\n\tfor(string s;getline(cin,s),s!=\"END\";cin.ignore()){\n\t\tint n; cin>>n;\n\t\tvi a(n);\n\t\trep(i,n) rep(j,4){\n\t\t\tint x; cin>>x;\n\t\t\ta[i]|=x<<j;\n\t\t}\n\t\t\n\t\trep(i,s.size()) if(isdigit(s[i])) s[i]--;\n\t\tcout<<parse(s,a,0).second[15]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nbool next_operation(std::string &s) {\n  for (size_t i=s.length(); i--;) {\n    if (s[i] == 'A') {\n      s[i] = 'O';\n      return true;\n    } else if (s[i] == 'O') {\n      s[i] = 'X';\n      return true;\n    } else if (s[i] == 'X') {\n      s[i] = 'A';\n    }\n  }\n  return false;\n}\n\nint parse(const std::string &s, size_t &i, size_t preced=0) {\n  const std::vector<std::string> ops={\"AOX\"};\n\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      int res=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if ('0' <= s[i] && s[i] < '0'+16) {\n      return s[i++]-'0';\n    }\n    assert(false);\n  }\n\n  int lhs=parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!isupper(op)) break;\n    int rhs=parse(s, ++i, preced+1);\n    if (op == 'A') lhs &= rhs;\n    if (op == 'O') lhs |= rhs;\n    if (op == 'X') lhs ^= rhs;\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  char buf[1024];\n  scanf(\" %[^\\n]\", buf);\n  std::string s=buf;\n  if (s == \"END\") return 1;\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<int> item(n);\n  for (size_t i=0; i<n; ++i) {\n    for (int j=0; j<4; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      item[i] |= x<<j;\n    }\n  }\n\n  {\n    size_t ii=0;\n    for (size_t i=0; i<s.length(); ++i) {\n      if (isdigit(s[i])) {\n        s[i] = item[ii++]+'0';\n      } else if (s[i] == ' ') {\n        s[i] = 'A';\n      }\n    }\n  }\n\n  int res=0;\n  do {\n    size_t i=0;\n    if (parse(s, i) == 15) ++res;\n  } while (next_operation(s));\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\nclass P{\npublic:\n\tint val,l,r;\n\tP(int _val,int _l,int _r){\n\t\tval = _val;\n\t\tl = _l;\n\t\tr = _r;\n\t}\n\n\tvoid show(void){\n\t\tcout<<\"[\"<<val<<\",\"<<l<<\",\"<<r<<\"]\"<<endl;\n\t}\n};\n\nint n,idx,leaf[10];\nstring s;\nvector<P> tree;\n\nvoid mkTree(int node){\n\tif(isdigit(s[idx])){\n\t\ttree[node].val = s[idx++] - '0';\n\t\treturn;\n\t}\n\n\ttree.push_back(P(0,-1,-1));\n\ttree.push_back(P(0,-1,-1));\n\ttree[node].r = tree.size()-1;\n\ttree[node].l = tree.size()-2;\n\n\tidx++; // '('\n\tmkTree(tree[node].l);\n\tidx++; // ' '\n\tmkTree(tree[node].r);\n\tidx++; // ')'\n}\n\nmap<int,int> solve(int node){\n\tmap<int,int> res;\n\tif(tree[node].val > 0){\n\t\tres[leaf[tree[node].val-1]]++;\n\t\treturn res;\n\t}\n\n\tmap<int,int> left = solve(tree[node].l);\n\tmap<int,int> right = solve(tree[node].r);\n\n\tfor(map<int,int>::iterator i=left.begin();i!=left.end();i++){\n\t\tfor(map<int,int>::iterator j=right.begin();j!=right.end();j++){\n\t\t\tint lbit = i->first;\n\t\t\tint rbit = j->first;\n\t\t\tres[lbit & rbit] += i->second * j->second;\n\t\t\tres[lbit | rbit] += i->second * j->second;\n\t\t\tres[lbit ^ rbit] += i->second * j->second;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\twhile(getline(cin,s),s!=\"END\"){\n\t\tidx = 0;\n\t\ttree.clear();\n\t\ttree.push_back(P(0,-1,-1));\n\t\tmkTree(0);\n\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tleaf[i] = 0;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x) leaf[i] |= 1<<j;\n\t\t\t}\n\t\t}\n\n\t\tmap<int,int> rst = solve(0);\n\t\tcout<<rst[15]<<endl;\n\n\t\tgetchar(); //ツ嘉シツ行ツづづ篠つオ\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n\nusing namespace std;\n\nvector<string> leaf;\n\nvector<string> solve(string s){\n  vector<string> a, b;\n  if(s.size() == 5){\n    a = vector<string>(1, leaf[s[1]-'0']);\n    b = vector<string>(1, leaf[s[3]-'0']);\n  }else if(isdigit(s[1])){\n    a = vector<string>(1, leaf[s[1]-'0']);\n    b = solve(string(s.begin()+3, s.end()-1));\n  }else if(isdigit(s[s.size()-2])){\n    a = solve(string(s.begin()+1, s.end()-3));\n    b = vector<string>(1, leaf[s[s.size()-2]-'0']);\n  }else{\n    int x=0, k;\n    for(int i=1; i<s.size(); ++i){\n      if(s[i] == '(') ++x;\n      if(s[i] == ')') --x;\n      if(x == 0){ k=i+1; break; }\n    }\n    a = solve(string(s.begin()+1, s.begin()+k));\n    b = solve(string(s.begin()+k+1, s.end()-1));\n  }\n  vector<string> data;\n  for(int i=0; i<a.size(); ++i){\n    for(int j=0; j<b.size(); ++j){\n      string A(4,'0'), O(4,'0'), X(4,'0');\n      for(int k=0; k<4; ++k){\n\tif(a[i][k]=='1' && b[j][k]=='1') A[k]='1';\n\tif(a[i][k]=='1' || b[j][k]=='1') O[k]='1';\n\tif(a[i][k] != b[j][k]) X[k]='1';\n      }\n      data.push_back(A);\n      data.push_back(O);\n      data.push_back(X);\n    }\n  }\n  return data;\n}\n\nint main(){\n  int n, x;\n  string s;\n  while(1){\n    s.clear();\n    leaf.clear();\n    while(s.empty()) getline(cin, s);\n    if(s == \"END\") break;\n    cin >> n;\n    leaf = vector<string>(n+1);\n    for(int i=1; i<=n; ++i){\n      string t(4,'0');\n      for(int j=0; j<4; ++j){\n\tcin >> x;\n\tif(x == 1) t[j] = '1';\n      }\n      leaf[i] = t;\n    }\n    vector<string> data = solve(s);\n    int ans=0;\n    for(int i=0; i<data.size(); ++i){\n      if(data[i] == \"1111\") ++ans;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Tree[114514],m;\nmap<int,int> mp;\nvector<int> order;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1, bit);\n    int r = getBit(2*v+2, bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint getNum(string::iterator &it){\n    int res = 0;\n    while(isdigit(*it)){\n        res *= 10;\n        res += *it-'0';\n        ++it;\n    }\n    --it;\n    return res;\n}\n\nvoid makeTree(string &s){\n    memset(Tree,-1,sizeof(Tree));\n    int depth = -1;\n    string::iterator it;\n    for(it = s.begin() ; it != s.end() ; ++it){\n        if(*it == '(') depth++;\n        else if(*it == ')') depth--;\n        else if(isdigit(*it)){\n            Tree[2*depth+1] = getNum(it)-1;\n        }else{\n            ++it;\n            Tree[2*depth+2] = getNum(it)-1;\n        }\n    }\n}\n\nvoid dfs(int v,int depth){\n    if(depth == 11) return;\n    if(Tree[v] == -1){\n        mp[v] = m++;\n        dfs(2*v+1, depth+1);\n        dfs(2*v+2, depth+1);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        int res = 0;\n        makeTree(s); m = 0; dfs(0,0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[10024];\nvoid out(void);\n//((1 2) 3)\n//(1 (2 3))\n//(1 ((2 3) 4))\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 && tree[ima*2+2].mark==-1)return tree[ima].bit;\n  assert(tree[ima*2+1].mark!=-1&&tree[ima*2+2].mark!=-1);\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\n\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=10000)ima++;\n  if(ima>10000 && check(0)==(1<<4)-1)ans++;\n  else if(ima<=10000)\n    for(int i=0;i<=2;i++)tree[ima].mark=i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<10024;i++)tree[i].bit=-1,tree[i].mark=-1;\n  int ima=0,num=0,p[1024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  if(flg==0)return flg;\n\n  int m;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    mark_dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<7;i++){\n    cout << tree[i].mark<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\nstring str;\nint pos;\nint tree[32];\nint ha[10];\nint type[32];\nint maxp;\nint cnt;\n\n\nint getDigit() {\n  int s = pos;\n  int length = 0;\n  while(pos < str.length() && isdigit(str[pos])) { pos++; length++; }\n  return atoi((str.substr(s, length)).c_str());\n}\n\nvoid exp(int p) {\n  for(int i = 0; i < 2; ++i) {\n    int child = p*2 + (i+1);\n    maxp = max(maxp, child);\n    if(str[pos] == '(') {\n      tree[child] = 0;\n      pos++; exp(child); pos++;\n    } else {\n      tree[child] = getDigit();\n    }\n    if(i == 0) pos++;\n  }\n}\n\nvoid conv() {\n  fill(tree, tree+32, -1);\n  if(str[0] != '(') {\n    maxp = 1;\n    pos = 0;\n    tree[0] = getDigit();\n  } else {\n    maxp = 0;\n    tree[0] = 0;\n    pos = 1; exp(0);\n    maxp++;\n  }\n}\n\nint rec2(int p) {\n  if(tree[p] != 0) {\n    return ha[tree[p]-1];\n  } else {\n    int a[2];\n    for(int i = 0; i < 2; ++i) {\n      int child = p*2 + (i+1);\n      a[i] = rec2(child);\n    }\n    if(type[p] == 0) {\n      return a[0] & a[1];\n    } else if(type[p] == 1) {\n      return a[0] | a[1];\n    } else if(type[p] == 2) {\n      return a[0] ^ a[1];\n    }\n  }\n}\n\nvoid rec(int p) {\n  if(p == maxp) {\n    if(rec2(0) == (1<<4)-1) cnt++;\n    return;\n  }\n  if(tree[p] != 0) {\n    rec(p+1);\n  } else {\n    for(int i = 0; i < 3; ++i) {\n      type[p] = i;\n      rec(p+1);\n    }\n  }\n}\n\nvoid solve() {\n  conv();\n  cnt = 0;\n\n  rec(0);\n  cout << cnt << endl;\n}\n\nmain() {\n  while(1) {\n    getline(cin, str);\n    if(str == \"END\") break;\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n      ha[i] = 0;\n      for(int j = 0; j < 4; ++j) {\n\tint a;\n\tcin >> a;\n\tha[i] |= a << j;\n      }\n    }\n    solve();\n    getchar();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint curPos = 0;\nstring str;\nint info[18] = {};\nvector< vector<int> > g;\nint number[18] = {};\nint mx = 0;\nvoid parse(int pos){\n\t//cout << curPos << \" \" << str[curPos] << endl;\n\tmx = max(pos,mx);\n\tif( str[curPos] >= '0' && str[curPos] <= '9'){\n\t\tnumber[pos] = info[ str[curPos] - '0' - 1];\n\t\tcurPos++;\n\t\treturn;\n\t}\n\t\n\t\n\tcurPos++;\n\tg[pos].push_back(pos*2+1);\n\tparse(pos*2+1);\n\t\n\t\n\tcurPos++; // space \n\t\n\t\n\tg[pos].push_back(pos*2+2);\n\tparse(pos*2+2);\n\t\n\tcurPos++;\n\treturn;\n}\n\nint calc(int a,int b,int t){\n\tif( t == 0 ) return a & b;\n\tif( t == 1 ) return a | b;\n\treturn a^b;\n}\n\nint tmp[30] = {};\n\nvector<int> all(int pos){\n\tif( number[pos] >= 0 ){\n\t\tvector<int> u(16);\n\t\tu[number[pos]] = 1;\n\t\treturn u;\n\t}else{\n\t\tvector<int> a,b,c(16);\n\t\ta = all(pos*2+1);\n\t\tb = all(pos*2+2);\n\t\tfor(int k = 0 ; k < 3 ; k++){\n\t\t\tfor(int i = 0 ; i < 16 ; i++){\n\t\t\t\tfor(int j = 0 ; j < 16 ; j++){\n\t\t\t\t\tc[calc(i,j,k)] += a[i] * b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\t\twhile( getline(cin,str) && (str == \"\" || str == \"END\") ){ if(str == \"END\") return 0; }\n\t\t\n\t\tfor(int i = 0 ; i < 18 ; i++) number[i] = -1;\n\t\tcin >> n;\n\t\tg.clear();\n\t\tg.resize(18);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint inf = 0 , a;\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tinf |= (a<<j);\n\t\t\t}\n\t\t\tinfo[i] = inf;\n\t\t}\n\t\tcurPos = 0;\n\t\tmx = 0;\n\t\tparse(0);\n\t\t/*for(int i = 0 ; i <= mx ; i++){\n\t\t\tcout << i << \"(\" << number[i] << \")\" << \" : \";\n\t\t\tfor(int j =0 ; j < g[i].size() ; j++) cout << g[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tvector<int> answer = all(0);\n\t\tcout << answer[15] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Node{\n  int ID;\n  int N;\n  Node* p[2];\n  Node(int ID) : ID(ID){}\n  Node(int ID, int N) : ID(ID), N(N) {}\n};\nstring s;\nint L;\nint S[10];\nint R;\npair<Node*, int> parse(int k){\n  if(s[k] == '('){\n    Node* res = new Node(L++);\n    pair<Node*, int> pr = parse(k + 1);\n    res->p[0] = pr.first;\n    pair<Node*, int> pr2 = parse(pr.second + 1);\n    res->p[1] = pr2.first;\n    return make_pair(res, pr2.second + 1);\n  }else{\n    assert(isdigit(s[k]));\n    Node* node = new Node(-1, s[k] - '1');\n    return make_pair(node, k + 1);\n  }\n}\nint input(){\n  int res = 0;\n  REP(i, 4){\n    int t; cin>>t;\n    res += (t<<i);\n  }\n  return res;\n}\nint dfs(Node* p){\n  if(p->ID == -1){\n    return S[p->N];\n  }else{\n    int op = R >> (2 * p->ID) & 3;\n    int l = dfs(p->p[0]);\n    int r = dfs(p->p[1]);\n    if(l == -1 || r == -1) return -1;\n    if(op == 0){\n      return l & r;\n    }else if(op == 1){\n      return l | r;\n    }else if(op == 2){\n      return l ^ r;\n    }else if(op == 3){\n      return -1;\n    }\n  }\n}\n\nint main(){\n  while(getline(cin, s) && s != \"END\"){\n    L = 0;\n    Node* r = parse(0).first;\n    int N; cin>>N;\n    REP(i, N){\n      S[i] = input();\n    }\n    int ans = 0;\n    for(R = 0; R < 1 << (2 * L); R++){\n      if(dfs(r) == 15) ans++;\n    }\n    cout << ans << endl;\n    cin.ignore();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Tree[1145],m;\nmap<int,int> mp;\nvector<int> order;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1,bit);\n    int r = getBit(2*v+2,bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint getNum(string::iterator &it){\n    int res = 0;\n    while(isdigit(*it)){\n        res *= 10;\n        res += *it-'0';\n        ++it;\n    }\n    --it;\n    return res;\n}\n\nvoid makeTree(string &s){\n    memset(Tree,-1,sizeof(Tree));\n    int depth = -1;\n    string::iterator it;\n    for(it = s.begin() ; it != s.end() ; ++it){\n        if(*it == '(') depth++;\n        else if(*it == ')') depth--;\n        else if(isdigit(*it)){\n            Tree[2*depth+1] = getNum(it)-1;\n        }else if(*it == ' '){\n            ++it;\n            Tree[2*depth+2] = getNum(it)-1;\n        }\n    }\n}\n\nvoid dfs(int v){\n    if(Tree[v] == -1){\n        mp[v] = m++;\n        dfs(2*v+1);\n        dfs(2*v+2);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        int res = 0;\n        makeTree(s);\n        m = 0; dfs(0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[10024];\nint m;\nvoid out(void);\n\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 && tree[ima*2+2].mark==-1)return tree[ima].bit;\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\nint cnt=0;\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=10000)ima++;\n  if(ima>10000){\n    cnt++;\n    if(check(0)==(1<<4)-1)ans++;\n  }\n  else\n    for(int i=0;i<=2;i++)tree[ima].mark=i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<10024;i++)tree[i].bit=tree[i].mark=-1;\n  int ima=0,num=0,p[10024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  if(flg==0)return flg;\n\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    cnt=0;\n    mark_dfs(0);\n    int sum=1;\n    for(int i=1;i<m;i++) sum*=3;\n    assert(cnt == sum);\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<7;i++){\n    cout << tree[i].mark<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define A (0)\n#define O (1)\n#define X (2)\n#define PRINT_FLAG(x) for(int i = 0; i < 4; i++)printf(\"%d\", ((x) >> i) & 1); puts(\"\");\n\ntypedef struct tree {\n\tunsigned int flag;\n\tstruct tree *right;\n\tstruct tree *left;\n} TREE;\n\nint input_tree(TREE *root, char str[], int i, TREE *point[10]);\nint make_num(int depth, int num, int max_depth, TREE *root);\nunsigned int check_tree(TREE *root, int *mode_list, bool flag);\n\n\nint input_count;\nint ans;\n\nint main(void)\n{\n\tTREE root;\n\tTREE *point[10];\n\tchar str[100];\n\t\n\tans = 0;\n\troot.right = root.left = NULL;\n\t\n\tfgets(str, 100, stdin);\n\t\n\tinput_tree(&root, str, 0, point);\n\t\n\tscanf(\"%d\", &input_count);\n\tfor (int i = 0; i < input_count; i++){\n\t\tpoint[i]->flag = 0;\n\t\tfor (int j = 0; j < 4; j++){\n\t\t\tunsigned int flag;\n\t\t\tscanf(\"%u\", &flag);\n\t\t\t\n\t\t\tpoint[i]->flag |= flag << j;\n\t\t}\n\t}\n\t\n\tmake_num(0, 0, input_count - 1, &root);\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn (0);\n}\n\nint input_tree(TREE *root, char str[], int i, TREE *point[10])\n{\n\twhile (1){\n\t\tif (str[i] == '\\0'){\n\t\t\treturn (i);\n\t\t}\n\t\t\n\t\tif (str[i] == '('){\n\t\t\troot->right = (TREE *)malloc(sizeof(TREE));\n\t\t\troot->left = (TREE *)malloc(sizeof(TREE));\n\t\t\t\n\t\t\troot->right->right = root->right->left = root->left->right = root->left->left = NULL;\n\t\t\ti = input_tree(root->left, str, i + 1, point);\n\t\t\ti = input_tree(root->right, str, i + 1, point);\n\t\t\treturn (i);\n\t\t}\n\t\tif (str[i] >= '1' && str[i] <= '9'){\n\t\t\tpoint[str[i] - '0' - 1] = root;\n\t\t\treturn (i);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint make_num(int depth, int num, int max_depth, TREE *root)\n{\n\tif (depth == max_depth){\n\t\tbool flag = false;\n\t\t\n\t\tif (check_tree(root, &num, flag) == 0xf){\n\t\t\tans++;\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tnum *= 10;\n\t\n\tfor (int i = A; i <= X; i++){\n\t\tint temp = num;\n\t\ttemp += i;\n\t\tmake_num(depth + 1, temp, max_depth, root);\n\t}\n\t\n\treturn (0);\n}\n\nunsigned int check_tree(TREE *root, int *mode_list, bool flag)\n{\n\tunsigned int ans_flag;\n\t\n\tif (root->left == NULL){\n\t\treturn (root->flag);\n\t}\n\telse {\n\t\tunsigned int flag1 = check_tree(root->left, mode_list, flag);\n\t\tunsigned int flag2 = check_tree(root->right, mode_list, flag);\n\t\t\n\t\t//if (flag)printf(\"%d\\n\", *mode_list % 10);\n\t\tswitch (*mode_list % 10){\n\t\t  case 0:\n\t\t  \tans_flag = (flag1 & flag2);\n\t\t\tbreak;\n\t\t  case 1:\n\t\t  \tans_flag = (flag1 | flag2);\n\t\t\tbreak;\n\t\t  case 2:\n\t\t  \tans_flag = (flag1 ^ flag2);\n\t\t\tbreak;\n\t\t}\n\t\t*mode_list /= 10;\n\t}\n\t\n\t/*if (flag){\n\t\tPRINT_FLAG(ans_flag);\n\t}*/\n\t\n\treturn (ans_flag);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[10024];\nvoid out(void);\n\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 && tree[ima*2+2].mark==-1)return tree[ima].bit;\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\nint cnt=0;\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=10000)ima++;\n  if(ima>1000){\n    cnt++;\n    if(check(0)==(1<<4)-1)ans++;\n  }\n  else\n    for(int i=0;i<=2;i++)tree[ima].mark=i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<10024;i++)tree[i].bit=tree[i].mark=-1;\n  int ima=0,num=0,p[1024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  if(flg==0)return flg;\n  int m;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    mark_dfs(0);\n    assert(ans>=0);\n    cout<<ans<<endl;\n    // cout <<cnt<<endl;\n  }\n  return 0;\n}\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<20;i++){\n    cout << tree[i].bit<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint curPos = 0;\nstring str;\nint info[128] = {};\nvector< vector<int> > g;\nint number[128] = {};\nint mx = 0;\nvoid parse(int pos){\n\t//cout << curPos << \" \" << str[curPos] << endl;\n\tmx = max(pos,mx);\n\tif( str[curPos] >= '0' && str[curPos] <= '9'){\n\t\tnumber[pos] = info[ str[curPos] - '0' - 1];\n\t\tcurPos++;\n\t\treturn;\n\t}\n\t\n\tassert(str[curPos] == '(');\n\tcurPos++;\n\tg[pos].push_back(pos*2+1);\n\tparse(pos*2+1);\n\t\n\tassert(str[curPos] == ' ');\n\tcurPos++; // space \n\t\n\t\n\tg[pos].push_back(pos*2+2);\n\tparse(pos*2+2);\n\tassert(str[curPos] == ')');\n\tcurPos++;\n\treturn;\n}\n\nint calc(int a,int b,int t){\n\tif( t == 0 ) return a & b;\n\tif( t == 1 ) return a | b;\n\treturn a^b;\n}\n\nint tmp[30] = {};\n\nvector<int> all(int pos){\n\tif( number[pos] >= 0 ){\n\t\tvector<int> c(16);\n\t\tc[number[pos]] = 1;\n\t\t//cout << pos << \" : \";\n\t\t//for(int i = 0 ; i < 16 ; i++) cout << c[i] << \" \"; cout << endl;\n\t\treturn c;\n\t}else{\n\t\tvector<int> a,b,c(16);\n\t\ta = all(pos*2+1);\n\t\tb = all(pos*2+2);\n\t\tfor(int k = 0 ; k < 3 ; k++){\n\t\t\tfor(int i = 0 ; i < 16 ; i++){\n\t\t\t\tfor(int j = 0 ; j < 16 ; j++){\n\t\t\t\t\tc[calc(i,j,k)] += a[i] * b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << pos << \" : \";\n\t\t//for(int i = 0 ; i < 16 ; i++) cout << c[i] << \" \"; cout << endl;\n\t\treturn c;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\t\twhile( getline(cin,str) && (str == \"\" || str == \"END\") ){ if(str == \"END\") return 0; }\n\t\tfor(int i = 0 ; i < 128 ; i++) number[i] = -1;\n\t\tcin >> n;\n\t\tg.clear();\n\t\tg.resize(128);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint inf = 0 , a;\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tinf |= (a<<j);\n\t\t\t}\n\t\t\tinfo[i] = inf;\n\t\t}\n\t\tstr += \"~\";\n\t\tcurPos = 0;\n\t\tmx = 0;\n\t\tparse(0);\n\t\tassert(str[curPos] == '~');\n\t\t/*for(int i = 0 ; i <= mx ; i++){\n\t\t\tcout << i << \"(\" << number[i] << \")\" << \" : \";\n\t\t\tfor(int j =0 ; j < g[i].size() ; j++) cout << g[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tvector<int> answer = all(0);\n\t\tcout << answer[15] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\n\nstring str;\nint pos;\n\nint S[20];\nint n;\nint ans;\n\nint getnum(){\n  int l=0,r=0;\n  char c;\n  if(str[pos]=='('){\n    ++pos;\n    l=getnum();\n  }else{\n    ++pos;\n    return S[str[pos-1]-'0'];\n  }\n\n\n  c=str[pos];\n  ++pos;\n\n  r=getnum();\n\n  ++pos;\n\n  switch(c){\n  case 'A':\n    return l&r;\n  case 'O':\n    return l|r;\n  }\n  return l^r;\n}\n  \nvoid dfs(int idx){\n  while(idx<str.size() && str[idx]!=' ')++idx;\n  if(idx==str.size()){\n    //cout<<str<<endl;\n    pos=0;\n    int st=getnum();\n    //cout<<st<<endl;\n    if(st==15)++ans;\n    return;\n  }\n\n  str[idx]='A';\n  dfs(idx);\n  str[idx]='O';\n  dfs(idx);\n  str[idx]='X';\n  dfs(idx);\n  str[idx]=' ';\n}\n\nmain(){\n  while(getline(cin,str)){\n    if(str==\"END\")break;\n    rep(i,str.size()){\n      if(isdigit(str[i]))str[i]--;\n    }\n\n    string tss;\n    getline(cin,tss);\n    stringstream tsin(tss);\n    tsin>>n;\n    rep(i,n){\n\n      getline(cin,tss);\n      stringstream sin(tss);\n      S[i]=0;\n      rep(j,4){\n\tint t;\n\tsin>>t;\n\tS[i]|=t<<j;\n      }\n    }\n    ans=0;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\n// <TREE> := (<LEAF><OPE><LEAF>)\n// <LEAF> := (<TREE>) | <NUMBER>\n\nP tree(const string& expr,int sweets[16],int pos);\nP leaf(const string& expr,int sweets[16],int pos);\n\nP tree(const string& expr,int sweets[16],int pos){\n  int set = 0;\n  if(expr[pos] == '('){\n    P r1 = leaf(expr,sweets,pos + 1);\n    pos = r1.first;\n    char ope = expr[pos];\n    P r2 = leaf(expr,sweets,pos+1);\n    if(ope == 'A'){\n      set |= (r1.second & r2.second);\n    }\n    else if(ope == 'O'){\n      set |= (r1.second | r2.second);\n    }\n    else if(ope == 'X'){\n      set |= (r1.second ^ r2.second);\n    }\n    pos = r2.first;\n  }\n  return P(pos,set);\n}\n\nP leaf(const string& expr,int sweets[16], int pos){\n  if(expr[pos] == '('){\n    P r = tree(expr,sweets,pos);\n    pos = r.first + 1;\n    return P(pos,r.second);\n  }\n  else{\n    return P(pos+1,sweets[expr[pos] - '0']);\n  }\n}\n\nint dfs(string expr,int sweets[16],int pos,int N){\n  if(pos >= expr.size()){\n    P r = tree(expr,sweets,0);\n    if(r.second == (1<<4) - 1){\n      return 1;\n    }\n    else{\n      return 0;\n    }\n  }\n\n  int res = 0;\n  const char ope[] = {'A','O','X'};\n  if(expr[pos] == ' '){\n    for(int i = 0; i < 3; i++){\n      expr[pos] = ope[i];\n      res += dfs(expr,sweets,pos+1,N);\n    }\n  }\n  else{\n    res += dfs(expr,sweets,pos+1,N);\n  }\n  return res;\n}\n\nint main(){\n  string expr;\n  while(getline(cin,expr)){\n    if(expr == \"END\") break;\n    int N;\n    string N_str;\n    getline(cin,N_str);\n    N = atoi(N_str.c_str());\n    int sweets[16];\n    for(int i = 1; i <= N; i++){\n      int bit = 0;\n      string flag_str;\n      getline(cin,flag_str);\n      for(int j = 0; j <= 6; j+=2){\n        if(flag_str[j] - '0'){\n          bit |= (1<<(j/2));\n        }\n      }\n      sweets[i] = bit;\n    }\n    printf(\"%d\\n\",dfs(expr,sweets,0,N));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef map<int, int> MII;\ntypedef pair<int, int> PII;\n\nint D[11];\nstring s;\nint ns;\nint k;\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\nint toInt( char c ) {\n    return c - '0';\n}\n\nMII solve() {\n    MII res;\n    \n    if ( isNumber( s[k] ) ) {\n        res[D[toInt(s[k++])-1]] ++;\n        return res;\n    }\n\n    k ++;\n    MII left = solve();\n    k ++;\n    MII right = solve();\n    k ++;\n\n    for ( MII::iterator it_i = left.begin(); it_i != left.end(); ++ it_i ) {\n        for ( MII::iterator it_j = right.begin(); it_j != right.end(); ++ it_j ) {\n            PII l = *it_i;\n            PII r = *it_j;\n            int num = l.second * r.second;\n            res[l.first & r.first] += num;\n            res[l.first | r.first] += num;\n            res[l.first ^ r.first] += num;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    while ( getline( cin, s ) ) {\n        if ( s == \"END\" ) break;\n        ns = s.size();\n        \n        int n;\n        cin >> n;\n        for ( int i = 0; i < n; ++ i ) {\n            D[i] = 0;\n        }\n        for ( int i = 0; i < n; ++ i ) {\n            for ( int j = 0; j < 4; ++ j ) {\n                int d;\n                cin >> d;\n                if ( d ) D[i] |= 1 << j;\n            }\n        }\n        cin.ignore();\n        cin.clear();\n\n        k = 0;\n        MII res = solve();\n        cout << res[15] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Tree[1<<12],m;\nmap<int,int> mp;\nvector<int> order;\nstring::iterator it;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1, bit);\n    int r = getBit(2*v+2, bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint makeTree(int v){\n    if(*it == '('){\n        ++it;\n        char cl = *it;\n        int l = makeTree(2*v+1);\n        if(isdigit(cl)){\n            Tree[2*v+1] = l;\n        }\n        ++it;\n        char cr = *it;\n        int r = makeTree(2*v+2);\n        if(isdigit(cr)){\n            Tree[2*v+2] = r;\n        }\n        ++it;\n    }else if(isdigit(*it)){\n        int num = ((*it - '0') - 1);\n        ++it;\n        return num;\n    }\n    return -1;\n}\n\nvoid dfs(int v){\n    if(Tree[v] == -1){\n        mp[v] = m++;\n        dfs(2*v+1);\n        dfs(2*v+2);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        int res = 0;\n        memset(Tree,-1,sizeof(Tree));\n        it = s.begin();\n        makeTree(0); m = 0; dfs(0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for(int i = m; i < int(n); ++i)\n\nstring str;\nint n;\n\nint bit[10];\n\nvoid f(string s, int res[]) {\n  //cout << s << endl;\n  rep (i, 20) res[i] = 0;\n  if (s[0] != '(') {\n    res[bit[atoi(s.c_str()) - 1]] = 1;\n    //cout << bit[atoi(s.c_str()) - 1] << endl;\n    return;\n  }\n  int count = 0;\n  int left[20], right[20];\n  repn (i, 1, s.size() - 1) {\n    if (s[i] == '(') ++count;\n    if (s[i] == ')') --count;\n    if (s[i] == ' ' && count == 0) {\n      f(s.substr(1, i - 1), left);\n      f(s.substr(i + 1, s.size() - i - 2), right);\n    }\n  }\n  rep (i, 20) res[i] = 0;\n  rep (i, 16) rep (j, 16) {\n    if (left[i] && right[j]) {\n      ++res[i & j];\n      ++res[i | j];\n      ++res[i ^ j];\n    }\n  }\n}\n\nint main() {\n  for (;;) {\n    getline(cin, str);\n    if (str == \"END\") break;\n    cin >> n;\n    rep (i, n) {\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      bit[i] = 8 * a + 4 * b + 2 * c + d;\n    }\n    int res[20];\n    f(str, res);\n    cout << res[15] << endl;\n    getline(cin, str);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<bitset>\n#include<cstdio>\n#include<cassert>\n#include<set>\n#include<sstream>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 20\n\nusing namespace std;\n\nstring parse;\nchar  cparse[MAX];\nint N,sweets[MAX];\n\nset<vector<char> > ans;\nchar opr[] = {'&','|','^'};\n\nint exp(int&,int&,vector<char>&);\n\nint fact(int &cur,int &ocnt,vector<char> &vec)\n{\n  int p;\n  if(parse[cur] == '(')\n    {\n      cur++;\n      p = exp(cur,ocnt,vec);\n      cur++;\n      return p;\n    }\n  else\n    {\n      p = parse[cur]-'0';\n      cur++;\n      return sweets[p-1];\n    }\n}\n\nint exp(int &cur,int &ocnt,vector<char> &vec)\n{\n  int p;\n  p = fact(cur,ocnt,vec);\n  if(ocnt < vec.size())\n    {\n      int q = fact(cur,ocnt,vec);\n      int ret;\n      if(vec[ocnt] == '&')ret = p & q;\n      if(vec[ocnt] == '|')ret = p | q;\n      if(vec[ocnt] == '^')ret = p ^ q;\n      ocnt++;\n      return ret;\n    }\n  return p;\n}\n\n\nbool check(vector<char> &vec)\n{\n  int cur = 0;\n  int ocnt = 0;\n  int res = exp(cur,ocnt,vec);\n  return res == (1<<4)-1;\n}\n\nvoid dfs(int cur,vector<char> &vec)\n{\n  if(cur >= N-1)\n    {\n      if(check(vec))ans.insert(vec);\n      return;\n    }\n\n  rep(i,3)\n    {\n      vec[cur] = opr[i];\n      dfs(cur+1,vec);\n    }\n\n}\n\nvoid change()\n{\n  stringstream ss;\n  ss << parse;\n  string content = \"\";\n  while(!(ss>>parse).fail())content += parse;\n  parse = content;\n}\n\nint main()\n{\n  while(getline(cin,parse),parse != \"END\")\n    {\n      change();\n      ans.clear();\n\n      cin >> N;\n      rep(i,N)\n\t{\n\t  sweets[i] = 0;\n\t  rep(j,4)\n\t    {\n\t      int bit;\n\t      cin >> bit;\n\t      if(bit)\n\t\t{\n\t\t  sweets[i] |= (1<<j);\n\t\t}\n\t    }\n\t}\n\n      vector<char> vec(N-1);\n      dfs(0,vec);\n\n      cout << ans.size() << endl;\n      cin.ignore();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <set>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint sits[11];\nint n;\n\nmultiset<int> analysis(string str){\n  if(str[0]!='('){\n\t  multiset<int> si;\n\t  si.insert(sits[atoi(str.c_str())]);\n\t  return si;\n  }\n  else{\n\t  multiset<int> si;\n    stack<char> s;\n\n\tfor(int i = 0; i < str.size(); i++){\n      if(str[i]=='('){\n\ts.push('(');\n      }\n      else if(str[i]==')'){\n\ts.pop();\n      }\n      else{\n\tif(s.size()==1&&str[i]==' '){\n\t  // ツ閉ェツ環つオツづ催帰\n\t\tstring str1=str.substr(1,i-1);\n\t\tstring str2=str.substr(i+1,str.size()-i-2);\n\n\t\tmultiset<int> s1 = analysis(str1);\n\t\tmultiset<int> s2 = analysis(str2);\n\t  // union\n\t  {\n\t    for(multiset<int>::iterator it = s1.begin(); it!=s1.end(); it++){\n\t      for(multiset<int>::iterator iit = s2.begin(); iit!=s2.end(); iit++){\n\t\tsi.insert((*it)|(*iit));\n\t      }\n\t    }\n\t  }\n\t  // partition\n\t  {\n\t    for(multiset<int>::iterator it = s1.begin(); it!=s1.end(); it++){\n\t      for(multiset<int>::iterator iit = s2.begin(); iit!=s2.end(); iit++){\n\t\tsi.insert((*it)&(*iit));\n\t      }\n\t    }\n\t  }\n\t  // diff\n\t  {\n\t    for(multiset<int>::iterator it = s1.begin(); it!=s1.end(); it++){\n\t      for(multiset<int>::iterator iit = s2.begin(); iit!=s2.end(); iit++){\n\t\tsi.insert((*it)^(*iit));\n\t      }\n\t    }\n\t  }\n\t  return si;\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n\n  string str;\n  while(getline(cin,str)&&str!=\"END\"){\n\t  cin>>n;\n    for(int i = 0; i < n; i++){\n      int s=0;\n      for(int j = 0; j < 4; j++){\n\tint b;\n\tcin>>b;\n\tif(b==1)\n\t  s+=(int)pow(2.0,j);\n      }\n      sits[i+1]=s;\n    }\n\tmultiset<int> ms = analysis(str);\n\tint cnt=0;\n\tfor(multiset<int>::iterator it = ms.begin(); it!= ms.end(); it++){\n\t\tif(*it==15)\n\t\t\tcnt++;\n\t}\n\tcout<<cnt<<endl;\n\tgetline(cin,str);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nstruct Node {\n    int num;\n    int leaf;\n    Node *left,*right;\n};\n\nint p,inm;\nNode* parse(string &s) {\n    Node *ret = new Node();\n    if(isdigit(s[p])) {\n        ret->num = s[p] - '0' -1;\n        ret->left = ret->right = NULL;\n        p++;\n        return ret;\n    }else if(s[p] == '(') {\n        p++;\n        ret->num = inm++;\n        ret->left = parse(s);\n        if(s[p] == ' ') p++;\n        ret->right = parse(s);\n        if(s[p] == ')') p++;\n        return ret;\n    }\n\n    assert(false);\n}\n\nvoid track(Node *v,int n,int m) {\n    if(v->right == NULL && v->left == NULL && v->num == n) {\n        v->leaf = m;\n        return;\n    }else if(v->right == NULL && v->left == NULL) {\n        return;\n    } else {\n        track(v->left,n,m);\n        track(v->right,n,m);\n    }\n}\n\nint check(string &s,Node *root) {\n    if(root->left == NULL && root->right == NULL) return root->leaf;\n    int l = check(s,root->left);\n    int r = check(s,root->right);\n\n//    cout<<root->num<<\" \"<<l<<\" \"<<r<<endl;\n    if(s[root->num] == 'A') return l&r;\n    else if(s[root->num] == 'O') return l|r;\n    else if(s[root->num] == 'X') return l^r;\n    assert(false);\n}\n\nint ok;\nvoid dfs(int d,string &s,Node *root) {\n    if(d == inm) {\n        int k = check(s,root);\n//        cout<<s<<\" \"<<k<<endl;\n        if(k == 15) ok++;\n        return;\n    }\n\n    s[d] = 'A';\n    dfs(d+1,s,root);\n    s[d] = 'O';\n    dfs(d+1,s,root);\n    s[d] = 'X';\n    dfs(d+1,s,root);\n}\n\nint main() {\n    string s;\n    int n,l,m;\n    while(getline(cin, s)) {\n        if(s == \"END\") break;\n        ok = p = inm = 0;\n        Node *root = parse(s);\n        cin>>n;\n\n        for(int i=0; i<n; ++i) {\n            m = 0;\n            for(int k=0; k<4; ++k) {\n                cin>>l;\n                if(l == 1) {\n                    m |= (1<<k);\n                }\n            }\n            track(root,i,m);\n        }\n\n\n        string s(inm,'.');\n        dfs(0,s,root);\n        cout<<ok<<endl;\n        cin.ignore();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<string>\n#include<iostream>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint subset[8];\n\nint TREE(const string &,int &);\nint LEAF(const string &,int &);\nchar OPE(const string &,int &);\n\nint TREE(const string &exp,int &idx){\n\tif(isdigit(exp[idx]))\treturn LEAF(exp,idx);\n\n\tidx++;\n\tint a=TREE(exp,idx);\n\tchar o=OPE(exp,idx);\n\tint b=TREE(exp,idx);\n\tidx++;\n\n\tif     (o=='a')\treturn a&b;\n\telse if(o=='o')\treturn a|b;\n\telse\t\t\treturn a^b;\n}\n\nint LEAF(const string &exp,int &idx){\n\treturn subset[exp[idx++]-'0'-1];\n}\n\nchar OPE(const string &exp,int &idx){\n\treturn exp[idx++];\n}\n\nint parse(string s){\n\tint idx=0;\n\tstring exp=s;\n\treturn TREE(exp,idx)==15;\n}\n\nint main(){\n\tfor(string s;getline(cin,s),s!=\"END\";){\n\t\tint len=s.length();\n\t\tint n;\tcin>>n;\n\t\trep(i,n){\n\t\t\tsubset[i]=0;\n\t\t\trep(j,4){\n\t\t\t\tint t;\tcin>>t;\n\t\t\t\tsubset[i]|=t<<j;\n\t\t\t}\n\t\t}\n\t\tcin.ignore();\n\n\t\tint spnum=0,sppos[7];\n\t\trep(i,len) if(s[i]==' ') sppos[spnum++]=i;\n\n\t\tint cnt=0;\n\t\tchar op[]=\"aox\";\n\t\trep(i,(int)pow(3.,spnum)){\n\t\t\tint k=i;\n\t\t\tstring exp=s;\n\t\t\trep(j,spnum){\n\t\t\t\texp[sppos[j]]=op[k%3];\n\t\t\t\tk/=3;\n\t\t\t}\n\t\t\tif(parse(exp))\tcnt++,cout<<exp<<endl;\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<sstream>\n\nusing namespace std;\n\nstruct data{\n  int num[4];\n};\n\nint info[9][4];\n\nbool isJoint(string s){\n  int p = 0;\n \n  for(int i = 0; i < s.length(); i++)\n    if(s[i] == '(' || s[i] == ')') p++;\n \n  return p==2;\n}\n\n\ndata mul(int n1,int n2){\n  data d;\n\n  for(int i = 0; i < 4; i++)\n    d.num[i] = (info[n1][i] && info[n2][i]);\n\n  return d;\n}\n\ndata add(int n1,int n2){\n  data d;\n  \n  for(int i = 0; i < 4; i++)\n    d.num[i] = (info[n1][i] || info[n2][i]);\n\n  return d;\n}\n\n\ndata opp(int n1,int n2){\n  data d;\n\n  for(int i = 0; i < 4; i++)\n    d.num[i] = (info[n1][i] != info[n2][i]);\n\n  return d;\n}\n\nvector<data> getVV(vector<data> V1, vector<data> V2){\n  vector<data> V;\n\n  for(int i = 0; i < V1.size(); i++)\n    for(int j = 0; j < V2.size(); j++){\n      data d;\n\n      for(int k = 0; k < 4; k++)\n\td.num[k] = (V1[i].num[k]&&V2[j].num[k]);\n      V.push_back(d);\n\n      for(int k = 0; k < 4; k++)\n\td.num[k] = (V1[i].num[k]||V2[j].num[k]);\n      V.push_back(d);\n\n\n      for(int k = 0; k < 4; k++)\n\td.num[k] = (V1[i].num[k]!=V2[j].num[k]);\n      V.push_back(d);\n    }\n\n  return V;\n}\n\nvector<data> getV(int n1, int n2){\n  data d[3];\n\n  vector<data> V;\n  d[0] = mul(n1,n2);\n  d[1] = add(n1,n2);\n  d[2] = opp(n1,n2);\n\n  for(int i = 0; i < 3; i++)\n    V.push_back(d[i]);\n  return V;\n}\n\nbool isnum(string s){\n\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] == '(' || s[i] == ')') return false;\n\n  return true;\n}\n\nvector<data> make(string s){\n\n  //cout << \"s \" << s << endl;\n\n  if(isnum(s)){\n\n    vector<data> V;\n\n    stringstream ss(s);\n    int a;\n    ss >> a;\n    data d;\n\n    for(int i = 0; i < 4; i++)\n      d.num[i] = info[a][i];\n    V.push_back(d);\n    return V;\n\n  }else if(isJoint(s)){\n    int n1 = 0,n2 = 0;\n    int pos = 1;\n\n    while(s[pos] != ' '){\n      n1 *= 10;\n      n1 += s[pos]-'0';\n      pos++;\n    } \n    pos++;\n\n    while(s[pos] != ')'){\n      n2 *= 10;\n      n2 += s[pos]-'0';\n      pos++;\n    }\n    \n    vector<data> V = getV(n1,n2);\n\n    return V;\n  }else{\n    int p = 0;\n    string s1 = \"\",s2 = \"\";\n    int pos;\n\n    for(int i = 1; i < s.length()-1; i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(s[i] == ' ' && p == 0){\n\tpos = i;\n\tbreak;\n      }\n      s1+=s[i];\n    }\n\n    for(int i = pos+1; i < s.length()-1; i++)\n      s2+=s[i];\n\n    return getVV(make(s1),make(s2));\n  }\n\n}\n\nint main(){\n\n\n  string s;\n  while(getline(cin,s) && s != \"END\"){\n    int num;\n    cin >> num;\n\n    for(int i = 1; i <= num; i++)\n      for(int j = 0; j < 4; j++)\n\tcin >> info[i][j];\n\n    vector<data> V = make(s);\n    \n    int ans = 0;\n\n    for(int i = 0; i < V.size(); i++)\n      if(V[i].num[0] == 1 && V[i].num[1] == 1 && \n\t V[i].num[2] == 1 && V[i].num[3] == 1) ans++;\n\n\n    cout << ans << endl;\n    getline(cin,s);\n \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nstruct bt{\n  int a,b,c,d;\n  int e;\n  struct bt* l;\n  struct bt* r;\n};\nint f(int a[][4],string s,struct bt* p,int e){\n  int i,j;\n  if(s[0]=='('){\n    p->l=(struct bt*)malloc(sizeof(struct bt));\n    p->r=(struct bt*)malloc(sizeof(struct bt));\n    p->e=e;\n    e++;\n    if(s[1]=='('){\n      j=1;\n      for(i=2;j;i++){\n\tif(0){\n\t}else if(s[i]=='('){\n\t  j++;\n\t}else if(s[i]==')'){\n\t  j--;\n\t}\n      }\n      e=f(a,s.substr(1,i-1),p->l,e);\n    }else{\n      e=f(a,s.substr(1,1),p->l,e);\n    }\n    if(s[s.length()-2]==')'){\n      j=1;\n      for(i=s.length()-3;j;i--){\n\tif(0){\n\t}else if(s[i]==')'){\n\t  j++;\n\t}else if(s[i]=='('){\n\t  j--;\n\t}\n      }\n      e=f(a,s.substr(i,s.length()-i),p->r,e);\n    }else{\n      e=f(a,s.substr(s.length()-2,1),p->r,e);\n    }\n  }else{\n    p->l=NULL;\n    p->r=NULL;\n    p->a=a[s[0]-'1'][0];\n    p->b=a[s[0]-'1'][1];\n    p->c=a[s[0]-'1'][2];\n    p->d=a[s[0]-'1'][3];\n  }\n  return e;\n}\nstruct bt g(struct bt* z,int i){\n  struct bt a,b,c;\n  if(z->l==NULL){\n    return *z;\n  }else{\n    a=g(z->l,i);\n    b=g(z->r,i);\n    if(0){\n    }else if(i/(int)pow(3,z->e)%3==0){\n      c.a=a.a&b.a;\n      c.b=a.b&b.b;\n      c.c=a.c&b.c;\n      c.d=a.d&b.d;\n    }else if(i/(int)pow(3,z->e)%3==1){\n      c.a=a.a|b.a;\n      c.b=a.b|b.b;\n      c.c=a.c|b.c;\n      c.d=a.d|b.d;\n    }else if(i/(int)pow(3,z->e)%3==2){\n      c.a=a.a^b.a;\n      c.b=a.b^b.b;\n      c.c=a.c^b.c;\n      c.d=a.d^b.d;\n    }\n    return c;\n  }\n}\nint main(){\n  int i,j;\n  int a[9][4],n,e;\n  int sm;\n  string s;\n  struct bt c;\n  struct bt* z;\n  while(getline(cin,s)&&s!=\"END\"){\n    cin>>n;\n    for(i=0;i<n;i++)\n      for(j=0;j<4;j++)\n\tcin>>a[i][j];\n    z=(struct bt*)malloc(sizeof(struct bt));\n    e=f(a,s,z,0);\n    sm=0;\n    for(i=0;i<(int)pow(3,e);i++){\n\tc=g(z,i);\n\tsm+=c.a&c.b&c.c&c.d;\n    }\n    cout<<sm<<endl;\n    getline(cin,s);\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint curPos = 0;\nstring str;\nint info[128] = {};\nvector< vector<int> > g;\nint number[128] = {};\nint mx = 0;\nvoid parse(int pos){\n\t//cout << curPos << \" \" << str[curPos] << endl;\n\tmx = max(pos,mx);\n\tif( str[curPos] >= '0' && str[curPos] <= '9'){\n\t\tnumber[pos] = info[ str[curPos] - '0' - 1];\n\t\tcurPos++;\n\t\treturn;\n\t}\n\t\n\t\n\tcurPos++;\n\tg[pos].push_back(pos*2+1);\n\tparse(pos*2+1);\n\t\n\t\n\tcurPos++; // space \n\t\n\t\n\tg[pos].push_back(pos*2+2);\n\tparse(pos*2+2);\n\t\n\tcurPos++;\n\treturn;\n}\n\nint calc(int a,int b,int t){\n\tif( t == -1 ) return a & b;\n\tif( t == -2 ) return a | b;\n\treturn a^b;\n}\n\nint tmp[30] = {};\n\n\nint all(int pos){\n\tif( tmp[pos] >= 0 ){\n\t\treturn number[pos];\n\t}else{\n\t\treturn calc(all(pos*2+1),all(pos*2+2),tmp[pos]);\n\t}\n}\n\nint answer = 0;\nint dfs(int pos){\n\tif(pos == mx+1){\n\t\tint r = all(0);\n\t\tanswer +=r == 15;\n\t\treturn 0;\n\t}\n\tif( number[pos] == -1){\n\t\tfor(int i = 1 ; i <= 3 ; i++){\n\t\t\ttmp[pos] = -i;\n\t\t\tdfs(pos+1);\n\t\t}\n\t}else{\n\t\ttmp[pos] = number[pos];\n\t\tdfs(pos+1);\n\t}\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(getline(cin,str) && str != \"END\"){\n\t\tfor(int i = 0 ; i < 128 ; i++) number[i] = -1;\n\t\tcin >> n;\n\t\tg.clear();\n\t\tg.resize(128);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint inf = 0 , a;\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tinf |= (a<<j);\n\t\t\t}\n\t\t\tinfo[i] = inf;\n\t\t}\n\t\tcurPos = 0;\n\t\tmx = 0;\n\t\tparse(0);\n\t\t/*for(int i = 0 ; i <= mx ; i++){\n\t\t\tcout << i << \"(\" << number[i] << \")\" << \" : \";\n\t\t\tfor(int j =0 ; j < g[i].size() ; j++) cout << g[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tanswer = 0;\n\t\tdfs(0);\n\t\tcout << answer << endl;\n\t\tgetline(cin,str);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<string>\n#include<iostream>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint subset[10];\n\n/*\n\t<TREE> ::= <LEAF>|(<TREE><OPE><TREE>)\n\t<LEAF> ::= 1,2,..,8\n\t<OPE>  ::= a,o,x\n*/\nint TREE(const string &,int &);\nint LEAF(const string &,int &);\nchar OPE(const string &,int &);\n\nint TREE(const string &exp,int &idx){\n\tif(isdigit(exp[idx]))\treturn LEAF(exp,idx);\n\n\tidx++;\n\tint a=TREE(exp,idx);\n\tchar o=OPE(exp,idx);\n\tint b=TREE(exp,idx);\n\tidx++;\n\n\tif     (o=='a')\treturn a&b;\n\telse if(o=='o')\treturn a|b;\n\telse\t\t\treturn a^b;\n}\n\nint LEAF(const string &exp,int &idx){\n\treturn subset[exp[idx++]-'0'-1];\n}\n\nchar OPE(const string &exp,int &idx){\n\treturn exp[idx++];\n}\n\nint parse(string s){\n\tint idx=0;\n\tstring exp=s;\n\treturn TREE(exp,idx)==15;\n}\n\nint main(){\n\tfor(string s;getline(cin,s),s!=\"END\";){\n\t\tint len=s.length();\n\t\tint n;\tcin>>n;\n\t\trep(i,n){\n\t\t\tsubset[i]=0;\n\t\t\trep(j,4){\n\t\t\t\tint t;\tcin>>t;\n\t\t\t\tsubset[i]|=t<<j;\n\t\t\t}\n\t\t}\n\t\tcin.ignore();\n\n\t\tint spnum=0,sppos[8];\n\t\trep(i,len) if(s[i]==' ') sppos[spnum++]=i;\n\n\t\tint cnt=0;\n\t\tchar op[]=\"aox\";\n\t\trep(i,(int)pow(3.,spnum)){\n\t\t\tint k=i;\n\t\t\tstring exp=s;\n\t\t\trep(j,spnum){\n\t\t\t\texp[sppos[j]]=op[k%3];\n\t\t\t\tk/=3;\n\t\t\t}\n\t\t\tif(parse(exp))\tcnt++;\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M;\nvector<int> vs;\nstring S;\nstring::const_iterator iter;\n\nmap<int, int> merge(map<int, int>& a, map<int, int>& b) {\n  map<int, int> ret;\n  rep(i, 0b10000) rep(j, 0b10000) {\n    ret[i&j] += a[i] * b[j];\n    ret[i|j] += a[i] * b[j];\n    ret[i^j] += a[i] * b[j];\n  }\n  return ret;\n}\n\nmap<int, int> dfs() {\n  if(*iter == '(') {\n    iter ++;\n    auto l = dfs();\n    iter ++;\n    auto r = dfs();\n    iter ++;\n    return merge(l, r);\n  }\n  else {\n    int a = *iter - '0'; a--;\n    iter ++;\n    return {{vs[a], 1}};\n  }\n}\n\nint main() {\n\n  while(1) {\n    getline(cin, S);\n    if(S == \"END\") break;\n    N = S.size();\n    cin >> M;\n    vs.clear();\n    rep(i, M) {\n      int a, b, c, d; cin >> a >> b >> c >> d;\n      vs.push_back(a * 8 + b * 4 + c * 2 + d);\n    }\n    \n    iter = S.begin();\n    auto s = dfs();\n    \n    cout << s[0b1111] << endl;\n    cin.ignore();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\ntypedef vector<string> vs;\n\nvs v;\n\n\nvs mergevec(vs veca,vs vecb){\n\tvs ret;\n\tfor(auto &a:veca){\n\t\tfor(auto &b:vecb){\n\t\t\tint count[4]={};\n\t\t\trep(i,a.size()) count[a[i]-'a']++;\n\t\t\trep(i,b.size()) count[b[i]-'a']++;\n\t\t\tstring andelm=\"\",orelm=\"\",xorelm=\"\";\n\t\t\trep(i,4){\n\t\t\t\tif(count[i]==2)andelm+='a'+i;\n\t\t\t\tif(count[i]!=0) orelm+='a'+i;\n\t\t\t\tif(count[i]==1)xorelm+='a'+i;\n\t\t\t}\n\t\t\tret.pb(andelm);\n\t\t\tret.pb( orelm);\n\t\t\tret.pb(xorelm);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nvs leaf(State &begin){\n\tvs ret;\n\tret.pb(v[*begin-'0']);\n\tbegin++;\n\treturn ret;\n}\n\n\nvector<string> tree(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\t\n\t\tvs tmp1 = tree(begin);\n\t\tbegin++;\t//read ' '\n\n\t\tvs tmp2 = tree(begin);\n\t\tbegin++;\t//read ')'\n\t\t\n\t\treturn mergevec(tmp1,tmp2);\n\t}\n\telse return leaf(begin);\n}\n\nint main(){\n\tstring s;\n\twhile(getline(cin,s)){\n\t\tif(s==\"END\")break;\n\t\tint n;\n\t\tcin>>n;\n\t\tv.clear();\n\t\tv.resize(n+1);\n\t\trep(i,n){\n\t\t\tstring tmp=\"\";\n\t\t\trep(j,4){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x==1)tmp+='a'+j;\n\t\t\t}\n\t\t\tv[i+1]=tmp;\n\t\t}\n//\t\trep(i,n+1) cout<<\"x\"<<v[i]<<\"x\"<<endl;\n\t\t\n\t\tState begin = s.begin();\n\t\tvector<string> vs = tree(begin);\n\t\t\n\t\tint ans=0;\n\t\trep(i,vs.size())if(vs[i]==\"abcd\")ans++;\n\t\tcout<<ans<<endl;\n\t\t\n\t\tgetline(cin,s);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef map<int, int> P;\n\nint in[10], n, idx;\nstring str;\n\nP solve(){\n  P res;\n  if('0' <= str[idx] && str[idx] <= '9'){\n    res[in[str[idx++]-'1']]++;\n    return res;\n  }\n  idx++;\n  P l = solve();\n  idx++;\n  P r = solve();\n  idx++;\n  for(P::iterator i=l.begin();i!=l.end();i++){\n    for(P::iterator j=r.begin();j!=r.end();j++){\n      int bl = i->first;\n      int br = j->first;\n      res[bl & br] += i->second * j->second;\n      res[bl | br] += i->second * j->second;\n      res[bl ^ br] += i->second * j->second;\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(getline(cin, str) && str != \"END\"){\n    cin >> n;\n    for(int i=0;i<n;i++){\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      in[i] = 0;\n      if(a) in[i] += 1<<3;\n      if(b) in[i] += 1<<2;\n      if(c) in[i] += 1<<1;\n      if(d) in[i] += 1<<0;\n    }\n    getchar();\n    idx = 0;\n    P ans = solve();\n    cout << ans[(1<<4)-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nvector<int> op, sweet;\nint k;\n\nstruct Node{\n    Node* left;\n    Node* right;\n    int id;\n    int bit;\n};\n\nNode* newNode(){\n    Node* ret = (Node*)(malloc(sizeof(Node)));\n    ret->left = NULL;\n    ret->right = NULL;\n    return ret;\n}\n\nNode* build(int &pos, string s){\n    Node* ret = newNode();\n    if(s[pos] == '('){\n        ret->id = k++;\n        pos++;\n        ret->left = build(pos, s);\n        pos++;  // space\n        ret->right = build(pos, s);\n        pos++;  // )\n    }else{\n        int num = s[pos++]-'0';\n        ret->bit = sweet[num-1];\n    }\n    return ret;\n}\n\nint play(Node* root){\n    if(root->left != NULL){\n        int x = play(root->left), y = play(root->right);\n        if(op[root->id] == 0)   root->bit = x&y;\n        if(op[root->id] == 1)   root->bit = x|y;\n        if(op[root->id] == 2)   root->bit = x^y;\n    }\n    return root->bit;\n}\n\nint main(){\n    string s;\n    while(getline(cin, s), s != \"END\"){\n        int n;\n        cin >> n;\n        k = 0;\n        sweet.clear();\n        for(int i = 0; i < n; i++){\n            int bit = 0;\n            for(int j = 0; j < 4; j++){\n                int x;  cin >> x;\n                bit += x * (1<<j);\n            }\n            sweet.push_back(bit);\n        }\n        int pos = 0;\n        Node* root = build(pos, s);\n        op.assign(k, 0);\n        int ans = 0;\n        for(int i = 0; i < pow(3,k); i++){\n            int cp = i;\n            for(int j = 0; j < k; j++){\n                op[j] = cp%3;\n                cp /= 3;\n            }\n            if(play(root) == (1<<4)-1)  ans++;\n        }\n        cout << ans << endl;\n        cin.ignore();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstring in;\nP data[20];\nint data2[20];\nint da[10], db[10], dc[10], dd[10], n, p;\nint data3[20], ans;\n\nint calc(int r, int l){\n  int now = p++;\n  if(r == l){\n    data2[now] = in[r]-'1';\n    return now;\n  }\n  for(int i=r;i<=l;i++){\n    if(in[i] == ' '){\n      data[now].first = calc(r+1, i-1);\n      data[now].second = calc(i+1, l-1);\n    }\n  }\n  return now;\n}\n\nint calc2(int pos){\n  if(data2[pos] != -1){\n    int tmp = data2[pos];\n    int res = 0;\n    if(da[tmp] == 1) res += 1<<3;\n    if(db[tmp] == 1) res += 1<<2;\n    if(dc[tmp] == 1) res += 1<<1;\n    if(dd[tmp] == 1) res += 1<<0;\n    return res;\n  }\n  if(data3[pos] == 0) return calc2(data[pos].first) & calc2(data[pos].second);\n  if(data3[pos] == 1) return calc2(data[pos].first) | calc2(data[pos].second);\n  if(data3[pos] == 2) return calc2(data[pos].first) ^ calc2(data[pos].second);\n}\n\nvoid change(int pos){\n  if(data2[pos] != -1){\n    if(calc2(0) == 15) ans++;\n    return;\n  }\n  data3[pos] = 0;\n  change(data[pos].first);\n  data3[pos] = 1;\n  change(data[pos].first);\n  data3[pos] = 2;\n  change(data[pos].first);\n}\n\nmain(){\n  while(1){\n    getline(cin, in);\n    if(in == \"END\") break;\n    fill(data, data+20, P(-1, -1));\n    fill(data2, data2+20, -1);\n    p = 0;\n    calc(0, (int)in.size()-1);\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> da[i] >> db[i] >> dc[i] >> dd[i];\n    }\n    getchar();\n    ans = 0;\n    change(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Tree\n{\npublic:\n\tint val;\n\tTree *l,*r;\n\t\n\tTree()\n\t:l(NULL),r(NULL),val(-1)\n\t{}\n\t\n\t~Tree()\n\t{\n\t\tif(l) delete l;\n\t\tif(r) delete r;\n\t}\n};\n\nint p,cnt,w[9];\nstring expr;\n\nvoid parse(Tree* t)\n{\n\tif(expr[p]=='(')\n\t{\n\t\tt->l=new Tree;\n\t\tt->r=new Tree;\n\t\tp++;\n\t}\n\tif(expr[p]=='(') parse(t->l);\n\tif(isdigit(expr[p]))\n\t{\n\t\tt->l->val=expr[p]-'0';\n\t\tp++;\n\t}\n\t\n\tif(expr[p]==' ') p++;\n\t\n\tif(expr[p]=='(') parse(t->r);\n\tif(isdigit(expr[p]))\n\t{\n\t\tt->r->val=expr[p]-'0';\n\t\tp++;\n\t}\n\tp++;\n}\n\nvoid Adj(Tree* t, vector<Tree*>& ret)\n{\n\tif(t->val==-1) \n\t{\n\t\tret.push_back(t);\n\t\tAdj(t->l, ret);\n\t\tAdj(t->r, ret);\n\t}\n}\n\nint check(Tree* t)\n{\n\tint val;\n\tif(t->val<0)\n\t{\n\t\tint l=check(t->l);\n\t\tint r=check(t->r);\n\t\t\n\t\tif(t->val==-1) val=l&r;\n\t\tif(t->val==-2) val=l|r;\n\t\tif(t->val==-3) val=l^r;\n\t}\n\telse val=w[(t->val)];\n\t\n\treturn val;\n}\n\nvoid Attach(int ps, vector<Tree*>& ct, Tree* t)\n{\n\tif(ps==ct.size()) \n\t{\n\t\tif(check(t)==15) cnt++;\n\t}\n\telse\n\t{\n\t\tfor(int i=1; i<=3; i++)\n\t\t{\n\t\t\tct[ps]->val=-i;\n\t\t\tAttach(ps+1, ct, t);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tp=0,cnt=0;\n\t\tgetline(cin,expr);\n\t\tif(expr.size()==0) getline(cin,expr);\n\t\tif(expr[0]=='E'||expr[0]=='N') break;\n\t\t\n\t\tTree* t = new Tree;\n\t\tparse(t);\n\t\tvector<Tree*> ct;\n\t\tAdj(t,ct);\n\t\tint N;\n\t\tcin >> N;\n\t\tfor(int i=1; i<=N; i++)\n\t\t{\n\t\t\tint v=0;\n\t\t\tfor(int j=0; j<4; j++)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tv|=(t<<j);\n\t\t\t}\n\t\t\tw[i]=v;\n\t\t}\n\t\t\n\t\tAttach(0,ct,t);\n\t\tcout << cnt << endl;\n\t\tdelete t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stack>\nusing namespace std;\n\nvector<int> s;\n\nint solve(stack<int> stk, istringstream& iss)\n{\n\tif (iss.eof()) {\n\t\tif (stk.top() == 15)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint n, st = 0;\n\twhile (iss >> n) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tstk.push(n);\n\t\t++st;\n\t}\n\n\tint a = s[stk.top()-1];\n\tstk.pop();\n\tint b;\n\tif (st == 1)\n\t\tb = stk.top();\n\telse\n\t\tb = s[stk.top()-1];\n\tstk.pop();\n\n\tint cnt = 0;\n\n\tstk.push(a|b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\tstk.push(a&b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\tstk.push(a^b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\treturn cnt;\n}\n\nint main()\n{\n\tfor ( ; ; ) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif (tree == \"END\")\n\t\t\tbreak;\n\n\t\tfor (string::iterator it = tree.begin(); it != tree.end(); ) {\n\t\t\tif ((*it) == '(') {\n\t\t\t\tit = tree.erase(it);\n\t\t\t} else if ((*it) == ')') {\n\t\t\t\t*it = '0';\n\t\t\t\tit = tree.insert(it, ' ');\n\t\t\t\tit += 2;\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ts.push_back(a*8 + b*4 + c*2 + d);\n\t\t}\n\n\t\tistringstream iss(tree);\n\n\t\t// skip '\\n'\n\t\tgetline(cin, tree);\n\n\t\tcout << solve(stack<int>(), iss) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring s;\nint p,cnt,m,a,ans;\nint t[10];\n\nint size;\nint u[10];\n\nint solve(){\n  if(s[p]=='('){\n    p++;\n    int lc=solve();\n    p++;\n    int rc=solve();\n    p++;\n    int res;\n    if(u[cnt]==0)res=lc|rc;\n    if(u[cnt]==1)res=lc&rc;\n    if(u[cnt]==2)res=lc^rc;\n    cnt++;\n    return res;\n  }else{\n    int num=s[p]-'0';\n    p++;\n    return t[num];\n  }\n}\nint calc(){\n  p=cnt=0;\n  return solve();\n}\n\nvoid rec(int x){\n  if(x==size){\n    if(calc()==15)ans++;\n  }else{\n    for(int i=0;i<3;i++){\n      u[x]=i;\n      rec(x+1);\n    }\n  }\n}\nint main(){\n  while(1){\n    getline(cin,s);\n    if(s==\"END\")break;\n    cin>>m;\n    for(int i=1;i<=m;i++){\n      t[i]=0;\n      for(int j=0;j<4;j++){\n        cin>>a;\n        t[i]=t[i]*2+a;\n      }\n    }\n    ans=size=0;\n    for(int i=0;i<(int)s.size();i++)if(s[i]=='(')size++;\n    rec(0);\n    cout<<ans<<endl;\n    getline(cin,s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\nint n,idx,leaf[10];\nstring s;\n\nmap<int,int> solve(void){\n\tmap<int,int> res;\n\tif(isdigit(s[idx])){\n\t\tres[ leaf[s[idx++]-'1'] ]++;\n\t\treturn res;\n\t}\n\n\tidx++;\n\tmap<int,int> left = solve();\n\tidx++;\n\tmap<int,int> right = solve();\n\tidx++;\n\n\tfor(map<int,int>::iterator i=left.begin();i!=left.end();i++){\n\t\tfor(map<int,int>::iterator j=right.begin();j!=right.end();j++){\n\t\t\tint lbit = i->first;\n\t\t\tint rbit = j->first;\n\t\t\tres[lbit & rbit] += i->second * j->second;\n\t\t\tres[lbit | rbit] += i->second * j->second;\n\t\t\tres[lbit ^ rbit] += i->second * j->second;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\twhile(getline(cin,s),s!=\"END\"){\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tleaf[i] = 0;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x) leaf[i] |= 1<<j;\n\t\t\t}\n\t\t}\n\n\t\tidx = 0;\n\t\tmap<int,int> rst = solve();\n\t\tcout<<rst[15]<<endl;\n\n\t\tgetchar();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nbool next_operation(std::string &s) {\n  for (size_t i=s.length(); i--;) {\n    if (s[i] == 'A') {\n      s[i] = 'O';\n      return true;\n    } else if (s[i] == 'O') {\n      s[i] = 'X';\n      return true;\n    } else if (s[i] == 'X') {\n      s[i] = 'A';\n    }\n  }\n  return false;\n}\n\nint parse(const std::string &s, size_t &i, size_t preced=0) {\n  const std::vector<std::string> ops={\"AOX\"};\n\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      int res=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if ('0' <= s[i] && s[i] < '0'+16) {\n      return s[i++]-'0';\n    }\n    assert(false);\n  }\n\n  int lhs=parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!isupper(op)) break;\n    int rhs=parse(s, ++i, preced+1);\n    if (op == 'A') lhs &= rhs;\n    if (op == 'O') lhs |= rhs;\n    if (op == 'X') lhs ^= rhs;\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  char buf[1024];\n  scanf(\" %[^\\n]\", buf);\n  std::string s=buf;\n  if (s == \"END\") return 1;\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<int> item(n);\n  for (size_t i=0; i<n; ++i) {\n    for (int j=0; j<4; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      item[i] |= x<<j;\n    }\n  }\n\n  {\n    for (size_t i=0; i<s.length(); ++i) {\n      if (isdigit(s[i])) {\n        s[i] = item[s[i]-'1']+'0';\n      } else if (s[i] == ' ') {\n        s[i] = 'A';\n      }\n    }\n  }\n\n  int res=0;\n  do {\n    size_t i=0;\n    if (parse(s, i) == 15) ++res;\n  } while (next_operation(s));\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[10024];\nint m,p[10024],cnt;\nset <int> S;\n\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 && tree[ima*2+2].mark==-1)return tree[ima].bit;\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\nvoid mark_dfs(set<int>::iterator ima){\n  if(S.end()==ima){\n    cnt++;\n    if(check(0)==15) ans++;\n    return;\n  }\n  set<int>::iterator nx=ima;nx++;\n  if(tree[(*ima)*2+1].mark==-1||tree[(*ima)*2+2].mark==-1) mark_dfs(nx);\n  else\n    for(int i=0;i<=2;i++){\n      tree[(*ima)].mark=i;\n      mark_dfs(nx);\n    }\n}\n\nint input(){\n  S.clear();\n  for(int i=0;i<10024;i++)tree[i].bit=tree[i].mark=-1,  p[i] = 0;\n  char ch;\n  int ima=0,num=0,flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n    S.insert(ima);\n  }\n  if(flg==0)return flg;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit|=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    cnt=0;\n    mark_dfs(S.begin());\n    cout<<ans<<endl;\n    // cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint cnt=0;\n\n#define A 0\n#define O 1\n#define X 2\n\nclass state{\npublic:\n  int num[(1<<4)];\n  \n};\nconst int lim = ( 1 << 4);\nint table[8][(1<<4)];\nint data[8];\n\nstate parse(string &in,int &p){\n  state ret;\n  rep(i,lim)ret.num[i]=0;\n  if ( in[p]== '('){\n    p++;\n    state left = parse(in,p);\n    p++;//space\n    state right =parse(in,p);\n    p++;\n\n\n    rep(i,lim){\n      rep(j,lim){\n\tint val1=i&j,val2=i|j,val3=i^j;\n\n\tint add=left.num[i]*right.num[j];\n\tret.num[val1]+=add;\n\tret.num[val2]+=add;\n\tret.num[val3]+=add;\n      }\n    }\n  }else if ( in[p] <='9' && in[p] >='0'){\n    int now = in[p]-'0';\n    now--;\n    ret.num[data[now]]=1;\n    p++;\n  }\n  return ret;\n}\n\n\nmain(){\n  string t;\n  while(getline(cin,t) && t != \"END\"){\n    int n;\n    cin>>n;\n    \n    int num=0;\n    int p=0;\n    rep(i,n){\n      data[i]=0;\n      int kari;\n      rep(j,4)cin>>kari,data[i]|=(kari<<j);\n    }\n    \n    state ans = parse(t,p);\n    cout << ans.num[(1<<4)-1]<<endl;\n    getline(cin,t);\n  }\n  return false;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint x[15];\nint type[15];\nstring s;\nint num;\n\nint parse(int l, int r){\n\tif (r-l == 1) return x[s[l] - '1'];\n\n\tint sp = -1;\n\tfor (int i = l; i < r; ++i){\n\t\tif (s[i] == ' ') sp = i;\n\t}\n\n\tint res1 = parse(l + 1, sp);\n\tint res2 = parse(sp + 1, r - 1);\n\n\tint ret = -1;\n\tif (type[num] == 0) ret = res1 | res2;\n\tif (type[num] == 1) ret = res1 & res2;\n\tif (type[num] == 2) ret = res1 ^ res2;\n\t++num;\n\treturn ret;\n}\n\n\nint ans;\nint m;\nvoid rec(int n){\n\tif (n == m){\n\t\tnum = 0;\n\t\t//cout << parse(0, s.size()) << endl;\n\t\tans += parse(0, s.size()) == 15;\n\t\treturn;\n\t}\n\trep(i, 3){\n\t\ttype[n] = i;\n\t\trec(n + 1);\n\t}\n}\n\nint main(){\n\twhile (getline(cin, s), s != \"END\"){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tMEMSET(x, 0);\n\t\trep(i, n) rep(j, 4){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tx[i] |= (t << j);\n\t\t}\n\t\tans = 0;\n\t\tm = count(ALL(s), ' ');\n\t\trec(0);\n\t\tcout << ans << endl;\n\t\tcin.ignore();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//32\n#include<iostream>\n#include<cmath>\n\nusing namespace std;\n\nchar t[128];\nint n;\nint l[11];\nchar *p;\n\nint prs(){\n  if(*p!='('){\n    return l[*p++-'0'];\n  }else{\n    p++;\n    int a=prs();\n    char o=*p++;\n    int b=prs();\n    p++;\n    switch(o){\n    case 'A':\n      return a&b;\n    case 'O':\n      return a|b;\n    case 'X':\n      return a^b;\n    }\n  }\n}\n\nint dfs(char *s){\n  while(*s!=' '&&*s!='\\0'){\n    s++;\n  }\n  if(*s!='\\0'){\n    int r=0;\n    for(int i=0;i<3;i++){\n      const char *o=\"AOX\";\n      *s=o[i];\n      r+=dfs(s);\n    }\n    *s=' ';\n    return r;\n  }else{\n    p=t;\n    return 15==prs();\n  }\n}\n\nint main(){\n  while(cin.getline(t,128),t[0]!='E'){\n    cin>>n;\n    for(int i=0;i<n;i++){\n      int tl=0;\n      for(int j=0;j<4;j++){\n\tint b;\n\tcin>>b;\n\ttl=tl<<1|b;\n      }\n      l[i+1]=tl;\n    }\n    cin.ignore();\n    cout<<dfs(t)<<endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint curPos = 0;\nstring str;\nint info[18] = {};\nvector< vector<int> > g;\nint number[18] = {};\nint mx = 0;\nvoid parse(int pos){\n\t//cout << curPos << \" \" << str[curPos] << endl;\n\tmx = max(pos,mx);\n\tif( str[curPos] >= '0' && str[curPos] <= '9'){\n\t\tnumber[pos] = info[ str[curPos] - '0' - 1];\n\t\tcurPos++;\n\t\treturn;\n\t}\n\t\n\t\n\tcurPos++;\n\tg[pos].push_back(pos*2+1);\n\tparse(pos*2+1);\n\t\n\t\n\tcurPos++; // space \n\t\n\t\n\tg[pos].push_back(pos*2+2);\n\tparse(pos*2+2);\n\t\n\tcurPos++;\n\treturn;\n}\n\nint calc(int a,int b,int t){\n\tif( t == -1 ) return a & b;\n\tif( t == -2 ) return a | b;\n\treturn a^b;\n}\n\nint tmp[30] = {};\n\n\nint all(int pos){\n\tif( tmp[pos] >= 0 ){\n\t\treturn number[pos];\n\t}else{\n\t\treturn calc(all(pos*2+1),all(pos*2+2),tmp[pos]);\n\t}\n}\n\nint answer = 0;\nint dfs(int pos){\n\tif(pos == mx+1){\n\t\tint r = all(0);\n\t\tanswer +=r == 15;\n\t\treturn 0;\n\t}\n\tif( number[pos] == -1){\n\t\tfor(int i = 1 ; i <= 3 ; i++){\n\t\t\ttmp[pos] = -i;\n\t\t\tdfs(pos+1);\n\t\t}\n\t}else{\n\t\ttmp[pos] = number[pos];\n\t\tdfs(pos+1);\n\t}\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(1){\n\t\t\twhile( getline(cin,str) && (str == \"\" || str == \"END\") ){ if(str == \"END\") return 0; }\n\t\t\n\t\tfor(int i = 0 ; i < 18 ; i++) number[i] = -1;\n\t\tcin >> n;\n\t\tg.clear();\n\t\tg.resize(18);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint inf = 0 , a;\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tinf |= (a<<j);\n\t\t\t}\n\t\t\tinfo[i] = inf;\n\t\t}\n\t\tcurPos = 0;\n\t\tmx = 0;\n\t\tparse(0);\n\t\t/*for(int i = 0 ; i <= mx ; i++){\n\t\t\tcout << i << \"(\" << number[i] << \")\" << \" : \";\n\t\t\tfor(int j =0 ; j < g[i].size() ; j++) cout << g[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tanswer = 0;\n\t\tdfs(0);\n\t\tcout << answer << endl;\n\t\tgetline(cin,str);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stack>\nusing namespace std;\n\nint ans;\nvector<int> s;\nvoid solve(stack<int> stk, const string& str, unsigned int p)\n{\n\tif (str.size() == p) {\n\t\tif (stk.top() == 15)\n\t\t\t++ans;\n\t\treturn;\n\t}\n\n\tint st = 0;\n\tfor (; p < str.size(); ++p) {\n\t\tif (str[p] == '0')\n\t\t\tbreak;\n\t\tstk.push(s[str[p] - '0' - 1]);\n\t\t++st;\n\t}\n\n\tint a = stk.top();\n\tstk.pop();\n\tint b = stk.top();\n\tstk.pop();\n\n\tstk.push(a|b);\n\tsolve(stk, str, p+1);\n\tstk.pop();\n\n\tstk.push(a&b);\n\tsolve(stk, str, p+1);\n\tstk.pop();\n\n\tstk.push(a^b);\n\tsolve(stk, str, p+1);\n\tstk.pop();\n}\n\nint main()\n{\n\tfor ( ; ; ) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif (tree == \"END\")\n\t\t\tbreak;\n\n\t\tfor (string::iterator it = tree.begin(); it != tree.end(); ) {\n\t\t\tif ((*it) == '(' || (*it) == ' ') {\n\t\t\t\tit = tree.erase(it);\n\t\t\t} else if ((*it) == ')') {\n\t\t\t\t*it = '0';\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t\tint n;\n\t\tcin >> n;\n\t\ts.clear();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ts.push_back(a*8 + b*4 + c*2 + d);\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tsolve(stack<int>(), tree, 0);\n\t\tcout << ans << endl;\n\n\t\t// skip '\\n'\n\t\tgetline(cin, tree);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring s;\nint n,b[10],cnt,sum,aox[8],ans,p,k;\nvoid func(int);\nint calc();\n\nint main(){\n  int a,len;\n  while(1){\n    getline(cin,s);\n    if(s==\"END\") break;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      b[i]=0;\n      for(int j=0;j<4;j++) cin>>a,b[i]=(b[i]|(a<<j));\n    }\n    sum=0;\n    len=s.size();\n    for(int i=0;i<len;i++)\n      if(s[i]=='(') sum++;\n    ans=0;\n    func(0);\n    cout<<ans<<endl;\n    getline(cin,s);\n  }\n  return 0;\n}\n\nvoid func(int d){\n  if(d==sum){\n    p=k=0;\n    if(calc()==15) ans++;\n    return;\n  }\n  for(int i=0;i<3;i++) aox[d]=i,func(d+1);\n}\n\nint calc(){\n  int r,left,right;\n  if(s[p]=='('){\n    p++;\n    left=calc();\n    p++;\n    right=calc();\n    p++;\n    if(aox[k]==0) r=left&right;\n    if(aox[k]==1) r=left|right;\n    if(aox[k]==2) r=left^right;\n    k++;\n  }else{\n    int x=s[p]-'0';\n    r=b[x];\n    p++;\n  }\n  return r;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[10024];\nvoid out(void);\n//((1 2) 3)\n//(1 (2 3))\n//(1 ((2 3) 4))\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 || tree[ima*2+2].mark==-1)return tree[ima].bit;\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\n\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=10000)ima++;\n  if(ima>10000 && check(0)==(1<<4)-1)ans++;\n  else if(ima<=10000)\n    for(int i=0;i<=2;i++)tree[ima].mark=i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<10024;i++)tree[i].bit=-1,tree[i].mark=-1;\n  int ima=0,num=0,p[1024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  if(flg==0)return flg;\n\n  int m;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    mark_dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<7;i++){\n    cout << tree[i].mark<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint x[15];\nint type[15];\nstring s;\nint num;\n\nint parse(int l, int r){\n\tif (r-l == 1) return x[s[l] - '1'];\n\n\tint sp = -1;\n\tfor (int i = l; i < r; ++i){\n\t\tif (s[i] == ' ') sp = i;\n\t}\n\n\tint res1 = parse(l + 1, sp);\n\tint res2 = parse(sp + 1, r - 1);\n\n\tint ret = -1;\n\tif (type[num] == 0) ret = res1 | res2;\n\tif (type[num] == 1) ret = res1 & res2;\n\tif (type[num] == 2) ret = res1 ^ res2;\n\t++num;\n\treturn ret;\n}\n\n\nint ans;\nint m;\nvoid rec(int n){\n\tif (n == m){\n\t\tnum = 0;\n\t\t//cout << parse(0, s.size()) << endl;\n\t\tans += parse(0, s.size()) == 15;\n\t\treturn;\n\t}\n\trep(i, 3){\n\t\ttype[n] = i;\n\t\trec(n + 1);\n\t}\n}\n\nint main(){\n\twhile (getline(cin, s), s != \"END\"){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tMEMSET(x, 0);\n\t\trep(i, n) rep(j, 4){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tx[i] |= (t << j);\n\t\t}\n\t\tans = 0;\n\t\tm = count(ALL(s), ' ');\n\t\trec(0);\n\t\tcout << ans << endl;\n\t\tcin.ignore();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nchar str[110];\nchar w[5]=\"AOX\";\nint at[20];\nint var[20];\nint pow3[20];\nint cur;\nint expr(){\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tint L=expr();\n\t\tchar ex=str[cur++];\n\t\tint R=expr();\n\t\tcur++;\n\t\tif(ex=='A')return L&R;\n\t\tif(ex=='X')return L^R;\n\t\treturn L|R;\n\t}else{\n\t\treturn var[str[cur++]-'1'];\n\t}\n}\nint main(){\n\tpow3[0]=1;\n\tfor(int i=1;i<20;i++)pow3[i]=pow3[i-1]*3;\n\twhile(1){\n\t\tgets(str);\n\t\tif(str[0]=='E')return 0;\n\t\tint sz=0;\n\t\tfor(int i=0;str[i];i++)if(str[i]==' '){\n\t\t\tat[sz++]=i;\n\t\t}\n\t\tint n;scanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar[i]=0;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint p;scanf(\"%d\",&p);\n\t\t\t\tif(p)var[i]+=(1<<j);\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<pow3[sz];i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tstr[at[j]]=w[i%pow3[j+1]/pow3[j]];\n\t\t\t}\n\t\t//\tprintf(\"%s\\n\",str);\n\t\t\tcur=0;\n\t\t\tif(expr()==15)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);gets(str);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cctype>\n#include <map>\n\n#define conv(c) (int)(c-'1')\n\nusing namespace std;\n\ntypedef pair<int, string> P; \n\nvector<string> vec;\nstring str;\nmap<P, string> mpp;\n\nstring func(string st)\n{\n  string s = \"\";\n  for(int i = 0; i < st.size(); ++i)\n    if(st[i] != ' ') s += st[i];\n\n  return s;\n}\n\nvoid mkMap(string s, int d)\n{\n  if(d == 8){\n    for(int i = 0; i < 3; ++i){\n      string st = \"\";\n      for(int j = 0; j < 4; ++j){\n\tif(i == 0){\n\t  st += ((s[j] == '1' || s[j+4] == '1')? \"1\" : \"0\"); \n\t} else if(i == 1){\n\t  st += ((s[j] == '1' && s[j+4] == '1')? \"1\" : \"0\");\n\t} else {\n\t  st += ((s[j] != s[j+4])? \"1\" : \"0\");\n\t}\n      }\n      mpp[P(i, s)] = st;\n    }\n  } else {\n    for(int i = 0; i < 2; ++i)\n      mkMap(s+(char)('0'+i), d+1);\n  }\n\n  return ;\n}\n\nint p;\nvector<string> rec()\n{\n  vector<string> v1, v2, res;\n  if(isdigit(str[p])){\n    v1.push_back(vec[conv(str[p])]);\n    p+=2;\n  } else {\n    ++p;\n    v1 = rec();\n    ++p;\n  }\n\n  if(isdigit(str[p])){\n    v2.push_back(vec[conv(str[p])]);\n    p+=2;\n  } else {\n    ++p;\n    v2 = rec();\n    ++p;\n  }\n\n  for(int k = 0; k < v1.size(); ++k)\n    for(int l = 0; l < v2.size(); ++l)\n      for(int i = 0; i < 3; ++i)\n\tres.push_back(mpp[P(i, v1[k]+v2[l])]);\n\n  return res;\n}\n\nint solve(string s)\n{\n  int cnt = 0;\n  p = 1;\n  vector<string> res = rec();\n\n  for(int i = 0; i < res.size(); ++i)\n    if(res[i] == s) cnt++;\n\n  return cnt;\n}\n\nint main()\n{\n  int n;\n  string s1, s2=\"\";\n\n  mkMap(\"\", 0);\n  for(int i = 0; i < 4; i++) s2 += \"1\";\n  while(getline(cin, str) && str != \"END\"){\n    getline(cin, s1);\n    n = atoi(s1.c_str());\n\n    while(n--){\n      getline(cin, s1);\n      vec.push_back(func(s1));\n    }\n\n    cout << solve(s2) << endl;\n    vec.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint Tree[1145],m;\nmap<int,int> mp;\nvector<int> order;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1,bit);\n    int r = getBit(2*v+2,bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint getNum(string::iterator &it){\n    int res = 0;\n    while(isdigit(*it)){\n        res *= 10;\n        res += *it-'0';\n        ++it;\n    }\n    --it;\n    return res;\n}\n\nvoid makeTree(string &s){\n    memset(Tree,-1,sizeof(Tree));\n    int depth = -1;\n    string::iterator it;\n    for(it = s.begin() ; it != s.end() ; ++it){\n        if(*it == '(') depth++;\n        else if(*it == ')') depth--;\n        else if(isdigit(*it)){\n            Tree[2*depth+1] = getNum(it)-1;\n        }else if(*it == ' '){\n            ++it;\n            Tree[2*depth+2] = getNum(it)-1;\n        }\n    }\n}\n\nvoid dfs(int v){\n    if(Tree[v] == -1){\n        mp[v] = m++;\n    }\n    if(Tree[2*v+1] == -1){\n        dfs(2*v+1);\n    }\n    if(Tree[2*v+2] == -1){\n        dfs(2*v+2);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        int res = 0;\n        makeTree(s);\n        m = 0; dfs(0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint Tree[5000],m;\nmap<int,int> mp;\nvector<int> order;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1,bit);\n    int r = getBit(2*v+2,bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint getNum(string::iterator &it){\n    int res = 0;\n    while(isdigit(*it)){\n        res *= 10;\n        res += *it-'0';\n        ++it;\n    }\n    --it;\n    return res;\n}\n\nvoid makeTree(string &s){\n    memset(Tree,-1,sizeof(Tree));\n    int depth = -1;\n    string::iterator it;\n    for(it = s.begin() ; it != s.end() ; ++it){\n        if(*it == '(') depth++;\n        else if(*it == ')') depth--;\n        else if(isdigit(*it)){\n            Tree[2*depth+1] = getNum(it)-1;\n        }else if(*it == ' '){\n            ++it;\n            Tree[2*depth+2] = getNum(it)-1;\n        }\n    }\n}\n\nvoid dfs(int v){\n    if(Tree[v] == -1){\n        mp[v] = m++;\n    }\n    if(Tree[2*v+1] == -1){\n        dfs(2*v+1);\n    }\n    if(Tree[2*v+2] == -1){\n        dfs(2*v+2);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        int res = 0;\n        makeTree(s);\n        m = 0; dfs(0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Node {\n\tbool leaf;\n\tchar op;\n\tint leafnum;\n\tunion {\n\t\tint mask;\n\t\tNode* children[2];\n\t};\n};\n\nvector<int> leafmask(9);\nvector<Node*> mids;\n\nvoid skip(const string &str, int &pos, char c) {\n\tif(str[pos] != c) {\n\t\tcerr << \"Error at \" << pos << \": expected \" << c << \" but \" << str[pos] << endl;\n\t}\n\t++pos;\n}\n\nNode *node(const string &str, int &pos) {\n\tNode *n = new Node;\n\tif(isdigit(str[pos])) {\n\t\tn->leaf = true;\n\t\tn->mask = 0;\n\t\t//leaves[str[pos]-'0'-1] = n;\n\t\tn->leafnum = str[pos]-'0'-1;\n\t\t++pos;\n\t}\n\telse {\n\t\tn->leaf = false;\n\t\tskip(str, pos, '(');\n\t\tn->children[0] = node(str, pos);\n\t\tskip(str, pos, ' ');\n\t\tn->children[1] = node(str, pos);\n\t\tskip(str, pos, ')');\n\t\tmids.push_back(n);\n\t}\n\treturn n;\n}\n\nint calc(Node *n) {\n\tif(n->leaf) return leafmask[n->leafnum];\n\n\tint l = calc(n->children[0]);\n\tint r = calc(n->children[1]);\n\tif(n->op == 'A') return l&r;\n\telse if(n->op == 'O') return l|r;\n\telse return l^r;\n}\n\nint main() {\n\twhile(true) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif(tree == \"END\") break;\n\n\t\tmids.clear();\n\t\tint pos = 0;\n\t\tNode *root = node(tree, pos);\n\n\t\tint N;\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tleafmask[i] = 0;\n\t\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\t\tint flag;\n\t\t\t\tcin >> flag;\n\t\t\t\t//if(flag) leaves[i]->mask |= (1<<j);\n\t\t\t\tif(flag) leafmask[i] |= (1<<j);\n\t\t\t}\n\t\t}\n\t\tint limit = 1;\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < mids.size(); ++i) limit *= 3;\n\t\tfor(int i = 0; i < limit; ++i) {\n\t\t\tint tmp = i;\n\t\t\tfor(int j = 0; j < mids.size(); ++j) {\n\t\t\t\tmids[j]->op = \"AOX\"[tmp%3];\n\t\t\t\ttmp /= 3;\n\t\t\t}\n\t\t\tif(calc(root) == 0x0f) ++cnt;\n\t\t}\n\t\tcout << cnt << endl;\n\t\tcin.ignore();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint data[10];\n\nint calc(const char *buff){\n  if(*buff == '('){\n    buff++;\n    int l = calc(buff);\n    if(*buff == '('){\n      int depth = 1;\n      buff++;\n      while(depth != 0){\n        if(*buff == '(') depth++;\n        if(*buff == ')') depth--;\n        buff++;\n      }\n    }else{\n      buff++;\n    }\n    char op = *buff++;\n    int r = calc(buff);\n    if(op == '|'){\n      return l | r;\n    }else if(op == '&'){\n      return l & r;\n    }else{\n      return l ^ r;\n    }\n  }else{\n    return data[*buff - '1'];\n  }\n}\n\nint main(){\n  char buff[1000];\n  while(fgets(buff,sizeof(buff),stdin),\n        strncmp(buff, \"END\", 3)){\n    int n;\n    scanf(\"%d \",&n);\n    REP(i,n){\n      data[i] = 0;\n      REP(j,4){\n        int t;\n        scanf(\"%d \",&t);\n        if(t == 1) data[i] |= (1<<j);\n      }\n    }\n    int spPos[8];\n    int cnt = 0;\n    int last = 1;\n    for(int i=0; buff[i]; i++){\n      if(buff[i] == ' '){\n        spPos[cnt++] = i;\n        last *= 3;\n      }\n    }\n    const char *ops = \"|&^\";\n    int ans = 0;\n    REP(i,last){\n      int tmp = i;\n      REP(j,cnt){\n        char op = ops[tmp%3];\n        tmp/=3;\n        buff[spPos[j]] = op;\n      }\n      if(calc(buff) == 15)\n        ans++;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cctype>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nstruct Node {\n  int l, r;\n  int id;\n  int leaf;\n  Node() {\n    l = r = 0;\n    leaf = -1;\n  }\n};\nvector<Node> tree;\nint okasi[16];\n\nint parse(string s, int &p) {\n  int n = tree.size();\n  int temp;\n  if( s[p] == '(' ) {\n    tree.push_back( Node() );\n    p++;\n    temp = parse(s, p);\n    tree[n].l = temp;\n    p++;\n    temp = parse(s, p);\n    tree[n].r = temp;\n    p++;\n  }\n  else if( isdigit( s[p]) ) {\n    int num = 0;\n    while( isdigit( s[p] ) ) {\n      num = num * 10 + s[p] - '0';\n      p++;\n    }\n    tree.push_back( Node() );\n    tree[n].leaf = num - 1;\n  }\n  return n;\n}\n\n\nint pattern[16];\nint run(int p) {\n  if( tree[p].leaf >= 0 ) return okasi[ tree[p].leaf ];\n  int l = run( tree[p].l);\n  int r = run( tree[p].r);\n\n  int res = 15;\n  if( pattern[ tree[p].id ] == 0 )\n    res = res & (l & r);\n  if( pattern[ tree[p].id ] == 1 )\n    res = res & (l | r);\n  if( pattern[ tree[p].id ] == 2 )\n    res = res & (l ^ r);\n  return res;\n}\n\nint ans = 0;\nvoid rec(int depth, int max_depth) {\n  if( depth == max_depth ) {\n    int get = run(0);\n    if( get == 15 ) ans++;\n  } else {\n    for(int i = 0; i < 3; i++) {\n      pattern[depth] = i;\n      rec( depth + 1, max_depth);\n    }\n  }\n}\n\nint main() {\n  for(;;) {\n    memset(okasi, 0, sizeof(okasi));\n    string str;\n    cin >> ws;\n    getline(cin, str);\n    if( str == \"END\" ) break;\n    tree.clear();\n    int p = 0;\n    parse(str, p);\n\n    int N; cin >> N;\n    REP(i, N) {\n      int num = 0;\n      REP(k, 4) {\n        int x;\n        cin >> x;\n        num = num * 2 + x;\n      }\n      okasi[i] = num;\n    }\n\n    int inner = 0;\n    REP(i, tree.size()) if( tree[i].leaf == -1 ) {\n      tree[i].id = inner;\n      ++inner;\n    }\n    memset(pattern, 0, sizeof(pattern));\n    ans = 0;    \n    rec(0, inner);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Node{\n\tint num,left_child,right_child,code_id,order;\n};\n\nNode nodes[200];\nint nodes_index,setsu_num,codes[200][16];\n\nchar buf[200];\nint length,POW[4] = {1,2,4,8};\n\nvoid recursive(int left,int right,int parent_index){\n\tint depth = 0;\n\tint count = 0;\n\n\tfor(int i = left; i <= right;){\n\n\t\tif(depth == 0 && buf[i] == '('){\n\t\t\tdepth = 1;\n\n\t\t\tfor(int k = i+1; k <= right; k++){\n\t\t\t\tif(buf[k] == '('){\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(buf[k] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\t\tnodes[parent_index].left_child = nodes_index;\n\t\t\t\t\t\t\tnodes_index++;\n\t\t\t\t\t\t\trecursive(i+1,k-1,nodes_index-1);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\ti = k+2;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnodes[parent_index].right_child = nodes_index;\n\t\t\t\t\t\t\tnodes_index++;\n\t\t\t\t\t\t\trecursive(i+1,k-1,nodes_index-1);\n\t\t\t\t\t\t\ti = k+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(buf[i] >= '1' && buf[i] <= '9'){\n\n\t\t\tint code_id = buf[i]-'0';\n\n\t\t\tif(count == 0){\n\t\t\t\tnodes[parent_index].left_child = nodes_index;\n\t\t\t\ti += 2;\n\t\t\t}else{\n\t\t\t\tnodes[parent_index].right_child = nodes_index;\n\t\t\t\ti += 1;\n\t\t\t}\n\n\t\t\tnodes[nodes_index].code_id = code_id;\n\t\t\tnodes_index++;\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nvoid calc(int node_id){\n\n\tif(nodes[node_id].left_child == -1){\n\n\t\tcodes[node_id][nodes[node_id].num]++;\n\n\t}else{\n\n\t\t//????????????????¨????\n\t\tcalc(nodes[node_id].left_child);\n\t\tcalc(nodes[node_id].right_child);\n\n\t\tint left_table[16],right_table[16];\n\t\tfor(int i = 0; i < 16; i++){\n\t\t\tleft_table[i] = codes[nodes[node_id].left_child][i];\n\t\t\tright_table[i] = codes[nodes[node_id].right_child][i];\n\t\t}\n\n\t\tint num_A,num_O,num_X;\n\n\t\tfor(int left = 0; left < 16; left++){\n\t\t\tif(left_table[left] == 0)continue;\n\t\t\tfor(int right = 0; right < 16; right++){\n\t\t\t\tif(right_table[right] == 0)continue;\n\n\t\t\t\tnum_A = num_O = num_X = 0;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tif((left & (1 << i)) != 0 && (right & (1 << i)) != 0){\n\t\t\t\t\t\tnum_A += POW[i];\n\t\t\t\t\t\tnum_O += POW[i];\n\t\t\t\t\t}else if((left & (1 << i)) == 0 && (right & (1 << i)) != 0){\n\t\t\t\t\t\tnum_O += POW[i];\n\t\t\t\t\t\tnum_X += POW[i];\n\t\t\t\t\t}else if((left & (1 << i)) != 0 && (right & (1 << i)) == 0){\n\t\t\t\t\t\tnum_O += POW[i];\n\t\t\t\t\t\tnum_X += POW[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcodes[node_id][num_O] += left_table[left]*right_table[right];\n\n\t\t\t\tcodes[node_id][num_A] += left_table[left]*right_table[right];\n\n\t\t\t\tcodes[node_id][num_X] += left_table[left]*right_table[right];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 200; i++){\n\t\tnodes[i].left_child = -1;\n\t\tnodes[i].right_child = -1;\n\t\tnodes[i].num = -1;\n\t\tnodes[i].code_id = -1;\n\t}\n\n\tfor(length = 0; buf[length] != '\\0' && buf[length] != '\\n'; length++);\n\n\tnodes_index = 1;\n\trecursive(1,length-2,0);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint tmp[4],table[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d %d %d %d\",&tmp[0],&tmp[1],&tmp[2],&tmp[3]);\n\n\t\ttable[i] = POW[3]*tmp[0] + POW[2]*tmp[1] + POW[1]*tmp[2] + POW[0]*tmp[3];\n\t}\n\n\tsetsu_num = 0;\n\tfor(int i = 0; i < nodes_index;i++){\n\t\tif(nodes[i].code_id != -1){\n\t\t\tnodes[i].num = table[nodes[i].code_id];\n\t\t}else{\n\t\t\tsetsu_num++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < nodes_index; i++){\n\t\tfor(int k = 0; k < 16; k++)codes[i][k] = 0;\n\t}\n\n\tcalc(0);\n\n\tprintf(\"%d\\n\",codes[0][15]);\n\n\tgetchar();\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tfgets(buf,200,stdin);\n\t\tif(buf[0] == 'E')break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<vector>\n#include<map>\ntypedef std::map<int,int>M;\ntypedef M::iterator I;\ntypedef std::pair<int,int>P;\nstd::vector<P>v;\nint x[10];\nint F(char*&p,int n)\n{\n\tif(isdigit(*p))\n\t\treturn -*p+'0';\n\tv.push_back(P(0,0));\n\tint s=v.size();\n\tv[n].first=F(++p,s);\n\ts=v.size();\n\tv[n].second=F(p+=2,s);\n\t++p;\n\treturn n;\n}\nM G(int i)\n{\n\tM m;\n\tif(i<0)m[x[-i]]=1;\n\telse\n\t{\n\t\tM a(G(v[i].first)),b(G(v[i].second));\n\t\tfor(I p=a.begin();p!=a.end();++p)for(I q=b.begin();q!=b.end();++q)\n\t\t{\n\t\t\tint a=p->first,b=q->first,c=p->second*q->second;\n\t\t\tm[a&b]+=c;\n\t\t\tm[a|b]+=c;\n\t\t\tm[a^b]+=c;\n\t\t}\n\t}\n\treturn m;\n}\nint main()\n{\n\tint n,i,j,t;\n\tchar*p,s[512];\n\twhile(fgets(s,512,stdin),*s-'E')\n\t{\n\t\tv.clear();\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;++i)for(x[i]=j=0;j<4;++j)scanf(\"%d\",&t),x[i]=x[i]*2+t;\n\t\tt=F(p=s,0);\n\t\tprintf(\"%d\\n\",t?x[-t]==15:G(0)[15]);\n\t\tfgets(s,512,stdin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nstruct bt{\n  int a,b,c,d;\n  int e;\n  struct bt* l;\n  struct bt* r;\n};\nint f(int a[][4],string s,struct bt* p,int e){\n  int i,j;\n  if(s[0]=='('){\n    p->l=(struct bt*)malloc(sizeof(struct bt));\n    p->r=(struct bt*)malloc(sizeof(struct bt));\n    p->e=e;\n    e++;\n    if(s[1]=='('){\n      j=1;\n      for(i=2;j;i++){\n\tif(0){\n\t}else if(s[i]=='('){\n\t  j++;\n\t}else if(s[i]==')'){\n\t  j--;\n\t}\n      }\n      e=f(a,s.substr(1,i-1),p->l,e);\n    }else{\n      e=f(a,s.substr(1,1),p->l,e);\n    }\n    if(s[s.length()-2]==')'){\n      j=1;\n      for(i=s.length()-3;j;i--){\n\tif(0){\n\t}else if(s[i]==')'){\n\t  j++;\n\t}else if(s[i]=='('){\n\t  j--;\n\t}\n      }\n      e=f(a,s.substr(i+1,s.length()-i-2),p->r,e);\n    }else{\n      e=f(a,s.substr(s.length()-2,1),p->r,e);\n    }\n  }else{\n    p->l=NULL;\n    p->r=NULL;\n    p->a=a[s[0]-'1'][0];\n    p->b=a[s[0]-'1'][1];\n    p->c=a[s[0]-'1'][2];\n    p->d=a[s[0]-'1'][3];\n  }\n  return e;\n}\nstruct bt g(struct bt* z,int i){\n  struct bt a,b,c;\n  if(z->l==NULL){\n    return *z;\n  }else{\n    a=g(z->l,i);\n    b=g(z->r,i);\n    if(0){\n    }else if(i/(int)pow(3,z->e)%3==0){\n      c.a=a.a&b.a;\n      c.b=a.b&b.b;\n      c.c=a.c&b.c;\n      c.d=a.d&b.d;\n    }else if(i/(int)pow(3,z->e)%3==1){\n      c.a=a.a|b.a;\n      c.b=a.b|b.b;\n      c.c=a.c|b.c;\n      c.d=a.d|b.d;\n    }else if(i/(int)pow(3,z->e)%3==2){\n      c.a=a.a^b.a;\n      c.b=a.b^b.b;\n      c.c=a.c^b.c;\n      c.d=a.d^b.d;\n    }\n    return c;\n  }\n}\nint main(){\n  int i,j;\n  int a[9][4],n,e;\n  int sm;\n  string s;\n  struct bt c;\n  struct bt* z;\n  while(getline(cin,s)&&s!=\"END\"){\n    cin>>n;\n    for(i=0;i<n;i++)\n      for(j=0;j<4;j++)\n\tcin>>a[i][j];\n    z=(struct bt*)malloc(sizeof(struct bt));\n    e=f(a,s,z,0);    \n    sm=0;\n    for(i=0;i<(int)pow(3,e);i++){\n\tc=g(z,i);\n\tsm+=c.a&c.b&c.c&c.d;\n    }\n    cout<<sm<<endl;\n    getline(cin,s);\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool a[10][4];\nint n;\nint v[8];\nint node;\nint hoge;\n\nvector<bool> solve(string s) {\n//  cout << s << endl;\n  if (s[0] != '(') {\n    vector<bool> res(4);\n    REP(i,4)\n      if (a[s[0]-'1'][i]) {\n        res[i] = 1;\n      }\n    return res;\n  }\n  int aa = 0;\n  REP(i, s.size()) {\n    if (s[i] == '(') aa++;\n    else if (s[i] == ')') aa--;\n    if (aa == 1 && s[i] == ' ') {\n      vector<bool> L = solve(s.substr(1,i-1));\n      vector<bool> R = solve(s.substr(i+1,s.size()-i-2));\n      vector<bool> res(4);\n      if (v[hoge] == 0) {\n        REP(i,4) if (L[i]&&R[i]) res[i] = 1;\n      } else if (v[hoge] == 1) {\n        REP(i,4) if (L[i]||R[i]) res[i] = 1;\n      } else {\n        REP(i,4) if (L[i]&&!R[i] || !L[i]&&R[i]) res[i] = 1;\n      }\n      hoge++;\n      // cout << \"L \";\n      // FOR(it, L)\n      //   cout <<*it << \" \";\n      // cout << endl;\n      // cout << \"R \";\n      // FOR(it, R)\n      //   cout <<*it << \" \";\n      // cout << endl;\n      // FOR(it, res)\n      //   cout <<*it << \" \";\n      // cout << endl;\n      return res;\n    }\n  }\n}\n\nint res;\nvoid solve1(string s, int nest) {\n  if (nest == node) {\n    hoge = 0;\n    vector<bool> vv = solve(s);\n    // cout << \"node = \";\n    // REP(i, node) {\n    //   cout << v[i] << \" \";\n    // }\n    // cout <<\"OK\" << endl;\n    \n    if (count(ALL(vv), 1) == 4)\n      res++;\n    return;\n  }\n  REP(i,3) {\n    v[nest] = i;\n    solve1(s,nest+1);\n  }\n}\n\n\n\nint main() {\n  string s;\n  while(getline(cin,s)) {\n    if (s==\"END\") break;\n    cin >> n;\n    REP(i,n) {\n      REP(j,4)\n        cin >> a[i][j];\n    }\n    cin.ignore();\n    node = count(ALL(s), '(');\n    res = 0;\n    solve1(s, 0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Node{\n\tint num,left_child,right_child,code_id;\n};\n\nNode nodes[200];\nint nodes_index;\n\nchar buf[200];\nint length,POW[4] = {1,2,4,8},ans;\n\nvoid recursive(int left,int right,int parent_index){\n\tint depth = 0;\n\tint count = 0;\n\n\tfor(int i = left; i <= right;){\n\n\t\tif(depth == 0 && buf[i] == '('){\n\t\t\tdepth = 1;\n\n\t\t\tfor(int k = i+1; k <= right; k++){\n\t\t\t\tif(buf[k] == '('){\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(buf[k] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\t\tnodes[parent_index].left_child = nodes_index;\n\t\t\t\t\t\t\tnodes_index++;\n\t\t\t\t\t\t\trecursive(i+1,k-1,nodes_index-1);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\ti = k+2;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnodes[parent_index].right_child = nodes_index;\n\t\t\t\t\t\t\tnodes_index++;\n\t\t\t\t\t\t\trecursive(i+1,k-1,nodes_index-1);\n\t\t\t\t\t\t\ti = k+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(buf[i] >= '1' && buf[i] <= '9'){\n\n\t\t\tint code_id = buf[i]-'0';\n\n\t\t\tif(count == 0){\n\t\t\t\tnodes[parent_index].left_child = nodes_index;\n\t\t\t\ti += 2;\n\t\t\t}else{\n\t\t\t\tnodes[parent_index].right_child = nodes_index;\n\t\t\t\ti += 1;\n\t\t\t}\n\n\t\t\tnodes[nodes_index].code_id = code_id;\n\t\t\tnodes_index++;\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint calc(int node_id){\n\n\tif(nodes[node_id].left_child == -1){\n\n\t\treturn nodes[node_id].num;\n\n\t}else{\n\n\t\tint left_num = calc(nodes[node_id].left_child);\n\t\tint right_num = calc(nodes[node_id].right_child);\n\n\t\tbool check[4] = {false,false,false,false};\n\n\t\tint double_num = 0,one_num = 0;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif((left_num & (1 << i)) != 0 && (right_num & (1 << i)) != 0){\n\t\t\t\tcheck[i] = true;\n\t\t\t\tdouble_num++;\n\t\t\t}else if((left_num & (1 << i)) == 0 && (right_num & (1 << i)) != 0){\n\t\t\t\tcheck[i] = true;\n\t\t\t\tone_num++;\n\t\t\t}else if((left_num & (1 << i)) != 0 && (right_num & (1 << i)) == 0){\n\t\t\t\tcheck[i] = true;\n\t\t\t\tone_num++;\n\t\t\t}\n\t\t}\n\n\t\tif(double_num == 0){\n\n\t\t\tans *= 2;\n\t\t\treturn left_num+right_num;\n\n\t\t}else if(one_num == 0){\n\n\t\t\tans *= 2;\n\t\t\treturn left_num;\n\n\t\t}else{\n\n\t\t\tint ret = 0;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tif(check[i]){\n\t\t\t\t\tret += POW[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 200; i++){\n\t\tnodes[i].left_child = -1;\n\t\tnodes[i].right_child = -1;\n\t\tnodes[i].num = -1;\n\t\tnodes[i].code_id = -1;\n\t}\n\n\tfor(length = 0; buf[length] != '\\0' && buf[length] != '\\n'; length++);\n\n\tnodes_index = 1;\n\trecursive(1,length-2,0);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint tmp[4],table[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d %d %d %d\",&tmp[0],&tmp[1],&tmp[2],&tmp[3]);\n\n\t\ttable[i] = POW[3]*tmp[0] + POW[2]*tmp[1] + POW[1]*tmp[2] + POW[0]*tmp[3];\n\t}\n\n\tfor(int i = 0; i < nodes_index;i++){\n\t\tif(nodes[i].code_id != -1){\n\t\t\tnodes[i].num = table[nodes[i].code_id];\n\t\t}\n\t}\n\n\tans = 1;\n\tcalc(0);\n\n\tprintf(\"%d\\n\",ans);\n\tgetchar();\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tfgets(buf,200,stdin);\n\t\tif(buf[0] == 'E')break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<vector>\n#include<map>\ntypedef std::map<int,int>M;\ntypedef M::iterator I;\ntypedef std::pair<int,int>P;\nstd::vector<P>v;\nint x[10];\nint F(char*&p,int n)\n{\n\tif(isdigit(*p))\n\t\treturn -*p+'0';\n\tv.push_back(P(0,0));\n\tint r=F(++p,v.size());\n\tv[n].first=r;\n\tr=F(p+=2,v.size());\n\tv[n].second=r;\n\t++p;\n\treturn n;\n}\nM G(int i)\n{\n\tM m;\n\tif(i<0)m[x[-i]]=1;\n\telse\n\t{\n\t\tM a(G(v[i].first)),b(G(v[i].second));\n\t\tfor(I p=a.begin();p!=a.end();++p)for(I q=b.begin();q!=b.end();++q)\n\t\t{\n\t\t\tint a=p->first,b=q->first,c=p->second*q->second;\n\t\t\tm[a&b]+=c;\n\t\t\tm[a|b]+=c;\n\t\t\tm[a^b]+=c;\n\t\t}\n\t}\n\treturn m;\n}\nint main()\n{\n\tint n,i,j,t;\n\tchar*p,s[512];\n\twhile(fgets(s,512,stdin),*s-'E')\n\t{\n\t\tv.clear();\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;++i)for(x[i]=j=0;j<4;++j)scanf(\"%d\",&t),x[i]=x[i]*2+t;\n\t\tt=F(p=s,0);\n\t\tprintf(\"%d\\n\",t?x[-t]==15:G(0)[15]);\n\t\tfgets(s,512,stdin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nint node[10];\nstring str;\nint ans,a,n,cnt;\nvector<int> v[10];\n\nvector<int> parse(string s){\n  if('1'<=s[0] && s[0]<= '9'){\n    return v[s[0]-'0'-1];\n  }\n\n  int pos = 0;\n  int k=0;\n  while(pos<s.size()){\n    if(s[pos]=='(')k++;\n    if(s[pos]==')')k--;\n    \n    if(k==1 && s[pos] == ' '){\n      vector<int> x = parse(s.substr(1,pos-1));\n      vector<int> y = parse(s.substr(pos+1,(int)s.size()-2-pos));\n      \n      if(node[cnt] == 0){\n\tcnt++;\n\tvector<int> res;\n\tfor(int i=0;i<4;i++)\n\t  res.push_back(x[i]&y[i]);\t\n\treturn res;\n      }\n      \n      if(node[cnt] == 1){\n\tcnt++;\n\tvector<int> res;\n\tfor(int i=0;i<4;i++)\n\t  res.push_back(x[i]|y[i]);\t\n\treturn res;\n      }\n      \n      if(node[cnt] == 2){\n\tcnt++;\n\tvector<int> res;\n\tfor(int i=0;i<4;i++)\n\t  res.push_back(x[i]!=y[i]);\t\n\treturn res;\n      }\n    }\n    pos++;\n  }\n}\n\nvoid rec(int s){\n  if(s == a){\n    cnt = 0;\n    vector<int> tmp = parse(str);\n    int pop=0;\n \n    for(int i=0;i<4;i++)\n      if(tmp[i])pop++;\n    if(pop==4)ans++;\n    \n    return;\n  }\n  for(int i=0;i<3;i++){\n    node[s] = i;\n    rec(s+1);\n  }\n}\n\nint main(){\n  int c = 0;\n  while(getline(cin,str)){\n    if(str==\"END\")break;\n    a = 0;\n    for(int i=0;i<(int)str.size();i++)\n      if(str[i] == ' ')a++;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      v[i].clear();\n      int hoge;\n      for(int j=0;j<4;j++){\n\tcin >> hoge;\n\tv[i].push_back(hoge);\n      }\n    }\n    ans = 0;\n    rec(0);\n    cout << ans << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstring in;\nP data[50];\nint data2[50];\nint da[10], db[10], dc[10], dd[10], n, p;\nint data3[50], ans;\n\nint calc(int r, int l){\n  int now = p++;\n  bool f = true;\n  for(int i=r;i<=l;i++){\n    if(in[i] == ')' || in[i] == '(') f = false;\n  }\n  if(f){\n    data2[now] = atoi(in.substr(r, l-r+1).c_str()) - 1;\n    return now;\n  }\n  for(int i=r;i<=l;i++){\n    if(in[i] == ' '){\n      data[now].first = calc(r+1, i-1);\n      data[now].second = calc(i+1, l-1);\n    }\n  }\n  return now;\n}\n\nint calc2(int pos){\n  if(data2[pos] != -1){\n    int tmp = data2[pos];\n    int res = 0;\n    if(da[tmp] == 1) res += 1<<3;\n    if(db[tmp] == 1) res += 1<<2;\n    if(dc[tmp] == 1) res += 1<<1;\n    if(dd[tmp] == 1) res += 1<<0;\n    return res;\n  }\n  if(data3[pos] == 0) return calc2(data[pos].first) & calc2(data[pos].second);\n  if(data3[pos] == 1) return calc2(data[pos].first) | calc2(data[pos].second);\n  if(data3[pos] == 2) return calc2(data[pos].first) ^ calc2(data[pos].second);\n}\n\nvoid change(int pos){\n  if(data2[pos] != -1){\n    if(calc2(0) == 15) ans++;\n    return;\n  }\n  data3[pos] = 0;\n  change(data[pos].first);\n  data3[pos] = 1;\n  change(data[pos].first);\n  data3[pos] = 2;\n  change(data[pos].first);\n}\n\nmain(){\n  while(1){\n    getline(cin, in);\n    if(in == \"END\") break;\n    fill(data, data+20, P(-1, -1));\n    fill(data2, data2+20, -1);\n    p = 0;\n    calc(0, (int)in.size()-1);\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> da[i] >> db[i] >> dc[i] >> dd[i];\n    }\n    getchar();\n    ans = 0;\n    change(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstring in;\nP data[50];\nint data2[50];\nint da[10], db[10], dc[10], dd[10], n, p;\nint data3[50], ans;\n\nint calc(int r, int l){\n  int now = p++;\n  bool f = true;\n  for(int i=r;i<=l;i++){\n    if(in[i] == ')' || in[i] == '(') f = false;\n  }\n  if(f){\n    data2[now] = atoi(in.substr(r, l-r+1).c_str()) - 1;\n    return now;\n  }\n  for(int i=r;i<=l;i++){\n    if(in[i] == ' '){\n      data[now].first = calc(r+1, i-1);\n      data[now].second = calc(i+1, l-1);\n    }\n  }\n  return now;\n}\n\nint calc2(int pos){\n  if(data2[pos] != -1){\n    int tmp = data2[pos];\n    int res = 0;\n    if(da[tmp] == 1) res += 1<<3;\n    if(db[tmp] == 1) res += 1<<2;\n    if(dc[tmp] == 1) res += 1<<1;\n    if(dd[tmp] == 1) res += 1<<0;\n    return res;\n  }\n  if(data3[pos] == 0) return calc2(data[pos].first) & calc2(data[pos].second);\n  if(data3[pos] == 1) return calc2(data[pos].first) | calc2(data[pos].second);\n  if(data3[pos] == 2) return calc2(data[pos].first) ^ calc2(data[pos].second);\n}\n\nvoid change(int pos){\n  if(data2[pos] != -1){\n    if(calc2(0) == 15) ans++;\n    return;\n  }\n  data3[pos] = 0;\n  change(data[pos].first);\n  data3[pos] = 1;\n  change(data[pos].first);\n  data3[pos] = 2;\n  change(data[pos].first);\n}\n\nmain(){\n  while(1){\n    getline(cin, in);\n    if(in == \"END\") break;\n    fill(data, data+20, P(0, 0));\n    fill(data2, data2+20, -1);\n    p = 0;\n    calc(0, (int)in.size()-1);\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> da[i] >> db[i] >> dc[i] >> dd[i];\n    }\n    getchar();\n    ans = 0;\n    change(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint id_cnt=0;\n\nstruct node{\n\tnode *left,*right;\n\tint n,id;\n\tnode(node *left,node *right,int id):left(left),right(right),n(-1),id(id){}\n\tnode(int n,int id):n(n),left(NULL),right(NULL),id(id){}\n\n\tvi search(vvi &masks,string &pattern){\n\t\tif(n!=-1){\n\t\t\treturn masks[n];\n\t\t}\n\t\tvi l_mask=left->search(masks,pattern);\n\t\tvi r_mask=right->search(masks,pattern);\n\t\tvi ret(4);\n\t\tswitch(pattern[id]){\n\t\tcase 'A':\n\t\t\tREP(i,4){\n\t\t\t\tret[i]=l_mask[i]&r_mask[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tREP(i,4){\n\t\t\t\tret[i]=l_mask[i]|r_mask[i];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tREP(i,4){\n\t\t\t\tret[i]=l_mask[i]^r_mask[i];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid make_initial_pattern(string &pattern){\n\t\tif(n!=-1){\n\t\t\tpattern[id]='.';\n\t\t}else{\n\t\t\tpattern[id]='A';\n\t\t}\n\t\tif(left){\n\t\t\tleft->make_initial_pattern(pattern);\n\t\t}\n\t\tif(right){\n\t\t\tright->make_initial_pattern(pattern);\n\t\t}\n\t}\n};\n\n\nnode *read(string &s, int &p){\n\tswitch(s[p]){\n\tcase '(':\n\t\t{\n\t\tp++;\n\t\tnode *left=read(s,p);\n\t\tassert(s[p]==' ');\n\t\tp++;\n\t\tnode *right=read(s,p);\n\t\tassert(s[p]==')');\n\t\tp++;\n\t\treturn new node(left,right,id_cnt++);\n\t\t}\n\tdefault:\n\t\tassert(isdigit(s[p]));\n\t\treturn new node(s[p++]-'0'-1,id_cnt++);\n\t}\n}\n\nbool increment(string &pattern,int n){\n\tif(n==pattern.size()){\n\t\treturn false;\n\t}\n\tswitch(pattern[n]){\n\tcase 'A':\n\t\tpattern[n]='O';break;\n\tcase 'O':\n\t\tpattern[n]='X';break;\n\tcase 'X':\n\t\tpattern[n]='A';\n\t\tif(!increment(pattern,n+1)){\n\t\t\treturn false;\t\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif(!increment(pattern,n+1)){\n\t\t\treturn false;\t\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tstring s;\n\twhile(getline(cin,s),s!=\"END\"){\n\t\tint p=0;\n\t\tnode *root=read(s,p);\n\t\tint n;\n\t\tcin>>n;\n\t\tvvi masks(n);\n\t\tREP(i,n){\n\t\t\tREP(j,4){\n\t\t\t\tint b;\n\t\t\t\tcin>>b;\n\t\t\t\tmasks[i].push_back(b);\n\t\t\t}\n\t\t}\n\t\tstring pattern(id_cnt,' ');\n\t\troot->make_initial_pattern(pattern);\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tvi m=root->search(masks,pattern);\n\t\t\tbool flag=true;\n\t\t\tREP(i,4){\n\t\t\t\tif(m[i]==0){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(!increment(pattern,0)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tgetline(cin,s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nint curPos = 0;\nstring str;\nint info[128] = {};\nvector< vector<int> > g;\nint number[128] = {};\nint mx = 0;\nvoid parse(int pos){\n\t//cout << curPos << \" \" << str[curPos] << endl;\n\tmx = max(pos,mx);\n\tif( str[curPos] >= '0' && str[curPos] <= '9'){\n\t\tnumber[pos] = info[ str[curPos] - '0' - 1];\n\t\tcurPos++;\n\t\treturn;\n\t}\n\t\n\tassert(str[curPos] == '(');\n\tcurPos++;\n\tg[pos].push_back(pos*2+1);\n\tparse(pos*2+1);\n\t\n\tassert(str[curPos] == ' ');\n\tcurPos++; // space \n\t\n\t\n\tg[pos].push_back(pos*2+2);\n\tparse(pos*2+2);\n\tassert(str[curPos] == ')');\n\tcurPos++;\n\treturn;\n}\n\nint calc(int a,int b,int t){\n\tif( t == 0 ) return a & b;\n\tif( t == 1 ) return a | b;\n\treturn a^b;\n}\n\nint tmp[30] = {};\n\nvector<int> all(int pos){\n\tif( number[pos] >= 0 ){\n\t\tvector<int> c(16);\n\t\tc[number[pos]] = 1;\n\t\t//cout << pos << \" : \";\n\t\t//for(int i = 0 ; i < 16 ; i++) cout << c[i] << \" \"; cout << endl;\n\t\treturn c;\n\t}else{\n\t\tvector<int> a,b,c(16);\n\t\ta = all(pos*2+1);\n\t\tb = all(pos*2+2);\n\t\tfor(int k = 0 ; k < 3 ; k++){\n\t\t\tfor(int i = 0 ; i < 16 ; i++){\n\t\t\t\tfor(int j = 0 ; j < 16 ; j++){\n\t\t\t\t\tc[calc(i,j,k)] += a[i] * b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << pos << \" : \";\n\t\t//for(int i = 0 ; i < 16 ; i++) cout << c[i] << \" \"; cout << endl;\n\t\treturn c;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\t\twhile( getline(cin,str) && (str == \"\" || str == \"END\") ){ if(str == \"END\") return 0; }\n\t\tfor(int i = 0 ; i < 128 ; i++) number[i] = -1;\n\t\tcin >> n;\n\t\tg.clear();\n\t\tg.resize(128);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint inf = 0 , a;\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tinf |= (a<<j);\n\t\t\t}\n\t\t\tinfo[i] = inf;\n\t\t}\n\t\tstr += \"~\";\n\t\tcurPos = 0;\n\t\tmx = 0;\n\t\tparse(0);\n\t\tassert(str[curPos] == '~');\n\t\t/*for(int i = 0 ; i <= mx ; i++){\n\t\t\tcout << i << \"(\" << number[i] << \")\" << \" : \";\n\t\t\tfor(int j =0 ; j < g[i].size() ; j++) cout << g[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tvector<int> answer = all(0);\n\t\tcout << answer[15] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for(int i = m; i < int(n); ++i)\n\nstring str;\nint n;\n\nint bit[10];\n\nvoid f(string s, int res[]) {\n  //cout << s << endl;\n  rep (i, 20) res[i] = 0;\n  if (s[0] != '(') {\n    res[bit[atoi(s.c_str()) - 1]] = 1;\n    //cout << bit[atoi(s.c_str()) - 1] << endl;\n    return;\n  }\n  int count = 0;\n  int left[20], right[20];\n  repn (i, 1, s.size() - 1) {\n    if (s[i] == '(') ++count;\n    if (s[i] == ')') --count;\n    if (s[i] == ' ' && count == 0) {\n      f(s.substr(1, i - 1), left);\n      f(s.substr(i + 1, s.size() - i - 2), right);\n    }\n  }\n  rep (i, 20) res[i] = 0;\n  rep (i, 16) rep (j, 16) {\n    if (left[i] && right[j]) {\n      res[i & j] += left[i] * right[j];\n      res[i | j] += left[i] * right[j];\n      res[i ^ j] += left[i] * right[j];\n    }\n  }\n  //cout << s << endl;\n  //rep (i, 16) cout << i << \" \" << res[i] << endl;\n}\n\nint main() {\n  for (;;) {\n    getline(cin, str);\n    if (str == \"END\") break;\n    cin >> n;\n    rep (i, n) {\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      bit[i] = 8 * a + 4 * b + 2 * c + d;\n    }\n    int res[20];\n    f(str, res);\n    cout << res[15] << endl;\n    getline(cin, str);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstring in;\nP data[20];\nint data2[20];\nint da[10], db[10], dc[10], dd[10], n, p;\nint data3[20], ans;\n\nint calc(int r, int l){\n  int now = p++;\n  bool f = true;\n  for(int i=r;i<=l;i++){\n    if(in[i] == ')' || in[i] == '(') f = false;\n  }\n  if(f){\n    data2[now] = atoi(in.substr(r, l-r+1).c_str()) - 1;\n    return now;\n  }\n  for(int i=r;i<=l;i++){\n    if(in[i] == ' '){\n      data[now].first = calc(r+1, i-1);\n      data[now].second = calc(i+1, l-1);\n    }\n  }\n  return now;\n}\n\nint calc2(int pos){\n  if(data2[pos] != -1){\n    int tmp = data2[pos];\n    int res = 0;\n    if(da[tmp] == 1) res += 1<<3;\n    if(db[tmp] == 1) res += 1<<2;\n    if(dc[tmp] == 1) res += 1<<1;\n    if(dd[tmp] == 1) res += 1<<0;\n    return res;\n  }\n  if(data3[pos] == 0) return calc2(data[pos].first) & calc2(data[pos].second);\n  if(data3[pos] == 1) return calc2(data[pos].first) | calc2(data[pos].second);\n  if(data3[pos] == 2) return calc2(data[pos].first) ^ calc2(data[pos].second);\n}\n\nvoid change(int pos){\n  if(data2[pos] != -1){\n    if(calc2(0) == 15) ans++;\n    return;\n  }\n  data3[pos] = 0;\n  change(data[pos].first);\n  data3[pos] = 1;\n  change(data[pos].first);\n  data3[pos] = 2;\n  change(data[pos].first);\n}\n\nmain(){\n  while(1){\n    getline(cin, in);\n    if(in == \"END\") break;\n    fill(data, data+20, P(-1, -1));\n    fill(data2, data2+20, -1);\n    p = 0;\n    calc(0, (int)in.size()-1);\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> da[i] >> db[i] >> dc[i] >> dd[i];\n    }\n    getchar();\n    ans = 0;\n    change(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Tree[1<<18],m;\nmap<int,int> mp;\nvector<int> order;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1, bit);\n    int r = getBit(2*v+2, bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint getNum(string::iterator &it){\n    int res = 0;\n    while(isdigit(*it)){\n        res *= 10;\n        res += *it-'0';\n        ++it;\n    }\n    --it;\n    return res;\n}\n\nvoid makeTree(string &s){\n    memset(Tree,-1,sizeof(Tree));\n    int depth = -1;\n    string::iterator it;\n    for(it = s.begin() ; it != s.end() ; ++it){\n        if(*it == '(') depth++;\n        else if(*it == ')') depth--;\n        else if(isdigit(*it)){\n            Tree[2*depth+1] = getNum(it)-1;\n        }else{\n            ++it;\n            Tree[2*depth+2] = getNum(it)-1;\n        }\n    }\n}\n\nvoid dfs(int v,int depth){\n    if(depth == 17) return;\n    if(Tree[v] == -1){\n        mp[v] = m++;\n        dfs(2*v+1, depth+1);\n        dfs(2*v+2, depth+1);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        int res = 0;\n        makeTree(s); m = 0; dfs(0,0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define A (0)\n#define O (1)\n#define X (2)\n#define PRINT_FLAG(x) for(int i = 0; i < 4; i++)printf(\"%d\", ((x) >> i) & 1); puts(\"\");\n\ntypedef struct tree {\n\tint point;\n\tunsigned int flag;\n\tstruct tree *right;\n\tstruct tree *left;\n} TREE;\n\nint input_tree(TREE *root, char str[], int i);\nint set_flag(TREE *root, int point, unsigned int flag);\nint make_num(int depth, int num, int max_depth, TREE *root);\nunsigned int check_tree(TREE *root, int *mode_list, bool flag);\n\n\nint input_count;\nint ans;\nint leaf_count;\n\nint main(void)\n{\n\tTREE root;\n\tchar str[100];\n\t\n\twhile (1){\n\t\tleaf_count = 0;\n\t\tans = 0;\n\t\troot.right = root.left = NULL;\n\t\tinput_count = 0;\n\t\t\n\t\tfgets(str, 100, stdin);\n\t\tif (str[0] == 'E'){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tinput_tree(&root, str, 0);\n\t\tscanf(\"%d\", &input_count);\n\t\tif (input_count == 0){\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < input_count; i++){\n\t\t\tunsigned flag = 0;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tunsigned int flag_;\n\t\t\t\tscanf(\"%u\", &flag_);\n\t\t\t\t\n\t\t\t\tflag |= flag_ << j;\n\t\t\t}\n\t\t\t\n\t\t\tset_flag(&root, i, flag);\n\t\t}\n\t\t\n\t\tmake_num(0, 0, leaf_count - 1, &root);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t}\n\treturn (0);\n}\n\nint input_tree(TREE *root, char str[], int i)\n{\n\twhile (1){\n\t\tif (str[i] == '\\0'){\n\t\t\treturn (i);\n\t\t}\n\t\t\n\t\tif (str[i] == '('){\n\t\t\troot->right = (TREE *)malloc(sizeof(TREE));\n\t\t\troot->left = (TREE *)malloc(sizeof(TREE));\n\t\t\t\n\t\t\troot->right->right = root->right->left = root->left->right = root->left->left = NULL;\n\t\t\ti = input_tree(root->left, str, i + 1);\n\t\t\ti = input_tree(root->right, str, i + 1);\n\t\t\treturn (i);\n\t\t}\n\t\tif (str[i] >= '1' && str[i] <= '9'){\n\t\t\tleaf_count++;\n\t\t\troot->point = str[i] - '0' - 1;\n\t\t\treturn (i);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint make_num(int depth, int num, int max_depth, TREE *root)\n{\n\tif (depth == max_depth){\n\t\tbool flag = false;\n\t\t\n\t\tif (check_tree(root, &num, flag) == 0xf){\n\t\t\tans++;\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (int i = A; i <= X; i++){\n\t\tint temp = num * 10;\n\t\ttemp += i;\n\t\tmake_num(depth + 1, temp, max_depth, root);\n\t}\n\t\n\treturn (0);\n}\n\nunsigned int check_tree(TREE *root, int *mode_list, bool flag)\n{\n\tunsigned int ans_flag;\n\t\n\tif (root->left == NULL){\n\t\treturn (root->flag);\n\t}\n\telse {\n\t\tunsigned int flag1 = check_tree(root->left, mode_list, flag);\n\t\tunsigned int flag2 = check_tree(root->right, mode_list, flag);\n\t\t\n\t\tif (flag)printf(\"%d\\n\", *mode_list % 10);\n\t\tswitch (*mode_list % 10){\n\t\t  case 0:\n\t\t  \tans_flag = (flag1 & flag2);\n\t\t\tbreak;\n\t\t  case 1:\n\t\t  \tans_flag = (flag1 | flag2);\n\t\t\tbreak;\n\t\t  case 2:\n\t\t  \tans_flag = (flag1 ^ flag2);\n\t\t\tbreak;\n\t\t}\n\t\t*mode_list /= 10;\n\t}\n\t\n\tif (flag){\n\t\tPRINT_FLAG(ans_flag);\n\t}\n\t\n\treturn (ans_flag);\n}\n\nint set_flag(TREE *root, int point, unsigned int flag)\n{\n\tif (root == NULL){\n\t\treturn (0);\n\t}\n\tset_flag(root->left, point, flag);\n\tset_flag(root->right, point, flag);\n\t\n\t\n\tif (root->point == point){\n\t\troot->flag = flag;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[1024];\nvoid out(void);\n//((1 2) 3)\n//(1 (2 3))\n//(1 ((2 3) 4))\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 || tree[ima*2+2].mark==-1)return tree[ima].bit;\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\n\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=1000)ima++;\n  if(ima>1000 && check(0)==(1<<4)-1)ans++;\n  else if(ima<1000)\n    for(int i=0;i<=2;i++)tree[ima].mark = i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<1024;i++)tree[i].bit=-1,tree[i].mark=-1;\n  int ima=0,num=0,p[1024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  if(flg==0)return flg;\n\n  int m;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n\n  while(input()){\n    ans=0;\n    mark_dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<7;i++){\n    cout << tree[i].mark<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nvector<int> g_sets;\n\nstruct Result {\n        int value, p;\n};\n\n#define PARSER_DECL(name) \\\n        Result name (const string &s, int p)\n\nPARSER_DECL(expr);\nPARSER_DECL(factor);\n\nPARSER_DECL(expr){\n        Result r = factor(s, p);\n        while(isupper(s[r.p])){\n                Result q = factor(s, r.p + 1);\n                switch(s[r.p]){\n                        case 'A': r.value &= q.value; break;\n                        case 'O': r.value |= q.value; break;\n                        case 'X': r.value ^= q.value; break;\n                }\n                r.p = q.p;\n        }\n        return r;\n}\nPARSER_DECL(factor){\n        Result r;\n        if(s[p] == '('){\n                r = expr(s, p + 1);\n                ++r.p;\n        }else{\n                int index = 0;\n                while(isdigit(s[p])){\n                        index = (index * 10) + (s[p] - '0');\n                        ++p;\n                }\n                r.value = g_sets[index];\n                r.p = p;\n        }\n        return r;\n}\n\nint solve(string &s, const vector<int> &op, int i){\n        int answer = 0;\n        if(i == op.size()){\n                answer = (expr(s, 0).value == 15 ? 1 : 0);\n        }else{\n                const char OPERATIONS[] = \"AOX\";\n                for(int j = 0; j < 3; ++j){\n                        s[op[i]] = OPERATIONS[j];\n                        answer += solve(s, op, i + 1);\n                }\n        }\n        return answer;\n}\n\nint main(){\n        while(true){\n                string s;\n                getline(cin, s);\n                if(s == \"END\"){ break; }\n                vector<int> op;\n                for(int i = 0; i < s.size(); ++i){\n                        if(s[i] == ' '){ op.push_back(i); }\n                }\n                int n;\n                cin >> n;\n                g_sets = vector<int>(n + 1);\n                for(int i = 1; i <= n; ++i){\n                        int a, b, c, d;\n                        cin >> a >> b >> c >> d;\n                        g_sets[i] = (a << 3) | (b << 2) | (c << 1) | d;\n                }\n                cout << solve(s, op, 0) << endl;\n                getline(cin, s);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint x[10];\nint type[10];\nstring s;\nint num;\n\nint parse(int l, int r){\n\tif (r-l == 1) return x[s[l] - '1'];\n\n\tint sp;\n\tfor (int i = l; i < r; ++i){\n\t\tif (s[i] == ' ') sp = i;\n\t}\n\n\tint res1 = parse(l + 1, sp);\n\tint res2 = parse(sp + 1, r - 1);\n\n\tint ret = -1;\n\tif (type[num] == 0) ret = res1 | res2;\n\tif (type[num] == 1) ret = res1 & res2;\n\tif (type[num] == 2) ret = res1 ^ res2;\n\t++num;\n\treturn ret;\n}\n\n\nint ans;\nint m;\nvoid rec(int n){\n\tif (n == m){\n\t\tnum = 0;\n\t\t//cout << parse(0, s.size()) << endl;\n\t\tans += parse(0, s.size()) == 15;\n\t\treturn;\n\t}\n\trep(i, 3){\n\t\ttype[n] = i;\n\t\trec(n + 1);\n\t}\n}\n\nint main(){\n\twhile (getline(cin, s), s != \"END\"){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tMEMSET(x, 0);\n\t\trep(i, n) rep(j, 4){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tx[i] |= (t << j);\n\t\t}\n\t\tans = 0;\n\t\tm = count(ALL(s), ' ');\n\t\trec(0);\n\t\tcout << ans << endl;\n\t\tcin.ignore();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstring in;\nP data[30];\nint data2[30];\nint da[10], db[10], dc[10], dd[10], n, p;\nint data3[30], ans;\n\nint calc(int r, int l){\n  int now = p++;\n  bool f = true;\n  for(int i=r;i<=l;i++){\n    if(in[i] == ')' || in[i] == '(') f = false;\n  }\n  if(f){\n    data2[now] = atoi(in.substr(r, l-r+1).c_str()) - 1;\n    return now;\n  }\n  for(int i=r;i<=l;i++){\n    if(in[i] == ' '){\n      data[now].first = calc(r+1, i-1);\n      data[now].second = calc(i+1, l-1);\n    }\n  }\n  return now;\n}\n\nint calc2(int pos){\n  if(data2[pos] != -1){\n    int tmp = data2[pos];\n    int res = 0;\n    if(da[tmp] == 1) res += 1<<3;\n    if(db[tmp] == 1) res += 1<<2;\n    if(dc[tmp] == 1) res += 1<<1;\n    if(dd[tmp] == 1) res += 1<<0;\n    return res;\n  }\n  if(data3[pos] == 0) return calc2(data[pos].first) & calc2(data[pos].second);\n  if(data3[pos] == 1) return calc2(data[pos].first) | calc2(data[pos].second);\n  if(data3[pos] == 2) return calc2(data[pos].first) ^ calc2(data[pos].second);\n}\n\nvoid change(int pos){\n  if(data2[pos] != -1){\n    if(calc2(0) == 15) ans++;\n    return;\n  }\n  data3[pos] = 0;\n  change(data[pos].first);\n  data3[pos] = 1;\n  change(data[pos].first);\n  data3[pos] = 2;\n  change(data[pos].first);\n}\n\nmain(){\n  while(1){\n    getline(cin, in);\n    if(in == \"END\") break;\n    fill(data, data+20, P(-1, -1));\n    fill(data2, data2+20, -1);\n    p = 0;\n    calc(0, (int)in.size()-1);\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> da[i] >> db[i] >> dc[i] >> dd[i];\n    }\n    getchar();\n    ans = 0;\n    change(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring expr;\nint n,sweet[4],s,ans;\nint eval(int b,int e){\n\tif(b+1==e)return sweet[expr[b]-'1'];\n\tint l,o,r,d;\n\tfor(o=b,d=0;o<e;o++){\n\t\tchar c=expr[o];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='&'||c=='|'||c=='^'))break;\n\t}\n\tif(o==e&&expr[b]=='(')return eval(b+1,e-1);\n\tl=eval(b,o),r=eval(o+1,e);char c=expr[o];\n\treturn c!='&'?c=='^'?l^r:l|r:l&r;\n}\nvoid op(int c){\n\tfor(;c<s;c++)if(expr[c]==' ')break;\n\tif(c<s)rep(i,3){\n\t\texpr[c]=\"&|^\"[i];op(c+1);expr[c]=' ';\n\t}else if(eval(0,s)==15)ans++;\n}\nint main(){\n\twhile(getline(cin,expr),expr!=\"END\"){\n\t\ts=expr.size(),ans=0;cin>>n;\n\t\trep(i,n){\n\t\t\tint t;sweet[i]=0;\n\t\t\trep(j,4)cin>>t,sweet[i]<<=1,sweet[i]+=t;\n\t\t}\n\t\top(0);\n\t\tcout<<ans<<endl;\n\t\tcin.ignore();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n  \nvector<int>aget(const vector<int>&l, const vector<int>&r,const int type) {\n\tvector<int>v(4);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tif (type == 0)v[i] = l[i] || r[i];\n\t\telse if (type == 1)v[i] = l[i] && r[i];\n\t\telse v[i] = l[i] ^ r[i];\n\t}\n\treturn v;\n}\n\nstruct node {\n\tint type;\n\tnode* l;\n\tnode* r;\n\n\tnode() : l(nullptr), r(nullptr) {\n\t\ttype = -1;\n\t}\n};\n\n\nstring st;\nint a = 0;\nint  num = 0;\nvector<vector<int>>cakes;\nnode* make_tree() {\n\tnode* no=new node();\n\tif (st[a] == '(') {\n\t\tnum++;\n\t\tno->type = -num;\n\t\ta++;\n\t\tno->l = make_tree();\n\t\ta++;\n\t\tassert(st[a] == ' ');\n\t\ta++;\n\t\tno->r = make_tree();\n\t\ta++;\n\t\tassert(st[a] == ')');\n\t}\n\telse {\n\t\tno->type = st[a] - '1';\n\t}\n\treturn no;\n}\n\nvector<int>getans(node* now,const vector<int>&types) {\n\tif (now->type <0) {\n\t\treturn aget(getans(now->l, types), getans(now->r, types), types[-now->type - 1]);\n\t}\n\telse {\n\t\treturn cakes[now->type];\n\t}\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (getline(cin, st)) {\n\t\tcakes.clear();\n\t\tif (st == \"END\")break;\n\t\ta = 0;\n\t\tnum = 0;\n\t\tnode* root(make_tree());\n\t\tint M; cin >> M;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tvector<int>v(4);\n\t\t\tfor (int j = 0; j < 4; ++j)cin >> v[j];\n\t\t\tcakes.emplace_back(v);\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <powint(3,num); ++i) {\n\t\t\tvector<int>types(num);\n\t\t\t{\n\t\t\t\tint n(i);\n\t\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\t\ttypes[i] = n % 3;\n\t\t\t\t\tn /= 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto ans = getans(root, types);\n\t\t\tif (all_of(ans.begin(), ans.end(), [](const int a) {return a == 1; })) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t\tgetline(cin, st);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nint bits[11];\nconst char *ptr;\n\nvector<int> parse(){\n\tvector<int> ret(16);\n\tif(*ptr == '('){\n\t\t++ptr;\n\t\tvector<int> v1 = parse();\n\t\t++ptr;\n\t\tvector<int> v2 = parse();\n\t\t++ptr;\n\n\t\tfor(int i = 0; i < 16; ++i)\n\t\tfor(int j = 0; j < 16; ++j){\n\t\t\tint x = v1[i] * v2[j];\n\t\t\tret[i & j] += x;\n\t\t\tret[i | j] += x;\n\t\t\tret[i ^ j] += x;\n\t\t}\n\t}\n\telse{\n\t\tchar *endp;\n\t\tint k = strtol(ptr, &endp, 10);\n\t\tptr = endp;\n\t\tret[bits[k]] = 1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint num[16] = {};\n\tfor(int i = 0; i < 15; ++i){\n\t\tfor(int j = 0; j < 4; ++j){\n\t\t\tif(i >> j & 1) ++num[i];\n\t\t}\n\t}\n\n\tstring s;\n\tint n, x;\n\twhile(getline(cin, s), s[0] != 'E'){\n\t\tptr = s.c_str();\n\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tint t = 0;\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tcin >> x;\n\t\t\t\tt = t << 1 | x;\n\t\t\t}\n\t\t\tbits[i] = t;\n\t\t}\n\t\tcin.ignore();\n\n\t\tvector<int> ret = parse();\n\t\tcout << ret[15] << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <map>\n#include <memory>\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nconstexpr int NUM = 4;\nconstexpr int MAX_N = 10;\n\narray<int, MAX_N> S;\n\nstruct node_t {\n\tint S_index;\n\tunique_ptr<node_t> left;\n\tunique_ptr<node_t> right;\n\n\tnode_t(int index = -1):S_index(index) {}\n\n\tbool is_leaf() const {\n\t\treturn S_index != -1;\n\t}\n\n\tunordered_map<int, int> calc() const {\n\t\tif(is_leaf()) return {{S[S_index], 1}};\n\n\t\tunordered_map<int, int> res;\n\t\tconst auto l_result = left->calc();\n\t\tconst auto r_result = right->calc();\n\n\t\tfor(const auto &l_e : l_result) {\n\t\t\tfor(const auto &r_e : r_result) {\n\t\t\t\tconst int inc = l_e.second * r_e.second;\n\t\t\t\tres[l_e.first & r_e.first] += inc;\n\t\t\t\tres[l_e.first | r_e.first] += inc;\n\t\t\t\tres[l_e.first ^ r_e.first] += inc;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nunique_ptr<node_t> parse(string::const_iterator &it) {\n\tunique_ptr<node_t> res(new node_t);\n\n\tif(isdigit(*it)) {\n\t\tres->S_index = *it - '1';\n\t\t++it;\n\t}\n\telse {\n\t\t++it; // '('\n\t\tres->left = parse(it);\n\t\t++it; // ' '\n\t\tres->right = parse(it);\n\t\t++it; // ')'\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tconstexpr int all = (1 << NUM) - 1;\n\n\tfor(string line; getline(cin, line) && line != \"END\";) {\n\t\tstring::const_iterator it = line.cbegin();\n\t\tunique_ptr<node_t> root = parse(it);\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tS.fill(0);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < NUM; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tS[i] |= (in << j);\n\t\t\t}\n\t\t}\n\t\tcin.ignore();\n\n\t\tauto ans = root->calc();\n\t\tcout << ans[all] << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define A (0)\n#define O (1)\n#define X (2)\n#define PRINT_FLAG(x) for(int i = 0; i < 4; i++)printf(\"%d\", ((x) >> i) & 1); puts(\"\");\n\ntypedef struct tree {\n\tunsigned int flag;\n\tstruct tree *right;\n\tstruct tree *left;\n} TREE;\n\nint input_tree(TREE *root, char str[], int i, TREE *point[10]);\nint make_num(int depth, int num, int max_depth, TREE *root);\nunsigned int check_tree(TREE *root, int *mode_list, bool flag);\n\n\nint input_count;\nint ans;\n\nint main(void)\n{\n\tTREE root;\n\tTREE *point[10];\n\tchar str[100];\n\t\n\twhile (1){\n\t\tans = 0;\n\t\troot.right = root.left = NULL;\n\t\tinput_count = 0;\n\t\t\n\t\tfgets(str, 100, stdin);\n\t\tif (str[0] == 'E'){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tinput_tree(&root, str, 0, point);\n\t\tscanf(\"%d\", &input_count);\n\t\tif (input_count == 0){\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < input_count; i++){\n\t\t\tpoint[i]->flag = 0;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tunsigned int flag;\n\t\t\t\tscanf(\"%u\", &flag);\n\t\t\t\t\n\t\t\t\tpoint[i]->flag |= flag << j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmake_num(0, 0, input_count - 1, &root);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t}\n\treturn (0);\n}\n\nint input_tree(TREE *root, char str[], int i, TREE *point[10])\n{\n\twhile (1){\n\t\tif (str[i] == '\\0'){\n\t\t\treturn (i);\n\t\t}\n\t\t\n\t\tif (str[i] == '('){\n\t\t\troot->right = (TREE *)malloc(sizeof(TREE));\n\t\t\troot->left = (TREE *)malloc(sizeof(TREE));\n\t\t\t\n\t\t\troot->right->right = root->right->left = root->left->right = root->left->left = NULL;\n\t\t\ti = input_tree(root->left, str, i + 1, point);\n\t\t\ti = input_tree(root->right, str, i + 1, point);\n\t\t\treturn (i);\n\t\t}\n\t\tif (str[i] >= '1' && str[i] <= '9'){\n\t\t\tpoint[str[i] - '0' - 1] = root;\n\t\t\treturn (i);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint make_num(int depth, int num, int max_depth, TREE *root)\n{\n\tif (depth == max_depth){\n\t\tbool flag = false;\n\t\t\n\t\tif (check_tree(root, &num, flag) == 0xf){\n\t\t\tans++;\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tnum *= 10;\n\t\n\tfor (int i = A; i <= X; i++){\n\t\tint temp = num;\n\t\ttemp += i;\n\t\tmake_num(depth + 1, temp, max_depth, root);\n\t}\n\t\n\treturn (0);\n}\n\nunsigned int check_tree(TREE *root, int *mode_list, bool flag)\n{\n\tunsigned int ans_flag;\n\t\n\tif (root->left == NULL){\n\t\treturn (root->flag);\n\t}\n\telse {\n\t\tunsigned int flag1 = check_tree(root->left, mode_list, flag);\n\t\tunsigned int flag2 = check_tree(root->right, mode_list, flag);\n\t\t\n\t\t//if (flag)printf(\"%d\\n\", *mode_list % 10);\n\t\tswitch (*mode_list % 10){\n\t\t  case 0:\n\t\t  \tans_flag = (flag1 & flag2);\n\t\t\tbreak;\n\t\t  case 1:\n\t\t  \tans_flag = (flag1 | flag2);\n\t\t\tbreak;\n\t\t  case 2:\n\t\t  \tans_flag = (flag1 ^ flag2);\n\t\t\tbreak;\n\t\t}\n\t\t*mode_list /= 10;\n\t}\n\t\n\t/*if (flag){\n\t\tPRINT_FLAG(ans_flag);\n\t}*/\n\t\n\treturn (ans_flag);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Tree[114514],m;\nmap<int,int> mp;\nvector<int> order;\n\nvector<int> getOrder(int x,int m){\n    vector<int> res;\n    while(x > 0){\n        res.push_back(x%3);\n        x /= 3;\n    }\n    while((int)res.size() != m){\n        res.push_back(0);\n    }\n    return res;\n}\n\nint getBit(int v,vector<int> &bit){\n    if(Tree[v] != -1){\n        return bit[Tree[v]];\n    }\n    int S = -1;\n    int l = getBit(2*v+1, bit);\n    int r = getBit(2*v+2, bit);\n    switch(order[mp[v]]){\n    case 0:\n        S = l & r;\n        break;\n    case 1:\n        S = l | r;\n        break;\n    case 2:\n        S = (l | r) - (l & r);\n        break;\n    };\n    return S;\n}\n\nbool check(vector<int> &bit){\n    return (getBit(0,bit) == (1<<4)-1);\n}\n\nint getNum(string::iterator &it){\n    int res = 0;\n    while(isdigit(*it)){\n        res *= 10;\n        res += *it-'0';\n        ++it;\n    }\n    --it;\n    return res;\n}\n\nvoid makeTree(string &s){\n    memset(Tree,-1,sizeof(Tree));\n    int depth = -1;\n    string::iterator it;\n    for(it = s.begin() ; it != s.end() ; ++it){\n        if(*it == '(') depth++;\n        else if(*it == ')') depth--;\n        else if(isdigit(*it)){\n            Tree[2*depth+1] = getNum(it)-1;\n        }else{\n            ++it;\n            Tree[2*depth+2] = getNum(it)-1;\n        }\n    }\n}\n\nvoid dfs(int v){\n    if(Tree[v] == -1){\n        mp[v] = m++;\n        dfs(2*v+1);\n        dfs(2*v+2);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s), s != \"END\"){\n        int N,x;\n        cin >> N;\n        vector<int> bit(N, 0);\n        for(int i = 0 ; i < N ; i++){\n            for(int j = 0 ; j < 4 ; j++){\n                cin >> x;\n                if(x == 1) bit[i] |= 1<<j;\n            }\n        }\n        if(s.size() == 1) for(;;){}\n        int res = 0;\n        makeTree(s); m = 0; dfs(0);\n        int n = pow(3., m);\n        for(int i = 0 ; i < n ; i++){\n            order = getOrder(i, m);\n            if(check(bit)) res++;\n        }\n        cout << res << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nconst char opr[] = {'A','O','X'};\n\n#define N 4\n#define WHITES 16\n#define DIGIT 16\n\nstruct Set{\n  bool sweet[N];\n  Set(){fill(sweet,sweet+N,false);}\n  Set And(const Set &t){\n    Set ret;\n    for(int i=0;i<N;++i){ret.sweet[i]=sweet[i]&&t.sweet[i];}\n    return ret;\n  }\n  Set Or(const Set &t){\n    Set ret;\n    for(int i=0;i<N;++i){ret.sweet[i]=sweet[i]||t.sweet[i];}\n    return ret;\n  }\n  Set Xor(const Set &t){\n    Set ret;\n    for(int i=0;i<N;++i){ret.sweet[i]=(!sweet[i]&&t.sweet[i])||(!t.sweet[i]&&sweet[i]);}\n    return ret;\n  }\n};\ntypedef pair<int,Set> parsed;\nSet sets[DIGIT];\n\nparsed parse(const string &s, int pos);\nparsed term(const string &s, int pos);\n\nparsed parse(const string &s, int pos){\n  ++pos;\n  parsed L = term(s, pos);\n  pos = L.first;\n  char op = s[pos++];\n  parsed R = term(s, pos );\n  pos = R.first + 1;\n  //cout << \" R TERM, NEXT POS \" << pos << ' ' << s[pos] << endl;\n  Set result;\n  if(op=='A')result=L.second.And(R.second);\n  if(op=='O')result=L.second.Or(R.second);\n  if(op=='X')result=L.second.Xor(R.second);\n  return parsed( pos, result );\n}\n\nparsed term(const string &s, int pos){\n  if( s[pos] == '(' ){\n    return parse(s,pos);\n  }else if( isdigit(s[pos]) ){\n    return parsed( pos + 1, sets[ s[pos] - '0' ] );\n  }\n}\n\nvoid dfs(string &s, int n, int white[], bool used[], int left, int &ans){\n  if( left == 0 ){\n    bool ng=false;\n    //cout << s << \" : \";\n    parsed ps = parse(s,0);\n    Set ts = ps.second;\n    for(int i = 0; i < N; ++i){\n      //cout << ts.sweet[i] << ' ';\n      if( !ts.sweet[i] ){ng=true;}\n    }\n    //cout << endl;\n    if(ng)return ;\n    ++ans;\n    return ;\n  }\n  for(int i = 0; i < n; ++i){\n    if( !used[i] ){\n      used[i]=true;\n      for(int k = 0; k < sizeof(opr)/sizeof(*opr); ++k){\n\ts[ white[i] ] = opr[k];\n\tdfs(s,n,white,used,left-1,ans);\n      }\n      s[ white[i] ] =' ';\n      used[i]=false;\n      break;\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    string s;\n    int num = 0;\n    int pos_white[WHITES];\n    bool used[WHITES]={false,};\n    getline(cin,s);\n    if( s == \"END\" ) break;\n\n    for(int i = 0; i < s.length(); ++i){\n      if( s[i] == ' ' ){\n\tpos_white[num++] = i;\n      }\n    }\n    \n    int n;\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < N; ++j){\n\tint d;\n\tcin >> d;\n\tif( d == 1 ) sets[i+1].sweet[j] = 1;\n\telse sets[i+1].sweet[j] = 0;\n      }\n    }\n    \n    dfs(s, num, pos_white, used, num, ans );\n    getline(cin,s);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stack>\nusing namespace std;\n\n\nint ans;\nvector<int> s;\n\nvoid solve(stack<int> stk, string str, unsigned int p)\n{\n\tif (str.size() == p) {\n\t\tif (stk.top() == 15)\n\t\t\t++ans;\n\t\treturn;\n\t}\n\n\tint st = 0;\n\tfor (; p < str.size(); ++p) {\n\t\tif (str[p] == '0')\n\t\t\tbreak;\n\t\tstk.push(str[p] - '0');\n\t\t++st;\n\t}\n\n\tint a, b;\n\tif (st == 0) {\n\t\ta = stk.top();\n\t\tstk.pop();\n\t\tb = stk.top();\n\t\tstk.pop();\n\t} else {\n\t\ta = s[stk.top()-1];\n\t\tstk.pop();\n\t\tif (st == 1)\n\t\t\tb = stk.top();\n\t\telse\n\t\t\tb = s[stk.top()-1];\n\t\tstk.pop();\n\t}\n\n\tstk.push(a|b);\n\tsolve(stk, str, p+1);\n\tstk.pop();\n\n\tstk.push(a&b);\n\tsolve(stk, str, p+1);\n\tstk.pop();\n\n\tstk.push(a^b);\n\tsolve(stk, str, p+1);\n\tstk.pop();\n}\n\nint main()\n{\n\tfor ( ; ; ) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif (tree == \"END\")\n\t\t\tbreak;\n\n\t\tfor (string::iterator it = tree.begin(); it != tree.end(); ) {\n\t\t\tif ((*it) == '(' || (*it) == ' ') {\n\t\t\t\tit = tree.erase(it);\n\t\t\t} else if ((*it) == ')') {\n\t\t\t\t*it = '0';\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t\tint n;\n\t\tcin >> n;\n\t\ts.clear();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ts.push_back(a*8 + b*4 + c*2 + d);\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tsolve(stack<int>(), tree, 0);\n\t\tcout << ans << endl;\n\n\t\t// skip '\\n'\n\t\tgetline(cin, tree);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint x[15];\nint type[15];\nstring s;\nint num;\n\nint parse(int l, int r){\n\tif (r-l == 1) return x[s[l] - '1'];\n\n\tint sp = -1, nest = 0;\n\tfor (int i = l+1; i < r-1; ++i){\n\t\tif (s[i] == '(') ++nest;\n\t\tif (s[i] == ')') --nest;\n\t\tif (!nest && s[i] == ' ') sp = i;\n\t}\n\n\tint res1 = parse(l + 1, sp);\n\tint res2 = parse(sp + 1, r - 1);\n\n\tint ret = -1;\n\tif (type[num] == 0) ret = res1 | res2;\n\tif (type[num] == 1) ret = res1 & res2;\n\tif (type[num] == 2) ret = res1 ^ res2;\n\t++num;\n\treturn ret;\n}\n\n\nint ans;\nint m;\nvoid rec(int n){\n\tif (n == m){\n\t\tnum = 0;\n\t\t//cout << parse(0, s.size()) << endl;\n\t\tans += parse(0, s.size()) == 15;\n\t\treturn;\n\t}\n\trep(i, 3){\n\t\ttype[n] = i;\n\t\trec(n + 1);\n\t}\n}\n\nint main(){\n\twhile (getline(cin, s), s != \"END\"){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tMEMSET(x, 0);\n\t\trep(i, n) rep(j, 4){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tx[i] |= (t << j);\n\t\t}\n\t\tans = 0;\n\t\tm = count(ALL(s), ' ');\n\t\trec(0);\n\t\tcout << ans << endl;\n\t\tcin.ignore();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint curPos = 0;\nstring str;\nint info[18] = {};\nvector< vector<int> > g;\nint number[18] = {};\nint mx = 0;\nvoid parse(int pos){\n\t//cout << curPos << \" \" << str[curPos] << endl;\n\tmx = max(pos,mx);\n\tif( str[curPos] >= '0' && str[curPos] <= '9'){\n\t\tnumber[pos] = info[ str[curPos] - '0' - 1];\n\t\tcurPos++;\n\t\treturn;\n\t}\n\t\n\t\n\tcurPos++;\n\tg[pos].push_back(pos*2+1);\n\tparse(pos*2+1);\n\t\n\t\n\tcurPos++; // space \n\t\n\t\n\tg[pos].push_back(pos*2+2);\n\tparse(pos*2+2);\n\t\n\tcurPos++;\n\treturn;\n}\n\nint calc(int a,int b,int t){\n\tif( t == -1 ) return a & b;\n\tif( t == -2 ) return a | b;\n\treturn a^b;\n}\n\nint tmp[30] = {};\n\n\nint all(int pos){\n\tif( tmp[pos] >= 0 ){\n\t\treturn number[pos];\n\t}else{\n\t\treturn calc(all(pos*2+1),all(pos*2+2),tmp[pos]);\n\t}\n}\n\nint answer = 0;\nint dfs(int pos){\n\tif(pos == mx+1){\n\t\tint r = all(0);\n\t\tanswer +=r == 15;\n\t\treturn 0;\n\t}\n\tif( number[pos] == -1){\n\t\tfor(int i = 1 ; i <= 3 ; i++){\n\t\t\ttmp[pos] = -i;\n\t\t\tdfs(pos+1);\n\t\t}\n\t}else{\n\t\ttmp[pos] = number[pos];\n\t\tdfs(pos+1);\n\t}\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(1){\n\t\t\twhile( getline(cin,str) && (str == \"\" || str == \"END\") ){ if(str == \"END\") return 0; }\n\t\t\n\t\tfor(int i = 0 ; i < 18 ; i++) number[i] = -1;\n\t\tcin >> n;\n\t\tg.clear();\n\t\tg.resize(18);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint inf = 0 , a;\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tcin >> a;\n\t\t\t\tinf |= (a<<j);\n\t\t\t}\n\t\t\tinfo[i] = inf;\n\t\t}\n\t\tcurPos = 0;\n\t\tmx = 0;\n\t\tparse(0);\n\t\t/*for(int i = 0 ; i <= mx ; i++){\n\t\t\tcout << i << \"(\" << number[i] << \")\" << \" : \";\n\t\t\tfor(int j =0 ; j < g[i].size() ; j++) cout << g[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tanswer = 0;\n\t\tdfs(0);\n\t\tcout << answer << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring expr;\nint n,sweet[10],s,ans;\nint eval(int b,int e){\n\tif(b+1==e)return sweet[expr[b]-'1'];\n\tint l,o,r,d;\n\tfor(o=b,d=0;o<e;o++){\n\t\tchar c=expr[o];\n\t\tif(c=='(')d++;\n\t\tif(c==')')d--;\n\t\tif(d==0&&(c=='&'||c=='|'||c=='^'))break;\n\t}\n\tif(o==e&&expr[b]=='(')return eval(b+1,e-1);\n\tl=eval(b,o),r=eval(o+1,e);char c=expr[o];\n\treturn c!='&'?c=='^'?l^r:l|r:l&r;\n}\nvoid op(int c){\n\tfor(;c<s;c++)if(expr[c]==' ')break;\n\tif(c<s)rep(i,3){\n\t\texpr[c]=\"&|^\"[i];op(c+1);expr[c]=' ';\n\t}else if(eval(0,s)==15)ans++;\n}\nint main(){\n\twhile(getline(cin,expr),expr!=\"END\"){\n\t\ts=expr.size(),ans=0;cin>>n;\n\t\trep(i,n){\n\t\t\tint t;sweet[i]=0;\n\t\t\trep(j,4)cin>>t,sweet[i]<<=1,sweet[i]+=t;\n\t\t}\n\t\top(0);\n\t\tcout<<ans<<endl;\n\t\tcin.ignore();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define A (0)\n#define O (1)\n#define X (2)\n#define PRINT_FLAG(x) for(int i = 0; i < 4; i++)printf(\"%d\", ((x) >> i) & 1); puts(\"\");\n\ntypedef struct tree {\n\tint point;\n\tunsigned int flag;\n\tstruct tree *right;\n\tstruct tree *left;\n} TREE;\n\nint input_tree(TREE *root, char str[], int i);\nint set_flag(TREE *root, int point, unsigned int flag);\nint make_num(int depth, int num, int max_depth, TREE *root);\nunsigned int check_tree(TREE *root, int *mode_list, bool flag);\n\n\nint input_count;\nint ans;\nint leaf_count;\n\nint main(void)\n{\n\tTREE root;\n\tchar str[100];\n\t\n\twhile (1){\n\t\tleaf_count = 0;\n\t\tans = 0;\n\t\troot.right = root.left = NULL;\n\t\tinput_count = 0;\n\t\t\n\t\tfgets(str, 100, stdin);\n\t\tif (str[0] == 'E'){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tinput_tree(&root, str, 0);\n\t\tscanf(\"%d\", &input_count);\n\t\tif (input_count == 0){\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < input_count; i++){\n\t\t\tunsigned flag = 0;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tunsigned int flag_;\n\t\t\t\tscanf(\"%u\", &flag_);\n\t\t\t\t\n\t\t\t\tflag |= flag_ << j;\n\t\t\t}\n\t\t\t\n\t\t\tset_flag(&root, i, flag);\n\t\t}\n\t\t\n\t\tmake_num(0, 0, leaf_count - 1, &root);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t}\n\treturn (0);\n}\n\nint input_tree(TREE *root, char str[], int i)\n{\n\twhile (1){\n\t\tif (str[i] == '\\0'){\n\t\t\treturn (i);\n\t\t}\n\t\t\n\t\tif (str[i] == '('){\n\t\t\troot->right = (TREE *)malloc(sizeof(TREE));\n\t\t\troot->left = (TREE *)malloc(sizeof(TREE));\n\t\t\t\n\t\t\troot->right->right = root->right->left = root->left->right = root->left->left = NULL;\n\t\t\ti = input_tree(root->left, str, i + 1);\n\t\t\ti = input_tree(root->right, str, i + 1);\n\t\t\treturn (i);\n\t\t}\n\t\tif (str[i] >= '1' && str[i] <= '9'){\n\t\t\tleaf_count++;\n\t\t\troot->point = str[i] - '0' - 1;\n\t\t\treturn (i);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint make_num(int depth, int num, int max_depth, TREE *root)\n{\n\tif (depth == max_depth){\n\t\tbool flag = false;\n\t\t\n\t\tif (check_tree(root, &num, flag) == 0xf){\n\t\t\tans++;\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (int i = A; i <= X; i++){\n\t\tint temp = num * 10;\n\t\ttemp += i;\n\t\tmake_num(depth + 1, temp, max_depth, root);\n\t}\n\t\n\treturn (0);\n}\n\nunsigned int check_tree(TREE *root, int *mode_list, bool flag)\n{\n\tunsigned int ans_flag;\n\t\n\tif (root->left == NULL){\n\t\treturn (root->flag);\n\t}\n\telse {\n\t\tunsigned int flag1 = check_tree(root->left, mode_list, flag);\n\t\tunsigned int flag2 = check_tree(root->right, mode_list, flag);\n\t\t\n\t\tif (flag)printf(\"%d\\n\", *mode_list % 10);\n\t\tswitch (*mode_list % 10){\n\t\t  case 0:\n\t\t  \tans_flag = (flag1 & flag2);\n\t\t\tbreak;\n\t\t  case 1:\n\t\t  \tans_flag = (flag1 | flag2);\n\t\t\tbreak;\n\t\t  case 2:\n\t\t  \tans_flag = (flag1 ^ flag2);\n\t\t\tbreak;\n\t\t}\n\t\t*mode_list /= 10;\n\t}\n\t\n\tif (flag){\n\t\tPRINT_FLAG(ans_flag);\n\t}\n\t\n\treturn (ans_flag);\n}\n\nint set_flag(TREE *root, int point, unsigned int flag)\n{\n\tif (root == NULL){\n\t\treturn (0);\n\t}\n\tset_flag(root->left, point, flag);\n\tset_flag(root->right, point, flag);\n\t\n\t\n\tif (root->point == point){\n\t\troot->flag = flag;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define A (0)\n#define O (1)\n#define X (2)\n#define PRINT_FLAG(x) for(int i = 0; i < 4; i++)printf(\"%d\", ((x) >> i) & 1); puts(\"\");\n\ntypedef struct tree {\n\tint point;\n\tunsigned int flag;\n\tstruct tree *right;\n\tstruct tree *left;\n} TREE;\n\nint input_tree(TREE *root, char str[], int i);\nint set_flag(TREE *root, int point, unsigned int flag);\nint make_num(int depth, int num, int max_depth, TREE *root);\nunsigned int check_tree(TREE *root, int *mode_list, bool flag);\n\n\nint input_count;\nint ans;\nint leaf_count;\n\nint main(void)\n{\n\tTREE root;\n\tchar str[100];\n\t\n\twhile (1){\n\t\tleaf_count = 0;\n\t\tans = 0;\n\t\troot.right = root.left = NULL;\n\t\tinput_count = 0;\n\t\t\n\t\tfgets(str, 100, stdin);\n\t\tif (str[0] == 'E'){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tinput_tree(&root, str, 0);\n\t\tscanf(\"%d\", &input_count);\n\t\tif (input_count == 0){\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < input_count; i++){\n\t\t\tunsigned flag = 0;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tunsigned int flag_;\n\t\t\t\tscanf(\"%u\", &flag_);\n\t\t\t\t\n\t\t\t\tflag |= flag_ << j;\n\t\t\t}\n\t\t\t\n\t\t\tset_flag(&root, i, flag);\n\t\t}\n\t\t\n\t\tmake_num(0, 0, leaf_count - 1, &root);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t}\n\treturn (0);\n}\n\nint input_tree(TREE *root, char str[], int i)\n{\n\twhile (1){\n\t\tif (str[i] == '\\0'){\n\t\t\treturn (i);\n\t\t}\n\t\t\n\t\tif (str[i] == '('){\n\t\t\troot->right = (TREE *)malloc(sizeof(TREE));\n\t\t\troot->left = (TREE *)malloc(sizeof(TREE));\n\t\t\t\n\t\t\troot->right->right = root->right->left = root->left->right = root->left->left = NULL;\n\t\t\ti = input_tree(root->left, str, i + 1);\n\t\t\ti = input_tree(root->right, str, i + 1);\n\t\t\treturn (i);\n\t\t}\n\t\tif (str[i] >= '1' && str[i] <= '9'){\n\t\t\tleaf_count++;\n\t\t\troot->point = str[i] - '0' - 1;\n\t\t\treturn (i);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint make_num(int depth, int num, int max_depth, TREE *root)\n{\n\tif (depth == max_depth){\n\t\tbool flag = false;\n\t\t\n\t\tif (check_tree(root, &num, flag) == 0xf){\n\t\t\tans++;\n\t\t}\n\t\treturn (0);\n\t}\n\t\n\tfor (int i = A; i <= X; i++){\n\t\tint temp = num * 10;\n\t\ttemp += i;\n\t\tmake_num(depth + 1, temp, max_depth, root);\n\t}\n\t\n\treturn (0);\n}\n\nunsigned int check_tree(TREE *root, int *mode_list, bool flag)\n{\n\tunsigned int ans_flag;\n\t\n\tif (root->left == NULL){\n\t\treturn (root->flag);\n\t}\n\telse {\n\t\tunsigned int flag1 = check_tree(root->left, mode_list, flag);\n\t\tunsigned int flag2 = check_tree(root->right, mode_list, flag);\n\t\t\n\t\tif (flag)printf(\"%d\\n\", *mode_list % 10);\n\t\tswitch (*mode_list % 10){\n\t\t  case 0:\n\t\t  \tans_flag = (flag1 & flag2);\n\t\t\tbreak;\n\t\t  case 1:\n\t\t  \tans_flag = (flag1 | flag2);\n\t\t\tbreak;\n\t\t  case 2:\n\t\t  \tans_flag = (flag1 ^ flag2);\n\t\t\tbreak;\n\t\t}\n\t\t*mode_list /= 10;\n\t}\n\t\n\tif (flag){\n\t\tPRINT_FLAG(ans_flag);\n\t}\n\t\n\treturn (ans_flag);\n}\n\nint set_flag(TREE *root, int point, unsigned int flag)\n{\n\tif (root == NULL){\n\t\treturn (0);\n\t}\n\tset_flag(root->left, point, flag);\n\tset_flag(root->right, point, flag);\n\t\n\t\n\tif (root->point == point){\n\t\troot->flag = flag;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstring s;\nint n,p;\nint t[20];\n\n\nvector<int> solve(){\n  vector<int> res(1<<4);\n\n  if(s[p]!='('){\n    res[t[s[p]-'0']]=1;\n    p++;\n    return res;\n  }\n\n  p++;\n  vector<int> lv=solve();\n  p++;\n  vector<int> rv=solve();\n  p++;\n\n  for(int i=0;i<(1<<4);i++){\n    for(int j=0;j<(1<<4);j++){\n      res[i|j]+=lv[i]*rv[j];\n      res[i&j]+=lv[i]*rv[j];\n      res[i^j]+=lv[i]*rv[j];\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    getline(cin,s);    \n    if(s==\"END\")break;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      int S=0,a;\n      for(int j=0;j<4;j++){\n\tcin>>a;\n\tS+=(a<<j);\n      }\n      t[i]=S;\n    }  \n    p=0;\n    vector<int> ans=solve();\n    cout<<ans[(1<<4)-1]<<endl;\n    cin.ignore();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stack>\nusing namespace std;\n\nvector<int> s;\n\nint solve(stack<int> stk, istringstream& iss)\n{\n\tif (iss.eof()) {\n\t\tif (stk.top() == 15)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint n, st = 0;\n\twhile (iss >> n) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tstk.push(n);\n\t\t++st;\n\t}\n\n\tint a, b;\n\tif (st == 0) {\n\t\ta = stk.top();\n\t\tstk.pop();\n\t\tb = stk.top();\n\t\tstk.pop();\n\t} else {\n\t\ta = s[stk.top()-1];\n\t\tstk.pop();\n\t\tif (st == 1)\n\t\t\tb = stk.top();\n\t\telse\n\t\t\tb = s[stk.top()-1];\n\t\tstk.pop();\n\t}\n\n\tint cnt = 0;\n\tstk.push(a|b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\tstk.push(a&b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\tstk.push(a^b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\treturn cnt;\n}\n\nint main()\n{\n\tfor ( ; ; ) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif (tree == \"END\")\n\t\t\tbreak;\n\n\t\tfor (string::iterator it = tree.begin(); it != tree.end(); ) {\n\t\t\tif ((*it) == '(') {\n\t\t\t\tit = tree.erase(it);\n\t\t\t} else if ((*it) == ')') {\n\t\t\t\t*it = '0';\n\t\t\t\tit = tree.insert(it, ' ');\n\t\t\t\tit += 2;\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ts.push_back(a*8 + b*4 + c*2 + d);\n\t\t}\n\n\t\tistringstream iss(tree);\n\n\t\t// skip '\\n'\n\t\tgetline(cin, tree);\n\n\t\tcout << solve(stack<int>(), iss) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Node{\n\tint num,left_child,right_child,code_id;\n};\n\nNode nodes[200];\nint nodes_index;\n\nchar buf[200];\nint length,POW[4] = {1,2,4,8},ans;\n\nvoid recursive(int left,int right,int parent_index){\n\tint depth = 0;\n\tint count = 0;\n\n\tfor(int i = left; i <= right;){\n\n\t\tif(depth == 0 && buf[i] == '('){\n\t\t\tdepth = 1;\n\n\t\t\tfor(int k = i+1; k <= right; k++){\n\t\t\t\tif(buf[k] == '('){\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(buf[k] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\t\tnodes[parent_index].left_child = nodes_index;\n\t\t\t\t\t\t\tnodes_index++;\n\t\t\t\t\t\t\trecursive(i+1,k-1,nodes_index-1);\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\ti = k+2;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnodes[parent_index].right_child = nodes_index;\n\t\t\t\t\t\t\tnodes_index++;\n\t\t\t\t\t\t\trecursive(i+1,k-1,nodes_index-1);\n\t\t\t\t\t\t\ti = k+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(buf[i] >= '1' && buf[i] <= '9'){\n\n\t\t\tint code_id = buf[i]-'0';\n\n\t\t\tif(count == 0){\n\t\t\t\tnodes[parent_index].left_child = nodes_index;\n\t\t\t\ti += 2;\n\t\t\t}else{\n\t\t\t\tnodes[parent_index].right_child = nodes_index;\n\t\t\t\ti += 1;\n\t\t\t}\n\n\t\t\tnodes[nodes_index].code_id = code_id;\n\t\t\tnodes_index++;\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint calc(int node_id){\n\n\tif(nodes[node_id].left_child == -1){\n\n\t\treturn nodes[node_id].num;\n\n\t}else{\n\n\t\tint left_num = calc(nodes[node_id].left_child);\n\t\tint right_num = calc(nodes[node_id].right_child);\n\n\t\tbool check[4] = {false,false,false,false};\n\n\t\tint double_num = 0,one_num = 0;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif((left_num & (1 << i)) != 0 && (right_num & (1 << i)) != 0){\n\t\t\t\tcheck[i] = true;\n\t\t\t\tdouble_num++;\n\t\t\t}else if((left_num & (1 << i)) == 0 && (right_num & (1 << i)) != 0){\n\t\t\t\tcheck[i] = true;\n\t\t\t\tone_num++;\n\t\t\t}else if((left_num & (1 << i)) != 0 && (right_num & (1 << i)) == 0){\n\t\t\t\tcheck[i] = true;\n\t\t\t\tone_num++;\n\t\t\t}\n\t\t}\n\n\t\tif(double_num == 0 && right_num == 0){\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(double_num == 0){\n\n\t\t\tans *= 2;\n\t\t\treturn left_num+right_num;\n\n\t\t}else if(one_num == 0){\n\n\t\t\tans *= 2;\n\t\t\treturn left_num;\n\n\t\t}else{\n\n\t\t\tint ret = 0;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tif(check[i]){\n\t\t\t\t\tret += POW[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 200; i++){\n\t\tnodes[i].left_child = -1;\n\t\tnodes[i].right_child = -1;\n\t\tnodes[i].num = -1;\n\t\tnodes[i].code_id = -1;\n\t}\n\n\tfor(length = 0; buf[length] != '\\0' && buf[length] != '\\n'; length++);\n\n\tnodes_index = 1;\n\trecursive(1,length-2,0);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint tmp[4],table[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%d %d %d %d\",&tmp[0],&tmp[1],&tmp[2],&tmp[3]);\n\n\t\ttable[i] = POW[3]*tmp[0] + POW[2]*tmp[1] + POW[1]*tmp[2] + POW[0]*tmp[3];\n\t}\n\n\tfor(int i = 0; i < nodes_index;i++){\n\t\tif(nodes[i].code_id != -1){\n\t\t\tnodes[i].num = table[nodes[i].code_id];\n\t\t}\n\t}\n\n\tans = 1;\n\tcalc(0);\n\n\tprintf(\"%d\\n\",ans);\n\tgetchar();\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tfgets(buf,200,stdin);\n\t\tif(buf[0] == 'E')break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[10024];\nvoid out(void);\n//((1 2) 3)\n//(1 (2 3))\n//(1 ((2 3) 4))\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 && tree[ima*2+2].mark==-1)return tree[ima].bit;\nassert(tree[ima].mark!=-1);\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\n\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=10000)ima++;\n  if(ima>10000 && check(0)==(1<<4)-1)ans++;\n  else if(ima<=10000)\n    for(int i=0;i<=2;i++)tree[ima].mark=i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<10024;i++)tree[i].bit=-1,tree[i].mark=-1;\n  int ima=0,num=0,p[1024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  assert(ima==0);\n  if(flg==0)return flg;\n\n  int m;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    mark_dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<7;i++){\n    cout << tree[i].mark<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct P {\n  int l,r,d;\n}p[10000];\n\nstring s;\nint k;\nmap<int,int> ma;\nint a[11];\n\nvoid dfs(int x) {\n  while(k<s.size()) {\n    if(s[k]=='(') {\n      k++;\n      p[x].l=x*2;\n      dfs(x*2);\n    }\n    if(s[k]==' ') {\n      k++;\n      p[x].r=x*2+1;\n      dfs(x*2+1);\n    }\n    if(isdigit(s[k])) {\n      int y=0;\n      while(k<s.size()&&isdigit(s[k])) {\n        y*=10;\n        y+=s[k]-'0';\n        k++;\n      }\n      p[x].d=y;\n      break;\n    }\n    if(s[k]==')') {\n      k++;\n      break;\n    }\n  }\n}\n\nint dfs2(int x) {\n  if(p[x].l!=-1) {\n    int ll=dfs2(p[x].l);\n    int rr=dfs2(p[x].r);\n    int r=ma[x];\n    if(r==0) return ll&rr;\n    else if(r==1) return ll|rr;\n    return ll^rr;\n  }\n  return a[p[x].d-1];\n}\n\nint main() {\n  while(1) {\n    getline(cin,s);\n    if(s==\"END\") break;\n    int n;\n    cin >> n;\n    memset(a,0,sizeof(a));\n    for(int i=0; i<n; i++) {\n      for(int j=0,c; j<4; j++) {\n        cin >> c;\n        a[i]|=c<<j;\n      }\n    }\n    for(int i=0; i<10000; i++) p[i]=(P){-1,-1,-1};\n    k=0;\n    dfs(1);\n    vector<int> v;\n    for(int i=0; i<10000; i++) {\n      if(p[i].l!=-1) v.push_back(i);\n    }\n    int m=v.size(),ans=0;\n    for(int t=0; t<(1<<(2*m)); t++) {\n      bool f=1;\n      ma.clear();\n      for(int i=0; i<m; i++) {\n        int b=(t>>(i*2))%4;\n        if(b==3) f=0;\n        else ma[v[i]]=b;\n      }\n      if(!f) continue;\n      if(dfs2(1)==15) ans++;\n    }\n    cout << ans << endl;\n    getline(cin,s);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<string>\n#include<iostream>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint subset[8];\n\nint TREE(const string &,int &);\nint  NUM(const string &,int &);\nchar OPE(const string &,int &);\n\nint TREE(const string &exp,int &idx){\n\tif(isdigit(exp[idx]))\treturn NUM(exp,idx);\n\n\tidx++;\n\tint a=TREE(exp,idx);\n\tchar o=OPE(exp,idx);\n\tint b=TREE(exp,idx);\n\tidx++;\n\n\tif     (o=='a')\treturn a&b;\n\telse if(o=='o')\treturn a|b;\n\telse\t\t\treturn a^b;\n}\n\nint NUM(const string &exp,int &idx){\n\treturn subset[exp[idx++]-'0'-1];\n}\n\nchar OPE(const string &exp,int &idx){\n\treturn exp[idx++];\n}\n\nint parse(const string &exp){\n\tint idx=0;\n\treturn TREE(exp,idx)==15;\n}\n\nint main(){\n\tfor(string s;getline(cin,s),s!=\"END\";){\n\t\tint len=s.length();\n\t\tint n;\tcin>>n;\n\t\trep(i,n){\n\t\t\tsubset[i]=0;\n\t\t\trep(j,4){\n\t\t\t\tint t;\tcin>>t;\n\t\t\t\tsubset[i]|=t<<j;\n\t\t\t}\n\t\t}\n\t\tcin.ignore();\n\n\t\tint sppos[7];\n\t\tfor(int i=0,j=0;i<len;i++) if(s[i]==' ') sppos[j++]=i;\n\n\t\tint cnt=0;\n\t\tchar op[]=\"aox\";\n\t\trep(i,(int)pow(3.,n-1)){\n\t\t\tint k=i;\n\t\t\tstring exp=s;\n\t\t\trep(j,n-1){\n\t\t\t\texp[sppos[j]]=op[k%3];\n\t\t\t\tk/=3;\n\t\t\t}\n\t\t\tif(parse(exp))\tcnt++;\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint u[50], a[50], cnt, ans, lim;\nstring s;\nint dfs(string&s, int&i) {\n\tif (s[i] == '(') {\n\t\tint b = cnt++;\n\t\ti++; int l = dfs(s, i); i++;\n\t\tint r = dfs(s, i); i++;\n\t\tif (a[b] == 0)return l&r;\n\t\telse if (a[b] == 1)return l | r;\n\t\telse return l^r;\n\t}\n\telse {\n\t\tint a = u[s[i] - '1']; i++;\n\t\treturn a;\n\t}\n}\nvoid calc(int p) {\n\tif (p == lim) {\n\t\tint i = 0; cnt = 0; if (dfs(s, i) == (1 << 4) - 1)ans++;\n\t\treturn;\n\t}\n\trep(i, 3)a[p] = i, calc(p + 1);\n}\nint main() {\n\twhile (getline(cin, s), s != \"END\") {\n\t\tint n; scanf(\"%d\", &n);\n\t\tmemset(u, 0, sizeof(u));\n\t\trep(i, n)rep(j, 4) {\n\t\t\tint a; scanf(\"%d\", &a);\n\t\t\tu[i] |= a << j;\n\t\t}\n\t\tcnt = 0; int i = 0; dfs(s, i);\n\t\tlim = cnt;\n\t\tans = 0; calc(0);\n\t\tprintf(\"%d\\n\", ans);\n\t\tscanf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct tree {\n  bool is_leaf;\n  int idx;\n  int value;\n  vector<tree> children;\n  tree() {}\n  tree(int i) : is_leaf(true), idx(i) {}\n  tree(const tree& l, const tree& r) : is_leaf(false), children(2)\n  {\n    children[0] = l;\n    children[1] = r;\n  }\n\n  tree left() const { return children[0]; }\n  tree right() const { return children[1]; }\n};\n\npair<tree,int> parse(const string& s, int start = 0)\n{\n  if (s[start] == '(') {\n    pair<tree,int> left = parse(s, start+1);\n    pair<tree,int> right = parse(s, left.second+1);\n    return make_pair(tree(left.first, right.first), right.second+1);\n  } else {\n    return make_pair(tree(s[start]-'1'), start+1);\n  }\n}\n\nvector<int> evals(const tree& t, vector<int> binds)\n{\n  if (t.is_leaf) {\n    return vector<int>(1, binds[t.idx]);\n  } else {\n    const vector<int> l = evals(t.left(), binds);\n    const vector<int> r = evals(t.right(), binds);\n    vector<int> ret;\n    for (vector<int>::const_iterator it(l.begin()); it != l.end(); ++it) {\n      for (vector<int>::const_iterator jt(r.begin()); jt != r.end(); ++jt) {\n        ret.push_back(*it & *jt);\n        ret.push_back(*it | *jt);\n        ret.push_back(*it ^ *jt);\n      }\n    }\n    return ret;\n  }\n}\n\nvoid print(const tree& t)\n{\n  if (t.is_leaf) {\n    cout << t.idx;\n  } else {\n    cout << '(';\n    print(t.children[0]);\n    cout << ' ';\n    print(t.children[1]);\n    cout << ')';\n  }\n}\n\nint main()\n{\n  string s;\n  while (getline(cin, s) && s != \"END\") {\n    pair<tree,int> p = parse(s);\n    getline(cin, s);\n    int N = s[0]-'0';\n    vector<int> b(N);\n    for (int i = 0; i < N; i++) {\n      getline(cin, s);\n      int v = 0;\n      for (int j = 0; j < 4; j++) {\n        int a = s[j*2]-'0';\n        v = (v<<1) | a;\n      }\n      b[i] = v;\n    }\n\n    int ans = 0;\n    vector<int> r = evals(p.first, b);\n    for (vector<int>::const_iterator it(r.begin()); it != r.end(); ++it) {\n      if (*it == 15) {\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nstring s;\nvvi in;\nvi w;\nint n,m,out;\nint a,b;\nvi f(){\n\tint e=w[b];\n\ta++;\n\tvi ss(4),t(4);\n\tif(s[a]=='('){b++;ss=f();}\n\telse ss=in[s[a]-'1'];\n\ta++;\n\tif(s[a]=='('){b++;t=f();}\n\telse t=in[s[a]-'1'];\n\tvi re(4);\n\trep(i,4)if(e==0)re[i]=(ss[i]&&t[i]);\n\telse if(e==1)re[i]=(ss[i]||t[i]);\n\telse if(e==2)re[i]=(ss[i]^t[i]);\n\ta++;\n\treturn re;\n}\nint main(){\n\twhile(getline(cin,s),s!=\"END\"){\n\t\trep(i,s.size())if(s[i]==' '){\n\t\t\ts.erase(s.begin()+i);\n\t\t\ti--;\n\t\t}\n\t\tm=out=0;\n\t\trep(i,s.size())if(s[i]=='(')m++;\n\t\tcin>>n;\n\t\tin=vvi(n,vi(4));\n\t\tw=vi(m);\n\t\trep(i,n)rep(j,4)cin>>in[i][j];\n\t\t\n\t\tint q=pow(3,m);\n\t\trep(i,q){\n\t\t\tint t=i;\n\t\t\trep(j,m){\n\t\t\t\tw[j]=t%3;\n\t\t\t\tt/=3;\n\t\t\t}\n\t\t\ta=b=0;\n\t\t\tvi tmp=f();\n\t\t\tsort(all(tmp));\n\t\t\tif(tmp[0]==1)out++;\n\t\t}\n\t\tcout<<out<<endl;\n\t\tgetline(cin,s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stack>\nusing namespace std;\n\nvector<int> s;\n\nint solve(stack<int> stk, istringstream& iss)\n{\n\tif (iss.eof()) {\n\t\tif (stk.top() == 15)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint n, st = 0;\n\twhile (iss >> n) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tstk.push(n);\n\t\t++st;\n\t}\n\n\tint a, b;\n\tif (st == 0) {\n\t\ta = stk.top();\n\t\tstk.pop();\n\t\tb = stk.top();\n\t\tstk.pop();\n\t} else {\n\t\ta = s[stk.top()-1];\n\t\tstk.pop();\n\t\tif (st == 1)\n\t\t\tb = stk.top();\n\t\telse\n\t\t\tb = s[stk.top()-1];\n\t\tstk.pop();\n\t}\n\n\tint cnt = 0;\n\tstk.push(a|b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\tstk.push(a&b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\tstk.push(a^b);\n\tcnt += solve(stk, iss);\n\tstk.pop();\n\n\treturn cnt;\n}\n\nint main()\n{\n\tfor ( ; ; ) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif (tree == \"END\")\n\t\t\tbreak;\n\n\t\tfor (string::iterator it = tree.begin(); it != tree.end(); ) {\n\t\t\tif ((*it) == '(') {\n\t\t\t\tit = tree.erase(it);\n\t\t\t} else if ((*it) == ')') {\n\t\t\t\t*it = '0';\n\t\t\t\tit = tree.insert(it, ' ');\n\t\t\t\tit += 2;\n\t\t\t} else {\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t\tint n, rev = 0;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ts.push_back(a*8 + b*4 + c*2 + d);\n\t\t\tif (s.back() == 15)\n\t\t\t\t++rev;\n\t\t}\n\n\t\tistringstream iss(tree);\n\n\t\t// skip '\\n'\n\t\tgetline(cin, tree);\n\n\t\tcout << solve(stack<int>(), iss)+rev << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<vector>\n#include<map>\ntypedef std::map<int,int>M;\ntypedef M::iterator I;\ntypedef std::pair<int,int>P;\nstd::vector<P>v;\nint x[10];\nint F(char*&p,int n)\n{\n\tif(isdigit(*p))\n\t\treturn -*p+'0';\n\tv.push_back(P(0,0));\n\tint s=v.size();\n\tv[n].first=F(++p,s);\n\ts=v.size();\n\tv[n].second=F(p+=2,s);\n\t++p;\n\treturn n;\n}\nM G(int i)\n{\n\tM m;\n\tif(i<0)m[x[-i]]=1;\n\telse\n\t{\n\t\tM a(G(v[i].first)),b(G(v[i].second));\n\t\tfor(I p=a.begin();p!=a.end();++p)for(I q=b.begin();q!=b.end();++q)\n\t\t{\n\t\t\tint a=p->first,b=q->first,c=p->second*q->second;\n\t\t\tm[a&b]+=c;\n\t\t\tm[a|b]+=c;\n\t\t\tm[a^b]+=c;\n\t\t}\n\t}\n\treturn m;\n}\nint main()\n{\n\tint n,i,j,t;\n\tchar*p,s[512];\n\tv.reserve(64);\n\twhile(fgets(s,512,stdin),*s-'E')\n\t{\n\t\tv.clear();\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;++i)for(x[i]=j=0;j<4;++j)scanf(\"%d\",&t),x[i]=x[i]*2+t;\n\t\tt=F(p=s,0);\n\t\tprintf(\"%d\\n\",t?x[-t]==15:G(0)[15]);\n\t\tfgets(s,512,stdin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Node {\n\tbool leaf;\n\tchar op;\n\tunion {\n\t\tint mask;\n\t\tNode* children[2];\n\t};\n};\n\nvector<Node*> leaves(9);\nvector<Node*> mids;\n\nvoid skip(const string &str, int &pos, char c) {\n\tif(str[pos] != c) {\n\t\tcerr << \"Error at \" << pos << \": expected \" << c << \" but \" << str[pos] << endl;\n\t}\n\t++pos;\n}\n\nNode *node(const string &str, int &pos) {\n\tNode *n = new Node;\n\tif(isdigit(str[pos])) {\n\t\tn->leaf = true;\n\t\tn->mask = 0;\n\t\tleaves[str[pos]-'0'-1] = n;\n\t\t++pos;\n\t}\n\telse {\n\t\tn->leaf = false;\n\t\tskip(str, pos, '(');\n\t\tn->children[0] = node(str, pos);\n\t\tskip(str, pos, ' ');\n\t\tn->children[1] = node(str, pos);\n\t\tskip(str, pos, ')');\n\t\tmids.push_back(n);\n\t}\n\treturn n;\n}\n\nint calc(Node *n) {\n\tif(n->leaf) return n->mask;\n\n\tint l = calc(n->children[0]);\n\tint r = calc(n->children[1]);\n\tif(n->op == 'A') return l&r;\n\telse if(n->op == 'O') return l|r;\n\telse return l^r;\n}\n\nint main() {\n\twhile(true) {\n\t\tstring tree;\n\t\tgetline(cin, tree);\n\t\tif(tree == \"END\") break;\n\n\t\tmids.clear();\n\t\tint pos = 0;\n\t\tNode *root = node(tree, pos);\n\n\t\tint N;\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\t\tint flag;\n\t\t\t\tcin >> flag;\n\t\t\t\tif(flag) leaves[i]->mask |= (1<<j);\n\t\t\t}\n\t\t}\n\t\tint limit = 1;\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < mids.size(); ++i) limit *= 3;\n\t\tfor(int i = 0; i < limit; ++i) {\n\t\t\tint tmp = i;\n\t\t\tfor(int j = 0; j < mids.size(); ++j) {\n\t\t\t\tmids[j]->op = \"AOX\"[tmp%3];\n\t\t\t\ttmp /= 3;\n\t\t\t}\n\t\t\tif(calc(root) == 0x0f) ++cnt;\n\t\t}\n\t\tcout << cnt << endl;\n\t\tcin.ignore();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nint bit[8];\nstring::iterator it;\n\nmap<int, int> merge(map<int, int> &a, map<int, int> &b)\n{\n    map<int, int> res;\n    for (int i = 0; i < (1<<4); i++) {\n        for (int j = 0; j < (1<<4); j++) {\n            if (!a.count(i) || !b.count(j)) continue;\n            res[i&j] += a[i] * b[j];\n            res[i|j] += a[i] * b[j];\n            res[i^j] += a[i] * b[j];\n        }\n    }\n    return res;\n}\n\nmap<int, int> solve()\n{\n    if (*it == '(') {\n        ++it;\n        auto l = solve();        \n        ++it;\n        auto r = solve();        \n        ++it;        \n        return merge(l, r); \n    } else {\n        int x = *it - '1'; ++it;\n        return {{bit[x], 1}};\n    }\n}\n\nint main()\n{\n    while (getline(cin, s), s != \"END\") {\n        int N, x;\n        cin >> N;\n        for (int i = 0; i < N; i++) {\n            bit[i] = 0;\n            for (int j = 0; j < 4; j++) {\n                cin >> x;\n                bit[i] |= (1<<j) * x;\n            }\n        }\n        it = s.begin();\n        auto res = solve();\n        cout << res[(1<<4)-1] << endl;\n        cin.ignore();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nstruct node{int bit,mark;};\nnode tree[1024];\nvoid out(void);\n//((1 2) 3)\n//(1 (2 3))\n//(1 ((2 3) 4))\nint ans;\nint check(int ima){\n  if(tree[ima*2+1].mark==-1 || tree[ima*2+2].mark==-1)return tree[ima].bit;\n  int mark=tree[ima].mark;\n  int l = check(ima*2+1);\n  int r = check(ima*2+2);\n  if(mark==0) return l|r;\n  if(mark==1) return l&r;\n  if(mark==2) return l^r;\n}\n\n\nvoid mark_dfs(int ima){ \n  while((tree[ima].mark==-1||tree[ima*2+1].mark==-1||tree[ima*2+2].mark==-1)&&ima<=1000)ima++;\n  if(ima>1000 && check(0)==(1<<4)-1)ans++;\n  else if(ima<=1000)\n    for(int i=0;i<=2;i++)tree[ima].mark=i, mark_dfs(ima+1);  \n}\n\nint input(){\n  char ch;\n  for(int i=0;i<1024;i++)tree[i].bit=-1,tree[i].mark=-1;\n  int ima=0,num=0,p[1024]={},flg=1;\n  while(1){\n    scanf(\"%c\",&ch);\n    tree[ima].mark=0;\n    if(ch=='E') flg=0;\n    if(ch=='\\n')break;\n    if(ch=='(') ima=ima*2+1;\n    else if('0'<=ch&&ch<='9') num=num*10+ch-'0';\n    else if(ch==' ') p[num]=ima,num=0,ima++; \n    else if(ch==')') p[num]=ima,num=0,ima=(ima-1)/2;\n  }\n  if(flg==0)return flg;\n\n  int m;\n  cin>>m;\n  for(int i=1;i<=m;i++){\n    int bit=0,a;\n    for(int j=0;j<4;j++)cin >> a, bit+=a<<(3-j);\n    tree[p[i]].bit=bit;\n  }\n  scanf(\"%c\",&ch);\n  return flg;\n}\n\nint main() {\n  while(input()){\n    ans=0;\n    mark_dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid out(){\n  int a=0,b=2;\n  for(int i=0;i<7;i++){\n    cout << tree[i].mark<<\" \";\n    if(a==i) cout << endl,a+=b,b*=2;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid readTree(string& s, int& i, vector<char>& rpn)\n{\n    if(s[i] != '('){\n        rpn.push_back(s[i]);\n        ++ i;\n    }else{\n        for(int j=0; j<2; ++j){\n            ++ i;\n            if(s[i] == '(')\n                readTree(s, i, rpn);\n            else\n                rpn.push_back(s[i]);\n            ++ i;\n        }\n        rpn.push_back('.');\n    }\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        getline(cin, s);\n        if(s == \"\")\n            getline(cin, s);\n        if(s == \"END\")\n            return 0;\n\n        vector<char> rpn;\n        int tmp = 0;\n        readTree(s, tmp, rpn);\n\n        int n;\n        cin >> n;\n        vector<int> sweet(n, 0);\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                sweet[i] <<= 1;\n                char c;\n                cin >> c;\n                if(c == '1')\n                    sweet[i] |= 1;\n            }\n        }\n\n        int num = count(rpn.begin(), rpn.end(), '.');\n        int a = 1;\n        for(int i=0; i<num; ++i)\n            a *= 3;\n\n        int ret = 0;\n        for(int i=0; i<a; ++i){\n            int b = i;\n            stack<int> stk;\n            for(unsigned j=0; j<rpn.size(); ++j){\n                if(rpn[j] == '.'){\n                    int x = stk.top();\n                    stk.pop();\n                    int y = stk.top();\n                    stk.pop();\n                    if(b % 3 == 0){\n                        stk.push(x & y);\n                    }else if(b % 3 == 1){\n                        stk.push(x | y);\n                    }else{\n                        stk.push(x ^ y);\n                    }\n                    b /= 3;\n                }else{\n                    stk.push(sweet[rpn[j]-'1']);\n                }\n            }\n            if(stk.top() == 15)\n                ++ ret;\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<vector>\n#include<map>\ntypedef std::map<int,int>M;\ntypedef M::iterator I;\ntypedef std::pair<int,int>P;\nstd::vector<P>v;\nint x[10];\nint F(char*&p,int n)\n{\n\tif(isdigit(*p))\n\t\treturn -*p+'0';\n\tv.push_back(P(0,0));\n\tint s=v.size();\n\tv[n].first=F(++p,s);\n\ts=v.size();\n\tv[n].second=F(p+=2,s);\n\t++p;\n\treturn n;\n}\nM G(int i)\n{\n\tM m;\n\tif(i<0)m[x[-i]]=1;\n\telse\n\t{\n\t\tM a(G(v[i].first)),b(G(v[i].second));\n\t\tfor(I p=a.begin();p!=a.end();++p)for(I q=b.begin();q!=b.end();++q)\n\t\t{\n\t\t\tint a=p->first,b=q->first,c=p->second*q->second;\n\t\t\tm[a&b]+=c;\n\t\t\tm[a|b]+=c;\n\t\t\tm[a^b]+=c;\n\t\t}\n\t}\n\treturn m;\n}\nint main()\n{\n\tint n,i,j,t;\n\tchar*p,s[512];\n\twhile(fgets(s,512,stdin),*s-'E')\n\t{\n\t\tv.clear();\n\t\tF(p=s,0);\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=1;i<=n;++i)for(x[i]=j=0;j<4;++j)scanf(\"%d\",&t),x[i]=x[i]*2+t;\n\t\tprintf(\"%d\\n\",G(0)[15]);\n\t\tfgets(s,512,stdin);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<bitset>\n#include<cstdio>\n#include<cassert>\n#include<set>\n#include<sstream>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 20\n\nusing namespace std;\n\nstring parse;\nchar  cparse[MAX];\nint N,sweets[MAX],n;\n\nset<vector<char> > ans;\nchar opr[] = {'&','|','^'};\n\nint exp(int&,int&,vector<char>&);\n\nint fact(int &cur,int &ocnt,vector<char> &vec)\n{\n  int p;\n  if(parse[cur] == '(')\n    {\n      cur++;\n      p = exp(cur,ocnt,vec);\n      cur++;\n      return p;\n    }\n  else\n    {\n      p = parse[cur]-'0';\n      cur++;\n      return sweets[p-1];\n    }\n}\n\nint exp(int &cur,int &ocnt,vector<char> &vec)\n{\n  int p;\n  p = fact(cur,ocnt,vec);\n  if(ocnt < vec.size())\n    {\n      int q = fact(cur,ocnt,vec);\n      int ret;\n      if(vec[ocnt] == '&')ret = p & q;\n      if(vec[ocnt] == '|')ret = p | q;\n      if(vec[ocnt] == '^')ret = p ^ q;\n      ocnt++;\n      return ret;\n    }\n  return p;\n}\n\n\nbool check(vector<char> &vec)\n{\n  int cur = 0;\n  int ocnt = 0;\n  int res = exp(cur,ocnt,vec);\n  return res == (1<<4)-1;\n}\n\nvoid dfs(int cur,vector<char> &vec)\n{\n  if(cur >= vec.size())\n    {\n      if(check(vec))ans.insert(vec);\n      return;\n    }\n\n  rep(i,3)\n    {\n      vec[cur] = opr[i];\n      dfs(cur+1,vec);\n    }\n\n}\n\nvoid change()\n{\n  stringstream ss;\n  ss << parse;\n  string content = \"\";\n  while(!(ss>>parse).fail())content += parse;\n  parse = content;\n}\n\nint main()\n{\n  while(getline(cin,parse),parse != \"END\")\n    {\n      n = 0;\n      rep(i,parse.size())if(parse[i] == '(')n++;\n      change();\n      ans.clear();\n\n\n      cin >> N;\n      rep(i,N)\n\t{\n\t  sweets[i] = 0;\n\t  rep(j,4)\n\t    {\n\t      int bit;\n\t      cin >> bit;\n\t      if(bit)\n\t\t{\n\t\t  sweets[i] |= (1<<j);\n\t\t}\n\t    }\n\t}\n\n      vector<char> vec(n);\n      dfs(0,vec);\n\n      cout << ans.size() << endl;\n      cin.ignore();\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1037 Midnight Teatime\n// 2018.2.3 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint info[10];\nchar tree[100], *p;\nint buf[10][16], sz;\n\nint *calc()\n{\n\tint i, j, k;\n\tint *left, *right, *ans;\n\n\tans = buf[sz++];\n\tif (*p == '(') {\n\t\tp++, left = calc(), p++, right = calc(), p++;\n\t\tfor (i = 0; i < 16; i++) for (j = 0; j < 16; j++) {\n\t\t\tif (k = left[i] * right[j]) {\n\t\t\t\tans[i & j] += k;\n\t\t\t\tans[i | j] += k;\n\t\t\t\tans[i ^ j] += k;\n\t\t\t}\n\t\t}\n\t} else ans[info[*p++ -'1']] = 1;\n\treturn ans;\n}\n\nint main()\n{\n\tint n, i, j;\n\tint *ans;\n\tchar s[20];\n\n\twhile(fgets(tree,100, stdin) && *tree != 'E') {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tmemset(info, 0, sizeof(info));\n\n\t\tfgets(s, 5, stdin), n = *s & 0xf;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=s, 20, stdin);\n\t\t\tfor (j = 0; j < 4; j++, p+=2) if (*p & 1) info[i] |= (1<<j);\n\t\t}\n\n\t\tp = tree, sz = 0, ans = calc();\n\t\tprintf(\"%d\\n\", ans[15]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#if 0\n#define PRINT_TREE\n#endif\n\nint A(int sl, int sr) { return sl & sr; }\nint O(int sl, int sr) { return sl | sr; }\nint X(int sl, int sr) { return sl ^ sr; }\n\nint (*keisan[3])(int, int) = {A, O, X};\n\nchar tree_data[100000];\nint N;\nint bubunnsyuugou[10];\n\nint tree_pos;\nint tree_ungetchar_pos = 0;\nint tree_ungetchar_data[100000];\nint tree_getchar(void) {\n\treturn tree_ungetchar_pos > 0 ? tree_ungetchar_data[--tree_ungetchar_pos] : tree_data[tree_pos++];\n}\n\nvoid tree_ungetchar(int c) {\n\ttree_ungetchar_data[tree_ungetchar_pos++] = c;\n}\n\ntypedef struct node_t_tag {\n\tint num;\n\tstruct node_t_tag *left, *right;\n} node_t;\n\nint in_node_num;\nnode_t* in_node[16];\n\nnode_t* parse_tree(void) {\n\tint input;\n\tnode_t* node = malloc(sizeof(node_t));\n\tif (node == NULL) exit(1);\n\tinput = tree_getchar();\n\tif (input == '(') {\n\t\tnode->num = -1;\n\t\tnode->left = parse_tree();\n\t\tinput = tree_getchar(); assert(input == ' ');\n\t\tnode->right = parse_tree();\n\t\tinput = tree_getchar(); assert(input == ')');\n\t\tin_node[in_node_num++] = node;\n\t} else {\n\t\tnode->num = input - '1';\n\t\tnode->left = node->right = NULL;\n\t}\n\treturn node;\n}\n\n#ifdef PRINT_TREE\n/* for testing */\nvoid print_tree(const node_t* node) {\n\tif (node == NULL) {\n\t\tputchar('X');\n\t} else if (node->left == NULL && node->right == NULL) {\n\t\tprintf(\"%d\", node->num + 1);\n\t} else {\n\t\tputchar('(');\n\t\tprint_tree(node->left);\n\t\tputchar(' ');\n\t\tprint_tree(node->right);\n\t\tputchar(')');\n\t}\n}\n#endif\n\nint evaluate_tree(const node_t* node) {\n\tif (node == NULL) {\n\t\treturn 0;\n\t} else if (node->left == NULL || node->right == NULL) {\n\t\treturn bubunnsyuugou[node->num];\n\t} else {\n\t\treturn keisan[node->num](evaluate_tree(node->left), evaluate_tree(node->right));\n\t}\n}\n\nvoid free_tree(node_t* node) {\n\tif (node != NULL) {\n\t\tfree_tree(node->left);\n\t\tfree_tree(node->right);\n\t\tfree(node);\n\t}\n}\n\nint main(void) {\n\twhile (fgets(tree_data, sizeof(tree_data), stdin) != NULL && tree_data[0] != 'E') {\n\t\tchar data_buffer[1024];\n\t\tint i;\n\t\tnode_t* root;\n#ifndef PRINT_TREE\n\t\tint search, search_max;\n\t\tint answer;\n#endif\n\t\tif (fgets(data_buffer, sizeof(data_buffer), stdin) == NULL ||\n\t\t\tsscanf(data_buffer, \"%d\", &N) != 1) return 1;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tif (fgets(data_buffer, sizeof(data_buffer), stdin) == NULL ||\n\t\t\tsscanf(data_buffer, \"%d%d%d%d\", &a, &b, &c, &d) != 4) return 1;\n\t\t\tbubunnsyuugou[i] = (a << 3) | (b << 2) | (c << 1) | d;\n\t\t}\n\t\ttree_pos = 0;\n\t\tin_node_num = 0;\n\t\troot = parse_tree();\n#ifdef PRINT_TREE\n\t\tprint_tree(root);\n\t\tputchar('\\n');\n#else\n\t\tsearch_max = 1;\n\t\tfor (i = 0; i < in_node_num; i++) search_max *= 3;\n\t\tanswer = 0;\n\t\tfor (search = 0; search < search_max; search++) {\n\t\t\tint cur = search;\n\t\t\tfor (i = 0; i < in_node_num; i++) {\n\t\t\t\tin_node[i]->num = cur % 3;\n\t\t\t\tcur /= 3;\n\t\t\t}\n\t\t\tif (evaluate_tree(root) == (1 << 4) - 1) answer++;\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n#endif\n\t\tfree_tree(root);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,tree[99];\nleaf[11];\neval(int*ans){\n\tmemset(ans,0,sizeof(int)*16);\n\tif(*p=='('){\n\t\tint l[16],r[16],i,j;\n\t\tp++;\n\t\teval(l);\n\t\tp++;\n\t\teval(r);\n\t\tp++;\n\t\tfor(i=0;i<16;i++){\n\t\t\tfor(j=0;j<16;j++){\n\t\t\t\tans[i&j]+=l[i]*r[j];\n\t\t\t\tans[i|j]+=l[i]*r[j];\n\t\t\t\tans[i^j]+=l[i]*r[j];\n\t\t\t}\n\t\t}\n\t}else{\n\t\tans[leaf[*p-'0']]=1;\n\t\tp++;\n\t}\n}\nmain(){\n\tint N,i,ans[16];\n\tfor(;scanf(\"%[^\\n]\",tree),*tree!='E';){\n\t\tscanf(\"%d\",&N);\n\t\tfor(i=1;i<=N;i++){\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d%d%d%d\\n\",&a,&b,&c,&d);\n\t\t\tleaf[i]=a+b*2+c*4+d*8;\n\t\t}\n\t\tp=tree;\n\t\teval(ans);\n\t\tprintf(\"%d\\n\",ans[15]);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1037\n  Title:Midnight Tea Time\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint a1,a2,a3,a4;\nchar node[11];\nchar s_exp[100];\nint dist[16],n;\n\nvoid evaluate(char s_exp[],int dist[])\n{\n  int ret,dist1[16],dist2[16],lv,len;\n  int i,j;\n  char *p,*q,*r; \n\n  //printf(\"s-exp=[%s]\\n\",s_exp);\n  memset(dist,0,sizeof(dist));\n  memset(dist1,0,sizeof(dist1));\n  memset(dist2,0,sizeof(dist2));\n\n  if((ret=atoi(s_exp))>0)\n    {\n      dist[node[ret]]=1;\n      return;\n    }\n\n  lv=0;\n  len=strlen(s_exp);\n  for(p=s_exp;*p;p++)\n    {\n      if(*p=='(')\n\tlv++;\n      if(*p==')')\n\tlv--;\n      if(lv==1 && *p==' ')\n\t{\n\t  q=p;\n\t  break;\n\t}\n    }\n  *q=0;\n  evaluate(s_exp+1,dist1);\n  s_exp[len-1]='\\0';\n  evaluate(p+1,dist2);\n  \n  for(i=0;i<16;i++)\n    for(j=0;j<16;j++)\n      {\n\tdist[i & j] += dist1[i]*dist2[j];\n\tdist[i | j] += dist1[i]*dist2[j];\n\tdist[i ^ j] += dist1[i]*dist2[j];\n      }\n}\n\nmain()\n{\n  int i,ret,dn;\n  \n  fgets(s_exp,100,stdin);\n    {\n      \n      scanf(\"%d\",&n);\n      for(i=1;i<=n;i++)\n\t{\n\t  scanf(\"%d %d %d %d\",&a1,&a2,&a3,&a4);\n\t  node[i]=8*a1+4*a2+2*a3+a4;\n\t}\n      \n      s_exp[strlen(s_exp)-1]=0;\n      evaluate(s_exp,dist);\n      printf(\"%d\\n\",dist[15]);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nint a1,a2,a3,a4,d[16],n;;\nchar node[20],s[100];\nevaluate(char s[],int d[])\n{ int ret,d1[16],d2[16],lv,len;\n  int i,j;\n  char *p,*q; \n  memset(d,0,sizeof(d1));\n  memset(d1,0,sizeof(d1));\n  memset(d2,0,sizeof(d2));\n  if((ret=atoi(s))>0) \n    { d[node[ret]]=1;\n      return;\n    }\n  lv=0;len=strlen(s);\n  for(p=s;*p;p++)\n     if(*p=='(')\n\tlv++;\n      else if(*p==')')\n\tlv--;\n      else if(lv==1 && *p==' ')\n\t{ q=p;\n\t  break;\n\t}\n  *q='\\0';\n  evaluate(s+1,d1); \n  s[len-1]='\\0';\n  evaluate(p+1,d2);     \n  for(i=0;i<16;i++)\n    for(j=0;j<16;j++)\n      d[i&j]+=d1[i]*d2[j],d[i|j]+=d1[i]*d2[j],d[i^j]+=d1[i]*d2[j];\n}\nmain()\n{\n  int i,ret;\n  while(fgets(s,100,stdin) && *s != 'E')\n    { scanf(\"%d\",&n);\n      for(i=1;i<=n;i++)\n\t{ scanf(\"%d %d %d %d \",&a1,&a2,&a3,&a4);\n\t  node[i]=8*a1+4*a2+2*a3+a4;\n\t}\n      evaluate(s,d);\n      printf(\"%d\\n\",d[15]);\n      memset(s,0,sizeof(s));\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1037 Midnight Teatime\n// 2018.2.3 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint info[10];\nchar tree[100], *p;\nint buf[20][16], sz;\n\nint *calc()\n{\n\tint i, j, k;\n\tint *left, *right, *ans;\n\n\tans = buf[sz++];\n\tif (*p == '(') {\n\t\tp++, left = calc(), p++, right = calc(), p++;\n\t\tfor (i = 0; i < 16; i++) for (j = 0; j < 16; j++) {\n\t\t\tif (k = left[i] * right[j]) {\n\t\t\t\tans[i & j] += k;\n\t\t\t\tans[i | j] += k;\n\t\t\t\tans[i ^ j] += k;\n\t\t\t}\n\t\t}\n\t} else ans[info[*p++ -'1']] = 1;\n\treturn ans;\n}\n\nint main()\n{\n\tint n, i, j;\n\tint *ans;\n\tchar s[20];\n\n\twhile(fgets(tree,100, stdin) && *tree != 'E') {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tmemset(info, 0, sizeof(info));\n\n\t\tfgets(s, 5, stdin), n = *s & 0xf;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=s, 20, stdin);\n\t\t\tfor (j = 0; j < 4; j++, p+=2) if (*p & 1) info[i] |= (1<<j);\n\t\t}\n\n\t\tp = tree, sz = 0, ans = calc();\n\t\tprintf(\"%d\\n\", ans[15]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "char*p;L[11],i,j,a,b,c;E(int*A){int l[16]={0},r[16]={0};if(*p-40)A[L[*p++-48]]=1;else for(p++,E(l),E(r),i=16;i--;)for(j=16;j--;A[i^j]+=a)A[i&j]+=a=l[i]*r[j],A[i|j]+=a;p++;}main(d,T){for(;scanf(\"%[^\\n]\",p=T),c=*p-69;){int A[16]={0};for(i=scanf(\"%d\",&j);i<=j;L[i++]=a+b*2+c*4+d*8)scanf(\"%d%d%d%d\\n\",&a,&b,&c,&d);E(A);printf(\"%d\\n\",A[15]);}}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1037\n  Title:Midnight Tea Time\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint a1,a2,a3,a4;\nchar node[20];\nchar s_exp[100];\nint dist[16],n;\n\ndump(int dist[])\n{\n  int i;\n  for(i=0;i<16;i++)\n    printf(\"%d|\",dist[i]);\n  printf(\"\\n\");\n}\n\nvoid evaluate(char s_exp[],int dist[])\n{\n  int ret,dist1[16],dist2[16],lv,len;\n  int i,j;\n  char *p,*q; \n\n#ifdef DEBUG\n  printf(\"s-exp=[%s]\\n\",s_exp);\n#endif\n  memset(dist,0,sizeof(dist1));\n  memset(dist1,0,sizeof(dist1));\n  memset(dist2,0,sizeof(dist2));\n\n  if((ret=atoi(s_exp))>0) // atom?\n    {\n      dist[node[ret]]=1;\n      return;\n    }\n\n  lv=0;\n  len=strlen(s_exp);\n  for(p=s_exp;*p;p++)\n    {\n      if(*p=='(')\n\tlv++;\n      if(*p==')')\n\tlv--;\n      if(lv==1 && *p==' ')\n\t{\n\t  q=p;\n\t  break;\n\t}\n    }\n  *q=0;\n  evaluate(s_exp+1,dist1); //car\n  s_exp[len-1]='\\0';\n  evaluate(p+1,dist2);     //cadr\n\n#ifdef DEBUG  \n  dump(dist1);\n  dump(dist2);\n#endif\n\n  for(i=0;i<16;i++)\n    for(j=0;j<16;j++)\n      {\n\tdist[i & j] += dist1[i]*dist2[j];\n\tdist[i | j] += dist1[i]*dist2[j];\n\tdist[i ^ j] += dist1[i]*dist2[j];\n      }\n}\nrtrim(char s[])\n{\n  int i=strlen(s)-1;\n  while(!isgraph(s[i]))\n    s[i--]='\\0';\n\n}\nmain()\n{\n  int i,ret,dn;\n  \n  while(fgets(s_exp,100,stdin) && *s_exp != 'E')\n    {\n#ifdef DEBUG\n      rtrim(s_exp);\n      printf(\":s-exp=%s\\n\",s_exp);\n#endif\n      scanf(\"%d\",&n);\n      for(i=1;i<=n;i++)\n\t{\n\t  scanf(\"%d %d %d %d \",&a1,&a2,&a3,&a4);\n\t  node[i]=8*a1+4*a2+2*a3+a4;\n\t}\n      \n      evaluate(s_exp,dist);\n#ifdef DEBUG  \n  dump(dist);\n#endif\n      printf(\"%d\\n\",dist[15]);\n      memset(s_exp,0,sizeof(s_exp));\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tint [] data;\n\t\n\tprivate TreeMap<Integer, Integer> fact() {\n\t\tchar c = str.charAt(pos++);\n\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\tif(Character.isDigit(c)){\n\t\t\t//res.add(c - '0');\n\t\t\tint ind = (c - '0') - 1;\n\t\t\tint num = data[ind];\n\t\t\t//System.out.println(ind);\n\t\t\tif(res.containsKey(num)){\n\t\t\t\tint count = res.get(num) + 1;\n\t\t\t\tres.put(num, count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres.put(num, 1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\telse if(c == '('){\n\t\t\t//System.out.println(\"pos= \" + pos);\n\t\t\tTreeMap<Integer, Integer> right = fact();\n\t\t\tpos++;\n\t\t\tTreeMap<Integer, Integer> left = fact();\n\t\t\tpos++;\n\t\t\tSystem.out.println(\"test1 = \" +right.toString() + \" \" + left.toString());\n\t\t\t//calc\n\t\t\tfor(int r: right.keySet()){\n\t\t\t\tfor(int l: left.keySet()){\n\t\t\t\t\tfor(int i=0; i < 3; i++){\n\t\t\t\t\t\tint res2 = -1;\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tres2 = r & l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tres2 = r | l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tres2 = r ^ l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(res2 != -1){\n\t\t\t\t\t\t\tif(res.containsKey(res2)){\n\t\t\t\t\t\t\t\tint count = res.get(res2) + 1;\n\t\t\t\t\t\t\t\tres.put(res2, count);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tres.put(res2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tstr = sc.nextLine();\n\t\t\tif(str.equals(\"END\")) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tdata = new int[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint temp = sc.nextInt();\n\t\t\t\t\tnum = num * 2 + temp;\n\t\t\t\t}\n\t\t\t\tdata[i] = num;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\t\tres = fact();\n\t\t\tint lastind = res.lastKey();\n\t\t\tSystem.out.println(res.toString());\n\t\t\tSystem.out.println(res.get(lastind));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\tint cnt;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\tcnt++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() throws Exception {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tcnt = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tT = tree();\n\t\t\tps = new int[cnt - 1];\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) throws Exception {\n\t\tint res = 0;\n\t\tif (k == cnt - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) throws Exception {\n\t\tif (tr.v > 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tif (n == 1) {\n\t\t\tthrow new Exception(\"tr.v: \" + tr.v + \" \" + t);\n\t\t}\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Midnight Teatime\npublic class Main{\n\n\tclass R{\n\t\tint id, x;\n\t\tchar ch;\n\t\tR l, r;\n\t\tboolean leaf;\n\t\tpublic R(int id, boolean leaf) {\n\t\t\tthis.id = id;\n\t\t\tthis.leaf = leaf;\n\t\t\tl = r = null;\n\t\t\tx = 0;\n\t\t}\n\t\tint get(){\n\t\t\tif(leaf)return x;\n\t\t\tif(ch=='A')return l.get()&r.get();\n\t\t\telse if(ch=='O')return l.get()|r.get();\n\t\t\telse return l.get()^r.get();\n\t\t}\n\t\tvoid f(){\n\t\t\tif(leaf){\n\t\t\t\tSystem.out.print(x); return;\n\t\t\t}\n\t\t\tSystem.out.print(\"(\");\n\t\t\tl.f();\n\t\t\tSystem.out.print(\" \"+ch+\" \");\n\t\t\tr.f();\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n\t\n\tint ID, c;\n\tR[] v;\n\tR root;\n\tList<R> leafs;\n\t\n\tchar[] s;\n\tint id;\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\t\n\tR exp(){\n\t\tchar ch = get();\n\t\tif(ch!='('){\n\t\t\tint x = ch-'0';\n\t\t\tR res = new R(x, true);\n\t\t\tleafs.add(res);\n\t\t\treturn res;\n\t\t}\n\t\tR res = new R(ID, false);\n\t\tv[ID++] = res;\n\t\tres.l = exp();\n\t\tget();\n\t\tres.r = exp();\n\t\tget();\n\t\treturn res;\n\t}\n\t\n\tvoid dfs(int k){\n\t\tif(k==ID){\n\t\t\tint x = root.get();\n\t\t\tif(x==15)c++;\n//\t\t\troot.f();System.out.println(\" F:\"+(x==15));\n\t\t\treturn;\n\t\t}\n\t\tv[k].ch = 'A'; dfs(k+1);\n\t\tv[k].ch = 'O'; dfs(k+1);\n\t\tv[k].ch = 'X'; dfs(k+1);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='E')break;\n\t\t\tid = 0;\n\t\t\tv = new R[8];\n\t\t\tleafs = new ArrayList<R>();\n\t\t\tID = 0;\n\t\t\troot = exp();\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tint x = 0;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tx += sc.nextInt()<<j;\n\t\t\t\t}\n\t\t\t\tfor(R r:leafs)if(r.id==i)r.x = x;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tc = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\tfinal static byte OPER_DUMMY = -10;\n\tfinal static byte OPER_AND = -1;\n\tfinal static byte OPER_OR_ = -2;\n\tfinal static byte OPER_XOR = -3;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\n\t\t\tfor (char c : line.trim().toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push(OPER_DUMMY);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == OPER_DUMMY) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, OPER_AND);\n\t\t\t\tsolve(0, idx, exp, OPER_OR_);\n\t\t\t\tsolve(0, idx, exp, OPER_XOR);\n\t\t\t\tSystem.out.println(count);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(exp.toString());\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2, op;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) < 0) {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\top = exp.get(i);\n\t\t\t\tswitch ((int) op) {\n\t\t\t\tcase OPER_AND:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase OPER_OR_:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase OPER_XOR:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p < idx.size()) {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tif (p == idx.size() - 1) {\n\t\t\t\tif (answer(exp) == 15) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p + 1, idx, exp, OPER_AND);\n\t\t\tsolve(p + 1, idx, exp, OPER_OR_);\n\t\t\tsolve(p + 1, idx, exp, OPER_XOR);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) throws Exception {\n\t\tif (tr.v > 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tif (n == 1) {\n\t\t\tthrow new Exception(\"tr.v: \" + tr.v);\n\t\t}\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\tint cnt;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\tcnt++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() throws Exception {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tcnt = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tT = tree();\n\t\t\tps = new int[cnt - 1];\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) throws Exception {\n\t\tint res = 0;\n\t\tif (k == cnt - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) throws Exception {\n\t\tif (tr.v > 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Midnight Teatime\npublic class Main{\n\n\tclass R{\n\t\tint id, x;\n\t\tchar ch;\n\t\tR l, r;\n\t\tboolean leaf;\n\t\tpublic R(int id, boolean leaf) {\n\t\t\tthis.id = id;\n\t\t\tthis.leaf = leaf;\n\t\t\tl = r = null;\n\t\t\tx = 0;\n\t\t}\n\t\tint get(){\n\t\t\tif(leaf)return x;\n\t\t\tif(ch=='A')return l.get()&r.get();\n\t\t\telse if(ch=='O')return l.get()|r.get();\n\t\t\telse return l.get()^r.get();\n\t\t}\n\t}\n\t\n\tint ID, c;\n\tR[] v;\n\tR root;\n\tMap<Integer, R> leafs;\n\t\n\tchar[] s;\n\tint id;\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\t\n\tR exp(){\n\t\tchar ch = get();\n\t\tif(ch!='('){\n\t\t\tint x = ch-'0';\n\t\t\tR res = new R(x, true);\n\t\t\tleafs.put(x, res);\n\t\t\treturn res;\n\t\t}\n\t\tR res = new R(ID, false);\n\t\tv[ID++] = res;\n\t\tres.l = exp();\n\t\tget();\n\t\tres.r = exp();\n\t\tget();\n\t\treturn res;\n\t}\n\t\n\tvoid dfs(int k){\n\t\tif(k==ID){\n\t\t\tint x = root.get();\n\t\t\tif(x==15)c++;\n\t\t\treturn;\n\t\t}\n\t\tv[k].ch = 'A'; dfs(k+1);\n\t\tv[k].ch = 'O'; dfs(k+1);\n\t\tv[k].ch = 'X'; dfs(k+1);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='E')break;\n\t\t\tid = 0;\n\t\t\tv = new R[8];\n\t\t\tleafs = new HashMap<Integer, R>();\n\t\t\tID = 0;\n\t\t\troot = exp();\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tR r = leafs.get(i);\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tr.x*=2; r.x+=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tc = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() throws Exception {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) throws Exception {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) throws Exception {\n\t\tif (tr.v > 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tif (n == 1) {\n\t\t\tthrow new Exception(\"tr.v: \" + tr.v + \" \" + t);\n\t\t}\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) {\n\t\tif (tr.v >= 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\tfinal static byte dummy = -10;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\t\t\tString linex = line;\n\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push(dummy);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == dummy) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(exp.toString());\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2, op;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) > 0) {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t} else {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\top = exp.get(i);\n\t\t\t\tswitch ((int) op) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p < idx.size()) {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tif (p == idx.size() - 1) {\n\t\t\t\tif (answer(exp) == 15) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Node{\n\t\tNode right, left;\n\t\tint number;\n\t\tint bit;\n\t\t\n\t\tpublic Node(Node right, Node left) {\n\t\t\tsuper();\n\t\t\tthis.right = right;\n\t\t\tthis.left = left;\n\t\t}\n\t\t\n\t\tpublic Node(int number) {\n\t\t\tsuper();\n\t\t\tthis.number = number;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\tif(right == null && left == null){\n\t\t\t\treturn number + \"(\" + bit + \")\";\n\t\t\t}else{\n\t\t\t\treturn \"(\" + right.toString() + \" \" + left.toString() + \") (\" + bit + \")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node make_tree(char[] input, int start, int end, Node[] array, ArrayList<Node> nodes){\t\t\n\t\tint c_start = start, c_end = end, c_level = 0;\n\t\tint sep = -1;\n\t\t\n\t\tfor(int i = start; i <= end; i++){\n\t\t\tif(input[i] == '('){\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_start = i;\n\t\t\t\t}\n\t\t\t\tc_level++;\n\t\t\t}else if(input[i] == ')'){\n\t\t\t\tc_level--;\n\t\t\t\t\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_end = i;\n\t\t\t\t}\n\t\t\t}else if(c_level == 1 && input[i] == ' '){\n\t\t\t\tsep = i;\n\t\t\t}else if(c_level == 0 && input[i] >= '0' && input[i] <= '9'){\n\t\t\t\tNode node = new Node(input[i] - '0');\n\t\t\t\tarray[input[i] - '0' - 1] = node;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t\n\t\tNode node = new Node(make_tree(input, c_start + 1, sep - 1, array, nodes), make_tree(input, sep + 1, c_end - 1, array, nodes));\n\t\tnodes.add(node);\n\t\treturn node;\n\t}\n\t\n\tpublic static int count(Node top, ArrayList<Node> nodes, int depth){\n\t\tint ret = 0;\n\t\t\n\t\tif(depth >= nodes.size()){\n\t\t\tif((ok(top) & 15) == 15){\n\t\t\t\t//System.out.println(nodes);\n\t\t\t\t\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tnodes.get(depth).bit = i;\n\t\t\t\tret += count(top, nodes, depth + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int ok(Node top){\n\t\tif(top.left == null && top.right == null){\n\t\t\treturn top.bit;\n\t\t}\n\t\t\n\t\tint bit = ok(top.left);\n\t\t\n\t\tif(top.bit == 0){\n\t\t\tbit &= ok(top.right);\n\t\t}else if(top.bit == 1){\n\t\t\tbit |= ok(top.right);\n\t\t}else if(top.bit == 2){\n\t\t\tbit ^= ok(top.right);\n\t\t\tbit &= 15;\n\t\t}\n\t\t\n\t\t//System.out.println(bit);\n\t\t\n\t\treturn bit;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString in = sc.nextLine();\n\t\t\t\n\t\t\tif(\"END\".equals(in)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(sc.nextLine());\n\t\t\t\n\t\t\tNode[] leafs = new Node[n];\n\t\t\tArrayList<Node> nodes = new ArrayList<Node>();\n\t\t\t\n\t\t\tNode top = make_tree(in.toCharArray(), 0, in.length() - 1, leafs, nodes);\n\t\t\t//System.out.println(top);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString[] str = sc.nextLine().split(\" \");\n\t\t\t\tint bit = (Integer.parseInt(str[0]) << 3) + (Integer.parseInt(str[1]) << 2) + (Integer.parseInt(str[2]) << 1) + Integer.parseInt(str[3]);\n\t\t\t\tleafs[i].bit = bit;\n\t\t\t\t//System.out.println(Arrays.toString(str));\n\t\t\t\t//System.out.println(bit);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count(top, nodes, 0));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push((byte) 0);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == 0) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\tSystem.out.println(count / 3);\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2;\n\t\ttry {\n\t\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i) > 0) {\n\t\t\t\t\tans.push(exp.get(i));\n\t\t\t\t} else {\n\t\t\t\t\tb2 = ans.pop();\n\t\t\t\t\tb1 = ans.pop();\n\t\t\t\t\tswitch ((int) exp.get(i)) {\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -2:\n\t\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -3:\n\t\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (EmptyStackException e) {\n\t\t\tSystem.err.println(exp.toString());\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p == idx.size()) {\n\t\t\tif (answer(exp) == 15)\n\t\t\t\tcount++;\n\t\t\treturn;\n\t\t} else {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\tfinal static byte dummy = -10;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\t\t\tString linex = line;\n\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push(dummy);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == dummy) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(linex);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2, op;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) > 0) {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t} else {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\top = exp.get(i);\n\t\t\t\tswitch ((int) op) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p < idx.size()) {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tif (p == idx.size() - 1) {\n\t\t\t\tif (answer(exp) == 15) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = 0;\n\t\t\tif (n == 1) {\n\t\t\t\tset = ls[T.v-1];\n\t\t\t} else {\n\t\t\t\tset = check(T);\n\t\t\t}\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) {\n\t\tif (tr.v >= 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tint [] data;\n\t\n\tprivate TreeMap<Integer, Integer> fact() {\n\t\tchar c = str.charAt(pos++);\n\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\tif(Character.isDigit(c)){\n\t\t\t//res.add(c - '0');\n\t\t\tint ind = (c - '0') - 1;\n\t\t\tint num = data[ind];\n\t\t\t//System.out.println(ind);\n\t\t\tif(res.containsKey(num)){\n\t\t\t\tint count = res.get(num) + 1;\n\t\t\t\tres.put(num, count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres.put(num, 1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\telse if(c == '('){\n\t\t\t//System.out.println(\"pos= \" + pos);\n\t\t\tTreeMap<Integer, Integer> right = fact();\n\t\t\tpos++;\n\t\t\tTreeMap<Integer, Integer> left = fact();\n\t\t\tpos++;\n\t\t\t//System.out.println(\"test1 = \" +right.toString() + \" \" + left.toString());\n\t\t\t//calc\n\t\t\tfor(int r: right.keySet()){\n\t\t\t\tfor(int l: left.keySet()){\n\t\t\t\t\tfor(int i=0; i < 3; i++){\n\t\t\t\t\t\tint res2 = -1;\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tres2 = r & l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tres2 = r | l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tres2 = r ^ l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(res2 != -1){\n\t\t\t\t\t\t\tif(res.containsKey(res2)){\n\t\t\t\t\t\t\t\tint count = res.get(res2) + 1;\n\t\t\t\t\t\t\t\tres.put(res2, count);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tres.put(res2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tstr = sc.nextLine();\n\t\t\tif(str.equals(\"END\")) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tdata = new int[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint temp = sc.nextInt();\n\t\t\t\t\tnum = num * 2 + temp;\n\t\t\t\t}\n\t\t\t\tdata[i] = num;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\t\tres = fact();\n\t\t\tint lastind = res.lastKey();\n\t\t\t//System.out.println(res.toString());\n\t\t\tSystem.out.println(res.get(lastind));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static interface Expr{\n\t  \tpublic int eval(int[] bits, int[] types);\n\t}\n\t\n\tpublic static final int AND = 0;\n\tpublic static final int OR  = 1;\n\tpublic static final int SUB = 2;\n\t\n\tpublic static class Node implements Expr{\n\t\tint number;\n\t\tExpr left, right;\n\t\t\n\t\tpublic Node(int n, Expr l, Expr r){\n\t\t\tnumber = n;\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\t\t\n\t\tpublic int eval(int[] bits, int[] types){\n\t\t\tif(types[number] == AND){\n\t\t\t\t//System.out.println(\"And : \" + (Integer.toBinaryString(left.eval(bits, types) & right.eval(bits, types))));\n\t\t\t\treturn left.eval(bits, types) & right.eval(bits, types);\n\t\t\t}else if(types[number] == OR){\n\t\t\t\t//System.out.println(\"Or : \" + (Integer.toBinaryString(left.eval(bits, types) | right.eval(bits, types))));\n\t\t\t\treturn left.eval(bits, types) | right.eval(bits, types);\n\t\t\t}else if(types[number] == SUB){\n\t\t\t\treturn left.eval(bits, types) ^ right.eval(bits, types);\n\t\t\t}else{\n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Var implements Expr{\n\t\tint number;\n\t\t\n\t\tpublic Var(int n){\n\t\t\tnumber = n;\n\t\t}\n\t\t\n\t\tpublic int eval(int[] bits, int[] types){\n\t\t\treturn bits[number];\n\t\t}\n\t}\n\t\n\t\n\tpublic static int node_number = 0;\n\tpublic static Expr parse(char[] input, int start, int end){\n\t\tif(input[start] == '('){\n\t\t\tint kakko_lv = 1;\n\t\t\tint kakko_end = -1;\n\t\t\tint space_pos = -1;\n\t\t\t\n\t\t\tfor(int pos = start + 1; pos <= end; pos++){\n\t\t\t\tif(input[pos] == '('){\n\t\t\t\t\tkakko_lv++;\n\t\t\t\t}else if(input[pos] == ')'){\n\t\t\t\t\tkakko_lv--;\n\t\t\t\t\tif(kakko_lv == 0){\n\t\t\t\t\t\tkakko_end = pos;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if(kakko_lv == 1 && input[pos] == ' '){\n\t\t\t\t\tspace_pos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode_number++;\n\t\t\treturn new Node(node_number - 1, parse(input, start + 1, space_pos - 1), parse(input, space_pos + 1, kakko_end - 1));\n\t\t}else{\n\t\t\treturn new Var((int)(input[start] - '0') - 1);\n\t\t}\n\t}\n\t\n\tpublic static int dps(int nodes, int n, int deep, int[] bits, int[] types, Expr expr){\n\t\tif(nodes <= deep){\n\t\t\tint ret = expr.eval(bits, types);\n\t\t\t//System.out.println(Arrays.toString(types));\n\t\t\tif(ret == (1 << 4) - 1){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}else{\n\t\t\tint ret = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttypes[deep] = i;\n\t\t\t\t//System.out.println(deep + \" \" + i);\n\t\t\t\tret += dps(nodes, n, deep + 1, bits, types, expr);\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tnode_number = 0;\n\t\t\t\n\t\t\tString input = sc.nextLine();\n\t\t\tif(input.equals(\"END\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(sc.nextLine());\n\t\t\t\n\t\t\tint bits[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString[] inputs = sc.nextLine().split(\" \");\n\t\t\t\t\n\t\t\t\tint count = 0;\n\t\t\t\tfor(String ins : inputs){\n\t\t\t\t\tint bit = Integer.parseInt(ins);\n\t\t\t\t\t\n\t\t\t\t\tbits[i] += bit << count;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tExpr expr = parse(input.toCharArray(), 0, input.length() - 1);\n\n\t\t\tint[] types = new int[node_number];\n\t\t\tSystem.out.println(dps(node_number, n, 0, bits, types, expr));\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tString line = br.readLine();\n\t\t\t\tif(line.equals(\"END\")) break;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\t\n\t\t\t\tint[] l = new int[n+1];\n\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tString line2 = br.readLine().replaceAll(\" \",\"\");\n\t\t\t\t\tl[i] = Integer.parseInt(line2,2);\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\tNode t = makeTree(line,0,l);\n\t\t\t\t//t.output();\n\t\t\t\t\n\t\t\t\tint ans = 0;\n\t\t\t\tt = check(t,l);\n\t\t\t\tfor(int c : t.cand){\n\t\t\t\t\tif(c==15) ans++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t}\n\t\n\tstatic class Node{\n\t\tint v;\n\t\tint level;\n\t\tNode left,right;\n\t\tArrayList<Integer> cand;\n\t\t\n\t\tpublic Node(int d){\n\t\t\tthis.v = 0;\n\t\t\tthis.level = d;\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.cand = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tpublic void output(){\n\t\t\tif(this.v!=0){\n\t\t\t\tSystem.out.print(this.v);\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"(\");\n\t\t\t\tthis.left.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tthis.right.output();\n\t\t\t\tSystem.out.print(\")\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static Node makeTree(String s, int d, int[] l){\n\t\tNode t = new Node(d);\n\t\tif(s.length()==1){\n\t\t\tt.v = Integer.parseInt(s);\n\t\t\tt.cand.add(l[t.v]);\n\t\t\t//System.err.println(t.cand.size());\n\t\t} else {\n\t\t\tint level = 0;\n\t\t\tint index = 0;\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tif(s.charAt(index)=='('){\n\t\t\t\t\tlevel++;\n\t\t\t\t} else if(s.charAt(index)==')'){\n\t\t\t\t\tlevel--;\n\t\t\t\t} else if(s.charAt(index)==' '&&level==1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tt.left = makeTree(s.substring(1,index),d+1,l);\n\t\t\tt.right = makeTree(s.substring(index+1, s.length()-1),d+1,l);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\tpublic static Node check(Node r, int[] l){\n\t\tif(r.left==null&&r.right==null){\n\t\t\treturn r;\n\t\t}\n\t\t\n\t\t//if node r does not have grand-children\n\t\tif(r.left.left==null&&r.right.left==null){\n\t\t\tr.cand.add(r.left.cand.get(0)&r.right.cand.get(0));\n\t\t\tr.cand.add(r.left.cand.get(0)|r.right.cand.get(0));\n\t\t\tr.cand.add(r.left.cand.get(0)^r.right.cand.get(0));\n\t\t} else {//if r has grand-children\n\t\t\tr.left = check(r.left,l);\n\t\t\tr.right = check(r.right,l);\n\t\t\t//System.err.println(r.left.cand.size() + \", \" + r.right.cand.size());\n\t\t\tfor(int c1 : r.left.cand){\n\t\t\t\tfor(int c2 : r.right.cand){\n\t\t\t\t\tr.cand.add(c1&c2);\n\t\t\t\t\tr.cand.add(c1|c2);\n\t\t\t\t\tr.cand.add(c1^c2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() throws Exception {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) throws Exception {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) throws Exception {\n\t\tif (tr.v > 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tif (n == 1) {\n\t\t\tthrow new Exception(\"tr.v: \" + tr.v);\n\t\t}\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] leaf;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tString tree = sc.nextLine();\n\t\t\tif (tree.equals(\"END\")) break;\n\t\t\tint N = sc.nextInt();\n\t\t\tleaf = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tleaf[i] += (sc.nextInt() << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tNode root = new Parser(tree).parse();\n\t\t\troot.process();\n\t\t\tSystem.out.println(root.count[0xF]);\n\t\t}\n\t}\n\n\tstatic class Parser {\n\t\tString val;\n\t\tint pos = 0;\n\n\t\tParser(String tree) {\n\t\t\tthis.val = tree;\n\t\t}\n\n\t\tNode parse() {\n\t\t\tNode ret = new Node();\n\t\t\t++pos;\n\t\t\tif (val.charAt(pos) == '(') {\n\t\t\t\tret.left = parse();\n\t\t\t} else {\n\t\t\t\tint index = parseInt();\n\t\t\t\tret.left = new Node();\n\t\t\t\tret.left.count[leaf[index - 1]] = 1;\n\t\t\t}\n\t\t\t++pos;\n\t\t\tif (val.charAt(pos) == '(') {\n\t\t\t\tret.right = parse();\n\t\t\t} else {\n\t\t\t\tint index = parseInt();\n\t\t\t\tret.right = new Node();\n\t\t\t\tret.right.count[leaf[index - 1]] = 1;\n\t\t\t}\n\t\t\t++pos;\n\t\t\treturn ret;\n\t\t}\n\n\t\tint parseInt() {\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= val.charAt(pos) && val.charAt(pos) <= '9') {\n\t\t\t\tret *= 10;\n\t\t\t\tret += val.charAt(pos) - '0';\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tstatic class Node {\n\t\tNode left;\n\t\tNode right;\n\t\tint[] count = new int[16];\n\n\t\tvoid process() {\n\t\t\tif (left == null) return;\n\t\t\tleft.process();\n\t\t\tright.process();\n\t\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\t\tfor (int j = 0; j < 16; ++j) {\n\t\t\t\t\tcount[i & j] += left.count[i] * right.count[j];\n\t\t\t\t\tcount[i | j] += left.count[i] * right.count[j];\n\t\t\t\t\tcount[i ^ j] += left.count[i] * right.count[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tint [] data;\n\t\n\tprivate TreeMap<Integer, Integer> fact() {\n\t\tchar c = str.charAt(pos++);\n\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\tif(Character.isDigit(c)){\n\t\t\t//res.add(c - '0');\n\t\t\tint ind = (c - '0') - 1;\n\t\t\tint num = data[ind];\n\t\t\t//System.out.println(ind);\n\t\t\tif(res.containsKey(num)){\n\t\t\t\tint count = res.get(num) + 1;\n\t\t\t\tres.put(num, count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres.put(num, 1);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\telse if(c == '('){\n\t\t\t//System.out.println(\"pos= \" + pos);\n\t\t\tTreeMap<Integer, Integer> right = fact();\n\t\t\tpos++;\n\t\t\tTreeMap<Integer, Integer> left = fact();\n\t\t\tpos++;\n\t\t\t//System.out.println(\"test1 = \" +right.toString() + \" \" + left.toString());\n\t\t\t//calc\n\t\t\tfor(int r: right.keySet()){\n\t\t\t\tfor(int l: left.keySet()){\n\t\t\t\t\tfor(int i=0; i < 3; i++){\n\t\t\t\t\t\tint res2 = -1;\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tres2 = r & l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tres2 = r | l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tres2 = r ^ l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(res2 != -1){\n\t\t\t\t\t\t\tif(res.containsKey(res2)){\n\t\t\t\t\t\t\t\tint count = res.get(res2) + 1;\n\t\t\t\t\t\t\t\tres.put(res2, count);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tres.put(res2, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tstr = sc.nextLine();\n\t\t\tif(str.equals(\"END\")) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tdata = new int[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint temp = sc.nextInt();\n\t\t\t\t\tnum = num * 2 + temp;\n\t\t\t\t}\n\t\t\t\tdata[i] = num;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\t\tres = fact();\n\t\t\tint lastind = res.lastKey();\n\t\t\tif(lastind == 15){\n\t\t\t\tSystem.out.println(res.get(lastind));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static ArrayList<ArrayList<Integer>> g;\n\tpublic static Tree t;\n\tpublic static void main(String args[]) throws Exception{\n\t\twhile(true){\n\t\t\tString line = readLine();\n\t\t\tif(line.equals(\"END\")) return;\n\n\t\t\tTree.n = 0;\n\t\t\tt = new Tree(line);\n\t\t\tint n = readInt();\n\t\t\tTree.info = new int[n][];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tTree.info[i] = readIntMap();\n\t\t\t\n\t\t\tint[] ops = new int[Tree.n];\n\t\t\tp(dfs(ops, 0, Tree.n));\n\t\t}\n\t}\n\t\n\tpublic static int dfs(int[] ops, int d, int n){\n\t\tif(d == n){\n\t\t\tTree.ops = ops;\n\t\t\tint[] res = t.calc();\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t\tif(res[i] == 0) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tops[d] = i;\n\t\t\tcount += dfs(ops, d+1, n);\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n}\n\nclass Tree extends MyUtil{\n\tpublic static int[][] info;\n\tpublic static int[] ops;\n\tpublic static int n = 0;\n\tTree left, right;\n\tint leafnum = 0;\n\tint num = 0;\n\tTree(String str){\n\t\tint l = str.length();\n\t\t\n\t\tif(l <= 1){\n\t\t\tleafnum = parseInt(str);\n\t\t}else{\n\t\t\tnum = n++;\n\t\t\t\n\t\t\tint lv = 0, index = 0;\n\t\t\tfor(int i = 0; i < l; i++){\n\t\t\t\tchar c = str.charAt(i);\n\t\t\t\tif(c == '(') lv++;\n\t\t\t\telse if(c == ')') lv--;\n\t\t\t\telse if(c == ' ' && lv == 1) index = i;\n\t\t\t}\n\t\t\tleft = new Tree(str.substring(1, index));\n\t\t\tright = new Tree(str.substring(index+1, l-1));\n\t\t}\n\t}\n\t\n\tpublic int[] calc(){\n\t\tif(leafnum != 0) return info[leafnum-1];\n\t\tswitch(ops[num]){\n\t\tcase 0: // and;\n\t\t\treturn and(left.calc(), right.calc());\n\t\tcase 1: // or\n\t\t\treturn or(left.calc(), right.calc());\n\t\tcase 2: // xor\n\t\t\treturn xor(left.calc(), right.calc());\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static int[] and(int[] a, int[] b){\n\t\tint[] res = new int[4];\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tres[i] = a[i] & b[i];\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static int[] or(int[] a, int[] b){\n\t\tint[] res = new int[4];\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tres[i] = a[i] | b[i];\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static int[] xor(int[] a, int[] b){\n\t\tint[] res = new int[4];\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tres[i] = a[i] ^ b[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n\n\n/**\n * 整数を数え上げたりするクラス\n * new Prime(int n) でnまでエラトステネスの篩を実行。\n * @author yoshikyoto\n * @param a[i] iが素数の時true\n * @param count[i] i以下の素数の数\n */\nclass Prime{\n\tboolean[] a;\n\tint[] count;\n\tPrime(int n){\n\t\ta = new boolean[n+1];\n\t\ta[0] = false; a[1] = false;\n\t\tfor(int i = 2; i <= n; i++) a[i] = true;\n\t\t// ふるい\n\t\tfor(int i = 2; i < (n - 3) / 2; i++)\n\t\t\tif(a[i]) for(int j = 2; j * i <= n; j++)\n\t\t\t\t\ta[j * i] = false;\n\t\t\n\t\t// 数え上げ\n\t\tcount = new int[n+1];\n\t\tcount[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint gain = 0;\n\t\t\tif(a[i]) gain = 1;\n\t\t\tcount[i] = count[i-1] + gain;\n\t\t}\n\t}\n}\n\nclass AI extends ArrayList<Integer>{}\nclass SI extends Stack<Integer>{}\n\nclass HMI<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n\nclass HMSI extends HMI<String>{}\nclass Q<E> extends ArrayDeque<E>{\n\tpublic void push(E item){add(item);}\n\tpublic E pop(){return poll();}\n}\nclass QS extends Q<String>{}\nclass QI extends Q<Integer>{}\n\nclass MyUtil extends MyIO{\n\tpublic static long start_time = 0;\n\tpublic static void start(){start_time = System.currentTimeMillis();}\n\tpublic static void end(){\n\t\tif(start_time == 0) return;\n\t\tlong time = System.currentTimeMillis() - start_time;\n\t\tif(DEBUG) p(time + \"ms\");\n\t}\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){\n\t\tStringBuffer sb = new StringBuffer(s);\n\t\treturn sb.reverse().toString();\n\t}\n\tpublic static void sort(int[] a){Arrays.sort(a);}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n}\n\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static boolean DEBUG = false;\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static void p(Object o){System.out.println(o.toString());}\n\tpublic static void pr(Object o){System.out.print(o.toString());}\n\tpublic static void d(Object o){if(DEBUG)System.out.println(o.toString());}\n\tpublic static void dr(Object o){if(DEBUG)System.out.print(o.toString());}\n\tpublic static void da(Object[] o){if(DEBUG)System.out.println(Arrays.toString(o));}\n\tpublic static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(double[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(boolean[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n\nclass MyMath{\n\t/**\n\t * 弧度法の角度を入力してsinの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double sin(int r){return Math.sin(Math.toRadians(r));}\n\n\t/**\n\t * 弧度法の角度を入力してcosの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double cos(int r){return Math.cos(Math.toRadians(r));}\n\tpublic static int max(int a, int b){return Math.max(a, b);}\n\tpublic static int min(int a, int b){return Math.min(a, b);}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    // 並行な場合\n\t    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t    if(m == 0) return false;\n\t    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t    return (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    if((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t    else return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) {\n\t\tif (tr.v >= 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Node{\n\t\tNode right, left;\n\t\tint number;\n\t\tint bit;\n\t\t\n\t\tpublic Node(Node right, Node left) {\n\t\t\tsuper();\n\t\t\tthis.right = right;\n\t\t\tthis.left = left;\n\t\t}\n\t\t\n\t\tpublic Node(int number) {\n\t\t\tsuper();\n\t\t\tthis.number = number;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\tif(right == null && left == null){\n\t\t\t\treturn \"\"+number;\n\t\t\t}else{\n\t\t\t\treturn \"(\" + right.toString() + \" \" + left.toString() + \")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node make_tree(char[] input, int start, int end, Node[] array, ArrayList<Node> nodes){\t\t\n\t\tint c_start = start, c_end = end, c_level = 0;\n\t\tint sep = -1;\n\t\t\n\t\tfor(int i = start; i <= end; i++){\n\t\t\tif(input[i] == '('){\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_start = i;\n\t\t\t\t}\n\t\t\t\tc_level++;\n\t\t\t}else if(input[i] == ')'){\n\t\t\t\tc_level--;\n\t\t\t\t\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_end = i;\n\t\t\t\t}\n\t\t\t}else if(c_level == 1 && input[i] == ' '){\n\t\t\t\tsep = i;\n\t\t\t}else if(c_level == 0 && input[i] >= '0' && input[i] <= '9'){\n\t\t\t\tNode node = new Node(input[i] - '0');\n\t\t\t\tarray[input[i] - '0' - 1] = node;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t\n\t\tNode node = new Node(make_tree(input, c_start + 1, sep - 1, array, nodes), make_tree(input, sep + 1, c_end - 1, array, nodes));\n\t\tnodes.add(node);\n\t\treturn node;\n\t}\n\t\n\tpublic static int count(Node top, ArrayList<Node> nodes, int depth){\n\t\tint ret = 0;\n\t\t\n\t\tif(depth >= nodes.size()){\n\t\t\tif(ok(top) == 15){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tnodes.get(depth).bit = i;\n\t\t\t\tret += count(top, nodes, depth + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int ok(Node top){\n\t\tif(top.left == null && top.right == null){\n\t\t\treturn top.bit;\n\t\t}\n\t\t\n\t\tint bit = ok(top.left);\n\t\t\n\t\tif(top.bit == 0){\n\t\t\tbit &= ok(top.right);\n\t\t}else if(top.bit == 1){\n\t\t\tbit |= ok(top.right);\n\t\t}else if(top.bit == 2){\n\t\t\tbit ^= ok(top.right);\n\t\t}\n\t\t\n\t\t//System.out.println(bit);\n\t\t\n\t\treturn bit;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString in = sc.nextLine();\n\t\t\t\n\t\t\tif(\"END\".equals(in)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(sc.nextLine());\n\t\t\t\n\t\t\tNode[] leafs = new Node[n];\n\t\t\tArrayList<Node> nodes = new ArrayList<Node>();\n\t\t\t\n\t\t\tNode top = make_tree(in.toCharArray(), 0, in.length() - 1, leafs, nodes);\n\t\t\t//System.out.println(top);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString[] str = sc.nextLine().split(\" \");\n\t\t\t\tint bit = (Integer.parseInt(str[0]) << 3) + (Integer.parseInt(str[1]) << 2) + (Integer.parseInt(str[2]) << 1) + Integer.parseInt(str[3]);\n\t\t\t\tleafs[i].bit = bit;\n\t\t\t\t//System.out.println(Arrays.toString(str));\n\t\t\t\t//System.out.println(bit);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count(top, nodes, 0));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Midnight Teatime\npublic class Main{\n\n\tclass R{\n\t\tint id, x;\n\t\tchar ch;\n\t\tR l, r;\n\t\tboolean leaf;\n\t\tpublic R(int id, boolean leaf) {\n\t\t\tthis.id = id;\n\t\t\tthis.leaf = leaf;\n\t\t\tl = r = null;\n\t\t\tx = 0;\n\t\t}\n\t\tint get(){\n\t\t\tif(leaf)return x;\n\t\t\tif(ch=='A')return l.get()&r.get();\n\t\t\telse if(ch=='O')return l.get()|r.get();\n\t\t\telse return l.get()^r.get();\n\t\t}\n\t}\n\t\n\tint ID, c;\n\tR[] v;\n\tR root;\n\tList<R> leafs;\n\t\n\tchar[] s;\n\tint id;\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\t\n\tR exp(){\n\t\tchar ch = get();\n\t\tif(ch!='('){\n\t\t\tint x = ch-'0';\n\t\t\tR res = new R(x, true);\n\t\t\tleafs.add(res);\n\t\t\treturn res;\n\t\t}\n\t\tR res = new R(ID, false);\n\t\tv[ID++] = res;\n\t\tres.l = exp();\n\t\tget();\n\t\tres.r = exp();\n\t\tget();\n\t\treturn res;\n\t}\n\t\n\tvoid dfs(int k){\n\t\tif(k==ID){\n\t\t\tint x = root.get();\n\t\t\tif(x==15)c++;\n\t\t\treturn;\n\t\t}\n\t\tv[k].ch = 'A'; dfs(k+1);\n\t\tv[k].ch = 'O'; dfs(k+1);\n\t\tv[k].ch = 'X'; dfs(k+1);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\ts = (sc.nextLine()+\"$\").toCharArray();\n\t\t\tif(s[0]=='E')break;\n\t\t\tid = 0;\n\t\t\tv = new R[8];\n\t\t\tleafs = new ArrayList<R>();\n\t\t\tID = 0;\n\t\t\troot = exp();\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tint x = 0;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tx += sc.nextInt()<<j;\n\t\t\t\t}\n\t\t\t\tfor(R r:leafs)if(r.id==i)r.x = x;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tc = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = 0;\n\t\t\tif (n == 1) {\n\t\t\t\tset = ls[T.v];\n\t\t\t} else {\n\t\t\t\tset = check(T);\n\t\t\t}\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) {\n\t\tif (tr.v >= 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Node{\n\t\tNode right, left;\n\t\tint number;\n\t\tint bit;\n\t\t\n\t\tpublic Node(Node right, Node left) {\n\t\t\tsuper();\n\t\t\tthis.right = right;\n\t\t\tthis.left = left;\n\t\t}\n\t\t\n\t\tpublic Node(int number) {\n\t\t\tsuper();\n\t\t\tthis.number = number;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\tif(right == null && left == null){\n\t\t\t\treturn number + \"(\" + bit + \")\";\n\t\t\t}else{\n\t\t\t\treturn \"(\" + right.toString() + \" \" + left.toString() + \") (\" + bit + \")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Node make_tree(char[] input, int start, int end, Node[] array, ArrayList<Node> nodes){\t\t\n\t\tint c_start = start, c_end = end, c_level = 0;\n\t\tint sep = -1;\n\t\t\n\t\tfor(int i = start; i <= end; i++){\n\t\t\tif(input[i] == '('){\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_start = i;\n\t\t\t\t}\n\t\t\t\tc_level++;\n\t\t\t}else if(input[i] == ')'){\n\t\t\t\tc_level--;\n\t\t\t\t\n\t\t\t\tif(c_level == 0){\n\t\t\t\t\tc_end = i;\n\t\t\t\t}\n\t\t\t}else if(c_level == 1 && input[i] == ' '){\n\t\t\t\tsep = i;\n\t\t\t}else if(c_level == 0 && input[i] >= '0' && input[i] <= '9'){\n\t\t\t\tNode node = new Node(input[i] - '0');\n\t\t\t\tarray[input[i] - '0' - 1] = node;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t\n\t\tNode node = new Node(make_tree(input, c_start + 1, sep - 1, array, nodes), make_tree(input, sep + 1, c_end - 1, array, nodes));\n\t\tnodes.add(node);\n\t\treturn node;\n\t}\n\t\n\tpublic static int count(Node top, ArrayList<Node> nodes, int depth){\n\t\tint ret = 0;\n\t\t\n\t\tif(depth >= nodes.size()){\n\t\t\tif(ok(top) == 15){\n\t\t\t\t//System.out.println(nodes);\n\t\t\t\t\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tnodes.get(depth).bit = i;\n\t\t\t\tret += count(top, nodes, depth + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static int ok(Node top){\n\t\tif(top.left == null && top.right == null){\n\t\t\treturn top.bit;\n\t\t}\n\t\t\n\t\tint bit = ok(top.left);\n\t\t\n\t\tif(top.bit == 0){\n\t\t\tbit &= ok(top.right);\n\t\t}else if(top.bit == 1){\n\t\t\tbit |= ok(top.right);\n\t\t}else if(top.bit == 2){\n\t\t\tbit ^= ok(top.right);\n\t\t}\n\t\t\n\t\t//System.out.println(bit);\n\t\t\n\t\treturn bit;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString in = sc.nextLine();\n\t\t\t\n\t\t\tif(\"END\".equals(in)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(sc.nextLine());\n\t\t\t\n\t\t\tNode[] leafs = new Node[n];\n\t\t\tArrayList<Node> nodes = new ArrayList<Node>();\n\t\t\t\n\t\t\tNode top = make_tree(in.toCharArray(), 0, in.length() - 1, leafs, nodes);\n\t\t\t//System.out.println(top);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString[] str = sc.nextLine().split(\" \");\n\t\t\t\tint bit = (Integer.parseInt(str[0]) << 3) + (Integer.parseInt(str[1]) << 2) + (Integer.parseInt(str[2]) << 1) + Integer.parseInt(str[3]);\n\t\t\t\tleafs[i].bit = bit;\n\t\t\t\t//System.out.println(Arrays.toString(str));\n\t\t\t\t//System.out.println(bit);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count(top, nodes, 0));\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push((byte) 0);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == 0) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count / 3);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(line);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) > 0) {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t} else {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\tswitch ((int) exp.get(i)) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p == idx.size()) {\n\t\t\tif (answer(exp) == 15)\n\t\t\t\tcount++;\n\t\t\treturn;\n\t\t} else {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tint [] data;\n\t\n\tprivate TreeMap<Integer, Integer> fact() {\n\t\tchar c = str.charAt(pos++);\n\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\tif(Character.isDigit(c)){\n\t\t\t//res.add(c - '0');\n\t\t\tint ind = (c - '0') - 1;\n\t\t\tint num = data[ind];\n\t\t\t//System.out.println(\"ind= \"+(ind + 1));\n\t\t\tres.put(num, 1);\n\t\t\treturn res;\n\t\t}\n\t\telse if(c == '('){\n\t\t\t//System.out.println(\"pos= \" + pos);\n\t\t\tTreeMap<Integer, Integer> right = fact();\n\t\t\tpos++;\n\t\t\tTreeMap<Integer, Integer> left = fact();\n\t\t\tpos++;\n\t\t\t//System.out.println(\"test1 = \" +right.toString() + \" \" + left.toString());\n\t\t\t//calc\n\t\t\tfor(int r: right.keySet()){\n\t\t\t\tfor(int l: left.keySet()){\n\t\t\t\t\tfor(int i=0; i < 3; i++){\n\t\t\t\t\t\tint res2 = -1;\n\t\t\t\t\t\tswitch(i){\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tres2 = r & l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tres2 = r | l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tres2 = r ^ l;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(res2 != -1){\n\t\t\t\t\t\t\tint sum = right.get(r) * left.get(l);\n\t\t\t\t\t\t\tif(res.containsKey(res2)){\n\t\t\t\t\t\t\t\tint count = res.get(res2) + sum;\n\t\t\t\t\t\t\t\tres.put(res2, count);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tres.put(res2, sum);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"res= \" + res.toString() + \" r= \" + right.toString() + \" l= \" + left.toString());\n\t\t\treturn res;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tstr = sc.nextLine();\n\t\t\tif(str.equals(\"END\")) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tint n = sc.nextInt();\n\t\t\tdata = new int[n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint temp = sc.nextInt();\n\t\t\t\t\tnum = num * 2 + temp;\n\t\t\t\t}\n\t\t\t\tdata[i] = num;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tTreeMap<Integer, Integer> res = new TreeMap<Integer, Integer>();\n\t\t\tres = fact();\n\t\t\tint lastind = res.lastKey();\n\t\t\t//System.out.println(res.toString());\n\t\t\tif(lastind == 15){\n\t\t\t\tSystem.out.println(res.get(lastind));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\t\t\tString linex = line;\n\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push((byte) 0);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == 0) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(linex);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) > 0) {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t} else {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\tswitch ((int) exp.get(i)) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p < idx.size()) {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tif (p == idx.size() - 1) {\n\t\t\t\tif (answer(exp) == 15) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\t\t\tString linex = line;\n\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push((byte) 0);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == 0) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count / 3);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(linex);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) > 0) {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t} else {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\tswitch ((int) exp.get(i)) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p == idx.size()) {\n\t\t\tif (answer(exp) == 15)\n\t\t\t\tcount++;\n\t\t\treturn;\n\t\t} else {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\t// Tree := (Tree Tree) | Leaf\n\tString t;\n\tint idx;\n\tint nidx;\n\tint ls[];\n\tint n;\n\tint ps[];\n\tTree T;\n\n\tTree tree() {\n\t\tif (t.charAt(idx) >= '0' && t.charAt(idx) <= '9') {\n\t\t\tint v = t.charAt(idx) - '0';\n\t\t\tidx++;\n\t\t\treturn new Tree(v);\n\t\t}\n\t\tif (t.charAt(idx) == '(')\n\t\t\tidx++;\n\t\tTree l = tree();\n\t\tidx++;\n\t\tTree r = tree();\n\t\tif (t.charAt(idx) == ')')\n\t\t\tidx++;\n\t\treturn new Tree(l, r);\n\t}\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tt = sc.nextLine();\n\t\t\tif (t.equals(\"END\"))\n\t\t\t\tbreak;\n\t\t\tidx = 0;\n\t\t\tn = sc.nextInt();\n\t\t\tls = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tls[i] = (a << 3) + (b << 2) + (c << 1) + d;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tps = new int[n - 1];\n\t\t\tT = tree();\n\t\t\tSystem.out.println(T);\n\t\t\tSystem.out.println(solve(0));\n\t\t}\n\t}\n\n\tint solve(int k) {\n\t\tint res = 0;\n\t\tif (k == n - 1) {\n\t\t\tnidx = 0;\n\t\t\tint set = check(T);\n\t\t\tif (set == 15)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[k] = i;\n\t\t\tres += solve(k + 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint check(Tree tr) {\n\t\tif (tr.v > 0) {\n\t\t\treturn ls[tr.v - 1];\n\t\t}\n\t\tTree l = tr.l;\n\t\tTree r = tr.r;\n\t\tint res = 0;\n\t\tswitch (ps[nidx++]) {\n\t\tcase 0:\n\t\t\tres = check(l) & check(r);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres = check(l) | check(r);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres = check(l) ^ check(r);\n\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n\nclass Tree {\n\tTree l;\n\tTree r;\n\tint v;\n\n\tTree(Tree l, Tree r) {\n\t\tthis.l = l;\n\t\tthis.r = r;\n\t\tv = -1;\n\t}\n\n\tTree(int v) {\n\t\tthis.v = v;\n\t}\n\n\tpublic String toString() {\n\t\tif (v < 0) {\n\t\t\treturn \"(\" + l.toString() + \" \" + r.toString() + \")\";\n\t\t}\n\t\treturn v + \"\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\tfinal static byte dummy = -10;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\t\t\tString linex = line;\n\n\t\t\tfor (char c : line.trim().toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push(dummy);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == dummy) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(exp.toString());\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2, op;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) > 0) {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t} else {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\top = exp.get(i);\n\t\t\t\tswitch ((int) op) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p < idx.size()) {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tif (p == idx.size() - 1) {\n\t\t\t\tif (answer(exp) == 15) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tString line = br.readLine();\n\t\t\t\tif(line.equals(\"END\")) break;\n\n\n\t\t\t\tint n = Integer.parseInt(br.readLine());\n\n\t\t\t\tint[] l = new int[n+1];\n\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tString line2 = br.readLine().replaceAll(\" \",\"\");\n\t\t\t\t\tl[i] = Integer.parseInt(line2,2);\n\t\t\t\t}\n\n\n\t\t\t\tNode t = makeTree(line,l);\n\t\t\t\t//t.output();\n\n\t\t\t\tint ans = 0;\n\t\t\t\tt = check(t,l);\n\t\t\t\tfor(int c : t.cand){\n\t\t\t\t\tif(c==15) ans++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} \n\t}\n\n\tstatic class Node{\n\t\tint v;\n\t\tNode left,right;\n\t\tArrayList<Integer> cand;\n\n\t\tpublic Node(){\n\t\t\tthis.v = 0;\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.cand = new ArrayList<Integer>();\n\t\t}\n\n\t\tpublic void output(){\n\t\t\tif(this.v!=0){\n\t\t\t\tSystem.out.print(this.v);\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"(\");\n\t\t\t\tthis.left.output();\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t\tthis.right.output();\n\t\t\t\tSystem.out.print(\")\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static Node makeTree(String s, int[] l){\n\t\tNode t = new Node();\n\t\tif(s.length()==1){\n\t\t\tt.v = Integer.parseInt(s);\n\t\t\tt.cand.add(l[t.v]);\n\t\t} else {\n\t\t\tint level = 0;\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(s.charAt(index)=='('){\n\t\t\t\t\tlevel++;\n\t\t\t\t} else if(s.charAt(index)==')'){\n\t\t\t\t\tlevel--;\n\t\t\t\t} else if(s.charAt(index)==' '&&level==1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tt.left = makeTree(s.substring(1,index),l);\n\t\t\tt.right = makeTree(s.substring(index+1, s.length()-1),l);\n\t\t}\n\t\treturn t;\n\t}\n\n\tpublic static Node check(Node r, int[] l){\n\t\tif(r.left==null&&r.right==null){\n\t\t\treturn r;\n\t\t}\n\n\t\tr.left = check(r.left,l);\n\t\tr.right = check(r.right,l);\n\t\tfor(int c1 : r.left.cand){\n\t\t\tfor(int c2 : r.right.cand){\n\t\t\t\tr.cand.add(c1&c2);\n\t\t\t\tr.cand.add(c1|c2);\n\t\t\t\tr.cand.add(c1^c2);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\n\n/**\n * Problem C: Midnight Teatime\n */\npublic class Main {\n\n\tstatic int count;\n\tfinal static byte dummy = -10;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"END\")) {\n\n\t\t\tStack<Byte> exp = new Stack<Byte>();\n\t\t\tStack<Byte> oper = new Stack<Byte>();\n\t\t\tString linex = line;\n\n\t\t\tfor (char c : line.trim().toCharArray()) {\n\t\t\t\tif (c == ' ') {\n\t\t\t\t\toper.push(dummy);\n\t\t\t\t} else if (c >= '1' && c <= '9') {\n\t\t\t\t\texp.push((byte) ((c - '0') * -1));\n\t\t\t\t} else if (c == ')') {\n\t\t\t\t\texp.push(oper.pop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tbyte b = stob(line = br.readLine());\n\t\t\t\tfor (int j = 0; j < exp.size(); j++) {\n\t\t\t\t\tif (exp.get(j).intValue() == i * -1) {\n\t\t\t\t\t\texp.setElementAt(Byte.valueOf(b), j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tcount = 0;\n\t\t\tArrayList<Byte> idx = new ArrayList<Byte>();\n\t\t\tfor (byte i = 0; i < exp.size(); i++) {\n\t\t\t\tif (exp.get(i).intValue() == dummy) {\n\t\t\t\t\tidx.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsolve(0, idx, exp, (byte) -1);\n\t\t\t\tsolve(0, idx, exp, (byte) -2);\n\t\t\t\tsolve(0, idx, exp, (byte) -3);\n\t\t\t\tSystem.out.println(count);\n\t\t\t} catch (EmptyStackException e) {\n\t\t\t\tSystem.err.println(exp.toString());\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic byte answer(Stack<Byte> exp) {\n\t\tStack<Byte> ans = new Stack<Byte>();\n\t\tbyte b1, b2, op;\n\t\tfor (int i = 0; i < exp.size(); i++) {\n\t\t\tif (exp.get(i) < 0) {\n\t\t\t\tb2 = ans.pop();\n\t\t\t\tb1 = ans.pop();\n\t\t\t\top = exp.get(i);\n\t\t\t\tswitch ((int) op) {\n\t\t\t\tcase -1:\n\t\t\t\t\tans.push((byte) (b1 & b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -2:\n\t\t\t\t\tans.push((byte) (b1 | b2));\n\t\t\t\t\tbreak;\n\t\t\t\tcase -3:\n\t\t\t\t\tans.push((byte) (b1 ^ b2));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tans.push(exp.get(i));\n\t\t\t}\n\t\t}\n\t\treturn (byte) ans.pop();\n\t}\n\n\tstatic byte stob(String str) {\n\t\tbyte b = 0;\n\t\tfor (int j = 0; j < 7; j += 2) {\n\t\t\tif (str.charAt(j) == '1') {\n\t\t\t\tb += 1 << j / 2;\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tstatic void solve(int p, ArrayList<Byte> idx, Stack<Byte> exp, byte op) {\n\t\tif (p < idx.size()) {\n\t\t\texp.setElementAt(Byte.valueOf(op), idx.get(p));\n\t\t\tif (p == idx.size() - 1) {\n\t\t\t\tif (answer(exp) == 15) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p + 1, idx, exp, (byte) -1);\n\t\t\tsolve(p + 1, idx, exp, (byte) -2);\n\t\t\tsolve(p + 1, idx, exp, (byte) -3);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tString s=\"\";\n\t\twhile((s=Console.ReadLine())!=null){\n\t\t\tif(s==\"END\")break;\n\t\t\tSol mySol =new Sol(s);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tchar[] cs=S.ToCharArray();\n\t\tfor(int i=0;i<cs.Length;i++){\n\t\t\tif(cs[i]>='1' && cs[i]<='9'){\n\t\t\t\tcs[i]=In[cs[i]-'0'];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tans=0;\n\t\tdfs(cs);\n\t\tConsole.WriteLine(ans);\n\t}\n\t\n\tint ans;\n\t\n\t\n\tvoid dfs(char[] cs_){\n\t\tchar[] cs=new Char[cs_.Length];\n\t\tint pibot=-1;\n\t\tfor(int i=0;i<cs.Length;i++){\n\t\t\tcs[i]=cs_[i];\n\t\t\tif(cs[i]==' ')pibot=i;\n\t\t}\n\t\n\t\tif(pibot==-1){\n\t\t\tString expr=new String(cs);\n\t\t\tString sc=ParseAndCalc(expr);\n\t\t\tif(sc==\"F\")ans++;\n\t\t\treturn;\n\t\t}\n\t\n\t\t//dfs all operator\n\t\tcs[pibot]='a';\n\t\tdfs(cs);\n\t\tcs[pibot]='o';\n\t\tdfs(cs);\n\t\tcs[pibot]='e';\n\t\tdfs(cs);\n\t\tcs[pibot]=' ';\n\t}\n\t\n\t\n\tString ParseAndCalc(String expr){\n\t\tString ret=expr;\n\t\tbool chk=true;\n\t\t\n\t\twhile(chk){\n\t\t\tchk=false;\n\t\t\tint i;\n\t\t\t//まずかっこを処理\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='('){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chk){\n\t\t\t\tint depth=1;\n\t\t\t\tint j=i;\n\t\t\t\twhile(depth!=0){\n\t\t\t\t\tj++;\n\t\t\t\t\tif(ret[j]=='(')depth++;\n\t\t\t\t\tif(ret[j]==')')depth--;\n\t\t\t\t}\n\t\t\t\tvar s=ret.Substring(i+1,j-i+1-2);\n\t\t\t\tret=ret.Substring(0,i)+ParseAndCalc(s)+ret.Substring(j+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\n\t\t\t//演算子を処理\n\t\t\tfor(i=0;i<ret.Length;i++){\n\t\t\t\tif(ret[i]=='a'||ret[i]=='o'||ret[i]=='e'){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chk){\n\t\t\t\tint l=H2I[ret[i-1]];\n\t\t\t\tint r=H2I[ret[i+1]];\n\t\n\t\t\t\tint res=0;\n\t\t\t\tif(ret[i]=='a')res=l&r;\n\t\t\t\tif(ret[i]=='o')res=l|r;\n\t\t\t\tif(ret[i]=='e')res=l^r;\n\t\t\t\t\n\t\t\t\tchar c=I2H[res];\n\t\t\t\tret=c.ToString();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t\n\t}\n\t\n\tString S;\n\tDictionary<char,int> H2I;\n\tchar[] I2H;\n\t\n\tint N;\n\tchar[] In;\n\t\n\tpublic Sol(String s){\n\t\tS=s;\n\t\t\n\t\tH2I=new Dictionary<char,int>();\n\t\tfor(char c='0';c<='9';c++){\n\t\t\tH2I.Add(c,(int)(c-'0'));\n\t\t}\n\t\tfor(char c='A';c<='F';c++){\n\t\t\tH2I.Add(c,10+(int)(c-'A'));\n\t\t}\n\t\t\n\t\tI2H=new char[16];\n\t\tfor(int i=0;i<16;i++){\n\t\t\tif(i<10)I2H[i]=(char)('0'+i);\n\t\t\tif(i>9)I2H[i]=(char)('A'+i-10);\n\t\t}\n\t\t\n\t\tN=ri();\n\t\tIn=new char[N+1];\n\t\tIn[0]='x';\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tvar d=ria();\n\t\t\tint ii=0;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tii=ii|(d[j]<<j);\n\t\t\t}\n\t\t\tIn[i]=I2H[ii];\n\t\t}\n\t\t\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n  AND, OR, XOR = (0..2).to_a\n  ALL = \"1111\".to_i(2)\n\n  def initialize(exp, sweet)\n    @size = 0\n    @root = parse(exp, sweet)\n  end\n\n  class Node\n    attr_accessor :left, :right, :value\n  end\n\n  def parse(exp, sweet)\n    node = Node.new\n    case exp.chr\n      when \"(\"\n        @size += 1\n        exp.slice!(0) # \"(\"\n        node.left = parse(exp, sweet)\n        exp.slice!(0) # \" \"\n        node.right = parse(exp, sweet)\n        exp.slice!(0) # \")\"\n      else\n        node.value = sweet[exp.slice!(0).to_i - 1]\n    end\n    node\n  end\n\n  def solve(depth = 0, operator = Array.new)\n    return (calculate(operator.dup) == ALL ? 1 : 0) if(depth == @size)\n    [AND, OR, XOR].map{|op|\n      operator[depth] = op\n      solve(depth + 1, operator)\n    }.inject(&:+)\n  end\n\n  def calculate(operator, node = @root)\n    return node.value if node.value\n    case operator.shift\n      when AND\n        calculate(operator, node.left) & calculate(operator, node.right)\n      when OR\n        calculate(operator, node.left) | calculate(operator, node.right)\n      when XOR\n        calculate(operator, node.left) ^ calculate(operator, node.right)\n    end\n  end\nend\n\nuntil (exp = gets.chomp) == \"END\"\n  p Tree.new(exp, gets.to_i.times.map{gets.delete(\" \").to_i(2)}).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n  AND, OR, XOR = (0..2).to_a\n  ALL = \"1111\".to_i(2)\n\n  def initialize(exp, sweet)\n    @size = 0\n    @root = parse(exp, sweet)\n  end\n\n  class Node\n    attr_accessor :left, :right, :value\n  end\n\n  def parse(exp, sweet)\n    node = Node.new\n    case exp.chr\n      when \"(\"\n        @size += 1\n        exp.slice!(0) # \"(\"\n        node.left = parse(exp, sweet)\n        exp.slice!(0) # \" \"\n        node.right = parse(exp, sweet)\n        exp.slice!(0) # \")\"\n      else\n        node.value = sweet[exp.slice!(0).to_i - 1]\n    end\n    node\n  end\n\n  def solve(depth = 0, operator = Array.new)\n    return (calculate(operator.dup) == ALL ? 1 : 0) if(depth == @size)\n    [AND, OR, XOR].map{|op|\n      operator[depth] = op\n      solve(depth + 1, operator)\n    }.inject(&:+)\n  end\n\n  def calculate(operator, node = @root)\n    return node.value if node.value\n    case operator.shift\n      when AND\n        calculate(operator, node.left) & calculate(operator, node.right)\n      when OR\n        calculate(operator, node.left) | calculate(operator, node.right)\n      when XOR\n        calculate(operator, node.left) ^ calculate(operator, node.right)\n    end\n  end\nend\n\nuntil (exp = gets.chomp) == \"END\"\n  p Tree.new(exp, gets.to_i.times.map{gets.delete(\" \").to_i(2)}).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n  AND, OR, XOR = (0..2).to_a\n  ALL = \"1111\".to_i(2)\n\n  def initialize(exp, sweet)\n    @size = 0\n    @root = parse(exp, sweet)\n  end\n\n  class Node\n    attr_accessor :left, :right, :value\n  end\n\n  def parse(exp, sweet)\n    node = Node.new\n    case exp.chr\n      when \"(\"\n        @size += 1\n        exp.slice!(0) # \"(\"\n        node.left = parse(exp, sweet)\n        exp.slice!(0) # \" \"\n        node.right = parse(exp, sweet)\n        exp.slice!(0) # \")\"\n      else\n        node.value = sweet[exp.slice!(0).to_i - 1]\n    end\n    node\n  end\n\n  def solve(depth = 0, operator = Array.new)\n    return (calculate(operator.dup) == ALL ? 1 : 0) if (depth == @size)\n    [AND, OR, XOR].map{|op|\n      operator[depth] = op\n      solve(depth + 1, operator)\n    }.inject(&:+)\n  end\n\n  def calculate(operator, node = @root)\n    return node.value if node.value\n    case operator.shift\n      when AND\n        calculate(operator, node.left) & calculate(operator, node.right)\n      when OR\n        calculate(operator, node.left) | calculate(operator, node.right)\n      when XOR\n        calculate(operator, node.left) ^ calculate(operator, node.right)\n    end\n  end\nend\n\nuntil (exp = gets.chomp) == \"END\"\n  p Tree.new(exp, gets.to_i.times.map{gets.delete(\" \").to_i(2)}).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n  AND, OR, XOR = (0..2).to_a\n  ALL = \"1111\".to_i(2)\n\n  def initialize(exp, sweet)\n    @size = 0\n    @root = parse(exp, sweet)\n  end\n\n  class Node\n    attr_accessor :left, :right, :value\n  end\n\n  def parse(exp, sweet)\n    node = Node.new\n    case exp.chr\n      when \"(\"\n        @size += 1\n        exp.slice!(0) # \"(\"\n        node.left = parse(exp, sweet)\n        exp.slice!(0) # \" \"\n        node.right = parse(exp, sweet)\n        exp.slice!(0) # \")\"\n      else\n        node.value = sweet[exp.slice!(0).to_i - 1]\n    end\n    node\n  end\n\n  def solve(depth = 0, operator = Array.new)\n    return (calculate(operator.dup) == ALL ? 1 : 0) if (depth == @size)\n    [AND, OR, XOR].inject(0){|sum, op|\n      operator[depth] = op\n      sum + solve(depth + 1, operator)\n    }\n  end\n\n  def calculate(operator, node = @root)\n    return node.value if node.value\n    case operator.shift\n      when AND\n        calculate(operator, node.left) & calculate(operator, node.right)\n      when OR\n        calculate(operator, node.left) | calculate(operator, node.right)\n      when XOR\n        calculate(operator, node.left) ^ calculate(operator, node.right)\n    end\n  end\nend\n\nuntil (exp = gets.chomp) == \"END\"\n  p Tree.new(exp, gets.to_i.times.map{gets.delete(\" \").to_i(2)}).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n  AND, OR, XOR = (0..2).to_a\n  ALL = \"1111\".to_i(2)\n\n  def initialize(exp, sweet)\n    @size = 0\n    @root = parse(exp, sweet)\n  end\n\n  class Node\n    attr_accessor :left, :right, :value\n    def print\n      p @value\n      return unless @left\n      p \"left\"\n      @left.print\n      p \"right\"\n      p @right.print\n    end\n  end\n\n  def parse(exp, sweet)\n    node = Node.new\n    case exp.chr\n      when \"(\"\n        @size += 1\n        exp.slice!(0) # \"(\"\n        node.left = parse(exp, sweet)\n        exp.slice!(0) # \" \"\n        node.right = parse(exp, sweet)\n        exp.slice!(0) # \")\"\n      else\n        node.value = sweet[exp.slice!(0).to_i - 1]\n    end\n    node\n  end\n\n  def solve(depth = 0, operator = Array.new)\n    return (calculate(operator.dup) == ALL ? 1 : 0) if(depth == @size)\n    [AND, OR, XOR].map{|op|\n      operator[depth] = op\n      solve(depth + 1, operator)\n    }.inject(&:+)\n  end\n\n  def calculate(operator, node = @root)\n    return node.value if node.value\n    case operator.shift\n      when AND\n        calculate(operator, node.left) & calculate(operator, node.right)\n      when OR\n        calculate(operator, node.left) | calculate(operator, node.right)\n      when XOR\n        calculate(operator, node.left) ^ calculate(operator, node.right)\n    end\n  end\nend\n\nuntil (exp = gets.chomp) == \"END\"\n  p Tree.new(exp, gets.to_i.times.map{gets.delete(\" \").to_i(2)}).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef parse_tree(ts)\n  if ts[$pos] =~ /[0-9]/\n    c = ts[$pos]\n    $pos += 1\n    return $rs[c.to_i - 1]\n  end\n\n  tr = [$nct]\n  $nct += 1\n\n  $pos += 1\n  tr << parse_tree(ts)\n  $pos += 1\n  tr << parse_tree(ts)\n  $pos += 1\n\n  tr\nend\n\ndef calc_tree(tr, ops)\n  return tr if tr.class != Array\n\n  sl = calc_tree(tr[1], ops)\n  sr = calc_tree(tr[2], ops)\n\n  case ops[tr[0]]\n  when 0\n    sl &= sr\n  when 1\n    sl |= sr\n  when 2\n    sl ^= sr\n  end\n\n  sl\nend\n\n### main\n\nmax_bits = 15\n\nloop do\n  treestr = gets.strip\n  break if treestr == 'END'\n\n  $n = gets.to_i\n  $rs = []\n\n  $n.times do\n    $rs << gets.split.join.to_i(2)\n  end\n\n  $pos = 0\n  $nct = 0\n\n  tr = parse_tree(treestr)\n  #p tr\n\n  ops = $nct.times.map{0}\n  count = 0\n\n  loop do\n    sbits = calc_tree(tr, ops)\n    count += 1 if sbits == max_bits\n\n    i = 0\n    while i < $nct\n      ops[i] += 1\n      break if ops[i] <= 2\n      ops[i] = 0\n      i += 1\n    end\n\n    break if i >= $nct\n  end\n\n  puts count\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    string s;\n    int[] bits;\n\n    bool input() {\n        s = readln.chomp;\n        if (s == \"END\") return false;\n        bits.clear;\n        int N; scanf(\"%d\\n\", &N);\n        foreach (i; 0 .. N) {\n            int bit = 0;\n            foreach (j; 0 .. 4) {\n                int x; scanf(\"%d\", &x);\n                bit |= (x << j);\n            }\n            scanf(\"\\n\");\n            bits ~= bit;\n        }\n        return true;\n    }\n\n    class Node {\n        Node left, right;\n        int bit;\n        this(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        this(int bit) {\n            this.bit = bit;\n            this.left = null;\n            this.right = null;\n        }\n        bool leaf() {\n            return left is null && right is null;\n        }\n    }\n    Node parse() {\n        int index = 0;\n        //writeln(s);\n        Node dfs() {\n            if (s[index] == '(') {\n                index++;\n                Node left = dfs;\n                assert(s[index] == ' ');\n                index++;\n                Node right = dfs;\n                assert(s[index] == ')');\n                index++;\n                return new Node(left, right);\n            } else if (isDigit(s[index])) {\n                int bit_i = s[index] - '1';\n                index++;\n                return new Node(bits[bit_i]);\n            } else {\n                assert(0);\n            }\n        }\n        return dfs;\n    }\n\n    void solve() {\n        Node root = parse;\n        const zs = \"AOX\";\n        int[] dfs(Node node) {\n            if (node.leaf) return [node.bit];\n            int[] ret;\n            int[] left = dfs(node.left),\n                  right = dfs(node.right);\n            foreach (a; left) {\n                foreach (b; right) {\n                    foreach (z; zs) {\n                        if (z == 'A') {\n                            ret ~= a & b;\n                        } else if (z == 'O') {\n                            ret ~= a | b;\n                        } else if (z == 'X') {\n                            ret ~= a ^ b;\n                        } else {\n                            assert(0);\n                        }\n                    }\n                }\n            }\n            return ret;\n        }\n        writeln(dfs(root).count(15));\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "# AOJ 1037 Midnight Teatime\n# Python3 2018.7.6 bal4u\n\ndef calc():\n\tglobal sz\n\tn = sz\n\tsz += 1\n\tif tree[0] == '(':\n\t\tdel tree[0]\n\t\tleft = calc()\n\t\tdel tree[0]\n\t\tright = calc()\n\t\tdel tree[0]\n\t\tfor i in range(16):\n\t\t\tfor j in range(16):\n\t\t\t\tk = left[i] * right[j]\n\t\t\t\tif k:\n\t\t\t\t\tbuf[n][i & j] += k\n\t\t\t\t\tbuf[n][i | j] += k\n\t\t\t\t\tbuf[n][i ^ j] += k\n\telse: buf[n][info[int(tree.pop(0))-1]] = 1\n\treturn buf[n]\n\nwhile True:\n\ttree = list(input())\n\tif tree[0] == 'E': break\n\tbuf, sz = [[0 for j in range(16)] for i in range(20)], 0\n\tinfo = [0]*10\n\tfor i in range(int(input())):\n\t\tp = list(map(int, input().split()))\n\t\tfor j in range(4):\n\t\t\tif p[j]: info[i] |= (1<<j)\n\tprint(calc()[15])\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self):\n        self.left=[0]\n        self.right=[0]\n    def createleft(self,inp,A):\n        cnt=0\n        for cn in range(len(inp)):\n            c=inp[cn]\n            if c=='(':\n                cnt+=1\n            elif c==')':\n                cnt-=1\n            elif cnt==0:\n                self.left=[A[int(c)-1]]\n            elif c==' ' and cnt==1:\n                leftnode=Node()\n                inpl=inp[1:cn]\n                inpr=inp[cn+1:len(inp)-1]\n                leftnode.createleft(inpl,A)\n                leftnode.createright(inpr,A)\n                self.left=leftnode\n        \n    def createright(self,inp,A):\n        cnt=0\n        for cn in range(len(inp)):\n            c=inp[cn]\n            if c=='(':\n                cnt+=1\n            elif c==')':\n                cnt-=1\n            elif cnt==0:\n                self.right=[A[int(c)-1]]\n            elif c==' ' and cnt==1:\n                inpl=inp[1:cn]\n                inpr=inp[cn+1:len(inp)-1]\n                root.createleft(inpl,A)\n                root.createright(inpr,A)\n    def possible(self):\n        lp=self.left\n        rp=self.right\n        if isinstance(self.left,Node):\n            lp=self.left.possible()\n        if  isinstance(self.right,Node):\n            rp=self.right.possible()\n        return [l & r for l in lp for r in rp]+[l | r for l in lp for r in rp]+[l ^ r for l in lp for r in rp]\n \n \n \nwhile(1):\n    inp=raw_input()\n    if inp=='END': break\n    n=int(raw_input())\n    A=[]\n    for i in range(n):\n        bn=int(''.join(raw_input().split()),2)\n        A.append(bn)\n    cnt=0\n    root=Node()\n    #create tree\n    cnt=0\n    for cn in range(len(inp)):\n        c=inp[cn]\n        if c=='(':\n            cnt+=1\n        elif c==')':\n            cnt-=1\n        elif c==' ' and cnt==1:\n            inpl=inp[1:cn]\n            inpr=inp[cn+1:len(inp)-1]\n            root.createleft(inpl,A)\n            root.createright(inpr,A)\n    #count\n    poss=root.possible()\n    ans=poss.count(15)\n    print ans"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self):\n        self.left=[0]\n        self.right=[0]\n    def createleft(self,inp,A):\n        cnt=0\n        for cn in range(len(inp)):\n            c=inp[cn]\n            if c=='(':\n                cnt+=1\n            elif c==')':\n                cnt-=1\n            elif cnt==0:\n                self.left=[A[int(c)-1]]\n            elif c==' ' and cnt==1:\n                leftnode=Node()\n                inpl=inp[1:cn]\n                inpr=inp[cn+1:len(inp)-1]\n                leftnode.createleft(inpl,A)\n                leftnode.createright(inpr,A)\n                self.left=leftnode\n        \n    def createright(self,inp,A):\n        cnt=0\n        for cn in range(len(inp)):\n            c=inp[cn]\n            if c=='(':\n                cnt+=1\n            elif c==')':\n                cnt-=1\n            elif cnt==0:\n                self.right=[A[int(c)-1]]\n            elif c==' ' and cnt==1:\n            \trightnode=Node()\n                inpl=inp[1:cn]\n                inpr=inp[cn+1:len(inp)-1]\n                rightnode.createleft(inpl,A)\n                rightnode.createright(inpr,A)\n                self.right=rightnode\n    def possible(self):\n        lp=self.left\n        rp=self.right\n        if isinstance(self.left,Node):\n            lp=self.left.possible()\n        if  isinstance(self.right,Node):\n            rp=self.right.possible()\n        return [l & r for l in lp for r in rp]+[l | r for l in lp for r in rp]+[l ^ r for l in lp for r in rp]\n \n \n \nwhile(1):\n    inp=raw_input()\n    if inp=='END': break\n    n=int(raw_input())\n    A=[]\n    for i in range(n):\n        bn=int(''.join(raw_input().split()),2)\n        A.append(bn)\n    cnt=0\n    root=Node()\n    #create tree\n    cnt=0\n    for cn in range(len(inp)):\n        c=inp[cn]\n        if c=='(':\n            cnt+=1\n        elif c==')':\n            cnt-=1\n        elif c==' ' and cnt==1:\n            inpl=inp[1:cn]\n            inpr=inp[cn+1:len(inp)-1]\n            root.createleft(inpl,A)\n            root.createright(inpr,A)\n    #count\n    poss=root.possible()\n    ans=poss.count(15)\n    print ans"
  }
]